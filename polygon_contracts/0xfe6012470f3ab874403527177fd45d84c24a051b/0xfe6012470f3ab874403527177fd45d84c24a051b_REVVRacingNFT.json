{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@animoca/ethereum-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {AccessControlBase} from \\\"./base/AccessControlBase.sol\\\";\\nimport {ContractOwnership} from \\\"./ContractOwnership.sol\\\";\\n\\n/// @title Access control via roles management (immutable version).\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract AccessControl is AccessControlBase, ContractOwnership {\\n\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/access/ContractOwnership.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {ContractOwnershipStorage} from \\\"./libraries/ContractOwnershipStorage.sol\\\";\\nimport {ContractOwnershipBase} from \\\"./base/ContractOwnershipBase.sol\\\";\\nimport {InterfaceDetection} from \\\"./../introspection/InterfaceDetection.sol\\\";\\n\\n/// @title ERC173 Contract Ownership Standard (immutable version).\\n/// @dev See https://eips.ethereum.org/EIPS/eip-173\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract ContractOwnership is ContractOwnershipBase, InterfaceDetection {\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n\\n    /// @notice Initializes the storage with an initial contract owner.\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC173.\\n    /// @dev Emits an {OwnershipTransferred} if `initialOwner` is not the zero address.\\n    /// @param initialOwner the initial contract owner.\\n    constructor(address initialOwner) {\\n        ContractOwnershipStorage.layout().constructorInit(initialOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/access/base/AccessControlBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {AccessControlStorage} from \\\"./../libraries/AccessControlStorage.sol\\\";\\nimport {ContractOwnershipStorage} from \\\"./../libraries/ContractOwnershipStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title Access control via roles management (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC173 (Contract Ownership standard).\\nabstract contract AccessControlBase is Context {\\n    using AccessControlStorage for AccessControlStorage.Layout;\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n\\n    /// @notice Emitted when a role is granted.\\n    /// @param role the granted role.\\n    /// @param account the account granted with the role.\\n    /// @param operator the initiator of the grant.\\n    event RoleGranted(bytes32 role, address account, address operator);\\n\\n    /// @notice Emitted when a role is revoked or renounced.\\n    /// @param role the revoked or renounced role.\\n    /// @param account the account losing the role.\\n    /// @param operator the initiator of the revocation, or identical to `account` for a renouncement.\\n    event RoleRevoked(bytes32 role, address account, address operator);\\n\\n    /// @notice Grants a role to an account.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Emits a {RoleGranted} event if the account did not previously have the role.\\n    /// @param role The role to grant.\\n    /// @param account The account to grant the role to.\\n    function grantRole(bytes32 role, address account) external {\\n        address operator = _msgSender();\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(operator);\\n        AccessControlStorage.layout().grantRole(role, account, operator);\\n    }\\n\\n    /// @notice Revokes a role from an account.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Emits a {RoleRevoked} event if the account previously had the role.\\n    /// @param role The role to revoke.\\n    /// @param account The account to revoke the role from.\\n    function revokeRole(bytes32 role, address account) external {\\n        address operator = _msgSender();\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(operator);\\n        AccessControlStorage.layout().revokeRole(role, account, operator);\\n    }\\n\\n    /// @notice Renounces a role by the sender.\\n    /// @dev Reverts if the sender does not have `role`.\\n    /// @dev Emits a {RoleRevoked} event.\\n    /// @param role The role to renounce.\\n    function renounceRole(bytes32 role) external {\\n        AccessControlStorage.layout().renounceRole(_msgSender(), role);\\n    }\\n\\n    /// @notice Retrieves whether an account has a role.\\n    /// @param role The role.\\n    /// @param account The account.\\n    /// @return whether `account` has `role`.\\n    function hasRole(bytes32 role, address account) external view returns (bool) {\\n        return AccessControlStorage.layout().hasRole(role, account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/access/base/ContractOwnershipBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC173} from \\\"./../interfaces/IERC173.sol\\\";\\nimport {ContractOwnershipStorage} from \\\"./../libraries/ContractOwnershipStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title ERC173 Contract Ownership Standard (proxiable version).\\n/// @dev See https://eips.ethereum.org/EIPS/eip-173\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC165 (Interface Detection Standard).\\nabstract contract ContractOwnershipBase is Context, IERC173 {\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n\\n    /// @inheritdoc IERC173\\n    function owner() public view virtual override returns (address) {\\n        return ContractOwnershipStorage.layout().owner();\\n    }\\n\\n    /// @inheritdoc IERC173\\n    function transferOwnership(address newOwner) public virtual override {\\n        ContractOwnershipStorage.layout().transferOwnership(_msgSender(), newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/access/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n/// @dev See https://eips.ethereum.org/EIPS/eip-173\\n/// @dev Note: the ERC-165 identifier for this interface is 0x7f5828d0\\ninterface IERC173 {\\n    /// @notice Emitted when the contract ownership changes.\\n    /// @param previousOwner the previous contract owner.\\n    /// @param newOwner the new contract owner.\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Sets the address of the new contract owner.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Emits an {OwnershipTransferred} event if `newOwner` is different from the current contract owner.\\n    /// @param newOwner The address of the new contract owner. Using the zero address means renouncing ownership.\\n    function transferOwnership(address newOwner) external;\\n\\n    /// @notice Gets the address of the contract owner.\\n    /// @return contractOwner The address of the contract owner.\\n    function owner() external view returns (address contractOwner);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/access/libraries/AccessControlStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {Bytes32} from \\\"./../../utils/libraries/Bytes32.sol\\\";\\n\\nlibrary AccessControlStorage {\\n    using Bytes32 for bytes32;\\n    using AccessControlStorage for AccessControlStorage.Layout;\\n\\n    struct Layout {\\n        mapping(bytes32 => mapping(address => bool)) roles;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.access.AccessControl.storage\\\")) - 1);\\n\\n    event RoleGranted(bytes32 role, address account, address operator);\\n    event RoleRevoked(bytes32 role, address account, address operator);\\n\\n    /// @notice Grants a role to an account.\\n    /// @dev Note: Call to this function should be properly access controlled.\\n    /// @dev Emits a {RoleGranted} event if the account did not previously have the role.\\n    /// @param role The role to grant.\\n    /// @param account The account to grant the role to.\\n    /// @param operator The account requesting the role change.\\n    function grantRole(Layout storage s, bytes32 role, address account, address operator) internal {\\n        if (!s.hasRole(role, account)) {\\n            s.roles[role][account] = true;\\n            emit RoleGranted(role, account, operator);\\n        }\\n    }\\n\\n    /// @notice Revokes a role from an account.\\n    /// @dev Note: Call to this function should be properly access controlled.\\n    /// @dev Emits a {RoleRevoked} event if the account previously had the role.\\n    /// @param role The role to revoke.\\n    /// @param account The account to revoke the role from.\\n    /// @param operator The account requesting the role change.\\n    function revokeRole(Layout storage s, bytes32 role, address account, address operator) internal {\\n        if (s.hasRole(role, account)) {\\n            s.roles[role][account] = false;\\n            emit RoleRevoked(role, account, operator);\\n        }\\n    }\\n\\n    /// @notice Renounces a role by the sender.\\n    /// @dev Reverts if `sender` does not have `role`.\\n    /// @dev Emits a {RoleRevoked} event.\\n    /// @param sender The message sender.\\n    /// @param role The role to renounce.\\n    function renounceRole(Layout storage s, address sender, bytes32 role) internal {\\n        s.enforceHasRole(role, sender);\\n        s.roles[role][sender] = false;\\n        emit RoleRevoked(role, sender, sender);\\n    }\\n\\n    /// @notice Retrieves whether an account has a role.\\n    /// @param role The role.\\n    /// @param account The account.\\n    /// @return whether `account` has `role`.\\n    function hasRole(Layout storage s, bytes32 role, address account) internal view returns (bool) {\\n        return s.roles[role][account];\\n    }\\n\\n    /// @notice Ensures that an account has a role.\\n    /// @dev Reverts if `account` does not have `role`.\\n    /// @param role The role.\\n    /// @param account The account.\\n    function enforceHasRole(Layout storage s, bytes32 role, address account) internal view {\\n        if (!s.hasRole(role, account)) {\\n            revert(string(abi.encodePacked(\\\"AccessControl: missing '\\\", role.toASCIIString(), \\\"' role\\\")));\\n        }\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/access/libraries/ContractOwnershipStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC173} from \\\"./../interfaces/IERC173.sol\\\";\\nimport {ProxyInitialization} from \\\"./../../proxy/libraries/ProxyInitialization.sol\\\";\\nimport {InterfaceDetectionStorage} from \\\"./../../introspection/libraries/InterfaceDetectionStorage.sol\\\";\\n\\nlibrary ContractOwnershipStorage {\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n    using InterfaceDetectionStorage for InterfaceDetectionStorage.Layout;\\n\\n    struct Layout {\\n        address contractOwner;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.access.ContractOwnership.storage\\\")) - 1);\\n    bytes32 internal constant PROXY_INIT_PHASE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.access.ContractOwnership.phase\\\")) - 1);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Initializes the storage with an initial contract owner (immutable version).\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC173.\\n    /// @dev Note: This function should be called ONLY in the constructor of an immutable (non-proxied) contract.\\n    /// @dev Emits an {OwnershipTransferred} if `initialOwner` is not the zero address.\\n    /// @param initialOwner The initial contract owner.\\n    function constructorInit(Layout storage s, address initialOwner) internal {\\n        if (initialOwner != address(0)) {\\n            s.contractOwner = initialOwner;\\n            emit OwnershipTransferred(address(0), initialOwner);\\n        }\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC173).interfaceId, true);\\n    }\\n\\n    /// @notice Initializes the storage with an initial contract owner (proxied version).\\n    /// @notice Sets the proxy initialization phase to `1`.\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC173.\\n    /// @dev Note: This function should be called ONLY in the init function of a proxied contract.\\n    /// @dev Reverts if the proxy initialization phase is set to `1` or above.\\n    /// @dev Emits an {OwnershipTransferred} if `initialOwner` is not the zero address.\\n    /// @param initialOwner The initial contract owner.\\n    function proxyInit(Layout storage s, address initialOwner) internal {\\n        ProxyInitialization.setPhase(PROXY_INIT_PHASE_SLOT, 1);\\n        s.constructorInit(initialOwner);\\n    }\\n\\n    /// @notice Sets the address of the new contract owner.\\n    /// @dev Reverts if `sender` is not the contract owner.\\n    /// @dev Emits an {OwnershipTransferred} event if `newOwner` is different from the current contract owner.\\n    /// @param newOwner The address of the new contract owner. Using the zero address means renouncing ownership.\\n    function transferOwnership(Layout storage s, address sender, address newOwner) internal {\\n        address previousOwner = s.contractOwner;\\n        require(sender == previousOwner, \\\"Ownership: not the owner\\\");\\n        if (previousOwner != newOwner) {\\n            s.contractOwner = newOwner;\\n            emit OwnershipTransferred(previousOwner, newOwner);\\n        }\\n    }\\n\\n    /// @notice Gets the address of the contract owner.\\n    /// @return contractOwner The address of the contract owner.\\n    function owner(Layout storage s) internal view returns (address contractOwner) {\\n        return s.contractOwner;\\n    }\\n\\n    /// @notice Ensures that an account is the contract owner.\\n    /// @dev Reverts if `account` is not the contract owner.\\n    /// @param account The account.\\n    function enforceIsContractOwner(Layout storage s, address account) internal view {\\n        require(account == s.contractOwner, \\\"Ownership: not the owner\\\");\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/introspection/InterfaceDetection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC165} from \\\"./interfaces/IERC165.sol\\\";\\nimport {InterfaceDetectionStorage} from \\\"./libraries/InterfaceDetectionStorage.sol\\\";\\n\\n/// @title ERC165 Interface Detection Standard (immutable or proxiable version).\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) or proxied implementation.\\nabstract contract InterfaceDetection is IERC165 {\\n    using InterfaceDetectionStorage for InterfaceDetectionStorage.Layout;\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\\n        return InterfaceDetectionStorage.layout().supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/introspection/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC165 Interface Detection Standard.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-165.\\n/// @dev Note: The ERC-165 identifier for this interface is 0x01ffc9a7.\\ninterface IERC165 {\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId the interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool supported);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/introspection/libraries/InterfaceDetectionStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC165} from \\\"./../interfaces/IERC165.sol\\\";\\n\\nlibrary InterfaceDetectionStorage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.core.introspection.InterfaceDetection.storage\\\")) - 1);\\n\\n    bytes4 internal constant ILLEGAL_INTERFACE_ID = 0xffffffff;\\n\\n    /// @notice Sets or unsets an ERC165 interface.\\n    /// @dev Reverts if `interfaceId` is `0xffffffff`.\\n    /// @param interfaceId the interface identifier.\\n    /// @param supported True to set the interface, false to unset it.\\n    function setSupportedInterface(Layout storage s, bytes4 interfaceId, bool supported) internal {\\n        require(interfaceId != ILLEGAL_INTERFACE_ID, \\\"InterfaceDetection: wrong value\\\");\\n        s.supportedInterfaces[interfaceId] = supported;\\n    }\\n\\n    /// @notice Returns whether this contract implements a given interface.\\n    /// @dev Note: This function call must use less than 30 000 gas.\\n    /// @param interfaceId The interface identifier to test.\\n    /// @return supported True if the interface is supported, false if `interfaceId` is `0xffffffff` or if the interface is not supported.\\n    function supportsInterface(Layout storage s, bytes4 interfaceId) internal view returns (bool supported) {\\n        if (interfaceId == ILLEGAL_INTERFACE_ID) {\\n            return false;\\n        }\\n        if (interfaceId == type(IERC165).interfaceId) {\\n            return true;\\n        }\\n        return s.supportedInterfaces[interfaceId];\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/metatx/ForwarderRegistryContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IForwarderRegistry} from \\\"./interfaces/IForwarderRegistry.sol\\\";\\nimport {IERC2771} from \\\"./interfaces/IERC2771.sol\\\";\\nimport {ForwarderRegistryContextBase} from \\\"./base/ForwarderRegistryContextBase.sol\\\";\\n\\n/// @title Meta-Transactions Forwarder Registry Context (immutable version).\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\n/// @dev Derived from https://github.com/wighawag/universal-forwarder (MIT licence)\\nabstract contract ForwarderRegistryContext is ForwarderRegistryContextBase, IERC2771 {\\n    constructor(IForwarderRegistry forwarderRegistry_) ForwarderRegistryContextBase(forwarderRegistry_) {}\\n\\n    function forwarderRegistry() external view returns (IForwarderRegistry) {\\n        return _forwarderRegistry;\\n    }\\n\\n    /// @inheritdoc IERC2771\\n    function isTrustedForwarder(address forwarder) external view virtual override returns (bool) {\\n        return forwarder == address(_forwarderRegistry);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/metatx/base/ForwarderRegistryContextBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IForwarderRegistry} from \\\"./../interfaces/IForwarderRegistry.sol\\\";\\nimport {ERC2771Calldata} from \\\"./../libraries/ERC2771Calldata.sol\\\";\\n\\n/// @title Meta-Transactions Forwarder Registry Context (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Derived from https://github.com/wighawag/universal-forwarder (MIT licence)\\nabstract contract ForwarderRegistryContextBase {\\n    IForwarderRegistry internal immutable _forwarderRegistry;\\n\\n    constructor(IForwarderRegistry forwarderRegistry) {\\n        _forwarderRegistry = forwarderRegistry;\\n    }\\n\\n    /// @notice Returns the message sender depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgSender() internal view virtual returns (address) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.sender;\\n        }\\n\\n        address sender = ERC2771Calldata.msgSender();\\n\\n        // Return the EIP-2771 calldata-appended sender address if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (msg.sender == address(_forwarderRegistry) || _forwarderRegistry.isApprovedForwarder(sender, msg.sender)) {\\n            return sender;\\n        }\\n\\n        return msg.sender;\\n    }\\n\\n    /// @notice Returns the message data depending on the ForwarderRegistry-based meta-transaction context.\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        // Optimised path in case of an EOA-initiated direct tx to the contract or a call from a contract not complying with EIP-2771\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender == tx.origin || msg.data.length < 24) {\\n            return msg.data;\\n        }\\n\\n        // Return the EIP-2771 calldata (minus the appended sender) if the message was forwarded by the ForwarderRegistry or an approved forwarder\\n        if (msg.sender == address(_forwarderRegistry) || _forwarderRegistry.isApprovedForwarder(ERC2771Calldata.msgSender(), msg.sender)) {\\n            return ERC2771Calldata.msgData();\\n        }\\n\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/metatx/interfaces/IERC2771.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title Secure Protocol for Native Meta Transactions.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2771\\ninterface IERC2771 {\\n    /// @notice Checks whether a forwarder is trusted.\\n    /// @param forwarder The forwarder to check.\\n    /// @return isTrusted True if `forwarder` is trusted, false if not.\\n    function isTrustedForwarder(address forwarder) external view returns (bool isTrusted);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/metatx/interfaces/IForwarderRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title Universal Meta-Transactions Forwarder Registry.\\n/// @dev Derived from https://github.com/wighawag/universal-forwarder (MIT licence)\\ninterface IForwarderRegistry {\\n    /// @notice Checks whether an account is as an approved meta-transaction forwarder for a sender account.\\n    /// @param sender The sender account.\\n    /// @param forwarder The forwarder account.\\n    /// @return isApproved True if `forwarder` is an approved meta-transaction forwarder for `sender`, false otherwise.\\n    function isApprovedForwarder(address sender, address forwarder) external view returns (bool isApproved);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/metatx/libraries/ERC2771Calldata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @dev Derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT licence)\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2771\\nlibrary ERC2771Calldata {\\n    /// @notice Returns the sender address appended at the end of the calldata, as specified in EIP-2771.\\n    function msgSender() internal pure returns (address sender) {\\n        assembly {\\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n        }\\n    }\\n\\n    /// @notice Returns the calldata while omitting the appended sender address, as specified in EIP-2771.\\n    function msgData() internal pure returns (bytes calldata data) {\\n        unchecked {\\n            return msg.data[:msg.data.length - 20];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/proxy/libraries/ProxyInitialization.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {StorageSlot} from \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\n/// @notice Multiple calls protection for storage-modifying proxy initialization functions.\\nlibrary ProxyInitialization {\\n    /// @notice Sets the initialization phase during a storage-modifying proxy initialization function.\\n    /// @dev Reverts if `phase` has been reached already.\\n    /// @param storageSlot the storage slot where `phase` is stored.\\n    /// @param phase the initialization phase.\\n    function setPhase(bytes32 storageSlot, uint256 phase) internal {\\n        StorageSlot.Uint256Slot storage currentVersion = StorageSlot.getUint256Slot(storageSlot);\\n        require(currentVersion.value < phase, \\\"Storage: phase reached\\\");\\n        currentVersion.value = phase;\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/security/TokenRecovery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {TokenRecoveryBase} from \\\"./base/TokenRecoveryBase.sol\\\";\\nimport {ContractOwnership} from \\\"./../access/ContractOwnership.sol\\\";\\n\\n/// @title Recovery mechanism for ETH/ERC20/ERC721 tokens accidentally sent to this contract (immutable version).\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract TokenRecovery is TokenRecoveryBase, ContractOwnership {\\n\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/security/base/TokenRecoveryBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport {IERC721} from \\\"./../../token/ERC721/interfaces/IERC721.sol\\\";\\nimport {ContractOwnershipStorage} from \\\"./../../access/libraries/ContractOwnershipStorage.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/// @title Recovery mechanism for ETH/ERC20/ERC721 tokens accidentally sent to this contract (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC173 (Contract Ownership standard).\\ncontract TokenRecoveryBase is Context {\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n    using SafeERC20 for IERC20;\\n    using Address for address payable;\\n\\n    /// @notice Extract ETH tokens which were accidentally sent to the contract to a list of accounts.\\n    /// @dev Note: While contracts can generally prevent accidental ETH transfer by implementating a reverting\\n    ///  `receive()` function, this can still be bypassed in a `selfdestruct(address)` scenario.\\n    /// @dev Warning: this function should be overriden for contracts which are supposed to hold ETH tokens\\n    ///  so that the extraction is limited to only amounts sent accidentally.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Reverts if `accounts` and `amounts` do not have the same length.\\n    /// @dev Reverts if one of the ETH transfers fails for any reason.\\n    /// @param accounts the list of accounts to transfer the tokens to.\\n    /// @param amounts the list of token amounts to transfer.\\n    function recoverETH(address payable[] calldata accounts, uint256[] calldata amounts) external virtual {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        uint256 length = accounts.length;\\n        require(length == amounts.length, \\\"Recovery: inconsistent arrays\\\");\\n        unchecked {\\n            for (uint256 i; i != length; ++i) {\\n                accounts[i].sendValue(amounts[i]);\\n            }\\n        }\\n    }\\n\\n    /// @notice Extract ERC20 tokens which were accidentally sent to the contract to a list of accounts.\\n    /// @dev Warning: this function should be overriden for contracts which are supposed to hold ERC20 tokens\\n    ///  so that the extraction is limited to only amounts sent accidentally.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Reverts if `accounts`, `tokens` and `amounts` do not have the same length.\\n    /// @dev Reverts if one of the ERC20 transfers fails for any reason.\\n    /// @param accounts the list of accounts to transfer the tokens to.\\n    /// @param tokens the list of ERC20 token addresses.\\n    /// @param amounts the list of token amounts to transfer.\\n    function recoverERC20s(address[] calldata accounts, IERC20[] calldata tokens, uint256[] calldata amounts) external virtual {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        uint256 length = accounts.length;\\n        require(length == tokens.length && length == amounts.length, \\\"Recovery: inconsistent arrays\\\");\\n        unchecked {\\n            for (uint256 i; i != length; ++i) {\\n                tokens[i].safeTransfer(accounts[i], amounts[i]);\\n            }\\n        }\\n    }\\n\\n    /// @notice Extract ERC721 tokens which were accidentally sent to the contract to a list of accounts.\\n    /// @dev Warning: this function should be overriden for contracts which are supposed to hold ERC721 tokens\\n    ///  so that the extraction is limited to only tokens sent accidentally.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Reverts if `accounts`, `contracts` and `amounts` do not have the same length.\\n    /// @dev Reverts if one of the ERC721 transfers fails for any reason.\\n    /// @param accounts the list of accounts to transfer the tokens to.\\n    /// @param contracts the list of ERC721 contract addresses.\\n    /// @param tokenIds the list of token ids to transfer.\\n    function recoverERC721s(address[] calldata accounts, IERC721[] calldata contracts, uint256[] calldata tokenIds) external virtual {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        uint256 length = accounts.length;\\n        require(length == contracts.length && length == tokenIds.length, \\\"Recovery: inconsistent arrays\\\");\\n        unchecked {\\n            for (uint256 i; i != length; ++i) {\\n                contracts[i].transferFrom(address(this), accounts[i], tokenIds[i]);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721BatchTransferWithOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {ERC721Storage} from \\\"./libraries/ERC721Storage.sol\\\";\\nimport {ERC721BatchTransferWithOperatorFiltererBase} from \\\"./base/ERC721BatchTransferWithOperatorFiltererBase.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard: optional extension: Batch Transfer with Operator Filterer (immutable version).\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract ERC721BatchTransferWithOperatorFilterer is ERC721BatchTransferWithOperatorFiltererBase {\\n    /// @notice Marks the following ERC165 interfaces(s) as supported: ERC721BatchTransfer\\n    constructor() {\\n        ERC721Storage.initERC721BatchTransfer();\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {ERC721Storage} from \\\"./libraries/ERC721Storage.sol\\\";\\nimport {ERC721BurnableBase} from \\\"./base/ERC721BurnableBase.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Burnable (immutable version).\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract ERC721Burnable is ERC721BurnableBase {\\n    /// @notice Marks the fllowing ERC165 interface(s) as supported: ERC721Burnable\\n    constructor() {\\n        ERC721Storage.initERC721Burnable();\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721Deliverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {ERC721Storage} from \\\"./libraries/ERC721Storage.sol\\\";\\nimport {ERC721DeliverableBase} from \\\"./base/ERC721DeliverableBase.sol\\\";\\nimport {AccessControl} from \\\"./../../access/AccessControl.sol\\\";\\nimport {ContractOwnership} from \\\"./../../access/ContractOwnership.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Deliverable (immutable version).\\n/// @notice ERC721Deliverable implementation where burnt tokens can be minted again.\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract ERC721Deliverable is ERC721DeliverableBase, AccessControl {\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Deliverable.\\n    constructor() {\\n        ERC721Storage.initERC721Deliverable();\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721MetadataWithBaseURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {ERC721ContractMetadataStorage} from \\\"./libraries/ERC721ContractMetadataStorage.sol\\\";\\nimport {ERC721MetadataWithBaseURIBase} from \\\"./base/ERC721MetadataWithBaseURIBase.sol\\\";\\nimport {TokenMetadataWithBaseURIStorage} from \\\"./../metadata/libraries/TokenMetadataWithBaseURIStorage.sol\\\";\\nimport {ContractOwnership} from \\\"./../../access/ContractOwnership.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Metadata (immutable version).\\n/// @notice ERC721Metadata implementation where tokenURIs are the concatenation of a base metadata URI and the token identifier (decimal).\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract ERC721MetadataWithBaseURI is ERC721MetadataWithBaseURIBase, ContractOwnership {\\n    using ERC721ContractMetadataStorage for ERC721ContractMetadataStorage.Layout;\\n    using TokenMetadataWithBaseURIStorage for TokenMetadataWithBaseURIStorage.Layout;\\n\\n    /// @notice Initializes the storage with a name and symbol.\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Metadata.\\n    /// @param tokenName The token name.\\n    /// @param tokenSymbol The token symbol.\\n    constructor(string memory tokenName, string memory tokenSymbol) {\\n        ERC721ContractMetadataStorage.layout().constructorInit(tokenName, tokenSymbol);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721Mintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {ERC721Storage} from \\\"./libraries/ERC721Storage.sol\\\";\\nimport {ERC721MintableBase} from \\\"./base/ERC721MintableBase.sol\\\";\\nimport {AccessControl} from \\\"./../../access/AccessControl.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Mintable (immutable version).\\n/// @notice ERC721Mintable implementation where burnt tokens can be minted again.\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract ERC721Mintable is ERC721MintableBase, AccessControl {\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Mintable.\\n    constructor() {\\n        ERC721Storage.initERC721Mintable();\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721WithOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IOperatorFilterRegistry} from \\\"./../royalty/interfaces/IOperatorFilterRegistry.sol\\\";\\nimport {ERC721Storage} from \\\"./libraries/ERC721Storage.sol\\\";\\nimport {OperatorFiltererStorage} from \\\"./../royalty/libraries/OperatorFiltererStorage.sol\\\";\\nimport {ERC721WithOperatorFiltererBase} from \\\"./base/ERC721WithOperatorFiltererBase.sol\\\";\\nimport {OperatorFiltererBase} from \\\"./../royalty/base/OperatorFiltererBase.sol\\\";\\nimport {ContractOwnership} from \\\"./../../access/ContractOwnership.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard with Operator Filterer (immutable version).\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract ERC721WithOperatorFilterer is ERC721WithOperatorFiltererBase, OperatorFiltererBase, ContractOwnership {\\n    using OperatorFiltererStorage for OperatorFiltererStorage.Layout;\\n\\n    /// @notice Marks the following ERC165 interfaces as supported: ERC721.\\n    /// @notice Sets the address that the contract will make OperatorFilter checks against.\\n    /// @param registry The operator filter registry address. When set to the zero address, checks will be bypassed.\\n    constructor(IOperatorFilterRegistry registry) {\\n        ERC721Storage.init();\\n        OperatorFiltererStorage.layout().constructorInit(registry);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/base/ERC721BatchTransferWithOperatorFiltererBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC721BatchTransfer} from \\\"./../interfaces/IERC721BatchTransfer.sol\\\";\\nimport {ERC721Storage} from \\\"./../libraries/ERC721Storage.sol\\\";\\nimport {OperatorFiltererStorage} from \\\"./../../royalty/libraries/OperatorFiltererStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Batch Transfer with Operator Filterer (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC721 (Non-Fungible Token Standard).\\nabstract contract ERC721BatchTransferWithOperatorFiltererBase is Context, IERC721BatchTransfer {\\n    using ERC721Storage for ERC721Storage.Layout;\\n    using OperatorFiltererStorage for OperatorFiltererStorage.Layout;\\n\\n    /// @inheritdoc IERC721BatchTransfer\\n    /// @dev Reverts with OperatorNotAllowed if the sender is not `from` and is not allowed by the operator registry.\\n    function batchTransferFrom(address from, address to, uint256[] calldata tokenIds) external virtual override {\\n        address sender = _msgSender();\\n        OperatorFiltererStorage.layout().requireAllowedOperatorForTransfer(sender, from);\\n        ERC721Storage.layout().batchTransferFrom(sender, from, to, tokenIds);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/base/ERC721BurnableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC721Burnable} from \\\"./../interfaces/IERC721Burnable.sol\\\";\\nimport {ERC721Storage} from \\\"./../libraries/ERC721Storage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Burnable (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC721 (Non-Fungible Token Standard).\\nabstract contract ERC721BurnableBase is Context, IERC721Burnable {\\n    using ERC721Storage for ERC721Storage.Layout;\\n\\n    /// @inheritdoc IERC721Burnable\\n    function burnFrom(address from, uint256 tokenId) external virtual override {\\n        ERC721Storage.layout().burnFrom(_msgSender(), from, tokenId);\\n    }\\n\\n    /// @inheritdoc IERC721Burnable\\n    function batchBurnFrom(address from, uint256[] calldata tokenIds) external virtual override {\\n        ERC721Storage.layout().batchBurnFrom(_msgSender(), from, tokenIds);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/base/ERC721DeliverableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC721Deliverable} from \\\"./../interfaces/IERC721Deliverable.sol\\\";\\nimport {ERC721Storage} from \\\"./../libraries/ERC721Storage.sol\\\";\\nimport {AccessControlStorage} from \\\"./../../../access/libraries/AccessControlStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Deliverable (proxiable version).\\n/// @notice ERC721Deliverable implementation where burnt tokens can be minted again.\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC721 (Non-Fungible Token Standard).\\n/// @dev Note: This contract requires AccessControl.\\nabstract contract ERC721DeliverableBase is Context, IERC721Deliverable {\\n    using ERC721Storage for ERC721Storage.Layout;\\n    using AccessControlStorage for AccessControlStorage.Layout;\\n\\n    // prevent variable name clash with public ERC721MintableBase.MINTER_ROLE\\n    bytes32 private constant _MINTER_ROLE = \\\"minter\\\";\\n\\n    /// @inheritdoc IERC721Deliverable\\n    /// @dev Reverts if the sender does not have the 'minter' role.\\n    function deliver(address[] calldata recipients, uint256[] calldata tokenIds) external virtual override {\\n        AccessControlStorage.layout().enforceHasRole(_MINTER_ROLE, _msgSender());\\n        ERC721Storage.layout().deliver(recipients, tokenIds);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/base/ERC721MetadataWithBaseURIBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC721Metadata} from \\\"./../interfaces/IERC721Metadata.sol\\\";\\nimport {ERC721Storage} from \\\"./../libraries/ERC721Storage.sol\\\";\\nimport {ERC721ContractMetadataStorage} from \\\"./../libraries/ERC721ContractMetadataStorage.sol\\\";\\nimport {TokenMetadataWithBaseURIStorage} from \\\"./../../metadata/libraries/TokenMetadataWithBaseURIStorage.sol\\\";\\nimport {ContractOwnershipStorage} from \\\"./../../../access/libraries/ContractOwnershipStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard (proxiable version), optional extension: Metadata (proxiable version).\\n/// @notice ERC721Metadata implementation where tokenURIs are the concatenation of a base metadata URI and the token identifier (decimal).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC721 (Non-Fungible Token Standard).\\n/// @dev Note: This contract requires ERC173 (Contract Ownership standard).\\nabstract contract ERC721MetadataWithBaseURIBase is Context, IERC721Metadata {\\n    using ERC721Storage for ERC721Storage.Layout;\\n    using ERC721ContractMetadataStorage for ERC721ContractMetadataStorage.Layout;\\n    using TokenMetadataWithBaseURIStorage for TokenMetadataWithBaseURIStorage.Layout;\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n\\n    /// @notice Emitted when the base token metadata URI is updated.\\n    /// @param baseMetadataURI The new base metadata URI.\\n    event BaseMetadataURISet(string baseMetadataURI);\\n\\n    /// @notice Sets the base metadata URI.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Emits a {BaseMetadataURISet} event.\\n    /// @param baseURI The base metadata URI.\\n    function setBaseMetadataURI(string calldata baseURI) external {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        TokenMetadataWithBaseURIStorage.layout().setBaseMetadataURI(baseURI);\\n    }\\n\\n    /// @notice Gets the base metadata URI.\\n    /// @return baseURI The base metadata URI.\\n    function baseMetadataURI() external view returns (string memory baseURI) {\\n        return TokenMetadataWithBaseURIStorage.layout().baseMetadataURI();\\n    }\\n\\n    /// @inheritdoc IERC721Metadata\\n    function name() external view override returns (string memory tokenName) {\\n        return ERC721ContractMetadataStorage.layout().name();\\n    }\\n\\n    /// @inheritdoc IERC721Metadata\\n    function symbol() external view override returns (string memory tokenSymbol) {\\n        return ERC721ContractMetadataStorage.layout().symbol();\\n    }\\n\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(uint256 tokenId) external view override returns (string memory uri) {\\n        ERC721Storage.layout().ownerOf(tokenId); // reverts if the token does not exist\\n        return TokenMetadataWithBaseURIStorage.layout().tokenMetadataURI(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/base/ERC721MintableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC721Mintable} from \\\"./../interfaces/IERC721Mintable.sol\\\";\\nimport {ERC721Storage} from \\\"./../libraries/ERC721Storage.sol\\\";\\nimport {AccessControlStorage} from \\\"./../../../access/libraries/AccessControlStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Mintable (proxiable version).\\n/// @notice ERC721Mintable implementation where burnt tokens can be minted again.\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC721 (Non-Fungible Token Standard).\\n/// @dev Note: This contract requires AccessControl.\\nabstract contract ERC721MintableBase is Context, IERC721Mintable {\\n    using ERC721Storage for ERC721Storage.Layout;\\n    using AccessControlStorage for AccessControlStorage.Layout;\\n\\n    bytes32 public constant MINTER_ROLE = \\\"minter\\\";\\n\\n    /// @inheritdoc IERC721Mintable\\n    /// @dev Reverts if the sender does not have the 'minter' role.\\n    function mint(address to, uint256 tokenId) external virtual override {\\n        AccessControlStorage.layout().enforceHasRole(MINTER_ROLE, _msgSender());\\n        ERC721Storage.layout().mint(to, tokenId);\\n    }\\n\\n    /// @inheritdoc IERC721Mintable\\n    /// @dev Reverts if the sender does not have the 'minter' role.\\n    function safeMint(address to, uint256 tokenId, bytes calldata data) external virtual override {\\n        AccessControlStorage.layout().enforceHasRole(MINTER_ROLE, _msgSender());\\n        ERC721Storage.layout().safeMint(_msgSender(), to, tokenId, data);\\n    }\\n\\n    /// @inheritdoc IERC721Mintable\\n    /// @dev Reverts if the sender does not have the 'minter' role.\\n    function batchMint(address to, uint256[] calldata tokenIds) external virtual override {\\n        AccessControlStorage.layout().enforceHasRole(MINTER_ROLE, _msgSender());\\n        ERC721Storage.layout().batchMint(to, tokenIds);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/base/ERC721WithOperatorFiltererBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC721} from \\\"./../interfaces/IERC721.sol\\\";\\nimport {IERC721Events} from \\\"./../interfaces/IERC721Events.sol\\\";\\nimport {ERC721Storage} from \\\"./../libraries/ERC721Storage.sol\\\";\\nimport {OperatorFiltererStorage} from \\\"./../../royalty/libraries/OperatorFiltererStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title ERC721 Non-Fungible Token Standard with Operator Filterer (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC165 (Interface Detection Standard).\\n/// @dev Note: This contract requires OperatorFilterer.\\nabstract contract ERC721WithOperatorFiltererBase is Context, IERC721, IERC721Events {\\n    using ERC721Storage for ERC721Storage.Layout;\\n    using OperatorFiltererStorage for OperatorFiltererStorage.Layout;\\n\\n    /// @inheritdoc IERC721\\n    /// @dev Reverts with OperatorNotAllowed if `to` is not the zero address and is not allowed by the operator registry.\\n    function approve(address to, uint256 tokenId) external virtual override {\\n        if (to != address(0)) {\\n            OperatorFiltererStorage.layout().requireAllowedOperatorForApproval(to);\\n        }\\n        ERC721Storage.layout().approve(_msgSender(), to, tokenId);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    /// @dev Reverts with OperatorNotAllowed if `approved` is true and `operator` is not allowed by the operator registry.\\n    function setApprovalForAll(address operator, bool approved) external virtual override {\\n        if (approved) {\\n            OperatorFiltererStorage.layout().requireAllowedOperatorForApproval(operator);\\n        }\\n        ERC721Storage.layout().setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    /// @dev Reverts with OperatorNotAllowed if the sender is not `from` and is not allowed by the operator registry.\\n    function transferFrom(address from, address to, uint256 tokenId) external override {\\n        address sender = _msgSender();\\n        OperatorFiltererStorage.layout().requireAllowedOperatorForTransfer(sender, from);\\n        ERC721Storage.layout().transferFrom(sender, from, to, tokenId);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    /// @dev Reverts with OperatorNotAllowed if the sender is not `from` and is not allowed by the operator registry.\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external virtual override {\\n        address sender = _msgSender();\\n        OperatorFiltererStorage.layout().requireAllowedOperatorForTransfer(sender, from);\\n        ERC721Storage.layout().safeTransferFrom(sender, from, to, tokenId);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    /// @dev Reverts with OperatorNotAllowed if the sender is not `from` and is not allowed by the operator registry.\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external virtual override {\\n        address sender = _msgSender();\\n        OperatorFiltererStorage.layout().requireAllowedOperatorForTransfer(sender, from);\\n        ERC721Storage.layout().safeTransferFrom(sender, from, to, tokenId, data);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view override returns (uint256 balance) {\\n        return ERC721Storage.layout().balanceOf(owner);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view override returns (address tokenOwner) {\\n        return ERC721Storage.layout().ownerOf(tokenId);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function getApproved(uint256 tokenId) external view override returns (address approved) {\\n        return ERC721Storage.layout().getApproved(tokenId);\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function isApprovedForAll(address owner, address operator) external view override returns (bool approvedForAll) {\\n        return ERC721Storage.layout().isApprovedForAll(owner, operator);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC721 Non-Fungible Token Standard, basic interface (functions).\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev This interface only contains the standard functions. See IERC721Events for the events.\\n/// @dev Note: The ERC-165 identifier for this interface is 0x80ac58cd.\\ninterface IERC721 {\\n    /// @notice Sets or unsets an approval to transfer a single token on behalf of its owner.\\n    /// @dev Note: There can only be one approved address per token at a given time.\\n    /// @dev Note: A token approval gets reset when this token is transferred, including a self-transfer.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @dev Reverts if `to` is the token owner.\\n    /// @dev Reverts if the sender is not the token owner and has not been approved by the token owner.\\n    /// @dev Emits an {Approval} event.\\n    /// @param to The address to approve, or the zero address to remove any existing approval.\\n    /// @param tokenId The token identifier to give approval for.\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /// @notice Sets or unsets an approval to transfer all tokens on behalf of their owner.\\n    /// @dev Reverts if the sender is the same as `operator`.\\n    /// @dev Emits an {ApprovalForAll} event.\\n    /// @param operator The address to approve for all tokens.\\n    /// @param approved True to set an approval for all tokens, false to unset it.\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /// @notice Unsafely transfers the ownership of a token to a recipient.\\n    /// @dev Note: Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer. Self-transfers are possible.\\n    /// @param tokenId The identifier of the token to transfer.\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @notice Safely transfers the ownership of a token to a recipient.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /// @notice Safely transfers the ownership of a token to a recipient.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    /// @param data Optional data to send along to a receiver contract.\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /// @notice Gets the balance of an address.\\n    /// @dev Reverts if `owner` is the zero address.\\n    /// @param owner The address to query the balance of.\\n    /// @return balance The amount owned by the owner.\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /// @notice Gets the owner of a token.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @param tokenId The token identifier to query the owner of.\\n    /// @return tokenOwner The owner of the token identifier.\\n    function ownerOf(uint256 tokenId) external view returns (address tokenOwner);\\n\\n    /// @notice Gets the approved address for a token.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @param tokenId The token identifier to query the approval of.\\n    /// @return approved The approved address for the token identifier, or the zero address if no approval is set.\\n    function getApproved(uint256 tokenId) external view returns (address approved);\\n\\n    /// @notice Gets whether an operator is approved for all tokens by an owner.\\n    /// @param owner The address which gives the approval for all tokens.\\n    /// @param operator The address which receives the approval for all tokens.\\n    /// @return approvedForAll Whether the operator is approved for all tokens by the owner.\\n    function isApprovedForAll(address owner, address operator) external view returns (bool approvedForAll);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/interfaces/IERC721BatchTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Batch Transfer.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0xf3993d11.\\ninterface IERC721BatchTransfer {\\n    /// @notice Unsafely transfers a batch of tokens to a recipient.\\n    /// @dev Resets the token approval for each of `tokenIds`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` is not owned by `from`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for each of `tokenIds`.\\n    /// @dev Emits an {IERC721-Transfer} event for each of `tokenIds`.\\n    /// @param from Current tokens owner.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenIds Identifiers of the tokens to transfer.\\n    function batchTransferFrom(address from, address to, uint256[] calldata tokenIds) external;\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/interfaces/IERC721Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Burnable.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x8b8b4ef5.\\ninterface IERC721Burnable {\\n    /// @notice Burns a token.\\n    /// @dev Reverts if `tokenId` is not owned by `from`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Emits an {IERC721-Transfer} event with `to` set to the zero address.\\n    /// @param from The current token owner.\\n    /// @param tokenId The identifier of the token to burn.\\n    function burnFrom(address from, uint256 tokenId) external;\\n\\n    /// @notice Burns a batch of tokens.\\n    /// @dev Reverts if one of `tokenIds` is not owned by `from`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for each of `tokenIds`.\\n    /// @dev Emits an {IERC721-Transfer} event with `to` set to the zero address for each of `tokenIds`.\\n    /// @param from The current tokens owner.\\n    /// @param tokenIds The identifiers of the tokens to burn.\\n    function batchBurnFrom(address from, uint256[] calldata tokenIds) external;\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/interfaces/IERC721Deliverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Deliverable.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x9da5e832.\\ninterface IERC721Deliverable {\\n    /// @notice Unsafely mints tokens to multiple recipients.\\n    /// @dev Reverts if `recipients` and `tokenIds` have different lengths.\\n    /// @dev Reverts if one of `recipients` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` already exists.\\n    /// @dev Emits an {IERC721-Transfer} event from the zero address for each of `recipients` and `tokenIds`.\\n    /// @param recipients Addresses of the new tokens owners.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function deliver(address[] calldata recipients, uint256[] calldata tokenIds) external;\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/interfaces/IERC721Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC721 Non-Fungible Token Standard, basic interface (events).\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev This interface only contains the standard events, see IERC721 for the functions.\\n/// @dev Note: The ERC-165 identifier for this interface is 0x80ac58cd.\\ninterface IERC721Events {\\n    /// @notice Emitted when a token is transferred.\\n    /// @param from The previous token owner.\\n    /// @param to The new token owner.\\n    /// @param tokenId The transferred token identifier.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /// @notice Emitted when a single token approval is set.\\n    /// @param owner The token owner.\\n    /// @param approved The approved address.\\n    /// @param tokenId The approved token identifier.\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /// @notice Emitted when an approval for all tokens is set or unset.\\n    /// @param owner The tokens owner.\\n    /// @param operator The approved address.\\n    /// @param approved True when then approval is set, false when it is unset.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/interfaces/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Metadata.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x5b5e139f.\\ninterface IERC721Metadata {\\n    /// @notice Gets the name of the token. E.g. \\\"My Token\\\".\\n    /// @return tokenName The name of the token.\\n    function name() external view returns (string memory tokenName);\\n\\n    /// @notice Gets the symbol of the token. E.g. \\\"TOK\\\".\\n    /// @return tokenSymbol The symbol of the token.\\n    function symbol() external view returns (string memory tokenSymbol);\\n\\n    /// @notice Gets the metadata URI for a token identifier.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @param tokenId The token identifier.\\n    /// @return uri The metadata URI for the token identifier.\\n    function tokenURI(uint256 tokenId) external view returns (string memory uri);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/interfaces/IERC721Mintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC721 Non-Fungible Token Standard, optional extension: Mintable.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x8e773e13.\\ninterface IERC721Mintable {\\n    /// @notice Unsafely mints a token.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `tokenId` already exists.\\n    /// @dev Emits an {IERC721-Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    function mint(address to, uint256 tokenId) external;\\n\\n    /// @notice Safely mints a token.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `tokenId` already exists.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits an {IERC721-Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    /// @param data Optional data to pass along to the receiver call.\\n    function safeMint(address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /// @notice Unsafely mints a batch of tokens.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` already exists.\\n    /// @dev Emits an {IERC721-Transfer} event from the zero address for each of `tokenIds`.\\n    /// @param to Address of the new tokens owner.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function batchMint(address to, uint256[] calldata tokenIds) external;\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC721 Non-Fungible Token Standard, Tokens Receiver.\\n/// @notice Interface for supporting safe transfers from ERC721 contracts.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// @dev Note: The ERC-165 identifier for this interface is 0x150b7a02.\\ninterface IERC721Receiver {\\n    /// @notice Handles the receipt of an ERC721 token.\\n    /// @dev Note: This function is called by an ERC721 contract after a safe transfer.\\n    /// @dev Note: The ERC721 contract address is always the message sender.\\n    /// @param operator The initiator of the safe transfer.\\n    /// @param from The previous token owner.\\n    /// @param tokenId The token identifier.\\n    /// @param data Optional additional data with no specified format.\\n    /// @return magicValue `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))` (`0x150b7a02`) to accept, any other value to refuse.\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/libraries/ERC721ContractMetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC721Metadata} from \\\"./../interfaces/IERC721Metadata.sol\\\";\\nimport {ProxyInitialization} from \\\"./../../../proxy/libraries/ProxyInitialization.sol\\\";\\nimport {InterfaceDetectionStorage} from \\\"./../../../introspection/libraries/InterfaceDetectionStorage.sol\\\";\\n\\nlibrary ERC721ContractMetadataStorage {\\n    using InterfaceDetectionStorage for InterfaceDetectionStorage.Layout;\\n    using ERC721ContractMetadataStorage for ERC721ContractMetadataStorage.Layout;\\n\\n    struct Layout {\\n        string tokenName;\\n        string tokenSymbol;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.token.ERC721.ERC721ContractMetadata.storage\\\")) - 1);\\n    bytes32 internal constant PROXY_INIT_PHASE_SLOT = bytes32(uint256(keccak256(\\\"animoca.token.ERC721.ERC712ContractMetadata.phase\\\")) - 1);\\n\\n    /// @notice Initializes the storage with a name and symbol (immutable version).\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Metadata.\\n    /// @dev Note: This function should be called ONLY in the constructor of an immutable (non-proxied) contract.\\n    /// @param tokenName The token name.\\n    /// @param tokenSymbol The token symbol.\\n    function constructorInit(Layout storage s, string memory tokenName, string memory tokenSymbol) internal {\\n        s.tokenName = tokenName;\\n        s.tokenSymbol = tokenSymbol;\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721Metadata).interfaceId, true);\\n    }\\n\\n    /// @notice Initializes the storage with a name and symbol (proxied version).\\n    /// @notice Sets the proxy initialization phase to `1`.\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Metadata.\\n    /// @dev Note: This function should be called ONLY in the init function of a proxied contract.\\n    /// @dev Reverts if the proxy initialization phase is set to `1` or above.\\n    /// @param tokenName The token name.\\n    /// @param tokenSymbol The token symbol.\\n    function proxyInit(Layout storage s, string calldata tokenName, string calldata tokenSymbol) internal {\\n        ProxyInitialization.setPhase(PROXY_INIT_PHASE_SLOT, 1);\\n        s.tokenName = tokenName;\\n        s.tokenSymbol = tokenSymbol;\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721Metadata).interfaceId, true);\\n    }\\n\\n    /// @notice Gets the name of the token. E.g. \\\"My Token\\\".\\n    /// @return tokenName The name of the token.\\n    function name(Layout storage s) internal view returns (string memory tokenName) {\\n        return s.tokenName;\\n    }\\n\\n    /// @notice Gets the symbol of the token. E.g. \\\"TOK\\\".\\n    /// @return tokenSymbol The symbol of the token.\\n    function symbol(Layout storage s) internal view returns (string memory tokenSymbol) {\\n        return s.tokenSymbol;\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/ERC721/libraries/ERC721Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC721} from \\\"./../interfaces/IERC721.sol\\\";\\nimport {IERC721BatchTransfer} from \\\"./../interfaces/IERC721BatchTransfer.sol\\\";\\nimport {IERC721Mintable} from \\\"./../interfaces/IERC721Mintable.sol\\\";\\nimport {IERC721Deliverable} from \\\"./../interfaces/IERC721Deliverable.sol\\\";\\nimport {IERC721Burnable} from \\\"./../interfaces/IERC721Burnable.sol\\\";\\nimport {IERC721Receiver} from \\\"./../interfaces/IERC721Receiver.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {ProxyInitialization} from \\\"./../../../proxy/libraries/ProxyInitialization.sol\\\";\\nimport {InterfaceDetectionStorage} from \\\"./../../../introspection/libraries/InterfaceDetectionStorage.sol\\\";\\n\\nlibrary ERC721Storage {\\n    using Address for address;\\n    using ERC721Storage for ERC721Storage.Layout;\\n    using InterfaceDetectionStorage for InterfaceDetectionStorage.Layout;\\n\\n    struct Layout {\\n        mapping(uint256 => uint256) owners;\\n        mapping(address => uint256) balances;\\n        mapping(uint256 => address) approvals;\\n        mapping(address => mapping(address => bool)) operators;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.token.ERC721.ERC721.storage\\\")) - 1);\\n\\n    bytes4 internal constant ERC721_RECEIVED = IERC721Receiver.onERC721Received.selector;\\n\\n    // Single token approval flag\\n    // This bit is set in the owner's value to indicate that there is an approval set for this token\\n    uint256 internal constant TOKEN_APPROVAL_OWNER_FLAG = 1 << 160;\\n\\n    // Burnt token magic value\\n    // This magic number is used as the owner's value to indicate that the token has been burnt\\n    uint256 internal constant BURNT_TOKEN_OWNER_VALUE = 0xdead000000000000000000000000000000000000000000000000000000000000;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721.\\n    function init() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721BatchTransfer.\\n    function initERC721BatchTransfer() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721BatchTransfer).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Mintable.\\n    function initERC721Mintable() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721Mintable).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Deliverable.\\n    function initERC721Deliverable() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721Deliverable).interfaceId, true);\\n    }\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC721Burnable.\\n    function initERC721Burnable() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC721Burnable).interfaceId, true);\\n    }\\n\\n    /// @notice Sets or unsets an approval to transfer a single token on behalf of its owner.\\n    /// @dev Note: This function implements {ERC721-approve(address,uint256)}.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @dev Reverts if `to` is the token owner.\\n    /// @dev Reverts if `sender` is not the token owner and has not been approved by the token owner.\\n    /// @dev Emits an {Approval} event.\\n    /// @param sender The message sender.\\n    /// @param to The address to approve, or the zero address to remove any existing approval.\\n    /// @param tokenId The token identifier to give approval for.\\n    function approve(Layout storage s, address sender, address to, uint256 tokenId) internal {\\n        uint256 owner = s.owners[tokenId];\\n        require(_tokenExists(owner), \\\"ERC721: non-existing token\\\");\\n        address ownerAddress = _tokenOwner(owner);\\n        require(to != ownerAddress, \\\"ERC721: self-approval\\\");\\n        require(_isOperatable(s, ownerAddress, sender), \\\"ERC721: non-approved sender\\\");\\n        if (to == address(0)) {\\n            if (_tokenHasApproval(owner)) {\\n                // remove the approval bit if it is present\\n                s.owners[tokenId] = uint256(uint160(ownerAddress));\\n            }\\n        } else {\\n            uint256 ownerWithApprovalBit = owner | TOKEN_APPROVAL_OWNER_FLAG;\\n            if (owner != ownerWithApprovalBit) {\\n                // add the approval bit if it is not present\\n                s.owners[tokenId] = ownerWithApprovalBit;\\n            }\\n            s.approvals[tokenId] = to;\\n        }\\n        emit Approval(ownerAddress, to, tokenId);\\n    }\\n\\n    /// @notice Sets or unsets an approval to transfer all tokens on behalf of their owner.\\n    /// @dev Note: This function implements {ERC721-setApprovalForAll(address,bool)}.\\n    /// @dev Reverts if `sender` is the same as `operator`.\\n    /// @dev Emits an {ApprovalForAll} event.\\n    /// @param sender The message sender.\\n    /// @param operator The address to approve for all tokens.\\n    /// @param approved True to set an approval for all tokens, false to unset it.\\n    function setApprovalForAll(Layout storage s, address sender, address operator, bool approved) internal {\\n        require(operator != sender, \\\"ERC721: self-approval for all\\\");\\n        s.operators[sender][operator] = approved;\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /// @notice Unsafely transfers the ownership of a token to a recipient by a sender.\\n    /// @dev Note: This function implements {ERC721-transferFrom(address,address,uint256)}.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts if `sender` is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param sender The message sender.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    function transferFrom(Layout storage s, address sender, address from, address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"ERC721: transfer to address(0)\\\");\\n\\n        uint256 owner = s.owners[tokenId];\\n        require(_tokenExists(owner), \\\"ERC721: non-existing token\\\");\\n        require(_tokenOwner(owner) == from, \\\"ERC721: non-owned token\\\");\\n\\n        if (!_isOperatable(s, from, sender)) {\\n            require(_tokenHasApproval(owner) && sender == s.approvals[tokenId], \\\"ERC721: non-approved sender\\\");\\n        }\\n\\n        s.owners[tokenId] = uint256(uint160(to));\\n        if (from != to) {\\n            unchecked {\\n                // cannot underflow as balance is verified through ownership\\n                --s.balances[from];\\n                //  cannot overflow as supply cannot overflow\\n                ++s.balances[to];\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /// @notice Safely transfers the ownership of a token to a recipient by a sender.\\n    /// @dev Note: This function implements {ERC721-safeTransferFrom(address,address,uint256)}.\\n    /// @dev Warning: Since a `to` contract can run arbitrary code, developers should be aware of potential re-entrancy attacks.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts if `sender` is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param sender The message sender.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    function safeTransferFrom(Layout storage s, address sender, address from, address to, uint256 tokenId) internal {\\n        s.transferFrom(sender, from, to, tokenId);\\n        if (to.isContract()) {\\n            _callOnERC721Received(sender, from, to, tokenId, \\\"\\\");\\n        }\\n    }\\n\\n    /// @notice Safely transfers the ownership of a token to a recipient by a sender.\\n    /// @dev Note: This function implements {ERC721-safeTransferFrom(address,address,uint256,bytes)}.\\n    /// @dev Warning: Since a `to` contract can run arbitrary code, developers should be aware of potential re-entrancy attacks.\\n    /// @dev Resets the token approval for `tokenId`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `from` is not the owner of `tokenId`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event.\\n    /// @param sender The message sender.\\n    /// @param from The current token owner.\\n    /// @param to The recipient of the token transfer.\\n    /// @param tokenId The identifier of the token to transfer.\\n    /// @param data Optional data to send along to a receiver contract.\\n    function safeTransferFrom(Layout storage s, address sender, address from, address to, uint256 tokenId, bytes calldata data) internal {\\n        s.transferFrom(sender, from, to, tokenId);\\n        if (to.isContract()) {\\n            _callOnERC721Received(sender, from, to, tokenId, data);\\n        }\\n    }\\n\\n    /// @notice Unsafely transfers a batch of tokens to a recipient by a sender.\\n    /// @dev Note: This function implements {ERC721BatchTransfer-batchTransferFrom(address,address,uint256[])}.\\n    /// @dev Resets the token approval for each of `tokenIds`.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` is not owned by `from`.\\n    /// @dev Reverts if the sender is not `from` and has not been approved by `from` for each of `tokenIds`.\\n    /// @dev Emits a {Transfer} event for each of `tokenIds`.\\n    /// @param sender The message sender.\\n    /// @param from Current tokens owner.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenIds Identifiers of the tokens to transfer.\\n    function batchTransferFrom(Layout storage s, address sender, address from, address to, uint256[] calldata tokenIds) internal {\\n        require(to != address(0), \\\"ERC721: transfer to address(0)\\\");\\n        bool operatable = _isOperatable(s, from, sender);\\n\\n        uint256 length = tokenIds.length;\\n        unchecked {\\n            for (uint256 i; i != length; ++i) {\\n                uint256 tokenId = tokenIds[i];\\n                uint256 owner = s.owners[tokenId];\\n                require(_tokenExists(owner), \\\"ERC721: non-existing token\\\");\\n                require(_tokenOwner(owner) == from, \\\"ERC721: non-owned token\\\");\\n                if (!operatable) {\\n                    require(_tokenHasApproval(owner) && sender == s.approvals[tokenId], \\\"ERC721: non-approved sender\\\");\\n                }\\n                s.owners[tokenId] = uint256(uint160(to));\\n                emit Transfer(from, to, tokenId);\\n            }\\n\\n            if (from != to && length != 0) {\\n                // cannot underflow as balance is verified through ownership\\n                s.balances[from] -= length;\\n                // cannot overflow as supply cannot overflow\\n                s.balances[to] += length;\\n            }\\n        }\\n    }\\n\\n    /// @notice Unsafely mints a token.\\n    /// @dev Note: This function implements {ERC721Mintable-mint(address,uint256)}.\\n    /// @dev Note: Either `mint` or `mintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `tokenId` already exists.\\n    /// @dev Emits a {Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    function mint(Layout storage s, address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"ERC721: mint to address(0)\\\");\\n        require(!_tokenExists(s.owners[tokenId]), \\\"ERC721: existing token\\\");\\n\\n        s.owners[tokenId] = uint256(uint160(to));\\n\\n        unchecked {\\n            // cannot overflow due to the cost of minting individual tokens\\n            ++s.balances[to];\\n        }\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /// @notice Safely mints a token.\\n    /// @dev Note: This function implements {ERC721Mintable-safeMint(address,uint256,bytes)}.\\n    /// @dev Note: Either `safeMint` or `safeMintOnce` should be used in a given contract, but not both.\\n    /// @dev Warning: Since a `to` contract can run arbitrary code, developers should be aware of potential re-entrancy attacks.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `tokenId` already exists.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    /// @param data Optional data to pass along to the receiver call.\\n    function safeMint(Layout storage s, address sender, address to, uint256 tokenId, bytes memory data) internal {\\n        s.mint(to, tokenId);\\n        if (to.isContract()) {\\n            _callOnERC721Received(sender, address(0), to, tokenId, data);\\n        }\\n    }\\n\\n    /// @notice Unsafely mints a batch of tokens.\\n    /// @dev Note: This function implements {ERC721Mintable-batchMint(address,uint256[])}.\\n    /// @dev Note: Either `batchMint` or `batchMintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` already exists.\\n    /// @dev Emits a {Transfer} event from the zero address for each of `tokenIds`.\\n    /// @param to Address of the new tokens owner.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function batchMint(Layout storage s, address to, uint256[] memory tokenIds) internal {\\n        require(to != address(0), \\\"ERC721: mint to address(0)\\\");\\n\\n        uint256 length = tokenIds.length;\\n        unchecked {\\n            for (uint256 i; i != length; ++i) {\\n                uint256 tokenId = tokenIds[i];\\n                require(!_tokenExists(s.owners[tokenId]), \\\"ERC721: existing token\\\");\\n\\n                s.owners[tokenId] = uint256(uint160(to));\\n                emit Transfer(address(0), to, tokenId);\\n            }\\n\\n            s.balances[to] += length;\\n        }\\n    }\\n\\n    /// @notice Unsafely mints tokens to multiple recipients.\\n    /// @dev Note: This function implements {ERC721Deliverable-deliver(address[],uint256[])}.\\n    /// @dev Note: Either `deliver` or `deliverOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts if `recipients` and `tokenIds` have different lengths.\\n    /// @dev Reverts if one of `recipients` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` already exists.\\n    /// @dev Emits a {Transfer} event from the zero address for each of `recipients` and `tokenIds`.\\n    /// @param recipients Addresses of the new tokens owners.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function deliver(Layout storage s, address[] memory recipients, uint256[] memory tokenIds) internal {\\n        uint256 length = recipients.length;\\n        require(length == tokenIds.length, \\\"ERC721: inconsistent arrays\\\");\\n        unchecked {\\n            for (uint256 i; i != length; ++i) {\\n                s.mint(recipients[i], tokenIds[i]);\\n            }\\n        }\\n    }\\n\\n    /// @notice Unsafely mints a token once.\\n    /// @dev Note: This function implements {ERC721Mintable-mint(address,uint256)}.\\n    /// @dev Note: Either `mint` or `mintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `tokenId` already exists.\\n    /// @dev Reverts if `tokenId` has been previously burnt.\\n    /// @dev Emits a {Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    function mintOnce(Layout storage s, address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"ERC721: mint to address(0)\\\");\\n\\n        uint256 owner = s.owners[tokenId];\\n        require(!_tokenExists(owner), \\\"ERC721: existing token\\\");\\n        require(!_tokenWasBurnt(owner), \\\"ERC721: burnt token\\\");\\n\\n        s.owners[tokenId] = uint256(uint160(to));\\n\\n        unchecked {\\n            // cannot overflow due to the cost of minting individual tokens\\n            ++s.balances[to];\\n        }\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /// @notice Safely mints a token once.\\n    /// @dev Note: This function implements {ERC721Mintable-safeMint(address,uint256,bytes)}.\\n    /// @dev Note: Either `safeMint` or `safeMintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if `tokenId` already exists.\\n    /// @dev Reverts if `tokenId` has been previously burnt.\\n    /// @dev Reverts if `to` is a contract and the call to {IERC721Receiver-onERC721Received} fails, reverts or is rejected.\\n    /// @dev Emits a {Transfer} event from the zero address.\\n    /// @param to Address of the new token owner.\\n    /// @param tokenId Identifier of the token to mint.\\n    /// @param data Optional data to pass along to the receiver call.\\n    function safeMintOnce(Layout storage s, address sender, address to, uint256 tokenId, bytes memory data) internal {\\n        s.mintOnce(to, tokenId);\\n        if (to.isContract()) {\\n            _callOnERC721Received(sender, address(0), to, tokenId, data);\\n        }\\n    }\\n\\n    /// @notice Unsafely mints a batch of tokens once.\\n    /// @dev Note: This function implements {ERC721Mintable-batchMint(address,uint256[])}.\\n    /// @dev Note: Either `batchMint` or `batchMintOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts if `to` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` already exists.\\n    /// @dev Reverts if one of `tokenIds` has been previously burnt.\\n    /// @dev Emits a {Transfer} event from the zero address for each of `tokenIds`.\\n    /// @param to Address of the new tokens owner.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function batchMintOnce(Layout storage s, address to, uint256[] memory tokenIds) internal {\\n        require(to != address(0), \\\"ERC721: mint to address(0)\\\");\\n\\n        uint256 length = tokenIds.length;\\n        unchecked {\\n            for (uint256 i; i != length; ++i) {\\n                uint256 tokenId = tokenIds[i];\\n                uint256 owner = s.owners[tokenId];\\n                require(!_tokenExists(owner), \\\"ERC721: existing token\\\");\\n                require(!_tokenWasBurnt(owner), \\\"ERC721: burnt token\\\");\\n\\n                s.owners[tokenId] = uint256(uint160(to));\\n\\n                emit Transfer(address(0), to, tokenId);\\n            }\\n\\n            s.balances[to] += length;\\n        }\\n    }\\n\\n    /// @notice Unsafely mints tokens to multiple recipients once.\\n    /// @dev Note: This function implements {ERC721Deliverable-deliver(address[],uint256[])}.\\n    /// @dev Note: Either `deliver` or `deliverOnce` should be used in a given contract, but not both.\\n    /// @dev Reverts if `recipients` and `tokenIds` have different lengths.\\n    /// @dev Reverts if one of `recipients` is the zero address.\\n    /// @dev Reverts if one of `tokenIds` already exists.\\n    /// @dev Reverts if one of `tokenIds` has been previously burnt.\\n    /// @dev Emits a {Transfer} event from the zero address for each of `recipients` and `tokenIds`.\\n    /// @param recipients Addresses of the new tokens owners.\\n    /// @param tokenIds Identifiers of the tokens to mint.\\n    function deliverOnce(Layout storage s, address[] memory recipients, uint256[] memory tokenIds) internal {\\n        uint256 length = recipients.length;\\n        require(length == tokenIds.length, \\\"ERC721: inconsistent arrays\\\");\\n        unchecked {\\n            for (uint256 i; i != length; ++i) {\\n                address to = recipients[i];\\n                require(to != address(0), \\\"ERC721: mint to address(0)\\\");\\n\\n                uint256 tokenId = tokenIds[i];\\n                uint256 owner = s.owners[tokenId];\\n                require(!_tokenExists(owner), \\\"ERC721: existing token\\\");\\n                require(!_tokenWasBurnt(owner), \\\"ERC721: burnt token\\\");\\n\\n                s.owners[tokenId] = uint256(uint160(to));\\n                ++s.balances[to];\\n\\n                emit Transfer(address(0), to, tokenId);\\n            }\\n        }\\n    }\\n\\n    /// @notice Burns a token by a sender.\\n    /// @dev Note: This function implements {ERC721Burnable-burnFrom(address,uint256)}.\\n    /// @dev Reverts if `tokenId` is not owned by `from`.\\n    /// @dev Reverts if `sender` is not `from` and has not been approved by `from` for `tokenId`.\\n    /// @dev Emits a {Transfer} event with `to` set to the zero address.\\n    /// @param sender The message sender.\\n    /// @param from The current token owner.\\n    /// @param tokenId The identifier of the token to burn.\\n    function burnFrom(Layout storage s, address sender, address from, uint256 tokenId) internal {\\n        uint256 owner = s.owners[tokenId];\\n        require(from == _tokenOwner(owner), \\\"ERC721: non-owned token\\\");\\n\\n        if (!_isOperatable(s, from, sender)) {\\n            require(_tokenHasApproval(owner) && sender == s.approvals[tokenId], \\\"ERC721: non-approved sender\\\");\\n        }\\n\\n        s.owners[tokenId] = BURNT_TOKEN_OWNER_VALUE;\\n\\n        unchecked {\\n            // cannot underflow as balance is verified through TOKEN ownership\\n            --s.balances[from];\\n        }\\n        emit Transfer(from, address(0), tokenId);\\n    }\\n\\n    /// @notice Burns a batch of tokens by a sender.\\n    /// @dev Note: This function implements {ERC721Burnable-batchBurnFrom(address,uint256[])}.\\n    /// @dev Reverts if one of `tokenIds` is not owned by `from`.\\n    /// @dev Reverts if `sender` is not `from` and has not been approved by `from` for each of `tokenIds`.\\n    /// @dev Emits a {Transfer} event with `to` set to the zero address for each of `tokenIds`.\\n    /// @param sender The message sender.\\n    /// @param from The current tokens owner.\\n    /// @param tokenIds The identifiers of the tokens to burn.\\n    function batchBurnFrom(Layout storage s, address sender, address from, uint256[] calldata tokenIds) internal {\\n        bool operatable = _isOperatable(s, from, sender);\\n\\n        uint256 length = tokenIds.length;\\n        unchecked {\\n            for (uint256 i; i != length; ++i) {\\n                uint256 tokenId = tokenIds[i];\\n                uint256 owner = s.owners[tokenId];\\n                require(from == _tokenOwner(owner), \\\"ERC721: non-owned token\\\");\\n                if (!operatable) {\\n                    require(_tokenHasApproval(owner) && sender == s.approvals[tokenId], \\\"ERC721: non-approved sender\\\");\\n                }\\n                s.owners[tokenId] = BURNT_TOKEN_OWNER_VALUE;\\n                emit Transfer(from, address(0), tokenId);\\n            }\\n\\n            if (length != 0) {\\n                s.balances[from] -= length;\\n            }\\n        }\\n    }\\n\\n    /// @notice Gets the balance of an address.\\n    /// @dev Note: This function implements {ERC721-balanceOf(address)}.\\n    /// @dev Reverts if `owner` is the zero address.\\n    /// @param owner The address to query the balance of.\\n    /// @return balance The amount owned by the owner.\\n    function balanceOf(Layout storage s, address owner) internal view returns (uint256 balance) {\\n        require(owner != address(0), \\\"ERC721: balance of address(0)\\\");\\n        return s.balances[owner];\\n    }\\n\\n    /// @notice Gets the owner of a token.\\n    /// @dev Note: This function implements {ERC721-ownerOf(uint256)}.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @param tokenId The token identifier to query the owner of.\\n    /// @return tokenOwner The owner of the token.\\n    function ownerOf(Layout storage s, uint256 tokenId) internal view returns (address tokenOwner) {\\n        uint256 owner = s.owners[tokenId];\\n        require(_tokenExists(owner), \\\"ERC721: non-existing token\\\");\\n        return _tokenOwner(owner);\\n    }\\n\\n    /// @notice Gets the approved address for a token.\\n    /// @dev Note: This function implements {ERC721-getApproved(uint256)}.\\n    /// @dev Reverts if `tokenId` does not exist.\\n    /// @param tokenId The token identifier to query the approval of.\\n    /// @return approved The approved address for the token identifier, or the zero address if no approval is set.\\n    function getApproved(Layout storage s, uint256 tokenId) internal view returns (address approved) {\\n        uint256 owner = s.owners[tokenId];\\n        require(_tokenExists(owner), \\\"ERC721: non-existing token\\\");\\n        if (_tokenHasApproval(owner)) {\\n            return s.approvals[tokenId];\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    /// @notice Gets whether an operator is approved for all tokens by an owner.\\n    /// @dev Note: This function implements {ERC721-isApprovedForAll(address,address)}.\\n    /// @param owner The address which gives the approval for all tokens.\\n    /// @param operator The address which receives the approval for all tokens.\\n    /// @return approvedForAll Whether the operator is approved for all tokens by the owner.\\n    function isApprovedForAll(Layout storage s, address owner, address operator) internal view returns (bool approvedForAll) {\\n        return s.operators[owner][operator];\\n    }\\n\\n    /// @notice Gets whether a token was burnt.\\n    /// @param tokenId The token identifier.\\n    /// @return tokenWasBurnt Whether the token was burnt.\\n    function wasBurnt(Layout storage s, uint256 tokenId) internal view returns (bool tokenWasBurnt) {\\n        return _tokenWasBurnt(s.owners[tokenId]);\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n\\n    /// @notice Calls {IERC721Receiver-onERC721Received} on a target contract.\\n    /// @dev Reverts if the call to the target fails, reverts or is rejected.\\n    /// @param sender The message sender.\\n    /// @param from Previous token owner.\\n    /// @param to New token owner.\\n    /// @param tokenId Identifier of the token transferred.\\n    /// @param data Optional data to send along with the receiver contract call.\\n    function _callOnERC721Received(address sender, address from, address to, uint256 tokenId, bytes memory data) private {\\n        require(IERC721Receiver(to).onERC721Received(sender, from, tokenId, data) == ERC721_RECEIVED, \\\"ERC721: safe transfer rejected\\\");\\n    }\\n\\n    /// @notice Returns whether an account is authorised to make a transfer on behalf of an owner.\\n    /// @param owner The token owner.\\n    /// @param account The account to check the operatability of.\\n    /// @return operatable True if `account` is `owner` or is an operator for `owner`, false otherwise.\\n    function _isOperatable(Layout storage s, address owner, address account) private view returns (bool operatable) {\\n        return (owner == account) || s.operators[owner][account];\\n    }\\n\\n    function _tokenOwner(uint256 owner) private pure returns (address tokenOwner) {\\n        return address(uint160(owner));\\n    }\\n\\n    function _tokenExists(uint256 owner) private pure returns (bool tokenExists) {\\n        return uint160(owner) != 0;\\n    }\\n\\n    function _tokenWasBurnt(uint256 owner) private pure returns (bool tokenWasBurnt) {\\n        return owner == BURNT_TOKEN_OWNER_VALUE;\\n    }\\n\\n    function _tokenHasApproval(uint256 owner) private pure returns (bool tokenHasApproval) {\\n        return owner & TOKEN_APPROVAL_OWNER_FLAG != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/metadata/libraries/TokenMetadataWithBaseURIStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {ProxyInitialization} from \\\"./../../../proxy/libraries/ProxyInitialization.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary TokenMetadataWithBaseURIStorage {\\n    using TokenMetadataWithBaseURIStorage for TokenMetadataWithBaseURIStorage.Layout;\\n    using Strings for uint256;\\n\\n    struct Layout {\\n        string baseURI;\\n    }\\n\\n    bytes32 public constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.token.metadata.TokenMetadataWithBaseURI.storage\\\")) - 1);\\n\\n    event BaseMetadataURISet(string baseMetadataURI);\\n\\n    /// @notice Sets the base metadata URI.\\n    /// @dev Emits a {BaseMetadataURISet} event.\\n    /// @param baseURI The base metadata URI.\\n    function setBaseMetadataURI(Layout storage s, string calldata baseURI) internal {\\n        s.baseURI = baseURI;\\n        emit BaseMetadataURISet(baseURI);\\n    }\\n\\n    /// @notice Gets the base metadata URI.\\n    /// @return baseURI The base metadata URI.\\n    function baseMetadataURI(Layout storage s) internal view returns (string memory baseURI) {\\n        return s.baseURI;\\n    }\\n\\n    /// @notice Gets the token metadata URI for a token as the concatenation of the base metadata URI and the token identfier.\\n    /// @param id The token identifier.\\n    /// @return tokenURI The token metadata URI as the concatenation of the base metadata URI and the token identfier.\\n    function tokenMetadataURI(Layout storage s, uint256 id) internal view returns (string memory tokenURI) {\\n        return string(abi.encodePacked(s.baseURI, id.toString()));\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/royalty/ERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {ERC2981Storage} from \\\"./libraries/ERC2981Storage.sol\\\";\\nimport {ERC2981Base} from \\\"./base/ERC2981Base.sol\\\";\\nimport {ContractOwnership} from \\\"./../../access/ContractOwnership.sol\\\";\\n\\n/// @title ERC2981 NFT Royalty Standard (immutable version).\\n/// @dev This contract is to be used via inheritance in an immutable (non-proxied) implementation.\\nabstract contract ERC2981 is ERC2981Base, ContractOwnership {\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC2981.\\n    constructor() {\\n        ERC2981Storage.init();\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/royalty/base/ERC2981Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC2981} from \\\"./../interfaces/IERC2981.sol\\\";\\nimport {ERC2981Storage} from \\\"./../libraries/ERC2981Storage.sol\\\";\\nimport {ContractOwnershipStorage} from \\\"./../../../access/libraries/ContractOwnershipStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title ERC2981 NFT Royalty Standard (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC165 (Interface Detection Standard).\\n/// @dev Note: This contract requires ERC173 (Contract Ownership standard).\\nabstract contract ERC2981Base is Context, IERC2981 {\\n    using ERC2981Storage for ERC2981Storage.Layout;\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n\\n    uint256 public constant ROYALTY_FEE_DENOMINATOR = ERC2981Storage.ROYALTY_FEE_DENOMINATOR;\\n\\n    /// @notice Sets the royalty percentage.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Reverts with IncorrectRoyaltyPercentage if `percentage` is above 100% (> FEE_DENOMINATOR).\\n    /// @param percentage The new percentage to set. For example 50000 sets 50% royalty.\\n    function setRoyaltyPercentage(uint256 percentage) external {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        ERC2981Storage.layout().setRoyaltyPercentage(percentage);\\n    }\\n\\n    /// @notice Sets the royalty receiver.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @dev Reverts with IncorrectRoyaltyReceiver if `receiver` is the zero address.\\n    /// @param receiver The new receiver to set.\\n    function setRoyaltyReceiver(address receiver) external {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        ERC2981Storage.layout().setRoyaltyReceiver(receiver);\\n    }\\n\\n    /// @inheritdoc IERC2981\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount) {\\n        return ERC2981Storage.layout().royaltyInfo(tokenId, salePrice);\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/royalty/base/OperatorFiltererBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IOperatorFilterRegistry} from \\\"./../interfaces/IOperatorFilterRegistry.sol\\\";\\nimport {OperatorFiltererStorage} from \\\"./../libraries/OperatorFiltererStorage.sol\\\";\\nimport {ContractOwnershipStorage} from \\\"./../../../access/libraries/ContractOwnershipStorage.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/// @title Operator Filterer for token contracts (proxiable version).\\n/// @dev This contract is to be used via inheritance in a proxied implementation.\\n/// @dev Note: This contract requires ERC173 (Contract Ownership standard).\\nabstract contract OperatorFiltererBase is Context {\\n    using OperatorFiltererStorage for OperatorFiltererStorage.Layout;\\n    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;\\n\\n    /// @notice Updates the address that the contract will make OperatorFilter checks against.\\n    /// @dev Reverts if the sender is not the contract owner.\\n    /// @param registry The new operator filter registry address. When set to the zero address, checks will be bypassed.\\n    function updateOperatorFilterRegistry(IOperatorFilterRegistry registry) external {\\n        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());\\n        OperatorFiltererStorage.layout().updateOperatorFilterRegistry(registry);\\n    }\\n\\n    /// @notice Gets the operator filter registry address.\\n    function operatorFilterRegistry() external view returns (IOperatorFilterRegistry) {\\n        return OperatorFiltererStorage.layout().operatorFilterRegistry();\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/royalty/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n/// @title ERC2981 NFT Royalty Standard.\\n/// @dev See https://eips.ethereum.org/EIPS/eip-2981\\n/// @dev Note: The ERC-165 identifier for this interface is 0x2a55205a.\\ninterface IERC2981 {\\n    /// @notice Called with the sale price to determine how much royalty is owed and to whom.\\n    /// @param tokenId The NFT asset queried for royalty information\\n    /// @param salePrice The sale price of the NFT asset specified by `tokenId`\\n    /// @return receiver Address of who should be sent the royalty payment\\n    /// @return royaltyAmount The royalty payment amount for `salePrice`\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/royalty/interfaces/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\ninterface IOperatorFilterRegistry {\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n\\n    function register(address registrant) external;\\n\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n\\n    function unregister(address addr) external;\\n\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n\\n    function subscriptionOf(address addr) external returns (address registrant);\\n\\n    function subscribers(address registrant) external returns (address[] memory);\\n\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n\\n    function filteredOperators(address addr) external returns (address[] memory);\\n\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n\\n    function isRegistered(address addr) external returns (bool);\\n\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/royalty/libraries/ERC2981Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IERC2981} from \\\"./../interfaces/IERC2981.sol\\\";\\nimport {InterfaceDetectionStorage} from \\\"./../../../introspection/libraries/InterfaceDetectionStorage.sol\\\";\\n\\nlibrary ERC2981Storage {\\n    using ERC2981Storage for ERC2981Storage.Layout;\\n    using InterfaceDetectionStorage for InterfaceDetectionStorage.Layout;\\n\\n    struct Layout {\\n        address royaltyReceiver;\\n        uint96 royaltyPercentage;\\n    }\\n\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.token.royalty.ERC2981.storage\\\")) - 1);\\n\\n    uint256 internal constant ROYALTY_FEE_DENOMINATOR = 100000;\\n\\n    error IncorrectRoyaltyPercentage(uint256 percentage);\\n    error IncorrectRoyaltyReceiver();\\n\\n    /// @notice Marks the following ERC165 interface(s) as supported: ERC2981.\\n    function init() internal {\\n        InterfaceDetectionStorage.layout().setSupportedInterface(type(IERC2981).interfaceId, true);\\n    }\\n\\n    /// @notice Sets the royalty percentage.\\n    /// @dev Reverts with IncorrectRoyaltyPercentage if `percentage` is above 100% (> FEE_DENOMINATOR).\\n    /// @param percentage The new percentage to set. For example 50000 sets 50% royalty.\\n    function setRoyaltyPercentage(Layout storage s, uint256 percentage) internal {\\n        if (percentage > ROYALTY_FEE_DENOMINATOR) {\\n            revert IncorrectRoyaltyPercentage(percentage);\\n        }\\n        s.royaltyPercentage = uint96(percentage);\\n    }\\n\\n    /// @notice Sets the royalty receiver.\\n    /// @dev Reverts with IncorrectRoyaltyReceiver if `receiver` is the zero address.\\n    /// @param receiver The new receiver to set.\\n    function setRoyaltyReceiver(Layout storage s, address receiver) internal {\\n        if (receiver == address(0)) {\\n            revert IncorrectRoyaltyReceiver();\\n        }\\n        s.royaltyReceiver = receiver;\\n    }\\n\\n    /// @notice Called with the sale price to determine how much royalty is owed and to whom.\\n    // / @param tokenId The NFT asset queried for royalty information\\n    /// @param salePrice The sale price of the NFT asset specified by `tokenId`\\n    /// @return receiver Address of who should be sent the royalty payment\\n    /// @return royaltyAmount The royalty payment amount for `salePrice`\\n    function royaltyInfo(Layout storage s, uint256, uint256 salePrice) internal view returns (address receiver, uint256 royaltyAmount) {\\n        receiver = s.royaltyReceiver;\\n        uint256 royaltyPercentage = s.royaltyPercentage;\\n        if (salePrice == 0 || royaltyPercentage == 0) {\\n            royaltyAmount = 0;\\n        } else {\\n            if (salePrice < ROYALTY_FEE_DENOMINATOR) {\\n                royaltyAmount = (salePrice * royaltyPercentage) / ROYALTY_FEE_DENOMINATOR;\\n            } else {\\n                royaltyAmount = (salePrice / ROYALTY_FEE_DENOMINATOR) * royaltyPercentage;\\n            }\\n        }\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/token/royalty/libraries/OperatorFiltererStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nimport {IOperatorFilterRegistry} from \\\"./../interfaces/IOperatorFilterRegistry.sol\\\";\\nimport {ProxyInitialization} from \\\"./../../../proxy/libraries/ProxyInitialization.sol\\\";\\n\\nlibrary OperatorFiltererStorage {\\n    using OperatorFiltererStorage for OperatorFiltererStorage.Layout;\\n\\n    struct Layout {\\n        IOperatorFilterRegistry registry;\\n    }\\n\\n    bytes32 internal constant PROXY_INIT_PHASE_SLOT = bytes32(uint256(keccak256(\\\"animoca.token.royalty.OperatorFilterer.phase\\\")) - 1);\\n    bytes32 internal constant LAYOUT_STORAGE_SLOT = bytes32(uint256(keccak256(\\\"animoca.token.royalty.OperatorFilterer.storage\\\")) - 1);\\n\\n    error OperatorNotAllowed(address operator);\\n\\n    /// @notice Sets the address that the contract will make OperatorFilter checks against.\\n    /// @dev Note: This function should be called ONLY in the constructor of an immutable (non-proxied) contract.\\n    /// @param registry The operator filter registry address. When set to the zero address, checks will be bypassed.\\n    function constructorInit(Layout storage s, IOperatorFilterRegistry registry) internal {\\n        s.registry = registry;\\n    }\\n\\n    /// @notice Sets the address that the contract will make OperatorFilter checks against.\\n    /// @dev Note: This function should be called ONLY in the init function of a proxied contract.\\n    /// @dev Reverts if the proxy initialization phase is set to `1` or above.\\n    /// @param registry The operator filter registry address. When set to the zero address, checks will be bypassed.\\n    function proxyInit(Layout storage s, IOperatorFilterRegistry registry) internal {\\n        ProxyInitialization.setPhase(PROXY_INIT_PHASE_SLOT, 1);\\n        s.constructorInit(registry);\\n    }\\n\\n    /// @notice Updates the address that the contract will make OperatorFilter checks against.\\n    /// @param registry The new operator filter registry address. When set to the zero address, checks will be bypassed.\\n    function updateOperatorFilterRegistry(Layout storage s, IOperatorFilterRegistry registry) internal {\\n        s.registry = registry;\\n    }\\n\\n    /// @dev Reverts with OperatorNotAllowed if `sender` is not `from` and is not allowed by a valid operator registry.\\n    function requireAllowedOperatorForTransfer(Layout storage s, address sender, address from) internal view {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred from an EOA.\\n        if (sender != from) {\\n            _checkFilterOperator(s, sender);\\n        }\\n    }\\n\\n    /// @dev Reverts with OperatorNotAllowed if `sender` is not allowed by a valid operator registry.\\n    function requireAllowedOperatorForApproval(Layout storage s, address operator) internal view {\\n        _checkFilterOperator(s, operator);\\n    }\\n\\n    function operatorFilterRegistry(Layout storage s) internal view returns (IOperatorFilterRegistry) {\\n        return s.registry;\\n    }\\n\\n    function layout() internal pure returns (Layout storage s) {\\n        bytes32 position = LAYOUT_STORAGE_SLOT;\\n        assembly {\\n            s.slot := position\\n        }\\n    }\\n\\n    function _checkFilterOperator(Layout storage s, address operator) private view {\\n        IOperatorFilterRegistry registry = s.registry;\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (address(registry) != address(0) && address(registry).code.length > 0) {\\n            if (!registry.isOperatorAllowed(address(this), operator)) {\\n                revert OperatorNotAllowed(operator);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@animoca/ethereum-contracts/contracts/utils/libraries/Bytes32.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\nlibrary Bytes32 {\\n    /// @notice Converts bytes32 to base32 string.\\n    /// @param value value to convert.\\n    /// @return the converted base32 string.\\n    function toBase32String(bytes32 value) internal pure returns (string memory) {\\n        unchecked {\\n            bytes32 base32Alphabet = 0x6162636465666768696A6B6C6D6E6F707172737475767778797A323334353637;\\n            uint256 i = uint256(value);\\n            uint256 k = 52;\\n            bytes memory bstr = new bytes(k);\\n            bstr[--k] = base32Alphabet[uint8((i % 8) << 2)]; // uint8 s = uint8((256 - skip) % 5);  // (i % (2**s)) << (5-s)\\n            i /= 8;\\n            while (k > 0) {\\n                bstr[--k] = base32Alphabet[i % 32];\\n                i /= 32;\\n            }\\n            return string(bstr);\\n        }\\n    }\\n\\n    /// @notice Converts a bytes32 value to an ASCII string, trimming the tailing zeros.\\n    /// @param value value to convert.\\n    /// @return the converted ASCII string.\\n    function toASCIIString(bytes32 value) internal pure returns (string memory) {\\n        unchecked {\\n            if (value == 0x00) return \\\"\\\";\\n            bytes memory bytesString = bytes(abi.encodePacked(value));\\n            uint256 pos = 31;\\n            while (true) {\\n                if (bytesString[pos] != 0) break;\\n                --pos;\\n            }\\n            bytes memory asciiString = new bytes(pos + 1);\\n            for (uint256 i; i <= pos; ++i) {\\n                asciiString[i] = bytesString[i];\\n            }\\n            return string(asciiString);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/ERC721/REVVRacingNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IOperatorFilterRegistry} from \\\"@animoca/ethereum-contracts/contracts/token/royalty/interfaces/IOperatorFilterRegistry.sol\\\";\\nimport {IForwarderRegistry} from \\\"@animoca/ethereum-contracts/contracts/metatx/interfaces/IForwarderRegistry.sol\\\";\\nimport {ERC721WithOperatorFilterer} from \\\"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721WithOperatorFilterer.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport {ERC721BatchTransferWithOperatorFilterer} from \\\"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721BatchTransferWithOperatorFilterer.sol\\\";\\nimport {ERC721MetadataWithBaseURI} from \\\"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721MetadataWithBaseURI.sol\\\";\\nimport {ERC721Mintable} from \\\"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721Mintable.sol\\\";\\nimport {ERC721Deliverable} from \\\"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721Deliverable.sol\\\";\\nimport {ERC721Burnable} from \\\"@animoca/ethereum-contracts/contracts/token/ERC721/ERC721Burnable.sol\\\";\\nimport {ERC2981} from \\\"@animoca/ethereum-contracts/contracts/token/royalty/ERC2981.sol\\\";\\nimport {TokenRecovery} from \\\"@animoca/ethereum-contracts/contracts/security/TokenRecovery.sol\\\";\\nimport {ContractOwnership} from \\\"@animoca/ethereum-contracts/contracts/access/ContractOwnership.sol\\\";\\nimport {Context} from \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport {ForwarderRegistryContextBase} from \\\"@animoca/ethereum-contracts/contracts/metatx/base/ForwarderRegistryContextBase.sol\\\";\\nimport {ForwarderRegistryContext} from \\\"@animoca/ethereum-contracts/contracts/metatx/ForwarderRegistryContext.sol\\\";\\n\\ncontract REVVRacingNFT is\\n    ERC721WithOperatorFilterer,\\n    ERC721BatchTransferWithOperatorFilterer,\\n    ERC721MetadataWithBaseURI,\\n    ERC721Burnable,\\n    ERC721Mintable,\\n    ERC721Deliverable,\\n    ERC2981,\\n    TokenRecovery,\\n    ForwarderRegistryContext\\n{\\n    constructor(\\n        IOperatorFilterRegistry filterRegistry,\\n        IForwarderRegistry forwarderRegistry\\n    )\\n        ERC721WithOperatorFilterer(filterRegistry)\\n        ERC721MetadataWithBaseURI(\\\"REVV Racing NFT\\\", \\\"RR\\\")\\n        ContractOwnership(msg.sender)\\n        ForwarderRegistryContext(forwarderRegistry)\\n    {}\\n\\n    /// @inheritdoc ForwarderRegistryContextBase\\n    function _msgSender() internal view virtual override(Context, ForwarderRegistryContextBase) returns (address) {\\n        return ForwarderRegistryContextBase._msgSender();\\n    }\\n\\n    /// @inheritdoc ForwarderRegistryContextBase\\n    function _msgData() internal view virtual override(Context, ForwarderRegistryContextBase) returns (bytes calldata) {\\n        return ForwarderRegistryContextBase._msgData();\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"filterRegistry\",\"type\":\"address\"},{\"internalType\":\"contract IForwarderRegistry\",\"name\":\"forwarderRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"IncorrectRoyaltyPercentage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectRoyaltyReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseMetadataURI\",\"type\":\"string\"}],\"name\":\"BaseMetadataURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROYALTY_FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseMetadataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchBurnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwarderRegistry\",\"outputs\":[{\"internalType\":\"contract IForwarderRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"approvedForAll\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorFilterRegistry\",\"outputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"recoverERC20s\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC721[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"recoverERC721s\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseMetadataURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setRoyaltyReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"updateOperatorFilterRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "REVVRacingNFT", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "000000000000000000000000000000000000aaeb6d7670e522a718067333cd4e0000000000000000000000003f547f87251710f70109ae0409d461b270709693", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}