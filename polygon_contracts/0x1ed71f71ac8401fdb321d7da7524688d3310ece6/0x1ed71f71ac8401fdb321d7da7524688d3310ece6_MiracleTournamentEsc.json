{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@thirdweb-dev/contracts/extension/ContractMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\nimport \\\"./interface/IContractMetadata.sol\\\";\\n\\n/**\\n *  @title   Contract Metadata\\n *  @notice  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\\n *           for you contract.\\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\\n */\\n\\nabstract contract ContractMetadata is IContractMetadata {\\n    /// @notice Returns the contract metadata URI.\\n    string public override contractURI;\\n\\n    /**\\n     *  @notice         Lets a contract admin set the URI for contract-level metadata.\\n     *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\\n     *                  See {_canSetContractURI}.\\n     *                  Emits {ContractURIUpdated Event}.\\n     *\\n     *  @param _uri     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     */\\n    function setContractURI(string memory _uri) external override {\\n        if (!_canSetContractURI()) {\\n            revert(\\\"Not authorized\\\");\\n        }\\n\\n        _setupContractURI(_uri);\\n    }\\n\\n    /// @dev Lets a contract admin set the URI for contract-level metadata.\\n    function _setupContractURI(string memory _uri) internal {\\n        string memory prevURI = contractURI;\\n        contractURI = _uri;\\n\\n        emit ContractURIUpdated(prevURI, _uri);\\n    }\\n\\n    /// @dev Returns whether contract metadata can be set in the given execution context.\\n    function _canSetContractURI() internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\nimport \\\"../lib/TWAddress.sol\\\";\\nimport \\\"./interface/IMulticall.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\ncontract Multicall is IMulticall {\\n    /**\\n     *  @notice Receives and executes a batch of function calls on this contract.\\n     *  @dev Receives and executes a batch of function calls on this contract.\\n     *\\n     *  @param data The bytes data that makes up the batch of function calls to execute.\\n     *  @return results The bytes data that makes up the result of the batch of function calls executed.\\n     */\\n    function multicall(bytes[] calldata data) external virtual override returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = TWAddress.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/Permissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\nimport \\\"./interface/IPermissions.sol\\\";\\nimport \\\"../lib/TWStrings.sol\\\";\\n\\n/**\\n *  @title   Permissions\\n *  @dev     This contracts provides extending-contracts with role-based access control mechanisms\\n */\\ncontract Permissions is IPermissions {\\n    /// @dev Map from keccak256 hash of a role => a map from address => whether address has role.\\n    mapping(bytes32 => mapping(address => bool)) private _hasRole;\\n\\n    /// @dev Map from keccak256 hash of a role to role admin. See {getRoleAdmin}.\\n    mapping(bytes32 => bytes32) private _getRoleAdmin;\\n\\n    /// @dev Default admin role for all roles. Only accounts with this role can grant/revoke other roles.\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /// @dev Modifier that checks if an account has the specified role; reverts otherwise.\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     *  @notice         Checks whether an account has a particular role.\\n     *  @dev            Returns `true` if `account` has been granted `role`.\\n     *\\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     *  @param account  Address of the account for which the role is being checked.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _hasRole[role][account];\\n    }\\n\\n    /**\\n     *  @notice         Checks whether an account has a particular role;\\n     *                  role restrictions can be swtiched on and off.\\n     *\\n     *  @dev            Returns `true` if `account` has been granted `role`.\\n     *                  Role restrictions can be swtiched on and off:\\n     *                      - If address(0) has ROLE, then the ROLE restrictions\\n     *                        don't apply.\\n     *                      - If address(0) does not have ROLE, then the ROLE\\n     *                        restrictions will apply.\\n     *\\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     *  @param account  Address of the account for which the role is being checked.\\n     */\\n    function hasRoleWithSwitch(bytes32 role, address account) public view returns (bool) {\\n        if (!_hasRole[role][address(0)]) {\\n            return _hasRole[role][account];\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     *  @notice         Returns the admin role that controls the specified role.\\n     *  @dev            See {grantRole} and {revokeRole}.\\n     *                  To change a role's admin, use {_setRoleAdmin}.\\n     *\\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     */\\n    function getRoleAdmin(bytes32 role) external view override returns (bytes32) {\\n        return _getRoleAdmin[role];\\n    }\\n\\n    /**\\n     *  @notice         Grants a role to an account, if not previously granted.\\n     *  @dev            Caller must have admin role for the `role`.\\n     *                  Emits {RoleGranted Event}.\\n     *\\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     *  @param account  Address of the account to which the role is being granted.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override {\\n        _checkRole(_getRoleAdmin[role], msg.sender);\\n        if (_hasRole[role][account]) {\\n            revert(\\\"Can only grant to non holders\\\");\\n        }\\n        _setupRole(role, account);\\n    }\\n\\n    /**\\n     *  @notice         Revokes role from an account.\\n     *  @dev            Caller must have admin role for the `role`.\\n     *                  Emits {RoleRevoked Event}.\\n     *\\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     *  @param account  Address of the account from which the role is being revoked.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override {\\n        _checkRole(_getRoleAdmin[role], msg.sender);\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     *  @notice         Revokes role from the account.\\n     *  @dev            Caller must have the `role`, with caller being the same as `account`.\\n     *                  Emits {RoleRevoked Event}.\\n     *\\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     *  @param account  Address of the account from which the role is being revoked.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        if (msg.sender != account) {\\n            revert(\\\"Can only renounce for self\\\");\\n        }\\n        _revokeRole(role, account);\\n    }\\n\\n    /// @dev Sets `adminRole` as `role`'s admin role.\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = _getRoleAdmin[role];\\n        _getRoleAdmin[role] = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /// @dev Sets up `role` for `account`\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _hasRole[role][account] = true;\\n        emit RoleGranted(role, account, msg.sender);\\n    }\\n\\n    /// @dev Revokes `role` from `account`\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        _checkRole(role, account);\\n        delete _hasRole[role][account];\\n        emit RoleRevoked(role, account, msg.sender);\\n    }\\n\\n    /// @dev Checks `role` for `account`. Reverts with a message including the required role.\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!_hasRole[role][account]) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"Permissions: account \\\",\\n                        TWStrings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        TWStrings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /// @dev Checks `role` for `account`. Reverts with a message including the required role.\\n    function _checkRoleWithSwitch(bytes32 role, address account) internal view virtual {\\n        if (!hasRoleWithSwitch(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"Permissions: account \\\",\\n                        TWStrings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        TWStrings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/PermissionsEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\nimport \\\"./interface/IPermissionsEnumerable.sol\\\";\\nimport \\\"./Permissions.sol\\\";\\n\\n/**\\n *  @title   PermissionsEnumerable\\n *  @dev     This contracts provides extending-contracts with role-based access control mechanisms.\\n *           Also provides interfaces to view all members with a given role, and total count of members.\\n */\\ncontract PermissionsEnumerable is IPermissionsEnumerable, Permissions {\\n    /**\\n     *  @notice A data structure to store data of members for a given role.\\n     *\\n     *  @param index    Current index in the list of accounts that have a role.\\n     *  @param members  map from index => address of account that has a role\\n     *  @param indexOf  map from address => index which the account has.\\n     */\\n    struct RoleMembers {\\n        uint256 index;\\n        mapping(uint256 => address) members;\\n        mapping(address => uint256) indexOf;\\n    }\\n\\n    /// @dev map from keccak256 hash of a role to its members' data. See {RoleMembers}.\\n    mapping(bytes32 => RoleMembers) private roleMembers;\\n\\n    /**\\n     *  @notice         Returns the role-member from a list of members for a role,\\n     *                  at a given index.\\n     *  @dev            Returns `member` who has `role`, at `index` of role-members list.\\n     *                  See struct {RoleMembers}, and mapping {roleMembers}\\n     *\\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     *  @param index    Index in list of current members for the role.\\n     *\\n     *  @return member  Address of account that has `role`\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view override returns (address member) {\\n        uint256 currentIndex = roleMembers[role].index;\\n        uint256 check;\\n\\n        for (uint256 i = 0; i < currentIndex; i += 1) {\\n            if (roleMembers[role].members[i] != address(0)) {\\n                if (check == index) {\\n                    member = roleMembers[role].members[i];\\n                    return member;\\n                }\\n                check += 1;\\n            } else if (hasRole(role, address(0)) && i == roleMembers[role].indexOf[address(0)]) {\\n                check += 1;\\n            }\\n        }\\n    }\\n\\n    /**\\n     *  @notice         Returns total number of accounts that have a role.\\n     *  @dev            Returns `count` of accounts that have `role`.\\n     *                  See struct {RoleMembers}, and mapping {roleMembers}\\n     *\\n     *  @param role     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     *\\n     *  @return count   Total number of accounts that have `role`\\n     */\\n    function getRoleMemberCount(bytes32 role) external view override returns (uint256 count) {\\n        uint256 currentIndex = roleMembers[role].index;\\n\\n        for (uint256 i = 0; i < currentIndex; i += 1) {\\n            if (roleMembers[role].members[i] != address(0)) {\\n                count += 1;\\n            }\\n        }\\n        if (hasRole(role, address(0))) {\\n            count += 1;\\n        }\\n    }\\n\\n    /// @dev Revokes `role` from `account`, and removes `account` from {roleMembers}\\n    ///      See {_removeMember}\\n    function _revokeRole(bytes32 role, address account) internal override {\\n        super._revokeRole(role, account);\\n        _removeMember(role, account);\\n    }\\n\\n    /// @dev Grants `role` to `account`, and adds `account` to {roleMembers}\\n    ///      See {_addMember}\\n    function _setupRole(bytes32 role, address account) internal override {\\n        super._setupRole(role, account);\\n        _addMember(role, account);\\n    }\\n\\n    /// @dev adds `account` to {roleMembers}, for `role`\\n    function _addMember(bytes32 role, address account) internal {\\n        uint256 idx = roleMembers[role].index;\\n        roleMembers[role].index += 1;\\n\\n        roleMembers[role].members[idx] = account;\\n        roleMembers[role].indexOf[account] = idx;\\n    }\\n\\n    /// @dev removes `account` from {roleMembers}, for `role`\\n    function _removeMember(bytes32 role, address account) internal {\\n        uint256 idx = roleMembers[role].indexOf[account];\\n\\n        delete roleMembers[role].members[idx];\\n        delete roleMembers[role].indexOf[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/interface/IContractMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\n/**\\n *  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\\n *  for you contract.\\n *\\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\\n */\\n\\ninterface IContractMetadata {\\n    /// @dev Returns the metadata URI of the contract.\\n    function contractURI() external view returns (string memory);\\n\\n    /**\\n     *  @dev Sets contract URI for the storefront-level metadata of the contract.\\n     *       Only module admin can call this function.\\n     */\\n    function setContractURI(string calldata _uri) external;\\n\\n    /// @dev Emitted when the contract URI is updated.\\n    event ContractURIUpdated(string prevURI, string newURI);\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/interface/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\ninterface IMulticall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/interface/IPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IPermissions {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/interface/IPermissionsEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\nimport \\\"./IPermissions.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IPermissionsEnumerable is IPermissions {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * [forum post](https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296)\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/lib/TWAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary TWAddress {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * [EIP1884](https://eips.ethereum.org/EIPS/eip-1884) increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/lib/TWStrings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary TWStrings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contract/Miracle-Tournament/Miracle-Escrow-R7.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"./Miracle-Tournament-R7.sol\\\";\\r\\nimport \\\"@thirdweb-dev/contracts/extension/ContractMetadata.sol\\\";\\r\\n//    _______ _______ ___ ___ _______ ______  ___     ___ ______  _______     ___     _______ _______  _______ \\r\\n//   |   _   |   _   |   Y   |   _   |   _  \\\\|   |   |   |   _  \\\\|   _   |   |   |   |   _   |   _   \\\\|   _   |\\r\\n//   |   1___|.  1___|.  |   |.  1___|.  |   |.  |   |.  |.  |   |.  1___|   |.  |   |.  1   |.  1   /|   1___|\\r\\n//   |____   |.  __)_|.  |   |.  __)_|.  |   |.  |___|.  |.  |   |.  __)_    |.  |___|.  _   |.  _   \\\\|____   |\\r\\n//   |:  1   |:  1   |:  1   |:  1   |:  |   |:  1   |:  |:  |   |:  1   |   |:  1   |:  |   |:  1    |:  1   |\\r\\n//   |::.. . |::.. . |\\\\:.. ./|::.. . |::.|   |::.. . |::.|::.|   |::.. . |   |::.. . |::.|:. |::.. .  |::.. . |\\r\\n//   `-------`-------' `---' `-------`--- ---`-------`---`--- ---`-------'   `-------`--- ---`-------'`-------'\\r\\n//   TournamentEscrow V0.7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              .0\\r\\n                                             \\r\\ninterface IERC20 {\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IERC1155{\\r\\n    function mintTo(address _to, uint256 _tokenId, string calldata _uri, uint256 _amount) external;\\r\\n}\\r\\n\\r\\ncontract MiracleTournamentEscrow is ContractMetadata {\\r\\n    address public deployer;\\r\\n    address public admin;\\r\\n    address payable public tournamentAddr;\\r\\n    //Royalty strring\\r\\n    uint public RoyaltyPrizeDev;\\r\\n    uint public RoyaltyregfeeDev;\\r\\n    uint public RoyaltyPrizeFlp;\\r\\n    uint public RoyaltyregfeeFlp;\\r\\n    address public royaltyAddrDev;\\r\\n    address public royaltyAddrFlp;\\r\\n    // Nexus point\\r\\n    IERC1155 public NexusPointEdition;\\r\\n    uint public NexusPointID;\\r\\n    string public NexusPointURI;\\r\\n\\r\\n    MiracleTournament internal miracletournament;\\r\\n\\r\\n    struct Tournament {\\r\\n        address organizer;\\r\\n        IERC20 prizeToken;\\r\\n        IERC20 feeToken;\\r\\n        uint prizeAmount;\\r\\n        uint joinFee;\\r\\n        uint feeBalance;\\r\\n        uint256[] prizeAmountArray;\\r\\n        bool tournamentCreated;\\r\\n        bool tournamentEnded;\\r\\n        bool tournamentCanceled;\\r\\n        string tournamentURI;\\r\\n        uint PlayersLimit;\\r\\n    }\\r\\n    mapping(uint => Tournament) public tournamentMapping;\\r\\n\\r\\n    event CreateTournament(uint tournamentId, address organizer, string tournamentURI);\\r\\n    event LockPrizeToken(uint tournamentId, uint prizeAmount);\\r\\n    event LockFeeToken(uint tournamentId, uint feeAmount);\\r\\n    event UnlockPrizeToken(uint tournamentId, uint amount);\\r\\n    event UnlockFeeToken(uint tournamentId, uint amount);\\r\\n    event WithdrawFee(uint tournamentId, uint feeBalance);\\r\\n    event PrizePaid(uint tournamentId, address account, uint PrizeAmount);\\r\\n    event ReturnFee(uint tournamentId, address account, uint feeAmount);\\r\\n    event ReturnPrize(uint tournamentId, address account, uint PrizeAmount);\\r\\n    event CanceledUnlock(uint tournamentId);\\r\\n    event EndedUnlock(uint tournamentId, address [] _withdrawAddresses);\\r\\n\\r\\n    constructor(address adminAddr, address _royaltyAddrDev, address _royaltyAddrFlp, IERC1155 _NexusPointEdition, uint _NexusPointID, string memory _nexusURI, string memory _contractURI) {\\r\\n        admin = adminAddr;\\r\\n        royaltyAddrDev = _royaltyAddrDev;\\r\\n        royaltyAddrFlp = _royaltyAddrFlp;\\r\\n        // Set default dev royalty \\r\\n        RoyaltyPrizeDev = 5;\\r\\n        RoyaltyregfeeDev = 5;\\r\\n        // Set default platform royalty \\r\\n        RoyaltyPrizeFlp = 5;\\r\\n        RoyaltyregfeeFlp = 5;\\r\\n        deployer = adminAddr;\\r\\n        NexusPointEdition = _NexusPointEdition;\\r\\n        NexusPointID = _NexusPointID;\\r\\n        NexusPointURI = _nexusURI;\\r\\n        _setupContractURI(_contractURI);\\r\\n    }\\r\\n\\r\\n    function _canSetContractURI() internal view virtual override returns (bool){\\r\\n        return msg.sender == deployer;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin(){\\r\\n        require(msg.sender == admin, \\\"Only admin can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyTournament(){\\r\\n        require(msg.sender == tournamentAddr, \\\"Only tournament contract can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOrganizer(uint _tournamentId){\\r\\n        Tournament storage _tournament = tournamentMapping[_tournamentId];\\r\\n        require(msg.sender == _tournament.organizer, \\\"Only organizer can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function connectTournament(address payable _miracletournament) public onlyAdmin{\\r\\n        tournamentAddr = _miracletournament;\\r\\n        miracletournament = MiracleTournament(_miracletournament);\\r\\n    }\\r\\n\\r\\n    // Create tournament\\r\\n    function createTournamentEscrow(uint _tournamentId, uint8 _tournamentType, address _prizeToken, address _feeToken, uint _prizeAmount, uint _joinFee, uint _registerStartTime, uint _registerEndTime, uint256[] memory _prizeAmountArray, string memory _tournamentURI, uint _playerLimit) external {\\r\\n        require(IERC20(_prizeToken).allowance(msg.sender, address(this)) >= _prizeAmount, \\\"Allowance is not sufficient.\\\");\\r\\n        require(_prizeAmount <= IERC20(_prizeToken).balanceOf(msg.sender), \\\"Insufficient balance.\\\");\\r\\n        uint256 totalWithdrawAmount;\\r\\n        for (uint256 i = 0; i < _prizeAmountArray.length; i++) {\\r\\n            totalWithdrawAmount += _prizeAmountArray[i];\\r\\n        }\\r\\n        require(totalWithdrawAmount == _prizeAmount, \\\"Total withdraw amount must equal prize amount.\\\");\\r\\n\\r\\n        Tournament storage newTournament = tournamentMapping[_tournamentId];\\r\\n        require(newTournament.tournamentCreated == false, \\\"Tournament already created.\\\");\\r\\n        require(IERC20(_prizeToken).transferFrom(msg.sender, address(this), _prizeAmount), \\\"Transfer failed.\\\");\\r\\n\\r\\n        newTournament.organizer = msg.sender;\\r\\n        newTournament.prizeToken = IERC20(_prizeToken);\\r\\n        newTournament.feeToken = IERC20(_feeToken);\\r\\n        newTournament.prizeAmount = _prizeAmount;\\r\\n        newTournament.joinFee = _joinFee;\\r\\n        newTournament.feeBalance = 0;\\r\\n        newTournament.prizeAmountArray = _prizeAmountArray;\\r\\n        newTournament.tournamentCreated = true;\\r\\n        newTournament.tournamentEnded = false;\\r\\n        newTournament.tournamentCanceled = false;\\r\\n        newTournament.tournamentURI = _tournamentURI;\\r\\n        newTournament.PlayersLimit = _playerLimit;\\r\\n        \\r\\n        miracletournament.createTournament(_tournamentId, _tournamentType, msg.sender, _registerStartTime, _registerEndTime, _prizeAmountArray.length, _playerLimit);\\r\\n        emit CreateTournament(_tournamentId, msg.sender, _tournamentURI);\\r\\n        emit LockPrizeToken(_tournamentId, _prizeAmount);\\r\\n    }\\r\\n\\r\\n    function endedTournament(uint _tournamentId, address[] memory _withdrawAddresses) external onlyTournament {\\r\\n        _EndedUnlockTransfer(_tournamentId, _withdrawAddresses);\\r\\n    }\\r\\n\\r\\n    function canceledTournament(uint _tournamentId, address[] memory _entryPlayers) external onlyTournament{\\r\\n        _CanceledUnlockTransfer(_tournamentId, _entryPlayers);\\r\\n    }\\r\\n\\r\\n    // USER entry to the tournament.\\r\\n    function register(uint _tournamentId) external {\\r\\n        Tournament storage _tournament = tournamentMapping[_tournamentId];\\r\\n        require(_tournament.feeToken.allowance(msg.sender, address(this)) >= _tournament.joinFee, \\\"Allowance is not sufficient.\\\");\\r\\n        require(_tournament.joinFee <= _tournament.feeToken.balanceOf(msg.sender), \\\"Insufficient balance.\\\");\\r\\n        require(_tournament.feeToken.transferFrom(msg.sender, address(this), _tournament.joinFee), \\\"Transfer failed.\\\");\\r\\n        require(_tournament.organizer != msg.sender, \\\"Organizers cannot register.\\\");\\r\\n\\r\\n        _tournament.feeBalance = _tournament.feeBalance + _tournament.joinFee;\\r\\n        miracletournament.register(_tournamentId, msg.sender);\\r\\n        // Mint Nexus Point\\r\\n        IERC1155(NexusPointEdition).mintTo(msg.sender, NexusPointID, NexusPointURI, 1);\\r\\n        emit LockFeeToken(_tournamentId, _tournament.joinFee);\\r\\n    }\\r\\n\\r\\n    // R5.1\\r\\n    // Tournament CANCEL unlock PRIZE and entry fee (auto transfer)\\r\\n    function _CanceledUnlockTransfer(uint _tournamentId, address[] memory _players) internal {\\r\\n        Tournament storage _tournament = tournamentMapping[_tournamentId];\\r\\n        // Set tournament status canceled\\r\\n        _tournament.tournamentCanceled = true;\\r\\n        // Transfer entry fee to users\\r\\n        for (uint256 i = 0; i < _players.length; i++) {\\r\\n            _tournament.feeToken.transfer(_players[i], _tournament.joinFee);\\r\\n        }\\r\\n        _tournament.prizeToken.transfer(_tournament.organizer, _tournament.prizeAmount);\\r\\n        emit CanceledUnlock(_tournamentId);\\r\\n    }\\r\\n\\r\\n    //R5.1\\r\\n    // Tournament END unlock PRIZE and entry fee (auto transfer)\\r\\n    function _EndedUnlockTransfer(uint _tournamentId, address[] memory _winner) internal {\\r\\n        Tournament storage _tournament = tournamentMapping[_tournamentId];\\r\\n        // Set tournament status ended\\r\\n        _tournament.tournamentEnded = true;\\r\\n\\r\\n        uint256[] memory _prizeAmountArray = _tournament.prizeAmountArray;\\r\\n        require(_winner.length == _prizeAmountArray.length, \\\"Arrays must be the same length.\\\");\\r\\n        // Transfer prize to winner\\r\\n        for (uint256 i = 0; i < _winner.length; i++) {\\r\\n            uint256 _prizeAmount = _prizeAmountArray[i];\\r\\n            uint256 _prizeFeeDev = (_prizeAmount * RoyaltyPrizeDev) / 100;\\r\\n            uint256 _prizeFeeFlp = (_prizeAmount * RoyaltyPrizeFlp) / 100;\\r\\n            uint256 _prizeUser = _prizeAmount - (_prizeFeeDev + _prizeFeeFlp);\\r\\n            \\r\\n            _tournament.prizeToken.transfer(royaltyAddrDev, _prizeFeeDev);\\r\\n            _tournament.prizeToken.transfer(royaltyAddrFlp, _prizeFeeFlp);\\r\\n            _tournament.prizeToken.transfer(_winner[i], _prizeUser);\\r\\n        }\\r\\n        // Transfer entry fee\\r\\n        uint256 _feeAmount = _tournament.feeBalance;\\r\\n        uint256 _feeFeeDev = (_feeAmount * RoyaltyregfeeDev) / 100;\\r\\n        uint256 _feeFeeFlp = (_feeAmount * RoyaltyregfeeFlp) / 100;\\r\\n        uint256 _feeOrg = _feeAmount - (_feeFeeDev + _feeFeeFlp);\\r\\n        _tournament.feeToken.transfer(royaltyAddrDev, _feeFeeDev);\\r\\n        _tournament.feeToken.transfer(royaltyAddrFlp, _feeFeeFlp);\\r\\n        _tournament.feeToken.transfer(_tournament.organizer, _feeOrg);\\r\\n\\r\\n        emit EndedUnlock(_tournamentId, _winner);\\r\\n    }\\r\\n\\r\\n    // Set royalty address\\r\\n    function setRoyaltyDevAddress(address _royaltyAddr) external onlyAdmin{\\r\\n        royaltyAddrDev = _royaltyAddr;\\r\\n    }\\r\\n\\r\\n    function setRoyaltyFlpAddress(address _royaltyAddr) external onlyAdmin{\\r\\n        royaltyAddrFlp = _royaltyAddr;\\r\\n    }\\r\\n\\r\\n    // Set prize royalty rate\\r\\n    function setPrizeRoyaltyDevRate(uint _royaltyRate) external onlyAdmin{\\r\\n        RoyaltyPrizeDev = _royaltyRate;\\r\\n    }\\r\\n\\r\\n    function setPrizeRoyaltyFlpRate(uint _royaltyRate) external onlyAdmin{\\r\\n        RoyaltyPrizeFlp = _royaltyRate;\\r\\n    }\\r\\n\\r\\n    // Set regfee royalty rate\\r\\n    function setRegfeeRoyaltyDevRate(uint _royaltyRate) external onlyAdmin{\\r\\n        RoyaltyregfeeDev = _royaltyRate;\\r\\n    }\\r\\n\\r\\n    function setRegfeeRoyaltyFlpRate(uint _royaltyRate) external onlyAdmin{\\r\\n        RoyaltyregfeeFlp = _royaltyRate;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contract/Miracle-Tournament/Miracle-Tournament-R7.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.17;    \\r\\n\\r\\nimport \\\"./Miracle-Escrow-R7.sol\\\";\\r\\nimport \\\"@thirdweb-dev/contracts/extension/PermissionsEnumerable.sol\\\";\\r\\nimport \\\"@thirdweb-dev/contracts/extension/Multicall.sol\\\";\\r\\nimport \\\"@thirdweb-dev/contracts/extension/ContractMetadata.sol\\\";\\r\\n\\r\\n//    _______ _______ ___ ___ _______ ______  ___     ___ ______  _______     ___     _______ _______  _______ \\r\\n//   |   _   |   _   |   Y   |   _   |   _  \\\\|   |   |   |   _  \\\\|   _   |   |   |   |   _   |   _   \\\\|   _   |\\r\\n//   |   1___|.  1___|.  |   |.  1___|.  |   |.  |   |.  |.  |   |.  1___|   |.  |   |.  1   |.  1   /|   1___|\\r\\n//   |____   |.  __)_|.  |   |.  __)_|.  |   |.  |___|.  |.  |   |.  __)_    |.  |___|.  _   |.  _   \\\\|____   |\\r\\n//   |:  1   |:  1   |:  1   |:  1   |:  |   |:  1   |:  |:  |   |:  1   |   |:  1   |:  |   |:  1    |:  1   |\\r\\n//   |::.. . |::.. . |\\\\:.. ./|::.. . |::.|   |::.. . |::.|::.|   |::.. . |   |::.. . |::.|:. |::.. .  |::.. . |\\r\\n//   `-------`-------' `---' `-------`--- ---`-------`---`--- ---`-------'   `-------`--- ---`-------'`-------'\\r\\n//   Tournament V1.0\\r\\n\\r\\ncontract MiracleTournament is PermissionsEnumerable, Multicall, ContractMetadata {\\r\\n    address public deployer;\\r\\n    address payable public EscrowAddr;\\r\\n    uint[] private OnGoingTournaments;\\r\\n    uint[] private EndedTournaments;\\r\\n\\r\\n    struct Tournament {\\r\\n        bool created;\\r\\n        uint8 tournamentType;\\r\\n        address [] players;\\r\\n        mapping(address => bool) playerRegistered;\\r\\n        address [] ranker;\\r\\n        address organizer;\\r\\n        uint PlayersLimit;\\r\\n        uint registerStartTime;\\r\\n        uint registerEndTime;\\r\\n        uint prizeCount;\\r\\n        bool tournamentEnded;\\r\\n        string scoreURI;\\r\\n    }\\r\\n\\r\\n    address admin;\\r\\n    mapping(uint => Tournament) public tournamentMapping;\\r\\n\\r\\n    event CreateTournament(uint tournamentId);\\r\\n    event Registered(uint tournamentId, address account);\\r\\n    event NewPersonalRecord(uint tournamentId, address account, uint score);\\r\\n    event ScoreUpdated(uint tournamentId, string uri);\\r\\n    event TournamentEnded(uint tournamentId); \\r\\n    event TournamentCanceled(uint tournamentId);\\r\\n    event ShuffledPlayers(uint tournamentId, uint playersCount);\\r\\n\\r\\n    bytes32 private constant FACTORY_ROLE = keccak256(\\\"FACTORY_ROLE\\\");\\r\\n    bytes32 private constant ESCROW_ROLE = keccak256(\\\"ESCROW_ROLE\\\");\\r\\n\\r\\n    constructor(address adminAddr, string memory _contractURI)  {\\r\\n        _setupRole(DEFAULT_ADMIN_ROLE, adminAddr);\\r\\n        _setupRole(FACTORY_ROLE, adminAddr);\\r\\n        deployer = adminAddr;\\r\\n        _setupContractURI(_contractURI);\\r\\n    }\\r\\n\\r\\n    function _canSetContractURI() internal view virtual override returns (bool){\\r\\n        return msg.sender == deployer;\\r\\n    }\\r\\n\\r\\n    modifier registrationOpen(uint tournamentId) {\\r\\n        Tournament storage tournament = tournamentMapping[tournamentId];\\r\\n        require(block.timestamp >= tournament.registerStartTime, \\\"Registration has not started yet\\\");\\r\\n        require(block.timestamp <= tournament.registerEndTime, \\\"Registration deadline passed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function connectEscrow(address payable _escrowAddr) public onlyRole(DEFAULT_ADMIN_ROLE) {\\r\\n        _setupRole(ESCROW_ROLE, _escrowAddr);\\r\\n        EscrowAddr = _escrowAddr;\\r\\n    }\\r\\n\\r\\n    function createTournament(uint _tournamentId, uint8 _tournamentType, address _organizer, uint _registerStartTime, uint _registerEndTime, uint _prizeCount, uint _playerLimit) public onlyRole(ESCROW_ROLE) {\\r\\n        Tournament storage newTournament = tournamentMapping[_tournamentId];\\r\\n        newTournament.created = true;\\r\\n        newTournament.tournamentType = _tournamentType;\\r\\n        newTournament.organizer = _organizer;\\r\\n        newTournament.registerStartTime = _registerStartTime;\\r\\n        newTournament.registerEndTime = _registerEndTime;\\r\\n        newTournament.prizeCount = _prizeCount;\\r\\n        newTournament.PlayersLimit = _playerLimit;\\r\\n        newTournament.tournamentEnded = false;\\r\\n        \\r\\n        addOnGoingTournament(_tournamentId);\\r\\n        emit CreateTournament(_tournamentId);\\r\\n    }\\r\\n    \\r\\n    function register(uint _tournamentId, address _player) public payable registrationOpen(_tournamentId) onlyRole(ESCROW_ROLE){\\r\\n        require(block.timestamp > tournamentMapping[_tournamentId].registerStartTime, \\\"Registration has not started yet\\\");\\r\\n        require(block.timestamp < tournamentMapping[_tournamentId].registerEndTime, \\\"Registration deadline passed\\\");\\r\\n        require(!tournamentMapping[_tournamentId].playerRegistered[_player], \\\"Address already registered\\\");\\r\\n        require(tournamentMapping[_tournamentId].players.length < tournamentMapping[_tournamentId].PlayersLimit, \\\"Tournament is full.\\\");\\r\\n        tournamentMapping[_tournamentId].playerRegistered[_player] = true;\\r\\n        tournamentMapping[_tournamentId].players.push(_player);\\r\\n        emit Registered(_tournamentId, _player);\\r\\n    }\\r\\n\\r\\n    function updateScore(uint tournamentId, string calldata _uri) external onlyRole(FACTORY_ROLE) {\\r\\n        tournamentMapping[tournamentId].scoreURI = _uri;\\r\\n    }\\r\\n\\r\\n    function playersShuffle(uint tournamentId) public onlyRole(FACTORY_ROLE){\\r\\n        Tournament storage tournament = tournamentMapping[tournamentId];\\r\\n        address[] memory shuffledArray = tournament.players;\\r\\n        uint n = shuffledArray.length;\\r\\n\\r\\n        for (uint i = 0; i < n; i++) {\\r\\n            uint j = i + uint(keccak256(abi.encodePacked(block.timestamp))) % (n - i);\\r\\n            (shuffledArray[i], shuffledArray[j]) = (shuffledArray[j], shuffledArray[i]);\\r\\n        }\\r\\n        tournament.players = shuffledArray;\\r\\n\\r\\n        emit ShuffledPlayers(tournamentId, shuffledArray.length);\\r\\n    }\\r\\n\\r\\n    function endTournament(uint _tournamentId, address[] calldata _rankers) public onlyRole(FACTORY_ROLE) {\\r\\n        Tournament storage _tournament = tournamentMapping[_tournamentId];\\r\\n        uint _prizeCount = _tournament.prizeCount;\\r\\n        address[] memory prizeAddr = new address[](_prizeCount);\\r\\n        for(uint i = 0; i < _prizeCount; i++){\\r\\n            prizeAddr[i] = _rankers[i];\\r\\n        }\\r\\n        // Unlock Escrow Prize Token / Fee Token to Escrow contract\\r\\n        MiracleTournamentEscrow(EscrowAddr).endedTournament(_tournamentId, prizeAddr);\\r\\n        _tournament.tournamentEnded = true;\\r\\n\\r\\n        removeOnGoingTournament(_tournamentId);\\r\\n        addEndedTournament(_tournamentId);\\r\\n\\r\\n        emit TournamentEnded(_tournamentId);\\r\\n    }\\r\\n\\r\\n    function cancelTournament(uint _tournamentId) public onlyRole(FACTORY_ROLE) {\\r\\n        Tournament storage _tournament = tournamentMapping[_tournamentId];\\r\\n        address[] memory _entryPlayers = _tournament.players;\\r\\n        MiracleTournamentEscrow(EscrowAddr).canceledTournament(_tournamentId, _entryPlayers);\\r\\n\\r\\n        removeOnGoingTournament(_tournamentId);\\r\\n        addEndedTournament(_tournamentId);\\r\\n\\r\\n        emit TournamentCanceled(_tournamentId);\\r\\n    }\\r\\n\\r\\n    function addOnGoingTournament(uint _tournamentId) internal {\\r\\n        OnGoingTournaments.push(_tournamentId);\\r\\n    }\\r\\n\\r\\n    function addEndedTournament(uint _tournamentId) internal {\\r\\n        EndedTournaments.push(_tournamentId);\\r\\n    }\\r\\n\\r\\n    function removeOnGoingTournament(uint _tournamentId) internal {\\r\\n        for (uint256 i = 0; i < OnGoingTournaments.length; i++) {\\r\\n            if (OnGoingTournaments[i] == _tournamentId) {\\r\\n                if (i != OnGoingTournaments.length - 1) {\\r\\n                    OnGoingTournaments[i] = OnGoingTournaments[OnGoingTournaments.length - 1];\\r\\n                }\\r\\n                OnGoingTournaments.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function getAllTournamentCount() external view returns (uint) {\\r\\n        uint count = OnGoingTournaments.length + EndedTournaments.length;\\r\\n        return count;\\r\\n    }\\r\\n\\r\\n    function getOnGoingTournamentsCount() external view returns (uint) {\\r\\n        return OnGoingTournaments.length;\\r\\n    }\\r\\n\\r\\n    function getEndedTournamentsCount() external view returns (uint) {\\r\\n        return EndedTournaments.length;\\r\\n    }\\r\\n\\r\\n    function getOnGoingTournaments() external view returns (uint[] memory) {\\r\\n        return OnGoingTournaments;\\r\\n    }\\r\\n\\r\\n    function getEndedTournaments() external view returns (uint[] memory) {\\r\\n        return EndedTournaments;\\r\\n    }\\r\\n\\r\\n    function getPlayerCount(uint _tournamentId) external view returns(uint _playerCnt){\\r\\n        Tournament storage _tournament = tournamentMapping[_tournamentId];\\r\\n        return _tournament.players.length;\\r\\n    }\\r\\n\\r\\n    function getPlayers(uint _tournamentId) external view returns(address[] memory){\\r\\n        Tournament storage _tournament = tournamentMapping[_tournamentId];\\r\\n        return _tournament.players;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adminAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_royaltyAddrDev\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_royaltyAddrFlp\",\"type\":\"address\"},{\"internalType\":\"contract IERC1155\",\"name\":\"_NexusPointEdition\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_NexusPointID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_nexusURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_contractURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"}],\"name\":\"CanceledUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"prevURI\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"ContractURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"organizer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tournamentURI\",\"type\":\"string\"}],\"name\":\"CreateTournament\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_withdrawAddresses\",\"type\":\"address[]\"}],\"name\":\"EndedUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"LockFeeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prizeAmount\",\"type\":\"uint256\"}],\"name\":\"LockPrizeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"PrizeAmount\",\"type\":\"uint256\"}],\"name\":\"PrizePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"ReturnFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"PrizeAmount\",\"type\":\"uint256\"}],\"name\":\"ReturnPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnlockFeeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnlockPrizeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tournamentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBalance\",\"type\":\"uint256\"}],\"name\":\"WithdrawFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NexusPointEdition\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NexusPointID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NexusPointURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RoyaltyPrizeDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RoyaltyPrizeFlp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RoyaltyregfeeDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RoyaltyregfeeFlp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_entryPlayers\",\"type\":\"address[]\"}],\"name\":\"canceledTournament\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_miracletournament\",\"type\":\"address\"}],\"name\":\"connectTournament\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_tournamentType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_prizeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_prizeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_joinFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_registerStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_registerEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_prizeAmountArray\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_tournamentURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_playerLimit\",\"type\":\"uint256\"}],\"name\":\"createTournamentEscrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_withdrawAddresses\",\"type\":\"address[]\"}],\"name\":\"endedTournament\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tournamentId\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyAddrDev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyAddrFlp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_royaltyRate\",\"type\":\"uint256\"}],\"name\":\"setPrizeRoyaltyDevRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_royaltyRate\",\"type\":\"uint256\"}],\"name\":\"setPrizeRoyaltyFlpRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_royaltyRate\",\"type\":\"uint256\"}],\"name\":\"setRegfeeRoyaltyDevRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_royaltyRate\",\"type\":\"uint256\"}],\"name\":\"setRegfeeRoyaltyFlpRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyAddr\",\"type\":\"address\"}],\"name\":\"setRoyaltyDevAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyAddr\",\"type\":\"address\"}],\"name\":\"setRoyaltyFlpAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tournamentAddr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tournamentMapping\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"organizer\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"prizeToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prizeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joinFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"tournamentCreated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"tournamentEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"tournamentCanceled\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"tournamentURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"PlayersLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MiracleTournamentEscrow", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "300", "ConstructorArguments": "00000000000000000000000090db3ab690fafefee2f09b79cf2a8ab03023c6c00000000000000000000000008d9de7c34f7ea801ba4dc8d06dbcf1c11408b22e0000000000000000000000004742990f6191f5a4b1ec6fe9c939038ec52c3129000000000000000000000000726fb4baa1db0c64c12d40a9b55354d2ef90fc2b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000037697066733a2f2f516d526870754e6779554d4a32627356456956795354626a3844654c66617832514a6d57523334706e76417a59382f300000000000000000000000000000000000000000000000000000000000000000000000000000000037697066733a2f2f516d5244585435734b4d63367351366f7a44396755395079316b716437794d646f5772483866675a624775486b642f30000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}