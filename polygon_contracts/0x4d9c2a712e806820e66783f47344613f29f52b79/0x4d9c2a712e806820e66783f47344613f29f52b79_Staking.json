{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"Staking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\ncontract Staking is Ownable\\n\\t{\\n    IERC20 public unlock;\\n\\n    uint256 public constant MIN_DEPOSIT_DAYS = 7;\\n    uint256 public constant MAX_DEPOSIT_DAYS = 4 * 365;\\n\\n    uint256 public constant ONE_YEAR = 365 days; // ONE YEAR in seconds\\n    uint256 public constant ONE_DAY = 1 days; // ONE DAY in seconds\\n\\n    uint256 public startTime;\\n\\n    struct Stake\\n        {\\n        uint256 unlockAmount;\\n        uint256 xUnlockAmount;\\n        uint256 startingDay;\\n        uint256 endingDay;\\n        bool unstaked; // note that this is not updated for the stakes mapping, only for stakesByUser\\n        }\\n\\n    mapping(address =\\u003e Stake[]) private stakesByUser;\\n    mapping(address =\\u003e uint256) public lastClaimedDayByUser;\\n    Stake[] private stakes;\\n\\n    mapping(uint256 =\\u003e uint256) public rewardsByDay;\\n    mapping(uint256 =\\u003e uint256) public totalXUnlockByDay;\\n\\n    uint256 public lastDayWithRewardsSet;\\n    uint256 public tempSum;\\n\\n    event UnlockStaked\\n        (\\n        address indexed user,\\n        uint256 amount,\\n        uint256 indexed startingDay,\\n        uint256 indexed endingDay );\\n\\n    event RewardClaimed\\n        (\\n        address indexed user,\\n        uint256 amount,\\n        uint256 indexed day,\\n        uint256 indexed stakeId );\\n\\n    event UnlockUnstaked\\n        (\\n        address indexed user,\\n        uint256 indexed stakeId,\\n        uint256 amount );\\n\\n    event XUnlockSetForDay (\\n        uint256 indexed day,\\n        uint256 indexed value );\\n\\n\\n    constructor()\\n        {\\n        startTime = block.timestamp;\\n        lastDayWithRewardsSet = 0;\\n        }\\n\\n\\n    function setUnlockAddress(address unlockAddress)\\n        public onlyOwner\\n        {\\n        unlock = IERC20( unlockAddress );\\n        }\\n\\n\\n    function _currentDay()\\n        private view returns (uint256)\\n        {\\n        return (block.timestamp - startTime) / ONE_DAY;\\n        }\\n\\n\\n    function currentDay()\\n        external view returns (uint256)\\n        {\\n        return _currentDay();\\n        }\\n\\n\\n    function numberOfStakes()\\n        external view returns (uint256)\\n        {\\n        return stakes.length;\\n        }\\n\\n    function stakeUnlock( uint256 unlockAmount, uint256 durationInDays )\\n        external\\n        {\\n        require\\n            ( durationInDays \\u003e= MIN_DEPOSIT_DAYS \\u0026\\u0026\\n            durationInDays \\u003c= MAX_DEPOSIT_DAYS,\\n            \\\"Invalid staking duration\\\" );\\n\\n        uint256 xUnlockAmount = unlockAmount * durationInDays / ( ONE_YEAR / ONE_DAY );\\n\\n        uint256 startingDay = ( block.timestamp - startTime ) / ONE_DAY;\\n\\n        uint256 endingDay = startingDay + durationInDays - 1;\\n\\n        Stake memory stake = Stake\\n            (\\n            unlockAmount,\\n            xUnlockAmount,\\n            startingDay,\\n            endingDay,\\n            false\\n            );\\n\\n        stakesByUser[msg.sender].push(stake);\\n        stakes.push(stake);\\n\\n        unlock.transferFrom( msg.sender, address(this), unlockAmount );\\n\\n        emit UnlockStaked( msg.sender, unlockAmount, startingDay, endingDay );\\n        }\\n\\n\\n    function claimRewards()\\n        external\\n        {\\n        uint256 length = stakesByUser[msg.sender].length;\\n        uint256 totalOwed;\\n\\n        for ( uint256 i = 0; i \\u003c length; i++ )\\n            {\\n            Stake storage userStake = stakesByUser[msg.sender][i];\\n\\n            uint256 lastClaimedDay = lastClaimedDayByUser[msg.sender];\\n            uint256 startingDay\\n                = lastClaimedDay == 0 || userStake.startingDay \\u003e lastClaimedDay\\n                ? userStake.startingDay : lastClaimedDay + 1;\\n\\n            uint256 endingDay\\n                = userStake.endingDay \\u003e lastDayWithRewardsSet\\n                ? lastDayWithRewardsSet : userStake.endingDay;\\n\\n            if ( lastClaimedDay == endingDay ) continue;\\n\\n            for ( uint256 day = startingDay; day \\u003c= endingDay; day++ )\\n                {\\n                uint256 xUnlockAmountByDay = getXUnlockAmountForStakeOnDay( userStake, day );\\n\\n                uint256 totalRewardAmount = rewardsByDay[day];\\n                uint256 totalXUnlockAmount = totalXUnlockByDay[day];\\n\\n                if  ( xUnlockAmountByDay != 0 \\u0026\\u0026\\n                    totalRewardAmount != 0 \\u0026\\u0026\\n                    totalXUnlockAmount != 0 )\\n                    {\\n                    uint256 userReward = totalRewardAmount * xUnlockAmountByDay / totalXUnlockAmount;\\n\\n                    totalOwed += userReward;\\n\\n                    emit RewardClaimed( msg.sender, userReward, day, i );\\n\\t                }\\n                }\\n            }\\n\\n        lastClaimedDayByUser[msg.sender] = lastDayWithRewardsSet;\\n        unlock.transfer(msg.sender, totalOwed);\\n        }\\n\\n\\n\\t// Unstake unlock from all the stakes that have fully matured\\n\\tfunction unstakeUnlock()\\n\\t\\texternal\\n\\t\\t{\\n        uint256 length = stakesByUser[msg.sender].length;\\n\\t\\tuint256 totalToUnstake = 0;\\n\\n\\t\\tuint256 day = ( block.timestamp - startTime ) / ONE_DAY;\\n\\n        for ( uint256 i = 0; i \\u003c length; i++ )\\n            {\\n            Stake storage userStake = stakesByUser[msg.sender][i];\\n\\n            if ( ! userStake.unstaked )\\n            if ( day \\u003e userStake.endingDay  )\\n                {\\n\\t\\t        userStake.unstaked = true;\\n\\n\\t\\t\\t\\tuint256 amount = userStake.unlockAmount;\\n\\n\\t\\t        totalToUnstake = totalToUnstake + amount;\\n\\n\\t\\t        emit UnlockUnstaked( msg.sender, i, amount );\\n\\t\\t\\t\\t}\\n            }\\n\\n\\t\\tif ( totalToUnstake \\u003e 0 )\\n\\t        unlock.transfer( msg.sender, totalToUnstake );\\n\\t\\t}\\n\\n\\n    function clearTempSum()\\n        public onlyOwner\\n        {\\n        tempSum = 0;\\n        }\\n\\n\\n    function addXUnlockAmountToTempSum( uint256 day, uint256 startIndex, uint256 endIndex )\\n        external onlyOwner\\n\\t\\t{\\n        require( day == ( lastDayWithRewardsSet + 1 ),\\n            \\\"Day totals must be updated in sequence\\\" );\\n\\n        uint256 tempSum2;\\n        for ( uint256 i = startIndex; i \\u003c= endIndex; i++ )\\n            tempSum2 += getXUnlockAmountForStakeOnDay( stakes[i], day );\\n\\n        tempSum += tempSum2;\\n        }\\n\\n\\n    function setXUnlockForDayToTempSumAndSpecifyRewards( uint256 day, uint256 rewardAmount )\\n        external onlyOwner\\n        {\\n        uint256 lastTimestampForDay = startTime + ( day * ONE_DAY );\\n\\n        require( block.timestamp \\u003e lastTimestampForDay,\\n            \\\"Day totals must be updated in sequence\\\" );\\n\\n        require( day == ( lastDayWithRewardsSet + 1 ),\\n            \\\"Days must be updated in sequence\\\" );\\n\\n\\t\\t// Set the total for the day\\n        totalXUnlockByDay[day] = tempSum;\\n\\n        // Set the rewards for the day\\n        // These will be transferred from the sender/owner\\n        // Only send the rewards if there is xUNLOCK for the day\\n        if ( tempSum \\u003e 0 )\\n\\t\\tif ( rewardAmount \\u003e 0 )\\n\\t        unlock.transferFrom( msg.sender, address( this ), rewardAmount );\\n\\n        rewardsByDay[day] = rewardAmount;\\n        lastDayWithRewardsSet = day;\\n\\n        emit XUnlockSetForDay( day, tempSum );\\n\\n        clearTempSum();\\n        }\\n\\n\\n\\t// Not normally used - requires that the node be synced past the point of the end of the specified day\\n    function setXUnlockForDayAndSpecifyRewards( uint256 day, uint256 xunlockAmount, uint256 rewardAmount )\\n        external onlyOwner\\n        {\\n        uint256 lastTimestampForDay = startTime + ( day * ONE_DAY );\\n\\n        require( block.timestamp \\u003e lastTimestampForDay,\\n            \\\"Day totals must be updated in sequence\\\" );\\n\\n        require( day == ( lastDayWithRewardsSet + 1 ),\\n            \\\"Days must be updated in sequence\\\" );\\n\\n\\t\\t// Set the total for the day\\n        totalXUnlockByDay[day] = xunlockAmount;\\n\\n        // Set the rewards for the day\\n        // These will be transferred from the sender/owner\\n        // Only send the rewards if there is xUNLOCK for the day\\n        if ( xunlockAmount \\u003e 0 )\\n\\t\\tif ( rewardAmount \\u003e 0 )\\n\\t        unlock.transferFrom( msg.sender, address( this ), rewardAmount );\\n\\n        rewardsByDay[day] = rewardAmount;\\n        lastDayWithRewardsSet = day;\\n\\n        emit XUnlockSetForDay( day, xunlockAmount );\\n        }\\n\\n\\n    function forceSpecifyRewardsForDay( uint256 day, uint256 rewardAmount )\\n        external onlyOwner\\n        {\\n        rewardsByDay[day] = rewardAmount;\\n\\t    }\\n\\n\\n    function forceSendUnlock( address wallet, uint256 amount )\\n        external onlyOwner\\n\\t    {\\n        unlock.transfer( wallet, amount );\\n        }\\n\\n\\n    function forceCreateStake( address wallet, uint256 unlockAmount, uint256 xUnlockAmount, uint256 startingDay, uint256 endingDay, bool unstaked )\\n        external onlyOwner\\n        {\\n        Stake memory stake = Stake(\\n            unlockAmount,\\n            xUnlockAmount,\\n            startingDay,\\n            endingDay,\\n\\t\\t\\tunstaked );\\n\\n        stakesByUser[wallet].push( stake );\\n        stakes.push( stake );\\n        }\\n\\n\\n    function getAllStakes()\\n        external view returns ( Stake[] memory )\\n        {\\n        return stakes;\\n        }\\n\\n\\n    function getStake( uint256 stakeIndex )\\n        external view returns (Stake memory)\\n        {\\n        return stakes[stakeIndex];\\n        }\\n\\n\\n    function getAllStakesByUser( address user )\\n        external view returns (Stake[] memory)\\n        {\\n        return stakesByUser[user];\\n        }\\n\\n\\n    function getAllStakeByUser( address user, uint256 stakeIndex )\\n        external view returns (Stake memory)\\n        {\\n        return stakesByUser[user][stakeIndex];\\n        }\\n\\n\\n\\t// Unstake unlock from all the stakes that have fully matured\\n    function currentAmountStakedUnlock( address wallet )\\n        external view returns ( uint256 amount )\\n        {\\n        uint256 length = stakesByUser[wallet].length;\\n\\n        uint256 totalStaked = 0;\\n\\n        for ( uint256 i = 0; i \\u003c length; i++ )\\n            {\\n            Stake storage userStake = stakesByUser[wallet][i];\\n\\n            if ( ! userStake.unstaked )\\n                totalStaked = totalStaked + userStake.unlockAmount;\\n            }\\n\\n        return totalStaked;\\n        }\\n\\n\\n    function _getXUnlockAmountForUserOnDay( address user, uint256 day )\\n        private view returns (uint256)\\n        {\\n        Stake[] storage userStakes = stakesByUser[user];\\n        uint256 length = userStakes.length;\\n\\n        uint256 totalXUnlock;\\n        for (uint256 i = 0; i \\u003c length; i++)\\n            totalXUnlock += getXUnlockAmountForStakeOnDay( userStakes[i], day );\\n\\n        return totalXUnlock;\\n\\t    }\\n\\n    function getXUnlockAmountForUserOnDay( address user, uint256 day )\\n        external view returns (uint256)\\n        {\\n        return _getXUnlockAmountForUserOnDay( user, day );\\n\\t    }\\n\\n\\n    function getCurrentXUnlockAmountForUser( address user )\\n        external view returns (uint256)\\n        {\\n        uint256 day = _currentDay();\\n\\n        return _getXUnlockAmountForUserOnDay( user, day );\\n\\t    }\\n\\n\\n\\t// Unstake unlock from all the stakes that have fully matured\\n    function unstakableUnlock( address wallet )\\n        external view returns ( uint256 amount )\\n        {\\n        uint256 day = _currentDay();\\n\\n        uint256 length = stakesByUser[wallet].length;\\n        uint256 totalToUnstake = 0;\\n\\n        for ( uint256 i = 0; i \\u003c length; i++ )\\n            {\\n            Stake storage userStake = stakesByUser[wallet][i];\\n\\n            if ( ! userStake.unstaked )\\n            if ( day \\u003e userStake.endingDay  )\\n                totalToUnstake = totalToUnstake + userStake.unlockAmount;\\n            }\\n\\n        return totalToUnstake;\\n        }\\n\\n\\n    function claimableRewards( address wallet )\\n        external view returns ( uint256 amount )\\n        {\\n        uint256 length = stakesByUser[wallet].length;\\n        uint256 totalOwed;\\n\\n        for ( uint256 i = 0; i \\u003c length; i++ )\\n            {\\n            Stake storage userStake = stakesByUser[wallet][i];\\n\\n            uint256 lastClaimedDay = lastClaimedDayByUser[wallet];\\n            uint256 startingDay = lastClaimedDay == 0 || userStake.startingDay \\u003e lastClaimedDay\\n\\t\\t\\t\\t? userStake.startingDay : lastClaimedDay + 1;\\n\\n            uint256 endingDay = userStake.endingDay \\u003e lastDayWithRewardsSet\\n                ? lastDayWithRewardsSet : userStake.endingDay;\\n\\n            if ( lastClaimedDay == endingDay )\\n                continue;\\n\\n            for ( uint256 day = startingDay; day \\u003c= endingDay; day++ )\\n                {\\n                uint256 xUnlockAmountByDay = getXUnlockAmountForStakeOnDay( userStake, day );\\n\\n                uint256 totalRewardAmount = rewardsByDay[day];\\n                uint256 totalXUnlockAmount = totalXUnlockByDay[day];\\n\\n                if  ( xUnlockAmountByDay != 0 \\u0026\\u0026\\n                    totalRewardAmount != 0 \\u0026\\u0026\\n                    totalXUnlockAmount != 0 )\\n                    {\\n                    uint256 userReward = totalRewardAmount * xUnlockAmountByDay / totalXUnlockAmount;\\n\\n                    totalOwed += userReward;\\n                    }\\n                }\\n            }\\n\\n        return totalOwed;\\n        }\\n\\n\\n    function getXUnlockAmountForStakeOnDay( Stake memory stake, uint256 day )\\n        private pure returns (uint256)\\n\\t\\t{\\n        if ( stake.endingDay \\u003c day || day \\u003c stake.startingDay )\\n            return 0;\\n\\n        uint256 totalDays = stake.endingDay - stake.startingDay + 1;\\n\\n        uint256 remainingDays = stake.endingDay - day + 1;\\n\\n        return stake.xUnlockAmount * remainingDays / totalDays;\\n        }\\n\\n\\n    function getXUnlockAmountByUserStake( address user, uint256 stakeId, uint256 day )\\n        public view returns (uint256)\\n            {\\n            return getXUnlockAmountForStakeOnDay( stakesByUser[user][stakeId], day );\\n\\t\\t    }\\n\\n\\n    function getTotalXUnlockAmountOnDay( uint256 day )\\n        public view returns (uint256)\\n            {\\n            return totalXUnlockByDay[day];\\n\\t\\t    }\\n\\n\\n\\n\\n    function markLastDayClaimedForUser( address user, uint256 day ) external onlyOwner\\n        {\\n        lastClaimedDayByUser[user] = day;\\n        }\\n    }\\n\\n\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"startingDay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"endingDay\",\"type\":\"uint256\"}],\"name\":\"UnlockStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnlockUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"XUnlockSetForDay\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_DEPOSIT_DAYS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DEPOSIT_DAYS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"addXUnlockAmountToTempSum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"claimableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearTempSum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"currentAmountStakedUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xUnlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingDay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"name\":\"forceCreateStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"forceSendUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"forceSpecifyRewardsForDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"getAllStakeByUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"unlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xUnlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingDay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"internalType\":\"struct Staking.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"unlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xUnlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingDay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"internalType\":\"struct Staking.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAllStakesByUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"unlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xUnlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingDay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"internalType\":\"struct Staking.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getCurrentXUnlockAmountForUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"getStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"unlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xUnlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingDay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"internalType\":\"struct Staking.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getTotalXUnlockAmountOnDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getXUnlockAmountByUserStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getXUnlockAmountForUserOnDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimedDayByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDayWithRewardsSet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"markLastDayClaimedForUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsByDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unlockAddress\",\"type\":\"address\"}],\"name\":\"setUnlockAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xunlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"setXUnlockForDayAndSpecifyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"setXUnlockForDayToTempSumAndSpecifyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationInDays\",\"type\":\"uint256\"}],\"name\":\"stakeUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tempSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalXUnlockByDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"unstakableUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4dfdf8b679fb426f19c2710d9295f44af3ce7493290ed766b820911b66698c1e"}