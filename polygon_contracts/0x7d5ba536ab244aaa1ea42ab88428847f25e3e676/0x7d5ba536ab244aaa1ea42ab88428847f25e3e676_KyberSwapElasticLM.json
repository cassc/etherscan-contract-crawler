{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/liquidityMining/KyberSwapElasticLM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport {KSMath} from '../libraries/KSMath.sol';\\nimport {IKyberSwapElasticLM} from '../interfaces/liquidityMining/IKyberSwapElasticLM.sol';\\nimport {IKSElasticLMHelper} from '../interfaces/liquidityMining/IKSElasticLMHelper.sol';\\nimport {IBasePositionManager} from '../interfaces/liquidityMining/IBasePositionManager.sol';\\nimport {IPoolStorage} from '../interfaces/liquidityMining/IPoolStorage.sol';\\nimport {KSAdmin} from './base/KSAdmin.sol';\\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\n\\ncontract KyberSwapElasticLM is IKyberSwapElasticLM, ReentrancyGuard, KSAdmin {\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using SafeERC20 for IERC20Metadata;\\n  using KSMath for uint256;\\n\\n  IERC721 public immutable nft;\\n  IKSElasticLMHelper private helper;\\n  address public immutable weth;\\n\\n  uint256 internal constant PRECISION = 1e12;\\n\\n  uint256 public poolLength;\\n\\n  // pId => Pool info\\n  mapping(uint256 => LMPoolInfo) public pools;\\n\\n  // nftId => Position info\\n  mapping(uint256 => PositionInfo) public positions;\\n\\n  // nftId => pId => Stake info\\n  mapping(uint256 => mapping(uint256 => StakeInfo)) public stakes;\\n\\n  // nftId => list of joined pools\\n  mapping(uint256 => EnumerableSet.UintSet) internal joinedPools;\\n\\n  // user address => set of nft id which user already deposit into LM contract\\n  mapping(address => EnumerableSet.UintSet) private depositNFTs;\\n\\n  mapping(uint256 => bool) public isEmergencyWithdrawnNFT;\\n\\n  bool public emergencyEnabled;\\n  bool public specialFeatureEnabled;\\n\\n  modifier checkLength(uint256 a, uint256 b) {\\n    require(a == b, 'invalid length');\\n    _;\\n  }\\n\\n  modifier isSpecialFeaturesEnabled() {\\n    require(specialFeatureEnabled, 'special feature disabled');\\n    _;\\n  }\\n\\n  constructor(IERC721 _nft, IKSElasticLMHelper _helper) {\\n    nft = _nft;\\n    helper = _helper;\\n    weth = IBasePositionManager(address(_nft)).WETH();\\n  }\\n\\n  /**\\n   * EXTERNAL FUNCTIONS *************************\\n   */\\n\\n  /**\\n   * @dev receive native reward token\\n   */\\n  receive() external payable {}\\n\\n  /**\\n   * @dev Set emergencyEnabled flag to true\\n   */\\n  function emergencyEnable() public isAdmin {\\n    require(!emergencyEnabled, 'Invalid value');\\n    emergencyEnabled = true;\\n    emit EmergencyEnabled();\\n  }\\n\\n  /**\\n   * @dev Set specialFeatureEnabled flag to true or false\\n   */\\n  function updateSpecialFeatureEnabled(bool enableOrDisable) public isAdmin {\\n    specialFeatureEnabled = enableOrDisable;\\n    emit UpdateSpecialFeatureEnabled(enableOrDisable);\\n  }\\n\\n  function updateHelper(IKSElasticLMHelper _helper) external isAdmin {\\n    helper = _helper;\\n\\n    emit LMHelperUpdated(_helper);\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function addPool(\\n    address poolAddress,\\n    uint32 startTime,\\n    uint32 endTime,\\n    address[] calldata rewardTokens,\\n    uint256[] calldata rewardAmounts,\\n    uint256 feeTarget\\n  ) external override isOperator checkLength(rewardTokens.length, rewardAmounts.length) {\\n    require(startTime >= _getBlockTime() && endTime > startTime, 'addPool: invalid times');\\n    uint256 pId = poolLength; // save gas\\n    LMPoolInfo storage pool = pools[pId];\\n\\n    pool.poolAddress = poolAddress;\\n    pool.startTime = startTime;\\n    pool.endTime = endTime;\\n    pool.totalSecondsClaimed = 0;\\n    pool.feeTarget = feeTarget;\\n\\n    for (uint256 i = 0; i < rewardTokens.length; i++) {\\n      pool.rewards.push(RewardData(rewardTokens[i], rewardAmounts[i]));\\n    }\\n    poolLength++;\\n    emit AddPool(pId, poolAddress, startTime, endTime, feeTarget);\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function renewPool(\\n    uint256 pId,\\n    uint32 startTime,\\n    uint32 endTime,\\n    uint256[] calldata rewardAmounts,\\n    uint256 feeTarget\\n  ) external override isOperator {\\n    LMPoolInfo storage pool = pools[pId];\\n\\n    // check if pool has not started or already ended\\n    require(\\n      pool.startTime > _getBlockTime() || pool.endTime < _getBlockTime(),\\n      'renew: invalid pool state'\\n    );\\n    require(pool.rewards.length == rewardAmounts.length, 'renew: invalid length');\\n    // check input startTime and endTime\\n    require(startTime > _getBlockTime() && endTime > startTime, 'renew: invalid times');\\n    // check pool has stakes\\n    require(pool.numStakes == 0, 'renew: pool has stakes');\\n\\n    pool.startTime = startTime;\\n    pool.endTime = endTime;\\n    pool.totalSecondsClaimed = 0;\\n    pool.feeTarget = feeTarget;\\n\\n    for (uint256 i = 0; i < rewardAmounts.length; ++i) {\\n      pool.rewards[i].rewardUnclaimed = rewardAmounts[i];\\n    }\\n    emit RenewPool(pId, startTime, endTime, feeTarget);\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function deposit(uint256[] calldata nftIds) external override nonReentrant {\\n    _depositAndJoin(0, nftIds, false);\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function depositAndJoin(\\n    uint256 pId,\\n    uint256[] calldata nftIds\\n  ) external override isSpecialFeaturesEnabled nonReentrant {\\n    _depositAndJoin(pId, nftIds, true);\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function withdraw(uint256[] calldata nftIds) external override nonReentrant {\\n    address sender = msg.sender;\\n    for (uint256 i = 0; i < nftIds.length; ++i) {\\n      require(positions[nftIds[i]].owner == sender, 'withdraw: not owner');\\n      require(joinedPools[nftIds[i]].length() == 0, 'withdraw: not exited yet');\\n      delete positions[nftIds[i]];\\n      require(depositNFTs[sender].remove(nftIds[i]));\\n      nft.transferFrom(address(this), sender, nftIds[i]);\\n      emit Withdraw(sender, nftIds[i]);\\n    }\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function emergencyWithdraw(uint256[] calldata nftIds) external override nonReentrant {\\n    address sender = msg.sender;\\n    // save gas\\n    bool _emergencyEnabled = emergencyEnabled;\\n\\n    for (uint256 i = 0; i < nftIds.length; ++i) {\\n      require(positions[nftIds[i]].owner == sender, 'withdraw: not owner');\\n\\n      isEmergencyWithdrawnNFT[nftIds[i]] = true;\\n      uint256[] memory values = joinedPools[nftIds[i]].values();\\n      for (uint256 j = 0; j < values.length; ++j) {\\n        uint256 poolId = values[j];\\n        unchecked {\\n          pools[poolId].numStakes--;\\n        }\\n        delete stakes[nftIds[i]][poolId];\\n      }\\n      delete positions[nftIds[i]];\\n\\n      if (!_emergencyEnabled) {\\n        require(depositNFTs[sender].remove(nftIds[i]));\\n        for (uint256 j = 0; j < values.length; ++j) {\\n          uint256 poolId = values[j];\\n          require(joinedPools[nftIds[i]].remove(poolId));\\n        }\\n      }\\n\\n      nft.transferFrom(address(this), sender, nftIds[i]);\\n      emit EmergencyWithdraw(sender, nftIds[i]);\\n    }\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function emergencyWithdrawForOwner(\\n    address[] calldata rewards,\\n    uint256[] calldata amounts\\n  ) external override isAdmin checkLength(rewards.length, amounts.length) {\\n    for (uint256 i = 0; i < rewards.length; ++i) {\\n      _transferReward(rewards[i], msg.sender, amounts[i]);\\n      emit EmergencyWithdrawForOwner(rewards[i], amounts[i]);\\n    }\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function join(\\n    uint256 pId,\\n    uint256[] calldata nftIds,\\n    uint256[] calldata liqs\\n  ) external override nonReentrant checkLength(nftIds.length, liqs.length) {\\n    require(poolLength > pId, 'Pool not exists');\\n    LMPoolInfo storage pool = pools[pId];\\n    require(pool.startTime <= _getBlockTime() && _getBlockTime() < pool.endTime, 'Invalid time');\\n    for (uint256 i = 0; i < nftIds.length; ++i) {\\n      require(positions[nftIds[i]].owner == msg.sender, 'Not owner');\\n      positions[nftIds[i]].liquidity = helper.getLiq(address(nft), nftIds[i]);\\n      StakeInfo storage stake = stakes[nftIds[i]][pId];\\n      if (stake.liquidity == 0) {\\n        _join(nftIds[i], pId, liqs[i], pool);\\n      } else {\\n        _sync(nftIds[i], pId, liqs[i], pool);\\n      }\\n    }\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function exit(\\n    uint256 pId,\\n    uint256[] calldata nftIds,\\n    uint256[] calldata liqs\\n  ) external override nonReentrant checkLength(nftIds.length, liqs.length) {\\n    require(poolLength > pId, 'Pool not exists');\\n    for (uint256 i = 0; i < nftIds.length; ++i) {\\n      _exit(nftIds[i], pId, liqs[i], true);\\n    }\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function harvestMultiplePools(\\n    uint256[] calldata nftIds,\\n    bytes[] calldata datas\\n  ) external override nonReentrant checkLength(nftIds.length, datas.length) {\\n    for (uint256 i; i < nftIds.length; ++i) {\\n      require(positions[nftIds[i]].owner == msg.sender, 'harvest: not owner');\\n      HarvestData memory data = abi.decode(datas[i], (HarvestData));\\n      for (uint256 j; j < data.pIds.length; ++j) {\\n        _harvest(nftIds[i], data.pIds[j]);\\n      }\\n    }\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function removeLiquidity(\\n    uint256 nftId,\\n    uint128 liquidity,\\n    uint256 amount0Min,\\n    uint256 amount1Min,\\n    uint256 deadline,\\n    bool isReceiveNative,\\n    bool[2] calldata claimFeeAndRewards\\n  ) external override nonReentrant isSpecialFeaturesEnabled {\\n    require(_getBlockTime() <= deadline, 'removeLiquidity: expired');\\n    require(positions[nftId].owner == msg.sender, 'removeLiquidity: not owner');\\n\\n    uint256 posLiquidity = helper.getLiq(address(nft), nftId);\\n    require(liquidity > 0 && liquidity <= posLiquidity, 'removeLiquidity: invalid liquidity');\\n\\n    posLiquidity -= liquidity;\\n    positions[nftId].liquidity = posLiquidity;\\n\\n    uint256[] memory poolIds = joinedPools[nftId].values();\\n    for (uint256 i; i < poolIds.length; ) {\\n      uint256 stakedLiquidity = stakes[nftId][poolIds[i]].liquidity;\\n      uint256 deltaLiq = stakedLiquidity > posLiquidity ? stakedLiquidity - posLiquidity : 0;\\n\\n      if (deltaLiq > 0) _exit(nftId, poolIds[i], deltaLiq, claimFeeAndRewards[1]);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    (address token0, address token1) = helper.getPair(address(nft), nftId);\\n    _removeLiquidity(nftId, liquidity, deadline);\\n    if (claimFeeAndRewards[0]) _claimFee(nftId, deadline, false);\\n    _transferTokens(token0, token1, amount0Min, amount1Min, msg.sender, isReceiveNative);\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function claimFee(\\n    uint256[] calldata nftIds,\\n    uint256 amount0Min,\\n    uint256 amount1Min,\\n    address poolAddress,\\n    bool isReceiveNative,\\n    uint256 deadline\\n  ) external override nonReentrant isSpecialFeaturesEnabled {\\n    require(_getBlockTime() <= deadline, 'claimFee: expired');\\n\\n    uint256 length = nftIds.length;\\n    (address token0, address token1) = (\\n      address(IPoolStorage(poolAddress).token0()),\\n      address(IPoolStorage(poolAddress).token1())\\n    );\\n\\n    for (uint256 i; i < length; ) {\\n      require(positions[nftIds[i]].owner == msg.sender, 'claimFee: not owner');\\n\\n      (address nftToken0, address nftToken1) = helper.getPair(address(nft), nftIds[i]);\\n      require(nftToken0 == token0 && nftToken1 == token1, 'claimFee: token pair not match');\\n\\n      _claimFee(nftIds[i], deadline, true);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    _transferTokens(token0, token1, amount0Min, amount1Min, msg.sender, isReceiveNative);\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function getJoinedPools(\\n    uint256 nftId\\n  ) external view override returns (uint256[] memory poolIds) {\\n    uint256 length = joinedPools[nftId].length();\\n    poolIds = new uint256[](length);\\n    for (uint256 i = 0; i < length; ++i) {\\n      poolIds[i] = joinedPools[nftId].at(i);\\n    }\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function getJoinedPoolsInRange(\\n    uint256 nftId,\\n    uint256 fromIndex,\\n    uint256 toIndex\\n  ) external view returns (uint256[] memory poolIds) {\\n    require(fromIndex <= toIndex, 'fromIndex > toIndex');\\n    require(toIndex < joinedPools[nftId].length(), 'toIndex >= length');\\n    poolIds = new uint256[](toIndex - fromIndex + 1);\\n    for (uint256 index = fromIndex; index <= toIndex; ++index) {\\n      poolIds[index - fromIndex] = joinedPools[nftId].at(index);\\n    }\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function getUserInfo(\\n    uint256 nftId,\\n    uint256 pId\\n  )\\n    external\\n    view\\n    override\\n    returns (uint256 liquidity, uint256[] memory rewardPending, uint256[] memory rewardLast)\\n  {\\n    LMPoolInfo storage pool = pools[pId];\\n    StakeInfo storage stake = stakes[nftId][pId];\\n\\n    require(stake.liquidity > 0, 'getUserInfo: not joined yet');\\n\\n    rewardPending = new uint256[](pool.rewards.length);\\n    rewardLast = new uint256[](pool.rewards.length);\\n\\n    RewardCalculationData memory data = getRewardCalculationData(nftId, pId);\\n    for (uint256 i = 0; i < pool.rewards.length; ++i) {\\n      uint256 rewardHarvest = _calculateRewardHarvest(\\n        stake.liquidity,\\n        pool.rewards[i].rewardUnclaimed,\\n        data.totalSecondsUnclaimed,\\n        data.secondsPerLiquidity\\n      );\\n      uint256 rewardCollected = _calculateRewardCollected(\\n        stake.rewardHarvested[i] + rewardHarvest,\\n        data.vestingVolume,\\n        stake.rewardLast[i]\\n      );\\n      rewardPending[i] = stake.rewardPending[i] + rewardCollected;\\n      rewardLast[i] = stake.rewardLast[i];\\n    }\\n    liquidity = stake.liquidity;\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function getPoolInfo(\\n    uint256 pId\\n  )\\n    external\\n    view\\n    override\\n    returns (\\n      address poolAddress,\\n      uint32 startTime,\\n      uint32 endTime,\\n      uint256 totalSecondsClaimed,\\n      uint256 feeTarget,\\n      uint256 numStakes,\\n      //index reward => reward data\\n      address[] memory rewardTokens,\\n      uint256[] memory rewardUnclaimeds\\n    )\\n  {\\n    LMPoolInfo storage pool = pools[pId];\\n\\n    poolAddress = pool.poolAddress;\\n    startTime = pool.startTime;\\n    endTime = pool.endTime;\\n    totalSecondsClaimed = pool.totalSecondsClaimed;\\n    feeTarget = pool.feeTarget;\\n    numStakes = pool.numStakes;\\n\\n    uint256 length = pool.rewards.length;\\n    rewardTokens = new address[](length);\\n    rewardUnclaimeds = new uint256[](length);\\n    for (uint256 i = 0; i < length; ++i) {\\n      rewardTokens[i] = pool.rewards[i].rewardToken;\\n      rewardUnclaimeds[i] = pool.rewards[i].rewardUnclaimed;\\n    }\\n  }\\n\\n  /// @inheritdoc IKyberSwapElasticLM\\n  function getDepositedNFTs(address user) external view returns (uint256[] memory listNFTs) {\\n    listNFTs = depositNFTs[user].values();\\n  }\\n\\n  /**\\n   * INTERNAL FUNCTIONS *************************\\n   */\\n\\n  /**\\n   * @dev Deposit NFTs to the LM contract, and join farming pool if needed\\n   * @param pId pool id to join farm, if isJoining = true\\n   * @param nftIds list of NFT ids to deposit\\n   * @param isJoining whether to join farm with pId\\n   */\\n  function _depositAndJoin(uint256 pId, uint256[] memory nftIds, bool isJoining) internal {\\n    require(!emergencyEnabled, 'Not allowed to deposit');\\n\\n    if (isJoining) {\\n      // verify if pool's state is valid\\n      require(poolLength > pId, 'Pool not exists');\\n      uint32 _blockTime = _getBlockTime();\\n      require(\\n        pools[pId].startTime <= _blockTime && _blockTime < pools[pId].endTime,\\n        'Invalid time'\\n      );\\n    }\\n\\n    address sender = msg.sender;\\n\\n    for (uint256 i = 0; i < nftIds.length; ) {\\n      // if the nft has used emergency withdraw before, not allow to re-deposit\\n      require(!isEmergencyWithdrawnNFT[nftIds[i]], 'Not allowed to deposit');\\n      // and nft to the list and deposit nft to the LM contract\\n      require(depositNFTs[sender].add(nftIds[i]));\\n      nft.transferFrom(sender, address(this), nftIds[i]);\\n      emit Deposit(sender, nftIds[i]);\\n      // update position data\\n      positions[nftIds[i]].owner = sender;\\n      uint128 liquidity = helper.getLiq(address(nft), nftIds[i]);\\n      positions[nftIds[i]].liquidity = liquidity;\\n      // join full liquidity to the farm if joining is enabled\\n      if (isJoining) {\\n        _join(nftIds[i], pId, liquidity, pools[pId]);\\n      }\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev join pool first time\\n   * @param nftId NFT id to join\\n   * @param pId pool id to join\\n   * @param liq liquidity amount to join\\n   * @param pool LM pool\\n   */\\n  function _join(uint256 nftId, uint256 pId, uint256 liq, LMPoolInfo storage pool) internal {\\n    PositionInfo storage position = positions[nftId];\\n    StakeInfo storage stake = stakes[nftId][pId];\\n    require(helper.checkPool(pool.poolAddress, address(nft), nftId), 'join: invalid pool');\\n    require(liq != 0 && liq <= position.liquidity, 'join: invalid liq');\\n\\n    stake.secondsPerLiquidityLast = helper.getActiveTime(pool.poolAddress, address(nft), nftId);\\n    stake.rewardLast = new uint256[](pool.rewards.length);\\n    stake.rewardPending = new uint256[](pool.rewards.length);\\n    stake.rewardHarvested = new uint256[](pool.rewards.length);\\n    if (pool.feeTarget != 0) {\\n      stake.feeFirst = helper.getSignedFee(address(nft), nftId);\\n    }\\n    stake.liquidity = liq;\\n    pool.numStakes++;\\n\\n    require(joinedPools[nftId].add(pId), 'Fail to add joinedPools');\\n\\n    emit Join(nftId, pId, liq);\\n  }\\n\\n  /**\\n   * @dev Increase liquidity in pool\\n   * @param nftId NFT id to sync\\n   * @param pId pool id to sync\\n   * @param liq liquidity amount to increase\\n   * @param pool LM pool\\n   */\\n  function _sync(uint256 nftId, uint256 pId, uint256 liq, LMPoolInfo storage pool) internal {\\n    PositionInfo storage position = positions[nftId];\\n    StakeInfo storage stake = stakes[nftId][pId];\\n\\n    require(liq != 0 && liq + stake.liquidity <= position.liquidity, 'sync: invalid liq');\\n\\n    RewardCalculationData memory data = getRewardCalculationData(nftId, pId);\\n\\n    for (uint256 i = 0; i < pool.rewards.length; ++i) {\\n      uint256 rewardHarvest = _calculateRewardHarvest(\\n        stake.liquidity,\\n        pool.rewards[i].rewardUnclaimed,\\n        data.totalSecondsUnclaimed,\\n        data.secondsPerLiquidity\\n      );\\n\\n      if (rewardHarvest != 0) {\\n        stake.rewardHarvested[i] += rewardHarvest;\\n        pool.rewards[i].rewardUnclaimed -= rewardHarvest;\\n      }\\n\\n      uint256 rewardCollected = _calculateRewardCollected(\\n        stake.rewardHarvested[i],\\n        data.vestingVolume,\\n        stake.rewardLast[i]\\n      );\\n\\n      if (rewardCollected != 0) {\\n        stake.rewardLast[i] += rewardCollected;\\n        stake.rewardPending[i] += rewardCollected;\\n      }\\n    }\\n\\n    pool.totalSecondsClaimed += data.secondsClaim;\\n    stake.secondsPerLiquidityLast = data.secondsPerLiquidityNow;\\n    stake.feeFirst = _calculateFeeFirstAfterJoin(\\n      stake.feeFirst,\\n      data.feeNow,\\n      pool.feeTarget,\\n      stake.liquidity,\\n      liq,\\n      nftId\\n    );\\n    stake.liquidity += liq;\\n    emit SyncLiq(nftId, pId, liq);\\n  }\\n\\n  /**\\n   * @dev Exit pool\\n   * @param nftId NFT id to exit\\n   * @param pId pool id to exit\\n   * @param liq liquidity amount to exit\\n   * @param claimReward transfer reward or not\\n   */\\n  function _exit(uint256 nftId, uint256 pId, uint256 liq, bool claimReward) internal {\\n    LMPoolInfo storage pool = pools[pId];\\n    address pOwner = positions[nftId].owner;\\n    StakeInfo storage stake = stakes[nftId][pId];\\n\\n    require(\\n      pOwner == msg.sender || (_getBlockTime() > pool.endTime && operators[msg.sender]),\\n      'exit: not owner or pool not ended'\\n    );\\n\\n    uint256 liquidityOld = stake.liquidity;\\n    require(liq != 0 && liq <= liquidityOld, 'exit: invalid liq');\\n\\n    uint256 liquidityNew = liquidityOld - liq;\\n    RewardCalculationData memory data = getRewardCalculationData(nftId, pId);\\n\\n    pool.totalSecondsClaimed += data.secondsClaim;\\n    stake.secondsPerLiquidityLast = data.secondsPerLiquidityNow;\\n    stake.liquidity = liquidityNew;\\n    for (uint256 i = 0; i < pool.rewards.length; ++i) {\\n      uint256 rewardHarvest = _calculateRewardHarvest(\\n        liquidityOld,\\n        pool.rewards[i].rewardUnclaimed,\\n        data.totalSecondsUnclaimed,\\n        data.secondsPerLiquidity\\n      );\\n\\n      if (rewardHarvest != 0) {\\n        stake.rewardHarvested[i] += rewardHarvest;\\n        pool.rewards[i].rewardUnclaimed -= rewardHarvest;\\n      }\\n\\n      uint256 rewardCollected = _calculateRewardCollected(\\n        stake.rewardHarvested[i],\\n        data.vestingVolume,\\n        stake.rewardLast[i]\\n      );\\n\\n      uint256 rewardPending = stake.rewardPending[i];\\n      if (rewardCollected != 0) {\\n        stake.rewardLast[i] += rewardCollected;\\n        rewardPending += rewardCollected;\\n      }\\n\\n      if (rewardPending != 0) {\\n        if (claimReward) {\\n          stake.rewardPending[i] = 0;\\n          _transferReward(pool.rewards[i].rewardToken, pOwner, rewardPending);\\n          emit Harvest(nftId, pOwner, pool.rewards[i].rewardToken, rewardPending);\\n        } else {\\n          stake.rewardPending[i] = rewardPending;\\n        }\\n      }\\n    }\\n    if (liquidityNew == 0) {\\n      delete stakes[nftId][pId];\\n      pool.numStakes--;\\n\\n      require(joinedPools[nftId].remove(pId), 'Fail to remove joinedPools');\\n    }\\n    emit Exit(msg.sender, nftId, pId, liq);\\n  }\\n\\n  /**\\n   * @dev Harvest reward\\n   * @param nftId NFT id to harvest\\n   * @param pId pool id to harvest\\n   */\\n  function _harvest(uint256 nftId, uint256 pId) internal {\\n    require(poolLength > pId, 'Pool not exists');\\n    LMPoolInfo storage pool = pools[pId];\\n    address pOwner = positions[nftId].owner;\\n    StakeInfo storage stake = stakes[nftId][pId];\\n\\n    require(stake.liquidity > 0, 'harvest: not joined yet');\\n\\n    RewardCalculationData memory data = getRewardCalculationData(nftId, pId);\\n\\n    pool.totalSecondsClaimed += data.secondsClaim;\\n    stake.secondsPerLiquidityLast = data.secondsPerLiquidityNow;\\n    for (uint256 i = 0; i < pool.rewards.length; ++i) {\\n      uint256 rewardHarvest = _calculateRewardHarvest(\\n        stake.liquidity,\\n        pool.rewards[i].rewardUnclaimed,\\n        data.totalSecondsUnclaimed,\\n        data.secondsPerLiquidity\\n      );\\n\\n      if (rewardHarvest != 0) {\\n        stake.rewardHarvested[i] += rewardHarvest;\\n        pool.rewards[i].rewardUnclaimed -= rewardHarvest;\\n      }\\n\\n      uint256 rewardCollected = _calculateRewardCollected(\\n        stake.rewardHarvested[i],\\n        data.vestingVolume,\\n        stake.rewardLast[i]\\n      );\\n\\n      uint256 rewardPending = stake.rewardPending[i] + rewardCollected;\\n      if (rewardPending != 0) {\\n        if (rewardCollected != 0) {\\n          stake.rewardLast[i] += rewardCollected;\\n        }\\n        stake.rewardPending[i] = 0;\\n        _transferReward(pool.rewards[i].rewardToken, pOwner, rewardPending);\\n        emit Harvest(nftId, pOwner, pool.rewards[i].rewardToken, rewardPending);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev transfer reward\\n   */\\n  function _transferReward(address _token, address _account, uint256 _amount) internal {\\n    if (_token == address(0)) {\\n      (bool success, ) = payable(_account).call{value: _amount}('');\\n      require(success, 'transfer reward token failed');\\n    } else {\\n      IERC20Metadata(_token).safeTransfer(_account, _amount);\\n    }\\n  }\\n\\n  /// @dev remove liquidiy of nft from posManager\\n  /// @param nftId nft's id\\n  /// @param liquidity liquidity amount to remove\\n  /// @param deadline removeLiquidity deadline\\n  function _removeLiquidity(uint256 nftId, uint128 liquidity, uint256 deadline) internal {\\n    IBasePositionManager.RemoveLiquidityParams memory removeLiq = IBasePositionManager\\n      .RemoveLiquidityParams({\\n        tokenId: nftId,\\n        liquidity: liquidity,\\n        amount0Min: 0,\\n        amount1Min: 0,\\n        deadline: deadline\\n      });\\n\\n    IBasePositionManager(address(nft)).removeLiquidity(removeLiq);\\n  }\\n\\n  /// @dev claim fee of nft from posManager\\n  /// @param nftId nft's id\\n  /// @param deadline claimFee deadline\\n  /// @param syncFee is need to sync new fee or not\\n  function _claimFee(uint256 nftId, uint256 deadline, bool syncFee) internal {\\n    if (syncFee) {\\n      IBasePositionManager(address(nft)).syncFeeGrowth(nftId);\\n    }\\n\\n    IBasePositionManager.BurnRTokenParams memory burnRToken = IBasePositionManager\\n      .BurnRTokenParams({tokenId: nftId, amount0Min: 0, amount1Min: 0, deadline: deadline});\\n\\n    IBasePositionManager(address(nft)).burnRTokens(burnRToken);\\n  }\\n\\n  /// @dev transfer tokens from removeLiquidity (and burnRToken if any) to receiver\\n  /// @param token0 address of token0\\n  /// @param token1 address of token1\\n  /// @param amount0Min minimum amount of token0 should receive\\n  /// @param amount1Min minimum amount of token1 should receive\\n  /// @param receiver receiver of tokens\\n  /// @param isReceiveNative should unwrap wrapped native or not\\n  function _transferTokens(\\n    address token0,\\n    address token1,\\n    uint256 amount0Min,\\n    uint256 amount1Min,\\n    address receiver,\\n    bool isReceiveNative\\n  ) internal {\\n    IBasePositionManager posManager = IBasePositionManager(address(nft));\\n\\n    if (isReceiveNative) {\\n      // expect to receive in native token\\n      if (weth == token0) {\\n        // receive in native for token0\\n        posManager.unwrapWeth(amount0Min, receiver);\\n        posManager.transferAllTokens(token1, amount1Min, receiver);\\n        return;\\n      }\\n      if (weth == token1) {\\n        // receive in native for token1\\n        posManager.transferAllTokens(token0, amount0Min, receiver);\\n        posManager.unwrapWeth(amount1Min, receiver);\\n        return;\\n      }\\n    }\\n\\n    posManager.transferAllTokens(token0, amount0Min, receiver);\\n    posManager.transferAllTokens(token1, amount1Min, receiver);\\n  }\\n\\n  /**\\n   * HELPER MATH FUNCTIONS *************************\\n   */\\n  function getRewardCalculationData(\\n    uint256 nftId,\\n    uint256 pId\\n  ) public view override returns (RewardCalculationData memory data) {\\n    LMPoolInfo storage pool = pools[pId];\\n    StakeInfo storage stake = stakes[nftId][pId];\\n\\n    data.secondsPerLiquidityNow = helper.getActiveTime(pool.poolAddress, address(nft), nftId);\\n    data.feeNow = helper.getSignedFeePool(pool.poolAddress, address(nft), nftId);\\n    data.vestingVolume = _calculateVestingVolume(data.feeNow, stake.feeFirst, pool.feeTarget);\\n    data.totalSecondsUnclaimed = _calculateSecondsUnclaimed(\\n      pool.startTime,\\n      pool.endTime,\\n      pool.totalSecondsClaimed\\n    );\\n    unchecked {\\n      data.secondsPerLiquidity = data.secondsPerLiquidityNow - stake.secondsPerLiquidityLast;\\n    }\\n    data.secondsClaim = stake.liquidity * data.secondsPerLiquidity;\\n  }\\n\\n  /**\\n   * @dev feeFirst = (liq * max(feeNow - feeTarget, feeFirst) + liqAdd * feeNow) / liqNew\\n   */\\n  function _calculateFeeFirstAfterJoin(\\n    int256 feeFirst,\\n    int256 feeNow,\\n    uint256 feeTarget,\\n    uint256 liquidity,\\n    uint256 liquidityAdd,\\n    uint256 nftId\\n  ) internal view returns (int256) {\\n    if (feeTarget == 0) {\\n      return 0;\\n    }\\n    int256 feeFirstCurrent = feeNow - int256(feeTarget) < feeFirst\\n      ? feeFirst\\n      : feeNow - int256(feeTarget);\\n    int256 numerator = int256(liquidity) *\\n      feeFirstCurrent +\\n      int256(liquidityAdd) *\\n      helper.getSignedFee(address(nft), nftId);\\n    int256 denominator = int256(liquidity + liquidityAdd);\\n    return numerator / denominator;\\n  }\\n\\n  /**\\n   * @dev vesting = min((feeNow - feeFirst) / feeTarget, 1)\\n   */\\n  function _calculateVestingVolume(\\n    int256 feeNow,\\n    int256 feeFirst,\\n    uint256 feeTarget\\n  ) internal pure returns (uint256) {\\n    if (feeTarget == 0) {\\n      return PRECISION;\\n    }\\n    uint256 feeInside = uint256(feeNow - feeFirst);\\n    return KSMath.min((feeInside * PRECISION) / feeTarget, PRECISION);\\n  }\\n\\n  /**\\n   * @dev secondsUnclaimed = (max(currentTime, endTime) - startTime) - secondsClaimed\\n   */\\n  function _calculateSecondsUnclaimed(\\n    uint256 startTime,\\n    uint256 endTime,\\n    uint256 totalSecondsClaimed\\n  ) internal view returns (uint256) {\\n    uint256 totalSeconds = KSMath.max(_getBlockTime(), endTime) - startTime;\\n    uint256 totalSecondsScaled = totalSeconds * (1 << 96);\\n    return totalSecondsScaled > totalSecondsClaimed ? totalSecondsScaled - totalSecondsClaimed : 0;\\n  }\\n\\n  /**\\n   * @dev rewardHarvested = L * rewardRate * secondsPerLiquidity\\n   */\\n  function _calculateRewardHarvest(\\n    uint256 liquidity,\\n    uint256 rewardUnclaimed,\\n    uint256 totalSecondsUnclaimed,\\n    uint256 secondsPerLiquidity\\n  ) internal pure returns (uint256) {\\n    return (liquidity * rewardUnclaimed * secondsPerLiquidity) / totalSecondsUnclaimed;\\n  }\\n\\n  /**\\n   * @dev rewardCollected = Max(rewardHarvested * vestingVolume - rewardLast, 0);\\n   */\\n  function _calculateRewardCollected(\\n    uint256 rewardHarvested,\\n    uint256 vestingVolume,\\n    uint256 rewardLast\\n  ) internal pure returns (uint256) {\\n    uint256 rewardNow = (rewardHarvested * vestingVolume) / PRECISION;\\n    return rewardNow > rewardLast ? rewardNow - rewardLast : 0;\\n  }\\n\\n  function _getBlockTime() internal view virtual returns (uint32) {\\n    return uint32(block.timestamp);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/KSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nlibrary KSMath {\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a >= b ? b : a;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityMining/IKyberSwapElasticLM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IKyberSwapElasticLMEvents} from './IKyberSwapElasticLMEvents.sol';\\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\n\\ninterface IKyberSwapElasticLM is IKyberSwapElasticLMEvents {\\n  struct RewardData {\\n    address rewardToken;\\n    uint256 rewardUnclaimed;\\n  }\\n\\n  struct LMPoolInfo {\\n    address poolAddress;\\n    uint32 startTime;\\n    uint32 endTime;\\n    uint256 totalSecondsClaimed; // scaled by (1 << 96)\\n    RewardData[] rewards;\\n    uint256 feeTarget;\\n    uint256 numStakes;\\n  }\\n\\n  struct PositionInfo {\\n    address owner;\\n    uint256 liquidity;\\n  }\\n\\n  struct StakeInfo {\\n    uint128 secondsPerLiquidityLast;\\n    uint256[] rewardLast;\\n    uint256[] rewardPending;\\n    uint256[] rewardHarvested;\\n    int256 feeFirst;\\n    uint256 liquidity;\\n  }\\n\\n  // input data in harvestMultiplePools function\\n  struct HarvestData {\\n    uint256[] pIds;\\n  }\\n\\n  // avoid stack too deep error\\n  struct RewardCalculationData {\\n    uint128 secondsPerLiquidityNow;\\n    int256 feeNow;\\n    uint256 vestingVolume;\\n    uint256 totalSecondsUnclaimed;\\n    uint256 secondsPerLiquidity;\\n    uint256 secondsClaim; // scaled by (1 << 96)\\n  }\\n\\n  /**\\n   * @dev Add new pool to LM\\n   * @param poolAddr pool address\\n   * @param startTime start time of liquidity mining\\n   * @param endTime end time of liquidity mining\\n   * @param rewardTokens reward token list for pool\\n   * @param rewardAmounts reward amount of list token\\n   * @param feeTarget fee target for pool\\n   *\\n   */\\n  function addPool(\\n    address poolAddr,\\n    uint32 startTime,\\n    uint32 endTime,\\n    address[] calldata rewardTokens,\\n    uint256[] calldata rewardAmounts,\\n    uint256 feeTarget\\n  ) external;\\n\\n  /**\\n   * @dev Renew a pool to start another LM program\\n   * @param pId pool id to update\\n   * @param startTime start time of liquidity mining\\n   * @param endTime end time of liquidity mining\\n   * @param rewardAmounts reward amount of list token\\n   * @param feeTarget fee target for pool\\n   *\\n   */\\n  function renewPool(\\n    uint256 pId,\\n    uint32 startTime,\\n    uint32 endTime,\\n    uint256[] calldata rewardAmounts,\\n    uint256 feeTarget\\n  ) external;\\n\\n  /**\\n   * @dev Deposit NFT\\n   * @param nftIds list nft id\\n   *\\n   */\\n  function deposit(uint256[] calldata nftIds) external;\\n\\n  /**\\n   * @dev Deposit NFTs into the pool and join farms if applicable\\n   * @param pId pool id to join farm\\n   * @param nftIds List of NFT ids from BasePositionManager, should match with the pId\\n   *\\n   */\\n  function depositAndJoin(uint256 pId, uint256[] calldata nftIds) external;\\n\\n  /**\\n   * @dev Withdraw NFT, must exit all pool before call.\\n   * @param nftIds list nft id\\n   *\\n   */\\n  function withdraw(uint256[] calldata nftIds) external;\\n\\n  /**\\n   * @dev Join pools\\n   * @param pId pool id to join\\n   * @param nftIds nfts to join\\n   * @param liqs list liquidity value to join each nft\\n   *\\n   */\\n  function join(uint256 pId, uint256[] calldata nftIds, uint256[] calldata liqs) external;\\n\\n  /**\\n   * @dev Exit from pools\\n   * @param pId pool ids to exit\\n   * @param nftIds list nfts id\\n   * @param liqs list liquidity value to exit from each nft\\n   *\\n   */\\n  function exit(uint256 pId, uint256[] calldata nftIds, uint256[] calldata liqs) external;\\n\\n  /**\\n   * @dev Claim rewards for a list of pools for a list of nft positions\\n   * @param nftIds List of NFT ids to harvest\\n   * @param datas List of pool ids to harvest for each nftId, encoded into bytes\\n   */\\n  function harvestMultiplePools(uint256[] calldata nftIds, bytes[] calldata datas) external;\\n\\n  /**\\n   * @dev remove liquidity from elastic for a list of nft position, also update on farm\\n   * @param nftId to remove\\n   * @param liquidity liquidity amount to remove from nft\\n   * @param amount0Min expected min amount of token0 should receive\\n   * @param amount1Min expected min amount of token1 should receive\\n   * @param deadline deadline of this tx\\n   * @param isReceiveNative should unwrap native or not\\n   * @param claimFeeAndRewards also claim LP Fee and farm rewards\\n   */\\n  function removeLiquidity(\\n    uint256 nftId,\\n    uint128 liquidity,\\n    uint256 amount0Min,\\n    uint256 amount1Min,\\n    uint256 deadline,\\n    bool isReceiveNative,\\n    bool[2] calldata claimFeeAndRewards\\n  ) external;\\n\\n  /**\\n   * @dev Claim fee from elastic for a list of nft positions\\n   * @param nftIds List of NFT ids to claim\\n   * @param amount0Min expected min amount of token0 should receive\\n   * @param amount1Min expected min amount of token1 should receive\\n   * @param poolAddress address of Elastic pool of those nfts\\n   * @param isReceiveNative should unwrap native or not\\n   * @param deadline deadline of this tx\\n   */\\n  function claimFee(\\n    uint256[] calldata nftIds,\\n    uint256 amount0Min,\\n    uint256 amount1Min,\\n    address poolAddress,\\n    bool isReceiveNative,\\n    uint256 deadline\\n  ) external;\\n\\n  /**\\n   * @dev Operator only. Call to withdraw all reward from list pools.\\n   * @param rewards list reward address erc20 token\\n   * @param amounts amount to withdraw\\n   *\\n   */\\n  function emergencyWithdrawForOwner(\\n    address[] calldata rewards,\\n    uint256[] calldata amounts\\n  ) external;\\n\\n  /**\\n   * @dev Withdraw NFT, can call any time, reward will be reset. Must enable this func by operator\\n   * @param pIds list pool to withdraw\\n   *\\n   */\\n  function emergencyWithdraw(uint256[] calldata pIds) external;\\n\\n  /**\\n   * @dev get list of pool that this nft joined\\n   * @param nftId to get\\n   */\\n  function getJoinedPools(uint256 nftId) external view returns (uint256[] memory poolIds);\\n\\n  /**\\n   * @dev get list of pool that this nft joined, only in a specific range\\n   * @param nftId to get\\n   * @param fromIndex index from\\n   * @param toIndex index to\\n   */\\n  function getJoinedPoolsInRange(\\n    uint256 nftId,\\n    uint256 fromIndex,\\n    uint256 toIndex\\n  ) external view returns (uint256[] memory poolIds);\\n\\n  /**\\n   * @dev get user's info (staked info) of a nft in a pool\\n   * @param nftId to get\\n   * @param pId to get\\n   */\\n  function getUserInfo(\\n    uint256 nftId,\\n    uint256 pId\\n  )\\n    external\\n    view\\n    returns (uint256 liquidity, uint256[] memory rewardPending, uint256[] memory rewardLast);\\n\\n  /**\\n   * @dev get pool info\\n   * @param pId to get\\n   */\\n  function getPoolInfo(\\n    uint256 pId\\n  )\\n    external\\n    view\\n    returns (\\n      address poolAddress,\\n      uint32 startTime,\\n      uint32 endTime,\\n      uint256 totalSecondsClaimed,\\n      uint256 feeTarget,\\n      uint256 numStakes,\\n      //index reward => reward data\\n      address[] memory rewardTokens,\\n      uint256[] memory rewardUnclaimeds\\n    );\\n\\n  /**\\n   * @dev get list of deposited nfts of an address\\n   * @param user address of user to get\\n   */\\n  function getDepositedNFTs(address user) external view returns (uint256[] memory listNFTs);\\n\\n  function nft() external view returns (IERC721);\\n\\n  function poolLength() external view returns (uint256);\\n\\n  function getRewardCalculationData(\\n    uint256 nftId,\\n    uint256 pId\\n  ) external view returns (RewardCalculationData memory data);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityMining/IKSElasticLMHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IKSElasticLMHelper {\\n  function checkPool(\\n    address pAddress,\\n    address nftContract,\\n    uint256 nftId\\n  ) external view returns (bool);\\n\\n  /// @dev use virtual to be overrided to mock data for fuzz tests\\n  function getActiveTime(\\n    address pAddr,\\n    address nftContract,\\n    uint256 nftId\\n  ) external view returns (uint128);\\n\\n  function getSignedFee(address nftContract, uint256 nftId) external view returns (int256);\\n\\n  function getSignedFeePool(\\n    address poolAddress,\\n    address nftContract,\\n    uint256 nftId\\n  ) external view returns (int256);\\n\\n  function getLiq(address nftContract, uint256 nftId) external view returns (uint128);\\n\\n  function getPair(address nftContract, uint256 nftId) external view returns (address, address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityMining/IBasePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface IBasePositionManager {\\n  struct Position {\\n    // the nonce for permits\\n    uint96 nonce;\\n    // the address that is approved for spending this token\\n    address operator;\\n    // the ID of the pool with which this token is connected\\n    uint80 poolId;\\n    // the tick range of the position\\n    int24 tickLower;\\n    int24 tickUpper;\\n    // the liquidity of the position\\n    uint128 liquidity;\\n    // the current rToken that the position owed\\n    uint256 rTokenOwed;\\n    // fee growth per unit of liquidity as of the last update to liquidity\\n    uint256 feeGrowthInsideLast;\\n  }\\n\\n  struct PoolInfo {\\n    address token0;\\n    uint16 fee;\\n    address token1;\\n  }\\n\\n  struct MintParams {\\n    address token0;\\n    address token1;\\n    uint24 fee;\\n    int24 tickLower;\\n    int24 tickUpper;\\n    int24[2] ticksPrevious;\\n    uint256 amount0Desired;\\n    uint256 amount1Desired;\\n    uint256 amount0Min;\\n    uint256 amount1Min;\\n    address recipient;\\n    uint256 deadline;\\n  }\\n\\n  struct IncreaseLiquidityParams {\\n    uint256 tokenId;\\n    uint256 amount0Desired;\\n    uint256 amount1Desired;\\n    uint256 amount0Min;\\n    uint256 amount1Min;\\n    uint256 deadline;\\n  }\\n\\n  struct RemoveLiquidityParams {\\n    uint256 tokenId;\\n    uint128 liquidity;\\n    uint256 amount0Min;\\n    uint256 amount1Min;\\n    uint256 deadline;\\n  }\\n\\n  struct BurnRTokenParams {\\n    uint256 tokenId;\\n    uint256 amount0Min;\\n    uint256 amount1Min;\\n    uint256 deadline;\\n  }\\n\\n  function positions(\\n    uint256 tokenId\\n  ) external view returns (Position memory pos, PoolInfo memory info);\\n\\n  function addressToPoolId(address pool) external view returns (uint80);\\n\\n  function WETH() external view returns (address);\\n\\n  function mint(\\n    MintParams calldata params\\n  )\\n    external\\n    payable\\n    returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\\n\\n  function addLiquidity(\\n    IncreaseLiquidityParams calldata params\\n  )\\n    external\\n    payable\\n    returns (uint128 liquidity, uint256 amount0, uint256 amount1, uint256 additionalRTokenOwed);\\n\\n  function removeLiquidity(\\n    RemoveLiquidityParams calldata params\\n  ) external returns (uint256 amount0, uint256 amount1, uint256 additionalRTokenOwed);\\n\\n  function syncFeeGrowth(uint256 tokenId) external returns (uint256 additionalRTokenOwed);\\n\\n  function burnRTokens(\\n    BurnRTokenParams calldata params\\n  ) external returns (uint256 rTokenQty, uint256 amount0, uint256 amount1);\\n\\n  function transferAllTokens(address token, uint256 minAmount, address recipient) external payable;\\n\\n  function unwrapWeth(uint256 minAmount, address recipient) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityMining/IPoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {IFactory} from './IFactory.sol';\\n\\ninterface IPoolStorage {\\n  struct PoolData {\\n    uint160 sqrtP;\\n    int24 nearestCurrentTick;\\n    int24 currentTick;\\n    bool locked;\\n    uint128 baseL;\\n    uint128 reinvestL;\\n    uint128 reinvestLLast;\\n    uint256 feeGrowthGlobal;\\n    uint128 secondsPerLiquidityGlobal;\\n    uint32 secondsPerLiquidityUpdateTime;\\n  }\\n\\n  // data stored for each initialized individual tick\\n  struct TickData {\\n    // gross liquidity of all positions in tick\\n    uint128 liquidityGross;\\n    // liquidity quantity to be added | removed when tick is crossed up | down\\n    int128 liquidityNet;\\n    // fee growth per unit of liquidity on the other side of this tick (relative to current tick)\\n    // only has relative meaning, not absolute \u2014 the value depends on when the tick is initialized\\n    uint256 feeGrowthOutside;\\n    // seconds spent on the other side of this tick (relative to current tick)\\n    // only has relative meaning, not absolute \u2014 the value depends on when the tick is initialized\\n    uint128 secondsPerLiquidityOutside;\\n  }\\n\\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\\n  /// @return The contract address\\n  function factory() external view returns (IFactory);\\n\\n  /// @notice The first of the two tokens of the pool, sorted by address\\n  /// @return The token contract address\\n  function token0() external view returns (IERC20);\\n\\n  /// @notice The second of the two tokens of the pool, sorted by address\\n  /// @return The token contract address\\n  function token1() external view returns (IERC20);\\n\\n  /// @notice The fee to be charged for a swap in basis points\\n  /// @return The swap fee in basis points\\n  function swapFeeBps() external view returns (uint16);\\n\\n  /// @notice The pool tick distance\\n  /// @dev Ticks can only be initialized and used at multiples of this value\\n  /// It remains an int24 to avoid casting even though it is >= 1.\\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\\n  /// @return The tick distance\\n  function tickDistance() external view returns (int24);\\n\\n  /// @notice Maximum gross liquidity that an initialized tick can have\\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n  /// @return The max amount of liquidity per tick\\n  function maxTickLiquidity() external view returns (uint128);\\n\\n  /// @notice Look up information about a specific tick in the pool\\n  /// @param tick The tick to look up\\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\\n  /// secondsPerLiquidityOutside the seconds spent on the other side of the tick relative to the current tick\\n  function ticks(int24 tick)\\n    external\\n    view\\n    returns (\\n      uint128 liquidityGross,\\n      int128 liquidityNet,\\n      uint256 feeGrowthOutside,\\n      uint128 secondsPerLiquidityOutside\\n    );\\n\\n  /// @notice Returns the previous and next initialized ticks of a specific tick\\n  /// @dev If specified tick is uninitialized, the returned values are zero.\\n  /// @param tick The tick to look up\\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\\n\\n  /// @notice Returns the information about a position by the position's key\\n  /// @return liquidity the liquidity quantity of the position\\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\\n  function getPositions(\\n    address owner,\\n    int24 tickLower,\\n    int24 tickUpper\\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\\n\\n  /// @notice Fetches the pool's prices, ticks and lock status\\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\\n  /// @return currentTick pool's current tick\\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\\n  /// @return locked true if pool is locked, false otherwise\\n  function getPoolState()\\n    external\\n    view\\n    returns (\\n      uint160 sqrtP,\\n      int24 currentTick,\\n      int24 nearestCurrentTick,\\n      bool locked\\n    );\\n\\n  /// @notice Fetches the pool's liquidity values\\n  /// @return baseL pool's base liquidity without reinvest liqudity\\n  /// @return reinvestL the liquidity is reinvested into the pool\\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\\n  function getLiquidityState()\\n    external\\n    view\\n    returns (\\n      uint128 baseL,\\n      uint128 reinvestL,\\n      uint128 reinvestLLast\\n    );\\n\\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\\n  function getFeeGrowthGlobal() external view returns (uint256);\\n\\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\\n  function getSecondsPerLiquidityData()\\n    external\\n    view\\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\\n\\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\\n  /// @param tickLower The lower tick (of a position)\\n  /// @param tickUpper The upper tick (of a position)\\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\\n  /// between the 2 ticks, per unit of liquidity.\\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\\n    external\\n    view\\n    returns (uint128 secondsPerLiquidityInside);\\n}\\n\"\r\n    },\r\n    \"contracts/liquidityMining/base/KSAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nabstract contract KSAdmin {\\n  address public admin;\\n  mapping(address => bool) public operators; // address => bool\\n\\n  event TransferAdmin(address indexed admin);\\n  event UpdateOperator(address indexed user, bool grantOrRevoke);\\n\\n  modifier isAdmin() {\\n    require(msg.sender == admin, 'forbidden');\\n    _;\\n  }\\n\\n  modifier isOperator() {\\n    require(operators[msg.sender], 'forbidden');\\n    _;\\n  }\\n\\n  constructor() {\\n    admin = msg.sender;\\n    operators[msg.sender] = true;\\n  }\\n\\n  function transferAdmin(address _admin) external virtual isAdmin {\\n    require(_admin != address(0), 'forbidden');\\n\\n    admin = _admin;\\n\\n    emit TransferAdmin(_admin);\\n  }\\n\\n  function updateOperator(address user, bool grantOrRevoke) external isAdmin {\\n    operators[user] = grantOrRevoke;\\n\\n    emit UpdateOperator(user, grantOrRevoke);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityMining/IKyberSwapElasticLMEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {IKSElasticLMHelper} from './IKSElasticLMHelper.sol';\\n\\ninterface IKyberSwapElasticLMEvents {\\n  event AddPool(\\n    uint256 indexed pId,\\n    address poolAddress,\\n    uint32 startTime,\\n    uint32 endTime,\\n    uint256 feeTarget\\n  );\\n\\n  event RenewPool(uint256 indexed pid, uint32 startTime, uint32 endTime, uint256 feeTarget);\\n\\n  event Deposit(address sender, uint256 indexed nftId);\\n\\n  event Withdraw(address sender, uint256 indexed nftId);\\n\\n  event Join(uint256 indexed nftId, uint256 indexed pId, uint256 indexed liq);\\n\\n  event Exit(address to, uint256 indexed nftId, uint256 indexed pId, uint256 indexed liq);\\n\\n  event SyncLiq(uint256 indexed nftId, uint256 indexed pId, uint256 indexed liq);\\n\\n  event Harvest(uint256 indexed nftId, address to, address reward, uint256 indexed amount);\\n\\n  event EmergencyEnabled();\\n\\n  event UpdateSpecialFeatureEnabled(bool enableOrDisable);\\n\\n  event EmergencyWithdrawForOwner(address reward, uint256 indexed amount);\\n\\n  event EmergencyWithdraw(address sender, uint256 indexed nftId);\\n\\n  event LMHelperUpdated(IKSElasticLMHelper helper);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/liquidityMining/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity >=0.8.0;\\n\\n/// @title KyberSwap v2 factory\\n/// @notice Deploys KyberSwap v2 pools and manages control over government fees\\ninterface IFactory {\\n  /// @notice Emitted when a pool is created\\n  /// @param token0 First pool token by address sort order\\n  /// @param token1 Second pool token by address sort order\\n  /// @param swapFeeBps Fee to be collected upon every swap in the pool, in basis points\\n  /// @param tickDistance Minimum number of ticks between initialized ticks\\n  /// @param pool The address of the created pool\\n  event PoolCreated(\\n    address indexed token0,\\n    address indexed token1,\\n    uint16 indexed swapFeeBps,\\n    int24 tickDistance,\\n    address pool\\n  );\\n\\n  /// @notice Emitted when a new fee is enabled for pool creation via the factory\\n  /// @param swapFeeBps Fee to be collected upon every swap in the pool, in basis points\\n  /// @param tickDistance Minimum number of ticks between initialized ticks for pools created with the given fee\\n  event SwapFeeEnabled(uint16 indexed swapFeeBps, int24 indexed tickDistance);\\n\\n  /// @notice Emitted when vesting period changes\\n  /// @param vestingPeriod The maximum time duration for which LP fees\\n  /// are proportionally burnt upon LP removals\\n  event VestingPeriodUpdated(uint32 vestingPeriod);\\n\\n  /// @notice Emitted when configMaster changes\\n  /// @param oldConfigMaster configMaster before the update\\n  /// @param newConfigMaster configMaster after the update\\n  event ConfigMasterUpdated(address oldConfigMaster, address newConfigMaster);\\n\\n  /// @notice Emitted when fee configuration changes\\n  /// @param feeTo Recipient of government fees\\n  /// @param governmentFeeBps Fee amount, in basis points,\\n  /// to be collected out of the fee charged for a pool swap\\n  event FeeConfigurationUpdated(address feeTo, uint16 governmentFeeBps);\\n\\n  /// @notice Emitted when whitelist feature is enabled\\n  event WhitelistEnabled();\\n\\n  /// @notice Emitted when whitelist feature is disabled\\n  event WhitelistDisabled();\\n\\n  /// @notice Returns the maximum time duration for which LP fees\\n  /// are proportionally burnt upon LP removals\\n  function vestingPeriod() external view returns (uint32);\\n\\n  /// @notice Returns the tick distance for a specified fee.\\n  /// @dev Once added, cannot be updated or removed.\\n  /// @param swapFeeBps Swap fee, in basis points.\\n  /// @return The tick distance. Returns 0 if fee has not been added.\\n  function feeAmountTickDistance(uint16 swapFeeBps) external view returns (int24);\\n\\n  /// @notice Returns the address which can update the fee configuration\\n  function configMaster() external view returns (address);\\n\\n  /// @notice Returns the keccak256 hash of the Pool creation code\\n  /// This is used for pre-computation of pool addresses\\n  function poolInitHash() external view returns (bytes32);\\n\\n  /// @notice Fetches the recipient of government fees\\n  /// and current government fee charged in basis points\\n  function feeConfiguration() external view returns (address _feeTo, uint16 _governmentFeeBps);\\n\\n  /// @notice Returns the status of whitelisting feature of NFT managers\\n  /// If true, anyone can mint liquidity tokens\\n  /// Otherwise, only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\n  function whitelistDisabled() external view returns (bool);\\n\\n  //// @notice Returns all whitelisted NFT managers\\n  /// If the whitelisting feature is turned on,\\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\n  function getWhitelistedNFTManagers() external view returns (address[] memory);\\n\\n  /// @notice Checks if sender is a whitelisted NFT manager\\n  /// If the whitelisting feature is turned on,\\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\n  /// @param sender address to be checked\\n  /// @return true if sender is a whistelisted NFT manager, false otherwise\\n  function isWhitelistedNFTManager(address sender) external view returns (bool);\\n\\n  /// @notice Returns the pool address for a given pair of tokens and a swap fee\\n  /// @dev Token order does not matter\\n  /// @param tokenA Contract address of either token0 or token1\\n  /// @param tokenB Contract address of the other token\\n  /// @param swapFeeBps Fee to be collected upon every swap in the pool, in basis points\\n  /// @return pool The pool address. Returns null address if it does not exist\\n  function getPool(\\n    address tokenA,\\n    address tokenB,\\n    uint16 swapFeeBps\\n  ) external view returns (address pool);\\n\\n  /// @notice Fetch parameters to be used for pool creation\\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\\n  /// @return factory The factory address\\n  /// @return token0 First pool token by address sort order\\n  /// @return token1 Second pool token by address sort order\\n  /// @return swapFeeBps Fee to be collected upon every swap in the pool, in basis points\\n  /// @return tickDistance Minimum number of ticks between initialized ticks\\n  function parameters()\\n    external\\n    view\\n    returns (\\n      address factory,\\n      address token0,\\n      address token1,\\n      uint16 swapFeeBps,\\n      int24 tickDistance\\n    );\\n\\n  /// @notice Creates a pool for the given two tokens and fee\\n  /// @param tokenA One of the two tokens in the desired pool\\n  /// @param tokenB The other of the two tokens in the desired pool\\n  /// @param swapFeeBps Desired swap fee for the pool, in basis points\\n  /// @dev Token order does not matter. tickDistance is determined from the fee.\\n  /// Call will revert under any of these conditions:\\n  ///     1) pool already exists\\n  ///     2) invalid swap fee\\n  ///     3) invalid token arguments\\n  /// @return pool The address of the newly created pool\\n  function createPool(\\n    address tokenA,\\n    address tokenB,\\n    uint16 swapFeeBps\\n  ) external returns (address pool);\\n\\n  /// @notice Enables a fee amount with the given tickDistance\\n  /// @dev Fee amounts may never be removed once enabled\\n  /// @param swapFeeBps The fee amount to enable, in basis points\\n  /// @param tickDistance The distance between ticks to be enforced for all pools created with the given fee amount\\n  function enableSwapFee(uint16 swapFeeBps, int24 tickDistance) external;\\n\\n  /// @notice Updates the address which can update the fee configuration\\n  /// @dev Must be called by the current configMaster\\n  function updateConfigMaster(address) external;\\n\\n  /// @notice Updates the vesting period\\n  /// @dev Must be called by the current configMaster\\n  function updateVestingPeriod(uint32) external;\\n\\n  /// @notice Updates the address receiving government fees and fee quantity\\n  /// @dev Only configMaster is able to perform the update\\n  /// @param feeTo Address to receive government fees collected from pools\\n  /// @param governmentFeeBps Fee amount, in basis points,\\n  /// to be collected out of the fee charged for a pool swap\\n  function updateFeeConfiguration(address feeTo, uint16 governmentFeeBps) external;\\n\\n  /// @notice Enables the whitelisting feature\\n  /// @dev Only configMaster is able to perform the update\\n  function enableWhitelist() external;\\n\\n  /// @notice Disables the whitelisting feature\\n  /// @dev Only configMaster is able to perform the update\\n  function disableWhitelist() external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"contract IKSElasticLMHelper\",\"name\":\"_helper\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeTarget\",\"type\":\"uint256\"}],\"name\":\"AddPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EmergencyEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdrawForOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liq\",\"type\":\"uint256\"}],\"name\":\"Exit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liq\",\"type\":\"uint256\"}],\"name\":\"Join\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IKSElasticLMHelper\",\"name\":\"helper\",\"type\":\"address\"}],\"name\":\"LMHelperUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeTarget\",\"type\":\"uint256\"}],\"name\":\"RenewPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liq\",\"type\":\"uint256\"}],\"name\":\"SyncLiq\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"TransferAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"grantOrRevoke\",\"type\":\"bool\"}],\"name\":\"UpdateOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enableOrDisable\",\"type\":\"bool\"}],\"name\":\"UpdateSpecialFeatureEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"feeTarget\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isReceiveNative\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"claimFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"depositAndJoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"rewards\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"emergencyWithdrawForOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"liqs\",\"type\":\"uint256[]\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDepositedNFTs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"listNFTs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"getJoinedPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"poolIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"}],\"name\":\"getJoinedPoolsInRange\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"poolIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"}],\"name\":\"getPoolInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"totalSecondsClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numStakes\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardUnclaimeds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"}],\"name\":\"getRewardCalculationData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"secondsPerLiquidityNow\",\"type\":\"uint128\"},{\"internalType\":\"int256\",\"name\":\"feeNow\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"vestingVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSecondsUnclaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsPerLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondsClaim\",\"type\":\"uint256\"}],\"internalType\":\"struct IKyberSwapElasticLM.RewardCalculationData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardPending\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardLast\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"datas\",\"type\":\"bytes[]\"}],\"name\":\"harvestMultiplePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isEmergencyWithdrawnNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"liqs\",\"type\":\"uint256[]\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"totalSecondsClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numStakes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReceiveNative\",\"type\":\"bool\"},{\"internalType\":\"bool[2]\",\"name\":\"claimFeeAndRewards\",\"type\":\"bool[2]\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"feeTarget\",\"type\":\"uint256\"}],\"name\":\"renewPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialFeatureEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"secondsPerLiquidityLast\",\"type\":\"uint128\"},{\"internalType\":\"int256\",\"name\":\"feeFirst\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKSElasticLMHelper\",\"name\":\"_helper\",\"type\":\"address\"}],\"name\":\"updateHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"grantOrRevoke\",\"type\":\"bool\"}],\"name\":\"updateOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enableOrDisable\",\"type\":\"bool\"}],\"name\":\"updateSpecialFeatureEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KyberSwapElasticLM", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e222fbe074a436145b255442d919e4e3a6c6a48000000000000000000000000035be3f4fd8239a35a7f120756d4d69e5c5e10870", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}