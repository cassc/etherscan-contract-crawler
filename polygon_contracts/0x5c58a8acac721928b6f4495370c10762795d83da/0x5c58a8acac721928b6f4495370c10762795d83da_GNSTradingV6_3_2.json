{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/ChainlinkFeedInterfaceV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface ChainlinkFeedInterfaceV5 {\\r\\n    function latestRoundData() external view returns (uint80, int, uint, uint, uint80);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/GNSBorrowingFeesInterfaceV6_3_2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface GNSBorrowingFeesInterfaceV6_3_2 {\\r\\n    // Structs\\r\\n    struct PairGroup {\\r\\n        uint16 groupIndex;\\r\\n        uint48 block;\\r\\n        uint64 initialAccFeeLong; // 1e10 (%)\\r\\n        uint64 initialAccFeeShort; // 1e10 (%)\\r\\n        uint64 prevGroupAccFeeLong; // 1e10 (%)\\r\\n        uint64 prevGroupAccFeeShort; // 1e10 (%)\\r\\n        uint64 pairAccFeeLong; // 1e10 (%)\\r\\n        uint64 pairAccFeeShort; // 1e10 (%)\\r\\n        uint64 _placeholder; // might be useful later\\r\\n    }\\r\\n    struct Pair {\\r\\n        PairGroup[] groups;\\r\\n        uint32 feePerBlock; // 1e10 (%)\\r\\n        uint64 accFeeLong; // 1e10 (%)\\r\\n        uint64 accFeeShort; // 1e10 (%)\\r\\n        uint48 accLastUpdatedBlock;\\r\\n        uint48 _placeholder; // might be useful later\\r\\n        uint lastAccBlockWeightedMarketCap; // 1e40\\r\\n    }\\r\\n    struct Group {\\r\\n        uint112 oiLong; // 1e10\\r\\n        uint112 oiShort; // 1e10\\r\\n        uint32 feePerBlock; // 1e10 (%)\\r\\n        uint64 accFeeLong; // 1e10 (%)\\r\\n        uint64 accFeeShort; // 1e10 (%)\\r\\n        uint48 accLastUpdatedBlock;\\r\\n        uint80 maxOi; // 1e10\\r\\n        uint lastAccBlockWeightedMarketCap; // 1e40\\r\\n    }\\r\\n    struct InitialAccFees {\\r\\n        uint64 accPairFee; // 1e10 (%)\\r\\n        uint64 accGroupFee; // 1e10 (%)\\r\\n        uint48 block;\\r\\n        uint80 _placeholder; // might be useful later\\r\\n    }\\r\\n    struct PairParams {\\r\\n        uint16 groupIndex;\\r\\n        uint32 feePerBlock; // 1e10 (%)\\r\\n    }\\r\\n    struct GroupParams {\\r\\n        uint32 feePerBlock; // 1e10 (%)\\r\\n        uint80 maxOi; // 1e10\\r\\n    }\\r\\n    struct BorrowingFeeInput {\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        bool long;\\r\\n        uint collateral; // 1e18 (DAI)\\r\\n        uint leverage;\\r\\n    }\\r\\n    struct LiqPriceInput {\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        uint openPrice; // 1e10\\r\\n        bool long;\\r\\n        uint collateral; // 1e18 (DAI)\\r\\n        uint leverage;\\r\\n    }\\r\\n\\r\\n    // Events\\r\\n    event PairParamsUpdated(uint indexed pairIndex, uint16 indexed groupIndex, uint32 feePerBlock);\\r\\n    event PairGroupUpdated(uint indexed pairIndex, uint16 indexed prevGroupIndex, uint16 indexed newGroupIndex);\\r\\n    event GroupUpdated(uint16 indexed groupIndex, uint32 feePerBlock, uint80 maxOi);\\r\\n    event TradeInitialAccFeesStored(\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index,\\r\\n        uint64 initialPairAccFee,\\r\\n        uint64 initialGroupAccFee\\r\\n    );\\r\\n    event TradeActionHandled(\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index,\\r\\n        bool open,\\r\\n        bool long,\\r\\n        uint positionSizeDai // 1e18\\r\\n    );\\r\\n    event PairAccFeesUpdated(\\r\\n        uint indexed pairIndex,\\r\\n        uint currentBlock,\\r\\n        uint64 accFeeLong,\\r\\n        uint64 accFeeShort,\\r\\n        uint accBlockWeightedMarketCap\\r\\n    );\\r\\n    event GroupAccFeesUpdated(\\r\\n        uint16 indexed groupIndex,\\r\\n        uint currentBlock,\\r\\n        uint64 accFeeLong,\\r\\n        uint64 accFeeShort,\\r\\n        uint accBlockWeightedMarketCap\\r\\n    );\\r\\n    event GroupOiUpdated(\\r\\n        uint16 indexed groupIndex,\\r\\n        bool indexed long,\\r\\n        bool indexed increase,\\r\\n        uint112 amount,\\r\\n        uint112 oiLong,\\r\\n        uint112 oiShort\\r\\n    );\\r\\n\\r\\n    // Functions\\r\\n    function getTradeLiquidationPrice(LiqPriceInput calldata) external view returns (uint); // PRECISION\\r\\n\\r\\n    function getTradeBorrowingFee(BorrowingFeeInput memory) external view returns (uint); // 1e18 (DAI)\\r\\n\\r\\n    function handleTradeAction(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint positionSizeDai, // 1e18 (collateral * leverage)\\r\\n        bool open,\\r\\n        bool long\\r\\n    ) external;\\r\\n\\r\\n    function withinMaxGroupOi(uint pairIndex, bool long, uint positionSizeDai) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/GNSPairInfosInterfaceV6.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface GNSPairInfosInterfaceV6 {\\r\\n    // Trade initial acc fees\\r\\n    struct TradeInitialAccFees {\\r\\n        uint rollover; // 1e18 (DAI)\\r\\n        int funding; // 1e18 (DAI)\\r\\n        bool openedAfterUpdate;\\r\\n    }\\r\\n\\r\\n    function tradeInitialAccFees(address, uint, uint) external view returns (TradeInitialAccFees memory);\\r\\n\\r\\n    function maxNegativePnlOnOpenP() external view returns (uint); // PRECISION (%)\\r\\n\\r\\n    function storeTradeInitialAccFees(address trader, uint pairIndex, uint index, bool long) external;\\r\\n\\r\\n    function getTradePriceImpact(\\r\\n        uint openPrice, // PRECISION\\r\\n        uint pairIndex,\\r\\n        bool long,\\r\\n        uint openInterest // 1e18 (DAI)\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint priceImpactP, // PRECISION (%)\\r\\n            uint priceAfterImpact // PRECISION\\r\\n        );\\r\\n\\r\\n    function getTradeRolloverFee(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint collateral // 1e18 (DAI)\\r\\n    ) external view returns (uint);\\r\\n\\r\\n    function getTradeFundingFee(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        bool long,\\r\\n        uint collateral, // 1e18 (DAI)\\r\\n        uint leverage\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            int // 1e18 (DAI) | Positive => Fee, Negative => Reward\\r\\n        );\\r\\n\\r\\n    function getTradeLiquidationPricePure(\\r\\n        uint openPrice, // PRECISION\\r\\n        bool long,\\r\\n        uint collateral, // 1e18 (DAI)\\r\\n        uint leverage,\\r\\n        uint rolloverFee, // 1e18 (DAI)\\r\\n        int fundingFee // 1e18 (DAI)\\r\\n    ) external pure returns (uint);\\r\\n\\r\\n    function getTradeLiquidationPrice(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint openPrice, // PRECISION\\r\\n        bool long,\\r\\n        uint collateral, // 1e18 (DAI)\\r\\n        uint leverage\\r\\n    ) external view returns (uint); // PRECISION\\r\\n\\r\\n    function getTradeValue(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        bool long,\\r\\n        uint collateral, // 1e18 (DAI)\\r\\n        uint leverage,\\r\\n        int percentProfit, // PRECISION (%)\\r\\n        uint closingFee // 1e18 (DAI)\\r\\n    ) external returns (uint); // 1e18 (DAI)\\r\\n\\r\\n    function manager() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/GNSReferralsInterfaceV6_2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface GNSReferralsInterfaceV6_2 {\\r\\n    function registerPotentialReferrer(address trader, address referral) external;\\r\\n\\r\\n    function distributePotentialReward(\\r\\n        address trader,\\r\\n        uint volumeDai,\\r\\n        uint pairOpenFeeP,\\r\\n        uint tokenPriceDai\\r\\n    ) external returns (uint);\\r\\n\\r\\n    function getPercentOfOpenFeeP(address trader) external view returns (uint);\\r\\n\\r\\n    function getTraderReferrer(address trader) external view returns (address referrer);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IArbSys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.21 <0.9.0;\\n\\n/**\\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\\n */\\ninterface IArbSys {\\n    /**\\n     * @notice Get internal version number identifying an ArbOS build\\n     * @return version number as int\\n     */\\n    function arbOSVersion() external pure returns (uint);\\n\\n    function arbChainID() external view returns (uint);\\n\\n    /**\\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n     * @return block number as int\\n     */\\n    function arbBlockNumber() external view returns (uint);\\n\\n    /**\\n     * @notice Send given amount of Eth to dest from sender.\\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\\n     * @param destination recipient address on L1\\n     * @return unique identifier for this L2-to-L1 transaction.\\n     */\\n    function withdrawEth(address destination) external payable returns (uint);\\n\\n    /**\\n     * @notice Send a transaction to L1\\n     * @param destination recipient address on L1\\n     * @param calldataForL1 (optional) calldata for L1 contract call\\n     * @return a unique identifier for this L2-to-L1 transaction.\\n     */\\n    function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint);\\n\\n    /**\\n     * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\\n     * @param account target account\\n     * @return the number of transactions issued by the given external account or the account sequence number of the given contract\\n     */\\n    function getTransactionCount(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice get the value of target L2 storage slot\\n     * This function is only callable from address 0 to prevent contracts from being able to call it\\n     * @param account target account\\n     * @param index target index of storage slot\\n     * @return stotage value for the given account at the given index\\n     */\\n    function getStorageAt(address account, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @notice check if current call is coming from l1\\n     * @return true if the caller of this was called directly from L1\\n     */\\n    function isTopLevelCall() external view returns (bool);\\n\\n    /**\\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\\n     * @return true iff the caller's address is an alias for an L1 contract address\\n     */\\n    function wasMyCallersAddressAliased() external view returns (bool);\\n\\n    /**\\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\\n     * @return address of the caller's caller, without applying L1 contract address aliasing\\n     */\\n    function myCallersAddressWithoutAliasing() external view returns (address);\\n\\n    /**\\n     * @notice map L1 sender contract address to its L2 alias\\n     * @param sender sender address\\n     * @param dest destination address\\n     * @return aliased sender address\\n     */\\n    function mapL1SenderContractAddressToL2Alias(address sender, address dest) external pure returns (address);\\n\\n    /**\\n     * @notice get the caller's amount of available storage gas\\n     * @return amount of storage gas available to the caller\\n     */\\n    function getStorageGasAvailable() external view returns (uint);\\n\\n    event L2ToL1Transaction(\\n        address caller,\\n        address indexed destination,\\n        uint indexed uniqueId,\\n        uint indexed batchNumber,\\n        uint indexInBatch,\\n        uint arbBlockNum,\\n        uint ethBlockNum,\\n        uint timestamp,\\n        uint callvalue,\\n        bytes data\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IGToken {\\r\\n    function manager() external view returns (address);\\r\\n\\r\\n    function admin() external view returns (address);\\r\\n\\r\\n    function currentEpoch() external view returns (uint);\\r\\n\\r\\n    function currentEpochStart() external view returns (uint);\\r\\n\\r\\n    function currentEpochPositiveOpenPnl() external view returns (uint);\\r\\n\\r\\n    function updateAccPnlPerTokenUsed(uint prevPositiveOpenPnl, uint newPositiveOpenPnl) external returns (uint);\\r\\n\\r\\n    struct LockedDeposit {\\r\\n        address owner;\\r\\n        uint shares; // 1e18\\r\\n        uint assetsDeposited; // 1e18\\r\\n        uint assetsDiscount; // 1e18\\r\\n        uint atTimestamp; // timestamp\\r\\n        uint lockDuration; // timestamp\\r\\n    }\\r\\n\\r\\n    function getLockedDeposit(uint depositId) external view returns (LockedDeposit memory);\\r\\n\\r\\n    function sendAssets(uint assets, address receiver) external;\\r\\n\\r\\n    function receiveAssets(uint assets, address user) external;\\r\\n\\r\\n    function distributeReward(uint assets) external;\\r\\n\\r\\n    function currentBalanceDai() external view returns (uint);\\r\\n\\r\\n    function tvl() external view returns (uint);\\r\\n\\r\\n    function marketCap() external view returns (uint);\\r\\n\\r\\n    function getPendingAccBlockWeightedMarketCap(uint currentBlock) external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/NftInterfaceV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface NftInterfaceV5 {\\r\\n    function balanceOf(address) external view returns (uint);\\r\\n\\r\\n    function ownerOf(uint) external view returns (address);\\r\\n\\r\\n    function transferFrom(address, address, uint) external;\\r\\n\\r\\n    function tokenOfOwnerByIndex(address, uint) external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/PairsStorageInterfaceV6.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface PairsStorageInterfaceV6 {\\r\\n    enum FeedCalculation {\\r\\n        DEFAULT,\\r\\n        INVERT,\\r\\n        COMBINE\\r\\n    } // FEED 1, 1 / (FEED 1), (FEED 1)/(FEED 2)\\r\\n    struct Feed {\\r\\n        address feed1;\\r\\n        address feed2;\\r\\n        FeedCalculation feedCalculation;\\r\\n        uint maxDeviationP;\\r\\n    } // PRECISION (%)\\r\\n\\r\\n    function incrementCurrentOrderId() external returns (uint);\\r\\n\\r\\n    function updateGroupCollateral(uint, uint, bool, bool) external;\\r\\n\\r\\n    function pairJob(uint) external returns (string memory, string memory, bytes32, uint);\\r\\n\\r\\n    function pairFeed(uint) external view returns (Feed memory);\\r\\n\\r\\n    function pairSpreadP(uint) external view returns (uint);\\r\\n\\r\\n    function pairMinLeverage(uint) external view returns (uint);\\r\\n\\r\\n    function pairMaxLeverage(uint) external view returns (uint);\\r\\n\\r\\n    function groupMaxCollateral(uint) external view returns (uint);\\r\\n\\r\\n    function groupCollateral(uint, bool) external view returns (uint);\\r\\n\\r\\n    function guaranteedSlEnabled(uint) external view returns (bool);\\r\\n\\r\\n    function pairOpenFeeP(uint) external view returns (uint);\\r\\n\\r\\n    function pairCloseFeeP(uint) external view returns (uint);\\r\\n\\r\\n    function pairOracleFeeP(uint) external view returns (uint);\\r\\n\\r\\n    function pairNftLimitOrderFeeP(uint) external view returns (uint);\\r\\n\\r\\n    function pairReferralFeeP(uint) external view returns (uint);\\r\\n\\r\\n    function pairMinLevPosDai(uint) external view returns (uint);\\r\\n\\r\\n    function pairsCount() external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/StorageInterfaceV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\nimport \\\"./TokenInterfaceV5.sol\\\";\\r\\nimport \\\"./NftInterfaceV5.sol\\\";\\r\\nimport \\\"./IGToken.sol\\\";\\r\\nimport \\\"./PairsStorageInterfaceV6.sol\\\";\\r\\nimport \\\"./ChainlinkFeedInterfaceV5.sol\\\";\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface PoolInterfaceV5 {\\r\\n    function increaseAccTokensPerLp(uint) external;\\r\\n}\\r\\n\\r\\ninterface PausableInterfaceV5 {\\r\\n    function isPaused() external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface StorageInterfaceV5 {\\r\\n    enum LimitOrder {\\r\\n        TP,\\r\\n        SL,\\r\\n        LIQ,\\r\\n        OPEN\\r\\n    }\\r\\n    struct Trade {\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        uint initialPosToken; // 1e18\\r\\n        uint positionSizeDai; // 1e18\\r\\n        uint openPrice; // PRECISION\\r\\n        bool buy;\\r\\n        uint leverage;\\r\\n        uint tp; // PRECISION\\r\\n        uint sl; // PRECISION\\r\\n    }\\r\\n    struct TradeInfo {\\r\\n        uint tokenId;\\r\\n        uint tokenPriceDai; // PRECISION\\r\\n        uint openInterestDai; // 1e18\\r\\n        uint tpLastUpdated;\\r\\n        uint slLastUpdated;\\r\\n        bool beingMarketClosed;\\r\\n    }\\r\\n    struct OpenLimitOrder {\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        uint positionSize; // 1e18 (DAI or GFARM2)\\r\\n        uint spreadReductionP;\\r\\n        bool buy;\\r\\n        uint leverage;\\r\\n        uint tp; // PRECISION (%)\\r\\n        uint sl; // PRECISION (%)\\r\\n        uint minPrice; // PRECISION\\r\\n        uint maxPrice; // PRECISION\\r\\n        uint block;\\r\\n        uint tokenId; // index in supportedTokens\\r\\n    }\\r\\n    struct PendingMarketOrder {\\r\\n        Trade trade;\\r\\n        uint block;\\r\\n        uint wantedPrice; // PRECISION\\r\\n        uint slippageP; // PRECISION (%)\\r\\n        uint spreadReductionP;\\r\\n        uint tokenId; // index in supportedTokens\\r\\n    }\\r\\n    struct PendingNftOrder {\\r\\n        address nftHolder;\\r\\n        uint nftId;\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        LimitOrder orderType;\\r\\n    }\\r\\n\\r\\n    function PRECISION() external pure returns (uint);\\r\\n\\r\\n    function gov() external view returns (address);\\r\\n\\r\\n    function dev() external view returns (address);\\r\\n\\r\\n    function dai() external view returns (TokenInterfaceV5);\\r\\n\\r\\n    function token() external view returns (TokenInterfaceV5);\\r\\n\\r\\n    function linkErc677() external view returns (TokenInterfaceV5);\\r\\n\\r\\n    function priceAggregator() external view returns (AggregatorInterfaceV6_2);\\r\\n\\r\\n    function vault() external view returns (IGToken);\\r\\n\\r\\n    function trading() external view returns (address);\\r\\n\\r\\n    function callbacks() external view returns (address);\\r\\n\\r\\n    function handleTokens(address, uint, bool) external;\\r\\n\\r\\n    function transferDai(address, address, uint) external;\\r\\n\\r\\n    function transferLinkToAggregator(address, uint, uint) external;\\r\\n\\r\\n    function unregisterTrade(address, uint, uint) external;\\r\\n\\r\\n    function unregisterPendingMarketOrder(uint, bool) external;\\r\\n\\r\\n    function unregisterOpenLimitOrder(address, uint, uint) external;\\r\\n\\r\\n    function hasOpenLimitOrder(address, uint, uint) external view returns (bool);\\r\\n\\r\\n    function storePendingMarketOrder(PendingMarketOrder memory, uint, bool) external;\\r\\n\\r\\n    function openTrades(address, uint, uint) external view returns (Trade memory);\\r\\n\\r\\n    function openTradesInfo(address, uint, uint) external view returns (TradeInfo memory);\\r\\n\\r\\n    function updateSl(address, uint, uint, uint) external;\\r\\n\\r\\n    function updateTp(address, uint, uint, uint) external;\\r\\n\\r\\n    function getOpenLimitOrder(address, uint, uint) external view returns (OpenLimitOrder memory);\\r\\n\\r\\n    function spreadReductionsP(uint) external view returns (uint);\\r\\n\\r\\n    function storeOpenLimitOrder(OpenLimitOrder memory) external;\\r\\n\\r\\n    function reqID_pendingMarketOrder(uint) external view returns (PendingMarketOrder memory);\\r\\n\\r\\n    function storePendingNftOrder(PendingNftOrder memory, uint) external;\\r\\n\\r\\n    function updateOpenLimitOrder(OpenLimitOrder calldata) external;\\r\\n\\r\\n    function firstEmptyTradeIndex(address, uint) external view returns (uint);\\r\\n\\r\\n    function firstEmptyOpenLimitIndex(address, uint) external view returns (uint);\\r\\n\\r\\n    function increaseNftRewards(uint, uint) external;\\r\\n\\r\\n    function nftSuccessTimelock() external view returns (uint);\\r\\n\\r\\n    function reqID_pendingNftOrder(uint) external view returns (PendingNftOrder memory);\\r\\n\\r\\n    function updateTrade(Trade memory) external;\\r\\n\\r\\n    function nftLastSuccess(uint) external view returns (uint);\\r\\n\\r\\n    function unregisterPendingNftOrder(uint) external;\\r\\n\\r\\n    function handleDevGovFees(uint, uint, bool, bool) external returns (uint);\\r\\n\\r\\n    function distributeLpRewards(uint) external;\\r\\n\\r\\n    function storeTrade(Trade memory, TradeInfo memory) external;\\r\\n\\r\\n    function openLimitOrdersCount(address, uint) external view returns (uint);\\r\\n\\r\\n    function openTradesCount(address, uint) external view returns (uint);\\r\\n\\r\\n    function pendingMarketOpenCount(address, uint) external view returns (uint);\\r\\n\\r\\n    function pendingMarketCloseCount(address, uint) external view returns (uint);\\r\\n\\r\\n    function maxTradesPerPair() external view returns (uint);\\r\\n\\r\\n    function pendingOrderIdsCount(address) external view returns (uint);\\r\\n\\r\\n    function maxPendingMarketOrders() external view returns (uint);\\r\\n\\r\\n    function openInterestDai(uint, uint) external view returns (uint);\\r\\n\\r\\n    function getPendingOrderIds(address) external view returns (uint[] memory);\\r\\n\\r\\n    function nfts(uint) external view returns (NftInterfaceV5);\\r\\n\\r\\n    function fakeBlockNumber() external view returns (uint); // Testing\\r\\n}\\r\\n\\r\\ninterface IStateCopyUtils {\\r\\n    function getOpenLimitOrders() external view returns (StorageInterfaceV5.OpenLimitOrder[] memory);\\r\\n\\r\\n    function nftRewards() external view returns (NftRewardsInterfaceV6_3_1);\\r\\n}\\r\\n\\r\\ninterface AggregatorInterfaceV6_2 {\\r\\n    enum OrderType {\\r\\n        MARKET_OPEN,\\r\\n        MARKET_CLOSE,\\r\\n        LIMIT_OPEN,\\r\\n        LIMIT_CLOSE,\\r\\n        UPDATE_SL\\r\\n    }\\r\\n\\r\\n    function pairsStorage() external view returns (PairsStorageInterfaceV6);\\r\\n\\r\\n    function getPrice(uint, OrderType, uint) external returns (uint);\\r\\n\\r\\n    function tokenPriceDai() external returns (uint);\\r\\n\\r\\n    function linkFee(uint, uint) external view returns (uint);\\r\\n\\r\\n    function openFeeP(uint) external view returns (uint);\\r\\n\\r\\n    function pendingSlOrders(uint) external view returns (PendingSl memory);\\r\\n\\r\\n    function storePendingSlOrder(uint orderId, PendingSl calldata p) external;\\r\\n\\r\\n    function unregisterPendingSlOrder(uint orderId) external;\\r\\n\\r\\n    struct PendingSl {\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        uint openPrice;\\r\\n        bool buy;\\r\\n        uint newSl;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface AggregatorInterfaceV6_3_1 is AggregatorInterfaceV6_2 {\\r\\n    function linkPriceFeed() external view returns (ChainlinkFeedInterfaceV5);\\r\\n}\\r\\n\\r\\ninterface NftRewardsInterfaceV6_3_1 {\\r\\n    struct TriggeredLimitId {\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        StorageInterfaceV5.LimitOrder order;\\r\\n    }\\r\\n    enum OpenLimitOrderType {\\r\\n        LEGACY,\\r\\n        REVERSAL,\\r\\n        MOMENTUM\\r\\n    }\\r\\n\\r\\n    function storeFirstToTrigger(TriggeredLimitId calldata, address, uint) external;\\r\\n\\r\\n    function storeTriggerSameBlock(TriggeredLimitId calldata, address) external;\\r\\n\\r\\n    function unregisterTrigger(TriggeredLimitId calldata) external;\\r\\n\\r\\n    function distributeNftReward(TriggeredLimitId calldata, uint, uint) external;\\r\\n\\r\\n    function openLimitOrderTypes(address, uint, uint) external view returns (OpenLimitOrderType);\\r\\n\\r\\n    function setOpenLimitOrderType(address, uint, uint, OpenLimitOrderType) external;\\r\\n\\r\\n    function triggered(TriggeredLimitId calldata) external view returns (bool);\\r\\n\\r\\n    function timedOut(TriggeredLimitId calldata) external view returns (bool);\\r\\n\\r\\n    function botInUse(bytes32) external view returns (bool);\\r\\n\\r\\n    function getNftBotHashes(uint, address, uint, address, uint, uint) external pure returns (bytes32, bytes32);\\r\\n\\r\\n    function setNftBotInUse(bytes32, bytes32) external;\\r\\n\\r\\n    function nftBotInUse(bytes32, bytes32) external view returns (bool);\\r\\n\\r\\n    function linkToTokenRewards(uint, uint) external view returns (uint);\\r\\n}\\r\\n\\r\\ninterface TradingCallbacksV6_3_2 {\\r\\n    enum TradeType {\\r\\n        MARKET,\\r\\n        LIMIT\\r\\n    }\\r\\n    struct SimplifiedTradeId {\\r\\n        address trader;\\r\\n        uint pairIndex;\\r\\n        uint index;\\r\\n        TradeType tradeType;\\r\\n    }\\r\\n    struct LastUpdated {\\r\\n        uint32 tp;\\r\\n        uint32 sl;\\r\\n        uint32 limit;\\r\\n        uint32 created;\\r\\n    }\\r\\n\\r\\n    function tradeLastUpdated(address, uint, uint, TradeType) external view returns (LastUpdated memory);\\r\\n\\r\\n    function setTradeLastUpdated(SimplifiedTradeId calldata, LastUpdated memory) external;\\r\\n\\r\\n    function canExecuteTimeout() external view returns (uint);\\r\\n\\r\\n    function pairMaxLeverage(uint) external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/TokenInterfaceV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface TokenInterfaceV5 {\\r\\n    function burn(address, uint256) external;\\r\\n\\r\\n    function mint(address, uint256) external;\\r\\n\\r\\n    function transfer(address, uint256) external returns (bool);\\r\\n\\r\\n    function transferFrom(address, address, uint256) external returns (bool);\\r\\n\\r\\n    function balanceOf(address) external view returns (uint256);\\r\\n\\r\\n    function hasRole(bytes32, address) external view returns (bool);\\r\\n\\r\\n    function approve(address, uint256) external returns (bool);\\r\\n\\r\\n    function allowance(address, address) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/ChainUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../interfaces/IArbSys.sol\\\";\\r\\n\\r\\nlibrary ChainUtils {\\r\\n    uint256 public constant ARBITRUM_MAINNET = 42161;\\r\\n    uint256 public constant ARBITRUM_GOERLI = 421613;\\r\\n    IArbSys public constant ARB_SYS = IArbSys(address(100));\\r\\n\\r\\n    function getBlockNumber() internal view returns (uint) {\\r\\n        if (block.chainid == ARBITRUM_MAINNET || block.chainid == ARBITRUM_GOERLI) {\\r\\n            return ARB_SYS.arbBlockNumber();\\r\\n        }\\r\\n\\r\\n        return block.number;\\r\\n    }\\r\\n\\r\\n    function getUint48BlockNumber(uint blockNumber) internal pure returns (uint48) {\\r\\n        require(blockNumber <= type(uint48).max, \\\"OVERFLOW\\\");\\r\\n        return uint48(blockNumber);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/TradeUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../interfaces/StorageInterfaceV5.sol\\\";\\r\\n\\r\\nlibrary TradeUtils {\\r\\n    function _getTradeLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_2.TradeType _type\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            TradingCallbacksV6_3_2,\\r\\n            TradingCallbacksV6_3_2.LastUpdated memory,\\r\\n            TradingCallbacksV6_3_2.SimplifiedTradeId memory\\r\\n        )\\r\\n    {\\r\\n        TradingCallbacksV6_3_2 callbacks = TradingCallbacksV6_3_2(_callbacks);\\r\\n        TradingCallbacksV6_3_2.LastUpdated memory l = callbacks.tradeLastUpdated(trader, pairIndex, index, _type);\\r\\n\\r\\n        return (callbacks, l, TradingCallbacksV6_3_2.SimplifiedTradeId(trader, pairIndex, index, _type));\\r\\n    }\\r\\n\\r\\n    function getTradeLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_2.TradeType _type\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            TradingCallbacksV6_3_2,\\r\\n            TradingCallbacksV6_3_2.LastUpdated memory,\\r\\n            TradingCallbacksV6_3_2.SimplifiedTradeId memory\\r\\n        )\\r\\n    {\\r\\n        return _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\\r\\n    }\\r\\n\\r\\n    function setTradeLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_2.TradeType _type,\\r\\n        uint blockNumber\\r\\n    ) external {\\r\\n        uint32 b = uint32(blockNumber);\\r\\n        TradingCallbacksV6_3_2 callbacks = TradingCallbacksV6_3_2(_callbacks);\\r\\n        callbacks.setTradeLastUpdated(\\r\\n            TradingCallbacksV6_3_2.SimplifiedTradeId(trader, pairIndex, index, _type),\\r\\n            TradingCallbacksV6_3_2.LastUpdated(b, b, b, b)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setSlLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_2.TradeType _type,\\r\\n        uint blockNumber\\r\\n    ) external {\\r\\n        (\\r\\n            TradingCallbacksV6_3_2 callbacks,\\r\\n            TradingCallbacksV6_3_2.LastUpdated memory l,\\r\\n            TradingCallbacksV6_3_2.SimplifiedTradeId memory id\\r\\n        ) = _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\\r\\n\\r\\n        l.sl = uint32(blockNumber);\\r\\n        callbacks.setTradeLastUpdated(id, l);\\r\\n    }\\r\\n\\r\\n    function setTpLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_2.TradeType _type,\\r\\n        uint blockNumber\\r\\n    ) external {\\r\\n        (\\r\\n            TradingCallbacksV6_3_2 callbacks,\\r\\n            TradingCallbacksV6_3_2.LastUpdated memory l,\\r\\n            TradingCallbacksV6_3_2.SimplifiedTradeId memory id\\r\\n        ) = _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\\r\\n\\r\\n        l.tp = uint32(blockNumber);\\r\\n        callbacks.setTradeLastUpdated(id, l);\\r\\n    }\\r\\n\\r\\n    function setLimitLastUpdated(\\r\\n        address _callbacks,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        TradingCallbacksV6_3_2.TradeType _type,\\r\\n        uint blockNumber\\r\\n    ) external {\\r\\n        (\\r\\n            TradingCallbacksV6_3_2 callbacks,\\r\\n            TradingCallbacksV6_3_2.LastUpdated memory l,\\r\\n            TradingCallbacksV6_3_2.SimplifiedTradeId memory id\\r\\n        ) = _getTradeLastUpdated(_callbacks, trader, pairIndex, index, _type);\\r\\n\\r\\n        l.limit = uint32(blockNumber);\\r\\n        callbacks.setTradeLastUpdated(id, l);\\r\\n    }\\r\\n\\r\\n    function isTpInTimeout(\\r\\n        address _callbacks,\\r\\n        TradingCallbacksV6_3_2.SimplifiedTradeId memory id,\\r\\n        uint currentBlock\\r\\n    ) external view returns (bool) {\\r\\n        (TradingCallbacksV6_3_2 callbacks, TradingCallbacksV6_3_2.LastUpdated memory l, ) = _getTradeLastUpdated(\\r\\n            _callbacks,\\r\\n            id.trader,\\r\\n            id.pairIndex,\\r\\n            id.index,\\r\\n            id.tradeType\\r\\n        );\\r\\n\\r\\n        return currentBlock < uint256(l.tp) + callbacks.canExecuteTimeout();\\r\\n    }\\r\\n\\r\\n    function isSlInTimeout(\\r\\n        address _callbacks,\\r\\n        TradingCallbacksV6_3_2.SimplifiedTradeId memory id,\\r\\n        uint currentBlock\\r\\n    ) external view returns (bool) {\\r\\n        (TradingCallbacksV6_3_2 callbacks, TradingCallbacksV6_3_2.LastUpdated memory l, ) = _getTradeLastUpdated(\\r\\n            _callbacks,\\r\\n            id.trader,\\r\\n            id.pairIndex,\\r\\n            id.index,\\r\\n            id.tradeType\\r\\n        );\\r\\n\\r\\n        return currentBlock < uint256(l.sl) + callbacks.canExecuteTimeout();\\r\\n    }\\r\\n\\r\\n    function isLimitInTimeout(\\r\\n        address _callbacks,\\r\\n        TradingCallbacksV6_3_2.SimplifiedTradeId memory id,\\r\\n        uint currentBlock\\r\\n    ) external view returns (bool) {\\r\\n        (TradingCallbacksV6_3_2 callbacks, TradingCallbacksV6_3_2.LastUpdated memory l, ) = _getTradeLastUpdated(\\r\\n            _callbacks,\\r\\n            id.trader,\\r\\n            id.pairIndex,\\r\\n            id.index,\\r\\n            id.tradeType\\r\\n        );\\r\\n\\r\\n        return currentBlock < uint256(l.limit) + callbacks.canExecuteTimeout();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v6.2/Delegatable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nabstract contract Delegatable {\\r\\n    mapping(address => address) public delegations;\\r\\n    address private senderOverride;\\r\\n\\r\\n    function setDelegate(address delegate) external {\\r\\n        require(tx.origin == msg.sender, \\\"NO_CONTRACT\\\");\\r\\n\\r\\n        delegations[msg.sender] = delegate;\\r\\n    }\\r\\n\\r\\n    function removeDelegate() external {\\r\\n        delegations[msg.sender] = address(0);\\r\\n    }\\r\\n\\r\\n    function delegatedAction(address trader, bytes calldata call_data) external returns (bytes memory) {\\r\\n        require(delegations[trader] == msg.sender, \\\"DELEGATE_NOT_APPROVED\\\");\\r\\n\\r\\n        senderOverride = trader;\\r\\n        (bool success, bytes memory result) = address(this).delegatecall(call_data);\\r\\n        if (!success) {\\r\\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577 (return the original revert reason)\\r\\n            if (result.length < 68) revert();\\r\\n            assembly {\\r\\n                result := add(result, 0x04)\\r\\n            }\\r\\n            revert(abi.decode(result, (string)));\\r\\n        }\\r\\n\\r\\n        senderOverride = address(0);\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function _msgSender() public view returns (address) {\\r\\n        if (senderOverride == address(0)) {\\r\\n            return msg.sender;\\r\\n        } else {\\r\\n            return senderOverride;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/v6.3.2/GNSTradingV6_3_2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\nimport \\\"../interfaces/StorageInterfaceV5.sol\\\";\\r\\nimport \\\"../interfaces/GNSPairInfosInterfaceV6.sol\\\";\\r\\nimport \\\"../interfaces/GNSReferralsInterfaceV6_2.sol\\\";\\r\\nimport \\\"../interfaces/GNSBorrowingFeesInterfaceV6_3_2.sol\\\";\\r\\nimport \\\"../v6.2/Delegatable.sol\\\";\\r\\nimport \\\"../libraries/ChainUtils.sol\\\";\\r\\nimport \\\"../libraries/TradeUtils.sol\\\";\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ncontract GNSTradingV6_3_2 is Delegatable {\\r\\n    using TradeUtils for address;\\r\\n\\r\\n    // Contracts (constant)\\r\\n    StorageInterfaceV5 public immutable storageT;\\r\\n    NftRewardsInterfaceV6_3_1 public immutable nftRewards;\\r\\n    GNSPairInfosInterfaceV6 public immutable pairInfos;\\r\\n    GNSReferralsInterfaceV6_2 public immutable referrals;\\r\\n    GNSBorrowingFeesInterfaceV6_3_2 public immutable borrowingFees;\\r\\n\\r\\n    // Params (constant)\\r\\n    uint constant PRECISION = 1e10;\\r\\n    uint constant MAX_SL_P = 75; // -75% PNL\\r\\n\\r\\n    // Params (adjustable)\\r\\n    uint public maxPosDai; // 1e18 (eg. 75000 * 1e18)\\r\\n    uint public marketOrdersTimeout; // block (eg. 30)\\r\\n\\r\\n    // State\\r\\n    bool public isPaused; // Prevent opening new trades\\r\\n    bool public isDone; // Prevent any interaction with the contract\\r\\n\\r\\n    // Events\\r\\n    event Done(bool done);\\r\\n    event Paused(bool paused);\\r\\n\\r\\n    event NumberUpdated(string name, uint value);\\r\\n\\r\\n    event MarketOrderInitiated(uint indexed orderId, address indexed trader, uint indexed pairIndex, bool open);\\r\\n\\r\\n    event OpenLimitPlaced(address indexed trader, uint indexed pairIndex, uint index);\\r\\n    event OpenLimitUpdated(\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index,\\r\\n        uint newPrice,\\r\\n        uint newTp,\\r\\n        uint newSl\\r\\n    );\\r\\n    event OpenLimitCanceled(address indexed trader, uint indexed pairIndex, uint index);\\r\\n\\r\\n    event TpUpdated(address indexed trader, uint indexed pairIndex, uint index, uint newTp);\\r\\n    event SlUpdated(address indexed trader, uint indexed pairIndex, uint index, uint newSl);\\r\\n    event SlUpdateInitiated(\\r\\n        uint indexed orderId,\\r\\n        address indexed trader,\\r\\n        uint indexed pairIndex,\\r\\n        uint index,\\r\\n        uint newSl\\r\\n    );\\r\\n\\r\\n    event NftOrderInitiated(uint orderId, address indexed nftHolder, address indexed trader, uint indexed pairIndex);\\r\\n    event NftOrderSameBlock(address indexed nftHolder, address indexed trader, uint indexed pairIndex);\\r\\n\\r\\n    event ChainlinkCallbackTimeout(uint indexed orderId, StorageInterfaceV5.PendingMarketOrder order);\\r\\n    event CouldNotCloseTrade(address indexed trader, uint indexed pairIndex, uint index);\\r\\n\\r\\n    constructor(\\r\\n        StorageInterfaceV5 _storageT,\\r\\n        NftRewardsInterfaceV6_3_1 _nftRewards,\\r\\n        GNSPairInfosInterfaceV6 _pairInfos,\\r\\n        GNSReferralsInterfaceV6_2 _referrals,\\r\\n        GNSBorrowingFeesInterfaceV6_3_2 _borrowingFees,\\r\\n        uint _maxPosDai,\\r\\n        uint _marketOrdersTimeout\\r\\n    ) {\\r\\n        require(\\r\\n            address(_storageT) != address(0) &&\\r\\n                address(_nftRewards) != address(0) &&\\r\\n                address(_pairInfos) != address(0) &&\\r\\n                address(_referrals) != address(0) &&\\r\\n                address(_borrowingFees) != address(0) &&\\r\\n                _maxPosDai > 0 &&\\r\\n                _marketOrdersTimeout > 0,\\r\\n            \\\"WRONG_PARAMS\\\"\\r\\n        );\\r\\n\\r\\n        storageT = _storageT;\\r\\n        nftRewards = _nftRewards;\\r\\n        pairInfos = _pairInfos;\\r\\n        referrals = _referrals;\\r\\n        borrowingFees = _borrowingFees;\\r\\n\\r\\n        maxPosDai = _maxPosDai;\\r\\n        marketOrdersTimeout = _marketOrdersTimeout;\\r\\n    }\\r\\n\\r\\n    // Modifiers\\r\\n    modifier onlyGov() {\\r\\n        isGov();\\r\\n        _;\\r\\n    }\\r\\n    modifier notContract() {\\r\\n        isNotContract();\\r\\n        _;\\r\\n    }\\r\\n    modifier notDone() {\\r\\n        isNotDone();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Saving code size by calling these functions inside modifiers\\r\\n    function isGov() private view {\\r\\n        require(msg.sender == storageT.gov(), \\\"GOV_ONLY\\\");\\r\\n    }\\r\\n\\r\\n    function isNotContract() private view {\\r\\n        require(tx.origin == msg.sender);\\r\\n    }\\r\\n\\r\\n    function isNotDone() private view {\\r\\n        require(!isDone, \\\"DONE\\\");\\r\\n    }\\r\\n\\r\\n    // Manage params\\r\\n    function setMaxPosDai(uint value) external onlyGov {\\r\\n        require(value > 0, \\\"VALUE_0\\\");\\r\\n        maxPosDai = value;\\r\\n        emit NumberUpdated(\\\"maxPosDai\\\", value);\\r\\n    }\\r\\n\\r\\n    function setMarketOrdersTimeout(uint value) external onlyGov {\\r\\n        require(value > 0, \\\"VALUE_0\\\");\\r\\n        marketOrdersTimeout = value;\\r\\n        emit NumberUpdated(\\\"marketOrdersTimeout\\\", value);\\r\\n    }\\r\\n\\r\\n    // Manage state\\r\\n    function pause() external onlyGov {\\r\\n        isPaused = !isPaused;\\r\\n        emit Paused(isPaused);\\r\\n    }\\r\\n\\r\\n    function done() external onlyGov {\\r\\n        isDone = !isDone;\\r\\n        emit Done(isDone);\\r\\n    }\\r\\n\\r\\n    // Open new trade (MARKET/LIMIT)\\r\\n    function openTrade(\\r\\n        StorageInterfaceV5.Trade memory t,\\r\\n        NftRewardsInterfaceV6_3_1.OpenLimitOrderType orderType, // LEGACY => market\\r\\n        uint spreadReductionId,\\r\\n        uint slippageP, // for market orders only\\r\\n        address referrer\\r\\n    ) external notContract notDone {\\r\\n        require(!isPaused, \\\"PAUSED\\\");\\r\\n        require(t.openPrice * slippageP < type(uint256).max, \\\"OVERFLOW\\\");\\r\\n\\r\\n        AggregatorInterfaceV6_2 aggregator = storageT.priceAggregator();\\r\\n        PairsStorageInterfaceV6 pairsStored = aggregator.pairsStorage();\\r\\n\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        require(\\r\\n            storageT.openTradesCount(sender, t.pairIndex) +\\r\\n                storageT.pendingMarketOpenCount(sender, t.pairIndex) +\\r\\n                storageT.openLimitOrdersCount(sender, t.pairIndex) <\\r\\n                storageT.maxTradesPerPair(),\\r\\n            \\\"MAX_TRADES_PER_PAIR\\\"\\r\\n        );\\r\\n\\r\\n        require(storageT.pendingOrderIdsCount(sender) < storageT.maxPendingMarketOrders(), \\\"MAX_PENDING_ORDERS\\\");\\r\\n        require(t.positionSizeDai <= maxPosDai, \\\"ABOVE_MAX_POS\\\");\\r\\n        require(t.positionSizeDai * t.leverage >= pairsStored.pairMinLevPosDai(t.pairIndex), \\\"BELOW_MIN_POS\\\");\\r\\n\\r\\n        require(\\r\\n            t.leverage > 0 &&\\r\\n                t.leverage >= pairsStored.pairMinLeverage(t.pairIndex) &&\\r\\n                t.leverage <= pairMaxLeverage(pairsStored, t.pairIndex),\\r\\n            \\\"LEVERAGE_INCORRECT\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            spreadReductionId == 0 || storageT.nfts(spreadReductionId - 1).balanceOf(sender) > 0,\\r\\n            \\\"NO_CORRESPONDING_NFT_SPREAD_REDUCTION\\\"\\r\\n        );\\r\\n\\r\\n        require(t.tp == 0 || (t.buy ? t.tp > t.openPrice : t.tp < t.openPrice), \\\"WRONG_TP\\\");\\r\\n        require(t.sl == 0 || (t.buy ? t.sl < t.openPrice : t.sl > t.openPrice), \\\"WRONG_SL\\\");\\r\\n\\r\\n        (uint priceImpactP, ) = pairInfos.getTradePriceImpact(0, t.pairIndex, t.buy, t.positionSizeDai * t.leverage);\\r\\n        require(priceImpactP * t.leverage <= pairInfos.maxNegativePnlOnOpenP(), \\\"PRICE_IMPACT_TOO_HIGH\\\");\\r\\n\\r\\n        storageT.transferDai(sender, address(storageT), t.positionSizeDai);\\r\\n\\r\\n        if (orderType != NftRewardsInterfaceV6_3_1.OpenLimitOrderType.LEGACY) {\\r\\n            uint index = storageT.firstEmptyOpenLimitIndex(sender, t.pairIndex);\\r\\n\\r\\n            storageT.storeOpenLimitOrder(\\r\\n                StorageInterfaceV5.OpenLimitOrder(\\r\\n                    sender,\\r\\n                    t.pairIndex,\\r\\n                    index,\\r\\n                    t.positionSizeDai,\\r\\n                    spreadReductionId > 0 ? storageT.spreadReductionsP(spreadReductionId - 1) : 0,\\r\\n                    t.buy,\\r\\n                    t.leverage,\\r\\n                    t.tp,\\r\\n                    t.sl,\\r\\n                    t.openPrice,\\r\\n                    t.openPrice,\\r\\n                    block.number,\\r\\n                    0\\r\\n                )\\r\\n            );\\r\\n\\r\\n            nftRewards.setOpenLimitOrderType(sender, t.pairIndex, index, orderType);\\r\\n            storageT.callbacks().setTradeLastUpdated(\\r\\n                sender,\\r\\n                t.pairIndex,\\r\\n                index,\\r\\n                TradingCallbacksV6_3_2.TradeType.LIMIT,\\r\\n                ChainUtils.getBlockNumber()\\r\\n            );\\r\\n\\r\\n            emit OpenLimitPlaced(sender, t.pairIndex, index);\\r\\n        } else {\\r\\n            uint orderId = aggregator.getPrice(\\r\\n                t.pairIndex,\\r\\n                AggregatorInterfaceV6_2.OrderType.MARKET_OPEN,\\r\\n                t.positionSizeDai * t.leverage\\r\\n            );\\r\\n\\r\\n            storageT.storePendingMarketOrder(\\r\\n                StorageInterfaceV5.PendingMarketOrder(\\r\\n                    StorageInterfaceV5.Trade(\\r\\n                        sender,\\r\\n                        t.pairIndex,\\r\\n                        0,\\r\\n                        0,\\r\\n                        t.positionSizeDai,\\r\\n                        0,\\r\\n                        t.buy,\\r\\n                        t.leverage,\\r\\n                        t.tp,\\r\\n                        t.sl\\r\\n                    ),\\r\\n                    0,\\r\\n                    t.openPrice,\\r\\n                    slippageP,\\r\\n                    spreadReductionId > 0 ? storageT.spreadReductionsP(spreadReductionId - 1) : 0,\\r\\n                    0\\r\\n                ),\\r\\n                orderId,\\r\\n                true\\r\\n            );\\r\\n\\r\\n            emit MarketOrderInitiated(orderId, sender, t.pairIndex, true);\\r\\n        }\\r\\n\\r\\n        referrals.registerPotentialReferrer(sender, referrer);\\r\\n    }\\r\\n\\r\\n    // Close trade (MARKET)\\r\\n    function closeTradeMarket(uint pairIndex, uint index) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t = storageT.openTrades(sender, pairIndex, index);\\r\\n        StorageInterfaceV5.TradeInfo memory i = storageT.openTradesInfo(sender, pairIndex, index);\\r\\n\\r\\n        require(storageT.pendingOrderIdsCount(sender) < storageT.maxPendingMarketOrders(), \\\"MAX_PENDING_ORDERS\\\");\\r\\n        require(!i.beingMarketClosed, \\\"ALREADY_BEING_CLOSED\\\");\\r\\n        require(t.leverage > 0, \\\"NO_TRADE\\\");\\r\\n\\r\\n        uint orderId = storageT.priceAggregator().getPrice(\\r\\n            pairIndex,\\r\\n            AggregatorInterfaceV6_2.OrderType.MARKET_CLOSE,\\r\\n            (t.initialPosToken * i.tokenPriceDai * t.leverage) / PRECISION\\r\\n        );\\r\\n\\r\\n        storageT.storePendingMarketOrder(\\r\\n            StorageInterfaceV5.PendingMarketOrder(\\r\\n                StorageInterfaceV5.Trade(sender, pairIndex, index, 0, 0, 0, false, 0, 0, 0),\\r\\n                0,\\r\\n                0,\\r\\n                0,\\r\\n                0,\\r\\n                0\\r\\n            ),\\r\\n            orderId,\\r\\n            false\\r\\n        );\\r\\n\\r\\n        emit MarketOrderInitiated(orderId, sender, pairIndex, false);\\r\\n    }\\r\\n\\r\\n    // Manage limit order (OPEN)\\r\\n    function updateOpenLimitOrder(\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint price, // PRECISION\\r\\n        uint tp,\\r\\n        uint sl\\r\\n    ) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n        require(storageT.hasOpenLimitOrder(sender, pairIndex, index), \\\"NO_LIMIT\\\");\\r\\n\\r\\n        StorageInterfaceV5.OpenLimitOrder memory o = storageT.getOpenLimitOrder(sender, pairIndex, index);\\r\\n\\r\\n        require(tp == 0 || (o.buy ? tp > price : tp < price), \\\"WRONG_TP\\\");\\r\\n        require(sl == 0 || (o.buy ? sl < price : sl > price), \\\"WRONG_SL\\\");\\r\\n\\r\\n        checkNoPendingTrigger(sender, pairIndex, index, StorageInterfaceV5.LimitOrder.OPEN);\\r\\n\\r\\n        o.minPrice = price;\\r\\n        o.maxPrice = price;\\r\\n        o.tp = tp;\\r\\n        o.sl = sl;\\r\\n\\r\\n        storageT.updateOpenLimitOrder(o);\\r\\n        storageT.callbacks().setTradeLastUpdated(\\r\\n            sender,\\r\\n            pairIndex,\\r\\n            index,\\r\\n            TradingCallbacksV6_3_2.TradeType.LIMIT,\\r\\n            ChainUtils.getBlockNumber()\\r\\n        );\\r\\n\\r\\n        emit OpenLimitUpdated(sender, pairIndex, index, price, tp, sl);\\r\\n    }\\r\\n\\r\\n    function cancelOpenLimitOrder(uint pairIndex, uint index) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n        require(storageT.hasOpenLimitOrder(sender, pairIndex, index), \\\"NO_LIMIT\\\");\\r\\n\\r\\n        StorageInterfaceV5.OpenLimitOrder memory o = storageT.getOpenLimitOrder(sender, pairIndex, index);\\r\\n\\r\\n        checkNoPendingTrigger(sender, pairIndex, index, StorageInterfaceV5.LimitOrder.OPEN);\\r\\n\\r\\n        storageT.unregisterOpenLimitOrder(sender, pairIndex, index);\\r\\n        storageT.transferDai(address(storageT), sender, o.positionSize);\\r\\n\\r\\n        emit OpenLimitCanceled(sender, pairIndex, index);\\r\\n    }\\r\\n\\r\\n    // Manage limit order (TP/SL)\\r\\n    function updateTp(uint pairIndex, uint index, uint newTp) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        checkNoPendingTrigger(sender, pairIndex, index, StorageInterfaceV5.LimitOrder.TP);\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t = storageT.openTrades(sender, pairIndex, index);\\r\\n        require(t.leverage > 0, \\\"NO_TRADE\\\");\\r\\n\\r\\n        storageT.updateTp(sender, pairIndex, index, newTp);\\r\\n        storageT.callbacks().setTpLastUpdated(\\r\\n            sender,\\r\\n            pairIndex,\\r\\n            index,\\r\\n            TradingCallbacksV6_3_2.TradeType.MARKET,\\r\\n            ChainUtils.getBlockNumber()\\r\\n        );\\r\\n\\r\\n        emit TpUpdated(sender, pairIndex, index, newTp);\\r\\n    }\\r\\n\\r\\n    function updateSl(uint pairIndex, uint index, uint newSl) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        checkNoPendingTrigger(sender, pairIndex, index, StorageInterfaceV5.LimitOrder.SL);\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t = storageT.openTrades(sender, pairIndex, index);\\r\\n        StorageInterfaceV5.TradeInfo memory i = storageT.openTradesInfo(sender, pairIndex, index);\\r\\n\\r\\n        require(t.leverage > 0, \\\"NO_TRADE\\\");\\r\\n\\r\\n        uint maxSlDist = (t.openPrice * MAX_SL_P) / 100 / t.leverage;\\r\\n\\r\\n        require(\\r\\n            newSl == 0 || (t.buy ? newSl >= t.openPrice - maxSlDist : newSl <= t.openPrice + maxSlDist),\\r\\n            \\\"SL_TOO_BIG\\\"\\r\\n        );\\r\\n\\r\\n        AggregatorInterfaceV6_2 aggregator = storageT.priceAggregator();\\r\\n\\r\\n        if (newSl == 0 || !aggregator.pairsStorage().guaranteedSlEnabled(pairIndex)) {\\r\\n            storageT.updateSl(sender, pairIndex, index, newSl);\\r\\n            storageT.callbacks().setSlLastUpdated(\\r\\n                sender,\\r\\n                pairIndex,\\r\\n                index,\\r\\n                TradingCallbacksV6_3_2.TradeType.MARKET,\\r\\n                ChainUtils.getBlockNumber()\\r\\n            );\\r\\n\\r\\n            emit SlUpdated(sender, pairIndex, index, newSl);\\r\\n        } else {\\r\\n            uint orderId = aggregator.getPrice(\\r\\n                pairIndex,\\r\\n                AggregatorInterfaceV6_2.OrderType.UPDATE_SL,\\r\\n                (t.initialPosToken * i.tokenPriceDai * t.leverage) / PRECISION\\r\\n            );\\r\\n\\r\\n            aggregator.storePendingSlOrder(\\r\\n                orderId,\\r\\n                AggregatorInterfaceV6_2.PendingSl(sender, pairIndex, index, t.openPrice, t.buy, newSl)\\r\\n            );\\r\\n\\r\\n            emit SlUpdateInitiated(orderId, sender, pairIndex, index, newSl);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Execute limit order\\r\\n    function executeNftOrder(\\r\\n        StorageInterfaceV5.LimitOrder orderType,\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        uint nftId,\\r\\n        uint nftType\\r\\n    ) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        require(nftType >= 1 && nftType <= 5, \\\"WRONG_NFT_TYPE\\\");\\r\\n        require(storageT.nfts(nftType - 1).ownerOf(nftId) == sender, \\\"NO_NFT\\\");\\r\\n\\r\\n        require(block.number >= storageT.nftLastSuccess(nftId) + storageT.nftSuccessTimelock(), \\\"SUCCESS_TIMELOCK\\\");\\r\\n        require(\\r\\n            canExecute(\\r\\n                orderType,\\r\\n                TradingCallbacksV6_3_2.SimplifiedTradeId(\\r\\n                    trader,\\r\\n                    pairIndex,\\r\\n                    index,\\r\\n                    orderType == StorageInterfaceV5.LimitOrder.OPEN\\r\\n                        ? TradingCallbacksV6_3_2.TradeType.LIMIT\\r\\n                        : TradingCallbacksV6_3_2.TradeType.MARKET\\r\\n                )\\r\\n            ),\\r\\n            \\\"IN_TIMEOUT\\\"\\r\\n        );\\r\\n\\r\\n        {\\r\\n            (bytes32 nftHash, bytes32 botHash) = nftRewards.getNftBotHashes(\\r\\n                block.number,\\r\\n                sender,\\r\\n                nftId,\\r\\n                trader,\\r\\n                pairIndex,\\r\\n                index\\r\\n            );\\r\\n            require(!nftRewards.nftBotInUse(nftHash, botHash), \\\"BOT_IN_USE\\\");\\r\\n\\r\\n            nftRewards.setNftBotInUse(nftHash, botHash);\\r\\n        }\\r\\n\\r\\n        StorageInterfaceV5.Trade memory t;\\r\\n\\r\\n        if (orderType == StorageInterfaceV5.LimitOrder.OPEN) {\\r\\n            require(storageT.hasOpenLimitOrder(trader, pairIndex, index), \\\"NO_LIMIT\\\");\\r\\n        } else {\\r\\n            t = storageT.openTrades(trader, pairIndex, index);\\r\\n\\r\\n            require(t.leverage > 0, \\\"NO_TRADE\\\");\\r\\n\\r\\n            if (orderType == StorageInterfaceV5.LimitOrder.LIQ) {\\r\\n                uint liqPrice = borrowingFees.getTradeLiquidationPrice(\\r\\n                    GNSBorrowingFeesInterfaceV6_3_2.LiqPriceInput(\\r\\n                        t.trader,\\r\\n                        t.pairIndex,\\r\\n                        t.index,\\r\\n                        t.openPrice,\\r\\n                        t.buy,\\r\\n                        (t.initialPosToken * storageT.openTradesInfo(t.trader, t.pairIndex, t.index).tokenPriceDai) /\\r\\n                            PRECISION,\\r\\n                        t.leverage\\r\\n                    )\\r\\n                );\\r\\n\\r\\n                require(t.sl == 0 || (t.buy ? liqPrice > t.sl : liqPrice < t.sl), \\\"HAS_SL\\\");\\r\\n            } else {\\r\\n                require(orderType != StorageInterfaceV5.LimitOrder.SL || t.sl > 0, \\\"NO_SL\\\");\\r\\n                require(orderType != StorageInterfaceV5.LimitOrder.TP || t.tp > 0, \\\"NO_TP\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        NftRewardsInterfaceV6_3_1.TriggeredLimitId memory triggeredLimitId = NftRewardsInterfaceV6_3_1.TriggeredLimitId(\\r\\n            trader,\\r\\n            pairIndex,\\r\\n            index,\\r\\n            orderType\\r\\n        );\\r\\n\\r\\n        if (!nftRewards.triggered(triggeredLimitId) || nftRewards.timedOut(triggeredLimitId)) {\\r\\n            uint leveragedPosDai;\\r\\n\\r\\n            if (orderType == StorageInterfaceV5.LimitOrder.OPEN) {\\r\\n                StorageInterfaceV5.OpenLimitOrder memory l = storageT.getOpenLimitOrder(trader, pairIndex, index);\\r\\n\\r\\n                leveragedPosDai = l.positionSize * l.leverage;\\r\\n                (uint priceImpactP, ) = pairInfos.getTradePriceImpact(0, l.pairIndex, l.buy, leveragedPosDai);\\r\\n\\r\\n                require(priceImpactP * l.leverage <= pairInfos.maxNegativePnlOnOpenP(), \\\"PRICE_IMPACT_TOO_HIGH\\\");\\r\\n            } else {\\r\\n                leveragedPosDai =\\r\\n                    (t.initialPosToken * storageT.openTradesInfo(trader, pairIndex, index).tokenPriceDai * t.leverage) /\\r\\n                    PRECISION;\\r\\n            }\\r\\n\\r\\n            storageT.transferLinkToAggregator(sender, pairIndex, leveragedPosDai);\\r\\n\\r\\n            AggregatorInterfaceV6_2 aggregator = storageT.priceAggregator();\\r\\n            uint orderId = aggregator.getPrice(\\r\\n                pairIndex,\\r\\n                orderType == StorageInterfaceV5.LimitOrder.OPEN\\r\\n                    ? AggregatorInterfaceV6_2.OrderType.LIMIT_OPEN\\r\\n                    : AggregatorInterfaceV6_2.OrderType.LIMIT_CLOSE,\\r\\n                leveragedPosDai\\r\\n            );\\r\\n\\r\\n            storageT.storePendingNftOrder(\\r\\n                StorageInterfaceV5.PendingNftOrder(sender, nftId, trader, pairIndex, index, orderType),\\r\\n                orderId\\r\\n            );\\r\\n\\r\\n            nftRewards.storeFirstToTrigger(triggeredLimitId, sender, aggregator.linkFee(pairIndex, leveragedPosDai));\\r\\n\\r\\n            emit NftOrderInitiated(orderId, sender, trader, pairIndex);\\r\\n        } else {\\r\\n            nftRewards.storeTriggerSameBlock(triggeredLimitId, sender);\\r\\n\\r\\n            emit NftOrderSameBlock(sender, trader, pairIndex);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Market timeout\\r\\n    function openTradeMarketTimeout(uint _order) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        StorageInterfaceV5.PendingMarketOrder memory o = storageT.reqID_pendingMarketOrder(_order);\\r\\n        StorageInterfaceV5.Trade memory t = o.trade;\\r\\n\\r\\n        require(o.block > 0 && block.number >= o.block + marketOrdersTimeout, \\\"WAIT_TIMEOUT\\\");\\r\\n        require(t.trader == sender, \\\"NOT_YOUR_ORDER\\\");\\r\\n        require(t.leverage > 0, \\\"WRONG_MARKET_ORDER_TYPE\\\");\\r\\n\\r\\n        storageT.unregisterPendingMarketOrder(_order, true);\\r\\n        storageT.transferDai(address(storageT), sender, t.positionSizeDai);\\r\\n\\r\\n        emit ChainlinkCallbackTimeout(_order, o);\\r\\n    }\\r\\n\\r\\n    function closeTradeMarketTimeout(uint _order) external notContract notDone {\\r\\n        address sender = _msgSender();\\r\\n\\r\\n        StorageInterfaceV5.PendingMarketOrder memory o = storageT.reqID_pendingMarketOrder(_order);\\r\\n        StorageInterfaceV5.Trade memory t = o.trade;\\r\\n\\r\\n        require(o.block > 0 && block.number >= o.block + marketOrdersTimeout, \\\"WAIT_TIMEOUT\\\");\\r\\n        require(t.trader == sender, \\\"NOT_YOUR_ORDER\\\");\\r\\n        require(t.leverage == 0, \\\"WRONG_MARKET_ORDER_TYPE\\\");\\r\\n\\r\\n        storageT.unregisterPendingMarketOrder(_order, false);\\r\\n\\r\\n        (bool success, ) = address(this).delegatecall(\\r\\n            abi.encodeWithSignature(\\\"closeTradeMarket(uint256,uint256)\\\", t.pairIndex, t.index)\\r\\n        );\\r\\n\\r\\n        if (!success) {\\r\\n            emit CouldNotCloseTrade(sender, t.pairIndex, t.index);\\r\\n        }\\r\\n\\r\\n        emit ChainlinkCallbackTimeout(_order, o);\\r\\n    }\\r\\n\\r\\n    // Helpers\\r\\n    function checkNoPendingTrigger(\\r\\n        address trader,\\r\\n        uint pairIndex,\\r\\n        uint index,\\r\\n        StorageInterfaceV5.LimitOrder orderType\\r\\n    ) private view {\\r\\n        NftRewardsInterfaceV6_3_1.TriggeredLimitId memory triggeredLimitId = NftRewardsInterfaceV6_3_1.TriggeredLimitId(\\r\\n            trader,\\r\\n            pairIndex,\\r\\n            index,\\r\\n            orderType\\r\\n        );\\r\\n        require(!nftRewards.triggered(triggeredLimitId) || nftRewards.timedOut(triggeredLimitId), \\\"PENDING_TRIGGER\\\");\\r\\n    }\\r\\n\\r\\n    function canExecute(\\r\\n        StorageInterfaceV5.LimitOrder orderType,\\r\\n        TradingCallbacksV6_3_2.SimplifiedTradeId memory id\\r\\n    ) private view returns (bool) {\\r\\n        if (orderType == StorageInterfaceV5.LimitOrder.LIQ) return true;\\r\\n\\r\\n        uint b = ChainUtils.getBlockNumber();\\r\\n        address cb = storageT.callbacks();\\r\\n\\r\\n        if (orderType == StorageInterfaceV5.LimitOrder.TP) return !cb.isTpInTimeout(id, b);\\r\\n        if (orderType == StorageInterfaceV5.LimitOrder.SL) return !cb.isSlInTimeout(id, b);\\r\\n\\r\\n        return !cb.isLimitInTimeout(id, b);\\r\\n    }\\r\\n\\r\\n    function pairMaxLeverage(PairsStorageInterfaceV6 pairsStored, uint pairIndex) private view returns (uint) {\\r\\n        uint max = TradingCallbacksV6_3_2(storageT.callbacks()).pairMaxLeverage(pairIndex);\\r\\n        return max > 0 ? max : pairsStored.pairMaxLeverage(pairIndex);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 125\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/TradeUtils.sol\": {\r\n        \"TradeUtils\": \"0xa3033c66de1f14e1f9fbfc22f93b6cb14c939ac2\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract StorageInterfaceV5\",\"name\":\"_storageT\",\"type\":\"address\"},{\"internalType\":\"contract NftRewardsInterfaceV6_3_1\",\"name\":\"_nftRewards\",\"type\":\"address\"},{\"internalType\":\"contract GNSPairInfosInterfaceV6\",\"name\":\"_pairInfos\",\"type\":\"address\"},{\"internalType\":\"contract GNSReferralsInterfaceV6_2\",\"name\":\"_referrals\",\"type\":\"address\"},{\"internalType\":\"contract GNSBorrowingFeesInterfaceV6_3_2\",\"name\":\"_borrowingFees\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxPosDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketOrdersTimeout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialPosToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionSizeDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sl\",\"type\":\"uint256\"}],\"internalType\":\"struct StorageInterfaceV5.Trade\",\"name\":\"trade\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wantedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippageP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spreadReductionP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct StorageInterfaceV5.PendingMarketOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"ChainlinkCallbackTimeout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"CouldNotCloseTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"done\",\"type\":\"bool\"}],\"name\":\"Done\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"MarketOrderInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftHolder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"}],\"name\":\"NftOrderInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftHolder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"}],\"name\":\"NftOrderSameBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NumberUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"OpenLimitCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"OpenLimitPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSl\",\"type\":\"uint256\"}],\"name\":\"OpenLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSl\",\"type\":\"uint256\"}],\"name\":\"SlUpdateInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSl\",\"type\":\"uint256\"}],\"name\":\"SlUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTp\",\"type\":\"uint256\"}],\"name\":\"TpUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_msgSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowingFees\",\"outputs\":[{\"internalType\":\"contract GNSBorrowingFeesInterfaceV6_3_2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"cancelOpenLimitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"closeTradeMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_order\",\"type\":\"uint256\"}],\"name\":\"closeTradeMarketTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"call_data\",\"type\":\"bytes\"}],\"name\":\"delegatedAction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"done\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum StorageInterfaceV5.LimitOrder\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftType\",\"type\":\"uint256\"}],\"name\":\"executeNftOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketOrdersTimeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPosDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftRewards\",\"outputs\":[{\"internalType\":\"contract NftRewardsInterfaceV6_3_1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialPosToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionSizeDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sl\",\"type\":\"uint256\"}],\"internalType\":\"struct StorageInterfaceV5.Trade\",\"name\":\"t\",\"type\":\"tuple\"},{\"internalType\":\"enum NftRewardsInterfaceV6_3_1.OpenLimitOrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"spreadReductionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippageP\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"openTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_order\",\"type\":\"uint256\"}],\"name\":\"openTradeMarketTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairInfos\",\"outputs\":[{\"internalType\":\"contract GNSPairInfosInterfaceV6\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"contract GNSReferralsInterfaceV6_2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"setDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMarketOrdersTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxPosDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storageT\",\"outputs\":[{\"internalType\":\"contract StorageInterfaceV5\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sl\",\"type\":\"uint256\"}],\"name\":\"updateOpenLimitOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSl\",\"type\":\"uint256\"}],\"name\":\"updateSl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newTp\",\"type\":\"uint256\"}],\"name\":\"updateTp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GNSTradingV6_3_2", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "125", "ConstructorArguments": "000000000000000000000000aee4d11a16b2bc65edd6416fb626eb404a6d65bd0000000000000000000000008103c0665a544201bbf606d90845d1b2d8005f1c000000000000000000000000ee7442accc1c27f2c69423576d3b1d25b563e9770000000000000000000000000f9498b1206bf9ffde2a2321fdb56f573a05242500000000000000000000000083ae6fadb88872d77299550dc746b95d0196fe1500000000000000000000000000000000000000000000152d02c7e14af6800000000000000000000000000000000000000000000000000000000000000000001e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}