{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/AccessControlRegistryAdminned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/SelfMulticall.sol\\\";\\nimport \\\"./RoleDeriver.sol\\\";\\nimport \\\"./interfaces/IAccessControlRegistryAdminned.sol\\\";\\nimport \\\"./interfaces/IAccessControlRegistry.sol\\\";\\n\\n/// @title Contract to be inherited by contracts whose adminship functionality\\n/// will be implemented using AccessControlRegistry\\ncontract AccessControlRegistryAdminned is\\n    SelfMulticall,\\n    RoleDeriver,\\n    IAccessControlRegistryAdminned\\n{\\n    /// @notice AccessControlRegistry contract address\\n    address public immutable override accessControlRegistry;\\n\\n    /// @notice Admin role description\\n    string public override adminRoleDescription;\\n\\n    bytes32 internal immutable adminRoleDescriptionHash;\\n\\n    /// @dev Contracts deployed with the same admin role descriptions will have\\n    /// the same roles, meaning that granting an account a role will authorize\\n    /// it in multiple contracts. Unless you want your deployed contract to\\n    /// share the role configuration of another contract, use a unique admin\\n    /// role description.\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription\\n    ) {\\n        require(_accessControlRegistry != address(0), \\\"ACR address zero\\\");\\n        require(\\n            bytes(_adminRoleDescription).length > 0,\\n            \\\"Admin role description empty\\\"\\n        );\\n        accessControlRegistry = _accessControlRegistry;\\n        adminRoleDescription = _adminRoleDescription;\\n        adminRoleDescriptionHash = keccak256(\\n            abi.encodePacked(_adminRoleDescription)\\n        );\\n    }\\n\\n    /// @notice Derives the admin role for the specific manager address\\n    /// @param manager Manager address\\n    /// @return adminRole Admin role\\n    function _deriveAdminRole(\\n        address manager\\n    ) internal view returns (bytes32 adminRole) {\\n        adminRole = _deriveRole(\\n            _deriveRootRole(manager),\\n            adminRoleDescriptionHash\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/AccessControlRegistryAdminnedWithManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AccessControlRegistryAdminned.sol\\\";\\nimport \\\"./interfaces/IAccessControlRegistryAdminnedWithManager.sol\\\";\\n\\n/// @title Contract to be inherited by contracts with manager whose adminship\\n/// functionality will be implemented using AccessControlRegistry\\n/// @notice The manager address here is expected to belong to an\\n/// AccessControlRegistry user that is a multisig/DAO\\ncontract AccessControlRegistryAdminnedWithManager is\\n    AccessControlRegistryAdminned,\\n    IAccessControlRegistryAdminnedWithManager\\n{\\n    /// @notice Address of the manager that manages the related\\n    /// AccessControlRegistry roles\\n    /// @dev The mutability of the manager role can be implemented by\\n    /// designating an OwnableCallForwarder contract as the manager. The\\n    /// ownership of this contract can then be transferred, effectively\\n    /// transferring managership.\\n    address public immutable override manager;\\n\\n    /// @notice Admin role\\n    /// @dev Since `manager` is immutable, so is `adminRole`\\n    bytes32 public immutable override adminRole;\\n\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    /// @param _manager Manager address\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription,\\n        address _manager\\n    )\\n        AccessControlRegistryAdminned(\\n            _accessControlRegistry,\\n            _adminRoleDescription\\n        )\\n    {\\n        require(_manager != address(0), \\\"Manager address zero\\\");\\n        manager = _manager;\\n        adminRole = _deriveAdminRole(_manager);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/interfaces/IAccessControlRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport \\\"../../utils/interfaces/IExpiringMetaTxForwarder.sol\\\";\\nimport \\\"../../utils/interfaces/ISelfMulticall.sol\\\";\\n\\ninterface IAccessControlRegistry is\\n    IAccessControl,\\n    IExpiringMetaTxForwarder,\\n    ISelfMulticall\\n{\\n    event InitializedManager(\\n        bytes32 indexed rootRole,\\n        address indexed manager,\\n        address sender\\n    );\\n\\n    event InitializedRole(\\n        bytes32 indexed role,\\n        bytes32 indexed adminRole,\\n        string description,\\n        address sender\\n    );\\n\\n    function initializeManager(address manager) external;\\n\\n    function initializeRoleAndGrantToSender(\\n        bytes32 adminRole,\\n        string calldata description\\n    ) external returns (bytes32 role);\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/interfaces/IAccessControlRegistryAdminned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/interfaces/ISelfMulticall.sol\\\";\\n\\ninterface IAccessControlRegistryAdminned is ISelfMulticall {\\n    function accessControlRegistry() external view returns (address);\\n\\n    function adminRoleDescription() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlRegistryAdminned.sol\\\";\\n\\ninterface IAccessControlRegistryAdminnedWithManager is\\n    IAccessControlRegistryAdminned\\n{\\n    function manager() external view returns (address);\\n\\n    function adminRole() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/RoleDeriver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contract to be inherited by contracts that will derive\\n/// AccessControlRegistry roles\\n/// @notice If a contract interfaces with AccessControlRegistry and needs to\\n/// derive roles, it should inherit this contract instead of re-implementing\\n/// the logic\\ncontract RoleDeriver {\\n    /// @notice Derives the root role of the manager\\n    /// @param manager Manager address\\n    /// @return rootRole Root role\\n    function _deriveRootRole(\\n        address manager\\n    ) internal pure returns (bytes32 rootRole) {\\n        rootRole = keccak256(abi.encodePacked(manager));\\n    }\\n\\n    /// @notice Derives the role using its admin role and description\\n    /// @dev This implies that roles adminned by the same role cannot have the\\n    /// same description\\n    /// @param adminRole Admin role\\n    /// @param description Human-readable description of the role\\n    /// @return role Role\\n    function _deriveRole(\\n        bytes32 adminRole,\\n        string memory description\\n    ) internal pure returns (bytes32 role) {\\n        role = _deriveRole(adminRole, keccak256(abi.encodePacked(description)));\\n    }\\n\\n    /// @notice Derives the role using its admin role and description hash\\n    /// @dev This implies that roles adminned by the same role cannot have the\\n    /// same description\\n    /// @param adminRole Admin role\\n    /// @param descriptionHash Hash of the human-readable description of the\\n    /// role\\n    /// @return role Role\\n    function _deriveRole(\\n        bytes32 adminRole,\\n        bytes32 descriptionHash\\n    ) internal pure returns (bytes32 role) {\\n        role = keccak256(abi.encodePacked(adminRole, descriptionHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/aggregation/Median.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Sort.sol\\\";\\nimport \\\"./QuickSelect.sol\\\";\\n\\n/// @title Contract to be inherited by contracts that will calculate the median\\n/// of an array\\n/// @notice The operation will be in-place, i.e., the array provided as the\\n/// argument will be modified.\\ncontract Median is Sort, Quickselect {\\n    /// @notice Returns the median of the array\\n    /// @dev Uses an unrolled sorting implementation for shorter arrays and\\n    /// quickselect for longer arrays for gas cost efficiency\\n    /// @param array Array whose median is to be calculated\\n    /// @return Median of the array\\n    function median(int256[] memory array) internal pure returns (int256) {\\n        uint256 arrayLength = array.length;\\n        if (arrayLength <= MAX_SORT_LENGTH) {\\n            sort(array);\\n            if (arrayLength % 2 == 1) {\\n                return array[arrayLength / 2];\\n            } else {\\n                assert(arrayLength != 0);\\n                unchecked {\\n                    return\\n                        average(\\n                            array[arrayLength / 2 - 1],\\n                            array[arrayLength / 2]\\n                        );\\n                }\\n            }\\n        } else {\\n            if (arrayLength % 2 == 1) {\\n                return array[quickselectK(array, arrayLength / 2)];\\n            } else {\\n                uint256 mid1;\\n                uint256 mid2;\\n                unchecked {\\n                    (mid1, mid2) = quickselectKPlusOne(\\n                        array,\\n                        arrayLength / 2 - 1\\n                    );\\n                }\\n                return average(array[mid1], array[mid2]);\\n            }\\n        }\\n    }\\n\\n    /// @notice Averages two signed integers without overflowing\\n    /// @param x Integer x\\n    /// @param y Integer y\\n    /// @return Average of integers x and y\\n    function average(int256 x, int256 y) private pure returns (int256) {\\n        unchecked {\\n            int256 averageRoundedDownToNegativeInfinity = (x >> 1) +\\n                (y >> 1) +\\n                (x & y & 1);\\n            // If the average rounded down to negative infinity is negative\\n            // (i.e., its 256th sign bit is set), and one of (x, y) is even and\\n            // the other one is odd (i.e., the 1st bit of their xor is set),\\n            // add 1 to round the average down to zero instead.\\n            // We will typecast the signed integer to unsigned to logical-shift\\n            // int256(uint256(signedInt)) >> 255 ~= signedInt >>> 255\\n            return\\n                averageRoundedDownToNegativeInfinity +\\n                (int256(\\n                    (uint256(averageRoundedDownToNegativeInfinity) >> 255)\\n                ) & (x ^ y));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/aggregation/QuickSelect.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contract to be inherited by contracts that will calculate the index\\n/// of the k-th and optionally (k+1)-th largest elements in the array\\n/// @notice Uses quickselect, which operates in-place, i.e., the array provided\\n/// as the argument will be modified.\\ncontract Quickselect {\\n    /// @notice Returns the index of the k-th largest element in the array\\n    /// @param array Array in which k-th largest element will be searched\\n    /// @param k K\\n    /// @return indK Index of the k-th largest element\\n    function quickselectK(\\n        int256[] memory array,\\n        uint256 k\\n    ) internal pure returns (uint256 indK) {\\n        uint256 arrayLength = array.length;\\n        assert(arrayLength > 0);\\n        unchecked {\\n            (indK, ) = quickselect(array, 0, arrayLength - 1, k, false);\\n        }\\n    }\\n\\n    /// @notice Returns the index of the k-th and (k+1)-th largest elements in\\n    /// the array\\n    /// @param array Array in which k-th and (k+1)-th largest elements will be\\n    /// searched\\n    /// @param k K\\n    /// @return indK Index of the k-th largest element\\n    /// @return indKPlusOne Index of the (k+1)-th largest element\\n    function quickselectKPlusOne(\\n        int256[] memory array,\\n        uint256 k\\n    ) internal pure returns (uint256 indK, uint256 indKPlusOne) {\\n        uint256 arrayLength = array.length;\\n        assert(arrayLength > 1);\\n        unchecked {\\n            (indK, indKPlusOne) = quickselect(\\n                array,\\n                0,\\n                arrayLength - 1,\\n                k,\\n                true\\n            );\\n        }\\n    }\\n\\n    /// @notice Returns the index of the k-th largest element in the specified\\n    /// section of the (potentially unsorted) array\\n    /// @param array Array in which K will be searched for\\n    /// @param lo Starting index of the section of the array that K will be\\n    /// searched in\\n    /// @param hi Last index of the section of the array that K will be\\n    /// searched in\\n    /// @param k K\\n    /// @param selectKPlusOne If the index of the (k+1)-th largest element is\\n    /// to be returned\\n    /// @return indK Index of the k-th largest element\\n    /// @return indKPlusOne Index of the (k+1)-th largest element (only set if\\n    /// `selectKPlusOne` is `true`)\\n    function quickselect(\\n        int256[] memory array,\\n        uint256 lo,\\n        uint256 hi,\\n        uint256 k,\\n        bool selectKPlusOne\\n    ) private pure returns (uint256 indK, uint256 indKPlusOne) {\\n        if (lo == hi) {\\n            return (k, 0);\\n        }\\n        uint256 indPivot = partition(array, lo, hi);\\n        if (k < indPivot) {\\n            unchecked {\\n                (indK, ) = quickselect(array, lo, indPivot - 1, k, false);\\n            }\\n        } else if (k > indPivot) {\\n            unchecked {\\n                (indK, ) = quickselect(array, indPivot + 1, hi, k, false);\\n            }\\n        } else {\\n            indK = indPivot;\\n        }\\n        // Since Quickselect ends in the array being partitioned around the\\n        // k-th largest element, we can continue searching towards right for\\n        // the (k+1)-th largest element, which is useful in calculating the\\n        // median of an array with even length\\n        if (selectKPlusOne) {\\n            unchecked {\\n                indKPlusOne = indK + 1;\\n            }\\n            uint256 i;\\n            unchecked {\\n                i = indKPlusOne + 1;\\n            }\\n            uint256 arrayLength = array.length;\\n            for (; i < arrayLength; ) {\\n                if (array[i] < array[indKPlusOne]) {\\n                    indKPlusOne = i;\\n                }\\n                unchecked {\\n                    i++;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Partitions the array into two around a pivot\\n    /// @param array Array that will be partitioned\\n    /// @param lo Starting index of the section of the array that will be\\n    /// partitioned\\n    /// @param hi Last index of the section of the array that will be\\n    /// partitioned\\n    /// @return pivotInd Pivot index\\n    function partition(\\n        int256[] memory array,\\n        uint256 lo,\\n        uint256 hi\\n    ) private pure returns (uint256 pivotInd) {\\n        if (lo == hi) {\\n            return lo;\\n        }\\n        int256 pivot = array[lo];\\n        uint256 i = lo;\\n        unchecked {\\n            pivotInd = hi + 1;\\n        }\\n        while (true) {\\n            do {\\n                unchecked {\\n                    i++;\\n                }\\n            } while (i < array.length && array[i] < pivot);\\n            do {\\n                unchecked {\\n                    pivotInd--;\\n                }\\n            } while (array[pivotInd] > pivot);\\n            if (i >= pivotInd) {\\n                (array[lo], array[pivotInd]) = (array[pivotInd], array[lo]);\\n                return pivotInd;\\n            }\\n            (array[i], array[pivotInd]) = (array[pivotInd], array[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/aggregation/Sort.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contract to be inherited by contracts that will sort an array using\\n/// an unrolled implementation\\n/// @notice The operation will be in-place, i.e., the array provided as the\\n/// argument will be modified.\\ncontract Sort {\\n    uint256 internal constant MAX_SORT_LENGTH = 9;\\n\\n    /// @notice Sorts the array\\n    /// @param array Array to be sorted\\n    function sort(int256[] memory array) internal pure {\\n        uint256 arrayLength = array.length;\\n        require(arrayLength <= MAX_SORT_LENGTH, \\\"Array too long to sort\\\");\\n        // Do a binary search\\n        if (arrayLength < 6) {\\n            // Possible lengths: 1, 2, 3, 4, 5\\n            if (arrayLength < 4) {\\n                // Possible lengths: 1, 2, 3\\n                if (arrayLength == 3) {\\n                    // Length: 3\\n                    swapIfFirstIsLarger(array, 0, 1);\\n                    swapIfFirstIsLarger(array, 1, 2);\\n                    swapIfFirstIsLarger(array, 0, 1);\\n                } else if (arrayLength == 2) {\\n                    // Length: 2\\n                    swapIfFirstIsLarger(array, 0, 1);\\n                }\\n                // Do nothing for Length: 1\\n            } else {\\n                // Possible lengths: 4, 5\\n                if (arrayLength == 5) {\\n                    // Length: 5\\n                    swapIfFirstIsLarger(array, 1, 2);\\n                    swapIfFirstIsLarger(array, 3, 4);\\n                    swapIfFirstIsLarger(array, 1, 3);\\n                    swapIfFirstIsLarger(array, 0, 2);\\n                    swapIfFirstIsLarger(array, 2, 4);\\n                    swapIfFirstIsLarger(array, 0, 3);\\n                    swapIfFirstIsLarger(array, 0, 1);\\n                    swapIfFirstIsLarger(array, 2, 3);\\n                    swapIfFirstIsLarger(array, 1, 2);\\n                } else {\\n                    // Length: 4\\n                    swapIfFirstIsLarger(array, 0, 1);\\n                    swapIfFirstIsLarger(array, 2, 3);\\n                    swapIfFirstIsLarger(array, 1, 3);\\n                    swapIfFirstIsLarger(array, 0, 2);\\n                    swapIfFirstIsLarger(array, 1, 2);\\n                }\\n            }\\n        } else {\\n            // Possible lengths: 6, 7, 8, 9\\n            if (arrayLength < 8) {\\n                // Possible lengths: 6, 7\\n                if (arrayLength == 7) {\\n                    // Length: 7\\n                    swapIfFirstIsLarger(array, 1, 2);\\n                    swapIfFirstIsLarger(array, 3, 4);\\n                    swapIfFirstIsLarger(array, 5, 6);\\n                    swapIfFirstIsLarger(array, 0, 2);\\n                    swapIfFirstIsLarger(array, 4, 6);\\n                    swapIfFirstIsLarger(array, 3, 5);\\n                    swapIfFirstIsLarger(array, 2, 6);\\n                    swapIfFirstIsLarger(array, 1, 5);\\n                    swapIfFirstIsLarger(array, 0, 4);\\n                    swapIfFirstIsLarger(array, 2, 5);\\n                    swapIfFirstIsLarger(array, 0, 3);\\n                    swapIfFirstIsLarger(array, 2, 4);\\n                    swapIfFirstIsLarger(array, 1, 3);\\n                    swapIfFirstIsLarger(array, 0, 1);\\n                    swapIfFirstIsLarger(array, 2, 3);\\n                    swapIfFirstIsLarger(array, 4, 5);\\n                } else {\\n                    // Length: 6\\n                    swapIfFirstIsLarger(array, 0, 1);\\n                    swapIfFirstIsLarger(array, 2, 3);\\n                    swapIfFirstIsLarger(array, 4, 5);\\n                    swapIfFirstIsLarger(array, 1, 3);\\n                    swapIfFirstIsLarger(array, 3, 5);\\n                    swapIfFirstIsLarger(array, 1, 3);\\n                    swapIfFirstIsLarger(array, 2, 4);\\n                    swapIfFirstIsLarger(array, 0, 2);\\n                    swapIfFirstIsLarger(array, 2, 4);\\n                    swapIfFirstIsLarger(array, 3, 4);\\n                    swapIfFirstIsLarger(array, 1, 2);\\n                    swapIfFirstIsLarger(array, 2, 3);\\n                }\\n            } else {\\n                // Possible lengths: 8, 9\\n                if (arrayLength == 9) {\\n                    // Length: 9\\n                    swapIfFirstIsLarger(array, 1, 8);\\n                    swapIfFirstIsLarger(array, 2, 7);\\n                    swapIfFirstIsLarger(array, 3, 6);\\n                    swapIfFirstIsLarger(array, 4, 5);\\n                    swapIfFirstIsLarger(array, 1, 4);\\n                    swapIfFirstIsLarger(array, 5, 8);\\n                    swapIfFirstIsLarger(array, 0, 2);\\n                    swapIfFirstIsLarger(array, 6, 7);\\n                    swapIfFirstIsLarger(array, 2, 6);\\n                    swapIfFirstIsLarger(array, 7, 8);\\n                    swapIfFirstIsLarger(array, 0, 3);\\n                    swapIfFirstIsLarger(array, 4, 5);\\n                    swapIfFirstIsLarger(array, 0, 1);\\n                    swapIfFirstIsLarger(array, 3, 5);\\n                    swapIfFirstIsLarger(array, 6, 7);\\n                    swapIfFirstIsLarger(array, 2, 4);\\n                    swapIfFirstIsLarger(array, 1, 3);\\n                    swapIfFirstIsLarger(array, 5, 7);\\n                    swapIfFirstIsLarger(array, 4, 6);\\n                    swapIfFirstIsLarger(array, 1, 2);\\n                    swapIfFirstIsLarger(array, 3, 4);\\n                    swapIfFirstIsLarger(array, 5, 6);\\n                    swapIfFirstIsLarger(array, 7, 8);\\n                    swapIfFirstIsLarger(array, 2, 3);\\n                    swapIfFirstIsLarger(array, 4, 5);\\n                } else {\\n                    // Length: 8\\n                    swapIfFirstIsLarger(array, 0, 7);\\n                    swapIfFirstIsLarger(array, 1, 6);\\n                    swapIfFirstIsLarger(array, 2, 5);\\n                    swapIfFirstIsLarger(array, 3, 4);\\n                    swapIfFirstIsLarger(array, 0, 3);\\n                    swapIfFirstIsLarger(array, 4, 7);\\n                    swapIfFirstIsLarger(array, 1, 2);\\n                    swapIfFirstIsLarger(array, 5, 6);\\n                    swapIfFirstIsLarger(array, 0, 1);\\n                    swapIfFirstIsLarger(array, 2, 3);\\n                    swapIfFirstIsLarger(array, 4, 5);\\n                    swapIfFirstIsLarger(array, 6, 7);\\n                    swapIfFirstIsLarger(array, 3, 5);\\n                    swapIfFirstIsLarger(array, 2, 4);\\n                    swapIfFirstIsLarger(array, 1, 2);\\n                    swapIfFirstIsLarger(array, 3, 4);\\n                    swapIfFirstIsLarger(array, 5, 6);\\n                    swapIfFirstIsLarger(array, 2, 3);\\n                    swapIfFirstIsLarger(array, 4, 5);\\n                    swapIfFirstIsLarger(array, 3, 4);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Swaps two elements of an array if the first element is greater\\n    /// than the second\\n    /// @param array Array whose elements are to be swapped\\n    /// @param ind1 Index of the first element\\n    /// @param ind2 Index of the second element\\n    function swapIfFirstIsLarger(\\n        int256[] memory array,\\n        uint256 ind1,\\n        uint256 ind2\\n    ) private pure {\\n        if (array[ind1] > array[ind2]) {\\n            (array[ind1], array[ind2]) = (array[ind2], array[ind1]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/Api3ServerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./OevDapiServer.sol\\\";\\nimport \\\"./BeaconUpdatesWithSignedData.sol\\\";\\nimport \\\"./interfaces/IApi3ServerV1.sol\\\";\\n\\n/// @title First version of the contract that API3 uses to serve data feeds\\n/// @notice Api3ServerV1 serves data feeds in the form of Beacons, Beacon sets,\\n/// dAPIs, with optional OEV support for all of these.\\n/// The base Beacons are only updateable using signed data, and the Beacon sets\\n/// are updateable based on the Beacons, optionally using PSP. OEV proxy\\n/// Beacons and Beacon sets are updateable using OEV-signed data.\\n/// Api3ServerV1 does not support Beacons to be updated using RRP or PSP.\\ncontract Api3ServerV1 is\\n    OevDapiServer,\\n    BeaconUpdatesWithSignedData,\\n    IApi3ServerV1\\n{\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    /// @param _manager Manager address\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription,\\n        address _manager\\n    ) OevDapiServer(_accessControlRegistry, _adminRoleDescription, _manager) {}\\n\\n    /// @notice Reads the data feed with ID\\n    /// @param dataFeedId Data feed ID\\n    /// @return value Data feed value\\n    /// @return timestamp Data feed timestamp\\n    function readDataFeedWithId(\\n        bytes32 dataFeedId\\n    ) external view override returns (int224 value, uint32 timestamp) {\\n        return _readDataFeedWithId(dataFeedId);\\n    }\\n\\n    /// @notice Reads the data feed with dAPI name hash\\n    /// @param dapiNameHash dAPI name hash\\n    /// @return value Data feed value\\n    /// @return timestamp Data feed timestamp\\n    function readDataFeedWithDapiNameHash(\\n        bytes32 dapiNameHash\\n    ) external view override returns (int224 value, uint32 timestamp) {\\n        return _readDataFeedWithDapiNameHash(dapiNameHash);\\n    }\\n\\n    /// @notice Reads the data feed as the OEV proxy with ID\\n    /// @param dataFeedId Data feed ID\\n    /// @return value Data feed value\\n    /// @return timestamp Data feed timestamp\\n    function readDataFeedWithIdAsOevProxy(\\n        bytes32 dataFeedId\\n    ) external view override returns (int224 value, uint32 timestamp) {\\n        return _readDataFeedWithIdAsOevProxy(dataFeedId);\\n    }\\n\\n    /// @notice Reads the data feed as the OEV proxy with dAPI name hash\\n    /// @param dapiNameHash dAPI name hash\\n    /// @return value Data feed value\\n    /// @return timestamp Data feed timestamp\\n    function readDataFeedWithDapiNameHashAsOevProxy(\\n        bytes32 dapiNameHash\\n    ) external view override returns (int224 value, uint32 timestamp) {\\n        return _readDataFeedWithDapiNameHashAsOevProxy(dapiNameHash);\\n    }\\n\\n    function dataFeeds(\\n        bytes32 dataFeedId\\n    ) external view override returns (int224 value, uint32 timestamp) {\\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\\n    }\\n\\n    function oevProxyToIdToDataFeed(\\n        address proxy,\\n        bytes32 dataFeedId\\n    ) external view override returns (int224 value, uint32 timestamp) {\\n        DataFeed storage dataFeed = _oevProxyToIdToDataFeed[proxy][dataFeedId];\\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/BeaconUpdatesWithSignedData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./DataFeedServer.sol\\\";\\nimport \\\"./interfaces/IBeaconUpdatesWithSignedData.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n/// @title Contract that updates Beacons using signed data\\ncontract BeaconUpdatesWithSignedData is\\n    DataFeedServer,\\n    IBeaconUpdatesWithSignedData\\n{\\n    using ECDSA for bytes32;\\n\\n    /// @notice Updates a Beacon using data signed by the Airnode\\n    /// @dev The signed data here is intentionally very general for practical\\n    /// reasons. It is less demanding on the signer to have data signed once\\n    /// and use that everywhere.\\n    /// @param airnode Airnode address\\n    /// @param templateId Template ID\\n    /// @param timestamp Signature timestamp\\n    /// @param data Update data (an `int256` encoded in contract ABI)\\n    /// @param signature Template ID, timestamp and the update data signed by\\n    /// the Airnode\\n    /// @return beaconId Updated Beacon ID\\n    function updateBeaconWithSignedData(\\n        address airnode,\\n        bytes32 templateId,\\n        uint256 timestamp,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external override returns (bytes32 beaconId) {\\n        require(\\n            (\\n                keccak256(abi.encodePacked(templateId, timestamp, data))\\n                    .toEthSignedMessageHash()\\n            ).recover(signature) == airnode,\\n            \\\"Signature mismatch\\\"\\n        );\\n        beaconId = deriveBeaconId(airnode, templateId);\\n        int224 updatedValue = processBeaconUpdate(beaconId, timestamp, data);\\n        emit UpdatedBeaconWithSignedData(\\n            beaconId,\\n            updatedValue,\\n            uint32(timestamp)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/DapiServer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../access-control-registry/AccessControlRegistryAdminnedWithManager.sol\\\";\\nimport \\\"./DataFeedServer.sol\\\";\\nimport \\\"./interfaces/IDapiServer.sol\\\";\\n\\n/// @title Contract that serves dAPIs mapped to Beacons and Beacon sets\\n/// @notice Beacons and Beacon sets are addressed by immutable IDs. Although\\n/// this is trust-minimized, it requires users to manage the ID of the data\\n/// feed they are using. For when the user does not want to do this, dAPIs can\\n/// be used as an abstraction layer. By using a dAPI, the user delegates this\\n/// responsibility to dAPI management. It is important for dAPI management to\\n/// be restricted by consensus rules (by using a multisig or a DAO) and similar\\n/// trustless security mechanisms.\\ncontract DapiServer is\\n    AccessControlRegistryAdminnedWithManager,\\n    DataFeedServer,\\n    IDapiServer\\n{\\n    /// @notice dAPI name setter role description\\n    string public constant override DAPI_NAME_SETTER_ROLE_DESCRIPTION =\\n        \\\"dAPI name setter\\\";\\n\\n    /// @notice dAPI name setter role\\n    bytes32 public immutable override dapiNameSetterRole;\\n\\n    /// @notice dAPI name hash mapped to the data feed ID\\n    mapping(bytes32 => bytes32) public override dapiNameHashToDataFeedId;\\n\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    /// @param _manager Manager address\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription,\\n        address _manager\\n    )\\n        AccessControlRegistryAdminnedWithManager(\\n            _accessControlRegistry,\\n            _adminRoleDescription,\\n            _manager\\n        )\\n    {\\n        dapiNameSetterRole = _deriveRole(\\n            _deriveAdminRole(manager),\\n            DAPI_NAME_SETTER_ROLE_DESCRIPTION\\n        );\\n    }\\n\\n    /// @notice Sets the data feed ID the dAPI name points to\\n    /// @dev While a data feed ID refers to a specific Beacon or Beacon set,\\n    /// dAPI names provide a more abstract interface for convenience. This\\n    /// means a dAPI name that was pointing to a Beacon can be pointed to a\\n    /// Beacon set, then another Beacon set, etc.\\n    /// @param dapiName Human-readable dAPI name\\n    /// @param dataFeedId Data feed ID the dAPI name will point to\\n    function setDapiName(\\n        bytes32 dapiName,\\n        bytes32 dataFeedId\\n    ) external override {\\n        require(dapiName != bytes32(0), \\\"dAPI name zero\\\");\\n        require(\\n            msg.sender == manager ||\\n                IAccessControlRegistry(accessControlRegistry).hasRole(\\n                    dapiNameSetterRole,\\n                    msg.sender\\n                ),\\n            \\\"Sender cannot set dAPI name\\\"\\n        );\\n        dapiNameHashToDataFeedId[\\n            keccak256(abi.encodePacked(dapiName))\\n        ] = dataFeedId;\\n        emit SetDapiName(dataFeedId, dapiName, msg.sender);\\n    }\\n\\n    /// @notice Returns the data feed ID the dAPI name is set to\\n    /// @param dapiName dAPI name\\n    /// @return Data feed ID\\n    function dapiNameToDataFeedId(\\n        bytes32 dapiName\\n    ) external view override returns (bytes32) {\\n        return dapiNameHashToDataFeedId[keccak256(abi.encodePacked(dapiName))];\\n    }\\n\\n    /// @notice Reads the data feed with dAPI name hash\\n    /// @param dapiNameHash dAPI name hash\\n    /// @return value Data feed value\\n    /// @return timestamp Data feed timestamp\\n    function _readDataFeedWithDapiNameHash(\\n        bytes32 dapiNameHash\\n    ) internal view returns (int224 value, uint32 timestamp) {\\n        bytes32 dataFeedId = dapiNameHashToDataFeedId[dapiNameHash];\\n        require(dataFeedId != bytes32(0), \\\"dAPI name not set\\\");\\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\\n        require(timestamp > 0, \\\"Data feed not initialized\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/DataFeedServer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../utils/ExtendedSelfMulticall.sol\\\";\\nimport \\\"./aggregation/Median.sol\\\";\\nimport \\\"./interfaces/IDataFeedServer.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n/// @title Contract that serves Beacons and Beacon sets\\n/// @notice A Beacon is a live data feed addressed by an ID, which is derived\\n/// from an Airnode address and a template ID. This is suitable where the more\\n/// recent data point is always more favorable, e.g., in the context of an\\n/// asset price data feed. Beacons can also be seen as one-Airnode data feeds\\n/// that can be used individually or combined to build Beacon sets.\\ncontract DataFeedServer is ExtendedSelfMulticall, Median, IDataFeedServer {\\n    using ECDSA for bytes32;\\n\\n    // Airnodes serve their fulfillment data along with timestamps. This\\n    // contract casts the reported data to `int224` and the timestamp to\\n    // `uint32`, which works until year 2106.\\n    struct DataFeed {\\n        int224 value;\\n        uint32 timestamp;\\n    }\\n\\n    /// @notice Data feed with ID\\n    mapping(bytes32 => DataFeed) internal _dataFeeds;\\n\\n    /// @dev Reverts if the timestamp is from more than 1 hour in the future\\n    modifier onlyValidTimestamp(uint256 timestamp) virtual {\\n        unchecked {\\n            require(\\n                timestamp < block.timestamp + 1 hours,\\n                \\\"Timestamp not valid\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    /// @notice Updates the Beacon set using the current values of its Beacons\\n    /// @dev As an oddity, this function still works if some of the IDs in\\n    /// `beaconIds` belong to Beacon sets rather than Beacons. This can be used\\n    /// to implement hierarchical Beacon sets.\\n    /// @param beaconIds Beacon IDs\\n    /// @return beaconSetId Beacon set ID\\n    function updateBeaconSetWithBeacons(\\n        bytes32[] memory beaconIds\\n    ) public override returns (bytes32 beaconSetId) {\\n        (int224 updatedValue, uint32 updatedTimestamp) = aggregateBeacons(\\n            beaconIds\\n        );\\n        beaconSetId = deriveBeaconSetId(beaconIds);\\n        DataFeed storage beaconSet = _dataFeeds[beaconSetId];\\n        if (beaconSet.timestamp == updatedTimestamp) {\\n            require(\\n                beaconSet.value != updatedValue,\\n                \\\"Does not update Beacon set\\\"\\n            );\\n        }\\n        _dataFeeds[beaconSetId] = DataFeed({\\n            value: updatedValue,\\n            timestamp: updatedTimestamp\\n        });\\n        emit UpdatedBeaconSetWithBeacons(\\n            beaconSetId,\\n            updatedValue,\\n            updatedTimestamp\\n        );\\n    }\\n\\n    /// @notice Reads the data feed with ID\\n    /// @param dataFeedId Data feed ID\\n    /// @return value Data feed value\\n    /// @return timestamp Data feed timestamp\\n    function _readDataFeedWithId(\\n        bytes32 dataFeedId\\n    ) internal view returns (int224 value, uint32 timestamp) {\\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\\n        (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\\n        require(timestamp > 0, \\\"Data feed not initialized\\\");\\n    }\\n\\n    /// @notice Derives the Beacon ID from the Airnode address and template ID\\n    /// @param airnode Airnode address\\n    /// @param templateId Template ID\\n    /// @return beaconId Beacon ID\\n    function deriveBeaconId(\\n        address airnode,\\n        bytes32 templateId\\n    ) internal pure returns (bytes32 beaconId) {\\n        beaconId = keccak256(abi.encodePacked(airnode, templateId));\\n    }\\n\\n    /// @notice Derives the Beacon set ID from the Beacon IDs\\n    /// @dev Notice that `abi.encode()` is used over `abi.encodePacked()`\\n    /// @param beaconIds Beacon IDs\\n    /// @return beaconSetId Beacon set ID\\n    function deriveBeaconSetId(\\n        bytes32[] memory beaconIds\\n    ) internal pure returns (bytes32 beaconSetId) {\\n        beaconSetId = keccak256(abi.encode(beaconIds));\\n    }\\n\\n    /// @notice Called privately to process the Beacon update\\n    /// @param beaconId Beacon ID\\n    /// @param timestamp Timestamp used in the signature\\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\\n    /// @return updatedBeaconValue Updated Beacon value\\n    function processBeaconUpdate(\\n        bytes32 beaconId,\\n        uint256 timestamp,\\n        bytes calldata data\\n    )\\n        internal\\n        onlyValidTimestamp(timestamp)\\n        returns (int224 updatedBeaconValue)\\n    {\\n        updatedBeaconValue = decodeFulfillmentData(data);\\n        require(\\n            timestamp > _dataFeeds[beaconId].timestamp,\\n            \\\"Does not update timestamp\\\"\\n        );\\n        _dataFeeds[beaconId] = DataFeed({\\n            value: updatedBeaconValue,\\n            timestamp: uint32(timestamp)\\n        });\\n    }\\n\\n    /// @notice Called privately to decode the fulfillment data\\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\\n    /// @return decodedData Decoded fulfillment data\\n    function decodeFulfillmentData(\\n        bytes memory data\\n    ) internal pure returns (int224) {\\n        require(data.length == 32, \\\"Data length not correct\\\");\\n        int256 decodedData = abi.decode(data, (int256));\\n        require(\\n            decodedData >= type(int224).min && decodedData <= type(int224).max,\\n            \\\"Value typecasting error\\\"\\n        );\\n        return int224(decodedData);\\n    }\\n\\n    /// @notice Called privately to aggregate the Beacons and return the result\\n    /// @param beaconIds Beacon IDs\\n    /// @return value Aggregation value\\n    /// @return timestamp Aggregation timestamp\\n    function aggregateBeacons(\\n        bytes32[] memory beaconIds\\n    ) internal view returns (int224 value, uint32 timestamp) {\\n        uint256 beaconCount = beaconIds.length;\\n        require(beaconCount > 1, \\\"Specified less than two Beacons\\\");\\n        int256[] memory values = new int256[](beaconCount);\\n        int256[] memory timestamps = new int256[](beaconCount);\\n        for (uint256 ind = 0; ind < beaconCount; ) {\\n            DataFeed storage dataFeed = _dataFeeds[beaconIds[ind]];\\n            values[ind] = dataFeed.value;\\n            timestamps[ind] = int256(uint256(dataFeed.timestamp));\\n            unchecked {\\n                ind++;\\n            }\\n        }\\n        value = int224(median(values));\\n        timestamp = uint32(uint256(median(timestamps)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/interfaces/IApi3ServerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOevDapiServer.sol\\\";\\nimport \\\"./IBeaconUpdatesWithSignedData.sol\\\";\\n\\ninterface IApi3ServerV1 is IOevDapiServer, IBeaconUpdatesWithSignedData {\\n    function readDataFeedWithId(\\n        bytes32 dataFeedId\\n    ) external view returns (int224 value, uint32 timestamp);\\n\\n    function readDataFeedWithDapiNameHash(\\n        bytes32 dapiNameHash\\n    ) external view returns (int224 value, uint32 timestamp);\\n\\n    function readDataFeedWithIdAsOevProxy(\\n        bytes32 dataFeedId\\n    ) external view returns (int224 value, uint32 timestamp);\\n\\n    function readDataFeedWithDapiNameHashAsOevProxy(\\n        bytes32 dapiNameHash\\n    ) external view returns (int224 value, uint32 timestamp);\\n\\n    function dataFeeds(\\n        bytes32 dataFeedId\\n    ) external view returns (int224 value, uint32 timestamp);\\n\\n    function oevProxyToIdToDataFeed(\\n        address proxy,\\n        bytes32 dataFeedId\\n    ) external view returns (int224 value, uint32 timestamp);\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/interfaces/IBeaconUpdatesWithSignedData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IDataFeedServer.sol\\\";\\n\\ninterface IBeaconUpdatesWithSignedData is IDataFeedServer {\\n    function updateBeaconWithSignedData(\\n        address airnode,\\n        bytes32 templateId,\\n        uint256 timestamp,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external returns (bytes32 beaconId);\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/interfaces/IDapiServer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol\\\";\\nimport \\\"./IDataFeedServer.sol\\\";\\n\\ninterface IDapiServer is\\n    IAccessControlRegistryAdminnedWithManager,\\n    IDataFeedServer\\n{\\n    event SetDapiName(\\n        bytes32 indexed dataFeedId,\\n        bytes32 indexed dapiName,\\n        address sender\\n    );\\n\\n    function setDapiName(bytes32 dapiName, bytes32 dataFeedId) external;\\n\\n    function dapiNameToDataFeedId(\\n        bytes32 dapiName\\n    ) external view returns (bytes32);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DAPI_NAME_SETTER_ROLE_DESCRIPTION()\\n        external\\n        view\\n        returns (string memory);\\n\\n    function dapiNameSetterRole() external view returns (bytes32);\\n\\n    function dapiNameHashToDataFeedId(\\n        bytes32 dapiNameHash\\n    ) external view returns (bytes32 dataFeedId);\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/interfaces/IDataFeedServer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/interfaces/IExtendedSelfMulticall.sol\\\";\\n\\ninterface IDataFeedServer is IExtendedSelfMulticall {\\n    event UpdatedBeaconWithSignedData(\\n        bytes32 indexed beaconId,\\n        int224 value,\\n        uint32 timestamp\\n    );\\n\\n    event UpdatedBeaconSetWithBeacons(\\n        bytes32 indexed beaconSetId,\\n        int224 value,\\n        uint32 timestamp\\n    );\\n\\n    function updateBeaconSetWithBeacons(\\n        bytes32[] memory beaconIds\\n    ) external returns (bytes32 beaconSetId);\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/interfaces/IOevDapiServer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOevDataFeedServer.sol\\\";\\nimport \\\"./IDapiServer.sol\\\";\\n\\ninterface IOevDapiServer is IOevDataFeedServer, IDapiServer {}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/interfaces/IOevDataFeedServer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IDataFeedServer.sol\\\";\\n\\ninterface IOevDataFeedServer is IDataFeedServer {\\n    event UpdatedOevProxyBeaconWithSignedData(\\n        bytes32 indexed beaconId,\\n        address indexed proxy,\\n        bytes32 indexed updateId,\\n        int224 value,\\n        uint32 timestamp\\n    );\\n\\n    event UpdatedOevProxyBeaconSetWithSignedData(\\n        bytes32 indexed beaconSetId,\\n        address indexed proxy,\\n        bytes32 indexed updateId,\\n        int224 value,\\n        uint32 timestamp\\n    );\\n\\n    event Withdrew(\\n        address indexed oevProxy,\\n        address oevBeneficiary,\\n        uint256 amount\\n    );\\n\\n    function updateOevProxyDataFeedWithSignedData(\\n        address oevProxy,\\n        bytes32 dataFeedId,\\n        bytes32 updateId,\\n        uint256 timestamp,\\n        bytes calldata data,\\n        bytes[] calldata packedOevUpdateSignatures\\n    ) external payable;\\n\\n    function withdraw(address oevProxy) external;\\n\\n    function oevProxyToBalance(\\n        address oevProxy\\n    ) external view returns (uint256 balance);\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/OevDapiServer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./OevDataFeedServer.sol\\\";\\nimport \\\"./DapiServer.sol\\\";\\nimport \\\"./interfaces/IOevDapiServer.sol\\\";\\n\\n/// @title Contract that serves OEV dAPIs\\ncontract OevDapiServer is OevDataFeedServer, DapiServer, IOevDapiServer {\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    /// @param _manager Manager address\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription,\\n        address _manager\\n    ) DapiServer(_accessControlRegistry, _adminRoleDescription, _manager) {}\\n\\n    /// @notice Reads the data feed as the OEV proxy with dAPI name hash\\n    /// @param dapiNameHash dAPI name hash\\n    /// @return value Data feed value\\n    /// @return timestamp Data feed timestamp\\n    function _readDataFeedWithDapiNameHashAsOevProxy(\\n        bytes32 dapiNameHash\\n    ) internal view returns (int224 value, uint32 timestamp) {\\n        bytes32 dataFeedId = dapiNameHashToDataFeedId[dapiNameHash];\\n        require(dataFeedId != bytes32(0), \\\"dAPI name not set\\\");\\n        DataFeed storage oevDataFeed = _oevProxyToIdToDataFeed[msg.sender][\\n            dataFeedId\\n        ];\\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\\n        if (oevDataFeed.timestamp > dataFeed.timestamp) {\\n            (value, timestamp) = (oevDataFeed.value, oevDataFeed.timestamp);\\n        } else {\\n            (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\\n        }\\n        require(timestamp > 0, \\\"Data feed not initialized\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/OevDataFeedServer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./DataFeedServer.sol\\\";\\nimport \\\"./interfaces/IOevDataFeedServer.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./proxies/interfaces/IOevProxy.sol\\\";\\n\\n/// @title Contract that serves OEV Beacons and Beacon sets\\n/// @notice OEV Beacons and Beacon sets can be updated by the winner of the\\n/// respective OEV auctions. The beneficiary can withdraw the proceeds from\\n/// this contract.\\ncontract OevDataFeedServer is DataFeedServer, IOevDataFeedServer {\\n    using ECDSA for bytes32;\\n\\n    /// @notice Data feed with ID specific to the OEV proxy\\n    /// @dev This implies that an update as a result of an OEV auction only\\n    /// affects contracts that read through the respective proxy that the\\n    /// auction was being held for\\n    mapping(address => mapping(bytes32 => DataFeed))\\n        internal _oevProxyToIdToDataFeed;\\n\\n    /// @notice Accumulated OEV auction proceeds for the specific proxy\\n    mapping(address => uint256) public override oevProxyToBalance;\\n\\n    /// @notice Updates a data feed that the OEV proxy reads using the\\n    /// aggregation signed by the absolute majority of the respective Airnodes\\n    /// for the specific bid\\n    /// @dev For when the data feed being updated is a Beacon set, an absolute\\n    /// majority of the Airnodes that power the respective Beacons must sign\\n    /// the aggregated value and timestamp. While doing so, the Airnodes should\\n    /// refer to data signed to update an absolute majority of the respective\\n    /// Beacons. The Airnodes should require the data to be fresh enough (e.g.,\\n    /// at most 2 minutes-old), and tightly distributed around the resulting\\n    /// aggregation (e.g., within 1% deviation), and reject to provide an OEV\\n    /// proxy data feed update signature if these are not satisfied.\\n    /// @param oevProxy OEV proxy that reads the data feed\\n    /// @param dataFeedId Data feed ID\\n    /// @param updateId Update ID\\n    /// @param timestamp Signature timestamp\\n    /// @param data Update data (an `int256` encoded in contract ABI)\\n    /// @param packedOevUpdateSignatures Packed OEV update signatures, which\\n    /// include the Airnode address, template ID and these signed with the OEV\\n    /// update hash\\n    function updateOevProxyDataFeedWithSignedData(\\n        address oevProxy,\\n        bytes32 dataFeedId,\\n        bytes32 updateId,\\n        uint256 timestamp,\\n        bytes calldata data,\\n        bytes[] calldata packedOevUpdateSignatures\\n    ) external payable override onlyValidTimestamp(timestamp) {\\n        require(\\n            timestamp > _oevProxyToIdToDataFeed[oevProxy][dataFeedId].timestamp,\\n            \\\"Does not update timestamp\\\"\\n        );\\n        bytes32 oevUpdateHash = keccak256(\\n            abi.encodePacked(\\n                block.chainid,\\n                address(this),\\n                oevProxy,\\n                dataFeedId,\\n                updateId,\\n                timestamp,\\n                data,\\n                msg.sender,\\n                msg.value\\n            )\\n        );\\n        int224 updatedValue = decodeFulfillmentData(data);\\n        uint32 updatedTimestamp = uint32(timestamp);\\n        uint256 beaconCount = packedOevUpdateSignatures.length;\\n        if (beaconCount > 1) {\\n            bytes32[] memory beaconIds = new bytes32[](beaconCount);\\n            uint256 validSignatureCount;\\n            for (uint256 ind = 0; ind < beaconCount; ) {\\n                bool signatureIsNotOmitted;\\n                (\\n                    signatureIsNotOmitted,\\n                    beaconIds[ind]\\n                ) = unpackAndValidateOevUpdateSignature(\\n                    oevUpdateHash,\\n                    packedOevUpdateSignatures[ind]\\n                );\\n                if (signatureIsNotOmitted) {\\n                    unchecked {\\n                        validSignatureCount++;\\n                    }\\n                }\\n                unchecked {\\n                    ind++;\\n                }\\n            }\\n            // \\\"Greater than or equal to\\\" is not enough because full control\\n            // of aggregation requires an absolute majority\\n            require(\\n                validSignatureCount > beaconCount / 2,\\n                \\\"Not enough signatures\\\"\\n            );\\n            require(\\n                dataFeedId == deriveBeaconSetId(beaconIds),\\n                \\\"Beacon set ID mismatch\\\"\\n            );\\n            emit UpdatedOevProxyBeaconSetWithSignedData(\\n                dataFeedId,\\n                oevProxy,\\n                updateId,\\n                updatedValue,\\n                updatedTimestamp\\n            );\\n        } else if (beaconCount == 1) {\\n            {\\n                (\\n                    bool signatureIsNotOmitted,\\n                    bytes32 beaconId\\n                ) = unpackAndValidateOevUpdateSignature(\\n                        oevUpdateHash,\\n                        packedOevUpdateSignatures[0]\\n                    );\\n                require(signatureIsNotOmitted, \\\"Missing signature\\\");\\n                require(dataFeedId == beaconId, \\\"Beacon ID mismatch\\\");\\n            }\\n            emit UpdatedOevProxyBeaconWithSignedData(\\n                dataFeedId,\\n                oevProxy,\\n                updateId,\\n                updatedValue,\\n                updatedTimestamp\\n            );\\n        } else {\\n            revert(\\\"Did not specify any Beacons\\\");\\n        }\\n        _oevProxyToIdToDataFeed[oevProxy][dataFeedId] = DataFeed({\\n            value: updatedValue,\\n            timestamp: updatedTimestamp\\n        });\\n        oevProxyToBalance[oevProxy] += msg.value;\\n    }\\n\\n    /// @notice Withdraws the balance of the OEV proxy to the respective\\n    /// beneficiary account\\n    /// @dev This does not require the caller to be the beneficiary because we\\n    /// expect that in most cases, the OEV beneficiary will be a contract that\\n    /// will not be able to make arbitrary calls. Our choice can be worked\\n    /// around by implementing a beneficiary proxy.\\n    /// @param oevProxy OEV proxy\\n    function withdraw(address oevProxy) external override {\\n        address oevBeneficiary = IOevProxy(oevProxy).oevBeneficiary();\\n        require(oevBeneficiary != address(0), \\\"Beneficiary address zero\\\");\\n        uint256 balance = oevProxyToBalance[oevProxy];\\n        require(balance != 0, \\\"OEV proxy balance zero\\\");\\n        oevProxyToBalance[oevProxy] = 0;\\n        emit Withdrew(oevProxy, oevBeneficiary, balance);\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = oevBeneficiary.call{value: balance}(\\\"\\\");\\n        require(success, \\\"Withdrawal reverted\\\");\\n    }\\n\\n    /// @notice Reads the data feed as the OEV proxy with ID\\n    /// @param dataFeedId Data feed ID\\n    /// @return value Data feed value\\n    /// @return timestamp Data feed timestamp\\n    function _readDataFeedWithIdAsOevProxy(\\n        bytes32 dataFeedId\\n    ) internal view returns (int224 value, uint32 timestamp) {\\n        DataFeed storage oevDataFeed = _oevProxyToIdToDataFeed[msg.sender][\\n            dataFeedId\\n        ];\\n        DataFeed storage dataFeed = _dataFeeds[dataFeedId];\\n        if (oevDataFeed.timestamp > dataFeed.timestamp) {\\n            (value, timestamp) = (oevDataFeed.value, oevDataFeed.timestamp);\\n        } else {\\n            (value, timestamp) = (dataFeed.value, dataFeed.timestamp);\\n        }\\n        require(timestamp > 0, \\\"Data feed not initialized\\\");\\n    }\\n\\n    /// @notice Called privately to unpack and validate the OEV update\\n    /// signature\\n    /// @param oevUpdateHash OEV update hash\\n    /// @param packedOevUpdateSignature Packed OEV update signature, which\\n    /// includes the Airnode address, template ID and these signed with the OEV\\n    /// update hash\\n    /// @return signatureIsNotOmitted If the signature is omitted in\\n    /// `packedOevUpdateSignature`\\n    /// @return beaconId Beacon ID\\n    function unpackAndValidateOevUpdateSignature(\\n        bytes32 oevUpdateHash,\\n        bytes calldata packedOevUpdateSignature\\n    ) private pure returns (bool signatureIsNotOmitted, bytes32 beaconId) {\\n        (address airnode, bytes32 templateId, bytes memory signature) = abi\\n            .decode(packedOevUpdateSignature, (address, bytes32, bytes));\\n        beaconId = deriveBeaconId(airnode, templateId);\\n        if (signature.length != 0) {\\n            require(\\n                (\\n                    keccak256(abi.encodePacked(oevUpdateHash, templateId))\\n                        .toEthSignedMessageHash()\\n                ).recover(signature) == airnode,\\n                \\\"Signature mismatch\\\"\\n            );\\n            signatureIsNotOmitted = true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/api3-server-v1/proxies/interfaces/IOevProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOevProxy {\\n    function oevBeneficiary() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ExtendedSelfMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./SelfMulticall.sol\\\";\\nimport \\\"./interfaces/IExtendedSelfMulticall.sol\\\";\\n\\n/// @title Contract that extends SelfMulticall to fetch some of the global\\n/// variables\\n/// @notice Available global variables are limited to the ones that Airnode\\n/// tends to need\\ncontract ExtendedSelfMulticall is SelfMulticall, IExtendedSelfMulticall {\\n    /// @notice Returns the chain ID\\n    /// @return Chain ID\\n    function getChainId() external view override returns (uint256) {\\n        return block.chainid;\\n    }\\n\\n    /// @notice Returns the account balance\\n    /// @param account Account address\\n    /// @return Account balance\\n    function getBalance(\\n        address account\\n    ) external view override returns (uint256) {\\n        return account.balance;\\n    }\\n\\n    /// @notice Returns if the account contains bytecode\\n    /// @dev An account not containing any bytecode does not indicate that it\\n    /// is an EOA or it will not contain any bytecode in the future.\\n    /// Contract construction and `SELFDESTRUCT` updates the bytecode at the\\n    /// end of the transaction.\\n    /// @return If the account contains bytecode\\n    function containsBytecode(\\n        address account\\n    ) external view override returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    /// @notice Returns the current block number\\n    /// @return Current block number\\n    function getBlockNumber() external view override returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /// @notice Returns the current block timestamp\\n    /// @return Current block timestamp\\n    function getBlockTimestamp() external view override returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /// @notice Returns the current block basefee\\n    /// @return Current block basefee\\n    function getBlockBasefee() external view override returns (uint256) {\\n        return block.basefee;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/interfaces/IExpiringMetaTxForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IExpiringMetaTxForwarder {\\n    event ExecutedMetaTx(bytes32 indexed metaTxHash);\\n\\n    event CanceledMetaTx(bytes32 indexed metaTxHash);\\n\\n    struct ExpiringMetaTx {\\n        address from;\\n        address to;\\n        bytes data;\\n        uint256 expirationTimestamp;\\n    }\\n\\n    function execute(\\n        ExpiringMetaTx calldata metaTx,\\n        bytes calldata signature\\n    ) external returns (bytes memory returndata);\\n\\n    function cancel(ExpiringMetaTx calldata metaTx) external;\\n\\n    function metaTxWithHashIsExecutedOrCanceled(\\n        bytes32 metaTxHash\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/interfaces/IExtendedSelfMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ISelfMulticall.sol\\\";\\n\\ninterface IExtendedSelfMulticall is ISelfMulticall {\\n    function getChainId() external view returns (uint256);\\n\\n    function getBalance(address account) external view returns (uint256);\\n\\n    function containsBytecode(address account) external view returns (bool);\\n\\n    function getBlockNumber() external view returns (uint256);\\n\\n    function getBlockTimestamp() external view returns (uint256);\\n\\n    function getBlockBasefee() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/interfaces/ISelfMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ISelfMulticall {\\n    function multicall(\\n        bytes[] calldata data\\n    ) external returns (bytes[] memory returndata);\\n\\n    function tryMulticall(\\n        bytes[] calldata data\\n    ) external returns (bool[] memory successes, bytes[] memory returndata);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SelfMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/ISelfMulticall.sol\\\";\\n\\n/// @title Contract that enables calls to the inheriting contract to be batched\\n/// @notice Implements two ways of batching, one requires none of the calls to\\n/// revert and the other tolerates individual calls reverting\\n/// @dev This implementation uses delegatecall for individual function calls.\\n/// Since delegatecall is a message call, it can only be made to functions that\\n/// are externally visible. This means that a contract cannot multicall its own\\n/// functions that use internal/private visibility modifiers.\\n/// Refer to OpenZeppelin's Multicall.sol for a similar implementation.\\ncontract SelfMulticall is ISelfMulticall {\\n    /// @notice Batches calls to the inheriting contract and reverts as soon as\\n    /// one of the batched calls reverts\\n    /// @param data Array of calldata of batched calls\\n    /// @return returndata Array of returndata of batched calls\\n    function multicall(\\n        bytes[] calldata data\\n    ) external override returns (bytes[] memory returndata) {\\n        uint256 callCount = data.length;\\n        returndata = new bytes[](callCount);\\n        for (uint256 ind = 0; ind < callCount; ) {\\n            bool success;\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (success, returndata[ind]) = address(this).delegatecall(data[ind]);\\n            if (!success) {\\n                bytes memory returndataWithRevertData = returndata[ind];\\n                if (returndataWithRevertData.length > 0) {\\n                    // Adapted from OpenZeppelin's Address.sol\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        let returndata_size := mload(returndataWithRevertData)\\n                        revert(\\n                            add(32, returndataWithRevertData),\\n                            returndata_size\\n                        )\\n                    }\\n                } else {\\n                    revert(\\\"Multicall: No revert string\\\");\\n                }\\n            }\\n            unchecked {\\n                ind++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Batches calls to the inheriting contract but does not revert if\\n    /// any of the batched calls reverts\\n    /// @param data Array of calldata of batched calls\\n    /// @return successes Array of success conditions of batched calls\\n    /// @return returndata Array of returndata of batched calls\\n    function tryMulticall(\\n        bytes[] calldata data\\n    )\\n        external\\n        override\\n        returns (bool[] memory successes, bytes[] memory returndata)\\n    {\\n        uint256 callCount = data.length;\\n        successes = new bool[](callCount);\\n        returndata = new bytes[](callCount);\\n        for (uint256 ind = 0; ind < callCount; ) {\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (successes[ind], returndata[ind]) = address(this).delegatecall(\\n                data[ind]\\n            );\\n            unchecked {\\n                ind++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accessControlRegistry\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_adminRoleDescription\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dataFeedId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"dapiName\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SetDapiName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beaconSetId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"name\":\"UpdatedBeaconSetWithBeacons\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beaconId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"name\":\"UpdatedBeaconWithSignedData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beaconSetId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"updateId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"name\":\"UpdatedOevProxyBeaconSetWithSignedData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beaconId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"updateId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"name\":\"UpdatedOevProxyBeaconWithSignedData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oevProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oevBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrew\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAPI_NAME_SETTER_ROLE_DESCRIPTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessControlRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminRoleDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"containsBytecode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"dapiNameHashToDataFeedId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dapiNameSetterRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dapiName\",\"type\":\"bytes32\"}],\"name\":\"dapiNameToDataFeedId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataFeedId\",\"type\":\"bytes32\"}],\"name\":\"dataFeeds\",\"outputs\":[{\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockBasefee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"returndata\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oevProxyToBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"dataFeedId\",\"type\":\"bytes32\"}],\"name\":\"oevProxyToIdToDataFeed\",\"outputs\":[{\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dapiNameHash\",\"type\":\"bytes32\"}],\"name\":\"readDataFeedWithDapiNameHash\",\"outputs\":[{\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dapiNameHash\",\"type\":\"bytes32\"}],\"name\":\"readDataFeedWithDapiNameHashAsOevProxy\",\"outputs\":[{\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataFeedId\",\"type\":\"bytes32\"}],\"name\":\"readDataFeedWithId\",\"outputs\":[{\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataFeedId\",\"type\":\"bytes32\"}],\"name\":\"readDataFeedWithIdAsOevProxy\",\"outputs\":[{\"internalType\":\"int224\",\"name\":\"value\",\"type\":\"int224\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dapiName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataFeedId\",\"type\":\"bytes32\"}],\"name\":\"setDapiName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"tryMulticall\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"successes\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"returndata\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"beaconIds\",\"type\":\"bytes32[]\"}],\"name\":\"updateBeaconSetWithBeacons\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"beaconSetId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"templateId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"updateBeaconWithSignedData\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"beaconId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oevProxy\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"dataFeedId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"updateId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"packedOevUpdateSignatures\",\"type\":\"bytes[]\"}],\"name\":\"updateOevProxyDataFeedWithSignedData\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oevProxy\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Api3ServerV1", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000012d82f38a038a71b0843bd3256cd1e0a1de74834000000000000000000000000000000000000000000000000000000000000006000000000000000000000000081bc85f329cdb28936fbb239f734ae495121f9a600000000000000000000000000000000000000000000000000000000000000124170693353657276657256312061646d696e0000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}