{"SourceCode": "// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/ChainIdMixin.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract ChainIdMixin {\r\n  bytes constant public networkId = hex\"89\";\r\n  uint256 constant public CHAINID = 137;\r\n}\r\n\r\n// File: contracts/child/misc/EIP712.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract LibEIP712Domain is ChainIdMixin {\r\n    string internal constant EIP712_DOMAIN_SCHEMA = \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\";\r\n    bytes32 public constant EIP712_DOMAIN_SCHEMA_HASH = keccak256(\r\n        abi.encodePacked(EIP712_DOMAIN_SCHEMA)\r\n    );\r\n\r\n    string internal constant EIP712_DOMAIN_NAME = \"Matic Network\";\r\n    string internal constant EIP712_DOMAIN_VERSION = \"1\";\r\n    uint256 internal constant EIP712_DOMAIN_CHAINID = CHAINID;\r\n\r\n    bytes32 public EIP712_DOMAIN_HASH;\r\n\r\n    constructor() public {\r\n        EIP712_DOMAIN_HASH = keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN_SCHEMA_HASH,\r\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\r\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\r\n                EIP712_DOMAIN_CHAINID,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function hashEIP712Message(bytes32 hashStruct)\r\n        internal\r\n        view\r\n        returns (bytes32 result)\r\n    {\r\n        bytes32 domainHash = EIP712_DOMAIN_HASH;\r\n\r\n        // Assembly for more efficient computing:\r\n        // keccak256(abi.encode(\r\n        //     EIP191_HEADER,\r\n        //     domainHash,\r\n        //     hashStruct\r\n        // ));\r\n\r\n        assembly {\r\n            // Load free memory pointer\r\n            let memPtr := mload(64)\r\n\r\n            mstore(\r\n                memPtr,\r\n                0x1901000000000000000000000000000000000000000000000000000000000000\r\n            ) // EIP191 header\r\n            mstore(add(memPtr, 2), domainHash) // EIP712 domain hash\r\n            mstore(add(memPtr, 34), hashStruct) // Hash of struct\r\n\r\n            // Compute hash\r\n            result := keccak256(memPtr, 66)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts/child/misc/LibTokenTransferOrder.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract LibTokenTransferOrder is LibEIP712Domain {\r\n    string internal constant EIP712_TOKEN_TRANSFER_ORDER_SCHEMA = \"TokenTransferOrder(address spender,uint256 tokenIdOrAmount,bytes32 data,uint256 expiration)\";\r\n    bytes32 public constant EIP712_TOKEN_TRANSFER_ORDER_SCHEMA_HASH = keccak256(\r\n        abi.encodePacked(EIP712_TOKEN_TRANSFER_ORDER_SCHEMA)\r\n    );\r\n\r\n    struct TokenTransferOrder {\r\n        address spender;\r\n        uint256 tokenIdOrAmount;\r\n        bytes32 data;\r\n        uint256 expiration;\r\n    }\r\n\r\n    function getTokenTransferOrderHash(\r\n        address spender,\r\n        uint256 tokenIdOrAmount,\r\n        bytes32 data,\r\n        uint256 expiration\r\n    ) public view returns (bytes32 orderHash) {\r\n        orderHash = hashEIP712Message(\r\n            hashTokenTransferOrder(spender, tokenIdOrAmount, data, expiration)\r\n        );\r\n    }\r\n\r\n    function hashTokenTransferOrder(\r\n        address spender,\r\n        uint256 tokenIdOrAmount,\r\n        bytes32 data,\r\n        uint256 expiration\r\n    ) internal pure returns (bytes32 result) {\r\n        bytes32 schemaHash = EIP712_TOKEN_TRANSFER_ORDER_SCHEMA_HASH;\r\n\r\n        // Assembly for more efficiently computing:\r\n        // return keccak256(abi.encode(\r\n        //   schemaHash,\r\n        //   spender,\r\n        //   tokenIdOrAmount,\r\n        //   data,\r\n        //   expiration\r\n        // ));\r\n\r\n        assembly {\r\n            // Load free memory pointer\r\n            let memPtr := mload(64)\r\n\r\n            mstore(memPtr, schemaHash) // hash of schema\r\n            mstore(\r\n                add(memPtr, 32),\r\n                and(spender, 0xffffffffffffffffffffffffffffffffffffffff)\r\n            ) // spender\r\n            mstore(add(memPtr, 64), tokenIdOrAmount) // tokenIdOrAmount\r\n            mstore(add(memPtr, 96), data) // hash of data\r\n            mstore(add(memPtr, 128), expiration) // expiration\r\n\r\n            // Compute hash\r\n            result := keccak256(memPtr, 160)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n// File: contracts/child/ChildToken.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract ChildToken is Ownable, LibTokenTransferOrder {\r\n    using SafeMath for uint256;\r\n\r\n    // ERC721/ERC20 contract token address on root chain\r\n    address public token;\r\n    address public parent;\r\n    address public parentOwner;\r\n\r\n    mapping(bytes32 => bool) public disabledHashes;\r\n\r\n    modifier isParentOwner() {\r\n        require(msg.sender == parentOwner);\r\n        _;\r\n    }\r\n\r\n    function deposit(address user, uint256 amountOrTokenId) public;\r\n    function withdraw(uint256 amountOrTokenId) public payable;\r\n    function setParent(address _parent) public;\r\n\r\n    event LogFeeTransfer(\r\n        address indexed token,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        uint256 input1,\r\n        uint256 input2,\r\n        uint256 output1,\r\n        uint256 output2\r\n    );\r\n\r\n    function ecrecovery(bytes32 hash, bytes memory sig)\r\n        public\r\n        pure\r\n        returns (address result)\r\n    {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (sig.length != 65) {\r\n            return address(0x0);\r\n        }\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := and(mload(add(sig, 65)), 255)\r\n        }\r\n        // https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return address(0x0);\r\n        }\r\n        // get address out of hash and signature\r\n        result = ecrecover(hash, v, r, s);\r\n        // ecrecover returns zero on error\r\n        require(result != address(0x0), \"Error in ecrecover\");\r\n    }\r\n}\r\n\r\n// File: contracts/child/BaseERC20Fix.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract BaseERC20 is ChildToken {\r\n    event Deposit(\r\n        address indexed token,\r\n        address indexed from,\r\n        uint256 amount,\r\n        uint256 input1,\r\n        uint256 output1\r\n    );\r\n\r\n    event Withdraw(\r\n        address indexed token,\r\n        address indexed from, uint256 amount,\r\n        uint256 input1,\r\n        uint256 output1\r\n    );\r\n\r\n    event LogTransfer(\r\n        address indexed token,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        uint256 input1,\r\n        uint256 input2,\r\n        uint256 output1,\r\n        uint256 output2\r\n    );\r\n\r\n    constructor() public {}\r\n\r\n    function transferWithSig(\r\n        bytes calldata sig,\r\n        uint256 amount,\r\n        bytes32 data,\r\n        uint256 expiration,\r\n        address to\r\n    ) external returns (address from) {\r\n\trevert(\"Disabled feature\");\r\n    }\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function _transfer(address sender, address recipient, uint256 amount)\r\n        internal;\r\n\r\n    /// @param from Address from where tokens are withdrawn.\r\n    /// @param to Address to where tokens are sent.\r\n    /// @param value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function _transferFrom(address from, address to, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint256 input1 = this.balanceOf(from);\r\n        uint256 input2 = this.balanceOf(to);\r\n        _transfer(from, to, value);\r\n        emit LogTransfer(\r\n            token,\r\n            from,\r\n            to,\r\n            value,\r\n            input1,\r\n            input2,\r\n            this.balanceOf(from),\r\n            this.balanceOf(to)\r\n        );\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/child/MRC20.sol\r\n\r\npragma solidity ^0.5.11;\r\n\r\n\r\n/**\r\n * @title Matic token contract\r\n * @notice This contract is an ECR20 like wrapper over native ether (matic token) transfers on the matic chain\r\n * @dev ERC20 methods have been made payable while keeping their method signature same as other ChildERC20s on Matic\r\n */\r\ncontract MRC20 is BaseERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    uint256 public currentSupply = 0;\r\n    uint8 private constant DECIMALS = 18;\r\n    bool isInitialized;\r\n\r\n    constructor() public {}\r\n\r\n    function initialize(address _childChain, address _token) public {\r\n        // Todo: once BorValidator(@0x1000) contract added uncomment me\r\n        // require(msg.sender == address(0x1000));\r\n        require(!isInitialized, \"The contract is already initialized\");\r\n        isInitialized = true;\r\n        token = _token;\r\n        _transferOwnership(_childChain);\r\n    }\r\n\r\n    function setParent(address) public {\r\n        revert(\"Disabled feature\");\r\n    }\r\n\r\n    function deposit(address user, uint256 amount) public onlyOwner {\r\n        // check for amount and user\r\n        require(\r\n            amount > 0 && user != address(0x0),\r\n            \"Insufficient amount or invalid user\"\r\n        );\r\n\r\n        // input balance\r\n        uint256 input1 = balanceOf(user);\r\n\r\n        // transfer amount to user\r\n        address payable _user = address(uint160(user));\r\n        _user.transfer(amount);\r\n\r\n        currentSupply = currentSupply.add(amount);\r\n\r\n        // deposit events\r\n        emit Deposit(token, user, amount, input1, balanceOf(user));\r\n    }\r\n\r\n    function withdraw(uint256 amount) public payable {\r\n        address user = msg.sender;\r\n        // input balance\r\n        uint256 input = balanceOf(user);\r\n\r\n        currentSupply = currentSupply.sub(amount);\r\n        // check for amount\r\n        require(\r\n            amount > 0 && msg.value == amount,\r\n            \"Insufficient amount\"\r\n        );\r\n\r\n        // withdraw event\r\n        emit Withdraw(token, user, amount, input, balanceOf(user));\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return \"Matic Token\";\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return \"MATIC\";\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return DECIMALS;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return 10000000000 * 10**uint256(DECIMALS);\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return account.balance;\r\n    }\r\n\r\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\r\n    /// @param to Address of token receiver.\r\n    /// @param value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transfer(address to, uint256 value) public payable returns (bool) {\r\n        if (msg.value != value) {\r\n            return false;\r\n        }\r\n        return _transferFrom(msg.sender, to, value);\r\n    }\r\n\r\n    /**\r\n   * @dev _transfer is invoked by _transferFrom method that is inherited from BaseERC20.\r\n   * This enables us to transfer MaticEth between users while keeping the interface same as that of an ERC20 Token.\r\n   */\r\n    function _transfer(address sender, address recipient, uint256 amount)\r\n        internal\r\n    {\r\n        require(recipient != address(this), \"can't send to MRC20\");\r\n        address(uint160(recipient)).transfer(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"setParent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"data\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferWithSig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_childChain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parentOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"ecrecovery\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"networkId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_TOKEN_TRANSFER_ORDER_SCHEMA_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"disabledHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdOrAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"data\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"getTokenTransferOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EIP712_DOMAIN_SCHEMA_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output1\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output1\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output2\",\"type\":\"uint256\"}],\"name\":\"LogTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output2\",\"type\":\"uint256\"}],\"name\":\"LogFeeTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "MRC20", "CompilerVersion": "v0.5.11+commit.c082d0b4", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}