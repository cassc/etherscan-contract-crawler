{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity 0.8.15;\r\n\r\n// File: ICommonReportTrigger.sol\r\n\r\ninterface ICommonReportTrigger {\r\n    function strategyReportTrigger(address _strategy) external view returns (bool, bytes memory);\r\n    function strategyTendTrigger(address _strategy) external view returns (bool, bytes memory);\r\n}\r\n// File: IERC20.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: IStrategy.sol\r\n\r\ninterface StrategyAPI {\r\n    function tend() external;\r\n    function report() external returns (uint256 _profit, uint256 _loss);\r\n    function keeper() external view returns (address);\r\n}\r\n// File: LibDataTypes.sol\r\n\r\n// solhint-disable max-line-length\r\nlibrary LibDataTypes {\r\n    /**\r\n     * @notice Whitelisted modules that are available for users to customise conditions and specifications of their tasks.\r\n     *\r\n     * @param RESOLVER Use dynamic condition & input data for execution. {See ResolverModule.sol}\r\n     * @param TIME Repeated execution of task at a specified timing and interval. {See TimeModule.sol}\r\n     * @param PROXY Creates a dedicated caller (msg.sender) to be used when executing the task. {See ProxyModule.sol}\r\n     * @param SINGLE_EXEC Task is cancelled after one execution. {See SingleExecModule.sol}\r\n     */\r\n    enum Module {\r\n        RESOLVER,\r\n        TIME,\r\n        PROXY,\r\n        SINGLE_EXEC\r\n    }\r\n\r\n    /**\r\n     * @notice Struct to contain modules and their relative arguments that are used for task creation.\r\n     *\r\n     * @param modules List of selected modules.\r\n     * @param args Arguments of modules if any. Pass \"0x\" for modules which does not require args {See encodeModuleArg}\r\n     */\r\n    struct ModuleData {\r\n        Module[] modules;\r\n        bytes[] args;\r\n    }\r\n\r\n    /**\r\n     * @notice Struct for time module.\r\n     *\r\n     * @param nextExec Time when the next execution should occur.\r\n     * @param interval Time interval between each execution.\r\n     */\r\n    struct Time {\r\n        uint128 nextExec;\r\n        uint128 interval;\r\n    }\r\n}\r\n\r\n// File: IGelato.sol\r\n\r\ninterface IGelatoOps {\r\n    function exec(\r\n        address _taskCreator,\r\n        address _execAddress,\r\n        bytes memory _execData,\r\n        LibDataTypes.ModuleData calldata _moduleData,\r\n        uint256 _txFee,\r\n        address _feeToken,\r\n        bool _useTaskTreasuryFunds,\r\n        bool _revertOnFailure\r\n    ) external;\r\n\r\n    function createTask(\r\n        address _execAddress,\r\n        bytes calldata _execDataOrSelector,\r\n        LibDataTypes.ModuleData calldata _moduleData,\r\n        address _feeToken\r\n    ) external returns (bytes32 taskId);\r\n\r\n    function cancelTask(bytes32 _taskId) external;\r\n\r\n    function getFeeDetails() external view returns (uint256, address);\r\n\r\n    function gelato() external view returns (address payable);\r\n\r\n    function getTaskIdsByUser(address _taskCreator)\r\n        external\r\n        view\r\n        returns (bytes32[] memory);\r\n\r\n    function getTaskId(\r\n        address taskCreator,\r\n        address execAddress,\r\n        bytes4 execSelector,\r\n        LibDataTypes.ModuleData memory moduleData,\r\n        address feeToken\r\n    ) external view returns (bytes32 taskId);\r\n}\r\n\r\n// File: YearnGelatoOps.sol\r\n\r\n/**\r\n@title yHaaS\r\n@author yearn.finance\r\n@notice yHaaS is Harvest-as-a-Service to automate harvests (reports) and tends of strategies with yHaaS assigned as keeper.\r\nIf a strategy has been added to the yHaaSLens, yHaaS detects it and creates a harvest job. Tend jobs are added manually.\r\n*/\r\n\r\ncontract yHaaS {\r\n    // An enum to list all supported jobs in the contract\r\n    enum jobTypes {\r\n        MONITOR,\r\n        HARVEST,\r\n        TEND\r\n    }\r\n\r\n    // `feeToken` is the crypto used for payment.\r\n    address internal constant feeToken = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    // `maxFee` determines the max fee allowed to be paid to Gelato\r\n    // denominated in `feeToken`. Note that setting it to 0 would\r\n    // effectively prevent all executors from running any task.\r\n    // To change its value, call `setMaxFee()`\r\n    uint256 public maxFee = 1e18;\r\n\r\n    // Yearn Lens data lens\r\n    IYearnLens public lens;\r\n\r\n    // Gelato Ops Proxy contract\r\n    IGelatoOps public immutable ops;\r\n\r\n    // commonReportTrigger is the the central contract that keepers should use to decide if Yearn V3 strategies should report profits as well as when a V3 Vaults should record a strategies profits.\r\n    ICommonReportTrigger public commonReportTrigger;\r\n\r\n    // Yearn accounts\r\n    address public owner;\r\n    address public keeper;\r\n    address public pendingGovernance;\r\n    address payable public governance;\r\n\r\n    // Yearn modifiers\r\n    modifier onlyKeepers() {\r\n        require(msg.sender == owner || msg.sender == governance || msg.sender == keeper, \"!keeper\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == owner || msg.sender == governance, \"!authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        require(msg.sender == governance, \"!governance\");\r\n        _;\r\n    }\r\n\r\n    // `JobCreated` is an event we emit when there's a succesful harvest\r\n    event JobCreated(\r\n        address indexed strategy,\r\n        jobTypes indexed jobType,\r\n        bytes32 jobId\r\n    );\r\n\r\n    // `HarvestByGelato` is an event we emit when there's a succesful harvest\r\n    event HarvestByGelato(address indexed strategy, uint256 gelatoFee);\r\n\r\n    // `TendByGelato` is an event we emit when there's a succesful tend\r\n    event TendByGelato(address indexed strategy, uint256 gelatoFee);\r\n\r\n    constructor(address lensAddress, address gelatoAddress, address commonReportTriggerAddress) {\r\n        // Set owner and governance\r\n        owner = msg.sender;\r\n        keeper = gelatoAddress;\r\n        governance = payable(msg.sender);\r\n\r\n        // Set Yearn Lens address\r\n        lens = IYearnLens(lensAddress);\r\n\r\n        // Set Gelato Ops\r\n        ops = IGelatoOps(gelatoAddress);\r\n\r\n        // Set CommonReportTrigger\r\n        commonReportTrigger = ICommonReportTrigger(commonReportTriggerAddress);\r\n    }\r\n\r\n    /**\r\n    @notice Creates Monitor job for yHaas OR an individual strategy.\r\n    @param strategyAddress Strategy address for which a job will be created\r\n    */\r\n    function createMonitorJob(address strategyAddress) public onlyKeepers\r\n    {\r\n        LibDataTypes.ModuleData memory moduleData = getModuleData(jobTypes.MONITOR, strategyAddress);\r\n        bytes memory execData = getJobData(jobTypes.MONITOR, strategyAddress);\r\n        bytes32 jobId = ops.createTask(address(this), execData, moduleData, feeToken);\r\n        emit JobCreated(strategyAddress, jobTypes.MONITOR, jobId);\r\n    }\r\n\r\n    /**\r\n    @notice Creates Gelato job for a strategy. This function can be used to manually create either a tend or harvest job. \r\n    @param jobType Enum determining job type\r\n    @param strategyAddress Strategy address for which a job will be created\r\n    */\r\n    function createJob(jobTypes jobType, address strategyAddress) public onlyKeepers\r\n    {\r\n        LibDataTypes.ModuleData memory moduleData = getModuleData(jobType, strategyAddress);\r\n        bytes memory execData = getJobData(jobType, strategyAddress);\r\n        bytes32 jobId = ops.createTask(address(this), execData, moduleData, feeToken);\r\n        emit JobCreated(strategyAddress, jobType, jobId);\r\n    }\r\n\r\n    /**\r\n    @notice Creates Gelato harvest job for a strategy and pays Gelato for creating the job. \r\n    @param strategyAddress Strategy Address for which a harvest job will be created\r\n    */\r\n    function createHarvestJob(address strategyAddress) external onlyKeepers {\r\n        // Create job and add it to the Gelato registry\r\n        createJob(jobTypes.HARVEST, strategyAddress);\r\n\r\n        // `gelatoFee` and `gelatoFeeToken` are state variables in the gelato ops contract that\r\n        // are temporarily modified by the executors right before executing the payload. They are\r\n        // reverted to default values when the gelato contract exec() method wraps up.\r\n        (uint256 gelatoFee, address gelatoFeeToken) = ops.getFeeDetails();\r\n\r\n        require(gelatoFeeToken == feeToken, \"!token\"); // dev: gelato not using intended token\r\n        require(gelatoFee <= maxFee, \"!fee\"); // dev: gelato executor overcharnging for the tx\r\n\r\n        // Pay Gelato for the service.\r\n        payKeeper(gelatoFee);\r\n    }\r\n\r\n    /**\r\n    @notice Cancel a job given a strategy address and job type\r\n    @param jobType Enum determining job type\r\n    @param strategyAddress Strategy for which to cancel a job    \r\n    */\r\n    function cancelJob(jobTypes jobType, address strategyAddress) external onlyAuthorized returns (bytes32 cancelledJobId)\r\n    {\r\n        cancelledJobId = getJobId(jobType, strategyAddress);\r\n        ops.cancelTask(cancelledJobId); // dev: reverts if non-existent\r\n    }\r\n\r\n    /**\r\n    @notice Cancel a Monitor job given a strategy address and job type\r\n    @param strategyAddress Strategy for which to cancel a job    \r\n    */\r\n    function cancelMonitorJob(address strategyAddress) external onlyAuthorized returns (bytes32 cancelledJobId)\r\n    {\r\n        cancelledJobId = getJobId(jobTypes.MONITOR, strategyAddress);\r\n        ops.cancelTask(cancelledJobId); // dev: reverts if non-existent\r\n    }\r\n    \r\n\r\n    /**\r\n    @notice Cancel a Harvest job given a strategy address and job type\r\n    @param strategyAddress Strategy for which to cancel a job    \r\n    */\r\n    function cancelHarvestJob(address strategyAddress) external onlyAuthorized returns (bytes32 cancelledJobId)\r\n    {\r\n        cancelledJobId = getJobId(jobTypes.HARVEST, strategyAddress);\r\n        ops.cancelTask(cancelledJobId); // dev: reverts if non-existent\r\n    }\r\n\r\n    /**\r\n    @notice Cancel a list of strategy addresses with harvest job type\r\n    @param strategies List of strategy address for which to cancel the harvest jobs \r\n    */\r\n    function cancelHarvestJobList(address[] calldata strategies)\r\n        external\r\n        onlyAuthorized\r\n        returns (bytes32[] memory cancelledJobId)\r\n    {\r\n        uint256 length = strategies.length;\r\n        bytes32 currentCancelledJobId;\r\n        for (uint256 i; i<length; i++) {\r\n            currentCancelledJobId = getJobId(jobTypes.HARVEST, strategies[i]);\r\n            cancelledJobId[i] = currentCancelledJobId;\r\n            ops.cancelTask(currentCancelledJobId); // dev: reverts if non-existent\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Cancel a Tend job given a strategy address\r\n    @param strategyAddress Strategy for which to cancel a job    \r\n    */\r\n    function cancelTendJob(address strategyAddress) external onlyAuthorized returns (bytes32 cancelledJobId)\r\n    {\r\n        cancelledJobId = getJobId(jobTypes.TEND, strategyAddress);\r\n        ops.cancelTask(cancelledJobId); // dev: reverts if non-existent\r\n    }\r\n\r\n    /**\r\n    @notice Cancel a list of strategy addresses with tend job type\r\n    @param strategies List of strategy address for which to cancel the tend jobs \r\n    */\r\n    function cancelTendJobList(address[] calldata strategies)\r\n        external\r\n        onlyAuthorized\r\n        returns (bytes32[] memory cancelledJobId)\r\n    {\r\n        uint256 length = strategies.length;\r\n        bytes32 currentCancelledJobId;\r\n        for (uint256 i; i<length; i++) {\r\n            currentCancelledJobId = getJobId(jobTypes.TEND, strategies[i]);\r\n            cancelledJobId[i] = currentCancelledJobId;\r\n            ops.cancelTask(currentCancelledJobId); // dev: reverts if non-existent\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Used by keepers to determine whether a new strategy was added to yHaaSLens\r\n    that has the yHaaS contract as its keeper. A harvest job is automatically created \r\n    for newly detected strategies. Tend jobs are not automatically created.\r\n    @return canExec boolean indicating whether a new strategy requires automation.\r\n    @return execPayload call data used by Gelato executors to call createHarvestJob(). It\r\n    includes the address of the strategy to harvest as an input.\r\n    */\r\n    function checkNewStrategies() external view returns (bool canExec, bytes memory execPayload)\r\n    {\r\n        execPayload = bytes(\"No new strategies to automate\");\r\n\r\n        // Pull list of active strategies in production\r\n        address[] memory strategies = lens.assetsStrategiesAddresses();\r\n\r\n        // Check if there are strategies with yGO assigned as keeper\r\n        for (uint256 i = 0; i < strategies.length; i++) {\r\n            if (StrategyAPI(strategies[i]).keeper() != address(this)) {\r\n                continue;\r\n            }\r\n\r\n            // Skip if the job was created before, disregarding current status\r\n            bytes32 jobId = getJobId(jobTypes.HARVEST, strategies[i]);\r\n            if (jobId == 0) {\r\n                canExec = true;\r\n                execPayload = getJobData(jobTypes.MONITOR, strategies[i]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Used by keepers to check whether a strategy is ready to harvest. \r\n    @param strategyAddress Strategy for which to obtain a harvest status\r\n    @return canExec boolean indicating whether the strategy is ready to harvest\r\n    @return execPayload call data used by Gelato executors to call harvestStrategy(). It\r\n    includes the address of the strategy to harvest as an input parameter.\r\n    */\r\n    function checkHarvestTrigger(address strategyAddress) external view returns (bool canExec, bytes memory execPayload)\r\n    {\r\n        execPayload = bytes(\"Strategy not ready to harvest\");\r\n\r\n        // Declare a strategy object\r\n        StrategyAPI strategy = StrategyAPI(strategyAddress);\r\n\r\n        // Make sure yGO is the keeper of the strategy.\r\n        if (strategy.keeper() != address(this)) {\r\n            execPayload = bytes(\r\n                \"Strategy not onboarded to yGO for harvest operations\"\r\n            );\r\n            return (canExec, execPayload);\r\n        }\r\n\r\n        // yearn-v3: we pass the strategy address to the CommonReportTrigger to check for reportTrigger\r\n        (canExec, ) = commonReportTrigger.strategyReportTrigger(strategyAddress);\r\n\r\n        // If we can execute, prepare the payload\r\n        if (canExec) {\r\n            execPayload = getJobData(jobTypes.HARVEST, strategyAddress);\r\n        }\r\n    }\r\n\r\n    function checkTendTrigger(address strategyAddress)\r\n        public\r\n        view\r\n        returns (bool canExec, bytes memory execPayload)\r\n    {\r\n        execPayload = bytes(\"Strategy not ready to tend\");\r\n\r\n        // Declare a strategy object\r\n        StrategyAPI strategy = StrategyAPI(strategyAddress);\r\n\r\n        // Make sure yGO is the keeper of the strategy.\r\n        if (strategy.keeper() != address(this)) {\r\n            execPayload = bytes(\r\n                \"Strategy not onboarded to yGO for tend operations\"\r\n            );\r\n            return (canExec, execPayload);\r\n        }\r\n\r\n        // yearn-v3: we pass the strategy address to the CommonReportTrigger to check for tendTrigger\r\n        (canExec, ) = commonReportTrigger.strategyTendTrigger(strategyAddress);\r\n\r\n        // If we can execute, prepare the payload\r\n        if (canExec) {\r\n            execPayload = getJobData(jobTypes.TEND, strategyAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Function that Gelato keepers call to harvest a strategy after `checkHarvestTrigger()`\r\n    has confirmed that it's ready to harvest.\r\n    It checks that the executors are getting paid in the expected crytocurrency and that\r\n    they do not overcharge for the tx. The method also pays executors.\r\n    @dev an active job for a strategy linked to the yGO must exist for executors to be\r\n    able to call this function. \r\n    @param strategyAddress The address of the strategy to harvest\r\n    */\r\n    function harvestStrategy(address strategyAddress) public onlyKeepers {\r\n        // Declare a strategy object\r\n        StrategyAPI strategy = StrategyAPI(strategyAddress);\r\n\r\n        // `gelatoFee` and `gelatoFeeToken` are state variables in the gelato contract that\r\n        // are temporarily modified by the executors before executing the payload. They are\r\n        // reverted to default values when the gelato contract exec() method wraps up.\r\n        (uint256 gelatoFee, address gelatoFeeToken) = ops.getFeeDetails();\r\n\r\n        require(gelatoFeeToken == feeToken, \"!token\"); // dev: gelato not using intended token\r\n        require(gelatoFee <= maxFee, \"!fee\"); // dev: gelato executor overcharging for the tx\r\n\r\n        // Re-run strategyReportTrigger() to ensure the tx makes economic sense.\r\n        // yearn-v3: we pass the strategy address to the CommonReportTrigger to check for reportTrigger\r\n        (bool shouldReport, ) = commonReportTrigger.strategyReportTrigger(strategyAddress);\r\n        require(shouldReport, \"!economic\");\r\n\r\n        strategy.report();\r\n\r\n        // Pay Gelato for the service.\r\n        payKeeper(gelatoFee);\r\n\r\n        emit HarvestByGelato(strategyAddress, gelatoFee);\r\n    }\r\n\r\n    /**\r\n    @notice Function that Gelato keepers call to tend a strategy after `checkTendTrigger()`\r\n    has confirmed that it's ready to tend.\r\n    It checks that the executors are getting paid in the expected crytocurrency and that\r\n    they do not overcharge for the tx. The method also pays executors.\r\n    @dev an active job for a strategy linked to yGO must exist for executors to be\r\n    able to call this function. \r\n    @param strategyAddress The address of the strategy to tend\r\n    */\r\n    function tendStrategy(address strategyAddress) external onlyKeepers {\r\n        // Declare a strategy object\r\n        StrategyAPI strategy = StrategyAPI(strategyAddress);\r\n\r\n        // `gelatoFee` and `gelatoFeeToken` are state variables in the gelato contract that\r\n        // are temporarily modified by the executors before executing the payload. They are\r\n        // reverted to default values when the gelato contract exec() method wraps up.\r\n        (uint256 gelatoFee, address gelatoFeeToken) = ops.getFeeDetails();\r\n\r\n        require(gelatoFeeToken == feeToken, \"!token\"); // dev: gelato not using intended token\r\n        require(gelatoFee <= maxFee, \"!fee\"); // dev: gelato executor overcharging for the tx\r\n\r\n        // Re-run strategyTendTrigger() to ensure the tx makes economic sense.\r\n        // yearn-v3: we pass the strategy address to the CommonReportTrigger to check for tendTrigger\r\n        (bool shouldTend, ) = commonReportTrigger.strategyTendTrigger(strategyAddress);\r\n        require(shouldTend, \"!economic\");\r\n\r\n        strategy.tend();\r\n\r\n        // Pay Gelato for the service.\r\n        payKeeper(gelatoFee);\r\n\r\n        emit TendByGelato(strategyAddress, gelatoFee);\r\n    }\r\n\r\n    /**\r\n    @notice Build call data used by the keeper to execute the job once it's workable\r\n    @param jobType Enum determining job type\r\n    @param strategyAddress Strategy address for which the call data will be created\r\n    */\r\n    function getJobData(jobTypes jobType, address strategyAddress)\r\n        public\r\n        view\r\n        returns (bytes memory jobSelector)\r\n    {\r\n        if (jobType == jobTypes.HARVEST) {\r\n            jobSelector = abi.encodeCall(\r\n                this.harvestStrategy,\r\n                (strategyAddress)\r\n            );\r\n        } else if (jobType == jobTypes.TEND) {\r\n            jobSelector = abi.encodeCall(this.tendStrategy, (strategyAddress));\r\n        } else if (jobType == jobTypes.MONITOR) {\r\n            jobSelector = abi.encodeCall(\r\n                this.createHarvestJob,\r\n                (strategyAddress)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Get gelato module used to check for the workable status of a job. \r\n    @param jobType Enum determining job type\r\n    @param strategyAddress Strategy address to check job status for\r\n    @dev Note that `strategyAddress` is not needed when `jobTypes` is jobTypes.MONITOR\r\n    */\r\n    function getModuleData(jobTypes jobType, address strategyAddress)\r\n        public\r\n        view\r\n        returns (LibDataTypes.ModuleData memory moduleData)\r\n    {\r\n        moduleData = LibDataTypes.ModuleData(\r\n            new LibDataTypes.Module[](1),\r\n            new bytes[](1)\r\n        );\r\n\r\n        // All job types use the same module type\r\n        moduleData.modules[0] = LibDataTypes.Module.RESOLVER;\r\n\r\n        if (jobType == jobTypes.MONITOR) {\r\n            moduleData.args[0] = abi.encode(\r\n                address(this),\r\n                abi.encodeCall(this.checkNewStrategies, ())\r\n            );\r\n        } else if (jobType == jobTypes.HARVEST) {\r\n            moduleData.args[0] = abi.encode(\r\n                address(this),\r\n                abi.encodeCall(this.checkHarvestTrigger, (strategyAddress))\r\n            );\r\n        } else if (jobType == jobTypes.TEND) {\r\n            moduleData.args[0] = abi.encode(\r\n                address(this),\r\n                abi.encodeCall(this.checkTendTrigger, (strategyAddress))\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    @notice Get function selector from `jobData`. Used to id the job in the Gelato contract.\r\n    @param jobData Call data used by the keeper to execute the job once it's workable\r\n    */\r\n    function extractSelector(bytes memory jobData)\r\n        internal\r\n        pure\r\n        returns (bytes4 selector)\r\n    {\r\n        selector =\r\n            jobData[0] |\r\n            (bytes4(jobData[1]) >> 8) |\r\n            (bytes4(jobData[2]) >> 16) |\r\n            (bytes4(jobData[3]) >> 24);\r\n    }\r\n\r\n    /**\r\n    @notice Query the Gelato job id contract storage and return a job id if the task exists.\r\n    @param jobType Enum determining job type\r\n    @param strategyAddress Strategy address for the job to query\r\n    */\r\n    function getJobId(jobTypes jobType, address strategyAddress)\r\n        public\r\n        view\r\n        returns (bytes32 jobId)\r\n    {\r\n        LibDataTypes.ModuleData memory moduleData = getModuleData(\r\n            jobType,\r\n            strategyAddress\r\n        );\r\n\r\n        bytes memory jobData = getJobData(jobType, strategyAddress);\r\n\r\n        bytes4 selector = extractSelector(jobData);\r\n\r\n        jobId = ops.getTaskId(\r\n            address(this),\r\n            address(this),\r\n            selector,\r\n            moduleData,\r\n            feeToken\r\n        );\r\n\r\n        bytes32[] memory jobIds = ops.getTaskIdsByUser(address(this));\r\n\r\n        for (uint256 i = 0; i < jobIds.length; i++) {\r\n            if (jobId == jobIds[i]) {\r\n                return jobId;\r\n            }\r\n        }\r\n        delete jobId;\r\n    }\r\n\r\n    /**\r\n    @notice Query the Gelato job id contract storage and return a job id if the task exists.\r\n    @param strategyAddress Strategy address for the job to query\r\n    */\r\n    function getMonitorJobId(address strategyAddress)\r\n        public\r\n        view\r\n        returns (bytes32 jobId)\r\n    {\r\n        return getJobId(jobTypes.MONITOR, strategyAddress);\r\n    }\r\n\r\n    /**\r\n    @notice Query the Gelato job id contract storage and return a job id if the task exists.\r\n    @param strategyAddress Strategy address for the job to query\r\n    */\r\n    function getHarvestJobId(address strategyAddress)\r\n        public\r\n        view\r\n        returns (bytes32 jobId)\r\n    {\r\n        return getJobId(jobTypes.HARVEST, strategyAddress);\r\n    }\r\n\r\n    /**\r\n    @notice Query the Gelato job id contract storage and return a job id if the task exists.\r\n    @param strategyAddress Strategy address for the job to query\r\n    */\r\n    function getTendJobId(address strategyAddress)\r\n        public\r\n        view\r\n        returns (bytes32 jobId)\r\n    {\r\n        return getJobId(jobTypes.TEND, strategyAddress);\r\n    }\r\n\r\n    /**\r\n    @notice Pays Gelato keepers.\r\n    @param gelatoFee Fee amount to pay Gelato keepers. Determined by the keeper.\r\n    */\r\n    function payKeeper(uint256 gelatoFee) internal {\r\n        address payable gelato = ops.gelato();\r\n        (bool success, ) = gelato.call{value: gelatoFee}(\"\");\r\n        require(success, \"!payment\");\r\n    }\r\n\r\n    /**\r\n    @notice Sets the max fee we allow Gelato to charge for a harvest\r\n    @dev Setting `maxFee` would effectively stop all jobs as they \r\n    would all start reverting.\r\n    @param _maxFee Max fee we allow Gelato to charge for a harvest.\r\n    */\r\n    function setMaxFee(uint256 _maxFee) external onlyAuthorized {\r\n        maxFee = _maxFee;\r\n    }\r\n\r\n    /**\r\n    @notice Changes the `lens` address.\r\n    @param _lens The new address to assign as `lens`.\r\n    */\r\n    function setLens(address _lens) external onlyAuthorized {\r\n        require(_lens != address(0));\r\n        lens = IYearnLens(_lens);\r\n    }\r\n    \r\n    /**\r\n    @notice Changes the `commonReportTrigger` address.\r\n    @param _commonReportTrigger The new address to assign as `commonReportTrigger`.\r\n    */\r\n    function setCommonReportTrigger(address _commonReportTrigger) external onlyAuthorized {\r\n        require(_commonReportTrigger != address(0));\r\n        commonReportTrigger = ICommonReportTrigger(_commonReportTrigger);\r\n    }\r\n\r\n    /**\r\n    @notice Changes the `owner` address.\r\n    @param _owner The new address to assign as `owner`.\r\n    */\r\n    function setOwner(address _owner) external onlyAuthorized {\r\n        require(_owner != address(0));\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n    @notice Changes the `keeper` address.\r\n    @param _keeper The new address to assign as `keeper`.\r\n    */\r\n    function setKeeper(address _keeper) external onlyAuthorized {\r\n        require(_keeper != address(0));\r\n        keeper = _keeper;\r\n    }\r\n\r\n    // 2-phase commit for a change in governance\r\n    /**\r\n    @notice\r\n    Nominate a new address to use as governance.\r\n\r\n    The change does not go into effect immediately. This function sets a\r\n    pending change, and the governance address is not updated until\r\n    the proposed governance address has accepted the responsibility.\r\n\r\n    @param _governance The address requested to take over yGO governance.\r\n    */\r\n    function setGovernance(address _governance) external onlyGovernance {\r\n        pendingGovernance = _governance;\r\n    }\r\n\r\n    /**\r\n    @notice\r\n    Once a new governance address has been proposed using setGovernance(),\r\n    this function may be called by the proposed address to accept the\r\n    responsibility of taking over governance for this contract.\r\n\r\n    This may only be called by the proposed governance address.\r\n    @dev\r\n    setGovernance() should be called by the existing governance address,\r\n    prior to calling this function.\r\n    */\r\n    function acceptGovernance() external {\r\n        require(msg.sender == pendingGovernance, \"!authorized\");\r\n        governance = payable(pendingGovernance);\r\n        delete pendingGovernance;\r\n    }\r\n\r\n    /**\r\n    @notice Allows governance to transfer funds out of the contract\r\n    @param _token The address of the token, which balance is to be transfered\r\n    to the governance multisig.\r\n    */\r\n    function sweep(address _token) external onlyGovernance {\r\n        uint256 amount;\r\n        if (_token == feeToken) {\r\n            amount = address(this).balance;\r\n            (bool success, ) = governance.call{value: amount}(\"\");\r\n            require(success, \"!transfer\");\r\n        } else {\r\n            IERC20 token = IERC20(_token);\r\n            amount = token.balanceOf(address(this));\r\n            token.transfer(governance, amount);\r\n        }\r\n    }\r\n\r\n    // enables the contract to receive native crypto\r\n    receive() external payable {}\r\n}\r\n\r\ninterface IYearnLens {\r\n    function assetsStrategiesAddresses() external view returns (address[] memory);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lensAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gelatoAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"commonReportTriggerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gelatoFee\",\"type\":\"uint256\"}],\"name\":\"HarvestByGelato\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum yHaaS.jobTypes\",\"name\":\"jobType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"jobId\",\"type\":\"bytes32\"}],\"name\":\"JobCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gelatoFee\",\"type\":\"uint256\"}],\"name\":\"TendByGelato\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"cancelHarvestJob\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cancelledJobId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"}],\"name\":\"cancelHarvestJobList\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"cancelledJobId\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum yHaaS.jobTypes\",\"name\":\"jobType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"cancelJob\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cancelledJobId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"cancelMonitorJob\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cancelledJobId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"cancelTendJob\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cancelledJobId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"}],\"name\":\"cancelTendJobList\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"cancelledJobId\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"checkHarvestTrigger\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkNewStrategies\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"checkTendTrigger\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commonReportTrigger\",\"outputs\":[{\"internalType\":\"contract ICommonReportTrigger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"createHarvestJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum yHaaS.jobTypes\",\"name\":\"jobType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"createJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"createMonitorJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"getHarvestJobId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobId\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum yHaaS.jobTypes\",\"name\":\"jobType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"getJobData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"jobSelector\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum yHaaS.jobTypes\",\"name\":\"jobType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"getJobId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobId\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum yHaaS.jobTypes\",\"name\":\"jobType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"getModuleData\",\"outputs\":[{\"components\":[{\"internalType\":\"enum LibDataTypes.Module[]\",\"name\":\"modules\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes[]\",\"name\":\"args\",\"type\":\"bytes[]\"}],\"internalType\":\"struct LibDataTypes.ModuleData\",\"name\":\"moduleData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"getMonitorJobId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobId\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"getTendJobId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"jobId\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"harvestStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lens\",\"outputs\":[{\"internalType\":\"contract IYearnLens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ops\",\"outputs\":[{\"internalType\":\"contract IGelatoOps\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_commonReportTrigger\",\"type\":\"address\"}],\"name\":\"setCommonReportTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"setKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lens\",\"type\":\"address\"}],\"name\":\"setLens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxFee\",\"type\":\"uint256\"}],\"name\":\"setMaxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyAddress\",\"type\":\"address\"}],\"name\":\"tendStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "yHaaS", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006463bbdaf0ea540ed74882374c0994f409f49026000000000000000000000000527a819db1eb0e34426297b03bae11f2f8b3a19e0000000000000000000000004d25b3aed34ec1222846f6c87e2ac4a73f4ab6b6", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5ab403175f8b907d52e9c41b45cb1dc919c3d633ce890b99f0dad7cf006cd9e9"}