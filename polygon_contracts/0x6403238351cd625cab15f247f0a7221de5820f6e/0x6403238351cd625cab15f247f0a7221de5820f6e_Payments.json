{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Credits/Payments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./IMortgageControl.sol\\\";\\nimport \\\"../Lending/IVaultLenders.sol\\\";\\nimport \\\"../Rewards/IVaultRewards.sol\\\";\\nimport \\\"../Control/TokenInfo.sol\\\";\\n\\ncontract Payments is ReentrancyGuard, AccessControl, IMortgageInterest {\\n    using SafeERC20 for IERC20;\\n    ///@dev developer role created\\n\\n    bytes32 public constant DEV_ROLE = keccak256(\\\"DEV_ROLE\\\");\\n    uint256 private constant MAX_UINT = 2 ** 255;\\n\\n    address internal relayAddress = 0x988F94C0Ef61815AacD775789Af297713408D3B8;\\n    address public walletPanoram;\\n\\n    IMortgageControl private mortgageControl;\\n    TokenInfo public tokenInfo;\\n    uint16 private percentagePanoram = 1000;\\n    uint16 private percentagePool = 9000;\\n    uint16 private percentagePanoramDelayedPay = 7000;\\n    uint16 private percentagePoolDelayedPay = 3000;\\n    uint8 private penalization = 3; // Penalizacion mensual por pago moratorio: 1 = normal; 2 = al doble (200%) ; Default => 3 = al triple (300%)\\n    bool private paused = false;\\n\\n    event successfullPayment(address indexed client, uint256 _IdMortgage, uint256 _amount);\\n    event CalcMortgagesPaymentsforSegment(address wallet, uint256 mortgageID, uint16 segment);\\n    event MortgageLiquidated(address user, uint256 mortgageID);\\n\\n    ///@dev constructor to set roles and contract addresses\\n    constructor(\\n        address _tokenInfo,\\n        address _Mortgagecontrol,\\n        address _token,\\n        address vaultLenders,\\n        address vaultRewardsLenders,\\n        address _walletPanoram\\n    ) {\\n        tokenInfo = TokenInfo(_tokenInfo);\\n        if (!tokenInfo.getToken(_token)) {\\n            revert(\\\"Token not supported\\\");\\n        }\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _setupRole(DEV_ROLE, msg.sender);\\n        _setupRole(DEFAULT_ADMIN_ROLE, 0x526324c87e3e44630971fd2f6d9D69f3914e01DA);\\n        _setupRole(DEV_ROLE, 0x526324c87e3e44630971fd2f6d9D69f3914e01DA);\\n        _setupRole(DEV_ROLE, relayAddress);\\n        mortgageControl = IMortgageControl(_Mortgagecontrol);\\n        walletPanoram = _walletPanoram;\\n        permissions(_token, vaultLenders, vaultRewardsLenders);\\n    }\\n\\n    // Modifiers\\n    modifier validToken(address _token) {\\n        if (!tokenInfo.getToken(_token)) {\\n            revert(\\\"Unsupported Token\\\");\\n        }\\n        _;\\n    }\\n\\n    modifier onlyDev() {\\n        if (!hasRole(DEV_ROLE, msg.sender)) {\\n            revert(\\\"Not enough Permissions\\\");\\n        }\\n        _;\\n    }\\n\\n    modifier isPaused() {\\n        if (paused) {\\n            revert(\\\"contract paused\\\");\\n        }\\n        _;\\n    }\\n    ///@dev Modifier to only allow the Relayer to use the Calc Functions.\\n\\n    modifier onlyRelayer() {\\n        if (msg.sender != relayAddress) {\\n            revert(\\\"You're not Allowed\\\");\\n        }\\n        _;\\n    }\\n\\n    ///@dev Function to get the debt of a mortgage when the user is liquidated.\\n    function getDebt(uint256 _IdMortgage, address _walletUser) external view onlyDev returns (uint256) {\\n        uint256 totalMortgages = mortgageControl.getTotalMortgages();\\n        if (_IdMortgage == 0 || _IdMortgage > totalMortgages) {\\n            revert(\\\"Invalid Mortgage\\\");\\n        }\\n        MortgageInterest memory mortgage = mortgageControl.getuserToMortgageInterest(_walletUser, _IdMortgage);\\n        uint256 deudaFinal = mortgage.totalDebt - mortgage.amountToVault;\\n        if (mortgage.isMonthlyPaymentDelayed) {\\n            deudaFinal += mortgage.totalToPayOnLiquidation;\\n        } else {\\n            deudaFinal += mortgage.totalMonthlyPay;\\n        }\\n        return (deudaFinal);\\n    }\\n\\n    ///@dev function to pay the  mortgage debt.\\n    function dailyInterestPayment(uint256 _IdMortgage, address _token)\\n        external\\n        validToken(_token)\\n        isPaused\\n        nonReentrant\\n    {\\n        bool liquidated = mortgageControl.getMortgageLiquidationStatus(msg.sender, _IdMortgage);\\n        if (liquidated) {\\n            revert(\\\"Liquidated Mortgage\\\");\\n        }\\n        MortgageInterest memory mortgage = mortgageControl.getuserToMortgageInterest(msg.sender, _IdMortgage);\\n        if (mortgage.isMonthlyPaymentDelayed) {\\n            handlePayment(_token, mortgage.totalToPayOnLiquidation, mortgage, _IdMortgage, true);\\n        } else {\\n            handlePayment(_token, mortgage.totalMonthlyPay, mortgage, _IdMortgage, false);\\n        }\\n    }\\n\\n    /// @dev Function to make advance payments.\\n\\n    function advancePayment(address _token, uint256 _IdMortgage, uint256 _amountToPay)\\n        external\\n        validToken(_token)\\n        isPaused\\n        nonReentrant\\n    {\\n        MortgageInterest memory mortgage = mortgageControl.getuserToMortgageInterest(msg.sender, _IdMortgage);\\n        uint256 startDate = mortgageControl.getStartDate(msg.sender, _IdMortgage);\\n        if (mortgage.totalDebt == 0) {\\n            revert(\\\"Mortgage is Paid\\\");\\n        }\\n        if (mortgage.liquidate) {\\n            revert(\\\"Liquidated Mortgage\\\");\\n        }\\n        if (!mortgage.isMonthlyPaymentPayed) {\\n            revert(\\\"You must be up to date on your payments first\\\");\\n        }\\n        if (mortgage.isMonthlyPaymentDelayed) {\\n            revert(\\\"You Must pay the accumulated debt first\\\");\\n        }\\n        if (_amountToPay > mortgage.totalDebt) {\\n            revert(\\\"Payment should be less or equal to Total Debt\\\");\\n        }\\n        (address vaultLenders,,) = tokenInfo.getVaultInfo(_token);\\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amountToPay);\\n        IVaultLenders(vaultLenders).depositCapital(_amountToPay, _token,false);\\n        if (_amountToPay >= mortgage.totalDebt) {\\n            mortgage.totalDebt = 0;\\n            mortgageControl.updateMortgageState(_IdMortgage, msg.sender, true);\\n        } else {\\n            mortgage.totalDebt -= _amountToPay;\\n        }\\n        mortgageControl.updateTotalDebtOnAdvancePayment(msg.sender, _IdMortgage, mortgage.totalDebt);\\n        mortgageControl.updateMortgagePayment(_IdMortgage, msg.sender);\\n        mortgageControl.updateLastTimePayment(msg.sender, _IdMortgage, block.timestamp);\\n\\n        uint256 daysPaid = (mortgage.lastTimePayment - startDate) / 86400;\\n        (, uint256 period,) = mortgageControl.getDebtInfo(msg.sender, _IdMortgage);\\n        uint256 daysToPay = (period * 30) - daysPaid;\\n        uint256 capitalPay = mortgage.totalDebt / daysToPay;\\n        mortgageControl.updateCapitalPay(_IdMortgage, msg.sender, capitalPay);\\n    }\\n\\n    /// @dev Function to allow the user to pay all the mortgage debt - liquidation Debt.\\n    function liquidationDebt(uint256 _IdMortgage, address _token) external validToken(_token) isPaused nonReentrant {\\n        MortgageInterest memory mortgage = mortgageControl.getuserToMortgageInterest(msg.sender, _IdMortgage);\\n        if (mortgage.totalDebt == 0) {\\n            revert(\\\"Mortgage is Paid\\\");\\n        }\\n        if (mortgage.liquidate) {\\n            revert(\\\"Liquidated Mortgage\\\");\\n        }\\n        uint256 totalToPay;\\n        bool delayed;\\n        if (mortgage.isMonthlyPaymentDelayed) {\\n            totalToPay = mortgage.totalDebt + mortgage.amountToPanoramDelayed + mortgage.amountToPoolDelayed;\\n            delayed = true;\\n        } else {\\n            totalToPay = mortgage.totalDebt + mortgage.amountToPanoram + mortgage.amountToPool;\\n            delayed = false;\\n        }\\n        (address vaultLenders, address vaultRewardsLenders,) = tokenInfo.getVaultInfo(_token);\\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), totalToPay);\\n\\n        if (delayed) {\\n            IVaultLenders(vaultLenders).depositCapital(mortgage.totalDebt, _token,false);\\n            IVaultRewards(vaultRewardsLenders).deposit(mortgage.amountToPoolDelayed, _token);\\n            IERC20(_token).safeTransfer(walletPanoram, mortgage.amountToPanoramDelayed);\\n        } else {\\n            IVaultLenders(vaultLenders).depositCapital(mortgage.totalDebt, _token,false);\\n            IVaultRewards(vaultRewardsLenders).deposit(mortgage.amountToPool, _token);\\n            IERC20(_token).safeTransfer(walletPanoram, mortgage.amountToPanoram);\\n        }\\n\\n        mortgageControl.resetMortgageInterest(msg.sender, _IdMortgage); // manda los otros campos del struct mortgage Interest a 0\\n        mortgageControl.resetDebt(msg.sender, _IdMortgage); // manda total debt a 0\\n        mortgageControl.updateMortgageState(_IdMortgage, msg.sender, true); // isPay = True\\n    }\\n\\n    /// @dev Function to pay a set of mortgages in one call.\\n    /// @param _IdMortgages - an Array of the user's Mortgages IDs.\\n    /// @param _token - The address of the token allowed to pay.\\n    function payMortgages(uint256[] calldata _IdMortgages, address _token)\\n        external\\n        validToken(_token)\\n        isPaused\\n        nonReentrant\\n    {\\n        uint256 finalPayment;\\n        uint256 payForLenders;\\n        uint256 payForLenderRewards;\\n        uint256 payForPanoram;\\n\\n        for (uint16 i = 0; i < _IdMortgages.length;) {\\n            MortgageInterest memory mortgage = mortgageControl.getuserToMortgageInterest(msg.sender, _IdMortgages[i]);\\n            if (!mortgage.liquidate) {\\n                // if Mortgage is liquidated it cannot be paid.\\n                if (mortgage.isMonthlyPaymentDelayed) {\\n                    finalPayment += mortgage.totalToPayOnLiquidation;\\n                    payForLenders += mortgage.amountToVault;\\n                    payForLenderRewards += mortgage.totalPoolLiquidation;\\n                    payForPanoram += mortgage.totalPanoramLiquidation;\\n                } else {\\n                    finalPayment += mortgage.totalMonthlyPay;\\n                    payForLenders += mortgage.amountToVault;\\n                    payForLenderRewards += mortgage.amountToPool;\\n                    payForPanoram += mortgage.amountToPanoram;\\n                }\\n            }\\n            if (mortgage.amountToVault >= mortgage.totalDebt) {\\n                mortgage.totalDebt = 0;\\n                mortgageControl.updateMortgageState(_IdMortgages[i], msg.sender, true);\\n            } else {\\n                mortgage.totalDebt -= mortgage.amountToVault;\\n            }\\n            mortgageControl.updateTotalDebtOnAdvancePayment(msg.sender, _IdMortgages[i], mortgage.totalDebt); // actualiza campo totalDebt\\n            mortgageControl.resetMortgageInterest(msg.sender, _IdMortgages[i]); // manda los otros campos a 0\\n            mortgageControl.updateMortgagePayment(_IdMortgages[i], msg.sender); // actualiza contador\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), finalPayment);\\n        (address vaultLenders, address VaultLendersRewards,) = tokenInfo.getVaultInfo(_token);\\n        IVaultLenders(vaultLenders).depositCapital(payForLenders, _token,false);\\n        IVaultRewards(VaultLendersRewards).deposit(payForLenderRewards, _token);\\n        IERC20(_token).safeTransfer(walletPanoram, payForPanoram);\\n    }\\n\\n    ///@dev Function to calculate the mortgage interest payment for the user.\\n    ///@dev cuando el array de wallets sea muy grande hay que llamar a la funcion por lotes de wallets para evitar que consuma todo el gas durante su ejecucion.\\n    function CalcMortgageInterestPayment(\\n        address[] calldata _userWallet,\\n        uint256[] calldata _idMortgage,\\n        uint16 _segment\\n    ) external onlyRelayer isPaused {\\n        if (_userWallet.length != _idMortgage.length) {\\n            revert(\\\"Array Mismatch\\\");\\n        }\\n        uint256 length = _userWallet.length;\\n        if (length > 0) {\\n            for (uint16 i = 0; i < length;) {\\n                MortgageInterest memory mortgage =\\n                    mortgageControl.getuserToMortgageInterest(_userWallet[i], _idMortgage[i]);\\n                if (!mortgage.liquidate) {\\n                    // ya lo valida el autotask, por lo que se puede quitar\\n                    if (!mortgageControl.getMortgageStatus(_userWallet[i], _idMortgage[i])) {\\n                        // ya lo valida el autotask, por lo que se puede quitar\\n                        if (mortgage.strikes == 30) {\\n                            if (!mortgage.isMonthlyPaymentPayed) {\\n                                mortgage.isMonthlyPaymentDelayed = true;\\n                            }\\n                        }\\n                        uint64 interestrate = mortgageControl.getInterestRate(); // se puede poner afuera del for ya que es la misma para todos\\n                        bool _status = validateTime(_userWallet[i], _idMortgage[i]);\\n                        if (!mortgage.isMonthlyPaymentDelayed) {\\n                            uint256 dayInterestToPay = ((mortgage.totalDebt * interestrate) / 100000);\\n                            if (_status) {\\n                                mortgage.totalMonthlyPay += dayInterestToPay;\\n                            } else {\\n                                uint256 newAmountVault = mortgageControl.getCapitalPay(_userWallet[i], _idMortgage[i]); // pago de capital diario\\n                                mortgage.amountToVault += newAmountVault;\\n                                mortgage.totalMonthlyPay += (dayInterestToPay + newAmountVault);\\n                            }\\n                            mortgage.amountToPanoram += ((dayInterestToPay * percentagePanoram) / 10000);\\n                            mortgage.amountToPool += ((dayInterestToPay * percentagePool) / 10000);\\n\\n                            mortgage.isMonthlyPaymentPayed = false;\\n                            mortgage.strikes += 1;\\n                            mortgage.lastTimeCalc = block.timestamp;\\n                            mortgageControl.addNormalMorgateInterestData(_userWallet[i], _idMortgage[i], mortgage);\\n                        } else {\\n                            uint256 dayDelayedInterestToPay =\\n                                (((mortgage.totalDebt * interestrate) * penalization) / 100000);\\n                            uint256 totalDelayedMonthlyPay;\\n                            if (_status) {\\n                                totalDelayedMonthlyPay = dayDelayedInterestToPay;\\n                            } else {\\n                                uint256 newAmountVault = mortgageControl.getCapitalPay(_userWallet[i], _idMortgage[i]); // pago de capital diario\\n                                mortgage.amountToVault += newAmountVault;\\n                                totalDelayedMonthlyPay = (dayDelayedInterestToPay + newAmountVault);\\n                            }\\n                            uint256 amountToPanoramDelayed =\\n                                ((dayDelayedInterestToPay * percentagePanoramDelayedPay) / 10000);\\n                            uint256 amountToPoolDelayed = ((dayDelayedInterestToPay * percentagePoolDelayedPay) / 10000);\\n\\n                            mortgage.totalDelayedMonthlyPay += totalDelayedMonthlyPay;\\n                            mortgage.amountToPanoramDelayed += amountToPanoramDelayed;\\n                            mortgage.amountToPoolDelayed += amountToPoolDelayed;\\n                            if (mortgage.strikes == 30) {\\n                                mortgage.totalToPayOnLiquidation = mortgage.totalMonthlyPay + totalDelayedMonthlyPay;\\n                                mortgage.totalPoolLiquidation = mortgage.amountToPool + amountToPoolDelayed;\\n                                mortgage.totalPanoramLiquidation = mortgage.amountToPanoram + amountToPanoramDelayed;\\n                            } else if (mortgage.strikes > 30 && mortgage.strikes < 60) {\\n                                mortgage.totalToPayOnLiquidation += totalDelayedMonthlyPay;\\n                                mortgage.totalPoolLiquidation += amountToPoolDelayed;\\n                                mortgage.totalPanoramLiquidation += amountToPanoramDelayed;\\n                            } else if (mortgage.strikes >= 60) {\\n                                mortgage.totalToPayOnLiquidation += totalDelayedMonthlyPay;\\n                                mortgage.totalPoolLiquidation += amountToPoolDelayed;\\n                                mortgage.totalPanoramLiquidation += amountToPanoramDelayed;\\n                                mortgage.liquidate = true;\\n                                emit MortgageLiquidated(_userWallet[i], _idMortgage[i]);\\n                            }\\n                            mortgage.isMonthlyPaymentDelayed = true;\\n                            mortgage.strikes += 1;\\n                            mortgage.lastTimeCalc = block.timestamp;\\n                            mortgageControl.addDelayedMorgateInterestData(_userWallet[i], _idMortgage[i], mortgage);\\n                        }\\n                    }\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            } // for\\n            emit CalcMortgagesPaymentsforSegment(_userWallet[length - 1], _idMortgage[length - 1], _segment);\\n        } else {\\n            emit CalcMortgagesPaymentsforSegment(address(0), 0, _segment);\\n        }\\n    }\\n\\n    function validateTime(address _wallet, uint256 _idMortgage) private view returns (bool _status) {\\n        (,,,,,, uint256 _startDate, uint256 _period,,,,) = mortgageControl.getUserInfo(_wallet, _idMortgage);\\n        uint256 daysleft = ((block.timestamp - _startDate) / 86400) / 30;\\n        //Returns true if the loan period has expired\\n        _period > daysleft ? _status = false : _status = true;\\n    }\\n\\n    ///@dev Function to handle the internal transfers and payments that happen when an user pay his mortgage debt.\\n    function handlePayment(\\n        address _token,\\n        uint256 _amount,\\n        MortgageInterest memory mortgageInt,\\n        uint256 _IdMortgage,\\n        bool delayedPayment\\n    ) private {\\n        (address vaultLenders, address vaultRewardsLenders,) = tokenInfo.getVaultInfo(_token);\\n        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\\n\\n        if (delayedPayment) {\\n            IVaultLenders(vaultLenders).depositCapital(mortgageInt.amountToVault, _token,false);\\n            IVaultRewards(vaultRewardsLenders).deposit(mortgageInt.totalPoolLiquidation, _token);\\n            IERC20(_token).safeTransfer(walletPanoram, mortgageInt.totalPanoramLiquidation);\\n        } else {\\n            IVaultLenders(vaultLenders).depositCapital(mortgageInt.amountToVault, _token,false);\\n            IVaultRewards(vaultRewardsLenders).deposit(mortgageInt.amountToPool, _token);\\n            IERC20(_token).safeTransfer(walletPanoram, mortgageInt.amountToPanoram);\\n        }\\n        if (mortgageInt.amountToVault >= mortgageInt.totalDebt) {\\n            mortgageInt.totalDebt = 0;\\n            mortgageControl.updateMortgageState(_IdMortgage, msg.sender, true);\\n        } else {\\n            mortgageInt.totalDebt -= mortgageInt.amountToVault;\\n        }\\n        mortgageControl.updateTotalDebtOnAdvancePayment(msg.sender, _IdMortgage, mortgageInt.totalDebt); // actualiza campo totalDebt\\n        mortgageControl.resetMortgageInterest(msg.sender, _IdMortgage); // manda los otros campos a 0\\n        mortgageControl.updateMortgagePayment(_IdMortgage, msg.sender); // actualiza contador\\n\\n        emit successfullPayment(msg.sender, _IdMortgage, _amount);\\n    }\\n\\n    ///@dev function to approve the contracts to transfer the money to pay the mortgage debt.\\n    function permissions(address _token, address _lender, address _lenndersrewards) public onlyDev validToken(_token) {\\n        IERC20(_token).safeApprove(_lender, MAX_UINT);\\n        IERC20(_token).safeApprove(_lenndersrewards, MAX_UINT);\\n    }\\n\\n    ///@dev function to pause the contract if needed\\n    function updatePaused(bool _Status) external onlyDev {\\n        paused = _Status;\\n    }\\n\\n    ///@dev Function to update the percentages paid to Panoram and the lenders rewards pool in payments made on time.\\n    function updateNormalPercentages(uint16 _panoram, uint16 _pool) external onlyDev isPaused {\\n        percentagePanoram = _panoram;\\n        percentagePool = _pool;\\n    }\\n\\n    ///@dev Function to update the percentages to pay to Panoram and the lenders rewards pool in past due payments.\\n    function updateDelayedPercentages(uint16 _panoram, uint16 _pool) external onlyDev isPaused {\\n        percentagePanoramDelayedPay = _panoram;\\n        percentagePoolDelayedPay = _pool;\\n    }\\n\\n    ///@dev Function to update the percentage of monthly penalty for late payments.\\n    function updatePenalization(uint8 _penalization) external onlyDev isPaused {\\n        penalization = _penalization;\\n    }\\n\\n    ///@dev Function to update the address of the mortgage control contract.\\n    function updateMortgageControl(address _newMortgageControl) external onlyDev isPaused {\\n        mortgageControl = IMortgageControl(_newMortgageControl);\\n    }\\n\\n    ///@dev Function to update the address of the Panoram wallet.\\n    function updatePanoramWallet(address _newWalletPanoram) external onlyDev {\\n        walletPanoram = _newWalletPanoram;\\n    }\\n    ///@dev Function to update the address of the Token Info Contract.\\n\\n    function updateTokenInfo(address _tokenInfo) external onlyDev {\\n        tokenInfo = TokenInfo(_tokenInfo);\\n    }\\n\\n    ///@dev Function to update the Relayer's address.\\n    function updateRelayer(address _relayer) external onlyDev {\\n        relayAddress = _relayer;\\n    }\\n\\n    function withdraw(address _token) external onlyDev {\\n        uint256 balance = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).safeTransfer(msg.sender, balance);\\n    }\\n}\"\r\n    },\r\n    \"contracts/Credits/IMortgageControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"./IMortgageInterest.sol\\\";\\n\\ninterface IMortgageControl is IMortgageInterest {\\n\\n    function addIdInfo(uint256 id, address wallet) external;\\n\\n    function updateCapitalPay(uint256 id, address wallet, uint256 _newDebt) external; \\n\\n    function getTotalMortgages() external view returns (uint256);\\n\\n    function getCapitalPay(address _user, uint256 _mortgageId) external view returns(uint256 _capitalPay);\\n\\n    function getDebtInfo(address _user, uint256 _mortgageId) external view returns(uint256,uint256,uint256);\\n\\n    function mortgageStatuts(address _user, uint256 _mortgageId) external view returns (bool _isPay);\\n\\n    function getMortgageLiquidationStatus(address _user, uint256 _mortgageId) external view returns(bool _status);\\n\\n    function mortgageLink(address _user, uint256 _mortgageId) external view returns (bool _mortgageAgain, uint256 _linkId);\\n\\n    function getMortgagesForWallet(address _wallet, address _collection)\\n        external\\n        view\\n        returns (uint256[] memory _idMortgagesForCollection);\\n\\n    function getuserToMortgageInterest(address _wallet, uint256 _IdMortgage)\\n        external\\n        view\\n        returns (MortgageInterest memory);\\n\\n    // Get FrontEnd Data\\n    function getFrontMortgageData(address _wallet, uint256 _IdMortage)\\n        external\\n        view\\n        returns (\\n            uint256 totalDebt,\\n            uint256 totalMonthlyPay,\\n            uint256 totalDelayedMonthlyPay,\\n            uint256 totalToPayOnLiquidation,\\n            uint256 lastTimePayment,\\n            bool isMonthlyPaymentPayed,\\n            bool isMonthlyPaymentDelayed,\\n            bool liquidate\\n        );\\n\\n    function getIdInfo(uint256 id) external view returns (address _user);\\n\\n    function getInterestRate() external view returns(uint64 _interest);\\n\\n    function getMortgageId(address _collection, uint256 _nftId) external view returns(uint256 _mortgageId);\\n\\n    function getStartDate(address _wallet, uint256 _mortgageID) external view returns(uint256);\\n\\n    function getUserInfo(address _user, uint256 _mortgageId)external view returns(address,uint256,address,uint256,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256);\\n\\n    function getMortgageStatus(address _user, uint256 _mortgageId) external view returns(bool _status);\\n\\n    function addMortgageId(address _collection, uint256 _nftId, uint256 _loanId) external;\\n\\n    function eraseMortgageId(address _collection, uint256 _nftId) external;\\n\\n    function addRegistry(uint256 id, address wallet, address _collection, address _wrapContract,uint256 _nftId, uint256 _loan,uint256 _downPay,\\n    uint256 _price,uint256 _startDate,uint256 _period ) external; \\n\\n    function updateMortgageLink(\\n        uint256 oldId,\\n        uint256 newId,\\n        address wallet,\\n        uint256 _loan,\\n        uint256 _downPay,\\n        uint256 _startDate,\\n        uint256 _period,\\n        bool _mortageState\\n    ) external;\\n\\n    function updateMortgageState(\\n        uint256 id,\\n        address wallet,\\n        bool _state\\n    ) external;\\n\\n    function updateMortgagePayment(uint256 id, address wallet) external;\\n\\n    function addNormalMorgateInterestData(\\n        address _wallet,\\n        uint256 _idMortgage,\\n        MortgageInterest memory _mortgage\\n    ) external;\\n\\n    function resetMortgageInterest(address _wallet, uint256 _idMortgage) external;\\n    \\n    function resetDebt(address _wallet, uint256 _idMortgage) external;\\n    \\n    function updateLastTimeCalc(address _wallet, uint256 _idMortgage,uint256 _lastTimeCalc) external;\\n    \\n    function addDelayedMorgateInterestData(\\n        address _wallet,\\n        uint256 _idMortgage,\\n        MortgageInterest memory _mortgage\\n    ) external;\\n\\n    function updateOnPayMortgageInterest(\\n        address _wallet,\\n        uint256 _idMortgage,\\n        MortgageInterest memory mort\\n    ) external;\\n\\n    function updateTotalDebtOnAdvancePayment(\\n        address _wallet,\\n        uint256 _idMortgage,\\n        uint256 _totalDebt\\n    ) external;\\n\\n    function updateLastTimePayment(address _wallet, uint256 _idMortgage,uint256 _lastPayment) external;\\n    \\n    function getLastTimePayment(address _wallet, uint256 _idMortgage) external view returns(uint256);\\n\\n    function migrateMortgateInterest(address _wallet, uint256 _IdMortgage, MortgageInterest calldata mort) external;\\n\\n    function migrateMortgateDebt(address _wallet, uint256 _IdMortgage, Information calldata _debt) external;\\n\\n}\"\r\n    },\r\n    \"contracts/Lending/IVaultLenders.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\n/// @title Vault Lenders Interface.\\n/// @author Panoram Finance.\\n/// @notice You can use this interface to connect to the Vault Lenders contract.\\ninterface IVaultLenders {\\n    /// @dev Function to deposit tokens in the vault.\\n    function deposit(uint256,address) external;\\n\\n    /// @dev Function to deposit Capital payments for loans.\\n    function depositCapital(uint256 _amount,  address _token, bool flag) external;\\n\\n    /// @dev Function to withdraw money when a loan is created\\n    function withdraw(uint256,address) external;\\n\\n    /// @dev Function for the multisign to withdraw all the money in the vault if necessary.\\n    function withdrawAll() external;\\n\\n    /// @dev Function to get the variable totalSupply, that represents the total tokens in the vault.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @dev Function to get the total borrowed money.\\n    function getBorrows() external view returns(uint256 _borrows);\\n\\n    /// @dev Function to get the available money for loans.\\n    function getAvaible() external view returns(uint256 _avaible);\\n\\n    /// @dev Function to add a withdrawal request for the money that the user deposited in lending. \\n    /// @dev They will be able to withdraw the money when the withdrawal waiting time is over.\\n    function addRequest(uint256 _amount) external;\\n\\n    /// @dev Function to delete a withdrawals request when the user cancel the request.\\n    function deleteRequest(uint256 _amount) external;\\n\\n    /// @dev Function to transfer money from the vault to the lending contract to fulfill a user's withdrawal request.\\n    function claimRequest(uint256 _amount) external;\\n\\n    /// @dev Function to get the amount of money requested for withdrawal.\\n    function getMoneyRequest() external view returns(uint256);\\n\\n    /// @dev Function to get the maximum amount that can be deposit into the vault.\\n    function getMaxDeposit() external view returns(uint256);\\n\\n    /// @dev Function to get the minimum amount that can be deposit into the vault.\\n    function getMinDeposit() external view returns(uint256);\\n\\n    /// @dev Function to get the percentage of the vault used in loans, based on scale of 10k.\\n    function usageRatio() external view returns(uint256 _usage);\\n}\\n\"\r\n    },\r\n    \"contracts/Rewards/IVaultRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\n/// @title Vault Rewards Builder & Holders Interface.\\n/// @author Panoram Finance.\\n/// @notice Use this interface in other contracts to connect to the Vault Rewards Builder & Holders Contract.\\ninterface IVaultRewards {\\n\\n    /// @dev Function to deposit money in the vault.\\n    function deposit(uint256 _amount,  address _token) external;\\n\\n    /// @dev Function to withdraw money from the vault.\\n    function withdraw(uint256 amount, address _token) external;\\n\\n    /// @dev Function for the Multisig to withdraw all the money from the vault if necessary in an emergency.\\n    function withdrawAll() external;\\n\\n    /// @dev Function to read the amount of rewards to distribute each day.\\n    function seeDaily() external returns (uint256 tempRewards);\\n\\n    /// @dev Function to get the last time the seeDaily flag was calculated.\\n    function getLastCall() external view returns(uint256 _last);\\n\\n    /// @dev Function to get the available rewards in the vault to distribute.\\n    function getAvaibleRewards() external view returns(uint256 _avaible);\\n}\"\r\n    },\r\n    \"contracts/Control/TokenInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\ncontract TokenInfo is AccessControl {\\n\\n    ///@dev developer role created\\n    bytes32 public constant DEV_ROLE = keccak256(\\\"DEV_ROLE\\\");\\n\\n    \\n    modifier onlydev() {\\n         if (!hasRole(DEV_ROLE, msg.sender)) {\\n            revert(\\\"have no dev role\\\");\\n        }\\n        _;\\n    }\\n\\n    constructor(){\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _setupRole(DEV_ROLE, msg.sender);\\n        _setupRole(DEFAULT_ADMIN_ROLE, 0x30268390218B20226FC101cD5651A51b12C07470);\\n        _setupRole(DEV_ROLE, 0x30268390218B20226FC101cD5651A51b12C07470);\\n        _setupRole(DEV_ROLE, 0x1921a154365A82b8d54a3Cb6e2Fd7488cD0FFd23); \\n    }\\n\\n    struct Vaults{\\n        address lender;\\n        address lenderRewards;\\n        address referals;\\n    }\\n    //registration and control of approved tokens\\n    mapping(address => bool) internal tokens;\\n    //save the token contract and the vault for it\\n    mapping(address => Vaults) internal vaultsInfo;\\n    //save the collection contract and the rental vault contract to be used for each collection\\n    mapping(address => address) internal collectionToVault;\\n\\n    function addToken(address _token) public onlydev {\\n        tokens[_token] = true;\\n    }\\n\\n    function removeToken(address _token) public onlydev {\\n        tokens[_token] = false;\\n    }\\n\\n    function getToken(address _token) public view returns(bool _ok){\\n        return tokens[_token];\\n    }\\n\\n    function addVaultRegistry(address _token, address _lender,address _lenderRewards,address _referals) public onlydev  {\\n        vaultsInfo[_token].lender = _lender;\\n        vaultsInfo[_token].lenderRewards = _lenderRewards;\\n        vaultsInfo[_token].referals = _referals;\\n    }\\n\\n    function removeVaultRegistry(address _token) public onlydev  {\\n        delete vaultsInfo[_token].lender;\\n        delete vaultsInfo[_token].lenderRewards;\\n        delete vaultsInfo[_token].referals;\\n    }\\n\\n    function getVaultInfo(address _token) public view returns(address _lender, address _lenderRewards,address referals){\\n        return ( vaultsInfo[_token].lender,\\n        vaultsInfo[_token].lenderRewards,\\n        vaultsInfo[_token].referals);\\n    }\\n\\n    function addVaultRent(address _collection, address _vault) public onlydev {\\n        collectionToVault[_collection] = _vault;\\n    }\\n\\n    function removeVaultRent(address _collection) public onlydev {\\n        collectionToVault[_collection] = address(0);\\n    }\\n\\n    function getVaultRent(address _collection) public view returns(address _vault){\\n        return collectionToVault[_collection];\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Credits/IMortgageInterest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IMortgageInterest {\\n    \\n    struct MortgageInterest {\\n        uint256 totalDebt; // para guardar lo que adeuda el cliente despues de cada pago\\n        uint256 totalMonthlyPay; // total a pagar en pago puntual 100\\n        uint256 amountToPanoram; // cantidad que se ira a la wallet de Panoram\\n        uint256 amountToPool; // cantidad que se ira al Pool de rewards\\n        uint256 amountToVault; // cantidad que se regresa al vault de lenders\\n        uint256 totalDelayedMonthlyPay; // total a pagar en caso de ser pago moratorio, incluye pagar las cuotas atrasadas\\n        uint256 amountToPanoramDelayed; // cantidad que se ira a la wallet de Panoram\\n        uint256 amountToPoolDelayed; // cantidad que se ira al Pool de rewards\\n        uint256 totalToPayOnLiquidation; // sumar los 3 meses con los interes\\n        uint256 totalPoolLiquidation; // intereses al pool en liquidation\\n        uint256 totalPanoramLiquidation; // total a pagar de intereses a panoram en los 3 meses que no pago.\\n        uint256 lastTimePayment; // guardamos la fecha de su ultimo pago\\n        uint256 lastTimeCalc; // la ultima vez que se calculo sus interes: para evitar calcularle 2 veces el mismo dia\\n        uint8 strikes; // cuando sean 2 se pasa a liquidacion. Resetear estas variables cuando se haga el pago\\n        bool isMonthlyPaymentPayed; // validar si ya hizo el pago mensual\\n        bool isMonthlyPaymentDelayed; // validar si el pago es moratorio\\n        bool liquidate; // true si el credito se liquido, se liquida cuando el user tiene 3 meses sin pagar\\n    }\\n\\n    ///@notice structure and mapping that keeps track of mortgage\\n    struct Information {\\n        address collection;\\n        uint256 nftId;\\n        address wrapContract;\\n        uint256 loan; // total prestado\\n        uint256 downPay;\\n        uint256 capitalPay;\\n        uint256 price;\\n        uint256 startDate;\\n        uint256 period; //months\\n        uint256 payCounter; //Start in zero\\n        bool isPay; //default is false\\n        bool mortgageAgain; //default is false\\n        uint256 linkId; //link to the new mortgage\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenInfo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Mortgagecontrol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultLenders\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultRewardsLenders\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_walletPanoram\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mortgageID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"segment\",\"type\":\"uint16\"}],\"name\":\"CalcMortgagesPaymentsforSegment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mortgageID\",\"type\":\"uint256\"}],\"name\":\"MortgageLiquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_IdMortgage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"successfullPayment\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userWallet\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_idMortgage\",\"type\":\"uint256[]\"},{\"internalType\":\"uint16\",\"name\":\"_segment\",\"type\":\"uint16\"}],\"name\":\"CalcMortgageInterestPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEV_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_IdMortgage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountToPay\",\"type\":\"uint256\"}],\"name\":\"advancePayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_IdMortgage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"dailyInterestPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_IdMortgage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_walletUser\",\"type\":\"address\"}],\"name\":\"getDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_IdMortgage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"liquidationDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_IdMortgages\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"payMortgages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lenndersrewards\",\"type\":\"address\"}],\"name\":\"permissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenInfo\",\"outputs\":[{\"internalType\":\"contract TokenInfo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_panoram\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_pool\",\"type\":\"uint16\"}],\"name\":\"updateDelayedPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMortgageControl\",\"type\":\"address\"}],\"name\":\"updateMortgageControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_panoram\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_pool\",\"type\":\"uint16\"}],\"name\":\"updateNormalPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWalletPanoram\",\"type\":\"address\"}],\"name\":\"updatePanoramWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_Status\",\"type\":\"bool\"}],\"name\":\"updatePaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_penalization\",\"type\":\"uint8\"}],\"name\":\"updatePenalization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"updateRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenInfo\",\"type\":\"address\"}],\"name\":\"updateTokenInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletPanoram\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Payments", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f106ec236ad8e887c8c227dc8d50bb64a84a409d000000000000000000000000681c02ac64d4602e3e974d62d7a99148d82bd58b000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000f9ff515a41198a78d3643b248f0b749e5fc5e4b7000000000000000000000000941159085deb15e07452f6b09c128267f9c7d822000000000000000000000000526324c87e3e44630971fd2f6d9d69f3914e01da", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}