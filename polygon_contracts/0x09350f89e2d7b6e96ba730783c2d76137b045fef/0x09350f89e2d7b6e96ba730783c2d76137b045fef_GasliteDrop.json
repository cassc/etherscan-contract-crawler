{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/GasliteDrop.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n\\n/**\\n                                                                                                                   \\n                                                          bbbbbbbb                                         dddddddd\\n                                                          b::::::b                                         d::::::d\\n                                                          b::::::b                                         d::::::d\\n                                                          b::::::b                                         d::::::d\\n                                                           b:::::b                                         d:::::d \\n   ggggggggg   ggggg aaaaaaaaaaaaa      ssssssssss         b:::::bbbbbbbbb      aaaaaaaaaaaaa      ddddddddd:::::d \\n  g:::::::::ggg::::g a::::::::::::a   ss::::::::::s        b::::::::::::::bb    a::::::::::::a   dd::::::::::::::d \\n g:::::::::::::::::g aaaaaaaaa:::::ass:::::::::::::s       b::::::::::::::::b   aaaaaaaaa:::::a d::::::::::::::::d \\ng::::::ggggg::::::gg          a::::as::::::ssss:::::s      b:::::bbbbb:::::::b           a::::ad:::::::ddddd:::::d \\ng:::::g     g:::::g    aaaaaaa:::::a s:::::s  ssssss       b:::::b    b::::::b    aaaaaaa:::::ad::::::d    d:::::d \\ng:::::g     g:::::g  aa::::::::::::a   s::::::s            b:::::b     b:::::b  aa::::::::::::ad:::::d     d:::::d \\ng:::::g     g:::::g a::::aaaa::::::a      s::::::s         b:::::b     b:::::b a::::aaaa::::::ad:::::d     d:::::d \\ng::::::g    g:::::ga::::a    a:::::assssss   s:::::s       b:::::b     b:::::ba::::a    a:::::ad:::::d     d:::::d \\ng:::::::ggggg:::::ga::::a    a:::::as:::::ssss::::::s      b:::::bbbbbb::::::ba::::a    a:::::ad::::::ddddd::::::dd\\n g::::::::::::::::ga:::::aaaa::::::as::::::::::::::s       b::::::::::::::::b a:::::aaaa::::::a d:::::::::::::::::d\\n  gg::::::::::::::g a::::::::::aa:::as:::::::::::ss        b:::::::::::::::b   a::::::::::aa:::a d:::::::::ddd::::d\\n    gggggggg::::::g  aaaaaaaaaa  aaaa sssssssssss          bbbbbbbbbbbbbbbb     aaaaaaaaaa  aaaa  ddddddddd   ddddd\\n            g:::::g                                                                                                \\ngggggg      g:::::g                                                                                                \\ng:::::gg   gg:::::g                                                                                                \\n g::::::ggg:::::::g                                                                                                \\n  gg:::::::::::::g                                                                                                 \\n    ggg::::::ggg                                                                                                   \\n       gggggg                                                                                                      \\n */\\n\\n/**\\n * @title GasliteDrop\\n * @notice Turbo gas optimized bulk transfers of ERC20, ERC721, and ETH\\n * @author Harrison (@PopPunkOnChain)\\n * @author Gaslite (@GasliteGG)\\n * @author Pop Punk LLC (@PopPunkLLC)\\n */\\ncontract GasliteDrop {\\n\\n    /**\\n     * @notice Airdrop ERC721 tokens to a list of addresses\\n     * @param _nft The address of the ERC721 contract\\n     * @param _addresses The addresses to airdrop to\\n     * @param _tokenIds The tokenIds to airdrop\\n     */\\n    function airdropERC721(\\n        address _nft, \\n        address[] calldata _addresses, \\n        uint256[] calldata _tokenIds\\n    ) external payable {\\n        assembly {\\n            // Check that the number of addresses matches the number of tokenIds\\n            if iszero(eq(_tokenIds.length, _addresses.length)) {\\n                revert(0, 0)\\n            }\\n            // transferFrom(address from, address to, uint256 tokenId)\\n            mstore(0x00, hex\\\"23b872dd\\\")\\n            // from address\\n            mstore(0x04, caller())\\n\\n            // end of array\\n            let end := add(_addresses.offset, shl(5, _addresses.length))\\n            // diff = _addresses.offset - _tokenIds.offset\\n            let diff := sub(_addresses.offset, _tokenIds.offset)\\n\\n            // Loop through the addresses\\n            for { let addressOffset := _addresses.offset } 1 {} {\\n                // to address\\n                mstore(0x24, calldataload(addressOffset))\\n                // tokenId\\n                mstore(0x44, calldataload(sub(addressOffset, diff)))\\n                // transfer the token\\n                if iszero(call(gas(), _nft, 0, 0x00, 0x64, 0, 0)){\\n                    revert(0, 0)\\n                }\\n                // increment the address offset\\n                addressOffset := add(addressOffset, 0x20)\\n                // if addressOffset >= end, break\\n                if iszero(lt(addressOffset, end)) { break }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Airdrop ERC20 tokens to a list of addresses\\n     * @param _token The address of the ERC20 contract\\n     * @param _addresses The addresses to airdrop to\\n     * @param _amounts The amounts to airdrop\\n     * @param _totalAmount The total amount to airdrop\\n     */\\n    function airdropERC20(\\n        address _token,\\n        address[] calldata _addresses,\\n        uint256[] calldata _amounts,\\n        uint256 _totalAmount\\n    ) external payable {\\n        assembly {\\n            // Check that the number of addresses matches the number of amounts\\n            if iszero(eq(_amounts.length, _addresses.length)) {\\n                revert(0, 0)\\n            }\\n\\n            // transferFrom(address from, address to, uint256 amount)\\n            mstore(0x00, hex\\\"23b872dd\\\")\\n            // from address\\n            mstore(0x04, caller())\\n            // to address (this contract)\\n            mstore(0x24, address())\\n            // total amount\\n            mstore(0x44, _totalAmount)\\n\\n            // transfer total amount to this contract\\n            if iszero(call(gas(), _token, 0, 0x00, 0x64, 0, 0)){\\n                revert(0, 0)\\n            }\\n\\n            // transfer(address to, uint256 value)\\n            mstore(0x00, hex\\\"a9059cbb\\\")\\n\\n            // end of array\\n            let end := add(_addresses.offset, shl(5, _addresses.length))\\n            // diff = _addresses.offset - _amounts.offset\\n            let diff := sub(_addresses.offset, _amounts.offset)\\n\\n            // Loop through the addresses\\n            for { let addressOffset := _addresses.offset } 1 {} {\\n                // to address\\n                mstore(0x04, calldataload(addressOffset))\\n                // amount\\n                mstore(0x24, calldataload(sub(addressOffset, diff)))\\n                // transfer the tokens\\n                if iszero(call(gas(), _token, 0, 0x00, 0x64, 0, 0)){\\n                    revert(0, 0)\\n                }\\n                // increment the address offset\\n                addressOffset := add(addressOffset, 0x20)\\n                // if addressOffset >= end, break\\n                if iszero(lt(addressOffset, end)) { break }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Airdrop ETH to a list of addresses\\n     * @param _addresses The addresses to airdrop to\\n     * @param _amounts The amounts to airdrop\\n     */\\n    function airdropETH(\\n        address[] calldata _addresses,\\n        uint256[] calldata _amounts\\n    ) external payable {\\n        assembly {\\n            // Check that the number of addresses matches the number of amounts\\n            if iszero(eq(_amounts.length, _addresses.length)) {\\n                revert(0, 0)\\n            }\\n\\n            // iterator\\n            let i := _addresses.offset\\n            // end of array\\n            let end := add(i, shl(5, _addresses.length))\\n            // diff = _addresses.offset - _amounts.offset\\n            let diff := sub(_amounts.offset, _addresses.offset)\\n\\n            // Loop through the addresses\\n            for {} 1 {} {\\n                // transfer the ETH\\n                if iszero(\\n                    call(gas(), calldataload(i), calldataload(add(i, diff)), 0x00, 0x00, 0x00, 0x00)\\n                ) { revert(0x00, 0x00) }\\n                // increment the iterator\\n                i := add(i, 0x20)\\n                // if i >= end, break\\n                if eq(end, i) { break }\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@solady/=lib/solady/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solady/=lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"}],\"name\":\"airdropERC20\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"airdropERC721\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"airdropETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "GasliteDrop", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}