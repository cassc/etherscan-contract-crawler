{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.6/FluxAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.6;\\n\\nimport \\\"./Median.sol\\\";\\nimport \\\"./Owned.sol\\\";\\nimport \\\"./SafeMath128.sol\\\";\\nimport \\\"./SafeMath32.sol\\\";\\nimport \\\"./SafeMath64.sol\\\";\\nimport \\\"./interfaces/AggregatorV2V3Interface.sol\\\";\\nimport \\\"./interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./vendor/SafeMathChainlink.sol\\\";\\n\\n/**\\n * @title The Prepaid Aggregator contract\\n * @notice Handles aggregating data pushed in from off-chain, and unlocks\\n * payment for oracles as they report. Oracles' submissions are gathered in\\n * rounds, with each round aggregating the submissions for each oracle into a\\n * single answer. The latest aggregated answer is exposed as well as historical\\n * answers and their updated at timestamp.\\n */\\ncontract FluxAggregator is AggregatorV2V3Interface, Owned {\\n  using SafeMathChainlink for uint256;\\n  using SafeMath128 for uint128;\\n  using SafeMath64 for uint64;\\n  using SafeMath32 for uint32;\\n\\n  struct Round {\\n    int256 answer;\\n    uint64 startedAt;\\n    uint64 updatedAt;\\n    uint32 answeredInRound;\\n  }\\n\\n  struct RoundDetails {\\n    int256[] submissions;\\n    uint32 maxSubmissions;\\n    uint32 minSubmissions;\\n    uint32 timeout;\\n    uint128 paymentAmount;\\n  }\\n\\n  struct OracleStatus {\\n    uint128 withdrawable;\\n    uint32 startingRound;\\n    uint32 endingRound;\\n    uint32 lastReportedRound;\\n    uint32 lastStartedRound;\\n    int256 latestSubmission;\\n    uint16 index;\\n    address admin;\\n    address pendingAdmin;\\n  }\\n\\n  struct Requester {\\n    bool authorized;\\n    uint32 delay;\\n    uint32 lastStartedRound;\\n  }\\n\\n  struct Funds {\\n    uint128 available;\\n    uint128 allocated;\\n  }\\n\\n  LinkTokenInterface public linkToken;\\n  AggregatorValidatorInterface public validator;\\n\\n  // Round related params\\n  uint128 public paymentAmount;\\n  uint32 public maxSubmissionCount;\\n  uint32 public minSubmissionCount;\\n  uint32 public restartDelay;\\n  uint32 public timeout;\\n  uint8 public override decimals;\\n  string public override description;\\n\\n  int256 immutable public minSubmissionValue;\\n  int256 immutable public maxSubmissionValue;\\n\\n  uint256 constant public override version = 3;\\n\\n  /**\\n   * @notice To ensure owner isn't withdrawing required funds as oracles are\\n   * submitting updates, we enforce that the contract maintains a minimum\\n   * reserve of RESERVE_ROUNDS * oracleCount() LINK earmarked for payment to\\n   * oracles. (Of course, this doesn't prevent the contract from running out of\\n   * funds without the owner's intervention.)\\n   */\\n  uint256 constant private RESERVE_ROUNDS = 2;\\n  uint256 constant private MAX_ORACLE_COUNT = 77;\\n  uint32 constant private ROUND_MAX = 2**32-1;\\n  uint256 private constant VALIDATOR_GAS_LIMIT = 100000;\\n  // An error specific to the Aggregator V3 Interface, to prevent possible\\n  // confusion around accidentally reading unset values as reported values.\\n  string constant private V3_NO_DATA_ERROR = \\\"No data present\\\";\\n\\n  uint32 private reportingRoundId;\\n  uint32 internal latestRoundId;\\n  mapping(address => OracleStatus) private oracles;\\n  mapping(uint32 => Round) internal rounds;\\n  mapping(uint32 => RoundDetails) internal details;\\n  mapping(address => Requester) internal requesters;\\n  address[] private oracleAddresses;\\n  Funds private recordedFunds;\\n\\n  event AvailableFundsUpdated(\\n    uint256 indexed amount\\n  );\\n  event RoundDetailsUpdated(\\n    uint128 indexed paymentAmount,\\n    uint32 indexed minSubmissionCount,\\n    uint32 indexed maxSubmissionCount,\\n    uint32 restartDelay,\\n    uint32 timeout // measured in seconds\\n  );\\n  event OraclePermissionsUpdated(\\n    address indexed oracle,\\n    bool indexed whitelisted\\n  );\\n  event OracleAdminUpdated(\\n    address indexed oracle,\\n    address indexed newAdmin\\n  );\\n  event OracleAdminUpdateRequested(\\n    address indexed oracle,\\n    address admin,\\n    address newAdmin\\n  );\\n  event SubmissionReceived(\\n    int256 indexed submission,\\n    uint32 indexed round,\\n    address indexed oracle\\n  );\\n  event RequesterPermissionsSet(\\n    address indexed requester,\\n    bool authorized,\\n    uint32 delay\\n  );\\n  event ValidatorUpdated(\\n    address indexed previous,\\n    address indexed current\\n  );\\n\\n  /**\\n   * @notice set up the aggregator with initial configuration\\n   * @param _link The address of the LINK token\\n   * @param _paymentAmount The amount paid of LINK paid to each oracle per submission, in wei (units of 10\u207b\u00b9\u2078 LINK)\\n   * @param _timeout is the number of seconds after the previous round that are\\n   * allowed to lapse before allowing an oracle to skip an unfinished round\\n   * @param _validator is an optional contract address for validating\\n   * external validation of answers\\n   * @param _minSubmissionValue is an immutable check for a lower bound of what\\n   * submission values are accepted from an oracle\\n   * @param _maxSubmissionValue is an immutable check for an upper bound of what\\n   * submission values are accepted from an oracle\\n   * @param _decimals represents the number of decimals to offset the answer by\\n   * @param _description a short description of what is being reported\\n   */\\n  constructor(\\n    address _link,\\n    uint128 _paymentAmount,\\n    uint32 _timeout,\\n    address _validator,\\n    int256 _minSubmissionValue,\\n    int256 _maxSubmissionValue,\\n    uint8 _decimals,\\n    string memory _description\\n  ) public {\\n    linkToken = LinkTokenInterface(_link);\\n    updateFutureRounds(_paymentAmount, 0, 0, 0, _timeout);\\n    setValidator(_validator);\\n    minSubmissionValue = _minSubmissionValue;\\n    maxSubmissionValue = _maxSubmissionValue;\\n    decimals = _decimals;\\n    description = _description;\\n    rounds[0].updatedAt = uint64(block.timestamp.sub(uint256(_timeout)));\\n  }\\n\\n  /**\\n   * @notice called by oracles when they have witnessed a need to update\\n   * @param _roundId is the ID of the round this submission pertains to\\n   * @param _submission is the updated data that the oracle is submitting\\n   */\\n  function submit(uint256 _roundId, int256 _submission)\\n    external\\n  {\\n    bytes memory error = validateOracleRound(msg.sender, uint32(_roundId));\\n    require(_submission >= minSubmissionValue, \\\"value below minSubmissionValue\\\");\\n    require(_submission <= maxSubmissionValue, \\\"value above maxSubmissionValue\\\");\\n    require(error.length == 0, string(error));\\n\\n    oracleInitializeNewRound(uint32(_roundId));\\n    recordSubmission(_submission, uint32(_roundId));\\n    (bool updated, int256 newAnswer) = updateRoundAnswer(uint32(_roundId));\\n    payOracle(uint32(_roundId));\\n    deleteRoundDetails(uint32(_roundId));\\n    if (updated) {\\n      validateAnswer(uint32(_roundId), newAnswer);\\n    }\\n  }\\n\\n  /**\\n   * @notice called by the owner to remove and add new oracles as well as\\n   * update the round related parameters that pertain to total oracle count\\n   * @param _removed is the list of addresses for the new Oracles being removed\\n   * @param _added is the list of addresses for the new Oracles being added\\n   * @param _addedAdmins is the admin addresses for the new respective _added\\n   * list. Only this address is allowed to access the respective oracle's funds\\n   * @param _minSubmissions is the new minimum submission count for each round\\n   * @param _maxSubmissions is the new maximum submission count for each round\\n   * @param _restartDelay is the number of rounds an Oracle has to wait before\\n   * they can initiate a round\\n   */\\n  function changeOracles(\\n    address[] calldata _removed,\\n    address[] calldata _added,\\n    address[] calldata _addedAdmins,\\n    uint32 _minSubmissions,\\n    uint32 _maxSubmissions,\\n    uint32 _restartDelay\\n  )\\n    external\\n    onlyOwner()\\n  {\\n    for (uint256 i = 0; i < _removed.length; i++) {\\n      removeOracle(_removed[i]);\\n    }\\n\\n    require(_added.length == _addedAdmins.length, \\\"need same oracle and admin count\\\");\\n    require(uint256(oracleCount()).add(_added.length) <= MAX_ORACLE_COUNT, \\\"max oracles allowed\\\");\\n\\n    for (uint256 i = 0; i < _added.length; i++) {\\n      addOracle(_added[i], _addedAdmins[i]);\\n    }\\n\\n    updateFutureRounds(paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, timeout);\\n  }\\n\\n  /**\\n   * @notice update the round and payment related parameters for subsequent\\n   * rounds\\n   * @param _paymentAmount is the payment amount for subsequent rounds\\n   * @param _minSubmissions is the new minimum submission count for each round\\n   * @param _maxSubmissions is the new maximum submission count for each round\\n   * @param _restartDelay is the number of rounds an Oracle has to wait before\\n   * they can initiate a round\\n   */\\n  function updateFutureRounds(\\n    uint128 _paymentAmount,\\n    uint32 _minSubmissions,\\n    uint32 _maxSubmissions,\\n    uint32 _restartDelay,\\n    uint32 _timeout\\n  )\\n    public\\n    onlyOwner()\\n  {\\n    uint32 oracleNum = oracleCount(); // Save on storage reads\\n    require(_maxSubmissions >= _minSubmissions, \\\"max must equal/exceed min\\\");\\n    require(oracleNum >= _maxSubmissions, \\\"max cannot exceed total\\\");\\n    require(oracleNum == 0 || oracleNum > _restartDelay, \\\"delay cannot exceed total\\\");\\n    require(recordedFunds.available >= requiredReserve(_paymentAmount), \\\"insufficient funds for payment\\\");\\n    if (oracleCount() > 0) {\\n      require(_minSubmissions > 0, \\\"min must be greater than 0\\\");\\n    }\\n\\n    paymentAmount = _paymentAmount;\\n    minSubmissionCount = _minSubmissions;\\n    maxSubmissionCount = _maxSubmissions;\\n    restartDelay = _restartDelay;\\n    timeout = _timeout;\\n\\n    emit RoundDetailsUpdated(\\n      paymentAmount,\\n      _minSubmissions,\\n      _maxSubmissions,\\n      _restartDelay,\\n      _timeout\\n    );\\n  }\\n\\n  /**\\n   * @notice the amount of payment yet to be withdrawn by oracles\\n   */\\n  function allocatedFunds()\\n    external\\n    view\\n    returns (uint128)\\n  {\\n    return recordedFunds.allocated;\\n  }\\n\\n  /**\\n   * @notice the amount of future funding available to oracles\\n   */\\n  function availableFunds()\\n    external\\n    view\\n    returns (uint128)\\n  {\\n    return recordedFunds.available;\\n  }\\n\\n  /**\\n   * @notice recalculate the amount of LINK available for payouts\\n   */\\n  function updateAvailableFunds()\\n    public\\n  {\\n    Funds memory funds = recordedFunds;\\n\\n    uint256 nowAvailable = linkToken.balanceOf(address(this)).sub(funds.allocated);\\n\\n    if (funds.available != nowAvailable) {\\n      recordedFunds.available = uint128(nowAvailable);\\n      emit AvailableFundsUpdated(nowAvailable);\\n    }\\n  }\\n\\n  /**\\n   * @notice returns the number of oracles\\n   */\\n  function oracleCount() public view returns (uint8) {\\n    return uint8(oracleAddresses.length);\\n  }\\n\\n  /**\\n   * @notice returns an array of addresses containing the oracles on contract\\n   */\\n  function getOracles() external view returns (address[] memory) {\\n    return oracleAddresses;\\n  }\\n\\n  /**\\n   * @notice get the most recently reported answer\\n   *\\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestAnswer()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (int256)\\n  {\\n    return rounds[latestRoundId].answer;\\n  }\\n\\n  /**\\n   * @notice get the most recent updated at timestamp\\n   *\\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestTimestamp()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return rounds[latestRoundId].updatedAt;\\n  }\\n\\n  /**\\n   * @notice get the ID of the last updated round\\n   *\\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestRound()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return latestRoundId;\\n  }\\n\\n  /**\\n   * @notice get past rounds answers\\n   * @param _roundId the round number to retrieve the answer for\\n   *\\n   * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended getRoundData\\n   * instead which includes better verification information.\\n   */\\n  function getAnswer(uint256 _roundId)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (int256)\\n  {\\n    if (validRoundId(_roundId)) {\\n      return rounds[uint32(_roundId)].answer;\\n    }\\n    return 0;\\n  }\\n\\n  /**\\n   * @notice get timestamp when an answer was last updated\\n   * @param _roundId the round number to retrieve the updated timestamp for\\n   *\\n   * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended getRoundData\\n   * instead which includes better verification information.\\n   */\\n  function getTimestamp(uint256 _roundId)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    if (validRoundId(_roundId)) {\\n      return rounds[uint32(_roundId)].updatedAt;\\n    }\\n    return 0;\\n  }\\n\\n  /**\\n   * @notice get data about a round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * @param _roundId the round ID to retrieve the round data for\\n   * @return roundId is the round ID for which data was retrieved\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started. This is 0\\n   * if the round hasn't been started yet.\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed. answeredInRound may be smaller than roundId when the round\\n   * timed out. answeredInRound is equal to roundId when the round didn't time out\\n   * and was completed regularly.\\n   * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received\\n   * maxSubmissions) answer and updatedAt may change between queries.\\n   */\\n  function getRoundData(uint80 _roundId)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    Round memory r = rounds[uint32(_roundId)];\\n\\n    require(r.answeredInRound > 0 && validRoundId(_roundId), V3_NO_DATA_ERROR);\\n\\n    return (\\n      _roundId,\\n      r.answer,\\n      r.startedAt,\\n      r.updatedAt,\\n      r.answeredInRound\\n    );\\n  }\\n\\n  /**\\n   * @notice get data about the latest round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values. Consumers are encouraged to\\n   * use this more fully featured method over the \\\"legacy\\\" latestRound/\\n   * latestAnswer/latestTimestamp functions. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * @return roundId is the round ID for which data was retrieved\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started. This is 0\\n   * if the round hasn't been started yet.\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed. answeredInRound may be smaller than roundId when the round\\n   * timed out. answeredInRound is equal to roundId when the round didn't time\\n   * out and was completed regularly.\\n   * @dev Note that for in-progress rounds (i.e. rounds that haven't yet\\n   * received maxSubmissions) answer and updatedAt may change between queries.\\n   */\\n   function latestRoundData()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    return getRoundData(latestRoundId);\\n  }\\n\\n\\n  /**\\n   * @notice query the available amount of LINK for an oracle to withdraw\\n   */\\n  function withdrawablePayment(address _oracle)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return oracles[_oracle].withdrawable;\\n  }\\n\\n  /**\\n   * @notice transfers the oracle's LINK to another address. Can only be called\\n   * by the oracle's admin.\\n   * @param _oracle is the oracle whose LINK is transferred\\n   * @param _recipient is the address to send the LINK to\\n   * @param _amount is the amount of LINK to send\\n   */\\n  function withdrawPayment(address _oracle, address _recipient, uint256 _amount)\\n    external\\n  {\\n    require(oracles[_oracle].admin == msg.sender, \\\"only callable by admin\\\");\\n\\n    // Safe to downcast _amount because the total amount of LINK is less than 2^128.\\n    uint128 amount = uint128(_amount);\\n    uint128 available = oracles[_oracle].withdrawable;\\n    require(available >= amount, \\\"insufficient withdrawable funds\\\");\\n\\n    oracles[_oracle].withdrawable = available.sub(amount);\\n    recordedFunds.allocated = recordedFunds.allocated.sub(amount);\\n\\n    assert(linkToken.transfer(_recipient, uint256(amount)));\\n  }\\n\\n  /**\\n   * @notice transfers the owner's LINK to another address\\n   * @param _recipient is the address to send the LINK to\\n   * @param _amount is the amount of LINK to send\\n   */\\n  function withdrawFunds(address _recipient, uint256 _amount)\\n    external\\n    onlyOwner()\\n  {\\n    uint256 available = uint256(recordedFunds.available);\\n    require(available.sub(requiredReserve(paymentAmount)) >= _amount, \\\"insufficient reserve funds\\\");\\n    require(linkToken.transfer(_recipient, _amount), \\\"token transfer failed\\\");\\n    updateAvailableFunds();\\n  }\\n\\n  /**\\n   * @notice get the admin address of an oracle\\n   * @param _oracle is the address of the oracle whose admin is being queried\\n   */\\n  function getAdmin(address _oracle)\\n    external\\n    view\\n    returns (address)\\n  {\\n    return oracles[_oracle].admin;\\n  }\\n\\n  /**\\n   * @notice transfer the admin address for an oracle\\n   * @param _oracle is the address of the oracle whose admin is being transferred\\n   * @param _newAdmin is the new admin address\\n   */\\n  function transferAdmin(address _oracle, address _newAdmin)\\n    external\\n  {\\n    require(oracles[_oracle].admin == msg.sender, \\\"only callable by admin\\\");\\n    oracles[_oracle].pendingAdmin = _newAdmin;\\n\\n    emit OracleAdminUpdateRequested(_oracle, msg.sender, _newAdmin);\\n  }\\n\\n  /**\\n   * @notice accept the admin address transfer for an oracle\\n   * @param _oracle is the address of the oracle whose admin is being transferred\\n   */\\n  function acceptAdmin(address _oracle)\\n    external\\n  {\\n    require(oracles[_oracle].pendingAdmin == msg.sender, \\\"only callable by pending admin\\\");\\n    oracles[_oracle].pendingAdmin = address(0);\\n    oracles[_oracle].admin = msg.sender;\\n\\n    emit OracleAdminUpdated(_oracle, msg.sender);\\n  }\\n\\n  /**\\n   * @notice allows non-oracles to request a new round\\n   */\\n  function requestNewRound()\\n    external\\n    returns (uint80)\\n  {\\n    require(requesters[msg.sender].authorized, \\\"not authorized requester\\\");\\n\\n    uint32 current = reportingRoundId;\\n    require(rounds[current].updatedAt > 0 || timedOut(current), \\\"prev round must be supersedable\\\");\\n\\n    uint32 newRoundId = current.add(1);\\n    requesterInitializeNewRound(newRoundId);\\n    return newRoundId;\\n  }\\n\\n  /**\\n   * @notice allows the owner to specify new non-oracles to start new rounds\\n   * @param _requester is the address to set permissions for\\n   * @param _authorized is a boolean specifying whether they can start new rounds or not\\n   * @param _delay is the number of rounds the requester must wait before starting another round\\n   */\\n  function setRequesterPermissions(address _requester, bool _authorized, uint32 _delay)\\n    external\\n    onlyOwner()\\n  {\\n    if (requesters[_requester].authorized == _authorized) return;\\n\\n    if (_authorized) {\\n      requesters[_requester].authorized = _authorized;\\n      requesters[_requester].delay = _delay;\\n    } else {\\n      delete requesters[_requester];\\n    }\\n\\n    emit RequesterPermissionsSet(_requester, _authorized, _delay);\\n  }\\n\\n  /**\\n   * @notice called through LINK's transferAndCall to update available funds\\n   * in the same transaction as the funds were transferred to the aggregator\\n   * @param _data is mostly ignored. It is checked for length, to be sure\\n   * nothing strange is passed in.\\n   */\\n  function onTokenTransfer(address, uint256, bytes calldata _data)\\n    external\\n  {\\n    require(_data.length == 0, \\\"transfer doesn't accept calldata\\\");\\n    updateAvailableFunds();\\n  }\\n\\n  /**\\n   * @notice a method to provide all current info oracles need. Intended only\\n   * only to be callable by oracles. Not for use by contracts to read state.\\n   * @param _oracle the address to look up information for.\\n   */\\n  function oracleRoundState(address _oracle, uint32 _queriedRoundId)\\n    external\\n    view\\n    returns (\\n      bool _eligibleToSubmit,\\n      uint32 _roundId,\\n      int256 _latestSubmission,\\n      uint64 _startedAt,\\n      uint64 _timeout,\\n      uint128 _availableFunds,\\n      uint8 _oracleCount,\\n      uint128 _paymentAmount\\n    )\\n  {\\n    require(msg.sender == tx.origin, \\\"off-chain reading only\\\");\\n\\n    if (_queriedRoundId > 0) {\\n      Round storage round = rounds[_queriedRoundId];\\n      RoundDetails storage details = details[_queriedRoundId];\\n      return (\\n        eligibleForSpecificRound(_oracle, _queriedRoundId),\\n        _queriedRoundId,\\n        oracles[_oracle].latestSubmission,\\n        round.startedAt,\\n        details.timeout,\\n        recordedFunds.available,\\n        oracleCount(),\\n        (round.startedAt > 0 ? details.paymentAmount : paymentAmount)\\n      );\\n    } else {\\n      return oracleRoundStateSuggestRound(_oracle);\\n    }\\n  }\\n\\n  /**\\n   * @notice method to update the address which does external data validation.\\n   * @param _newValidator designates the address of the new validation contract.\\n   */\\n  function setValidator(address _newValidator)\\n    public\\n    onlyOwner()\\n  {\\n    address previous = address(validator);\\n\\n    if (previous != _newValidator) {\\n      validator = AggregatorValidatorInterface(_newValidator);\\n\\n      emit ValidatorUpdated(previous, _newValidator);\\n    }\\n  }\\n\\n\\n  /**\\n   * Private\\n   */\\n\\n  function initializeNewRound(uint32 _roundId)\\n    private\\n  {\\n    updateTimedOutRoundInfo(_roundId.sub(1));\\n\\n    reportingRoundId = _roundId;\\n    RoundDetails memory nextDetails = RoundDetails(\\n      new int256[](0),\\n      maxSubmissionCount,\\n      minSubmissionCount,\\n      timeout,\\n      paymentAmount\\n    );\\n    details[_roundId] = nextDetails;\\n    rounds[_roundId].startedAt = uint64(block.timestamp);\\n\\n    emit NewRound(_roundId, msg.sender, rounds[_roundId].startedAt);\\n  }\\n\\n  function oracleInitializeNewRound(uint32 _roundId)\\n    private\\n  {\\n    if (!newRound(_roundId)) return;\\n    uint256 lastStarted = oracles[msg.sender].lastStartedRound; // cache storage reads\\n    if (_roundId <= lastStarted + restartDelay && lastStarted != 0) return;\\n\\n    initializeNewRound(_roundId);\\n\\n    oracles[msg.sender].lastStartedRound = _roundId;\\n  }\\n\\n  function requesterInitializeNewRound(uint32 _roundId)\\n    private\\n  {\\n    if (!newRound(_roundId)) return;\\n    uint256 lastStarted = requesters[msg.sender].lastStartedRound; // cache storage reads\\n    require(_roundId > lastStarted + requesters[msg.sender].delay || lastStarted == 0, \\\"must delay requests\\\");\\n\\n    initializeNewRound(_roundId);\\n\\n    requesters[msg.sender].lastStartedRound = _roundId;\\n  }\\n\\n  function updateTimedOutRoundInfo(uint32 _roundId)\\n    private\\n  {\\n    if (!timedOut(_roundId)) return;\\n\\n    uint32 prevId = _roundId.sub(1);\\n    rounds[_roundId].answer = rounds[prevId].answer;\\n    rounds[_roundId].answeredInRound = rounds[prevId].answeredInRound;\\n    rounds[_roundId].updatedAt = uint64(block.timestamp);\\n\\n    delete details[_roundId];\\n  }\\n\\n  function eligibleForSpecificRound(address _oracle, uint32 _queriedRoundId)\\n    private\\n    view\\n    returns (bool _eligible)\\n  {\\n    if (rounds[_queriedRoundId].startedAt > 0) {\\n      return acceptingSubmissions(_queriedRoundId) && validateOracleRound(_oracle, _queriedRoundId).length == 0;\\n    } else {\\n      return delayed(_oracle, _queriedRoundId) && validateOracleRound(_oracle, _queriedRoundId).length == 0;\\n    }\\n  }\\n\\n  function oracleRoundStateSuggestRound(address _oracle)\\n    private\\n    view\\n    returns (\\n      bool _eligibleToSubmit,\\n      uint32 _roundId,\\n      int256 _latestSubmission,\\n      uint64 _startedAt,\\n      uint64 _timeout,\\n      uint128 _availableFunds,\\n      uint8 _oracleCount,\\n      uint128 _paymentAmount\\n    )\\n  {\\n    Round storage round = rounds[0];\\n    OracleStatus storage oracle = oracles[_oracle];\\n\\n    bool shouldSupersede = oracle.lastReportedRound == reportingRoundId || !acceptingSubmissions(reportingRoundId);\\n    // Instead of nudging oracles to submit to the next round, the inclusion of\\n    // the shouldSupersede bool in the if condition pushes them towards\\n    // submitting in a currently open round.\\n    if (supersedable(reportingRoundId) && shouldSupersede) {\\n      _roundId = reportingRoundId.add(1);\\n      round = rounds[_roundId];\\n\\n      _paymentAmount = paymentAmount;\\n      _eligibleToSubmit = delayed(_oracle, _roundId);\\n    } else {\\n      _roundId = reportingRoundId;\\n      round = rounds[_roundId];\\n\\n      _paymentAmount = details[_roundId].paymentAmount;\\n      _eligibleToSubmit = acceptingSubmissions(_roundId);\\n    }\\n\\n    if (validateOracleRound(_oracle, _roundId).length != 0) {\\n      _eligibleToSubmit = false;\\n    }\\n\\n    return (\\n      _eligibleToSubmit,\\n      _roundId,\\n      oracle.latestSubmission,\\n      round.startedAt,\\n      details[_roundId].timeout,\\n      recordedFunds.available,\\n      oracleCount(),\\n      _paymentAmount\\n    );\\n  }\\n\\n  function updateRoundAnswer(uint32 _roundId)\\n    internal\\n    returns (bool, int256)\\n  {\\n    if (details[_roundId].submissions.length < details[_roundId].minSubmissions) {\\n      return (false, 0);\\n    }\\n\\n    int256 newAnswer = Median.calculateInplace(details[_roundId].submissions);\\n    rounds[_roundId].answer = newAnswer;\\n    rounds[_roundId].updatedAt = uint64(block.timestamp);\\n    rounds[_roundId].answeredInRound = _roundId;\\n    latestRoundId = _roundId;\\n\\n    emit AnswerUpdated(newAnswer, _roundId, now);\\n\\n    return (true, newAnswer);\\n  }\\n\\n  function validateAnswer(\\n    uint32 _roundId,\\n    int256 _newAnswer\\n  )\\n    private\\n  {\\n    AggregatorValidatorInterface av = validator; // cache storage reads\\n    if (address(av) == address(0)) return;\\n\\n    uint32 prevRound = _roundId.sub(1);\\n    uint32 prevAnswerRoundId = rounds[prevRound].answeredInRound;\\n    int256 prevRoundAnswer = rounds[prevRound].answer;\\n    // We do not want the validator to ever prevent reporting, so we limit its\\n    // gas usage and catch any errors that may arise.\\n    try av.validate{gas: VALIDATOR_GAS_LIMIT}(\\n      prevAnswerRoundId,\\n      prevRoundAnswer,\\n      _roundId,\\n      _newAnswer\\n    ) {} catch {}\\n  }\\n\\n  function payOracle(uint32 _roundId)\\n    private\\n  {\\n    uint128 payment = details[_roundId].paymentAmount;\\n    Funds memory funds = recordedFunds;\\n    funds.available = funds.available.sub(payment);\\n    funds.allocated = funds.allocated.add(payment);\\n    recordedFunds = funds;\\n    oracles[msg.sender].withdrawable = oracles[msg.sender].withdrawable.add(payment);\\n\\n    emit AvailableFundsUpdated(funds.available);\\n  }\\n\\n  function recordSubmission(int256 _submission, uint32 _roundId)\\n    private\\n  {\\n    require(acceptingSubmissions(_roundId), \\\"round not accepting submissions\\\");\\n\\n    details[_roundId].submissions.push(_submission);\\n    oracles[msg.sender].lastReportedRound = _roundId;\\n    oracles[msg.sender].latestSubmission = _submission;\\n\\n    emit SubmissionReceived(_submission, _roundId, msg.sender);\\n  }\\n\\n  function deleteRoundDetails(uint32 _roundId)\\n    private\\n  {\\n    if (details[_roundId].submissions.length < details[_roundId].maxSubmissions) return;\\n\\n    delete details[_roundId];\\n  }\\n\\n  function timedOut(uint32 _roundId)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    uint64 startedAt = rounds[_roundId].startedAt;\\n    uint32 roundTimeout = details[_roundId].timeout;\\n    return startedAt > 0 && roundTimeout > 0 && startedAt.add(roundTimeout) < block.timestamp;\\n  }\\n\\n  function getStartingRound(address _oracle)\\n    private\\n    view\\n    returns (uint32)\\n  {\\n    uint32 currentRound = reportingRoundId;\\n    if (currentRound != 0 && currentRound == oracles[_oracle].endingRound) {\\n      return currentRound;\\n    }\\n    return currentRound.add(1);\\n  }\\n\\n  function previousAndCurrentUnanswered(uint32 _roundId, uint32 _rrId)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return _roundId.add(1) == _rrId && rounds[_rrId].updatedAt == 0;\\n  }\\n\\n  function requiredReserve(uint256 payment)\\n    private\\n    view\\n    returns (uint256)\\n  {\\n    return payment.mul(oracleCount()).mul(RESERVE_ROUNDS);\\n  }\\n\\n  function addOracle(\\n    address _oracle,\\n    address _admin\\n  )\\n    private\\n  {\\n    require(!oracleEnabled(_oracle), \\\"oracle already enabled\\\");\\n\\n    require(_admin != address(0), \\\"cannot set admin to 0\\\");\\n    require(oracles[_oracle].admin == address(0) || oracles[_oracle].admin == _admin, \\\"owner cannot overwrite admin\\\");\\n\\n    oracles[_oracle].startingRound = getStartingRound(_oracle);\\n    oracles[_oracle].endingRound = ROUND_MAX;\\n    oracles[_oracle].index = uint16(oracleAddresses.length);\\n    oracleAddresses.push(_oracle);\\n    oracles[_oracle].admin = _admin;\\n\\n    emit OraclePermissionsUpdated(_oracle, true);\\n    emit OracleAdminUpdated(_oracle, _admin);\\n  }\\n\\n  function removeOracle(\\n    address _oracle\\n  )\\n    private\\n  {\\n    require(oracleEnabled(_oracle), \\\"oracle not enabled\\\");\\n\\n    oracles[_oracle].endingRound = reportingRoundId.add(1);\\n    address tail = oracleAddresses[uint256(oracleCount()).sub(1)];\\n    uint16 index = oracles[_oracle].index;\\n    oracles[tail].index = index;\\n    delete oracles[_oracle].index;\\n    oracleAddresses[index] = tail;\\n    oracleAddresses.pop();\\n\\n    emit OraclePermissionsUpdated(_oracle, false);\\n  }\\n\\n  function validateOracleRound(address _oracle, uint32 _roundId)\\n    private\\n    view\\n    returns (bytes memory)\\n  {\\n    // cache storage reads\\n    uint32 startingRound = oracles[_oracle].startingRound;\\n    uint32 rrId = reportingRoundId;\\n\\n    if (startingRound == 0) return \\\"not enabled oracle\\\";\\n    if (startingRound > _roundId) return \\\"not yet enabled oracle\\\";\\n    if (oracles[_oracle].endingRound < _roundId) return \\\"no longer allowed oracle\\\";\\n    if (oracles[_oracle].lastReportedRound >= _roundId) return \\\"cannot report on previous rounds\\\";\\n    if (_roundId != rrId && _roundId != rrId.add(1) && !previousAndCurrentUnanswered(_roundId, rrId)) return \\\"invalid round to report\\\";\\n    if (_roundId != 1 && !supersedable(_roundId.sub(1))) return \\\"previous round not supersedable\\\";\\n  }\\n\\n  function supersedable(uint32 _roundId)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return rounds[_roundId].updatedAt > 0 || timedOut(_roundId);\\n  }\\n\\n  function oracleEnabled(address _oracle)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return oracles[_oracle].endingRound == ROUND_MAX;\\n  }\\n\\n  function acceptingSubmissions(uint32 _roundId)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return details[_roundId].maxSubmissions != 0;\\n  }\\n\\n  function delayed(address _oracle, uint32 _roundId)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    uint256 lastStarted = oracles[_oracle].lastStartedRound;\\n    return _roundId > lastStarted + restartDelay || lastStarted == 0;\\n  }\\n\\n  function newRound(uint32 _roundId)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    return _roundId == reportingRoundId.add(1);\\n  }\\n\\n  function validRoundId(uint256 _roundId)\\n    private\\n    pure\\n    returns (bool)\\n  {\\n    return _roundId <= ROUND_MAX;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/Median.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./vendor/SafeMathChainlink.sol\\\";\\nimport \\\"./SignedSafeMath.sol\\\";\\n\\nlibrary Median {\\n  using SignedSafeMath for int256;\\n\\n  int256 constant INT_MAX = 2**255-1;\\n\\n  /**\\n   * @notice Returns the sorted middle, or the average of the two middle indexed items if the\\n   * array has an even number of elements.\\n   * @dev The list passed as an argument isn't modified.\\n   * @dev This algorithm has expected runtime O(n), but for adversarially chosen inputs\\n   * the runtime is O(n^2).\\n   * @param list The list of elements to compare\\n   */\\n  function calculate(int256[] memory list)\\n    internal\\n    pure\\n    returns (int256)\\n  {\\n    return calculateInplace(copy(list));\\n  }\\n\\n  /**\\n   * @notice See documentation for function calculate.\\n   * @dev The list passed as an argument may be permuted.\\n   */\\n  function calculateInplace(int256[] memory list)\\n    internal\\n    pure\\n    returns (int256)\\n  {\\n    require(0 < list.length, \\\"list must not be empty\\\");\\n    uint256 len = list.length;\\n    uint256 middleIndex = len / 2;\\n    if (len % 2 == 0) {\\n      int256 median1;\\n      int256 median2;\\n      (median1, median2) = quickselectTwo(list, 0, len - 1, middleIndex - 1, middleIndex);\\n      return SignedSafeMath.avg(median1, median2);\\n    } else {\\n      return quickselect(list, 0, len - 1, middleIndex);\\n    }\\n  }\\n\\n  /**\\n   * @notice Maximum length of list that shortSelectTwo can handle\\n   */\\n  uint256 constant SHORTSELECTTWO_MAX_LENGTH = 7;\\n\\n  /**\\n   * @notice Select the k1-th and k2-th element from list of length at most 7\\n   * @dev Uses an optimal sorting network\\n   */\\n  function shortSelectTwo(\\n    int256[] memory list,\\n    uint256 lo,\\n    uint256 hi,\\n    uint256 k1,\\n    uint256 k2\\n  )\\n    private\\n    pure\\n    returns (int256 k1th, int256 k2th)\\n  {\\n    // Uses an optimal sorting network (https://en.wikipedia.org/wiki/Sorting_network)\\n    // for lists of length 7. Network layout is taken from\\n    // http://jgamble.ripco.net/cgi-bin/nw.cgi?inputs=7&algorithm=hibbard&output=svg\\n\\n    uint256 len = hi + 1 - lo;\\n    int256 x0 = list[lo + 0];\\n    int256 x1 = 1 < len ? list[lo + 1] : INT_MAX;\\n    int256 x2 = 2 < len ? list[lo + 2] : INT_MAX;\\n    int256 x3 = 3 < len ? list[lo + 3] : INT_MAX;\\n    int256 x4 = 4 < len ? list[lo + 4] : INT_MAX;\\n    int256 x5 = 5 < len ? list[lo + 5] : INT_MAX;\\n    int256 x6 = 6 < len ? list[lo + 6] : INT_MAX;\\n\\n    if (x0 > x1) {(x0, x1) = (x1, x0);}\\n    if (x2 > x3) {(x2, x3) = (x3, x2);}\\n    if (x4 > x5) {(x4, x5) = (x5, x4);}\\n    if (x0 > x2) {(x0, x2) = (x2, x0);}\\n    if (x1 > x3) {(x1, x3) = (x3, x1);}\\n    if (x4 > x6) {(x4, x6) = (x6, x4);}\\n    if (x1 > x2) {(x1, x2) = (x2, x1);}\\n    if (x5 > x6) {(x5, x6) = (x6, x5);}\\n    if (x0 > x4) {(x0, x4) = (x4, x0);}\\n    if (x1 > x5) {(x1, x5) = (x5, x1);}\\n    if (x2 > x6) {(x2, x6) = (x6, x2);}\\n    if (x1 > x4) {(x1, x4) = (x4, x1);}\\n    if (x3 > x6) {(x3, x6) = (x6, x3);}\\n    if (x2 > x4) {(x2, x4) = (x4, x2);}\\n    if (x3 > x5) {(x3, x5) = (x5, x3);}\\n    if (x3 > x4) {(x3, x4) = (x4, x3);}\\n\\n    uint256 index1 = k1 - lo;\\n    if (index1 == 0) {k1th = x0;}\\n    else if (index1 == 1) {k1th = x1;}\\n    else if (index1 == 2) {k1th = x2;}\\n    else if (index1 == 3) {k1th = x3;}\\n    else if (index1 == 4) {k1th = x4;}\\n    else if (index1 == 5) {k1th = x5;}\\n    else if (index1 == 6) {k1th = x6;}\\n    else {revert(\\\"k1 out of bounds\\\");}\\n\\n    uint256 index2 = k2 - lo;\\n    if (k1 == k2) {return (k1th, k1th);}\\n    else if (index2 == 0) {return (k1th, x0);}\\n    else if (index2 == 1) {return (k1th, x1);}\\n    else if (index2 == 2) {return (k1th, x2);}\\n    else if (index2 == 3) {return (k1th, x3);}\\n    else if (index2 == 4) {return (k1th, x4);}\\n    else if (index2 == 5) {return (k1th, x5);}\\n    else if (index2 == 6) {return (k1th, x6);}\\n    else {revert(\\\"k2 out of bounds\\\");}\\n  }\\n\\n  /**\\n   * @notice Selects the k-th ranked element from list, looking only at indices between lo and hi\\n   * (inclusive). Modifies list in-place.\\n   */\\n  function quickselect(int256[] memory list, uint256 lo, uint256 hi, uint256 k)\\n    private\\n    pure\\n    returns (int256 kth)\\n  {\\n    require(lo <= k);\\n    require(k <= hi);\\n    while (lo < hi) {\\n      if (hi - lo < SHORTSELECTTWO_MAX_LENGTH) {\\n        int256 ignore;\\n        (kth, ignore) = shortSelectTwo(list, lo, hi, k, k);\\n        return kth;\\n      }\\n      uint256 pivotIndex = partition(list, lo, hi);\\n      if (k <= pivotIndex) {\\n        // since pivotIndex < (original hi passed to partition),\\n        // termination is guaranteed in this case\\n        hi = pivotIndex;\\n      } else {\\n        // since (original lo passed to partition) <= pivotIndex,\\n        // termination is guaranteed in this case\\n        lo = pivotIndex + 1;\\n      }\\n    }\\n    return list[lo];\\n  }\\n\\n  /**\\n   * @notice Selects the k1-th and k2-th ranked elements from list, looking only at indices between\\n   * lo and hi (inclusive). Modifies list in-place.\\n   */\\n  function quickselectTwo(\\n    int256[] memory list,\\n    uint256 lo,\\n    uint256 hi,\\n    uint256 k1,\\n    uint256 k2\\n  )\\n    internal // for testing\\n    pure\\n    returns (int256 k1th, int256 k2th)\\n  {\\n    require(k1 < k2);\\n    require(lo <= k1 && k1 <= hi);\\n    require(lo <= k2 && k2 <= hi);\\n\\n    while (true) {\\n      if (hi - lo < SHORTSELECTTWO_MAX_LENGTH) {\\n        return shortSelectTwo(list, lo, hi, k1, k2);\\n      }\\n      uint256 pivotIdx = partition(list, lo, hi);\\n      if (k2 <= pivotIdx) {\\n        hi = pivotIdx;\\n      } else if (pivotIdx < k1) {\\n        lo = pivotIdx + 1;\\n      } else {\\n        assert(k1 <= pivotIdx && pivotIdx < k2);\\n        k1th = quickselect(list, lo, pivotIdx, k1);\\n        k2th = quickselect(list, pivotIdx + 1, hi, k2);\\n        return (k1th, k2th);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Partitions list in-place using Hoare's partitioning scheme.\\n   * Only elements of list between indices lo and hi (inclusive) will be modified.\\n   * Returns an index i, such that:\\n   * - lo <= i < hi\\n   * - forall j in [lo, i]. list[j] <= list[i]\\n   * - forall j in [i, hi]. list[i] <= list[j]\\n   */\\n  function partition(int256[] memory list, uint256 lo, uint256 hi)\\n    private\\n    pure\\n    returns (uint256)\\n  {\\n    // We don't care about overflow of the addition, because it would require a list\\n    // larger than any feasible computer's memory.\\n    int256 pivot = list[(lo + hi) / 2];\\n    lo -= 1; // this can underflow. that's intentional.\\n    hi += 1;\\n    while (true) {\\n      do {\\n        lo += 1;\\n      } while (list[lo] < pivot);\\n      do {\\n        hi -= 1;\\n      } while (list[hi] > pivot);\\n      if (lo < hi) {\\n        (list[lo], list[hi]) = (list[hi], list[lo]);\\n      } else {\\n        // Let orig_lo and orig_hi be the original values of lo and hi passed to partition.\\n        // Then, hi < orig_hi, because hi decreases *strictly* monotonically\\n        // in each loop iteration and\\n        // - either list[orig_hi] > pivot, in which case the first loop iteration\\n        //   will achieve hi < orig_hi;\\n        // - or list[orig_hi] <= pivot, in which case at least two loop iterations are\\n        //   needed:\\n        //   - lo will have to stop at least once in the interval\\n        //     [orig_lo, (orig_lo + orig_hi)/2]\\n        //   - (orig_lo + orig_hi)/2 < orig_hi\\n        return hi;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Makes an in-memory copy of the array passed in\\n   * @param list Reference to the array to be copied\\n   */\\n  function copy(int256[] memory list)\\n    private\\n    pure\\n    returns(int256[] memory)\\n  {\\n    int256[] memory list2 = new int256[](list.length);\\n    for (uint256 i = 0; i < list.length; i++) {\\n      list2[i] = list[i];\\n    }\\n    return list2;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.6.0 <0.8.0;\\n\\n/**\\n * @title The Owned contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract Owned {\\n\\n  address public owner;\\n  address private pendingOwner;\\n\\n  event OwnershipTransferRequested(\\n    address indexed from,\\n    address indexed to\\n  );\\n  event OwnershipTransferred(\\n    address indexed from,\\n    address indexed to\\n  );\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address _to)\\n    external\\n    onlyOwner()\\n  {\\n    pendingOwner = _to;\\n\\n    emit OwnershipTransferRequested(owner, _to);\\n  }\\n\\n  /**\\n   * @dev Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership()\\n    external\\n  {\\n    require(msg.sender == pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = owner;\\n    owner = msg.sender;\\n    pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @dev Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, \\\"Only callable by owner\\\");\\n    _;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/SafeMath128.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * This library is a version of Open Zeppelin's SafeMath, modified to support\\n * unsigned 128 bit integers.\\n */\\nlibrary SafeMath128 {\\n  /**\\n    * @dev Returns the addition of two unsigned integers, reverting on\\n    * overflow.\\n    *\\n    * Counterpart to Solidity's `+` operator.\\n    *\\n    * Requirements:\\n    * - Addition cannot overflow.\\n    */\\n  function add(uint128 a, uint128 b) internal pure returns (uint128) {\\n    uint128 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the subtraction of two unsigned integers, reverting on\\n    * overflow (when the result is negative).\\n    *\\n    * Counterpart to Solidity's `-` operator.\\n    *\\n    * Requirements:\\n    * - Subtraction cannot overflow.\\n    */\\n  function sub(uint128 a, uint128 b) internal pure returns (uint128) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    uint128 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the multiplication of two unsigned integers, reverting on\\n    * overflow.\\n    *\\n    * Counterpart to Solidity's `*` operator.\\n    *\\n    * Requirements:\\n    * - Multiplication cannot overflow.\\n    */\\n  function mul(uint128 a, uint128 b) internal pure returns (uint128) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint128 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the integer division of two unsigned integers. Reverts on\\n    * division by zero. The result is rounded towards zero.\\n    *\\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n    * uses an invalid opcode to revert (consuming all remaining gas).\\n    *\\n    * Requirements:\\n    * - The divisor cannot be zero.\\n    */\\n  function div(uint128 a, uint128 b) internal pure returns (uint128) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    uint128 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n    * Reverts when dividing by zero.\\n    *\\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\\n    * invalid opcode to revert (consuming all remaining gas).\\n    *\\n    * Requirements:\\n    * - The divisor cannot be zero.\\n    */\\n  function mod(uint128 a, uint128 b) internal pure returns (uint128) {\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/SafeMath32.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * This library is a version of Open Zeppelin's SafeMath, modified to support\\n * unsigned 32 bit integers.\\n */\\nlibrary SafeMath32 {\\n  /**\\n    * @dev Returns the addition of two unsigned integers, reverting on\\n    * overflow.\\n    *\\n    * Counterpart to Solidity's `+` operator.\\n    *\\n    * Requirements:\\n    * - Addition cannot overflow.\\n    */\\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\\n    uint32 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the subtraction of two unsigned integers, reverting on\\n    * overflow (when the result is negative).\\n    *\\n    * Counterpart to Solidity's `-` operator.\\n    *\\n    * Requirements:\\n    * - Subtraction cannot overflow.\\n    */\\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    uint32 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the multiplication of two unsigned integers, reverting on\\n    * overflow.\\n    *\\n    * Counterpart to Solidity's `*` operator.\\n    *\\n    * Requirements:\\n    * - Multiplication cannot overflow.\\n    */\\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint32 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the integer division of two unsigned integers. Reverts on\\n    * division by zero. The result is rounded towards zero.\\n    *\\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n    * uses an invalid opcode to revert (consuming all remaining gas).\\n    *\\n    * Requirements:\\n    * - The divisor cannot be zero.\\n    */\\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    uint32 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n    * Reverts when dividing by zero.\\n    *\\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\\n    * invalid opcode to revert (consuming all remaining gas).\\n    *\\n    * Requirements:\\n    * - The divisor cannot be zero.\\n    */\\n  function mod(uint32 a, uint32 b) internal pure returns (uint32) {\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/SafeMath64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * This library is a version of Open Zeppelin's SafeMath, modified to support\\n * unsigned 64 bit integers.\\n */\\nlibrary SafeMath64 {\\n  /**\\n    * @dev Returns the addition of two unsigned integers, reverting on\\n    * overflow.\\n    *\\n    * Counterpart to Solidity's `+` operator.\\n    *\\n    * Requirements:\\n    * - Addition cannot overflow.\\n    */\\n  function add(uint64 a, uint64 b) internal pure returns (uint64) {\\n    uint64 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the subtraction of two unsigned integers, reverting on\\n    * overflow (when the result is negative).\\n    *\\n    * Counterpart to Solidity's `-` operator.\\n    *\\n    * Requirements:\\n    * - Subtraction cannot overflow.\\n    */\\n  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    uint64 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the multiplication of two unsigned integers, reverting on\\n    * overflow.\\n    *\\n    * Counterpart to Solidity's `*` operator.\\n    *\\n    * Requirements:\\n    * - Multiplication cannot overflow.\\n    */\\n  function mul(uint64 a, uint64 b) internal pure returns (uint64) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint64 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the integer division of two unsigned integers. Reverts on\\n    * division by zero. The result is rounded towards zero.\\n    *\\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n    * uses an invalid opcode to revert (consuming all remaining gas).\\n    *\\n    * Requirements:\\n    * - The divisor cannot be zero.\\n    */\\n  function div(uint64 a, uint64 b) internal pure returns (uint64) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    uint64 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n    * Reverts when dividing by zero.\\n    *\\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\\n    * invalid opcode to revert (consuming all remaining gas).\\n    *\\n    * Requirements:\\n    * - The divisor cannot be zero.\\n    */\\n  function mod(uint64 a, uint64 b) internal pure returns (uint64) {\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\n{\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorValidatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface AggregatorValidatorInterface {\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n  function approve(address spender, uint256 value) external returns (bool success);\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n  function decimals() external view returns (uint8 decimalPlaces);\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n  function name() external view returns (string memory tokenName);\\n  function symbol() external view returns (string memory tokenSymbol);\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n  function transfer(address to, uint256 value) external returns (bool success);\\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathChainlink {\\n  /**\\n    * @dev Returns the addition of two unsigned integers, reverting on\\n    * overflow.\\n    *\\n    * Counterpart to Solidity's `+` operator.\\n    *\\n    * Requirements:\\n    * - Addition cannot overflow.\\n    */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the subtraction of two unsigned integers, reverting on\\n    * overflow (when the result is negative).\\n    *\\n    * Counterpart to Solidity's `-` operator.\\n    *\\n    * Requirements:\\n    * - Subtraction cannot overflow.\\n    */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the multiplication of two unsigned integers, reverting on\\n    * overflow.\\n    *\\n    * Counterpart to Solidity's `*` operator.\\n    *\\n    * Requirements:\\n    * - Multiplication cannot overflow.\\n    */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the integer division of two unsigned integers. Reverts on\\n    * division by zero. The result is rounded towards zero.\\n    *\\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n    * uses an invalid opcode to revert (consuming all remaining gas).\\n    *\\n    * Requirements:\\n    * - The divisor cannot be zero.\\n    */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n    * Reverts when dividing by zero.\\n    *\\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\\n    * invalid opcode to revert (consuming all remaining gas).\\n    *\\n    * Requirements:\\n    * - The divisor cannot be zero.\\n    */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nlibrary SignedSafeMath {\\n  int256 constant private _INT256_MIN = -2**255;\\n\\n  /**\\n   * @dev Multiplies two signed integers, reverts on overflow.\\n   */\\n  function mul(int256 a, int256 b) internal pure returns (int256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n    int256 c = a * b;\\n    require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\\n   */\\n  function div(int256 a, int256 b) internal pure returns (int256) {\\n    require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n    require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n    int256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Subtracts two signed integers, reverts on overflow.\\n   */\\n  function sub(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a - b;\\n    require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Adds two signed integers, reverts on overflow.\\n   */\\n  function add(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a + b;\\n    require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @notice Computes average of two signed integers, ensuring that the computation\\n   * doesn't overflow.\\n   * @dev If the result is not an integer, it is rounded towards zero. For example,\\n   * avg(-3, -4) = -3\\n   */\\n  function avg(int256 _a, int256 _b)\\n    internal\\n    pure\\n    returns (int256)\\n  {\\n    if ((_a < 0 && _b > 0) || (_a > 0 && _b < 0)) {\\n      return add(_a, _b) / 2;\\n    }\\n    int256 remainder = (_a % 2 + _b % 2) / 2;\\n    return add(add(_a / 2, _b / 2), remainder);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer()\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n  \\n  function latestTimestamp()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function latestRound()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  function getAnswer(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      int256\\n    );\\n\\n  function getTimestamp(\\n    uint256 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  event AnswerUpdated(\\n    int256 indexed current,\\n    uint256 indexed roundId,\\n    uint256 updatedAt\\n  );\\n\\n  event NewRound(\\n    uint256 indexed roundId,\\n    address indexed startedBy,\\n    uint256 startedAt\\n  );\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_paymentAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_timeout\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"_minSubmissionValue\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_maxSubmissionValue\",\"type\":\"int256\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"AnswerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AvailableFundsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"startedBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"OracleAdminUpdateRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"OracleAdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"OraclePermissionsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"authorized\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"delay\",\"type\":\"uint32\"}],\"name\":\"RequesterPermissionsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"paymentAmount\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"minSubmissionCount\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"maxSubmissionCount\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"restartDelay\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"}],\"name\":\"RoundDetailsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"submission\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"SubmissionReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"ValidatorUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocatedFunds\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableFunds\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_removed\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_added\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_addedAdmins\",\"type\":\"address[]\"},{\"internalType\":\"uint32\",\"name\":\"_minSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_maxSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_restartDelay\",\"type\":\"uint32\"}],\"name\":\"changeOracles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOracles\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkToken\",\"outputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSubmissionCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSubmissionValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_queriedRoundId\",\"type\":\"uint32\"}],\"name\":\"oracleRoundState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_eligibleToSubmit\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"_roundId\",\"type\":\"uint32\"},{\"internalType\":\"int256\",\"name\":\"_latestSubmission\",\"type\":\"int256\"},{\"internalType\":\"uint64\",\"name\":\"_startedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_timeout\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"_availableFunds\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"_oracleCount\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"_paymentAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentAmount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestNewRound\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restartDelay\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_requester\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_authorized\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"_delay\",\"type\":\"uint32\"}],\"name\":\"setRequesterPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newValidator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"_submission\",\"type\":\"int256\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeout\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAvailableFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_paymentAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_minSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_maxSubmissions\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_restartDelay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_timeout\",\"type\":\"uint32\"}],\"name\":\"updateFutureRounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"withdrawablePayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FluxAggregator", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000b0897686c545045afc77cf20ec7a532e3120e0f1000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000000002a30000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000003b9aca0000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000f47415547454341534820494e4445580000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}