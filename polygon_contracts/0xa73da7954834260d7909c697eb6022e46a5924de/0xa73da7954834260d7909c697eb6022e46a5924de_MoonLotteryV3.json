{"SourceCode": "pragma solidity ^0.8.0;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal view returns (bytes memory) {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(\r\n                oldAllowance >= value,\r\n                \"SafeERC20: decreased allowance below zero\"\r\n            );\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(\r\n                token,\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    newAllowance\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IMoonLottery {\r\n    /**\r\n     * @notice Buy tickets for the current lottery\r\n     * @param _lotteryId: lotteryId\r\n     * @param _ticketNumbers: array of ticket numbers between 1,000,000 and 1,999,999\r\n     * @dev Callable by users\r\n     */\r\n    function buyTickets(\r\n        uint256 _lotteryId,\r\n        uint32[] calldata _ticketNumbers\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Claim a set of winning tickets for a lottery\r\n     * @param _lotteryIds: lottery id\r\n     * @param _ticketIds: array of ticket ids\r\n     * @param _brackets: array of brackets for the ticket ids\r\n     * @dev Callable by users only, not contract!\r\n     */\r\n    function claimTickets(\r\n        uint256[] calldata _lotteryIds,\r\n        uint256[][] calldata _ticketIds,\r\n        uint32[][] calldata _brackets\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Close lottery\r\n     * @param _lotteryId: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function closeLottery(uint256 _lotteryId) external;\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in MOON per group, and make lottery claimable\r\n     * @param _lotteryId: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function drawFinalNumberAndMakeLotteryClaimable(\r\n        uint256 _lotteryId\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Start the lottery\r\n     * @dev Callable by operator\r\n     * @param _endTime: endTime of the lottery\r\n     * @param _priceTicketInMoon: ticket price in MOON\r\n     * @param _discountPerTicket: discount price per ticket in MOON\r\n     */\r\n    function startLottery(\r\n        uint256 _endTime,\r\n        uint256 _priceTicketInMoon,\r\n        uint256 _discountPerTicket,\r\n        uint256 _rewardPrize\r\n    ) external;\r\n\r\n    /**\r\n     * @notice View current lottery id\r\n     */\r\n    function viewCurrentLotteryId() external returns (uint256);\r\n}\r\n\r\ninterface IMoonDealer {\r\n    /**\r\n     * @notice call returnFunds after the lottery round ends to update the reward amount for users\r\n     */\r\n    function returnFunds(\r\n        uint256 _lotteryId,\r\n        uint256 _amount,\r\n        uint256 _totalPrize\r\n    ) external;\r\n\r\n    /**\r\n     * @notice call injectToLottery when the lottery round starts to inject tokens from dealers\r\n     */\r\n    function injectToLottery(uint256 _lotteryId) external returns (uint256);\r\n}\r\n\r\ninterface IRandomNumberGenerator {\r\n    /**\r\n     * Requests randomness from a user-provided seed\r\n     */\r\n    function getRandomNumber() external;\r\n\r\n    /**\r\n     * View latest lotteryId numbers\r\n     */\r\n    function viewLatestLotteryId() external view returns (uint256);\r\n\r\n    /**\r\n     * Views random result\r\n     */\r\n    function viewRandomResult() external view returns (FinalNumber memory);\r\n}\r\n\r\ninterface IValidator {\r\n    function checkMegamoonWallet(address _user) external view returns (bool);\r\n}\r\n\r\ninterface IReferral {\r\n    function hasReferrer(address addr) external view returns (bool);\r\n\r\n    function addAchievementPoint(\r\n        address _user,\r\n        uint256 _point\r\n    ) external returns (uint256);\r\n\r\n    function registReferral(\r\n        address _user,\r\n        address _referral,\r\n        bool _shareBenefit\r\n    ) external returns (bool);\r\n\r\n    function payReferralBonus(address _user, uint256 _amount) external;\r\n}\r\n\r\nstruct FinalNumber {\r\n    uint32 bonus;\r\n    uint32 match6;\r\n    uint32 matchFirst;\r\n    uint32 matchLast1;\r\n    uint32 matchLast2;\r\n    uint32 matchLast3;\r\n    uint32 matchLast4;\r\n    uint32 match2;\r\n}\r\n\r\npragma abicoder v2;\r\n\r\n/** @title Moon Lottery.\r\n * @notice It is a contract for a lottery system using\r\n * randomness provided externally.\r\n */\r\ncontract MoonLotteryV3 is ReentrancyGuard, IMoonLottery, Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 internal moonToken;\r\n    IMoonDealer internal dealer;\r\n    IReferral internal referral;\r\n    IRandomNumberGenerator public randomGenerator;\r\n\r\n    address public operatorAddress;\r\n    address public daoAddress;\r\n    address public treasuryAddress;\r\n    address public dealerAddress;\r\n    address public referralAddress;\r\n    address public validator;\r\n\r\n    uint256 public currentLotteryId;\r\n\r\n    uint256 private constant MIN_LENGTH_LOTTERY = 5 minutes; // 5 minutes\r\n    uint256 private constant MAX_LENGTH_LOTTERY = 366 days + 5 minutes; // 1 year\r\n    uint32 private constant SUM_SLOT_SIZE = 26; // 50m+\r\n    uint32 private constant SUM_SLOT = 0x3FFFFFF; // 2^26 - 1 = 67,108,863\r\n    uint32 private constant COUNT_SLOT_SIZE = 23; // 5m+\r\n    uint32 private constant COUNT_SLOT = 0x7FFFFF; // 2^23 - 1 = 8,388,608\r\n    uint32 private constant TICKET_SLOT_SIZE = 25;\r\n    uint32 private constant TICKET_SLOT = 0x1FFFFFF; // 2^25 - 1 = 33,554,431\r\n    uint32 private constant MAX_TICKET_SLOT = 5000000; // 5m\r\n    uint16 private constant MAX_DEALER_BONUS = 3000; //5000 = 50%, 3000 = 30% (Back to dealer)\r\n    uint16 private constant MAX_FEE = 2000; // 2000 = 20%\r\n    uint16 private constant MAX_REFERRAL_BONUS = 5000; // 5000 = 50%\r\n    uint16 private constant MAX_DAO_FUND = 10000; // 10000 = 100% (max = no leftover for treasury)\r\n\r\n    uint128 public maxNumberTicketsPerBuyOrClaim = 300;\r\n    uint128 public maxPriceTicketInMoon = 100000000;\r\n    uint128 public minPriceTicketInMoon = 1000000;\r\n    uint32 public feePercent = 550; // collect 5.5% from ticket sold\r\n    uint32 public referralBonus = 3000; // 30% from fee collected amount\r\n    uint32 public daoPercent = 5000; // 50% from fee collected minus referral amount\r\n    uint32 public minimumBulk = 10;\r\n\r\n    // 0 = match 6 + bonus \t\t\t\t1,000,000\r\n    // 1 = match 6\t\t\t\t\t\t300,000\r\n    // 2 = match first 3 + bonus\t\t1,000\r\n    // 3 = match first 3\t\t\t\t300\r\n    // 4 = match last 3 \t\t\t\t300\r\n    // 5 = match any first 3 + bonus\t150\r\n    // 6 = match any first 3 \t\t\t100\r\n    // 7 = match last 2\t\t\t\t    100\r\n    uint32[] public rewardsPerBracket = [\r\n        1000000,\r\n        300000,\r\n        1000,\r\n        300,\r\n        300,\r\n        150,\r\n        100,\r\n        100\r\n    ];\r\n\r\n    enum Status {\r\n        Pending,\r\n        Open,\r\n        Close,\r\n        Claimable\r\n    }\r\n\r\n    struct Lottery {\r\n        Status status;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 priceTicketInMoon;\r\n        uint256 discountPerTicket;\r\n        uint256 rewardPrize;\r\n        uint256 jackpotPrize;\r\n        uint256[8] moonPerBracket;\r\n        uint256[8] winnersPerBracket;\r\n        uint256 feeCollectedInMoon;\r\n        uint256 amountCollectedInMoon;\r\n        FinalNumber finalNumber;\r\n    }\r\n\r\n    // Mapping are cheaper than arrays\r\n    mapping(uint256 => Lottery) internal _lotteries;\r\n\r\n    // Keeps track of number of ticket per unique combination for each lotteryId\r\n    mapping(uint256 => mapping(uint256 => uint256))\r\n        internal _numberTicketsPerLotteryId;\r\n    mapping(uint256 => mapping(uint256 => uint256))\r\n        internal _numberTickets2PerLotteryId;\r\n\r\n    // Keep track of user total tickets for the lotteryId [user][lotteryId]\r\n    mapping(address => mapping(uint256 => uint256)) internal _userTicketCount;\r\n\r\n    // Keep track of user tickets for a given lotteryId [user][lotteryId][slot] = 10 tickets\r\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256)))\r\n        internal _userTicketsPerLotteryId;\r\n\r\n    // Keep track of ticket claimed: [user][lotteryId][ticketId] = true/false\r\n    mapping(address => mapping(uint256 => mapping(uint256 => bool)))\r\n        internal _ticketClaimed;\r\n\r\n    modifier onlyMegamoonUser() {\r\n        require(\r\n            IValidator(validator).checkMegamoonWallet(msg.sender),\r\n            \"not megamoon wallet\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operatorAddress, \"Not operator\");\r\n        _;\r\n    }\r\n\r\n    event TokenRecovery(address token, uint256 amount);\r\n    event LotteryClose(uint256 indexed lotteryId);\r\n    event LotteryOpen(\r\n        uint256 indexed lotteryId,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        uint256 priceTicketInMoon,\r\n        uint256 discountPerTicket,\r\n        uint256 prize,\r\n        uint256 injectedAmount\r\n    );\r\n    event LotteryNumberDrawn(\r\n        uint256 indexed lotteryId,\r\n        FinalNumber finalNumber\r\n    );\r\n\r\n    event NewOperatorAddress(address operator);\r\n    event NewRandomGenerator(address indexed randomGenerator);\r\n    event NewReferral(address refferal);\r\n    event NewReferralBonus(uint256 bonusRate);\r\n    event NewMinAndMaxTicketPriceInMoon(\r\n        uint256 minPriceTicketInMoon,\r\n        uint256 maxPriceTicketInMoon\r\n    );\r\n    event NewMaxNumberTicketsPerBuyOrClaim(uint256 maxNumberTickets);\r\n    event NewMinimumBulk(uint32 number);\r\n    event NewDaoPercent(uint32 dao);\r\n    event NewFeePercent(uint32 percent);\r\n    event NewRewardsPerBracket(uint32[] brackets);\r\n\r\n    event TicketsPurchase(\r\n        address indexed buyer,\r\n        uint256 indexed lotteryId,\r\n        uint256 numberTickets\r\n    );\r\n    event TicketsClaim(\r\n        address indexed claimer,\r\n        uint256 amount,\r\n        uint256 indexed lotteryId,\r\n        uint256 numberTickets\r\n    );\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @dev RandomNumberGenerator must be deployed prior to this contract\r\n     * @param _randomGeneratorAddress: address of the RandomGenerator contract used to work with ChainLink VRF\r\n     * @param _moonTokenAddress: address of the MOON token\r\n     */\r\n    constructor(\r\n        address _moonTokenAddress,\r\n        address _randomGeneratorAddress,\r\n        address _dealerAddress,\r\n        address _operatorAddress,\r\n        address _daoAddress,\r\n        address _treasuryAddress,\r\n        address _referral,\r\n        address _validator\r\n    ) {\r\n        moonToken = IERC20(_moonTokenAddress);\r\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\r\n        dealerAddress = _dealerAddress;\r\n        operatorAddress = _operatorAddress;\r\n        daoAddress = _daoAddress;\r\n        treasuryAddress = _treasuryAddress;\r\n        dealer = IMoonDealer(dealerAddress);\r\n        referralAddress = _referral;\r\n        referral = IReferral(referralAddress);\r\n        validator = _validator;\r\n    }\r\n\r\n    /**\r\n     * @notice Buy tickets for the current lottery\r\n     * @param _lotteryId: lotteryId\r\n     * @param _ticketNumbers: array of ticket numbers between 1,000,000 and 1,999,999\r\n     * @dev Callable by users\r\n     */\r\n    function buyTickets(\r\n        uint256 _lotteryId,\r\n        uint32[] calldata _ticketNumbers\r\n    ) external override onlyMegamoonUser nonReentrant {\r\n        require(_ticketNumbers.length != 0, \"No ticket specified\");\r\n        require(\r\n            _ticketNumbers.length <= maxNumberTicketsPerBuyOrClaim,\r\n            \"Too many tickets\"\r\n        );\r\n        require(\r\n            _lotteries[_lotteryId].status == Status.Open,\r\n            \"Lottery is not open\"\r\n        );\r\n        require(\r\n            block.timestamp < _lotteries[_lotteryId].endTime,\r\n            \"Lottery is over\"\r\n        );\r\n\r\n        uint256 ticketCost;\r\n        if (_ticketNumbers.length < minimumBulk) {\r\n            // Calculate number of MOON to this contract\r\n            ticketCost =\r\n                _lotteries[_lotteryId].priceTicketInMoon *\r\n                _ticketNumbers.length;\r\n        } else {\r\n            ticketCost =\r\n                (_lotteries[_lotteryId].priceTicketInMoon -\r\n                    _lotteries[_lotteryId].discountPerTicket) *\r\n                _ticketNumbers.length;\r\n        }\r\n\r\n        // Transfer moon tokens to this contract\r\n        moonToken.safeTransferFrom(\r\n            address(msg.sender),\r\n            address(this),\r\n            ticketCost\r\n        );\r\n\r\n        uint256 feeCollected = (ticketCost * feePercent) / 10000;\r\n\r\n        // Increment the total amount collected for the lottery round\r\n        _lotteries[_lotteryId].amountCollectedInMoon += (ticketCost -\r\n            feeCollected);\r\n\r\n        referral.addAchievementPoint(msg.sender, _ticketNumbers.length);\r\n\r\n        if (referral.hasReferrer(msg.sender)) {\r\n            uint256 bonusForReferrer;\r\n\r\n            bonusForReferrer = (feeCollected * referralBonus) / 10000;\r\n            referral.payReferralBonus(msg.sender, bonusForReferrer);\r\n\r\n            moonToken.safeTransfer(referralAddress, bonusForReferrer);\r\n\r\n            feeCollected -= bonusForReferrer;\r\n        }\r\n\r\n        _lotteries[_lotteryId].feeCollectedInMoon += feeCollected;\r\n\r\n        // Prepare for user tickets memorize\r\n        uint256 storageNumber = _userTicketCount[msg.sender][_lotteryId];\r\n        uint256 startIndex = storageNumber % 10;\r\n        storageNumber = storageNumber / 10;\r\n        uint256 totalStorage = ((_ticketNumbers.length + startIndex) / 10) + 1;\r\n        uint256[] memory newUserTickets = new uint256[](totalStorage);\r\n\r\n        for (uint256 i = 0; i < _ticketNumbers.length; ++i) {\r\n            require(\r\n                (_ticketNumbers[i] >= 10000000) &&\r\n                    (_ticketNumbers[i] <= 19999999),\r\n                \"Outside range\"\r\n            );\r\n            uint256 ticketCount = (uint256(1) <<\r\n                (((_ticketNumbers[i] % 10) * COUNT_SLOT_SIZE) +\r\n                    SUM_SLOT_SIZE)) + 1; // SLOT_SIZE binary digits per number 0 - 9\r\n\r\n            if (\r\n                (_numberTicketsPerLotteryId[_lotteryId][\r\n                    _ticketNumbers[i] / 10\r\n                ] >> ticketCount) &\r\n                    0x1FFFFFF <=\r\n                MAX_TICKET_SLOT\r\n            ) {\r\n                // 1,XXX,XXX = [9,8,7,6,5,4,3,2,1,0,SUM]\r\n                _numberTicketsPerLotteryId[_lotteryId][\r\n                    _ticketNumbers[i] / 10\r\n                ] += ticketCount;\r\n                // 1XXX = [9,8,7,6,5,4,3,2,1,0,SUM]\r\n                _numberTicketsPerLotteryId[_lotteryId][\r\n                    ((_ticketNumbers[i] / 10) % 1000) + 1000\r\n                ] += ticketCount;\r\n                // 1XXX = SUM\r\n                _numberTickets2PerLotteryId[_lotteryId][\r\n                    (_ticketNumbers[i] / 10000)\r\n                ] += 1;\r\n            }\r\n\r\n            newUserTickets[(i + startIndex) / 10] +=\r\n                uint256(_ticketNumbers[i]) <<\r\n                (((i + startIndex) % 10) * TICKET_SLOT_SIZE);\r\n        }\r\n\r\n        // memo user tickets to cold storage\r\n        for (uint256 j = 0; j < totalStorage; ++j) {\r\n            _userTicketsPerLotteryId[msg.sender][_lotteryId][\r\n                storageNumber + j\r\n            ] += newUserTickets[j];\r\n        }\r\n\r\n        _userTicketCount[msg.sender][_lotteryId] += _ticketNumbers.length;\r\n\r\n        emit TicketsPurchase(msg.sender, _lotteryId, _ticketNumbers.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim a set of winning tickets for a lottery\r\n     * @param _lotteryIds: lottery id\r\n     * @param _ticketIds: array of ticket ids\r\n     * @param _brackets: array of brackets for the ticket ids\r\n     * @dev Callable by users only, not contract!\r\n     */\r\n    function claimTickets(\r\n        uint256[] calldata _lotteryIds,\r\n        uint256[][] calldata _ticketIds,\r\n        uint32[][] calldata _brackets\r\n    ) external override onlyMegamoonUser nonReentrant {\r\n        require(\r\n            _lotteryIds.length == _ticketIds.length &&\r\n                _ticketIds.length == _brackets.length,\r\n            \"Not same length\"\r\n        );\r\n        require(\r\n            _lotteryIds.length <= maxNumberTicketsPerBuyOrClaim,\r\n            \"Too many tickets\"\r\n        );\r\n\r\n        // Initializes the rewardInMoonToTransfer\r\n        uint256 rewardInMoonToTransfer;\r\n        for (uint256 i = 0; i < _lotteryIds.length; ++i) {\r\n            uint256 currentRoundReward;\r\n            require(\r\n                _lotteries[_lotteryIds[i]].status == Status.Claimable,\r\n                \"Lottery not claimable\"\r\n            );\r\n            require(_ticketIds[i].length != 0, \"Length must be > 0\");\r\n            require(\r\n                _ticketIds[i].length == _brackets[i].length,\r\n                \"Not same length\"\r\n            );\r\n\r\n            for (uint256 j = 0; j < _ticketIds[i].length; ++j) {\r\n                require(_brackets[i][j] < 8, \"Bracket is out of range\"); // Must be 0 -> 5\r\n                require(\r\n                    _userTicketCount[msg.sender][_lotteryIds[i]] >\r\n                        _ticketIds[i][j],\r\n                    \"TicketId is too high\"\r\n                );\r\n                require(\r\n                    _ticketClaimed[msg.sender][_lotteryIds[i]][\r\n                        _ticketIds[i][j]\r\n                    ] == false,\r\n                    \"Ticket was claimed\"\r\n                );\r\n\r\n                uint256 rewardForTicketId = _calculateRewardsForTicketId(\r\n                    msg.sender,\r\n                    _lotteryIds[i],\r\n                    _ticketIds[i][j],\r\n                    _brackets[i][j]\r\n                );\r\n\r\n                require(rewardForTicketId != 0, \"no reward for this ticket\");\r\n\r\n                // Update the lottery ticket claimed status to true\r\n                _ticketClaimed[msg.sender][_lotteryIds[i]][\r\n                    _ticketIds[i][j]\r\n                ] = true;\r\n\r\n                currentRoundReward += rewardForTicketId;\r\n            }\r\n\r\n            emit TicketsClaim(\r\n                msg.sender,\r\n                currentRoundReward,\r\n                _lotteryIds[i],\r\n                _ticketIds[i].length\r\n            );\r\n\r\n            rewardInMoonToTransfer += currentRoundReward;\r\n        }\r\n\r\n        // Transfer money to msg.sender\r\n        moonToken.safeTransfer(msg.sender, rewardInMoonToTransfer);\r\n    }\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in MOON per group, and make lottery claimable\r\n     * @param _lotteryId: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function drawFinalNumberAndMakeLotteryClaimable(\r\n        uint256 _lotteryId\r\n    ) external override onlyOperator nonReentrant {\r\n        require(\r\n            _lotteries[_lotteryId].status == Status.Close,\r\n            \"Lottery not close\"\r\n        );\r\n        require(\r\n            block.timestamp > _lotteries[_lotteryId].endTime,\r\n            \"Lottery not over\"\r\n        );\r\n        require(\r\n            _lotteryId == randomGenerator.viewLatestLotteryId(),\r\n            \"Numbers not drawn\"\r\n        );\r\n        // Calculate the finalNumber based on the randomResult generated by ChainLink's fallback\r\n        FinalNumber memory finalNumber = randomGenerator.viewRandomResult();\r\n\r\n        // Initializes the amount to withdraw to dealer\r\n        uint256 amountToWithdraw;\r\n        uint256 amountToShareToWinners = _lotteries[_lotteryId]\r\n            .amountCollectedInMoon;\r\n\r\n        // uint256[] memory winnerCount = new uint256[](8);\r\n        uint256[] memory winnerCount = _countWinner(_lotteryId, finalNumber);\r\n        _lotteries[_lotteryId].winnersPerBracket = [\r\n            winnerCount[0],\r\n            winnerCount[1],\r\n            winnerCount[2],\r\n            winnerCount[3],\r\n            winnerCount[4],\r\n            winnerCount[5],\r\n            winnerCount[6],\r\n            winnerCount[7]\r\n        ];\r\n\r\n        uint256 rewards = _calculateReward(_lotteryId);\r\n        uint256 feeLeftOver;\r\n\r\n        if (rewards < amountToShareToWinners) {\r\n            for (uint256 i = 0; i < 8; ++i) {\r\n                if (_lotteries[_lotteryId].winnersPerBracket[i] > 0) {\r\n                    _lotteries[_lotteryId].moonPerBracket[i] =\r\n                        rewardsPerBracket[i] *\r\n                        _lotteries[_lotteryId].rewardPrize;\r\n                }\r\n            }\r\n            amountToWithdraw = amountToShareToWinners - rewards;\r\n        } else {\r\n            uint256 sumRewards;\r\n            for (uint256 i = 0; i < 8; ++i) {\r\n                if (_lotteries[_lotteryId].winnersPerBracket[i] > 0) {\r\n                    _lotteries[_lotteryId].moonPerBracket[i] =\r\n                        (rewardsPerBracket[i] *\r\n                            _lotteries[_lotteryId].rewardPrize *\r\n                            amountToShareToWinners) /\r\n                        rewards;\r\n                    sumRewards +=\r\n                        _lotteries[_lotteryId].moonPerBracket[i] *\r\n                        _lotteries[_lotteryId].winnersPerBracket[i];\r\n                }\r\n            }\r\n            // a few chance of some tiny remaining from fraction\r\n            if (amountToShareToWinners > sumRewards) {\r\n                feeLeftOver = amountToShareToWinners - sumRewards;\r\n            }\r\n        }\r\n        // Update internal statuses for lottery\r\n        _lotteries[_lotteryId].finalNumber = finalNumber;\r\n        _lotteries[_lotteryId].status = Status.Claimable;\r\n        // Transfer MOON for dao fund\r\n        uint256 daoAmount = (_lotteries[_lotteryId].feeCollectedInMoon *\r\n            daoPercent) / 10000;\r\n        if (daoAmount > 0 || feeLeftOver > 0) {\r\n            moonToken.safeTransfer(daoAddress, daoAmount + feeLeftOver);\r\n        }\r\n        if (_lotteries[_lotteryId].feeCollectedInMoon - daoAmount > 0) {\r\n            moonToken.safeTransfer(\r\n                treasuryAddress,\r\n                _lotteries[_lotteryId].feeCollectedInMoon - daoAmount\r\n            );\r\n        }\r\n        // Transfer MOON to dealer\r\n        if (amountToWithdraw > 0) {\r\n            moonToken.safeTransfer(dealerAddress, amountToWithdraw);\r\n        }\r\n        dealer.returnFunds(\r\n            currentLotteryId,\r\n            amountToWithdraw,\r\n            _lotteries[_lotteryId].amountCollectedInMoon\r\n        );\r\n        emit LotteryNumberDrawn(\r\n            currentLotteryId,\r\n            _lotteries[_lotteryId].finalNumber\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Start the lottery\r\n     * @dev Callable by operator\r\n     * @param _endTime: endTime of the lottery\r\n     * @param _priceTicketInMoon: price of a ticket in MOON -> 3980000\r\n     # @param _discountPerTicket: discount of a ticket -> 210000\r\n     */\r\n    function startLottery(\r\n        uint256 _endTime,\r\n        uint256 _priceTicketInMoon,\r\n        uint256 _discountPerTicket,\r\n        uint256 _rewardPrize\r\n    ) external override onlyOperator {\r\n        require(\r\n            (currentLotteryId == 0) ||\r\n                (_lotteries[currentLotteryId].status == Status.Claimable),\r\n            \"Not time to start lottery\"\r\n        );\r\n        require(\r\n            ((_endTime - block.timestamp) > MIN_LENGTH_LOTTERY) &&\r\n                ((_endTime - block.timestamp) < MAX_LENGTH_LOTTERY),\r\n            \"Lottery time is outside of range\"\r\n        );\r\n        require(\r\n            (_priceTicketInMoon >= minPriceTicketInMoon) &&\r\n                (_priceTicketInMoon <= maxPriceTicketInMoon),\r\n            \"Ticket price is outside of limits\"\r\n        );\r\n        require(\r\n            _discountPerTicket < _priceTicketInMoon,\r\n            \"Invalid number, discount over price\"\r\n        );\r\n        currentLotteryId++;\r\n        uint256 injectAmount = dealer.injectToLottery(currentLotteryId);\r\n        uint256[8] memory initialArray;\r\n        FinalNumber memory initialFinalNumber;\r\n\r\n        _lotteries[currentLotteryId] = Lottery({\r\n            status: Status.Open,\r\n            startTime: block.timestamp,\r\n            endTime: _endTime,\r\n            priceTicketInMoon: _priceTicketInMoon,\r\n            discountPerTicket: _discountPerTicket,\r\n            rewardPrize: _rewardPrize,\r\n            jackpotPrize: 0,\r\n            moonPerBracket: initialArray,\r\n            winnersPerBracket: initialArray,\r\n            feeCollectedInMoon: 0,\r\n            amountCollectedInMoon: injectAmount,\r\n            finalNumber: initialFinalNumber\r\n        });\r\n\r\n        emit LotteryOpen(\r\n            currentLotteryId,\r\n            block.timestamp,\r\n            _endTime,\r\n            _priceTicketInMoon,\r\n            _discountPerTicket,\r\n            _rewardPrize,\r\n            injectAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Close lottery\r\n     * @param _lotteryId: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function closeLottery(\r\n        uint256 _lotteryId\r\n    ) external override onlyOperator nonReentrant {\r\n        require(\r\n            _lotteries[_lotteryId].status == Status.Open,\r\n            \"Lottery not open\"\r\n        );\r\n        require(\r\n            block.timestamp > _lotteries[_lotteryId].endTime,\r\n            \"Lottery not over\"\r\n        );\r\n\r\n        _lotteries[_lotteryId].status = Status.Close;\r\n\r\n        // Request a random number from the generator based on a seed\r\n        randomGenerator.getRandomNumber();\r\n\r\n        emit LotteryClose(_lotteryId);\r\n    }\r\n\r\n    function registReferral(\r\n        address _referrer,\r\n        bool _shareBenefit\r\n    ) external onlyMegamoonUser returns (bool) {\r\n        return referral.registReferral(msg.sender, _referrer, _shareBenefit);\r\n    }\r\n\r\n    /**\r\n     * @notice Change the random generator\r\n     * @dev The calls to functions are used to verify the new generator implements them properly.\r\n     * It is necessary to wait for the VRF response before starting a round.\r\n     * Callable only by the contract owner\r\n     * @param _randomGeneratorAddress: address of the random generator\r\n     */\r\n    function changeRandomGenerator(\r\n        address _randomGeneratorAddress\r\n    ) external onlyOwner {\r\n        require(\r\n            _lotteries[currentLotteryId].status == Status.Claimable,\r\n            \"Lottery not in claimable\"\r\n        );\r\n\r\n        // Request a random number from the generator based on a seed\r\n        IRandomNumberGenerator(_randomGeneratorAddress).getRandomNumber();\r\n\r\n        // Calculate the finalNumber based on the randomResult generated by ChainLink's fallback\r\n        IRandomNumberGenerator(_randomGeneratorAddress).viewRandomResult();\r\n\r\n        randomGenerator = IRandomNumberGenerator(_randomGeneratorAddress);\r\n\r\n        emit NewRandomGenerator(_randomGeneratorAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice It allows the owner to recover wrong tokens sent to the contract\r\n     * @param _tokenAddress: the address of the token to withdraw\r\n     * @param _tokenAmount: the number of token amount to withdraw\r\n     * @dev Only callable by owner.\r\n    //  */\r\n    function recoverWrongTokens(\r\n        address _tokenAddress,\r\n        uint256 _tokenAmount\r\n    ) external onlyOwner {\r\n        require(_tokenAddress != address(moonToken), \"Cannot be MOON token\");\r\n\r\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\r\n\r\n        emit TokenRecovery(_tokenAddress, _tokenAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Set MOON price ticket upper/lower limit\r\n     * @dev Only callable by owner\r\n     * @param _minPriceTicketInMoon: minimum price of a ticket in MOON\r\n     * @param _maxPriceTicketInMoon: maximum price of a ticket in MOON\r\n     */\r\n    function setMinAndMaxTicketPriceInMoon(\r\n        uint128 _minPriceTicketInMoon,\r\n        uint128 _maxPriceTicketInMoon\r\n    ) external onlyOwner {\r\n        require(\r\n            _minPriceTicketInMoon <= _maxPriceTicketInMoon,\r\n            \"minPrice must be < maxPrice\"\r\n        );\r\n\r\n        minPriceTicketInMoon = _minPriceTicketInMoon;\r\n        maxPriceTicketInMoon = _maxPriceTicketInMoon;\r\n\r\n        emit NewMinAndMaxTicketPriceInMoon(\r\n            minPriceTicketInMoon,\r\n            maxPriceTicketInMoon\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Set max number of tickets\r\n     * @dev Only callable by owner\r\n     */\r\n    function setMaxNumberTicketsPerBuy(\r\n        uint128 _maxNumberTicketsPerBuy\r\n    ) external onlyOwner {\r\n        require(_maxNumberTicketsPerBuy != 0, \"Must be > 0\");\r\n\r\n        maxNumberTicketsPerBuyOrClaim = _maxNumberTicketsPerBuy;\r\n\r\n        emit NewMaxNumberTicketsPerBuyOrClaim(maxNumberTicketsPerBuyOrClaim);\r\n    }\r\n\r\n    /**\r\n     * @notice Set new number for referral bonus\r\n     * @dev Only callable by owner\r\n     */\r\n    function setReferralBonus(uint32 _referralBonus) external onlyOwner {\r\n        require(_referralBonus != 0, \"Must be > 0\");\r\n        require(_referralBonus < MAX_REFERRAL_BONUS, \"Referral bonus too high\");\r\n        referralBonus = _referralBonus;\r\n\r\n        emit NewReferralBonus(_referralBonus);\r\n    }\r\n\r\n    function setReferral(address _referral) external onlyOwner {\r\n        require(_referral != address(0));\r\n\r\n        referralAddress = _referral;\r\n        referral = IReferral(referralAddress);\r\n\r\n        emit NewReferral(referralAddress);\r\n    }\r\n\r\n    function setDaoPercent(uint32 _percent) external onlyOwner {\r\n        require(_percent != 0, \"Must be > 0\");\r\n        require(_percent < MAX_DAO_FUND, \"Percent too high\");\r\n        daoPercent = _percent;\r\n\r\n        emit NewDaoPercent(_percent);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the number of minimum tickets that will get a discount\r\n     */\r\n    function setMinimumBulk(uint32 _number) external onlyOwner {\r\n        require(\r\n            _number > 0 && _number < maxNumberTicketsPerBuyOrClaim,\r\n            \"invalid number\"\r\n        );\r\n\r\n        minimumBulk = _number;\r\n\r\n        emit NewMinimumBulk(minimumBulk);\r\n    }\r\n\r\n    function setFee(uint32 _percent) external onlyOwner {\r\n        require(_percent > 0 && _percent <= MAX_FEE, \"Invalid number\");\r\n\r\n        feePercent = _percent;\r\n\r\n        emit NewFeePercent(_percent);\r\n    }\r\n\r\n    function setRewardsPerBracket(\r\n        uint32[] calldata _brackets\r\n    ) external onlyOwner {\r\n        require(_brackets.length == 8, \"Require length = 8\");\r\n\r\n        for (uint256 i = 0; i < 8; i = unsafe_inc(i)) {\r\n            require(_brackets[i] < 2 ** 32, \"Number too high\");\r\n            rewardsPerBracket[i] = _brackets[i];\r\n        }\r\n\r\n        emit NewRewardsPerBracket(_brackets);\r\n    }\r\n\r\n    /**\r\n     * @notice Set operator addresse\r\n     * @dev Only callable by owner\r\n     * @param _operatorAddress: address of the operator\r\n     */\r\n    function setOperatorAddress(address _operatorAddress) external onlyOwner {\r\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\r\n\r\n        operatorAddress = _operatorAddress;\r\n\r\n        emit NewOperatorAddress(_operatorAddress);\r\n    }\r\n\r\n    function viewCurrentLotteryId() external view override returns (uint256) {\r\n        return currentLotteryId;\r\n    }\r\n\r\n    /**\r\n     * @notice View lottery info\r\n     * @param _lotteryId: lottery id\r\n     */\r\n    function viewLottery(\r\n        uint256 _lotteryId\r\n    ) external view returns (Lottery memory) {\r\n        return _lotteries[_lotteryId];\r\n    }\r\n\r\n    /**\r\n     * @notice View moon token address\r\n     * @dev this function is required in case that the contract will use megamoon referral\r\n     */\r\n    function viewMoonTokenAddress() external view returns (address) {\r\n        return address(moonToken);\r\n    }\r\n\r\n    /**\r\n     * @notice View minimum bulk for ticket discount\r\n     */\r\n    function viewMinimumBulk() external view returns (uint256) {\r\n        return minimumBulk;\r\n    }\r\n\r\n    /**\r\n     * @notice View rewards for a given ticket, providing a bracket, and lottery id\r\n     * @dev Computations are mostly offchain. This is used to verify a ticket!\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketId: ticket id\r\n     * @param _bracket: bracket for the ticketId to verify the claim and calculate rewards\r\n     */\r\n    function viewRewardsForTicketId(\r\n        address _user,\r\n        uint256 _lotteryId,\r\n        uint256 _ticketId,\r\n        uint32 _bracket\r\n    ) external view returns (uint256) {\r\n        // Check lottery is in claimable status and ticketId is within the range\r\n        if (\r\n            _lotteries[_lotteryId].status != Status.Claimable &&\r\n            _ticketId >= _userTicketCount[_user][_lotteryId]\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        return\r\n            _calculateRewardsForTicketId(\r\n                _user,\r\n                _lotteryId,\r\n                _ticketId,\r\n                _bracket\r\n            );\r\n    }\r\n\r\n    function checkRewardBracket(\r\n        uint256 _lotteryId,\r\n        uint256 _ticketNumber\r\n    ) external view returns (uint256) {\r\n        return _checkRewardBracket(_lotteryId, _ticketNumber);\r\n    }\r\n\r\n    /**\r\n     * @notice View user ticket ids, numbers, and statuses of user for a given lottery\r\n     * @param _user: user address\r\n     * @param _lotteryId: lottery id\r\n     * @param _cursor: cursor to start where to retrieve the tickets\r\n     * @param _size: the number of tickets to retrieve\r\n     */\r\n    function viewUserInfoForLotteryId(\r\n        address _user,\r\n        uint256 _lotteryId,\r\n        uint256 _cursor,\r\n        uint256 _size\r\n    )\r\n        external\r\n        view\r\n        returns (uint256[] memory, uint256[] memory, bool[] memory, uint256)\r\n    {\r\n        uint256 length;\r\n\r\n        if (_size > (_userTicketCount[_user][_lotteryId] - _cursor)) {\r\n            length = _userTicketCount[_user][_lotteryId] - _cursor;\r\n        } else {\r\n            length = _size;\r\n        }\r\n\r\n        uint256[] memory lotteryTicketIds = new uint256[](length);\r\n        uint256[] memory ticketNumbers = new uint256[](length);\r\n        bool[] memory ticketStatuses = new bool[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            uint256 id = i + _cursor;\r\n            lotteryTicketIds[i] = id;\r\n            ticketNumbers[i] = _viewTicketNumber(_user, _lotteryId, id);\r\n            ticketStatuses[i] = _ticketClaimed[_user][_lotteryId][id];\r\n        }\r\n\r\n        return (\r\n            lotteryTicketIds,\r\n            ticketNumbers,\r\n            ticketStatuses,\r\n            _cursor + length\r\n        );\r\n    }\r\n\r\n    function _calculateReward(\r\n        uint256 _lotteryId\r\n    ) private view returns (uint256) {\r\n        uint256 rewards;\r\n        for (uint256 i = 0; i < 8; ++i) {\r\n            rewards +=\r\n                _lotteries[_lotteryId].winnersPerBracket[i] *\r\n                rewardsPerBracket[i] *\r\n                _lotteries[_lotteryId].rewardPrize;\r\n        }\r\n        return rewards;\r\n    }\r\n\r\n    function _countWinner(\r\n        uint256 _lotteryId,\r\n        FinalNumber memory finalNumber\r\n    ) private view returns (uint256[] memory) {\r\n        uint256[] memory rawWinnerCount = new uint256[](19);\r\n        uint256[] memory winnerCount = new uint256[](14);\r\n        uint256[] memory finalWinnerCount = new uint256[](8);\r\n\r\n        uint256 bonusLocation = ((finalNumber.bonus - 10) * COUNT_SLOT_SIZE) +\r\n            SUM_SLOT_SIZE;\r\n        uint256 storageValue;\r\n        // [jackpot, match6+bonus, matchFirst3+bonus, matchFirst3, matchLast3,\r\n        //  matchAny3+bonus, matchAny3, match2]\r\n\r\n        // --- COUNT MATCH JACKPOT AND MATCH 6 ---\r\n        storageValue = _numberTicketsPerLotteryId[_lotteryId][\r\n            finalNumber.match6\r\n        ];\r\n\r\n        rawWinnerCount[0] = (storageValue >> bonusLocation) & COUNT_SLOT;\r\n        rawWinnerCount[1] = (storageValue & SUM_SLOT);\r\n\r\n        finalWinnerCount[0] = rawWinnerCount[0];\r\n        finalWinnerCount[1] = rawWinnerCount[1] - rawWinnerCount[0];\r\n\r\n        // --- MATCH FIRST 3 DIGITS -------\r\n        storageValue = _numberTicketsPerLotteryId[_lotteryId][\r\n            finalNumber.matchFirst\r\n        ];\r\n\r\n        rawWinnerCount[2] = (storageValue >> bonusLocation) & COUNT_SLOT;\r\n        rawWinnerCount[3] = storageValue & SUM_SLOT;\r\n\r\n        finalWinnerCount[2] = rawWinnerCount[2];\r\n        finalWinnerCount[3] = rawWinnerCount[3];\r\n\r\n        if (finalNumber.matchFirst % 1000 == finalNumber.match6 % 1000) {\r\n            finalWinnerCount[2] -= rawWinnerCount[0];\r\n            finalWinnerCount[3] -= rawWinnerCount[1];\r\n        }\r\n        finalWinnerCount[3] -= finalWinnerCount[2];\r\n\r\n        // MATCH LAST 3\r\n        uint32[4] memory matchLast = [\r\n            finalNumber.matchLast1,\r\n            finalNumber.matchLast2,\r\n            finalNumber.matchLast3,\r\n            finalNumber.matchLast4\r\n        ];\r\n\r\n        for (uint256 i = 0; i < 4; ++i) {\r\n            rawWinnerCount[i + 4] = _numberTickets2PerLotteryId[_lotteryId][\r\n                matchLast[i]\r\n            ];\r\n            winnerCount[i] = rawWinnerCount[i + 4];\r\n            if (matchLast[i] == finalNumber.match6 / 1000) {\r\n                winnerCount[i] -= rawWinnerCount[1];\r\n            }\r\n            uint256 compareNumber = (matchLast[i] * 1000) +\r\n                (finalNumber.matchFirst - 1000);\r\n            storageValue = _numberTicketsPerLotteryId[_lotteryId][\r\n                compareNumber\r\n            ];\r\n            if (storageValue > 0 && compareNumber != finalNumber.match6) {\r\n                winnerCount[i] -= storageValue & SUM_SLOT;\r\n            }\r\n        }\r\n\r\n        finalWinnerCount[4] =\r\n            winnerCount[0] +\r\n            winnerCount[1] +\r\n            winnerCount[2] +\r\n            winnerCount[3];\r\n\r\n        // --- MATCH ANY FIRST 3 DIGITS ---\r\n        uint256[] memory matchAny = _getMatchAnyNumbers(finalNumber.matchFirst);\r\n\r\n        for (uint256 i = 0; i < matchAny.length; ++i) {\r\n            uint256 index = i * 2;\r\n            storageValue = _numberTicketsPerLotteryId[_lotteryId][\r\n                1000 + matchAny[i]\r\n            ];\r\n            if (storageValue > 0) {\r\n                rawWinnerCount[index + 8] =\r\n                    (storageValue >> bonusLocation) &\r\n                    COUNT_SLOT;\r\n                rawWinnerCount[index + 9] = storageValue & SUM_SLOT;\r\n\r\n                winnerCount[index + 4] = rawWinnerCount[index + 8];\r\n                winnerCount[index + 5] = rawWinnerCount[index + 9];\r\n\r\n                if (matchAny[i] == finalNumber.match6 % 1000) {\r\n                    winnerCount[index + 4] -= rawWinnerCount[0];\r\n                    winnerCount[index + 5] -= rawWinnerCount[1];\r\n                }\r\n\r\n                for (uint256 j = 0; j < 4; ++j) {\r\n                    if (rawWinnerCount[j + 4] > 0) {\r\n                        uint256 compareNumber = (matchLast[j] * 1000) +\r\n                            matchAny[i];\r\n                        storageValue = _numberTicketsPerLotteryId[_lotteryId][\r\n                            compareNumber\r\n                        ];\r\n                        if (compareNumber != finalNumber.match6) {\r\n                            winnerCount[index] -=\r\n                                (storageValue >> bonusLocation) &\r\n                                COUNT_SLOT;\r\n                            winnerCount[index + 1] -= storageValue & SUM_SLOT;\r\n                        }\r\n                    }\r\n                }\r\n                winnerCount[index + 5] -= winnerCount[index + 4];\r\n                finalWinnerCount[5] += winnerCount[index + 4];\r\n                finalWinnerCount[6] += winnerCount[index + 5];\r\n            }\r\n        }\r\n\r\n        // MATCH 2\r\n        for (uint256 i = 0; i < 10; ++i) {\r\n            rawWinnerCount[18] += _numberTickets2PerLotteryId[_lotteryId][\r\n                finalNumber.match2 * 10 + i\r\n            ];\r\n        }\r\n        finalWinnerCount[7] = rawWinnerCount[18];\r\n\r\n        if (finalNumber.match2 == finalNumber.match6 / 10000) {\r\n            finalWinnerCount[7] -= rawWinnerCount[1];\r\n        }\r\n\r\n        // check match 2 with match first\r\n        for (uint256 i = 0; i < 10; ++i) {\r\n            uint256 compareNumber = finalNumber.match2 * 10 + i;\r\n            uint256 storageNumber = (compareNumber * 1000) +\r\n                (finalNumber.matchFirst - 1000);\r\n            if (storageNumber != finalNumber.match6) {\r\n                storageValue = _numberTicketsPerLotteryId[_lotteryId][\r\n                    storageNumber\r\n                ];\r\n                if (storageValue > 0) {\r\n                    finalWinnerCount[7] -= storageValue & SUM_SLOT;\r\n                }\r\n            }\r\n        }\r\n\r\n        // check match 2 with match last * 4\r\n        for (uint256 i = 0; i < 4; ++i) {\r\n            if (finalNumber.match2 == (matchLast[i] / 10)) {\r\n                finalWinnerCount[7] -= winnerCount[i];\r\n            }\r\n        }\r\n\r\n        // check match 2 with match any first\r\n        for (uint256 i = 0; i < 10; ++i) {\r\n            uint256 compareNumber = finalNumber.match2 * 10 + i;\r\n            storageValue = 0;\r\n\r\n            if (\r\n                compareNumber != matchLast[0] &&\r\n                compareNumber != matchLast[1] &&\r\n                compareNumber != matchLast[2] &&\r\n                compareNumber != matchLast[3]\r\n            ) {\r\n                // check match any\r\n                for (uint256 j = 0; j < matchAny.length; ++j) {\r\n                    uint256 storageNumber = (compareNumber * 1000) +\r\n                        matchAny[j];\r\n                    if (storageNumber != finalNumber.match6) {\r\n                        storageValue = _numberTicketsPerLotteryId[_lotteryId][\r\n                            storageNumber\r\n                        ];\r\n                        if (storageValue > 0) {\r\n                            finalWinnerCount[7] -= storageValue & SUM_SLOT;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return finalWinnerCount;\r\n    }\r\n\r\n    function _viewTicketNumber(\r\n        address _user,\r\n        uint256 _lotteryId,\r\n        uint256 _id\r\n    ) private view returns (uint256) {\r\n        return\r\n            (_userTicketsPerLotteryId[_user][_lotteryId][_id / 10] >>\r\n                ((_id % 10) * 25)) & TICKET_SLOT;\r\n    }\r\n\r\n    /**\r\n     * @dev This function will use only last 3 digits of the initialNumber\r\n     */\r\n    function _getMatchAnyNumbers(\r\n        uint256 initialNumber\r\n    ) private pure returns (uint256[] memory) {\r\n        uint256[3] memory digit = [\r\n            (initialNumber / 100) % 10,\r\n            (initialNumber / 10) % 10,\r\n            initialNumber % 10\r\n        ];\r\n\r\n        uint256[] memory matchAny = new uint256[](5);\r\n        matchAny[0] = (digit[0] * 100) + (digit[2] * 10) + digit[1];\r\n        matchAny[1] = (digit[1] * 100) + (digit[0] * 10) + digit[2];\r\n        matchAny[2] = (digit[1] * 100) + (digit[2] * 10) + digit[0];\r\n        matchAny[3] = (digit[2] * 100) + (digit[0] * 10) + digit[1];\r\n        matchAny[4] = (digit[2] * 100) + (digit[1] * 10) + digit[0];\r\n\r\n        uint256 length;\r\n        bool[] memory dup = new bool[](5);\r\n\r\n        for (uint256 i = 0; i < 5; ++i) {\r\n            if (matchAny[i] == (initialNumber - 1000)) {\r\n                dup[i] = true;\r\n            } else {\r\n                for (uint256 j = 0; j < i; ++j) {\r\n                    if (matchAny[i] == matchAny[j]) {\r\n                        dup[i] = true;\r\n                    }\r\n                }\r\n            }\r\n            if (!dup[i]) {\r\n                ++length;\r\n            }\r\n        }\r\n\r\n        uint256[] memory result = new uint256[](length);\r\n        length = 0;\r\n        for (uint256 i = 0; i < 5; ++i) {\r\n            if (!dup[i]) {\r\n                result[length] = matchAny[i];\r\n                ++length;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate rewards for a given ticket\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketId: ticket id\r\n     * @param _bracket: bracket for the ticketId to verify the claim and calculate rewards\r\n     */\r\n    function _calculateRewardsForTicketId(\r\n        address _user,\r\n        uint256 _lotteryId,\r\n        uint256 _ticketId,\r\n        uint256 _bracket\r\n    ) internal view returns (uint256) {\r\n        uint256 userNumber = _viewTicketNumber(_user, _lotteryId, _ticketId);\r\n        // Apply transformation to verify the claim provided by the user is true\r\n        if (_checkRewardBracket(_lotteryId, userNumber) == _bracket) {\r\n            return _lotteries[_lotteryId].moonPerBracket[_bracket];\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function _checkRewardBracket(\r\n        uint256 _lotteryId,\r\n        uint256 _ticketNumber\r\n    ) internal view returns (uint256) {\r\n        FinalNumber memory finalNumber = _lotteries[_lotteryId].finalNumber;\r\n        bool bonusMatched = (_ticketNumber % 10 == finalNumber.bonus - 10);\r\n\r\n        // Match 6 (+ Bonus)\r\n        if (_ticketNumber / 10 == finalNumber.match6) {\r\n            return bonusMatched ? 0 : 1;\r\n        }\r\n\r\n        // Match Last 3 (+ Bonus) => 1XXX---- == 1XXX\r\n        if (((_ticketNumber / 10) % 1000) + 1000 == finalNumber.matchFirst) {\r\n            return bonusMatched ? 2 : 3;\r\n        }\r\n\r\n        // Match Last 3\r\n        uint256 matchingNumber = _ticketNumber / 10000; // 1XXX----\r\n        if (\r\n            matchingNumber == finalNumber.matchLast1 ||\r\n            matchingNumber == finalNumber.matchLast2 ||\r\n            matchingNumber == finalNumber.matchLast3 ||\r\n            matchingNumber == finalNumber.matchLast4\r\n        ) {\r\n            return 4;\r\n        }\r\n\r\n        uint256[] memory matchAny = _getMatchAnyNumbers(finalNumber.matchFirst);\r\n\r\n        // Match Any Last 3 (+ Bonus)\r\n        matchingNumber = (_ticketNumber / 10) % 1000;\r\n        for (uint256 i = 0; i < matchAny.length; ++i) {\r\n            if (matchingNumber == matchAny[i]) {\r\n                return bonusMatched ? 5 : 6;\r\n            }\r\n        }\r\n\r\n        // Match 2 => 1XX-----\r\n        if (_ticketNumber / 100000 == finalNumber.match2) {\r\n            return 7;\r\n        }\r\n\r\n        return 8; // Not Match\r\n    }\r\n\r\n    function unsafe_inc(uint256 x) private pure returns (uint256) {\r\n        unchecked {\r\n            return x + 1;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_moonTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_randomGeneratorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dealerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_daoAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"}],\"name\":\"LotteryClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"bonus\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"match6\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchFirst\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchLast1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchLast2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchLast3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchLast4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"match2\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct FinalNumber\",\"name\":\"finalNumber\",\"type\":\"tuple\"}],\"name\":\"LotteryNumberDrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceTicketInMoon\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"discountPerTicket\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"injectedAmount\",\"type\":\"uint256\"}],\"name\":\"LotteryOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"dao\",\"type\":\"uint32\"}],\"name\":\"NewDaoPercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"}],\"name\":\"NewFeePercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxNumberTickets\",\"type\":\"uint256\"}],\"name\":\"NewMaxNumberTicketsPerBuyOrClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPriceTicketInMoon\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxPriceTicketInMoon\",\"type\":\"uint256\"}],\"name\":\"NewMinAndMaxTicketPriceInMoon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"number\",\"type\":\"uint32\"}],\"name\":\"NewMinimumBulk\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"NewOperatorAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"randomGenerator\",\"type\":\"address\"}],\"name\":\"NewRandomGenerator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refferal\",\"type\":\"address\"}],\"name\":\"NewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusRate\",\"type\":\"uint256\"}],\"name\":\"NewReferralBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"brackets\",\"type\":\"uint32[]\"}],\"name\":\"NewRewardsPerBracket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberTickets\",\"type\":\"uint256\"}],\"name\":\"TicketsClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberTickets\",\"type\":\"uint256\"}],\"name\":\"TicketsPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenRecovery\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"_ticketNumbers\",\"type\":\"uint32[]\"}],\"name\":\"buyTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_randomGeneratorAddress\",\"type\":\"address\"}],\"name\":\"changeRandomGenerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketNumber\",\"type\":\"uint256\"}],\"name\":\"checkRewardBracket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_lotteryIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"_ticketIds\",\"type\":\"uint256[][]\"},{\"internalType\":\"uint32[][]\",\"name\":\"_brackets\",\"type\":\"uint32[][]\"}],\"name\":\"claimTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"}],\"name\":\"closeLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLotteryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoPercent\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dealerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"}],\"name\":\"drawFinalNumberAndMakeLotteryClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxNumberTicketsPerBuyOrClaim\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPriceTicketInMoon\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPriceTicketInMoon\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumBulk\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomGenerator\",\"outputs\":[{\"internalType\":\"contract IRandomNumberGenerator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverWrongTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralBonus\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_shareBenefit\",\"type\":\"bool\"}],\"name\":\"registReferral\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsPerBracket\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_percent\",\"type\":\"uint32\"}],\"name\":\"setDaoPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_percent\",\"type\":\"uint32\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_maxNumberTicketsPerBuy\",\"type\":\"uint128\"}],\"name\":\"setMaxNumberTicketsPerBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_minPriceTicketInMoon\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_maxPriceTicketInMoon\",\"type\":\"uint128\"}],\"name\":\"setMinAndMaxTicketPriceInMoon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_number\",\"type\":\"uint32\"}],\"name\":\"setMinimumBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"}],\"name\":\"setOperatorAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"setReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_referralBonus\",\"type\":\"uint32\"}],\"name\":\"setReferralBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_brackets\",\"type\":\"uint32[]\"}],\"name\":\"setRewardsPerBracket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceTicketInMoon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_discountPerTicket\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPrize\",\"type\":\"uint256\"}],\"name\":\"startLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewCurrentLotteryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"}],\"name\":\"viewLottery\",\"outputs\":[{\"components\":[{\"internalType\":\"enum MoonLotteryV3.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceTicketInMoon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discountPerTicket\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPrize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jackpotPrize\",\"type\":\"uint256\"},{\"internalType\":\"uint256[8]\",\"name\":\"moonPerBracket\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256[8]\",\"name\":\"winnersPerBracket\",\"type\":\"uint256[8]\"},{\"internalType\":\"uint256\",\"name\":\"feeCollectedInMoon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollectedInMoon\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"bonus\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"match6\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchFirst\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchLast1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchLast2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchLast3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"matchLast4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"match2\",\"type\":\"uint32\"}],\"internalType\":\"struct FinalNumber\",\"name\":\"finalNumber\",\"type\":\"tuple\"}],\"internalType\":\"struct MoonLotteryV3.Lottery\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewMinimumBulk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewMoonTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_bracket\",\"type\":\"uint32\"}],\"name\":\"viewRewardsForTicketId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"viewUserInfoForLotteryId\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MoonLotteryV3", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000e7493032b4986ec6f3c538fe3f63cc89a1634e40000000000000000000000000c5d1d50d9517db581de2ceb6e5d33b7750b0a04a0000000000000000000000004d1725dbe14ab81eb6d78ceba49e4c9edae51a8d0000000000000000000000007477426542aa5b8e5a0528f5e4680a1ca20c67d50000000000000000000000004783a28a29a2597589ed8154542e20cb2b5f50600000000000000000000000004c00e75a710e92ea915a865379b07cadf3e6c45e000000000000000000000000191ab030081ef9af7781063a7602f4e026eeaa32", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://28b4eea3a60088c8b7153b79bdbc650c951f1c9ad42ae17ff7eed831fccf2df8"}