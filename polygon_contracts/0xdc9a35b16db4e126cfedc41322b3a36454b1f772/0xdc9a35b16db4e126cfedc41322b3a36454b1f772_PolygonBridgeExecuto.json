{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PolygonBridgeExecutor.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport './interfaces/IFxMessageProcessor.sol';\\nimport './BridgeExecutorBase.sol';\\n\\ncontract PolygonBridgeExecutor is BridgeExecutorBase, IFxMessageProcessor {\\n  address private _fxRootSender;\\n  address private _fxChild;\\n\\n  event FxRootSenderUpdate(address previousFxRootSender, address newFxRootSender);\\n  event FxChildUpdate(address previousFxChild, address newFxChild);\\n\\n  modifier onlyFxChild() {\\n    require(msg.sender == _fxChild, 'UNAUTHORIZED_CHILD_ORIGIN');\\n    _;\\n  }\\n\\n  constructor(\\n    address fxRootSender,\\n    address fxChild,\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay,\\n    address guardian\\n  ) BridgeExecutorBase(delay, gracePeriod, minimumDelay, maximumDelay, guardian) {\\n    _fxRootSender = fxRootSender;\\n    _fxChild = fxChild;\\n  }\\n\\n  /// @inheritdoc IFxMessageProcessor\\n  function processMessageFromRoot(\\n    uint256 stateId,\\n    address rootMessageSender,\\n    bytes calldata data\\n  ) external override onlyFxChild {\\n    require(rootMessageSender == _fxRootSender, 'UNAUTHORIZED_ROOT_ORIGIN');\\n\\n    address[] memory targets;\\n    uint256[] memory values;\\n    string[] memory signatures;\\n    bytes[] memory calldatas;\\n    bool[] memory withDelegatecalls;\\n\\n    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(\\n      data,\\n      (address[], uint256[], string[], bytes[], bool[])\\n    );\\n\\n    _queue(targets, values, signatures, calldatas, withDelegatecalls);\\n  }\\n\\n  /**\\n   * @dev Update the expected address of contract originating a cross-chain tranasaction\\n   * @param fxRootSender contract originating a cross-chain tranasaction - likely the aave governance executor\\n   **/\\n  function updateFxRootSender(address fxRootSender) external onlyThis {\\n    emit FxRootSenderUpdate(_fxRootSender, fxRootSender);\\n    _fxRootSender = fxRootSender;\\n  }\\n\\n  /**\\n   * @dev Update the address of the FxChild contract\\n   * @param fxChild the address of the contract used to foward cross-chain transactions on Polygon\\n   **/\\n  function updateFxChild(address fxChild) external onlyThis {\\n    emit FxChildUpdate(_fxChild, fxChild);\\n    _fxChild = fxChild;\\n  }\\n\\n  /**\\n   * @dev Get the address currently stored as fxRootSender\\n   * @return fxRootSender contract originating a cross-chain tranasaction - likely the aave governance executor\\n   **/\\n  function getFxRootSender() external view returns (address) {\\n    return _fxRootSender;\\n  }\\n\\n  /**\\n   * @dev Get the address currently stored as fxChild\\n   * @return fxChild the address of the contract used to foward cross-chain transactions on Polygon\\n   **/\\n  function getFxChild() external view returns (address) {\\n    return _fxChild;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFxMessageProcessor.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.5;\\n\\ninterface IFxMessageProcessor {\\n  /**\\n   * @dev Process the cross-chain message from an FxChild contract through the ETH/Polygon StateSender\\n   * @param stateId Id of the cross-chain message created in the ETH/Polygon StateSender\\n   * @param rootMessageSender address that initally sent this message on ethereum\\n   * @param data the data from the abi-encoded cross-chain message\\n   **/\\n  function processMessageFromRoot(\\n    uint256 stateId,\\n    address rootMessageSender,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/BridgeExecutorBase.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\nimport './dependencies/utilities/SafeMath.sol';\\nimport './interfaces/IBridgeExecutor.sol';\\n\\nabstract contract BridgeExecutorBase is IBridgeExecutor {\\n  using SafeMath for uint256;\\n\\n  uint256 private _delay;\\n  uint256 private _gracePeriod;\\n  uint256 private _minimumDelay;\\n  uint256 private _maximumDelay;\\n  address private _guardian;\\n  uint256 private _actionsSetCounter;\\n\\n  mapping(uint256 => ActionsSet) private _actionsSets;\\n  mapping(bytes32 => bool) private _queuedActions;\\n\\n  modifier onlyGuardian() {\\n    require(msg.sender == _guardian, 'ONLY_BY_GUARDIAN');\\n    _;\\n  }\\n\\n  modifier onlyThis() {\\n    require(msg.sender == address(this), 'UNAUTHORIZED_ORIGIN_ONLY_THIS');\\n    _;\\n  }\\n\\n  constructor(\\n    uint256 delay,\\n    uint256 gracePeriod,\\n    uint256 minimumDelay,\\n    uint256 maximumDelay,\\n    address guardian\\n  ) {\\n    require(delay >= minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\\n    _delay = delay;\\n    _gracePeriod = gracePeriod;\\n    _minimumDelay = minimumDelay;\\n    _maximumDelay = maximumDelay;\\n    _guardian = guardian;\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function execute(uint256 actionsSetId) external payable override {\\n    require(getCurrentState(actionsSetId) == ActionsSetState.Queued, 'ONLY_QUEUED_ACTIONS');\\n\\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\\n    require(block.timestamp >= actionsSet.executionTime, 'TIMELOCK_NOT_FINISHED');\\n\\n    actionsSet.executed = true;\\n    uint256 actionCount = actionsSet.targets.length;\\n\\n    bytes[] memory returnedData = new bytes[](actionCount);\\n    for (uint256 i = 0; i < actionCount; i++) {\\n      returnedData[i] = _executeTransaction(\\n        actionsSet.targets[i],\\n        actionsSet.values[i],\\n        actionsSet.signatures[i],\\n        actionsSet.calldatas[i],\\n        actionsSet.executionTime,\\n        actionsSet.withDelegatecalls[i]\\n      );\\n    }\\n    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function cancel(uint256 actionsSetId) external override onlyGuardian {\\n    ActionsSetState state = getCurrentState(actionsSetId);\\n    require(state == ActionsSetState.Queued, 'ONLY_BEFORE_EXECUTED');\\n\\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\\n    actionsSet.canceled = true;\\n    for (uint256 i = 0; i < actionsSet.targets.length; i++) {\\n      _cancelTransaction(\\n        actionsSet.targets[i],\\n        actionsSet.values[i],\\n        actionsSet.signatures[i],\\n        actionsSet.calldatas[i],\\n        actionsSet.executionTime,\\n        actionsSet.withDelegatecalls[i]\\n      );\\n    }\\n\\n    emit ActionsSetCanceled(actionsSetId);\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function getActionsSetById(uint256 actionsSetId)\\n    external\\n    view\\n    override\\n    returns (ActionsSet memory)\\n  {\\n    return _actionsSets[actionsSetId];\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {\\n    require(_actionsSetCounter >= actionsSetId, 'INVALID_ACTION_ID');\\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\\n    if (actionsSet.canceled) {\\n      return ActionsSetState.Canceled;\\n    } else if (actionsSet.executed) {\\n      return ActionsSetState.Executed;\\n    } else if (block.timestamp > actionsSet.executionTime.add(_gracePeriod)) {\\n      return ActionsSetState.Expired;\\n    } else {\\n      return ActionsSetState.Queued;\\n    }\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function isActionQueued(bytes32 actionHash) public view override returns (bool) {\\n    return _queuedActions[actionHash];\\n  }\\n\\n  function receiveFunds() external payable {}\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function updateGuardian(address guardian) external override onlyThis {\\n    emit GuardianUpdate(_guardian, guardian);\\n    _guardian = guardian;\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function updateDelay(uint256 delay) external override onlyThis {\\n    _validateDelay(delay);\\n    emit DelayUpdate(_delay, delay);\\n    _delay = delay;\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function updateGracePeriod(uint256 gracePeriod) external override onlyThis {\\n    emit GracePeriodUpdate(_gracePeriod, gracePeriod);\\n    _gracePeriod = gracePeriod;\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function updateMinimumDelay(uint256 minimumDelay) external override onlyThis {\\n    uint256 previousMinimumDelay = _minimumDelay;\\n    _minimumDelay = minimumDelay;\\n    _validateDelay(_delay);\\n    emit MinimumDelayUpdate(previousMinimumDelay, minimumDelay);\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function updateMaximumDelay(uint256 maximumDelay) external override onlyThis {\\n    uint256 previousMaximumDelay = _maximumDelay;\\n    _maximumDelay = maximumDelay;\\n    _validateDelay(_delay);\\n    emit MaximumDelayUpdate(previousMaximumDelay, maximumDelay);\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function getDelay() external view override returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function getGracePeriod() external view override returns (uint256) {\\n    return _gracePeriod;\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function getMinimumDelay() external view override returns (uint256) {\\n    return _minimumDelay;\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function getMaximumDelay() external view override returns (uint256) {\\n    return _maximumDelay;\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function getGuardian() external view override returns (address) {\\n    return _guardian;\\n  }\\n\\n  /// @inheritdoc IBridgeExecutor\\n  function getActionsSetCount() external view override returns (uint256) {\\n    return _actionsSetCounter;\\n  }\\n\\n  /**\\n   * @dev target.delegatecall cannot be provided a value directly and is sent\\n   * with the entire available msg.value. In this instance, we only want each proposed action\\n   * to execute with exactly the value defined in the proposal. By splitting executeDelegateCall\\n   * into a seperate function, it can be called from this contract with a defined amout of value,\\n   * reducing the risk that a delegatecall is executed with more value than intended\\n   * @return success - boolean indicating it the delegate call was successfull\\n   * @return resultdata - bytes returned by the delegate call\\n   **/\\n  function executeDelegateCall(address target, bytes calldata data)\\n    external\\n    payable\\n    onlyThis\\n    returns (bool, bytes memory)\\n  {\\n    bool success;\\n    bytes memory resultData;\\n    // solium-disable-next-line security/no-call-value\\n    (success, resultData) = target.delegatecall(data);\\n    return (success, resultData);\\n  }\\n\\n  /**\\n   * @dev Queue the ActionsSet - only callable by the BridgeMessageProvessor\\n   * @param targets list of contracts called by each action's associated transaction\\n   * @param values list of value in wei for each action's  associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n   **/\\n  function _queue(\\n    address[] memory targets,\\n    uint256[] memory values,\\n    string[] memory signatures,\\n    bytes[] memory calldatas,\\n    bool[] memory withDelegatecalls\\n  ) internal {\\n    require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\\n    require(\\n      targets.length == values.length &&\\n        targets.length == signatures.length &&\\n        targets.length == calldatas.length &&\\n        targets.length == withDelegatecalls.length,\\n      'INCONSISTENT_PARAMS_LENGTH'\\n    );\\n\\n    uint256 actionsSetId = _actionsSetCounter;\\n    uint256 executionTime = block.timestamp.add(_delay);\\n    _actionsSetCounter++;\\n\\n    for (uint256 i = 0; i < targets.length; i++) {\\n      bytes32 actionHash =\\n        keccak256(\\n          abi.encode(\\n            targets[i],\\n            values[i],\\n            signatures[i],\\n            calldatas[i],\\n            executionTime,\\n            withDelegatecalls[i]\\n          )\\n        );\\n      require(!isActionQueued(actionHash), 'DUPLICATED_ACTION');\\n      _queuedActions[actionHash] = true;\\n    }\\n\\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\\n    actionsSet.targets = targets;\\n    actionsSet.values = values;\\n    actionsSet.signatures = signatures;\\n    actionsSet.calldatas = calldatas;\\n    actionsSet.withDelegatecalls = withDelegatecalls;\\n    actionsSet.executionTime = executionTime;\\n\\n    emit ActionsSetQueued(\\n      actionsSetId,\\n      targets,\\n      values,\\n      signatures,\\n      calldatas,\\n      withDelegatecalls,\\n      executionTime\\n    );\\n  }\\n\\n  function _executeTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, 'NOT_ENOUGH_CONTRACT_BALANCE');\\n\\n    bytes32 actionHash =\\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\\n    _queuedActions[actionHash] = false;\\n\\n    bytes memory callData;\\n    if (bytes(signature).length == 0) {\\n      callData = data;\\n    } else {\\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n    }\\n\\n    bool success;\\n    bytes memory resultData;\\n    if (withDelegatecall) {\\n      (success, resultData) = this.executeDelegateCall{value: value}(target, callData);\\n    } else {\\n      // solium-disable-next-line security/no-call-value\\n      (success, resultData) = target.call{value: value}(callData);\\n    }\\n    return _verifyCallResult(success, resultData);\\n  }\\n\\n  function _cancelTransaction(\\n    address target,\\n    uint256 value,\\n    string memory signature,\\n    bytes memory data,\\n    uint256 executionTime,\\n    bool withDelegatecall\\n  ) internal {\\n    bytes32 actionHash =\\n      keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall));\\n    _queuedActions[actionHash] = false;\\n  }\\n\\n  function _validateDelay(uint256 delay) internal view {\\n    require(delay >= _minimumDelay, 'DELAY_SHORTER_THAN_MINIMUM');\\n    require(delay <= _maximumDelay, 'DELAY_LONGER_THAN_MAXIMUM');\\n  }\\n\\n  function _verifyCallResult(bool success, bytes memory returndata)\\n    private\\n    pure\\n    returns (bytes memory)\\n  {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert('FAILED_ACTION_EXECUTION');\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/utilities/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBridgeExecutor.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.7.5;\\npragma abicoder v2;\\n\\ninterface IBridgeExecutor {\\n  enum ActionsSetState {Queued, Executed, Canceled, Expired}\\n\\n  struct ActionsSet {\\n    address[] targets;\\n    uint256[] values;\\n    string[] signatures;\\n    bytes[] calldatas;\\n    bool[] withDelegatecalls;\\n    uint256 executionTime;\\n    bool executed;\\n    bool canceled;\\n  }\\n\\n  /**\\n   * @dev emitted when an ActionsSet is received from the bridge message processor and queued\\n   * @param id Id of the ActionsSet\\n   * @param targets list of contracts called by each action's associated transaction\\n   * @param values list of value in wei for each action's  associated transaction\\n   * @param signatures list of function signatures (can be empty) to be used when created the callData\\n   * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n   * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n   * @param executionTime the time these actions can be executed\\n   **/\\n  event ActionsSetQueued(\\n    uint256 id,\\n    address[] targets,\\n    uint256[] values,\\n    string[] signatures,\\n    bytes[] calldatas,\\n    bool[] withDelegatecalls,\\n    uint256 executionTime\\n  );\\n\\n  /**\\n   * @dev emitted when an ActionsSet is executed successfully\\n   * @param id Id of the ActionsSet\\n   * @param initiatorExecution address that triggered the ActionsSet execution\\n   * @param returnedData address that triggered the ActionsSet execution\\n   **/\\n  event ActionsSetExecuted(uint256 id, address indexed initiatorExecution, bytes[] returnedData);\\n\\n  /**\\n   * @dev emitted when an ActionsSet is cancelled by the guardian\\n   * @param id Id of the ActionsSet\\n   **/\\n  event ActionsSetCanceled(uint256 id);\\n\\n  /**\\n   * @dev emitted when a new bridge is set\\n   * @param bridge address of the new admin\\n   * @param initiatorChange address of the creator of this change\\n   **/\\n  event NewBridge(address bridge, address indexed initiatorChange);\\n\\n  /**\\n   * @dev emitted when a new admin is set\\n   * @param newAdmin address of the new admin\\n   **/\\n  event NewAdmin(address newAdmin);\\n\\n  /**\\n   * @dev emitted when a new guardian is set\\n   * @param previousGuardian previous guardian\\n   * @param newGuardian new guardian\\n   **/\\n  event GuardianUpdate(address previousGuardian, address newGuardian);\\n\\n  /**\\n   * @dev emitted when a new delay (between queueing and execution) is set\\n   * @param previousDelay previous delay\\n   * @param newDelay new delay\\n   **/\\n  event DelayUpdate(uint256 previousDelay, uint256 newDelay);\\n\\n  /**\\n   * @dev emitted when a GracePeriod is updated\\n   * @param previousGracePeriod previous grace period\\n   * @param newGracePeriod new grace period\\n   **/\\n  event GracePeriodUpdate(uint256 previousGracePeriod, uint256 newGracePeriod);\\n\\n  /**\\n   * @dev emitted when a Minimum Delay is updated\\n   * @param previousMinimumDelay previous minimum delay\\n   * @param newMinimumDelay new minimum delay\\n   **/\\n  event MinimumDelayUpdate(uint256 previousMinimumDelay, uint256 newMinimumDelay);\\n\\n  /**\\n   * @dev emitted when a Maximum Delay is updated\\n   * @param previousMaximumDelay previous maximum delay\\n   * @param newMaximumDelay new maximum delay\\n   **/\\n  event MaximumDelayUpdate(uint256 previousMaximumDelay, uint256 newMaximumDelay);\\n\\n  /**\\n   * @dev Execute the ActionsSet\\n   * @param actionsSetId id of the ActionsSet to execute\\n   **/\\n  function execute(uint256 actionsSetId) external payable;\\n\\n  /**\\n   * @dev Cancel the ActionsSet\\n   * @param actionsSetId id of the ActionsSet to cancel\\n   **/\\n  function cancel(uint256 actionsSetId) external;\\n\\n  /**\\n   * @dev Get the ActionsSet by Id\\n   * @param actionsSetId id of the ActionsSet\\n   * @return the ActionsSet requested\\n   **/\\n  function getActionsSetById(uint256 actionsSetId) external view returns (ActionsSet memory);\\n\\n  /**\\n   * @dev Get the current state of an ActionsSet\\n   * @param actionsSetId id of the ActionsSet\\n   * @return The current state if the ActionsSet\\n   **/\\n  function getCurrentState(uint256 actionsSetId) external view returns (ActionsSetState);\\n\\n  /**\\n   * @dev Returns whether an action (via actionHash) is queued\\n   * @param actionHash hash of the action to be checked\\n   * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n   * @return true if underlying action of actionHash is queued\\n   **/\\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\\n\\n  /**\\n   * @dev Update guardian\\n   * @param guardian address of the new guardian\\n   **/\\n  function updateGuardian(address guardian) external;\\n\\n  /**\\n   * @dev Update the delay\\n   * @param delay delay between queue and execution of an ActionSet\\n   **/\\n  function updateDelay(uint256 delay) external;\\n\\n  /**\\n   * @dev Set the grace period - time before a queued action will expire\\n   * @param gracePeriod The gracePeriod in seconds\\n   **/\\n  function updateGracePeriod(uint256 gracePeriod) external;\\n\\n  /**\\n   * @dev Set the minimum allowed delay between queing and exection\\n   * @param minimumDelay The minimum delay in seconds\\n   **/\\n  function updateMinimumDelay(uint256 minimumDelay) external;\\n\\n  /**\\n   * @dev Set the maximum allowed delay between queing and exection\\n   * @param maximumDelay The maximum delay in seconds\\n   **/\\n  function updateMaximumDelay(uint256 maximumDelay) external;\\n\\n  /**\\n   * @dev Getter of the delay between queuing and execution\\n   * @return The delay in seconds\\n   **/\\n  function getDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of grace period constant\\n   * @return grace period in seconds\\n   **/\\n  function getGracePeriod() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of minimum delay constant\\n   * @return minimum delay in seconds\\n   **/\\n  function getMinimumDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Getter of maximum delay constant\\n   * @return maximum delay in seconds\\n   **/\\n  function getMaximumDelay() external view returns (uint256);\\n\\n  /**\\n   * @dev Get guardian address\\n   * @return guardian address\\n   **/\\n  function getGuardian() external view returns (address);\\n\\n  /**\\n   * @dev Get ActionSet count\\n   * @return current count of action sets processed\\n   **/\\n  function getActionsSetCount() external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fxRootSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fxChild\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gracePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumDelay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ActionsSetCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiatorExecution\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"returnedData\",\"type\":\"bytes[]\"}],\"name\":\"ActionsSetExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"}],\"name\":\"ActionsSetQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDelay\",\"type\":\"uint256\"}],\"name\":\"DelayUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousFxChild\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFxChild\",\"type\":\"address\"}],\"name\":\"FxChildUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousFxRootSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFxRootSender\",\"type\":\"address\"}],\"name\":\"FxRootSenderUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousGracePeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newGracePeriod\",\"type\":\"uint256\"}],\"name\":\"GracePeriodUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousGuardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"GuardianUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousMaximumDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaximumDelay\",\"type\":\"uint256\"}],\"name\":\"MaximumDelayUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousMinimumDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinimumDelay\",\"type\":\"uint256\"}],\"name\":\"MinimumDelayUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiatorChange\",\"type\":\"address\"}],\"name\":\"NewBridge\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actionsSetId\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actionsSetId\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeDelegateCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actionsSetId\",\"type\":\"uint256\"}],\"name\":\"getActionsSetById\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"signatures\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"},{\"internalType\":\"bool[]\",\"name\":\"withDelegatecalls\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canceled\",\"type\":\"bool\"}],\"internalType\":\"struct IBridgeExecutor.ActionsSet\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActionsSetCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actionsSetId\",\"type\":\"uint256\"}],\"name\":\"getCurrentState\",\"outputs\":[{\"internalType\":\"enum IBridgeExecutor.ActionsSetState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFxChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFxRootSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGracePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"actionHash\",\"type\":\"bytes32\"}],\"name\":\"isActionQueued\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stateId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rootMessageSender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"processMessageFromRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"updateDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fxChild\",\"type\":\"address\"}],\"name\":\"updateFxChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fxRootSender\",\"type\":\"address\"}],\"name\":\"updateFxRootSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gracePeriod\",\"type\":\"uint256\"}],\"name\":\"updateGracePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"updateGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maximumDelay\",\"type\":\"uint256\"}],\"name\":\"updateMaximumDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumDelay\",\"type\":\"uint256\"}],\"name\":\"updateMinimumDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PolygonBridgeExecutor", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ee56e2b3d491590b5b31738cc34d5232f378a8d50000000000000000000000008397259c983751daf40400790063935a11afa28a000000000000000000000000000000000000000000000000000000000002a300000000000000000000000000000000000000000000000000000000000003f48000000000000000000000000000000000000000000000000000000000000070800000000000000000000000000000000000000000000000000000000000093a800000000000000000000000001450f2898d6ba2710c98be9caf3041330ed5ae58", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}