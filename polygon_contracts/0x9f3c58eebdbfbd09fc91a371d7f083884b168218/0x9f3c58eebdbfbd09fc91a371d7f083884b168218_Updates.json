{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/storage/Updates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// License details specified at address returned by calling the function: license()\\npragma solidity =0.8.11;\\n\\n/**\\n @title Manages Updates of Multiverse properties and Ownership\\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\nimport \\\"../interfaces/IWriter.sol\\\";\\nimport \\\"../interfaces/IStorageGetters.sol\\\";\\nimport \\\"../interfaces/IInfo.sol\\\";\\nimport \\\"../interfaces/IUpdates.sol\\\";\\nimport \\\"../interfaces/IStakers.sol\\\";\\n\\nimport \\\"../pure/Messages.sol\\\";\\nimport \\\"../pure/MerkleSerialized.sol\\\";\\n\\ncontract Updates is IUpdates, Messages, MerkleSerialized {\\n    /// @inheritdoc IUpdates\\n    address public immutable _sto;\\n\\n    /// @inheritdoc IUpdates\\n    address public immutable _writer;\\n\\n    /// @inheritdoc IUpdates\\n    address public immutable _info;\\n\\n    /// @inheritdoc IUpdates\\n    uint32 constant public OWNERSHIP_TXFORMAT_VERSION = 1;\\n\\n    // temporary variable used to maintain signature \\n    // of functions being deprecated\\n    bool _dummy;\\n\\n    modifier onlyUniversesRelayer() {\\n        require(\\n            msg.sender == IStorageGetters(_sto).universesRelayer(),\\n            \\\"Only relay of universes is authorized.\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyTXRelayer() {\\n        require(\\n            msg.sender == IStorageGetters(_sto).txRelayer(),\\n            \\\"Only relay of TXs is authorized.\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlySuperUser() {\\n        require(\\n            msg.sender == IStorageGetters(_sto).superUser(),\\n            \\\"Only superUser is authorized.\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address storageAddress,\\n        address writer,\\n        address info\\n    ) {\\n        IInfo(info).assertValidStorageExtension();\\n        _sto = storageAddress;\\n        _writer = writer;\\n        _info = info;\\n        emit OwnershipTxFormatVersion(OWNERSHIP_TXFORMAT_VERSION);\\n    }\\n\\n    /// @inheritdoc IUpdates\\n    function license() external view returns (string memory) {\\n        return IStorageGetters(_sto).license();\\n    }\\n\\n    /**\\n     * @notice Sets a new Universe root\\n     * @param universeIdx the idx of the Universe\\n     * @param newRoot the new root of the Universe\\n     * @param prevTransRoot the previous root of the Universe\\n     * @param signature the signature of the authorized relayer\\n     * @param ipfsCid the IPFS address where data can be fetched\\n     */\\n    function setNewUniverseRoot(\\n        uint256 universeIdx,\\n        bytes32 newRoot,\\n        bytes32 prevTransRoot,\\n        bytes calldata signature,\\n        string calldata ipfsCid\\n    ) public onlyUniversesRelayer {\\n        require(\\n            !IStorageGetters(_sto).universeIsClosed(universeIdx),\\n            \\\"setNewUniverseRoot: universe already closed\\\"\\n        );\\n        require(\\n            prevTransRoot ==\\n                IStorageGetters(_sto).universeRootCurrent(universeIdx),\\n            \\\"prevTransRoot does not match\\\"\\n        );\\n        // If relayer is not authorized, check universe owner signature\\n        if (!IStorageGetters(_sto).universeAuthorizesRelay(universeIdx)) {\\n            bytes32 msgHash = prefixed(\\n                keccak256(abi.encode(newRoot, prevTransRoot))\\n            );\\n            require(\\n                IStorageGetters(_sto).universeOwner(universeIdx) ==\\n                    recoverAddrFromBytes(msgHash, signature),\\n                \\\"universe root update signature not correct\\\"\\n            );\\n        }\\n        uint256 newVerse = IWriter(_writer).addUniverseRoot(\\n            universeIdx,\\n            newRoot,\\n            block.timestamp\\n        );\\n        emit NewUniverseRoot(universeIdx, newRoot, newVerse, ipfsCid);\\n    }\\n\\n    /**\\n     * @notice Sets a new Universe root at verse\\n     * @param verse the next universe Verse\\n     * @param universeIdx the idx of the Universe\\n     * @param newRoot the new root of the Universe\\n     * @param prevTransRoot the previous root of the Universe\\n     * @param signature the signature of the authorized relayer\\n     * @param ipfsCid the IPFS address where data can be fetched\\n     */\\n    function submitNewUniverseRoot(\\n        uint256 verse,\\n        uint256 universeIdx,\\n        bytes32 newRoot,\\n        bytes32 prevTransRoot,\\n        bytes calldata signature,\\n        string calldata ipfsCid\\n    ) external onlyUniversesRelayer {\\n        require(\\n            !IStorageGetters(_sto).universeIsClosed(universeIdx),\\n            \\\"setNewUniverseRoot: universe already closed\\\"\\n        );\\n        require(\\n            prevTransRoot ==\\n                IStorageGetters(_sto).universeRootCurrent(universeIdx),\\n            \\\"prevTransRoot does not match\\\"\\n        );\\n        require(\\n            IInfo(_info).isReadyForUniverseRootSubmission(universeIdx),\\n            \\\"not ready for universe root submission: verse not settled\\\"\\n        );\\n        // If relayer is not authorized, check universe owner signature\\n        if (!IStorageGetters(_sto).universeAuthorizesRelay(universeIdx)) {\\n            bytes32 msgHash = prefixed(\\n                keccak256(abi.encode(newRoot, prevTransRoot))\\n            );\\n            require(\\n                IStorageGetters(_sto).universeOwner(universeIdx) ==\\n                    recoverAddrFromBytes(msgHash, signature),\\n                \\\"universe root update signature not correct\\\"\\n            );\\n        }\\n        uint256 newVerse = IWriter(_writer).addUniverseRoot(\\n            universeIdx,\\n            newRoot,\\n            block.timestamp\\n        );\\n        require(verse == newVerse, \\\"error: incorrect universe verse\\\");\\n        emit NewUniverseRoot(universeIdx, newRoot, newVerse, ipfsCid);\\n    }\\n\\n    /**\\n     * @notice Submission of new TXs batch\\n     * @param verse The verse that will open for the L2 nodes to process\\n     * @param txRoot The root summarizing the TX batch\\n     * @param nTXs The number of TXs included in the batch\\n     * @param txFormatVersion The version of the txFormat used\\n     * @param ipfsCid The IPFS address where the raw data can be obtained\\n     */\\n    function submitNewTXsRoot(\\n        uint256 verse,\\n        bytes32 txRoot,\\n        uint256 nTXs,\\n        uint32 txFormatVersion,\\n        string calldata ipfsCid\\n    ) external onlyTXRelayer {\\n        require(\\n            txFormatVersion == OWNERSHIP_TXFORMAT_VERSION,\\n            \\\"Updates::submitNewTXsRoot: incorrect txFormatVersion\\\"\\n        );\\n        require(\\n            IStorageGetters(_sto).txRootsCurrentVerse() + 1 == verse,\\n            \\\"error: submitNewTXsRoot for an incorrect verse\\\"\\n        );\\n        (bool isReady, uint8 actualLevel) = IInfo(_info)\\n            .isReadyForTXSubmission();\\n        require(\\n            isReady,\\n            \\\"not ready to accept new TX submission, verse not settled\\\"\\n        );\\n        require(\\n            (actualLevel == 1) || (actualLevel == 2),\\n            \\\"past verse ended up settling in incorrect level\\\"\\n        );\\n        if (nTXs == 0) {\\n            require(\\n                txRoot == bytes32(0),\\n                \\\"in a verse with no TXs, the TXRoot must be null\\\"\\n            );\\n        }\\n        // stores txRoot, timestamp, and (implicitly) increments verse (which equals the length of _txBatches):\\n        uint8 levelsPerChallenge = IStorageGetters(_sto)\\n            .nLevelsPerChallengeNextVerses();\\n        uint8 levelVeriableByBC = computeLevelVerifiableOnChain(\\n            nTXs,\\n            2**uint256(levelsPerChallenge)\\n        );\\n        uint256 txVerse = IWriter(_writer).addTXRoot(\\n            txRoot,\\n            block.timestamp,\\n            nTXs,\\n            actualLevel,\\n            levelVeriableByBC\\n        );\\n        if (txVerse > 1) {\\n            IWriter(_writer).finalize();\\n        }\\n        emit NewTXsRoot(txRoot, nTXs, levelsPerChallenge, txVerse, ipfsCid);\\n    }\\n\\n    /// @inheritdoc IUpdates\\n    function submitNewOwnershipRoot(uint256 verse, bytes32 ownershipRoot, uint32 txFormatVersion)\\n        external\\n    {\\n        require(\\n            txFormatVersion == OWNERSHIP_TXFORMAT_VERSION,\\n            \\\"Updates::submitNewOwnershipRoot: incorrect txFormatVersion\\\"\\n        );\\n        require(\\n            IStorageGetters(_sto).txRootsCurrentVerse() == verse,\\n            \\\"error: submitNewOwnershipRoot for an incorrect verse\\\"\\n        );\\n        // call for governance is two different roots are received during challenge period: \\n        if (\\n            IInfo(_info).isReadyForChallenge() && \\n            (ownershipRoot != IStorageGetters(_sto).challengesOwnershipRoot(0))\\n        ) {\\n            IWriter(_writer).activateGovernance();\\n            emit OwnershipRootMismatch(verse, ownershipRoot);\\n            return;\\n        }\\n        require(\\n            isReadyForOwnershipSubmission(),\\n            \\\"not ready for ownership submission: verse not settled or new TXs not submitted yet\\\"\\n        );\\n        uint256 ownVerse = IWriter(_writer).addOwnershipRoot(ownershipRoot, block.timestamp);\\n        IWriter(_writer).addChallenge(0, msg.sender); // this guarantees that only a staker could have done this submission\\n        emit NewOwnershipRoot(ownershipRoot, ownVerse);\\n    }\\n\\n    /**\\n     * @notice After governance action, it bypasses the current verse\\n     *  by not processing any of the submitted TXs, and duplicating the\\n     *  ownership root settled from the previous verse.\\n     * @dev Requires that the system is in awaitingGovernance, and if\\n     *  challenge time has passed, it moves the system to isReadyForSubmitTXs\\n     * @param verse - the current verse; the provision of this param is required\\n     *  to avoid replay attacks.\\n     */\\n    function bypassCurrentVerse(uint256 verse) external onlySuperUser\\n    {\\n        require(\\n            IStorageExtension(_info).isAwaitingGovernance(),\\n            \\\"Updates::bypassCurrentVerse: system not awaiting for Governance\\\"\\n        );\\n        require(\\n            IStorageGetters(_sto).txRootsCurrentVerse() == verse,\\n            \\\"Updates::bypassCurrentVerse: incorrect provided verse\\\"\\n        );\\n        bytes32 ownershipRootPrevVerse = IStorageGetters(_sto).ownershipRootAtVerse(verse - 1);\\n        IWriter(_writer).setProposedOwnershipToPrevVerse(ownershipRootPrevVerse);\\n        IWriter(_writer).storeBypassedVerse(verse);\\n        IWriter(_writer).deactivateGovernance();\\n        emit BypassVerse(verse);\\n    }\\n\\n    /**\\n     * @notice Bypasses the current universe verse by setting the root of the previous verse as root of the current verse \\n     * and adding universe verses in corresponding claim\\n     * @dev Requires that the system is in awaitingGovernance\\n     * @param verse - universe verse that is bypassed\\n     * @param universeIdx - universe index\\n     */\\n    function bypassCurrentUniverseVerse(\\n        uint256 universeIdx,\\n        uint256 verse\\n    ) external onlySuperUser {\\n        require(\\n            IStorageExtension(_info).isAwaitingGovernance(),\\n            \\\"Updates::bypassCurrentUniverseVerse: system not awaiting for Governance\\\"\\n        );\\n        require(\\n            IStorageGetters(_sto).universeVerse(universeIdx) == verse,\\n            \\\"Updates::bypassCurrentUniverseVerse: incorrect provided verse\\\"\\n        );\\n        bytes32 universeRootPrevVerse = IStorageGetters(_sto)\\n            .universeRootAtVerse(universeIdx, verse - 1);\\n        uint256 universeRootPrevTimestamp = IStorageGetters(_sto)\\n            .universeRootSubmissionTimeAtVerse(universeIdx, verse - 1);\\n        IWriter(_writer).popUniverseRoot(universeIdx);\\n        IWriter(_writer).addUniverseRoot(\\n            universeIdx,\\n            universeRootPrevVerse,\\n            universeRootPrevTimestamp\\n        );\\n        IWriter(_writer).storeBypassedUniverseVerse(universeIdx, verse);\\n        IWriter(_writer).deactivateGovernance();\\n        emit BypassUniverseVerse(universeIdx, verse);\\n    }\\n\\n    /**\\n     * @notice After reception of a NewTXs transaction, the data happens\\n     *  not to be available in IPFS, making new ownership computation impossible\\n     * @dev Requires that the system is in awaiting ownershipRoot, and moves the\\n    *   system to awaitingGovernance.\\n     * @param verse - the current verse; the provision of this param is required\\n     *  to avoid replay attacks.\\n     */\\n    function unavailableTXData(uint256 verse) external onlySuperUser\\n    {\\n        uint256 timeToFetchFromIPFS = IStorageGetters(_sto).verseInterval();\\n        address dummyStaker = address(0);\\n        _moveToGovernanceFromWrongTXsPublished(verse, timeToFetchFromIPFS, dummyStaker);\\n    }\\n\\n    /// @inheritdoc IUpdates\\n    function wrongTXDataRoot(uint256 verse) external\\n    {\\n        _moveToGovernanceFromWrongTXsPublished(verse, 0, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Implements transitions from awatiting ownershipRoot to Governance\\n     */\\n    function _moveToGovernanceFromWrongTXsPublished(\\n        uint256 verse,\\n        uint256 timeToFetchFromIPFS,\\n        address staker\\n    ) private {\\n        require(\\n            IInfo(_info).isReadyForOwnershipSubmission(),\\n            \\\"Updates::_moveToGovernanceFromWrongTXsPublished: system not awaiting for ownership submission\\\"\\n        );\\n        require(\\n            IStorageGetters(_sto).txRootsCurrentVerse() == verse,\\n            \\\"Updates::_moveToGovernanceFromWrongTXsPublished: incorrect provided verse\\\"\\n        );\\n        uint256 txSubmissionTime = IStorageGetters(_sto).txSubmissionTimeCurrent();\\n        require(\\n            block.timestamp > (txSubmissionTime + timeToFetchFromIPFS),\\n            \\\"Updates::_moveToGovernanceFromWrongTXsPublished: not enough time passed to claim TXData issues\\\"\\n        );\\n        // Before activating governance, first fake the second part of the ping-pong\\n        // with a submission of a null ownership root, right after the submission of NewTXs\\n        IWriter(_writer).addOwnershipRoot(0, txSubmissionTime + 1);\\n        IWriter(_writer).addChallenge(0, staker);\\n        IWriter(_writer).activateGovernance();\\n        emit UnavailableTXData(verse);  \\n    }\\n\\n    // @inheritdoc IUpdates\\n    function wrongUniverseRoot(uint256 universeIdx, uint256 verse) external {\\n        address stakers =  IStorageGetters(_sto).stakers();\\n        require(\\n            IStakers(stakers).isStaker(msg.sender),\\n            \\\"only staker can report wrong universe root\\\"\\n        );\\n        _moveToGovernanceFromWrongUniverseRootPublished(universeIdx, verse);\\n    }\\n\\n    /**\\n     * @notice Moves to governance when wrong universe root is published\\n     */\\n    function _moveToGovernanceFromWrongUniverseRootPublished(\\n        uint256 universeIdx,\\n        uint256 verse\\n    ) private {\\n        require(\\n            IStorageGetters(_sto).universeVerse(universeIdx) == verse,\\n            \\\"Updates::_moveToGovernanceFromWrongUniverseRootPublished: incorrect provided verse\\\"\\n        );\\n\\n        require(\\n            IInfo(_info).isUniverseRootReadyForChallenge(universeIdx),\\n            \\\"not ready for wrongUniverseRoot submission\\\"\\n        );\\n        IWriter(_writer).activateGovernance();\\n        emit WrongUniverseRoot(universeIdx, verse);\\n    }\\n\\n    /**\\n     * @notice Requests that universe roots of a given universe cannot be updated further.\\n     * @dev Requires that the universe is not already closed\\n     * @param universeIdx the idx of the Universe\\n     * @param validUntil the time until which the query will be valid\\n     * @param signature The signature of the universe owner\\n     */\\n    function requestUniverseClosure(\\n        uint256 universeIdx,\\n        uint256 validUntil,\\n        bytes calldata signature\\n    ) external onlyUniversesRelayer {\\n        // Check that the signature is from the universe owner\\n        bytes32 msgHash = prefixed(\\n            keccak256(abi.encode(\\\"RequestClosure\\\", universeIdx, validUntil))\\n        );\\n        require(\\n            IStorageGetters(_sto).universeOwner(universeIdx) ==\\n                recoverAddrFromBytes(msgHash, signature),\\n            \\\"requestUniverseClosure: signature not correct\\\"\\n        );\\n        require(\\n            validUntil > block.timestamp,\\n            \\\"requestUniverseClosure: request expired\\\"\\n        );\\n        require(\\n            !IStorageGetters(_sto).universeIsClosed(universeIdx),\\n            \\\"requestUniverseClosure: universe already closed\\\"\\n        );\\n        IWriter(_writer).changeUniverseClosure(universeIdx, true, false);\\n        emit UniverseClosure(universeIdx, true, false);\\n    }\\n\\n    /**\\n     * @notice Confirms that universe roots cannot be updated further.\\n     * @dev Requires a previous request to exist\\n     * @param universeIdx the idx of the Universe\\n     * @param validUntil the time until which the query will be valid\\n     * @param signature The signature of the universe owner\\n     */\\n    function confirmUniverseClosure(\\n        uint256 universeIdx,\\n        uint256 validUntil,\\n        bytes calldata signature\\n    ) external onlyUniversesRelayer {\\n        // Check that the signature is from the universe owner\\n        bytes32 msgHash = prefixed(\\n            keccak256(abi.encode(\\\"ConfirmClosure\\\", universeIdx, validUntil))\\n        );\\n        require(\\n            IStorageGetters(_sto).universeOwner(universeIdx) ==\\n                recoverAddrFromBytes(msgHash, signature),\\n            \\\"requestUniverseClosure: signature not correct\\\"\\n        );\\n        require(\\n            validUntil > block.timestamp,\\n            \\\"requestUniverseClosure: request expired\\\"\\n        );\\n        require(\\n            !IStorageGetters(_sto).universeIsClosed(universeIdx),\\n            \\\"requestUniverseClosure: universe already closed\\\"\\n        );\\n        require(\\n            IStorageGetters(_sto).universeIsClosureRequested(universeIdx),\\n            \\\"requestUniverseClosure: universe closure must be requested before confirming\\\"\\n        );\\n        IWriter(_writer).changeUniverseClosure(universeIdx, true, true);\\n        emit UniverseClosure(universeIdx, true, true);\\n    }\\n\\n    /**\\n     * @notice Removes initial request of universe closure. Cannot be used if already confirmed.\\n     * @param universeIdx the idx of the Universe\\n     * @param validUntil the time until which the query will be valid\\n     * @param signature The signature of the universe owner\\n     */\\n    function removeUniverseClosureRequest(\\n        uint256 universeIdx,\\n        uint256 validUntil,\\n        bytes calldata signature\\n    ) external onlyUniversesRelayer {\\n        // Check that the signature is from the universe owner\\n        bytes32 msgHash = prefixed(\\n            keccak256(\\n                abi.encode(\\\"RemoveClosureRequest\\\", universeIdx, validUntil)\\n            )\\n        );\\n        require(\\n            IStorageGetters(_sto).universeOwner(universeIdx) ==\\n                recoverAddrFromBytes(msgHash, signature),\\n            \\\"removeUniverseClosureRequest: signature not correct\\\"\\n        );\\n        require(\\n            validUntil > block.timestamp,\\n            \\\"removeUniverseClosureRequest: request expired\\\"\\n        );\\n        require(\\n            !IStorageGetters(_sto).universeIsClosed(universeIdx),\\n            \\\"removeUniverseClosureRequest: universe already closed\\\"\\n        );\\n        IWriter(_writer).changeUniverseClosure(universeIdx, false, false);\\n        emit UniverseClosure(universeIdx, false, false);\\n    }\\n\\n    /**\\n     * Main getters\\n     */\\n\\n    /// @inheritdoc IUpdates\\n    function isReadyForOwnershipSubmission() public view returns (bool) {\\n        return IInfo(_info).isReadyForOwnershipSubmission();\\n    }\\n\\n    /// @inheritdoc IUpdates\\n    function emitOwnershipIPFSAtVerse(uint256 verse, string calldata ipfsCid)\\n        external\\n        onlyTXRelayer\\n    {\\n        emit OwnershipIPFSAtVerse(verse, ipfsCid);\\n    }\\n\\n    /// @inheritdoc IUpdates\\n    function computeLevelVerifiableOnChain(\\n        uint256 nTXs,\\n        uint256 nLeavesPerChallenge\\n    ) public pure returns (uint8 levelVeriableByBC) {\\n        levelVeriableByBC = 3;\\n        uint256 maxTXs = nLeavesPerChallenge;\\n        while (nTXs > maxTXs) {\\n            levelVeriableByBC++;\\n            maxTXs *= nLeavesPerChallenge;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/pure/serialization/SerializeMerkleGet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Deserialization of Merkle Tree parameters\\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\nimport \\\"./SerializeBase.sol\\\";\\n\\ncontract SerializeMerkleGet is SerializeBase {\\n    // Merkle Proof Getters (for transition proofs, merkle proofs in general)\\n    function MTPos(bytes memory serialized) public pure returns (uint256 pos) {\\n        assembly {\\n            pos := mload(add(serialized, 32))\\n        }\\n    }\\n\\n    function MTLeaf(bytes memory serialized)\\n        public\\n        pure\\n        returns (bytes32 root)\\n    {\\n        assembly {\\n            root := mload(add(serialized, 64))\\n        } // 8 + 2 * 32\\n    }\\n\\n    function MTProof(bytes memory serialized)\\n        public\\n        pure\\n        returns (bytes32[] memory proof)\\n    {\\n        // total length = 32 * 2 + 32 * nEntries\\n        uint32 nEntries = (uint32(serialized.length) - 64) / 32;\\n        require(\\n            serialized.length == 32 * 2 + 32 * nEntries,\\n            \\\"incorrect serialized length\\\"\\n        );\\n        return bytesToBytes32ArrayWithoutHeader(serialized, 64, nEntries);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/pure/serialization/SerializeBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Common tool for serilization/deserialization functions\\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\ncontract SerializeBase {\\n    // For all types of txs you always start with 1 byte for tx type:\\n    function txGetType(bytes memory serialized)\\n        public\\n        pure\\n        returns (uint8 txType)\\n    {\\n        assembly {\\n            txType := mload(add(serialized, 1))\\n        }\\n    }\\n\\n    function bytesToBytes32ArrayWithoutHeader(\\n        bytes memory input,\\n        uint256 offset,\\n        uint32 nEntries\\n    ) public pure returns (bytes32[] memory) {\\n        bytes32[] memory output = new bytes32[](nEntries);\\n\\n        for (uint32 p = 0; p < nEntries; p++) {\\n            offset += 32;\\n            bytes32 thisEntry;\\n            assembly {\\n                thisEntry := mload(add(input, offset))\\n            }\\n            output[p] = thisEntry;\\n        }\\n        return output;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/pure/Messages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Pure library to recover address from signatures\\n*/\\n\\ncontract Messages {\\n    /**\\n     @notice retrieves the addr that signed a message\\n     @param msgHash the message digest\\n     @param sig the message signature\\n     @return the retrieved address\\n     */\\n    function recoverAddrFromBytes(bytes32 msgHash, bytes memory sig)\\n        public\\n        pure\\n        returns (address)\\n    {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (sig.length != 65) {\\n            return address(0x0);\\n        }\\n\\n        assembly {\\n            r := mload(add(sig, 32))\\n            s := mload(add(sig, 64))\\n            v := and(mload(add(sig, 65)), 255)\\n        }\\n\\n        if (v < 27) {\\n            v += 27;\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            return address(0);\\n        }\\n        return ecrecover(msgHash, v, r, s);\\n    }\\n\\n    /**\\n     @notice retrieves the addr that signed a message\\n     @param msgHash the message digest\\n     @param v,r,s the (v,r,s) params of the signtature\\n     @return the retrieved address\\n     */\\n    function recoverAddr(\\n        bytes32 msgHash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public pure returns (address) {\\n        return ecrecover(msgHash, v, r, s);\\n    }\\n\\n    /**\\n     @notice Returns the hash after prepending eth_sign prefix\\n     @param hash the hash before prepending\\n     @return the hash after prepending eth_sign prefix\\n     */\\n    function prefixed(bytes32 hash) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/pure/MerkleTreeBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Base functions for Standard Merkle Trees\\n*/\\n\\ncontract MerkleTreeBase {\\n    bytes32 constant NULL_BYTES32 = bytes32(0);\\n\\n    function hash_node(bytes32 left, bytes32 right)\\n        public\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        if ((right == NULL_BYTES32) && (left == NULL_BYTES32))\\n            return NULL_BYTES32;\\n        assembly {\\n            mstore(0x00, left)\\n            mstore(0x20, right)\\n            hash := keccak256(0x00, 0x40)\\n        }\\n        return hash;\\n    }\\n\\n    function buildProof(\\n        uint256 leafPos,\\n        bytes32[] memory leaves,\\n        uint256 nLevels\\n    ) public pure returns (bytes32[] memory proof) {\\n        if (nLevels == 0) {\\n            require(\\n                leaves.length == 1,\\n                \\\"buildProof: leaves length must be 0 if nLevels = 0\\\"\\n            );\\n            require(\\n                leafPos == 0,\\n                \\\"buildProof: leafPos must be 0 if there is only one leaf\\\"\\n            );\\n            return proof; // returns the empty array []\\n        }\\n        uint256 nLeaves = 2**nLevels;\\n        require(\\n            leaves.length == nLeaves,\\n            \\\"number of leaves is not = pow(2,nLevels)\\\"\\n        );\\n        proof = new bytes32[](nLevels);\\n        // The 1st element is just its pair\\n        proof[0] = ((leafPos % 2) == 0)\\n            ? leaves[leafPos + 1]\\n            : leaves[leafPos - 1];\\n        // The rest requires computing all hashes\\n        for (uint8 level = 0; level < nLevels - 1; level++) {\\n            nLeaves /= 2;\\n            leafPos /= 2;\\n            for (uint256 pos = 0; pos < nLeaves; pos++) {\\n                leaves[pos] = hash_node(leaves[2 * pos], leaves[2 * pos + 1]);\\n            }\\n            proof[level + 1] = ((leafPos % 2) == 0)\\n                ? leaves[leafPos + 1]\\n                : leaves[leafPos - 1];\\n        }\\n    }\\n\\n    /**\\n    * @dev \\n        if nLevel = 0, there is one single leaf, corresponds to an empty proof\\n        if nLevels = 1, we need 1 element in the proof array\\n        if nLevels = 2, we need 2 elements...\\n            .\\n            ..   ..\\n        .. .. .. ..\\n        01 23 45 67\\n    */\\n    function MTVerify(\\n        bytes32 root,\\n        bytes32[] memory proof,\\n        bytes32 leafHash,\\n        uint256 leafPos\\n    ) public pure returns (bool) {\\n        for (uint32 pos = 0; pos < proof.length; pos++) {\\n            if ((leafPos % 2) == 0) {\\n                leafHash = hash_node(leafHash, proof[pos]);\\n            } else {\\n                leafHash = hash_node(proof[pos], leafHash);\\n            }\\n            leafPos /= 2;\\n        }\\n        // return false if leafPos was too large for given tree depth\\n        // (at level previous to root, leafPos had to be 0 or 1,\\n        // so at the end of last iteration, it must be 0)\\n        return (leafPos == 0) && (root == leafHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/pure/MerkleSerialized.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Merkle Tree Verify for serialized inputs\\n @dev Unpacks serialized inputs and then calls Merkle Tree Verify\\n*/\\n\\nimport \\\"../pure/Merkle.sol\\\";\\nimport \\\"../pure/serialization/SerializeMerkleGet.sol\\\";\\n\\ncontract MerkleSerialized is Merkle, SerializeMerkleGet {\\n    /**\\n    @dev\\n         MTData serializes the leaf, its position, and the proof that it belongs to a tree\\n         MTVerifySerialized returns true if such tree has root that coincides with the provided root.\\n    */\\n    function MTVerifySerialized(bytes32 root, bytes memory MTData)\\n        public\\n        pure\\n        returns (bool)\\n    {\\n        return MTVerify(root, MTProof(MTData), MTLeaf(MTData), MTPos(MTData));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/pure/Merkle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Computation of Root in Standard Merkle Tree\\n @author Freeverse.io, www.freeverse.io\\n @dev Version that does not overwrite the input leaves\\n*/\\n\\nimport \\\"../pure/MerkleTreeBase.sol\\\";\\n\\ncontract Merkle is MerkleTreeBase {\\n    /**\\n    * @dev \\n        If it is called with nLeaves != 2**nLevels, then it behaves as if zero-padded to 2**nLevels\\n        If it is called with nLeaves != 2**nLevels, then it behaves as if zero-padded to 2**nLevels\\n        Assumed convention:\\n        nLeaves = 1, nLevels = 0, there is one leaf, which coincides with the root\\n        nLeaves = 2, nLevels = 1, the root is the hash of both leaves\\n        nLeaves = 4, nLevels = 2, ...\\n    */\\n    function merkleRoot(bytes32[] memory leaves, uint256 nLevels)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        if (nLevels == 0) return leaves[0];\\n        uint256 nLeaves = 2**nLevels;\\n        require(\\n            nLeaves >= leaves.length,\\n            \\\"merkleRoot: not enough levels given the number of leaves\\\"\\n        );\\n\\n        /**\\n        * @dev \\n            instead of reusing the leaves array entries to store hashes leaves,\\n            create a half-as-long array (_leaves) for that purpose, to avoid modifying\\n            the input array. Solidity passes-by-reference when the function is in the same contract)\\n            and passes-by-value when calling a function in an external contract\\n        */\\n        nLeaves /= 2;\\n        bytes32[] memory _leaves = new bytes32[](nLeaves);\\n\\n        // level = 0 uses the original leaves:\\n        uint256 nLeavesNonNull = leaves.length / 2;\\n        for (uint256 pos = 0; pos < nLeavesNonNull; pos++) {\\n            _leaves[pos] = hash_node(leaves[2 * pos], leaves[2 * pos + 1]);\\n        }\\n\\n        if (leaves.length % 2 != 0) {\\n            _leaves[nLeavesNonNull] = hash_node(leaves[leaves.length - 1], NULL_BYTES32);\\n            nLeavesNonNull += 1;\\n        }\\n\\n        // levels > 0 reuse the smaller _leaves array:\\n        for (uint8 level = 1; level < nLevels; level++) {\\n            nLeaves /= 2;\\n            nLeavesNonNull = (nLeavesNonNull % 2 == 0)\\n                ? (nLeavesNonNull / 2)\\n                : ((nLeavesNonNull / 2) + 1);\\n            if (nLeavesNonNull > nLeaves) nLeavesNonNull = nLeaves;\\n\\n            for (uint256 pos = 0; pos < nLeavesNonNull; pos++) {\\n                _leaves[pos] = hash_node(\\n                    _leaves[2 * pos],\\n                    _leaves[2 * pos + 1]\\n                );\\n            }\\n            for (uint256 pos = nLeavesNonNull; pos < nLeaves; pos++) {\\n                _leaves[pos] = NULL_BYTES32;\\n            }\\n        }\\n        return _leaves[0];\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Interface to contract with write authorization to storage\\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\ninterface IWriter {\\n    /**\\n     * @notice Returns address of the license details for the contract code\\n     */\\n    function license() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the address of the Storage contract that\\n     * this contract can write to\\n     */\\n    function _sto() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the Stakers contract that\\n     * this contract can communicate with\\n     */\\n    function _stakers() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the Updates contract that\\n     * this contract can communicate with\\n     */\\n    function _updates() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the Challenges contract that\\n     * this contract can communicate with\\n     */\\n    function _challenges() external view returns (address);\\n\\n    // Functions that write to the Storage Contract\\n\\n    /**\\n     * @notice Adds a new root to a Universe\\n     * @param universeIdx The idx of the universe\\n     * @param root The root to be added\\n     * @param timestamp The timestamp to be associated\\n     * @return verse The verse at which the universe is after the addition\\n     */\\n    function addUniverseRoot(\\n        uint256 universeIdx,\\n        bytes32 root,\\n        uint256 timestamp\\n    ) external returns (uint256 verse);\\n\\n    /**\\n     * @notice Adds a new TX root\\n     * @dev TXs are added in batches. When adding a new batch, the ownership root settled in the previous verse\\n     * is settled, by copying from the challenge struct to the last ownership entry.\\n     * @param txRoot The nex TX root to be added\\n     * @param timestamp The timestamp to be associated\\n     * @param nTXs The number of TXs included in the batch\\n     * @param actualLevel The level at which the last challenge ended at\\n     * @param levelVeriableByBC The level at which a Challenge can be verified by the blockchain contract\\n     * @return txVerse The length of the TX roots array after the addition\\n     */\\n    function addTXRoot(\\n        bytes32 txRoot,\\n        uint256 timestamp,\\n        uint256 nTXs,\\n        uint8 actualLevel,\\n        uint8 levelVeriableByBC\\n    ) external returns (uint256 txVerse);\\n\\n    /**\\n     * @notice Adds a new Ownership root\\n     * @dev A new ownership root, ready for challenge is received.\\n     * Registers timestamp of reception, creates challenge and it\\n     * either appends to _ownerships, or rewrites last entry, depending on\\n     * whether it corresponds to a new verse, or it results from a challenge\\n     * to the current verse.\\n     * The latter can happen when the challenge game moved tacitly to level 0.\\n     * @param ownershipRoot The new ownership root to be added\\n     * @param timestamp The timestamp associated with the root added\\n     * @return ownVerse The length of the ownership array after the addition\\n     */\\n    function addOwnershipRoot(bytes32 ownershipRoot, uint256 timestamp)\\n        external\\n        returns (uint256 ownVerse);\\n\\n    /**\\n     * @notice Pushes a challenge to the Challenges array\\n     * @param ownershipRoot The new proposed ownership root\\n     * @param transitionsRoot The transitions root provided by the challenger\\n     * @param rootAtEdge The edge-root stored at the provided challenge level\\n     * @param pos The position stored at the provided challenge level\\n     */\\n    function pushChallenge(\\n        bytes32 ownershipRoot,\\n        bytes32 transitionsRoot,\\n        bytes32 rootAtEdge,\\n        uint256 pos\\n    ) external;\\n\\n    /**\\n     * @notice Sets the timestamp associated to the last ownership root received\\n     * @param timestamp The new time\\n     */\\n    function setLastOwnershipSubmissiontime(uint256 timestamp) external;\\n\\n    /**\\n     * @notice Pops the last entries in the Challenge array as many times\\n     * as required to set its length to actualLevel\\n     */\\n    function popChallengeDataToLevel(uint8 actualLevel) external;\\n\\n    /**\\n     * @notice Changes the data associated with the closure of a universe\\n     */\\n    function changeUniverseClosure(\\n        uint256 universeIdx,\\n        bool closureRequested,\\n        bool closureConfirmed\\n    ) external;\\n\\n    /**\\n     * @dev Functions that write to Stakers conttact\\n     */\\n\\n    /**\\n     * @notice Finalizes the currently opened challenge\\n     */\\n    function finalize() external;\\n\\n    /**\\n     * @notice Adds a new challenge\\n     */\\n    function addChallenge(uint8 level, address staker) external;\\n\\n    /**\\n     * @notice Resolves the last entries of a Challenge so as to\\n     * leave its final level to equal the provided level\\n     */\\n    function resolveToLevel(uint8 level) external;\\n\\n    /**\\n     * @notice Pops updaters from a Challenge so as to\\n     * leave its final level to equal the provided level\\n     */\\n    function rewindToLevel(uint8 level) external;\\n\\n    /**\\n     * @notice Rewrites the challenge struct created on reception\\n     *  of a first submitNewOwnershipRoot, so that it contains\\n     *  the previous verse's settled ownership root.   \\n     * @param ownershipRootPrevVerse The ownership root from the previous verse\\n     */\\n    function setProposedOwnershipToPrevVerse(bytes32 ownershipRootPrevVerse) external;\\n\\n    /**\\n     * @notice Stores the input verse with a 'bypassed' mark in the storage contract \\n     * @param verse The verse to be stored as 'bypassed'\\n     */\\n    function storeBypassedVerse(uint256 verse) external;\\n\\n    /**\\n     * @notice Stores the input universe verse with a 'bypassed' mark in the storage contract\\n     * @param universeIdx universe index\\n     * @param verse The verse to be stored as 'bypassed'\\n     */\\n    function storeBypassedUniverseVerse(\\n        uint256 universeIdx,\\n        uint256 verse\\n    ) external;\\n\\n    /**\\n     * @notice Sets to true the value of awaitingGovernance in the storage contract\\n     */\\n    function activateGovernance() external;\\n\\n    /**\\n     * @notice Sets to false the value of awaitingGovernance in the storage contract\\n     */\\n    function deactivateGovernance() external;\\n\\n    /**\\n     * @notice remove the last universe root from storage contract and returns current verse\\n     * @param universeIdx index of the universe\\n     * @return verse current verse after removal\\n     */\\n    function popUniverseRoot(\\n        uint256 universeIdx\\n    ) external returns (uint256 verse);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IUpdates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Interface to contract that manages Updates of Multiverse properties and Ownership\\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\ninterface IUpdates {\\n    event NewUniverseRoot(\\n        uint256 indexed universeIdx,\\n        bytes32 indexed newRoot,\\n        uint256 indexed verse,\\n        string ipfsCid\\n    );\\n    event UniverseClosure(uint256 universeIdx, bool requested, bool confirmed);\\n    event NewTXsRoot(\\n        bytes32 indexed newRoot,\\n        uint256 nTXs,\\n        uint8 levelsPerChallenge,\\n        uint256 indexed verse,\\n        string ipfsCid\\n    );\\n    event NewOwnershipRoot(bytes32 indexed newRoot, uint256 indexed verse);\\n    event OwnershipIPFSAtVerse(uint256 indexed verse, string ipfsCid);\\n    event OwnershipTxFormatVersion(uint32 version);\\n    event OwnershipRootMismatch(uint256 indexed verse, bytes32 newProposedRoot);\\n    event BypassVerse(uint256 indexed verse);\\n    event BypassUniverseVerse(uint256 universeIdx, uint256 indexed verse);\\n    event UnavailableTXData(uint256 indexed verse);\\n    event WrongUniverseRoot(uint256 universeIdx, uint256 verse);\\n\\n    /**\\n     * @notice Returns address of the license details for the contract code\\n     */\\n    function license() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the address of the Storage contract that\\n     * this contract can communicate with\\n     */\\n    function _sto() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the Writer contract that\\n     * this contract can communicate with\\n     */\\n    function _writer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the Info contract that\\n     * this contract can communicate with\\n     */\\n    function _info() external view returns (address);\\n\\n    /**\\n     * @notice Returns the version number of the expected format\\n     * of ownership TXs     \\n     */\\n    function OWNERSHIP_TXFORMAT_VERSION() external returns (uint32);\\n\\n    /**\\n     * @notice Submission of new Ownership state, open to challenge process until settling.\\n     * @dev Only stakers can submit, otherwise addChallenge would fail\\n     * The specified verse refers to the current verse opened by the last TXs submission\\n     * @param verse The tx verse of the processed TX Batch, leading to the new ownershipRoot\\n     * @param ownershipRoot The new ownership root\\n     * @param txFormatVersion The version of the txFormat used\\n     */\\n    function submitNewOwnershipRoot(uint256 verse, bytes32 ownershipRoot, uint32 txFormatVersion)\\n        external;\\n\\n    /**\\n     * @notice After reception of a NewTXs transaction, the TX data can be fetched from\\n     *  IPFS, but its root does not coincide with the submitted one.\\n     * @dev Requires that the system is in awaiting ownershipRoot state, and moves the\\n     *   system to awaitingGovernance. Needs to be called by a staker.\\n     * @param verse - the current verse; the provision of this param is required\\n     *  to avoid replay attacks.\\n     */\\n    function wrongTXDataRoot(uint256 verse) external;\\n\\n    /**\\n     * @notice Used to report universe root mismatch as a result of applying the universe transactions of the current verse\\n     * @dev moves the system to governance state\\n     * @param universeIdx universe index\\n     * @param verse universe verse that is challenged\\n     */\\n    function wrongUniverseRoot(uint256 universeIdx, uint256 verse) external;\\n\\n    /**\\n     * @notice Returns true if the system is ready to accept a new ownership root\\n     * @dev When a TXs batch is submitted, a new Ownership state can be submitted.\\n     * @return Returns true if the system is ready to accept a new ownership root\\n     */\\n    function isReadyForOwnershipSubmission() external view returns (bool);\\n\\n    /**\\n     * @notice Function to submit entire snapshots of the ownership state and inform via emission of event\\n     * @param verse The TX verse that the event refers to\\n     * @param ipfsCid The IPFS address of the data describing the event\\n     */\\n    function emitOwnershipIPFSAtVerse(uint256 verse, string calldata ipfsCid)\\n        external;\\n\\n    /**\\n     * @notice Computes the level at which a challenge can be resolved by the blockchain contract\\n     * @dev Example:\\n     *  level 0: nothing has been submitted\\n     *  level 1: just submitted successfully: submitNewOwnershipRoot(bytes32 ownershipRoot, bytes32 transitionsRoot)\\n     *  level 2: either verifiable, or just submitted successfully: challenge( N roots)...\\n     * Formula nTXsMax = nLeavesPerChallenge^(levelBC-3) * (nLeavesPerChallenge - 1);\\n     * @param nTXs the number of TXs in the TX batch\\n     * @param nLeavesPerChallenge the number of leaves that each challenge level contains\\n     */\\n    function computeLevelVerifiableOnChain(\\n        uint256 nTXs,\\n        uint256 nLeavesPerChallenge\\n    ) external pure returns (uint8 levelVeriableByBC);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IStorageGetters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Interface to the main storage getters\\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\ninterface IStorageGetters {\\n    /**\\n     * @notice Returns address of the license details for the contract code\\n     */\\n    function license() external view returns (string memory);\\n\\n    // UNIVERSE GETTERS\\n\\n    /**\\n     * @notice Returns the owner of a universe\\n     * @param universeIdx The idx of the universe\\n     * @return The address of the owner\\n     */\\n    function universeOwner(uint256 universeIdx) external view returns (address);\\n\\n    /**\\n     * @notice Returns the name of a universe\\n     * @param universeIdx The idx of the universe\\n     * @return The name of the universe\\n     */\\n    function universeName(uint256 universeIdx)\\n        external\\n        view\\n        returns (string memory);\\n\\n    /**\\n     * @notice Returns whether owner of a universe authorizes the default relayer\\n     * @param universeIdx The idx of the universe\\n     * @return Returns true if owner of a universe authorizes the default relayer\\n     */\\n    function universeAuthorizesRelay(uint256 universeIdx)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @notice Returns the current verse at which a universe is\\n     * @param universeIdx The idx of the universe\\n     * @return The verse\\n     */\\n    function universeVerse(uint256 universeIdx) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the root of a universe at the provided verse\\n     * @param universeIdx The idx of the universe\\n     * @param verse The verse queried\\n     * @return The root of the universe at the provided verse\\n     */\\n    function universeRootAtVerse(uint256 universeIdx, uint256 verse)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /**\\n     * @notice Returns current root of a universe\\n     * @param universeIdx The idx of the universe\\n     * @return The root of the universe at the current verse\\n     */\\n    function universeRootCurrent(uint256 universeIdx)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /**\\n     * @notice Returns the number of universes created\\n     * @return The number of universes created\\n     */\\n    function nUniverses() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the submission time of a universe root at the\\n     * provided verse\\n     * @param universeIdx The idx of the universe\\n     * @param verse The verse queried\\n     * @return The submission time\\n     */\\n    function universeRootSubmissionTimeAtVerse(\\n        uint256 universeIdx,\\n        uint256 verse\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the submission time of the current universe root\\n     * @param universeIdx The idx of the universe\\n     * @return The submission time\\n     */\\n    function universeRootSubmissionTimeCurrent(uint256 universeIdx)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Returns true if the universe if closed\\n     * @param universeIdx The idx of the universe\\n     * @return Returns true if it is closed\\n     */\\n    function universeIsClosed(uint256 universeIdx) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the universe has its closure requested\\n     * @param universeIdx The idx of the universe\\n     * @return Returns true if it has its closure requested\\n     */\\n    function universeIsClosureRequested(uint256 universeIdx)\\n        external\\n        view\\n        returns (bool);\\n\\n    // OWNERSHIP GETTERS\\n\\n    /**\\n     * @notice Returns the amount of time allowed for challenging\\n     * an ownership root that is currently set as default for next verses\\n     * @return the amount of time allowed for challenging\\n     */\\n    function challengeWindowNextVerses() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the number of levels contained in each challenge\\n     * set as default for next verses\\n     * @return the number of levels contained in each challenge\\n     */\\n    function nLevelsPerChallengeNextVerses() external view returns (uint8);\\n\\n    /**\\n     * @notice Returns the maximum time since the production of the last\\n     * verse beyond which assets can be exported without new verses being produced\\n     * @return the maximum time\\n     */\\n    function maxTimeWithoutVerseProduction() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns information about possible export requests about the provided asset\\n     * @param assetId The id of the asset\\n     * @return owner The owner that requested the asset export\\n     * @return requestVerse The TX verse at which the export request was received\\n     * @return completedVerse The TX verse at which the export process was completed (0 if not completed)\\n     */\\n    function exportRequestInfo(uint256 assetId)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            uint256 requestVerse,\\n            uint256 completedVerse\\n        );\\n\\n    /**\\n     * @notice Returns the owner that requested the asset export\\n     * @param assetId The id of the asset\\n     * @return owner The owner that requested the asset export\\n     */\\n    function exportOwner(uint256 assetId) external view returns (address owner);\\n\\n    /**\\n     * @notice Returns the TX verse at which the export request was received\\n     * @param assetId The id of the asset\\n     * @return requestVerse The TX verse at which the export request was received\\n     */\\n    function exportRequestVerse(uint256 assetId)\\n        external\\n        view\\n        returns (uint256 requestVerse);\\n\\n    /**\\n     * @notice Returns the TX verse at which the export process was completed (0 if not completed)\\n     * @param assetId The id of the asset\\n     * @return completedVerse The TX verse at which the export process was completed (0 if not completed)\\n     */\\n    function exportCompletedVerse(uint256 assetId)\\n        external\\n        view\\n        returns (uint256 completedVerse);\\n\\n    /**\\n     * @notice Returns the length of the ownership root array\\n     * @return the length of the ownership root array\\n     */\\n    function ownershipCurrentVerse() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the length of the TXs root array\\n     * @return the length of the TXs root array\\n     */\\n    function txRootsCurrentVerse() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the reference verse used in the computation of\\n     * the time planned for the submission of a TX batch for a given verse\\n     * @return The reference verse\\n     */\\n    function referenceVerse() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the timestamp at which the reference verse took\\n     * place used, in the computation of the time planned for\\n     * the submission of a TX batch for a given verse\\n     * @return The timestamp at which the reference verse took place\\n     */\\n    function referenceTime() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the seconds between txVerses between TX batch\\n     * submissions, used in the computation of the time planned for\\n     * each submission\\n     * @return The seconds between txVerses\\n     */\\n    function verseInterval() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the ownership root at the provided verse\\n     * @param verse The verse queried\\n     * @return The ownership root at the provided verse\\n     */\\n    function ownershipRootAtVerse(uint256 verse)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /**\\n     * @notice Returns the TX root at the provided verse\\n     * @param verse The verse queried\\n     * @return The TX root at the provided verse\\n     */\\n    function txRootAtVerse(uint256 verse) external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the number of levels contained in each challenge\\n     * at the provided verse\\n     * @param verse The verse queried\\n     * @return The TX root at the provided verse\\n     */\\n    function nLevelsPerChallengeAtVerse(uint256 verse)\\n        external\\n        view\\n        returns (uint8);\\n\\n    /**\\n     * @notice Returns the challenge level verifiable on chain\\n     * at the provided verse\\n     * @param verse The verse queried\\n     * @return The level verifiable on chain\\n     */\\n    function levelVerifiableOnChainAtVerse(uint256 verse)\\n        external\\n        view\\n        returns (uint8);\\n\\n    /**\\n     * @notice Returns the number of TXs included in the batch at\\n     * the provided verse\\n     * @param verse The verse queried\\n     * @return The number of TXs included in the batch\\n     */\\n    function nTXsAtVerse(uint256 verse) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount of time allowed for challenging\\n     * an ownership root at the provided verse\\n     * @param verse The verse queried\\n     * @return the amount of time allowed for challenging\\n     */\\n    function challengeWindowAtVerse(uint256 verse)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Returns the submission time of the TX batch\\n     * at the provided verse\\n     * @param verse The verse queried\\n     * @return the submission time of the TX batch\\n     */\\n    function txSubmissionTimeAtVerse(uint256 verse)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Returns the submission time of the Ownership root\\n     * at the provided verse\\n     * @param verse The verse queried\\n     * @return the submission time of the Ownership root\\n     */\\n    function ownershipSubmissionTimeAtVerse(uint256 verse)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Returns the last entry of the ownership root array\\n     * @return the last entry of the ownership root array\\n     */\\n    function ownershipRootCurrent() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the last entry of the TXs root array\\n     * @return the last entry of the TXs root array\\n     */\\n    function txRootCurrent() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the number of levels contained in each challenge\\n     * in the current verse\\n     * @return the number of levels contained in each challenge\\n     */\\n    function nLevelsPerChallengeCurrent() external view returns (uint8);\\n\\n    /**\\n     * @notice Returns the challenge level verifiable on chain\\n     * in the current verse\\n     * @return The level verifiable on chain\\n     */\\n    function levelVerifiableOnChainCurrent() external view returns (uint8);\\n\\n    /**\\n     * @notice Returns the number of TXs included in the batch\\n     * in the current verse\\n     * @return The number of TXs included in the batch\\n     */\\n    function nTXsCurrent() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount of time allowed for challenging\\n     * an ownership root in the current verse\\n     * @return the amount of time allowed for challenging\\n     */\\n    function challengeWindowCurrent() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the submission time of the TX batch\\n     * in the current verse\\n     * @return the submission time of the TX batch\\n     */\\n    function txSubmissionTimeCurrent() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the submission time of the Ownership root\\n     * in the current verse\\n     * @return the submission time of the Ownership root\\n     */\\n    function ownershipSubmissionTimeCurrent() external view returns (uint256);\\n\\n    // CHALLENGES GETTERS\\n\\n    /**\\n     * @notice Returns the ownership root stored at the provided challenge level\\n     * @param level The queried challenge level\\n     * @return the stored root\\n     */\\n    function challengesOwnershipRoot(uint8 level)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /**\\n     * @notice Returns the transitions root stored at the provided challenge level\\n     * @param level The queried challenge level\\n     * @return the stored root\\n     */\\n    function challengesTransitionsRoot(uint8 level)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /**\\n     * @notice Returns the edge-root stored at the provided challenge level\\n     * @param level The queried challenge level\\n     * @return the stored root\\n     */\\n    function challengesRootAtEdge(uint8 level) external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the position stored at the provided challenge level\\n     * @param level The queried challenge level\\n     * @return the position\\n     */\\n    function challengesPos(uint8 level) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the level stored in the current challenge process\\n     * @return the level\\n     */\\n    function challengesLevel() external view returns (uint8);\\n\\n    /**\\n     * @notice Returns true if all positions stored in the current\\n     * challenge process are zero\\n     * @return Returns true if all positions are zero\\n     */\\n    function areAllChallengePosZero() external view returns (bool);\\n\\n    /**\\n     * @notice Returns number of leaves contained in each challenge\\n     * in the current verse\\n     * @return Returns true if all positions are zero\\n     */\\n    function nLeavesPerChallengeCurrent() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the position of the leaf at the bottom level\\n     * of the current challenge process\\n     * @return bottomLevelLeafPos The position of the leaf\\n     */\\n    function computeBottomLevelLeafPos(uint256)\\n        external\\n        view\\n        returns (uint256 bottomLevelLeafPos);\\n\\n    // ROLES GETTERS\\n\\n    /**\\n     * @notice Returns the address with company authorization\\n     */\\n    function company() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address proposed for company authorization\\n     */\\n    function proposedCompany() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address with super user authorization\\n     */\\n    function superUser() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address with universe-roots relayer authorization\\n     */\\n    function universesRelayer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address with TX Batch relayer authorization\\n     */\\n    function txRelayer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the Stakers contract\\n     */\\n    function stakers() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the Writer contract\\n     */\\n    function writer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the Directory contract\\n     */\\n    function directory() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the NFT contract where\\n     * assets are minted when exported\\n     */\\n    function externalNFTContract() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the Assets Exporter contract\\n     */\\n    function assetExporter() external view returns (address);\\n\\n    // CLAIMS GETTERS\\n\\n    /**\\n     * @notice Returns the (verse, value) pair of the provided key\\n     * in the provided claim\\n     * @param claimIdx The Idx that identifies claim\\n     * @param key The key queried the claim\\n     * @return verse The verse at which the key was set\\n     * @return value The value that corresponds to the key\\n     */\\n    function claim(uint256 claimIdx, uint256 key)\\n        external\\n        view\\n        returns (uint256 verse, string memory value);\\n\\n    /**\\n     * @notice Returns the number of Claims created\\n     * @return the number of Claims created\\n     */\\n    function nClaims() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IStorageExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Interface to contract for querying and using storage extensions \\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\nimport \\\"../interfaces/IBlackholeId.sol\\\";\\nimport \\\"../interfaces/IGovernance.sol\\\";\\n\\ninterface IStorageExtension is IBlackholeId, IGovernance {\\n\\n    /**\\n     * @notice Reverts unless the Storage contract stores the expected\\n     *  claims, with the expected allowed values\\n     */\\n    function assertValidStorageExtension() external view;\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IStakers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Interface to contract that Manages Stakers and their deposits. \\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\ninterface IStakers {\\n    event PotBalanceChange(uint256 newBalance);\\n    event RewardsExecuted();\\n    event AddedTrustedParty(address indexed party);\\n    event RemovedTrustedParty(address indexed party);\\n    event NewEnrol(address indexed staker);\\n    event NewUnenrol(address indexed staker);\\n    event SlashedBy(address indexed slashedStaker, address indexed goodStaker);\\n    event AddedRewardToUpdater(address indexed staker);\\n    event FinalizedLogicRound();\\n    event NewLevel(uint16 indexed level);\\n\\n    /**\\n     * @notice Returns address of the license details for the contract code\\n     */\\n    function license() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns address of the storage contract that\\n     * this contract is attached to.\\n     */\\n    function sto() external view returns (address);\\n\\n    /**\\n     * @notice Returns the factor required to convert the smallest unit\\n     *  of the currency in the blockchain of deploy to Wei.\\n     *  Examples:\\n     *      for Ethereum, Polygon, XDAI, should return 1\\n     *      for Hedera, which uses tinybars, should return 1e10\\n     * @return the conversion factor to Wei\\n     */\\n    function TO_WEI() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns true if the provided address is registered as staker.\\n     * @return whether the provided address is a staker\\n     */\\n    function isStaker(address) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the provided address is has been slashed.\\n     * @return whether the provided address has been slashed\\n     */\\n    function isSlashed(address) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the provided address is registered as trusted party.\\n     * @return whether the provided address is a trusted party\\n     */\\n    function isTrustedParty(address) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the amount staked by the provided address.\\n     * @return the amount staked by the provided address.\\n     */\\n    function stakes(address) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount available for withdrawal\\n     * by the the provided address.\\n     * @return the amount available for withdrawal\\n     */\\n    function pendingWithdrawals(address) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the number of updates performed\\n     * by the the provided address since the last event of\\n     * reward execution\\n     * @return the number of updates performed\\n     */\\n    function nUpdates(address) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the number of currently registered trusted parties\\n     * @return the number of currently registered trusted parties\\n     */\\n    function nTrustedParties() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the number of currently registered stakers\\n     * @return the number of currently registered stakers\\n     */\\n    function nStakers() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the idx-th address that was ever registered.\\n     *  This array is never decreasing. Some addresses may, or may not,\\n     *  be trustedParties or stakers at present time.\\n     *  Use the isTrustedParty and isStaker methods to filter.\\n     * @param idx The index in the array\\n     * @return the address at the idx provided\\n     */\\n    function registeredParty(uint256 idx) external view returns (address);\\n\\n    /**\\n     * @notice Returns the idx-th trustedParty address\\n     * @param idx The position of the queried trustedParty\\n     * @return the idx-th trustedParty address\\n     */\\n    function trustedParty(uint256 idx) external view returns (address);\\n\\n    /**\\n     * @notice Returns the idx-th staker address\\n     * @param idx The position of the queried staker\\n     * @return the idx-th staker address\\n     */\\n    function staker(uint256 idx) external view returns (address);\\n\\n\\n    /**\\n     * @notice Returns the stake amount required to join as staker\\n     * @return the stake amount required to join as staker interpreted in WEI\\n     */\\n    function requiredStake() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount available in the pot\\n     * @return the amount available in the pot\\n     */\\n    function potBalance() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns total number of updates performed since\\n     * the last event of reward execution\\n     * @return the total number of updates performed\\n     */\\n    function totalNumUpdates() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the address at the provided idx of the array of\\n     * stakers to be rewarded\\n     * @param idx The index in the array\\n     * @return the address of the staker to be rewarded at the idx provided\\n     */\\n    function toBeRewarded(uint256 idx) external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the updater at the idx provided\\n     * @param idx The index in the array\\n     * @return the address of the updater at the idx provided\\n     */\\n    function updaters(uint256 idx) external view returns (address);\\n\\n    /**\\n     * @notice Transfers pendingWithdrawals to the calling staker;\\n     * @dev the stake remains until unenrol is called\\n     */\\n    function withdraw() external;\\n\\n    /**\\n     * @notice Reverts if the address does not fulfil the conditions\\n     * required to become a trusted party\\n     */\\n    function assertGoodCandidate(address _addr) external view;\\n\\n    /**\\n     * @notice Registers a new staker\\n     * @dev Must be called by the candidate\\n     */\\n    function enrol() external payable;\\n\\n    /**\\n     * @notice Unregisters a staker and transfers all earnings\\n     * @dev Must be called by the corresponding staker\\n     */\\n    function unEnroll() external;\\n\\n    /**\\n     * @notice Update to a new level\\n     * @dev This function will also resolve previous updates when\\n     * level is below current or level has reached the end\\n     * Requiring that _staker is not slashed is already covered by not being part of stakers,\\n     * because slashing removes address from stakers\\n     * @param _level to which update\\n     * @param _staker address of the staker that reports this update\\n     */\\n    function addChallenge(uint16 _level, address _staker) external;\\n\\n    /**\\n     * @notice Resolves a challenge at the provided level\\n     * @param _level at which we will end up, due to a level proven right,\\n     * and previous one proven wrong, possibly a few times.\\n     */\\n    function resolveToLevel(uint16 _level) external;\\n\\n    /**\\n     * @notice Rewinds a challenge process to a previous level\\n     * @param _level at which we will end up, due to a challenge to a previously-challenged level.\\n     */\\n    function rewindToLevel(uint16 _level) external;\\n\\n    /**\\n     * @notice Finalize current challenge process, get ready for next one.\\n     * @dev Current state will be resolved at this point.\\n     * If called from level 1, then staker is rewarded.\\n     * When called from any other level, means that every\\n     * other staker told the truth but the one in between lied.\\n     */\\n    function finalize() external;\\n\\n    /**\\n     * @notice Adds funds to pot to be shared by stakers who update\\n     * @dev Any address can add funds\\n     */\\n    function addRewardToPot() external payable;\\n\\n    /**\\n     * @notice Returns true if the provided address has already\\n     * performed an update in the current challenge\\n     * @return whether the provided address has already performed an update\\n     */\\n    function alreadyDidUpdate(address _address) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the level at which the challenge is\\n     * @return the level at which the challenge is\\n     */\\n    function level() external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Interface to contract with info/view functions\\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\nimport \\\"../interfaces/IChallengeLibStatus.sol\\\";\\nimport \\\"../interfaces/IStorageExtension.sol\\\";\\n\\ninterface IInfo is IChallengeLibStatus, IStorageExtension {\\n\\n    /**\\n     * @notice The enum that describes the possible states of the L2 -> L1 ownership sync flow\\n     */\\n    enum OwnershipState { AWAIT_TXS, AWAIT_OWNERSHIP, AWAIT_CHALLENGE, AWAIT_VERSE_TICK, AWAIT_GOVERNANCE }\\n\\n    /**\\n     * @notice Returns address of the license details for the contract code\\n     */\\n    function license() external view returns (string memory);\\n\\n    /**\\n     * @notice Returns true only if the input owner owns the asset AND the asset has the provided props\\n     * @dev Proofs need to be provided. They are verified against current Ownerhsip and Universe roots.\\n     * @param assetId The id of the asset\\n     * @param owner The address of the asset owner\\n     * @param marketData The market data of the asset\\n     * @param assetCID The CID of the asset\\n     * @param ownershipProof The proof that the asset belongs to the current Ownership tree\\n     * @param propsProof The proof that the asset properties belong to the current Universe tree\\n     * @return whether the proofs are valid or not\\n     */\\n    function isCurrentOwnerOfAssetWithProps(\\n        uint256 assetId,\\n        address owner,\\n        bytes memory marketData,\\n        string memory assetCID,\\n        bytes memory ownershipProof,\\n        bytes memory propsProof\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true only if the input owner owns the asset\\n     * @dev Proof needs to be provided. They are verified against current Ownership root\\n     * - if marketDataNeverTraded(marketData) == true (asset has never been included in the ownership tree)\\n     *   - it first verifies that it's not in the tree (the leafHash is bytes(0x0))\\n     *   - it then verifies that \\\"owner\\\" is the default owner\\n     * - if marketDataNeverTraded(marketData) == false (asset must be included in the ownership tree)\\n     *   - it only verifies owner == current owner stored in the ownership tree\\n     * Once an asset is traded once, marketDataNeverTraded remains false forever.\\n     * If asset has been exported, this function returns false; ownership needs to be queried in the external ERC721 contract.\\n     * @param assetId The id of the asset\\n     * @param owner The address of the asset owner\\n     * @param marketData The market data of the asset\\n     * @param proof The proof that the asset belongs to the current Ownership tree\\n     * @return whether the proof is valid or not\\n     */\\n    function isCurrentOwner(\\n        uint256 assetId,\\n        address owner,\\n        bytes memory marketData,\\n        bytes memory proof\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true only if the input owner owned the asset at provided verse\\n     * @dev Identical to isCurrentOwner, but uses the Ownership root at provided verse\\n     * @param verse The ownership verse at which the query refers\\n     * @param assetId The id of the asset\\n     * @param owner The address of the asset owner\\n     * @param marketData The market data of the asset\\n     * @param proof The proof that the asset belonged to the Ownership tree at provided verse\\n     * @return whether the proof is valid or not\\n     */\\n    function wasOwnerAtVerse(\\n        uint256 verse,\\n        uint256 assetId,\\n        address owner,\\n        bytes memory marketData,\\n        bytes memory proof\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Serialized-inputs version of isCurrentOwner\\n     * @dev Unpacks inputs and calls isCurrentOwner\\n     * @param data The serialized ownership data\\n     * @return whether the proof contained in data is valid or not\\n     */\\n    function isCurrentOwnerSerialized(bytes memory data)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @notice Serialized-inputs version of wasOwnerAtVerse\\n     * @dev Unpacks inputs and calls wasOwnerAtVerse\\n     * @param verse The ownership verse at which the query refers\\n     * @param data The serialized ownership data\\n     * @return whether the proof contained in data is valid or not\\n     */\\n    function wasOwnerAtVerseSerialized(uint256 verse, bytes memory data)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @notice Returns true only if asset currently has the provided props\\n     * @dev Proof needs to be provided. They are verified against current Universe root\\n     * @param assetId The id of the asset\\n     * @param assetCID The CID of the asset\\n     * @param proof The proof that the asset belongs to the current Universe tree\\n     * @return whether the proof is valid or not\\n     */\\n    function isCurrentAssetProps(\\n        uint256 assetId,\\n        string memory assetCID,\\n        bytes memory proof\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Returns true only if the asset had the provided props at the provided verse\\n     * @dev Identical to isCurrentAssetProps, but uses the Universe root at the provided verse\\n     * @param assetId The id of the asset\\n     * @param verse The universe verse at which the query refers\\n     * @param assetCID The CID of the asset\\n     * @param proof The proof that the asset properties belonged to the\\n     * Universe tree at provided verse\\n     * @return whether the proof is valid or not\\n     */\\n    function wasAssetPropsAtVerse(\\n        uint256 assetId,\\n        uint256 verse,\\n        string memory assetCID,\\n        bytes memory proof\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the last Ownership root that is fully settled (there could be one still in challenge process)\\n     * @dev There are 3 phases to consider.\\n     * 1. When submitTX just arrived, we just need to return the last stored ownership root\\n     * 2. When submitOwn just arrived, a temp root is added, so we return the last-to-last stored ownership root\\n     * 3. When the challenge period is over we return the settled root, which is in the challenge struct.\\n     * @return the current settled ownership root\\n     */\\n    function currentSettledOwnershipRoot() external view returns (bytes32);\\n\\n    /**\\n     * @notice Returns the last settled ownership verse number\\n     * @return the settled ownership verse\\n     */\\n    function currentSettledOwnershipVerse() external view returns (uint256);\\n\\n    /**\\n     * @notice Computes data about whether the system is in the phase that goes between\\n     * the finishing of the challenge period, and the arrival\\n     * of a new submission of a TX Batch\\n     * @return isChallengeOver Whether the system is in the phase between the settlement of\\n     * the last ownership root, and the submission of a new TX Batch\\n     * @return actualLevel The level at which the last challenge process is, accounting for\\n     * implicit time-driven changes\\n     * @return txVerse The current txVerse\\n     */\\n    function isInChallengePeriodFinishedPhase()\\n        external\\n        view\\n        returns (\\n            bool isChallengeOver,\\n            uint8 actualLevel,\\n            uint256 txVerse\\n        );\\n\\n    /**\\n     * @notice Returns the current state of the ownership synchronization state machine\\n     * @return the current ownership state\\n     */\\n    function ownershipState() external view returns(OwnershipState);\\n\\n    /**\\n     * @notice Computes data about whether the system is ready to accept\\n     * the submission of a new TX batch\\n     * @return isReady Whether the system is ready to accept a new TX batch submission\\n     * @return actualLevel The level at which the last challenge process is, accounting for\\n     * implicit time-driven changes\\n     */\\n    function isReadyForTXSubmission()\\n        external\\n        view\\n        returns (bool isReady, uint8 actualLevel);\\n\\n    /**\\n     * @notice Returns the time planned for the submission of a TX batch for a given verse\\n     * @param verse The TX verse queried\\n     * @param referenceVerse The reference verse used in the computation\\n     * @param referenceTime The timestamp at which the reference verse took place\\n     * @param verseInterval The seconds between txVerses\\n     * @return the time planned for the submission of a TX batch for a given verse\\n     */\\n    function plannedTime(\\n        uint256 verse,\\n        uint256 referenceVerse,\\n        uint256 referenceTime,\\n        uint256 verseInterval\\n    ) external pure returns (uint256);\\n\\n    /**\\n     * @notice Returns true if the system is ready to accept a new ownership root\\n     * @dev When a TXs batch is submitted, a new Ownership state can be submitted.\\n     * @return Returns true if the system is ready to accept a new ownership root\\n     */\\n    function isReadyForOwnershipSubmission() external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the contract is ready to accept a new universe root submission\\n     * @param universeIdx universe index\\n     * @return isReady is true if the contract is ready to accept a new universe root submission\\n     */\\n    function isReadyForUniverseRootSubmission(\\n        uint256 universeIdx\\n    ) external view returns (bool isReady);\\n\\n    /**\\n     * @notice Returns true if the system is ready to accept challenges to the last\\n     * submitted ownership root\\n     * @return Whether the system is ready to accept challenges\\n     */\\n    function isReadyForChallenge() external view returns (bool);\\n\\n    /**\\n     * @notice Returns data about the status of the current challenge,\\n     * taking into account the time passed, so that the actual level\\n     * can be less than the level explicitly stored, or just settled.\\n     * @return isSettled Whether the current challenge process is settled\\n     * @return actualLevel The level at which the last challenge process is, accounting for\\n     * @return nJumps The number of challenge levels already accounted for when\\n     * taking time into account\\n     */\\n    function getCurrentChallengeStatus()\\n        external\\n        view\\n        returns (\\n            bool isSettled,\\n            uint8 actualLevel,\\n            uint8 nJumps\\n        );\\n\\n    /**\\n     * @notice Returns true if the universe verse is ready for challenge\\n     * taking into account the time passed\\n     * @param universeIdx universe index\\n     * @return isReady is true if the universe verse is ready for challenge\\n     */\\n    function isUniverseRootReadyForChallenge(\\n        uint256 universeIdx\\n    ) external view returns (bool isReady);\\n\\n    /**\\n     * @notice Returns true if the asset cannot undergo any ownership change\\n     * because of its export process\\n     * @dev This function requires both the assetId and the owner as inputs,\\n     * because an asset is blocked only if the owner coincides with\\n     * the address that made the request earlier.\\n     * This view function gathers export info from storage and calls isAssetBlockedByExportPure\\n     * @param assetId the id of the asset\\n     * @param currentOwner the current owner of the asset\\n     * @return whether the asset is blocked or not\\n     */\\n    function isAssetBlockedByExport(uint256 assetId, address currentOwner)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @notice Returnss true if the asset cannot undergo any ownership change\\n     * @dev Pure version of isAssetBlockedByExport\\n     * @param currentOwner The current owner of the asset\\n     * @param currentVerse The current txVerse\\n     * @param requestOwner The address of the owner who started the export request\\n     * @param requestVerse The txVerse at which the export request was made\\n     * @param completedVerse The txVerse at which the export process was completed.\\n     * Should be 0 if process is not completed.\\n     * @return whether the asset is blocked or not\\n     */\\n    function isAssetBlockedByExportPure(\\n        address currentOwner,\\n        uint256 currentVerse,\\n        address requestOwner,\\n        uint256 requestVerse,\\n        uint256 completedVerse\\n    ) external pure returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Interface to contract for querying and using isAwaitingGovernance \\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\ninterface IGovernance {\\n\\n    /**\\n     * @notice Returns the awaitGovernance bool stored in the Storage contract\\n     *  WARNING: this function can revert if the claim does not exist in storage,\\n     *  use hasGovernance() before calling this function to avoid unwanted reverts.\\n     * @return the awaitGovernance bool stored in the Storage contract\\n     */\\n    function isAwaitingGovernance() external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the Storage contract stores as claim(1,0)\\n     *  the expected data for a isAwaitingGovernance\\n     * @return true if the stored isAwaitingGovernance is as expected\\n     */\\n    function hasGovernance() external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the provided inputs follow the \\n     *  the expected data for a isAwaitingGovernance\\n     * @param str the provided string that identifies the claim as referring to 'isAwaitingGovernance'\\n     * @return true if the provided inputs follow the expected data for a isAwaitingGovernance\\n     */\\n    function claimIsValidGovernance(string memory str) external pure returns (bool);\\n\\n    /**\\n     * @notice Reverts unless the Storage contract stores as claim(1,0)\\n     *  the expected data for a isAwaitingGovernance\\n     */\\n    function assertValidGovernance() external view; \\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IChallengeLibStatus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @author Freeverse.io, www.freeverse.io\\n @dev Interface to contract with pure function to compute the status of a challenge\\n*/\\n\\ninterface IChallengeLibStatus {\\n    /**\\n     * @dev Computes if the system is ready to accept a new TX Batch submission\\n     *      Data from storage is fetched previous to passing to this function.\\n     */\\n    function isInChallengePeriodFinishedPhasePure(\\n        uint256 txRootsCurrentVerse,\\n        uint256 ownershipSubmissionTimeCurrent,\\n        uint256 challengeWindowCurrent,\\n        uint256 txSubmissionTimeCurrent,\\n        uint256 blockTimestamp,\\n        uint8 challengesLevel\\n    ) external pure returns (bool isChallengeOver, uint8 actualLevel);\\n\\n    /**\\n    * @dev Pure function to compute if the current challenge is settled already,\\n           or if due to time passing, one or more challenges have been tacitly accepted.\\n           In such case, the challenge processs reduces 2 levels per challenge accepted.\\n           inputs:\\n            currentTime: now, in secs, as return by block.timstamp\\n            lastChallTime: time at which the last challenge was received (at level 0, time of submission of ownershipRoot)\\n            challengeWindow: amount of time available for submitting a new challenge\\n            writtenLevel: the last stored level of the current challenge game\\n           returns:\\n            isSettled: if true, challenges are still accepted\\n            actualLevel: the level at which the challenge truly is, taking time into account.\\n            nJumps: the number of challenges tacitly accepted, taking time into account.\\n    */\\n    function computeChallStatus(\\n        uint256 currentTime,\\n        uint256 lastTxSubmissionTime,\\n        uint256 lastChallTime,\\n        uint256 challengeWindow,\\n        uint8 writtenLevel\\n    )\\n        external\\n        pure\\n        returns (\\n            bool isSettled,\\n            uint8 actualLevel,\\n            uint8 nJumps\\n        );\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IBlackholeId.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\n/**\\n @title Interface to contract for querying and using blackholeId \\n @author Freeverse.io, www.freeverse.io\\n*/\\n\\ninterface IBlackholeId {\\n\\n    /**\\n     * @notice Returns the blackholeId stored in the Storage contract\\n     *  WARNING: this function can revert if no claims exist in storage,\\n     *  use hasBlackholeId() before calling this function to avoid unwanted reverts.\\n     * @return blackholeId the blackholeId\\n     */\\n    function blackholeId() external view returns (uint8);\\n\\n    /**\\n     * @notice Returns true if the Storage contract stores as claim(0,0)\\n     *  the expected data for a BlackholeID\\n     * @return true if the stored blackholeId is as expected\\n     */\\n    function hasBlackholeId() external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the provided inputs follow the \\n     *  the expected data for a BlackholeID\\n     * @param number the provided value for blackholeId\\n     * @param str the provided string that identifies the claim as referring to 'blackholeId'\\n     * @return true if the provided inputs follow the expected data for a BlackholeID\\n     */\\n    function claimIsValidBlackholeID(uint256 number, string memory str) external pure returns (bool);\\n\\n    /**\\n     * @notice Reverts unless the Storage contract stores as claim(0,0)\\n     *  the expected data for a BlackholeID\\n     */\\n    function assertValidBlackholeId() external view; \\n\\n    /**\\n     * @notice Returns true if the provided assetId encodes a blackholeId that\\n     *  matches the provided id \\n     * @param assetId the assetId that encodes a certain blackholeId\\n     * @param id the blackholeId against which to compare\\n     * @return true if the provided assetId encodes a blackholeId that\\n     *  matches the provided id\\n     */\\n    function hasCorrectBlackholeId(uint256 assetId, uint8 id) external pure returns (bool);\\n\\n    /**\\n     * @notice Returns true if the provided assetId encodes a blackholeId that\\n     *  matches the blackholeId in the Storage contract\\n     * @param assetId the assetId that encodes a certain blackholeId\\n     * @return true if the provided assetId encodes a blackholeId that\\n     *  matches the blackholeId in the Storage contract\\n     */\\n    function hasCorrectBlackholeId(uint256 assetId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"storageAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"writer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"info\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"BypassUniverseVerse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"BypassVerse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"NewOwnershipRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nTXs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"levelsPerChallenge\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"}],\"name\":\"NewTXsRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"}],\"name\":\"NewUniverseRoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"}],\"name\":\"OwnershipIPFSAtVerse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newProposedRoot\",\"type\":\"bytes32\"}],\"name\":\"OwnershipRootMismatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"}],\"name\":\"OwnershipTxFormatVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"UnavailableTXData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"requested\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"}],\"name\":\"UniverseClosure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"WrongUniverseRoot\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"serialized\",\"type\":\"bytes\"}],\"name\":\"MTLeaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"serialized\",\"type\":\"bytes\"}],\"name\":\"MTPos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"serialized\",\"type\":\"bytes\"}],\"name\":\"MTProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"leafHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"leafPos\",\"type\":\"uint256\"}],\"name\":\"MTVerify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"MTData\",\"type\":\"bytes\"}],\"name\":\"MTVerifySerialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNERSHIP_TXFORMAT_VERSION\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_info\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sto\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_writer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leafPos\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"leaves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"nLevels\",\"type\":\"uint256\"}],\"name\":\"buildProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"bypassCurrentUniverseVerse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"bypassCurrentVerse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"nEntries\",\"type\":\"uint32\"}],\"name\":\"bytesToBytes32ArrayWithoutHeader\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nTXs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nLeavesPerChallenge\",\"type\":\"uint256\"}],\"name\":\"computeLevelVerifiableOnChain\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"levelVeriableByBC\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"confirmUniverseClosure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"}],\"name\":\"emitOwnershipIPFSAtVerse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"left\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"right\",\"type\":\"bytes32\"}],\"name\":\"hash_node\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReadyForOwnershipSubmission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"license\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"leaves\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"nLevels\",\"type\":\"uint256\"}],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"prefixed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"recoverAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recoverAddrFromBytes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"removeUniverseClosureRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"requestUniverseClosure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"prevTransRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"}],\"name\":\"setNewUniverseRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ownershipRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"txFormatVersion\",\"type\":\"uint32\"}],\"name\":\"submitNewOwnershipRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"txRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nTXs\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"txFormatVersion\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"}],\"name\":\"submitNewTXsRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"prevTransRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"ipfsCid\",\"type\":\"string\"}],\"name\":\"submitNewUniverseRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"serialized\",\"type\":\"bytes\"}],\"name\":\"txGetType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"txType\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"unavailableTXData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"wrongTXDataRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verse\",\"type\":\"uint256\"}],\"name\":\"wrongUniverseRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Updates", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e02b1d70cc1ab07e176ffc35fdb28c8531e08b430000000000000000000000009ad99d9ebe5a3a8f27ea158b557327414fb92ae2000000000000000000000000cc788480278fdef40cf7cbd37652473259d38b4e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}