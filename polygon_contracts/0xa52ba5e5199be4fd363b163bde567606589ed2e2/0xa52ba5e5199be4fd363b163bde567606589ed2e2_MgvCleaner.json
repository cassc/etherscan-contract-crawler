{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/periphery/MgvCleaner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.10;\\n\\nimport {MgvLib, MgvStructs} from \\\"../MgvLib.sol\\\";\\nimport {IMangrove} from \\\"mgv_src/IMangrove.sol\\\";\\n\\n/* The purpose of the Cleaner contract is to execute failing offers and collect\\n * their associated bounty. It takes an array of offers with same definition as\\n * `Mangrove.snipes` and expects them all to fail or not execute. */\\n\\n/* How to use:\\n   1) Ensure *your* address approved Mangrove for the token you will provide to the offer (`inbound_tkn`).\\n   2) Run `collect` on the offers that you detected were failing.\\n\\n   You can adjust takerWants/takerGives and gasreq as needed.\\n\\n   Note: in the current version you do not need to set MgvCleaner's allowance in Mangrove. */\\ncontract MgvCleaner {\\n  IMangrove immutable MGV;\\n\\n  constructor(address mgv) {\\n    MGV = IMangrove(payable(mgv));\\n  }\\n\\n  receive() external payable {}\\n\\n  /* Returns the entire balance, not just the bounty collected */\\n  function collect(address outbound_tkn, address inbound_tkn, uint[4][] calldata targets, bool fillWants)\\n    external\\n    returns (uint bal)\\n  {\\n    unchecked {\\n      (uint successes,,,,) = MGV.snipesFor(outbound_tkn, inbound_tkn, targets, fillWants, msg.sender);\\n      require(successes == 0, \\\"mgvCleaner/anOfferDidNotFail\\\");\\n      bal = address(this).balance;\\n      bool noRevert;\\n      (noRevert,) = msg.sender.call{value: bal}(\\\"\\\");\\n    }\\n  }\\n\\n  /* Collect bounties while impersonating another taker (`takerToImpersonate`) who has approved Mangrove for `inbound_tkn`. This allows borrowing that taker's `inbound_tkn` funds for cleaning instead of using `msg.sender`'s funds (who need not have any).\\n   * NB This impersonation trick only works for sniping of failing offers. Mangrove checks whether `msg.sender` is approved to send orders/snipes for the impersonated taker and reverts if it isn't the case. That check just happens `after` the order has completed and if all taken offers failed, no actual `inbound_tkn` funds were used and the check succeeds, because `msg.sender` is approved for 0 `inbound_tkn`s.\\n   * NB Returns the entire balance, not just the bounty collected\\n   */\\n  function collectByImpersonation(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint[4][] calldata targets,\\n    bool fillWants,\\n    address takerToImpersonate\\n  ) external returns (uint bal) {\\n    unchecked {\\n      (uint successes,,,,) = MGV.snipesFor(outbound_tkn, inbound_tkn, targets, fillWants, takerToImpersonate);\\n      require(successes == 0, \\\"mgvCleaner/anOfferDidNotFail\\\");\\n      bal = address(this).balance;\\n      bool noRevert;\\n      (noRevert,) = msg.sender.call{value: bal}(\\\"\\\");\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/MgvLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n\\n/* `MgvLib` contains data structures returned by external calls to Mangrove and the interfaces it uses for its own external calls. */\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./preprocessed/MgvStructs.post.sol\\\" as MgvStructs;\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/* # Structs\\nThe structs defined in `structs.js` have their counterpart as solidity structs that are easy to manipulate for outside contracts / callers of view functions. */\\n\\nlibrary MgvLib {\\n  /*\\n   Some miscellaneous data types useful to `Mangrove` and external contracts */\\n  //+clear+\\n\\n  /* `SingleOrder` holds data about an order-offer match in a struct. Used by `marketOrder` and `internalSnipes` (and some of their nested functions) to avoid stack too deep errors. */\\n  struct SingleOrder {\\n    address outbound_tkn;\\n    address inbound_tkn;\\n    uint offerId;\\n    MgvStructs.OfferPacked offer;\\n    /* `wants`/`gives` mutate over execution. Initially the `wants`/`gives` from the taker's pov, then actual `wants`/`gives` adjusted by offer's price and volume. */\\n    uint wants;\\n    uint gives;\\n    /* `offerDetail` is only populated when necessary. */\\n    MgvStructs.OfferDetailPacked offerDetail;\\n    MgvStructs.GlobalPacked global;\\n    MgvStructs.LocalPacked local;\\n  }\\n\\n  /* <a id=\\\"MgvLib/OrderResult\\\"></a> `OrderResult` holds additional data for the maker and is given to them _after_ they fulfilled an offer. It gives them their own returned data from the previous call, and an `mgvData` specifying whether Mangrove encountered an error. */\\n\\n  struct OrderResult {\\n    /* `makerdata` holds a message that was either returned by the maker or passed as revert message at the end of the trade execution*/\\n    bytes32 makerData;\\n    /* `mgvData` is an [internal Mangrove status code](#MgvOfferTaking/statusCodes) code. */\\n    bytes32 mgvData;\\n  }\\n}\\n\\n/* # Events\\nThe events emitted for use by bots are listed here: */\\ncontract HasMgvEvents {\\n  /* * Emitted at the creation of the new Mangrove contract on the pair (`inbound_tkn`, `outbound_tkn`)*/\\n  event NewMgv();\\n\\n  /* Mangrove adds or removes wei from `maker`'s account */\\n  /* * Credit event occurs when an offer is removed from Mangrove or when the `fund` function is called*/\\n  event Credit(address indexed maker, uint amount);\\n  /* * Debit event occurs when an offer is posted or when the `withdraw` function is called */\\n  event Debit(address indexed maker, uint amount);\\n\\n  /* * Mangrove reconfiguration */\\n  event SetActive(address indexed outbound_tkn, address indexed inbound_tkn, bool value);\\n  event SetFee(address indexed outbound_tkn, address indexed inbound_tkn, uint value);\\n  event SetGasbase(address indexed outbound_tkn, address indexed inbound_tkn, uint offer_gasbase);\\n  event SetGovernance(address value);\\n  event SetMonitor(address value);\\n  event SetUseOracle(bool value);\\n  event SetNotify(bool value);\\n  event SetGasmax(uint value);\\n  event SetDensity(address indexed outbound_tkn, address indexed inbound_tkn, uint value);\\n  event SetGasprice(uint value);\\n\\n  /* Market order execution */\\n  event OrderStart();\\n  event OrderComplete(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    address indexed taker,\\n    uint takerGot,\\n    uint takerGave,\\n    uint penalty,\\n    uint feePaid\\n  );\\n\\n  /* * Offer execution */\\n  event OfferSuccess(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint id,\\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\\n    address taker,\\n    uint takerWants,\\n    uint takerGives\\n  );\\n\\n  /* Log information when a trade execution reverts or returns a non empty bytes32 word */\\n  event OfferFail(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint id,\\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\\n    address taker,\\n    uint takerWants,\\n    uint takerGives,\\n    // `mgvData` may only be `\\\"mgv/makerRevert\\\"`, `\\\"mgv/makerTransferFail\\\"` or `\\\"mgv/makerReceiveFail\\\"`\\n    bytes32 mgvData\\n  );\\n\\n  /* Log information when a posthook reverts */\\n  event PosthookFail(address indexed outbound_tkn, address indexed inbound_tkn, uint offerId, bytes32 posthookData);\\n\\n  /* * After `permit` and `approve` */\\n  event Approval(address indexed outbound_tkn, address indexed inbound_tkn, address owner, address spender, uint value);\\n\\n  /* * Mangrove closure */\\n  event Kill();\\n\\n  /* * An offer was created or updated.\\n  A few words about why we include a `prev` field, and why we don't include a\\n  `next` field: in theory clients should need neither `prev` nor a `next` field.\\n  They could just 1. Read the order book state at a given block `b`.  2. On\\n  every event, update a local copy of the orderbook.  But in practice, we do not\\n  want to force clients to keep a copy of the *entire* orderbook. There may be a\\n  long tail of spam. Now if they only start with the first $N$ offers and\\n  receive a new offer that goes to the end of the book, they cannot tell if\\n  there are missing offers between the new offer and the end of the local copy\\n  of the book.\\n  \\n  So we add a prev pointer so clients with only a prefix of the book can receive\\n  out-of-prefix offers and know what to do with them. The `next` pointer is an\\n  optimization useful in Solidity (we traverse fewer memory locations) but\\n  useless in client code.\\n  */\\n  event OfferWrite(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    address maker,\\n    uint wants,\\n    uint gives,\\n    uint gasprice,\\n    uint gasreq,\\n    uint id,\\n    uint prev\\n  );\\n\\n  /* * `offerId` was present and is now removed from the book. */\\n  event OfferRetract(address indexed outbound_tkn, address indexed inbound_tkn, uint id, bool deprovision);\\n}\\n\\n/* # IMaker interface */\\ninterface IMaker {\\n  /* Called upon offer execution. \\n  - If the call throws, Mangrove will not try to transfer funds and the first 32 bytes of revert reason are passed to `makerPosthook`\u00a0as `makerData`\\n  - If the call returns normally, returndata is passed to `makerPosthook` as `makerData` and Mangrove will attempt to transfer the funds.\\n  */\\n  function makerExecute(MgvLib.SingleOrder calldata order) external returns (bytes32);\\n\\n  /* Called after all offers of an order have been executed. Posthook of the last executed order is called first and full reentrancy into Mangrove is enabled at this time. `order` recalls key arguments of the order that was processed and `result` recalls important information for updating the current offer. (see [above](#MgvLib/OrderResult))*/\\n  function makerPosthook(MgvLib.SingleOrder calldata order, MgvLib.OrderResult calldata result) external;\\n}\\n\\n/* # ITaker interface */\\ninterface ITaker {\\n  /* Inverted mangrove only: call to taker after loans went through */\\n  function takerTrade(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    // total amount of outbound_tkn token that was flashloaned to the taker\\n    uint totalGot,\\n    // total amount of inbound_tkn token that should be made available\\n    uint totalGives\\n  ) external;\\n}\\n\\n/* # Monitor interface\\nIf enabled, the monitor receives notification after each offer execution and is read for each pair's `gasprice` and `density`. */\\ninterface IMgvMonitor {\\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker) external;\\n\\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker) external;\\n\\n  function read(address outbound_tkn, address inbound_tkn) external view returns (uint gasprice, uint density);\\n}\\n\"\r\n    },\r\n    \"src/IMangrove.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n// This file was manually adapted from a file generated by abi-to-sol. It must\\n// be kept up-to-date with the actual Mangrove interface. Fully automatic\\n// generation is not yet possible due to user-generated types in the external\\n// interface lost in the abi generation.\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {MgvLib, MgvStructs, IMaker} from \\\"./MgvLib.sol\\\";\\n\\ninterface IMangrove {\\n  event Approval(address indexed outbound_tkn, address indexed inbound_tkn, address owner, address spender, uint value);\\n  event Credit(address indexed maker, uint amount);\\n  event Debit(address indexed maker, uint amount);\\n  event Kill();\\n  event NewMgv();\\n  event OfferFail(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint id,\\n    address taker,\\n    uint takerWants,\\n    uint takerGives,\\n    bytes32 mgvData\\n  );\\n  event OfferRetract(address indexed outbound_tkn, address indexed inbound_tkn, uint id, bool deprovision);\\n  event OfferSuccess(\\n    address indexed outbound_tkn, address indexed inbound_tkn, uint id, address taker, uint takerWants, uint takerGives\\n  );\\n  event OfferWrite(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    address maker,\\n    uint wants,\\n    uint gives,\\n    uint gasprice,\\n    uint gasreq,\\n    uint id,\\n    uint prev\\n  );\\n  event OrderComplete(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    address indexed taker,\\n    uint takerGot,\\n    uint takerGave,\\n    uint penalty,\\n    uint feePaid\\n  );\\n  event OrderStart();\\n  event PosthookFail(address indexed outbound_tkn, address indexed inbound_tkn, uint offerId, bytes32 posthookData);\\n  event SetActive(address indexed outbound_tkn, address indexed inbound_tkn, bool value);\\n  event SetDensity(address indexed outbound_tkn, address indexed inbound_tkn, uint value);\\n  event SetFee(address indexed outbound_tkn, address indexed inbound_tkn, uint value);\\n  event SetGasbase(address indexed outbound_tkn, address indexed inbound_tkn, uint offer_gasbase);\\n  event SetGasmax(uint value);\\n  event SetGasprice(uint value);\\n  event SetGovernance(address value);\\n  event SetMonitor(address value);\\n  event SetNotify(bool value);\\n  event SetUseOracle(bool value);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n  function withdrawERC20(address tokenAddress, uint value) external;\\n  function activate(address outbound_tkn, address inbound_tkn, uint fee, uint density, uint offer_gasbase) external;\\n\\n  function allowances(address, address, address, address) external view returns (uint);\\n\\n  function approve(address outbound_tkn, address inbound_tkn, address spender, uint value) external returns (bool);\\n\\n  function balanceOf(address) external view returns (uint);\\n\\n  function best(address outbound_tkn, address inbound_tkn) external view returns (uint);\\n\\n  function config(address outbound_tkn, address inbound_tkn)\\n    external\\n    view\\n    returns (MgvStructs.GlobalPacked, MgvStructs.LocalPacked);\\n\\n  function configInfo(address outbound_tkn, address inbound_tkn)\\n    external\\n    view\\n    returns (MgvStructs.GlobalUnpacked memory global, MgvStructs.LocalUnpacked memory local);\\n\\n  function deactivate(address outbound_tkn, address inbound_tkn) external;\\n\\n  function flashloan(MgvLib.SingleOrder memory sor, address taker) external returns (uint gasused, bytes32 makerData);\\n\\n  function fund(address maker) external payable;\\n\\n  function fund() external payable;\\n\\n  function governance() external view returns (address);\\n\\n  function isLive(MgvStructs.OfferPacked offer) external pure returns (bool);\\n\\n  function kill() external;\\n\\n  function locked(address outbound_tkn, address inbound_tkn) external view returns (bool);\\n\\n  function marketOrder(address outbound_tkn, address inbound_tkn, uint takerWants, uint takerGives, bool fillWants)\\n    external\\n    returns (uint takerGot, uint takerGave, uint bounty, uint fee);\\n\\n  function marketOrderFor(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint takerWants,\\n    uint takerGives,\\n    bool fillWants,\\n    address taker\\n  ) external returns (uint takerGot, uint takerGave, uint bounty, uint fee);\\n\\n  function newOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint wants,\\n    uint gives,\\n    uint gasreq,\\n    uint gasprice,\\n    uint pivotId\\n  ) external payable returns (uint);\\n\\n  function nonces(address) external view returns (uint);\\n\\n  function offerDetails(address, address, uint) external view returns (MgvStructs.OfferDetailPacked);\\n\\n  function offerInfo(address outbound_tkn, address inbound_tkn, uint offerId)\\n    external\\n    view\\n    returns (MgvStructs.OfferUnpacked memory offer, MgvStructs.OfferDetailUnpacked memory offerDetail);\\n\\n  function offers(address, address, uint) external view returns (MgvStructs.OfferPacked);\\n\\n  function permit(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    address owner,\\n    address spender,\\n    uint value,\\n    uint deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  function retractOffer(address outbound_tkn, address inbound_tkn, uint offerId, bool deprovision)\\n    external\\n    returns (uint provision);\\n\\n  function setDensity(address outbound_tkn, address inbound_tkn, uint density) external;\\n\\n  function setFee(address outbound_tkn, address inbound_tkn, uint fee) external;\\n\\n  function setGasbase(address outbound_tkn, address inbound_tkn, uint offer_gasbase) external;\\n\\n  function setGasmax(uint gasmax) external;\\n\\n  function setGasprice(uint gasprice) external;\\n\\n  function setGovernance(address governanceAddress) external;\\n\\n  function setMonitor(address monitor) external;\\n\\n  function setNotify(bool notify) external;\\n\\n  function setUseOracle(bool useOracle) external;\\n\\n  function snipes(address outbound_tkn, address inbound_tkn, uint[4][] memory targets, bool fillWants)\\n    external\\n    returns (uint successes, uint takerGot, uint takerGave, uint bounty, uint fee);\\n\\n  function snipesFor(address outbound_tkn, address inbound_tkn, uint[4][] memory targets, bool fillWants, address taker)\\n    external\\n    returns (uint successes, uint takerGot, uint takerGave, uint bounty, uint fee);\\n\\n  function updateOffer(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    uint wants,\\n    uint gives,\\n    uint gasreq,\\n    uint gasprice,\\n    uint pivotId,\\n    uint offerId\\n  ) external payable;\\n\\n  function withdraw(uint amount) external returns (bool noRevert);\\n\\n  receive() external payable;\\n}\\n\"\r\n    },\r\n    \"src/preprocessed/MgvStructs.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n// Note: can't do Type.Unpacked because typechain mixes up multiple 'Unpacked' structs under different namespaces. So for consistency we don't do Type.Packed either. We do TypeUnpacked and TypePacked.\\n\\nimport {OfferPacked, OfferUnpacked} from \\\"./MgvOffer.post.sol\\\";\\nimport \\\"./MgvOffer.post.sol\\\" as Offer;\\nimport {OfferDetailPacked, OfferDetailUnpacked} from \\\"./MgvOfferDetail.post.sol\\\";\\nimport \\\"./MgvOfferDetail.post.sol\\\" as OfferDetail;\\nimport {GlobalPacked, GlobalUnpacked} from \\\"./MgvGlobal.post.sol\\\";\\nimport \\\"./MgvGlobal.post.sol\\\" as Global;\\nimport {LocalPacked, LocalUnpacked} from \\\"./MgvLocal.post.sol\\\";\\nimport \\\"./MgvLocal.post.sol\\\" as Local;\"\r\n    },\r\n    \"src/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.6.2;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address account) external view returns (uint);\\n\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n\\n  function symbol() external view returns (string memory);\\n\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function name() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/preprocessed/MgvOffer.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n// fields are of the form [name,bits,type]\\n\\n// struct_defs are of the form [name,obj]\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n/* since you can't convert bool to uint in an expression without conditionals,\\n * we add a file-level function and rely on compiler optimization\\n */\\nfunction uint_of_bool(bool b) pure returns (uint u) {\\n  assembly { u := b }\\n}\\n\\nstruct OfferUnpacked {\\n  uint prev;\\n  uint next;\\n  uint wants;\\n  uint gives;\\n}\\n\\n//some type safety for each struct\\ntype OfferPacked is uint;\\nusing Library for OfferPacked global;\\n\\nuint constant prev_bits  = 32;\\nuint constant next_bits  = 32;\\nuint constant wants_bits = 96;\\nuint constant gives_bits = 96;\\n\\nuint constant prev_before  = 0;\\nuint constant next_before  = prev_before  + prev_bits ;\\nuint constant wants_before = next_before  + next_bits ;\\nuint constant gives_before = wants_before + wants_bits;\\n\\nuint constant prev_mask  = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint constant next_mask  = 0xffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint constant wants_mask = 0xffffffffffffffff000000000000000000000000ffffffffffffffffffffffff;\\nuint constant gives_mask = 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000;\\n\\nlibrary Library {\\n  function to_struct(OfferPacked __packed) internal pure returns (OfferUnpacked memory __s) { unchecked {\\n    __s.prev = (OfferPacked.unwrap(__packed) << prev_before) >> (256-prev_bits);\\n    __s.next = (OfferPacked.unwrap(__packed) << next_before) >> (256-next_bits);\\n    __s.wants = (OfferPacked.unwrap(__packed) << wants_before) >> (256-wants_bits);\\n    __s.gives = (OfferPacked.unwrap(__packed) << gives_before) >> (256-gives_bits);\\n  }}\\n\\n  function eq(OfferPacked __packed1, OfferPacked __packed2) internal pure returns (bool) { unchecked {\\n    return OfferPacked.unwrap(__packed1) == OfferPacked.unwrap(__packed2);\\n  }}\\n\\n  function unpack(OfferPacked __packed) internal pure returns (uint __prev, uint __next, uint __wants, uint __gives) { unchecked {\\n    __prev = (OfferPacked.unwrap(__packed) << prev_before) >> (256-prev_bits);\\n    __next = (OfferPacked.unwrap(__packed) << next_before) >> (256-next_bits);\\n    __wants = (OfferPacked.unwrap(__packed) << wants_before) >> (256-wants_bits);\\n    __gives = (OfferPacked.unwrap(__packed) << gives_before) >> (256-gives_bits);\\n  }}\\n\\n  function prev(OfferPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferPacked.unwrap(__packed) << prev_before) >> (256-prev_bits);\\n  }}\\n  function prev(OfferPacked __packed,uint val) internal pure returns(OfferPacked) { unchecked {\\n    return OfferPacked.wrap((OfferPacked.unwrap(__packed) & prev_mask)\\n                                | ((val << (256-prev_bits) >> prev_before)));\\n  }}\\n  function next(OfferPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferPacked.unwrap(__packed) << next_before) >> (256-next_bits);\\n  }}\\n  function next(OfferPacked __packed,uint val) internal pure returns(OfferPacked) { unchecked {\\n    return OfferPacked.wrap((OfferPacked.unwrap(__packed) & next_mask)\\n                                | ((val << (256-next_bits) >> next_before)));\\n  }}\\n  function wants(OfferPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferPacked.unwrap(__packed) << wants_before) >> (256-wants_bits);\\n  }}\\n  function wants(OfferPacked __packed,uint val) internal pure returns(OfferPacked) { unchecked {\\n    return OfferPacked.wrap((OfferPacked.unwrap(__packed) & wants_mask)\\n                                | ((val << (256-wants_bits) >> wants_before)));\\n  }}\\n  function gives(OfferPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferPacked.unwrap(__packed) << gives_before) >> (256-gives_bits);\\n  }}\\n  function gives(OfferPacked __packed,uint val) internal pure returns(OfferPacked) { unchecked {\\n    return OfferPacked.wrap((OfferPacked.unwrap(__packed) & gives_mask)\\n                                | ((val << (256-gives_bits) >> gives_before)));\\n  }}\\n}\\n\\nfunction t_of_struct(OfferUnpacked memory __s) pure returns (OfferPacked) { unchecked {\\n  return pack(__s.prev, __s.next, __s.wants, __s.gives);\\n}}\\n\\nfunction pack(uint __prev, uint __next, uint __wants, uint __gives) pure returns (OfferPacked) { unchecked {\\n  return OfferPacked.wrap(((((0\\n                              | ((__prev << (256-prev_bits)) >> prev_before))\\n                              | ((__next << (256-next_bits)) >> next_before))\\n                              | ((__wants << (256-wants_bits)) >> wants_before))\\n                              | ((__gives << (256-gives_bits)) >> gives_before)));\\n}}\"\r\n    },\r\n    \"src/preprocessed/MgvOfferDetail.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n// fields are of the form [name,bits,type]\\n\\n// struct_defs are of the form [name,obj]\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n/* since you can't convert bool to uint in an expression without conditionals,\\n * we add a file-level function and rely on compiler optimization\\n */\\nfunction uint_of_bool(bool b) pure returns (uint u) {\\n  assembly { u := b }\\n}\\n\\nstruct OfferDetailUnpacked {\\n  address maker;\\n  uint gasreq;\\n  uint offer_gasbase;\\n  uint gasprice;\\n}\\n\\n//some type safety for each struct\\ntype OfferDetailPacked is uint;\\nusing Library for OfferDetailPacked global;\\n\\nuint constant maker_bits         = 160;\\nuint constant gasreq_bits        = 24;\\nuint constant offer_gasbase_bits = 24;\\nuint constant gasprice_bits      = 16;\\n\\nuint constant maker_before         = 0;\\nuint constant gasreq_before        = maker_before         + maker_bits        ;\\nuint constant offer_gasbase_before = gasreq_before        + gasreq_bits       ;\\nuint constant gasprice_before      = offer_gasbase_before + offer_gasbase_bits;\\n\\nuint constant maker_mask         = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\\nuint constant gasreq_mask        = 0xffffffffffffffffffffffffffffffffffffffff000000ffffffffffffffffff;\\nuint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffffff;\\nuint constant gasprice_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff;\\n\\nlibrary Library {\\n  function to_struct(OfferDetailPacked __packed) internal pure returns (OfferDetailUnpacked memory __s) { unchecked {\\n    __s.maker = address(uint160((OfferDetailPacked.unwrap(__packed) << maker_before) >> (256-maker_bits)));\\n    __s.gasreq = (OfferDetailPacked.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\\n    __s.offer_gasbase = (OfferDetailPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __s.gasprice = (OfferDetailPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n\\n  function eq(OfferDetailPacked __packed1, OfferDetailPacked __packed2) internal pure returns (bool) { unchecked {\\n    return OfferDetailPacked.unwrap(__packed1) == OfferDetailPacked.unwrap(__packed2);\\n  }}\\n\\n  function unpack(OfferDetailPacked __packed) internal pure returns (address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) { unchecked {\\n    __maker = address(uint160((OfferDetailPacked.unwrap(__packed) << maker_before) >> (256-maker_bits)));\\n    __gasreq = (OfferDetailPacked.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\\n    __offer_gasbase = (OfferDetailPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __gasprice = (OfferDetailPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n\\n  function maker(OfferDetailPacked __packed) internal pure returns(address) { unchecked {\\n    return address(uint160((OfferDetailPacked.unwrap(__packed) << maker_before) >> (256-maker_bits)));\\n  }}\\n  function maker(OfferDetailPacked __packed,address val) internal pure returns(OfferDetailPacked) { unchecked {\\n    return OfferDetailPacked.wrap((OfferDetailPacked.unwrap(__packed) & maker_mask)\\n                                | ((uint(uint160(val)) << (256-maker_bits) >> maker_before)));\\n  }}\\n  function gasreq(OfferDetailPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferDetailPacked.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\\n  }}\\n  function gasreq(OfferDetailPacked __packed,uint val) internal pure returns(OfferDetailPacked) { unchecked {\\n    return OfferDetailPacked.wrap((OfferDetailPacked.unwrap(__packed) & gasreq_mask)\\n                                | ((val << (256-gasreq_bits) >> gasreq_before)));\\n  }}\\n  function offer_gasbase(OfferDetailPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferDetailPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n  }}\\n  function offer_gasbase(OfferDetailPacked __packed,uint val) internal pure returns(OfferDetailPacked) { unchecked {\\n    return OfferDetailPacked.wrap((OfferDetailPacked.unwrap(__packed) & offer_gasbase_mask)\\n                                | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\\n  }}\\n  function gasprice(OfferDetailPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferDetailPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n  function gasprice(OfferDetailPacked __packed,uint val) internal pure returns(OfferDetailPacked) { unchecked {\\n    return OfferDetailPacked.wrap((OfferDetailPacked.unwrap(__packed) & gasprice_mask)\\n                                | ((val << (256-gasprice_bits) >> gasprice_before)));\\n  }}\\n}\\n\\nfunction t_of_struct(OfferDetailUnpacked memory __s) pure returns (OfferDetailPacked) { unchecked {\\n  return pack(__s.maker, __s.gasreq, __s.offer_gasbase, __s.gasprice);\\n}}\\n\\nfunction pack(address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) pure returns (OfferDetailPacked) { unchecked {\\n  return OfferDetailPacked.wrap(((((0\\n                              | ((uint(uint160(__maker)) << (256-maker_bits)) >> maker_before))\\n                              | ((__gasreq << (256-gasreq_bits)) >> gasreq_before))\\n                              | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\\n                              | ((__gasprice << (256-gasprice_bits)) >> gasprice_before)));\\n}}\"\r\n    },\r\n    \"src/preprocessed/MgvGlobal.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n// fields are of the form [name,bits,type]\\n\\n// struct_defs are of the form [name,obj]\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n/* since you can't convert bool to uint in an expression without conditionals,\\n * we add a file-level function and rely on compiler optimization\\n */\\nfunction uint_of_bool(bool b) pure returns (uint u) {\\n  assembly { u := b }\\n}\\n\\nstruct GlobalUnpacked {\\n  address monitor;\\n  bool useOracle;\\n  bool notify;\\n  uint gasprice;\\n  uint gasmax;\\n  bool dead;\\n}\\n\\n//some type safety for each struct\\ntype GlobalPacked is uint;\\nusing Library for GlobalPacked global;\\n\\nuint constant monitor_bits   = 160;\\nuint constant useOracle_bits = 8;\\nuint constant notify_bits    = 8;\\nuint constant gasprice_bits  = 16;\\nuint constant gasmax_bits    = 24;\\nuint constant dead_bits      = 8;\\n\\nuint constant monitor_before   = 0;\\nuint constant useOracle_before = monitor_before   + monitor_bits  ;\\nuint constant notify_before    = useOracle_before + useOracle_bits;\\nuint constant gasprice_before  = notify_before    + notify_bits   ;\\nuint constant gasmax_before    = gasprice_before  + gasprice_bits ;\\nuint constant dead_before      = gasmax_before    + gasmax_bits   ;\\n\\nuint constant monitor_mask   = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\\nuint constant useOracle_mask = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\\nuint constant notify_mask    = 0xffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff;\\nuint constant gasprice_mask  = 0xffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff;\\nuint constant gasmax_mask    = 0xffffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffff;\\nuint constant dead_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffff;\\n\\nlibrary Library {\\n  function to_struct(GlobalPacked __packed) internal pure returns (GlobalUnpacked memory __s) { unchecked {\\n    __s.monitor = address(uint160((GlobalPacked.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\\n    __s.useOracle = (((GlobalPacked.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\\n    __s.notify = (((GlobalPacked.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\\n    __s.gasprice = (GlobalPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n    __s.gasmax = (GlobalPacked.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\\n    __s.dead = (((GlobalPacked.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\\n  }}\\n\\n  function eq(GlobalPacked __packed1, GlobalPacked __packed2) internal pure returns (bool) { unchecked {\\n    return GlobalPacked.unwrap(__packed1) == GlobalPacked.unwrap(__packed2);\\n  }}\\n\\n  function unpack(GlobalPacked __packed) internal pure returns (address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) { unchecked {\\n    __monitor = address(uint160((GlobalPacked.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\\n    __useOracle = (((GlobalPacked.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\\n    __notify = (((GlobalPacked.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\\n    __gasprice = (GlobalPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n    __gasmax = (GlobalPacked.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\\n    __dead = (((GlobalPacked.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\\n  }}\\n\\n  function monitor(GlobalPacked __packed) internal pure returns(address) { unchecked {\\n    return address(uint160((GlobalPacked.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\\n  }}\\n  function monitor(GlobalPacked __packed,address val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & monitor_mask)\\n                                | ((uint(uint160(val)) << (256-monitor_bits) >> monitor_before)));\\n  }}\\n  function useOracle(GlobalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((GlobalPacked.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\\n  }}\\n  function useOracle(GlobalPacked __packed,bool val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & useOracle_mask)\\n                                | ((uint_of_bool(val) << (256-useOracle_bits) >> useOracle_before)));\\n  }}\\n  function notify(GlobalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((GlobalPacked.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\\n  }}\\n  function notify(GlobalPacked __packed,bool val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & notify_mask)\\n                                | ((uint_of_bool(val) << (256-notify_bits) >> notify_before)));\\n  }}\\n  function gasprice(GlobalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (GlobalPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n  function gasprice(GlobalPacked __packed,uint val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & gasprice_mask)\\n                                | ((val << (256-gasprice_bits) >> gasprice_before)));\\n  }}\\n  function gasmax(GlobalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (GlobalPacked.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\\n  }}\\n  function gasmax(GlobalPacked __packed,uint val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & gasmax_mask)\\n                                | ((val << (256-gasmax_bits) >> gasmax_before)));\\n  }}\\n  function dead(GlobalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((GlobalPacked.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\\n  }}\\n  function dead(GlobalPacked __packed,bool val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & dead_mask)\\n                                | ((uint_of_bool(val) << (256-dead_bits) >> dead_before)));\\n  }}\\n}\\n\\nfunction t_of_struct(GlobalUnpacked memory __s) pure returns (GlobalPacked) { unchecked {\\n  return pack(__s.monitor, __s.useOracle, __s.notify, __s.gasprice, __s.gasmax, __s.dead);\\n}}\\n\\nfunction pack(address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) pure returns (GlobalPacked) { unchecked {\\n  return GlobalPacked.wrap(((((((0\\n                              | ((uint(uint160(__monitor)) << (256-monitor_bits)) >> monitor_before))\\n                              | ((uint_of_bool(__useOracle) << (256-useOracle_bits)) >> useOracle_before))\\n                              | ((uint_of_bool(__notify) << (256-notify_bits)) >> notify_before))\\n                              | ((__gasprice << (256-gasprice_bits)) >> gasprice_before))\\n                              | ((__gasmax << (256-gasmax_bits)) >> gasmax_before))\\n                              | ((uint_of_bool(__dead) << (256-dead_bits)) >> dead_before)));\\n}}\"\r\n    },\r\n    \"src/preprocessed/MgvLocal.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n// fields are of the form [name,bits,type]\\n\\n// struct_defs are of the form [name,obj]\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n/* since you can't convert bool to uint in an expression without conditionals,\\n * we add a file-level function and rely on compiler optimization\\n */\\nfunction uint_of_bool(bool b) pure returns (uint u) {\\n  assembly { u := b }\\n}\\n\\nstruct LocalUnpacked {\\n  bool active;\\n  uint fee;\\n  uint density;\\n  uint offer_gasbase;\\n  bool lock;\\n  uint best;\\n  uint last;\\n}\\n\\n//some type safety for each struct\\ntype LocalPacked is uint;\\nusing Library for LocalPacked global;\\n\\nuint constant active_bits        = 8;\\nuint constant fee_bits           = 16;\\nuint constant density_bits       = 112;\\nuint constant offer_gasbase_bits = 24;\\nuint constant lock_bits          = 8;\\nuint constant best_bits          = 32;\\nuint constant last_bits          = 32;\\n\\nuint constant active_before        = 0;\\nuint constant fee_before           = active_before        + active_bits       ;\\nuint constant density_before       = fee_before           + fee_bits          ;\\nuint constant offer_gasbase_before = density_before       + density_bits      ;\\nuint constant lock_before          = offer_gasbase_before + offer_gasbase_bits;\\nuint constant best_before          = lock_before          + lock_bits         ;\\nuint constant last_before          = best_before          + best_bits         ;\\n\\nuint constant active_mask        = 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint constant fee_mask           = 0xff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint constant density_mask       = 0xffffff0000000000000000000000000000ffffffffffffffffffffffffffffff;\\nuint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffff000000ffffffffffffffffffffffff;\\nuint constant lock_mask          = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\\nuint constant best_mask          = 0xffffffffffffffffffffffffffffffffffffffffff00000000ffffffffffffff;\\nuint constant last_mask          = 0xffffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffff;\\n\\nlibrary Library {\\n  function to_struct(LocalPacked __packed) internal pure returns (LocalUnpacked memory __s) { unchecked {\\n    __s.active = (((LocalPacked.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\\n    __s.fee = (LocalPacked.unwrap(__packed) << fee_before) >> (256-fee_bits);\\n    __s.density = (LocalPacked.unwrap(__packed) << density_before) >> (256-density_bits);\\n    __s.offer_gasbase = (LocalPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __s.lock = (((LocalPacked.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\\n    __s.best = (LocalPacked.unwrap(__packed) << best_before) >> (256-best_bits);\\n    __s.last = (LocalPacked.unwrap(__packed) << last_before) >> (256-last_bits);\\n  }}\\n\\n  function eq(LocalPacked __packed1, LocalPacked __packed2) internal pure returns (bool) { unchecked {\\n    return LocalPacked.unwrap(__packed1) == LocalPacked.unwrap(__packed2);\\n  }}\\n\\n  function unpack(LocalPacked __packed) internal pure returns (bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) { unchecked {\\n    __active = (((LocalPacked.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\\n    __fee = (LocalPacked.unwrap(__packed) << fee_before) >> (256-fee_bits);\\n    __density = (LocalPacked.unwrap(__packed) << density_before) >> (256-density_bits);\\n    __offer_gasbase = (LocalPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __lock = (((LocalPacked.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\\n    __best = (LocalPacked.unwrap(__packed) << best_before) >> (256-best_bits);\\n    __last = (LocalPacked.unwrap(__packed) << last_before) >> (256-last_bits);\\n  }}\\n\\n  function active(LocalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((LocalPacked.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\\n  }}\\n  function active(LocalPacked __packed,bool val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & active_mask)\\n                                | ((uint_of_bool(val) << (256-active_bits) >> active_before)));\\n  }}\\n  function fee(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << fee_before) >> (256-fee_bits);\\n  }}\\n  function fee(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & fee_mask)\\n                                | ((val << (256-fee_bits) >> fee_before)));\\n  }}\\n  function density(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << density_before) >> (256-density_bits);\\n  }}\\n  function density(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & density_mask)\\n                                | ((val << (256-density_bits) >> density_before)));\\n  }}\\n  function offer_gasbase(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n  }}\\n  function offer_gasbase(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & offer_gasbase_mask)\\n                                | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\\n  }}\\n  function lock(LocalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((LocalPacked.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\\n  }}\\n  function lock(LocalPacked __packed,bool val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & lock_mask)\\n                                | ((uint_of_bool(val) << (256-lock_bits) >> lock_before)));\\n  }}\\n  function best(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << best_before) >> (256-best_bits);\\n  }}\\n  function best(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & best_mask)\\n                                | ((val << (256-best_bits) >> best_before)));\\n  }}\\n  function last(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << last_before) >> (256-last_bits);\\n  }}\\n  function last(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & last_mask)\\n                                | ((val << (256-last_bits) >> last_before)));\\n  }}\\n}\\n\\nfunction t_of_struct(LocalUnpacked memory __s) pure returns (LocalPacked) { unchecked {\\n  return pack(__s.active, __s.fee, __s.density, __s.offer_gasbase, __s.lock, __s.best, __s.last);\\n}}\\n\\nfunction pack(bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) pure returns (LocalPacked) { unchecked {\\n  return LocalPacked.wrap((((((((0\\n                              | ((uint_of_bool(__active) << (256-active_bits)) >> active_before))\\n                              | ((__fee << (256-fee_bits)) >> fee_before))\\n                              | ((__density << (256-density_bits)) >> density_before))\\n                              | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\\n                              | ((uint_of_bool(__lock) << (256-lock_bits)) >> lock_before))\\n                              | ((__best << (256-best_bits)) >> best_before))\\n                              | ((__last << (256-last_bits)) >> last_before)));\\n}}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"kandel/=lib/kandel/\",\r\n      \"mgv_lib/=lib/\",\r\n      \"mgv_script/=script/\",\r\n      \"mgv_src/=src/\",\r\n      \"mgv_test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mgv\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256[4][]\",\"name\":\"targets\",\"type\":\"uint256[4][]\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"}],\"name\":\"collect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bal\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256[4][]\",\"name\":\"targets\",\"type\":\"uint256[4][]\"},{\"internalType\":\"bool\",\"name\":\"fillWants\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"takerToImpersonate\",\"type\":\"address\"}],\"name\":\"collectByImpersonation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bal\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MgvCleaner", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "0000000000000000000000009a58de548212f65c5406e46563372ee6dcc0ac43", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}