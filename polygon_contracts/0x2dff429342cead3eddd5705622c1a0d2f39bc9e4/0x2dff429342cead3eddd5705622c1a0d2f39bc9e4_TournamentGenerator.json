{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: contracts/interfaces/IMatch.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface IMatch {\r\n    // Events\r\n    event VotedPlayer(address, uint8, uint256);\r\n    event SetWinnerPlayer1();\r\n    event SetWinnerPlayer2();\r\n    event SetPot(uint256, uint256);\r\n    event setWithdrawal(address);\r\n    event Draw();\r\n\r\n    // Functions\r\n    function votePlayer(address, uint8, uint256) external;\r\n\r\n    // Mutators\r\n    function setWinner() external returns (bool);\r\n\r\n    function setPot(bytes memory) external;\r\n\r\n    function setWithdrawalSupporter(address) external;\r\n\r\n    // View functions\r\n    function votesPlayer1() external view returns (uint256);\r\n\r\n    function votesPlayer2() external view returns (uint256);\r\n\r\n    function supporterForPlayer1(address) external view returns (uint256);\r\n\r\n    function supporterForPlayer2(address) external view returns (uint256);\r\n\r\n    function getPlayer1() external view returns (bytes memory);\r\n\r\n    function getPlayer2() external view returns (bytes memory);\r\n\r\n    function getWinner() external view returns (bytes memory);\r\n\r\n    function claimAmount(address) external view returns (bytes memory);\r\n\r\n    function winnerId() external view returns (uint8);\r\n\r\n    function getFinished() external view returns (bool);\r\n\r\n    function getPot() external view returns (bytes memory);\r\n\r\n    function getWithdrawalSupporter(address) external view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IRound.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface IRound {\r\n    event VoteInPlayerMatch(uint256, address, uint256, uint256);\r\n    event RoundEnded();\r\n    event RoundStarted();\r\n    event JackpotUpdated(uint256);\r\n\r\n    // States of the tournament\r\n    enum StateRound {\r\n        Waiting,\r\n        Started,\r\n        Finished\r\n    }\r\n\r\n    // Mutators\r\n    function createMatches() external;\r\n\r\n    function startRound() external;\r\n\r\n    function endRound() external returns (bool);\r\n    \r\n    function addVotes(uint256) external;\r\n\r\n    // View functions\r\n    function matchesEncoded(uint256) external view returns (bytes memory);\r\n\r\n    function validateVote(address _matchAddress) external view;\r\n\r\n    function getStarted() external view returns (bool);\r\n\r\n    function getFinished() external view returns (bool);\r\n\r\n    function getMatchFinished(uint256) external view returns (bool);\r\n\r\n    function getMatch(uint256 _matchId) external view returns (address);\r\n\r\n    function getMatchesQty() external view returns (uint256);\r\n\r\n    function totalVoted() external view returns (uint256);\r\n\r\n    function roundStart() external view returns (uint256);\r\n\r\n    function roundEnd() external view returns (uint256);\r\n\r\n    function applyJackpot(uint256)\r\n        external\r\n        view\r\n        returns (bytes memory, bytes memory);\r\n\r\n    function getWinners() external view returns (uint256[] memory);\r\n\r\n    function getMatchesEncoded() external view returns (bytes[] memory);\r\n\r\n    function getPlayers() external view returns (uint256[] memory);\r\n}\r\n\r\n// File: contracts/interfaces/ITournamentFunctions.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface ITournamentFunctions {\r\n    event TournamentHubChanged(address);\r\n\r\n    function changeTournamentHub(address _contract) external;\r\n\r\n    function startTournament(address _tournament) external returns (bool);\r\n\r\n    function endRound(address _tournament) external returns (bool);\r\n\r\n    function depositNFT(\r\n        address _tournament,\r\n        address _sender,\r\n        uint256 _tokenId,\r\n        address _nftContract\r\n    ) external;\r\n\r\n    function vote(\r\n        address _tournament,\r\n        address _sender,\r\n        uint256 _matchId,\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        uint256 _amount\r\n    ) external returns (uint256);\r\n\r\n    function claimFromMatch(\r\n        address _tournamentAddress,\r\n        uint256 _matchId,\r\n        uint256 _roundNumber,\r\n        address _tribeToken,\r\n        address _sender\r\n    ) external returns (uint256);\r\n\r\n    function withdrawNFT(\r\n        address _tournamentAddress,\r\n        uint256 _tokenId,\r\n        address _nftContract,\r\n        address _sender\r\n    ) external;\r\n\r\n    function claimAllTokens(\r\n        address _tournamentAddress,\r\n        address _tribeToken,\r\n        address _sender\r\n    ) external;\r\n}\r\n\r\n// File: contracts/interfaces/IRoundGenerator.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\n// Interface\r\ninterface IRoundGenerator {\r\n    event RoundCreated(address);\r\n    event TournamentHubChanged(address);\r\n\r\n    function createRound(\r\n        bytes memory,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        bool,\r\n        address\r\n    ) external returns (address);\r\n\r\n    function changeTournamentHub(address) external;\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n// File: contracts/libraries/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ITournamentHub.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface ITournamentHub {\r\n    event ContractAdded(address);\r\n    event TournamentGeneratorChanged(address);\r\n    event TournamentGeneratorLockedChanged(address);\r\n    event RoundGeneratorChanged(address);\r\n    event MatchGeneratorChanged(address);\r\n    event TournamentFunctionsChanged(address);\r\n    event OnGoingTournamentAdded(address);\r\n    event OnGoingTournamentRemoved(address);\r\n    event TokenChanged(address);\r\n    event PublicGoodsWalletChanged(address);\r\n    event FeeWalletWalletChanged(address);\r\n    event JackpotWalletWalletChanged(address);\r\n    event AllNftClaimed(address);\r\n    event AllTokensClaimed(address);\r\n    event WithdrawNFTEvent(address indexed, address indexed, uint256);\r\n    event WithdrawEvent(address, uint256);\r\n    event BlacklistStatusChanged(address indexed, bool);\r\n    event CheckStatusChanged(address indexed, bool);\r\n    event DataFeedChanged(address indexed);\r\n\r\n    //View\r\n    function blacklistedNfts(address _address) external view returns (bool);\r\n\r\n    function checkedNfts(address _address) external view returns (bool);\r\n\r\n    function checkProject(address) external view returns (bool);\r\n\r\n    function checkAdmin(address) external view returns (bool);\r\n\r\n    function roundGenerator() external view returns (address);\r\n\r\n    function matchGenerator() external view returns (address);\r\n\r\n    function tournamentGenerator() external view returns (address);\r\n    \r\n    function tournamentGeneratorLocked() external view returns (address);\r\n\r\n    function tournamentFunctions() external view returns (address);\r\n\r\n    function publicGoodsWallet() external view returns (address);\r\n\r\n    function feeWallet() external view returns (address);\r\n\r\n    function jackpotWallet() external view returns (address);\r\n\r\n    function tribeXToken() external view returns (address);\r\n\r\n    function getOngoingSize() external view returns (uint256);\r\n\r\n    function tournamentVariables(address) external view returns (bytes memory);\r\n\r\n    function getTournamentJackpot(\r\n        address _tournamentAddress\r\n    ) external view returns (uint256);\r\n\r\n    function jackpotVariables(\r\n        address _tournamentAddress\r\n    ) external view returns (bytes memory);\r\n\r\n    function roundMatches(\r\n        address _tournamentAddress\r\n    ) external view returns (bytes[6] memory);\r\n\r\n    //Mutators\r\n    function setBlacklistStatus(address, bool) external;\r\n\r\n    function setCheckStatus(address, bool) external;\r\n\r\n    function addContract(address) external;\r\n\r\n    function addOnGoing(address) external;\r\n\r\n    function removeOnGoing(address) external;\r\n\r\n    function changePriceFeed(address) external;\r\n\r\n    function changeTournamentGenerator(address) external;\r\n\r\n    function changeTournamentGeneratorLocked(address) external;\r\n\r\n    function changeTournamentFunctions(address) external;\r\n\r\n    function changeRoundGenerator(address) external;\r\n\r\n    function changeMatchGenerator(address) external;\r\n\r\n    function changePublicGoodsWallet(address) external;\r\n\r\n    function changeFeesWallet(address) external;\r\n\r\n    function retrieveRandomArray(uint8) external returns (uint8[] memory);\r\n\r\n    function claimAllNfts(address _tournamentAddress) external;\r\n\r\n    function claimAllTokens(address _tournamentAddress) external;\r\n\r\n    function withdrawNFT(\r\n        address _tournamentAddress,\r\n        uint256 _tokenId,\r\n        address _nftContract\r\n    ) external;\r\n\r\n    function claimFromMatch(\r\n        address _tournamentAddress,\r\n        uint256 _matchId,\r\n        uint256 _roundNumber\r\n    ) external;\r\n}\r\n\r\n// File: contracts/interfaces/ITournament.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface ITournament {\r\n    // Events\r\n    event RoundStarted(uint256);\r\n    event RoundEnded(uint256);\r\n    event Draw(uint256, uint256);\r\n    event DepositNFTEvent(uint256, address indexed, uint256);\r\n    event StartTournamentEvent();\r\n    event EndTournamentEvent();\r\n    event WithdrawNFTEvent(address indexed, address indexed, uint256);\r\n    event VoteInPlayerMatch(uint256, uint256, uint256);\r\n    event WithdrawEvent(address, uint256);\r\n    event jackpotIncreased(uint256);\r\n    event OwnerOfNftChanged(uint256, uint256);\r\n    event PublicGoodsClaimed();\r\n\r\n    // States of the tournament\r\n    enum StateTournament {\r\n        Waiting,\r\n        Started,\r\n        Finished,\r\n        Canceled\r\n    }\r\n\r\n    enum FeesClaimed {\r\n        NotClaimed,\r\n        Claimed\r\n    }\r\n\r\n    // View\r\n    function lockedNft() external view returns (address);\r\n\r\n    function lockedNftVote() external view returns (bool);\r\n\r\n    function getNftOwner(bytes memory) external view returns (address);\r\n\r\n    function getNftUnlocked(bytes memory) external view returns (bool);\r\n\r\n    function getTournamentStatus() external view returns (uint8);\r\n\r\n    function totalVoted() external view returns (uint256);\r\n\r\n    function getPlayer(uint256) external view returns (bytes memory);\r\n\r\n    function getPlayerId(bytes memory) external view returns (uint256);\r\n\r\n    function numRounds() external view returns (uint8);\r\n\r\n    function roundDuration() external view returns (uint256);\r\n\r\n    function roundInterval() external view returns (uint256);\r\n\r\n    function startTime() external view returns (uint256);\r\n\r\n    function minutesOnDraw() external view returns (uint256);\r\n\r\n    function maxPlayers() external view returns (uint256);\r\n\r\n    function endTime() external view returns (uint256);\r\n\r\n    function fee() external view returns (uint256);\r\n\r\n    function round() external view returns (uint8);\r\n\r\n    function finalJackpot() external view returns (uint256);\r\n\r\n    function jackpot() external view returns (uint256);\r\n\r\n    function publicGoods() external view returns (uint256);\r\n\r\n    function jackpotPerc() external view returns (uint8);\r\n\r\n    function publicGoodsPerc() external view returns (uint8);\r\n\r\n    function getRound(uint256) external view returns (address);\r\n\r\n    function getMatches(uint256) external view returns (bytes[] memory);\r\n\r\n    function getPlayers(uint256) external view returns (uint256[] memory);\r\n\r\n    function totalVotes(uint8) external view returns (uint256);\r\n\r\n    function depositedLength() external view returns (uint256);\r\n\r\n    // Mutators\r\n    function depositNFT(\r\n        uint256,\r\n        address\r\n    ) external returns (uint256, address, uint256);\r\n\r\n    function addNFT(bytes memory _encodedNFT, address _sender) external;\r\n\r\n    function changeNftOwner(uint256, uint256) external;\r\n\r\n    function claimNFT(address, address, uint256) external;\r\n\r\n    function vote(\r\n        uint256,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external returns (uint256);\r\n\r\n    function increaseJackpot(uint256) external returns (uint256);\r\n\r\n    function claimTokens(address, uint256) external;\r\n\r\n    function claimPublicGoods() external;\r\n\r\n    function startTournament() external;\r\n\r\n    function cancelTournament() external;\r\n\r\n    function setDraw() external;\r\n\r\n    function setVariables(uint256, uint256, uint256) external;\r\n\r\n    function unlockNFT(address _lastMatch) external;\r\n\r\n    function setStartTime(uint256 _time) external;\r\n\r\n    function setEndTime(uint256) external;\r\n\r\n    function addRound(address) external;\r\n\r\n    function increaseRound() external;\r\n\r\n    function startRound() external;\r\n\r\n    function endRound() external returns (bool);\r\n}\r\n\r\n// File: contracts/Tournament.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Tournament is ITournament {\r\n    using SafeMath for uint256;\r\n    // variables\r\n    StateTournament public tournamentStatus;\r\n    FeesClaimed private claimed;\r\n    ITournamentHub private immutable tournamentHub;\r\n    ITournamentFunctions private immutable tournamentFunctions;\r\n\r\n    uint256 public override startTime; // it will be 0 if the Tournament doen't have a Start Date\r\n    uint256 public override endTime;\r\n    uint256 public override roundDuration; // duration of each round\r\n    uint256 public override roundInterval; // interval between rounds\r\n    uint256 public override minutesOnDraw; // how many minutes will be added on Draw\r\n    uint256 public override totalVoted;\r\n\r\n    uint256 public override maxPlayers;\r\n    uint8 public override round; // current round\r\n    uint8 public override numRounds; // number of rounds\r\n\r\n    uint256 public override jackpot; //jackpot for the last round\r\n    uint256 public override finalJackpot; //total final pot and jackpot for the last round\r\n    uint256 public override publicGoods; // value of Public Goods for this tournament\r\n    uint256 public override fee; //fee taken 0.5% at each round from loosers and 2% of final jackpot\r\n    uint8 public override jackpotPerc; //percentage of loosers that goes to jackpot each round\r\n    uint8 public override publicGoodsPerc; //percentage of jackpot that goes to publicGoods each round\r\n    address public override lockedNft;\r\n    bool public override lockedNftVote;\r\n\r\n    IERC20 internal immutable tribeToken;\r\n\r\n    // lists and mappings\r\n    address[] public override getRound;\r\n    bytes[] public override getPlayer;\r\n\r\n    mapping(bytes => address) public override getNftOwner; // says who's the owner of the NFT. It changes on match result\r\n    mapping(bytes => bool) public override getNftUnlocked;\r\n    mapping(bytes => uint256) public override getPlayerId;\r\n    mapping(uint8 => uint256) public override totalVotes; // takes the total votes for a player on the tournament\r\n\r\n    /**\r\n     * @dev Constructor for the Tournament contract\r\n     * @param _startTime is the time in timestamp milisseconds\r\n     * @param _numRounds is the number of rounds\r\n     * @param _roundDuration is the duration of each round in milisseconds\r\n     * @param _roundInterval is the interval between rounds in milisseconds\r\n     * @param _minutesOnDraw is the number of minutes added to the round duration when a draw happens\r\n     * @param _jackpotPerc is the percentage of the match pot that goes to the jackpot\r\n     * @param _publicGoodsPerc is the percentage of the jackpot that goes to public goods\r\n     * @param _tournamentHub is the address of the TournamentHub contract\r\n     * @param _lockedNft is the address of the NFT collection allowed for this tournament\r\n     * @param _lockedNftVote is a boolean that says if the NFT collection allowed for voting\r\n     */\r\n    constructor(\r\n        uint256 _startTime,\r\n        uint8 _numRounds,\r\n        uint256 _roundDuration,\r\n        uint256 _roundInterval,\r\n        uint256 _minutesOnDraw,\r\n        uint8 _jackpotPerc,\r\n        uint8 _publicGoodsPerc,\r\n        address _tournamentHub,\r\n        address _lockedNft,\r\n        bool _lockedNftVote\r\n    ) {\r\n        uint8 publicGoodsPerc_;\r\n        uint8 jackpotPerc_;\r\n\r\n        if (_jackpotPerc > 100) jackpotPerc_ = 100;\r\n        else jackpotPerc_ = _jackpotPerc;\r\n        jackpotPerc = jackpotPerc_;\r\n\r\n        // Public Goods needs to be at least 1%\r\n        if (_publicGoodsPerc == 0) publicGoodsPerc_ = 1;\r\n        else if (_publicGoodsPerc > 100) publicGoodsPerc_ = 100;\r\n        else publicGoodsPerc_ = _publicGoodsPerc;\r\n\r\n        publicGoodsPerc = publicGoodsPerc_;\r\n\r\n        startTime = _startTime;\r\n        endTime = _startTime.add(uint256(_numRounds).mul(_roundDuration)).add(\r\n            uint256(_numRounds).sub(1).mul(_roundInterval)\r\n        );\r\n        maxPlayers = 2 ** _numRounds;\r\n        roundDuration = _roundDuration;\r\n        tournamentStatus = StateTournament.Waiting;\r\n        claimed = FeesClaimed.NotClaimed;\r\n        numRounds = _numRounds;\r\n        roundInterval = _roundInterval;\r\n        round = 1;\r\n        totalVoted = 0;\r\n        jackpot = 0;\r\n        finalJackpot = 0;\r\n        fee = 0;\r\n        publicGoods = 0;\r\n        tournamentHub = ITournamentHub(_tournamentHub);\r\n        tournamentFunctions = ITournamentFunctions(\r\n            tournamentHub.tournamentFunctions()\r\n        );\r\n\r\n        tribeToken = IERC20(tournamentHub.tribeXToken());\r\n        lockedNft = _lockedNft;\r\n        lockedNftVote = _lockedNftVote;\r\n        minutesOnDraw = _minutesOnDraw;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the administrator.\r\n     */\r\n    modifier onlyAdministrator() {\r\n        // Check Permissions\r\n        require(tournamentHub.checkAdmin(msg.sender), \"T-01\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than project contracts.\r\n     */\r\n    modifier onlyProject() {\r\n        //Check authorization\r\n        require(tournamentHub.checkProject(msg.sender), \"T-02\");\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////// Tournament and round management\r\n\r\n    /**\r\n     * @dev Sets the tournament as finished\r\n     * @param _canceled is a boolean that says if the tournament was canceled or not\r\n     */\r\n    function _setFinished(bool _canceled) private {\r\n        if (_canceled) tournamentStatus = StateTournament.Canceled;\r\n        else tournamentStatus = StateTournament.Finished;\r\n        tournamentHub.removeOnGoing(address(this));\r\n        emit EndTournamentEvent();\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the tournament\r\n     */\r\n    function startTournament() public onlyAdministrator {\r\n        if (!tournamentFunctions.startTournament(address(this))) {\r\n            _setFinished(true);\r\n            return;\r\n        }\r\n\r\n        //IRound(_roundContract).createMatches();\r\n        emit RoundStarted(round);\r\n\r\n        tournamentStatus = StateTournament.Started;\r\n        emit StartTournamentEvent();\r\n    }\r\n\r\n    /**\r\n     * @dev Starts a round\r\n     */\r\n    function startRound() public onlyAdministrator {\r\n        IRound(getRound[round - 1]).startRound();\r\n\r\n        emit RoundStarted(round);\r\n    }\r\n\r\n    /**\r\n     * @dev Ends the tournament\r\n     */\r\n    function cancelTournament() public onlyAdministrator {\r\n        require(tournamentStatus == StateTournament.Waiting, \"T-08\");\r\n        _setFinished(true);\r\n    }\r\n\r\n    /**\r\n     * @dev Ends a round\r\n     * @return true if the round is ended, false if the round is not ended\r\n     */\r\n    function endRound() public onlyAdministrator returns (bool) {\r\n        finalJackpot = tournamentHub.getTournamentJackpot(address(this));\r\n        bool _roundEnded = tournamentFunctions.endRound(address(this));\r\n        if (_roundEnded) {\r\n            if (round == numRounds) {\r\n                _setFinished(false);\r\n            } else round++;\r\n        }\r\n        return _roundEnded;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds minutes on draw\r\n     */\r\n    function setDraw() public onlyProject {\r\n        endTime = endTime.add(minutesOnDraw);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates some variables of the tournament\r\n     * @param _tFee is the fee of the tournament\r\n     * @param _tJackpot is the jackpot of the tournament\r\n     * @param _tPublicGoods is the public goods of the tournament\r\n     */\r\n    function setVariables(\r\n        uint256 _tFee,\r\n        uint256 _tJackpot,\r\n        uint256 _tPublicGoods\r\n    ) public onlyProject {\r\n        fee = _tFee;\r\n        jackpot = _tJackpot;\r\n        publicGoods = _tPublicGoods;\r\n    }\r\n\r\n    ///////////////////////////////// NFT and token deposits\r\n\r\n    /**\r\n     * @dev ERC721Receiver interface\r\n     * Default function to handle NFTs\r\n     */\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a round to the tournament\r\n     * @param _contract is the address of the round contract\r\n     */\r\n    function addRound(address _contract) public onlyProject {\r\n        getRound.push(_contract);\r\n    }\r\n\r\n    /**\r\n     * @dev Deposits an NFT to the tournament\r\n     * @param _tokenId is the id of the NFT\r\n     * @param _nftContract is the address of the NFT contract\r\n     * @return the id of the player, the address of the player and the id of the NFT\r\n     */\r\n    function depositNFT(\r\n        uint256 _tokenId,\r\n        address _nftContract\r\n    ) public returns (uint256, address, uint256) {\r\n        tournamentFunctions.depositNFT(\r\n            address(this),\r\n            msg.sender,\r\n            _tokenId,\r\n            _nftContract\r\n        );\r\n\r\n        IERC721 nftCollection = IERC721(_nftContract);\r\n        nftCollection.safeTransferFrom(msg.sender, address(this), _tokenId);\r\n\r\n        emit DepositNFTEvent(getPlayer.length - 1, msg.sender, _tokenId);\r\n        return (getPlayer.length - 1, msg.sender, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a NFT to the list\r\n     * @param _encodedNFT is the encoded NFT\r\n     */\r\n    function addNFT(\r\n        bytes memory _encodedNFT,\r\n        address _sender\r\n    ) public onlyProject {\r\n        getNftOwner[_encodedNFT] = _sender;\r\n        getPlayer.push(_encodedNFT);\r\n        getPlayerId[_encodedNFT] = getPlayer.length - 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of players in the tournament\r\n     * @param _amount the amount of tokens to be added to the jackpot\r\n     * @return jackpot the amount of tokens in jackpot\r\n     */\r\n    function increaseJackpot(\r\n        uint256 _amount\r\n    ) public onlyAdministrator returns (uint256) {\r\n        require(\r\n            tournamentStatus == StateTournament.Waiting ||\r\n                tournamentStatus == StateTournament.Started\r\n        );\r\n        tribeToken.transferFrom(msg.sender, address(this), _amount);\r\n\r\n        jackpot = jackpot.add(_amount);\r\n        emit jackpotIncreased(_amount);\r\n        return jackpot;\r\n    }\r\n\r\n    /**\r\n     * @dev Vote for a match\r\n     * @param _matchId is the id of the match\r\n     * @param _nftAddress is the address of the NFT contract\r\n     * @param _tokenId is the id of the NFT\r\n     * @param _amount is the amount of tokens to be used for voting\r\n     * @return the amount of tokens used for voting\r\n     */\r\n    function vote(\r\n        uint256 _matchId,\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        uint256 _amount\r\n    ) public returns (uint256) {\r\n        uint256 _voted = tournamentFunctions.vote(\r\n            address(this),\r\n            msg.sender,\r\n            _matchId,\r\n            _nftAddress,\r\n            _tokenId,\r\n            _amount\r\n        );\r\n\r\n        if (_voted == 0) return 0;\r\n\r\n        tribeToken.transferFrom(msg.sender, address(this), _amount);\r\n        totalVoted = totalVoted.add(_amount);\r\n\r\n        emit VoteInPlayerMatch(round, _matchId, _amount);\r\n        return _amount;\r\n    }\r\n\r\n    /////////////////////////////////  NFT and Tokens claim management\r\n\r\n    /**\r\n     * @dev Changes the owner of an NFT\r\n     * @param _playerId is the id of the player\r\n     * @param _newPlayerId is the id of the new player\r\n     */\r\n    function changeNftOwner(\r\n        uint256 _playerId,\r\n        uint256 _newPlayerId\r\n    ) public onlyProject {\r\n        getNftOwner[getPlayer[_playerId]] = getNftOwner[\r\n            getPlayer[_newPlayerId]\r\n        ];\r\n        getNftUnlocked[getPlayer[_playerId]] = true;\r\n        emit OwnerOfNftChanged(_playerId, _newPlayerId);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim tokens from a match\r\n     * @param _sender is the address of the sender\r\n     * @param _total is the amount of tokens to be claimed\r\n     */\r\n    function claimTokens(address _sender, uint256 _total) public onlyProject {\r\n        tribeToken.transfer(_sender, _total);\r\n    }\r\n\r\n    /**\r\n     * @dev Claims an NFT from the tournament\r\n     * @param _sender is the address of the player\r\n     * @param _tokenId is the id of the NFT\r\n     * @param _nftContract is the address of the NFT contract\r\n     */\r\n    function claimNFT(\r\n        address _sender,\r\n        address _nftContract,\r\n        uint256 _tokenId\r\n    ) public onlyProject {\r\n        IERC721 nftCollection = IERC721(_nftContract);\r\n        nftCollection.safeTransferFrom(address(this), _sender, _tokenId);\r\n        emit WithdrawNFTEvent(_sender, _nftContract, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Claims the public goods and fees to project wallet\r\n     */\r\n    function claimPublicGoods() public onlyAdministrator {\r\n        require(claimed == FeesClaimed.NotClaimed, \"T-07\");\r\n        require(getTournamentStatus() == 2, \"TF-15\");\r\n\r\n        uint256 _publicGoods = publicGoods;\r\n\r\n        IRound _actualRound = IRound(\r\n            getRound[round - 1]\r\n        );\r\n        uint256 _lastRoundVotes = _actualRound.totalVoted();\r\n\r\n        uint256 _balance = IERC20(tribeToken).balanceOf(address(this));\r\n\r\n        if (_lastRoundVotes == 0) {\r\n            tribeToken.transfer(tournamentHub.jackpotWallet(), jackpot);\r\n            _balance.sub(jackpot);\r\n        }\r\n\r\n        tribeToken.transfer(tournamentHub.feeWallet(), fee);\r\n        _balance.sub(fee);\r\n\r\n        if (_balance < _publicGoods) _publicGoods = _balance;\r\n        tribeToken.transfer(tournamentHub.publicGoodsWallet(), _publicGoods);\r\n\r\n        claimed = FeesClaimed.Claimed;\r\n        emit PublicGoodsClaimed();\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the tournament start time\r\n     * @param _time is the time of the start date\r\n     */\r\n    function setStartTime(uint256 _time) public onlyProject {\r\n        startTime = _time;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the tournament end time\r\n     * @param _time is the time of the end date\r\n     */\r\n    function setEndTime(uint256 _time) public onlyProject {\r\n        endTime = _time;\r\n    }\r\n\r\n    /**\r\n     * @dev increase round by one\r\n     */\r\n    function increaseRound() public onlyProject {\r\n        round++;\r\n    }\r\n\r\n    /**\r\n     * @dev Unlocks NFTs of a player\r\n     * @param _lastMatch is the address of the last match\r\n     */\r\n    function unlockNFT(address _lastMatch) public onlyProject {\r\n        getNftUnlocked[IMatch(_lastMatch).getWinner()] = true;\r\n    }\r\n\r\n    //////////////////////////// View functions\r\n\r\n    /**\r\n     * @dev Returns the matches of a round\r\n     * @param _round is the number of the round\r\n     * @return the matches of the round\r\n     */\r\n    function getMatches(uint256 _round) public view returns (bytes[] memory) {\r\n        return IRound(getRound[_round - 1]).getMatchesEncoded();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if the round is started\r\n     * @return true if the round is started, false if the round is not started\r\n     */\r\n    function getRoundStart() public view returns (uint256) {\r\n        return IRound(getRound[round - 1]).roundStart();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if the round is ended\r\n     * @return true if the round is ended, false if the round is not ended\r\n     */\r\n    function getRoundEnd() public view returns (uint256) {\r\n        return IRound(getRound[round - 1]).roundEnd();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the active players of a round\r\n     * @param _round is the number of the round\r\n     * @return array of active players Ids\r\n     */\r\n    function getPlayers(uint256 _round) public view returns (uint256[] memory) {\r\n        return IRound(getRound[_round - 1]).getPlayers();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of deposited NFTs\r\n     * @return 0 for Waiting, 1 for Started, 2 for Finished and 3 for Canceled\r\n     */\r\n    function getTournamentStatus() public view returns (uint8) {\r\n        return uint8(tournamentStatus);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of deposited NFTs\r\n     * @return number of deposited NFTs\r\n     */\r\n    function depositedLength() public view returns (uint256) {\r\n        return getPlayer.length;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ITournamentGenerator.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\n// Interface\r\ninterface ITournamentGenerator {\r\n    event TournamentCreated(address);\r\n    event TournamentHubChanged(address);\r\n\r\n    function createTournament(\r\n        uint256,\r\n        uint8,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint8,\r\n        uint8\r\n    ) external returns (address);\r\n\r\n    function changeTournamentHub(address) external;\r\n}\r\n\r\n// File: contracts/TournamentGenerator.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\n\r\n\r\n\r\n\r\ncontract TournamentGenerator is ITournamentGenerator {\r\n    ITournamentHub private tournamentHub;\r\n    address[] public tournaments;\r\n    bool public activated;\r\n    address private deployer;\r\n\r\n    constructor() {\r\n        deployer = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Generates a new Tournament Contract.\r\n     * @param _startTime Timestamp of the start of the tournament\r\n     * @param _numRounds Number of rounds in the tournament\r\n     * @param _roundDuration Duration of each round in timestamp milliseconds\r\n     * @param _roundInterval Interval between rounds in timestamp milliseconds\r\n     * @param _minutesOnDraw Minutes to add on match draw\r\n     * @param _jackpotPerc Percentage of the jackpot\r\n     * @param _publicGoodsPerc Percentage of the jackpot that goes to public goods\r\n     * @return address of the new Tournament contract\r\n     */\r\n    function createTournament(\r\n        uint256 _startTime,\r\n        uint8 _numRounds,\r\n        uint256 _roundDuration,\r\n        uint256 _roundInterval,\r\n        uint256 _minutesOnDraw,\r\n        uint8 _jackpotPerc,\r\n        uint8 _publicGoodsPerc\r\n    ) public returns (address) {\r\n        //Check if activated\r\n        require(activated, \"TG-01\");\r\n        //Check authorization\r\n        require(tournamentHub.checkAdmin(msg.sender), \"TG-02\");\r\n\r\n        if (_minutesOnDraw < 5) _minutesOnDraw = 5;\r\n        if (_numRounds == 0) _numRounds = 1;\r\n        if (_roundDuration == 0) _roundDuration = 21600000;\r\n        if (_roundInterval == 0) _roundInterval = 21600000;\r\n\r\n        // Create new tournament\r\n        Tournament t = new Tournament(\r\n            _startTime,\r\n            _numRounds,\r\n            _roundDuration,\r\n            _roundInterval,\r\n            _minutesOnDraw,\r\n            _jackpotPerc,\r\n            _publicGoodsPerc,\r\n            address(tournamentHub),\r\n            address(0),\r\n            false\r\n        );\r\n        address tournamentAddress = address(t);\r\n        tournaments.push(tournamentAddress);\r\n        tournamentHub.addContract(tournamentAddress);\r\n        tournamentHub.addOnGoing(tournamentAddress);\r\n\r\n        // Emit event\r\n        emit TournamentCreated(tournamentAddress);\r\n\r\n        // Return address\r\n        return tournamentAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes Tournament Hub contract and activates Generator\r\n     * @param _contract Address of the new Tournament Hub contract\r\n     */\r\n    function changeTournamentHub(address _contract) public {\r\n        // Check Permissions\r\n        if (activated) require(tournamentHub.checkAdmin(msg.sender), \"TG-02\");\r\n        else require(deployer == msg.sender, \"TG-04\");\r\n\r\n        tournamentHub = ITournamentHub(_contract);\r\n        activated = true;\r\n        emit TournamentHubChanged(_contract);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"TournamentCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"TournamentHubChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"changeTournamentHub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_numRounds\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_roundDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roundInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minutesOnDraw\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_jackpotPerc\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_publicGoodsPerc\",\"type\":\"uint8\"}],\"name\":\"createTournament\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tournaments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TournamentGenerator", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://386f434ae0a88913ed1366b17ad14c1869b47f2a2ab5bdcb804a372ef2f3bf6d"}