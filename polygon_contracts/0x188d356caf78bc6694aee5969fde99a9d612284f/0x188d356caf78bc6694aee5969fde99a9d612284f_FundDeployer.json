{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/persistent/dispatcher/IDispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IDispatcher Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IDispatcher {\\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\\n\\n    function claimOwnership() external;\\n\\n    function deployVaultProxy(\\n        address _vaultLib,\\n        address _owner,\\n        address _vaultAccessor,\\n        string calldata _fundName\\n    ) external returns (address vaultProxy_);\\n\\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\\n\\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\\n\\n    function getFundDeployerForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        returns (address fundDeployer_);\\n\\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        returns (\\n            address nextFundDeployer_,\\n            address nextVaultAccessor_,\\n            address nextVaultLib_,\\n            uint256 executableTimestamp_\\n        );\\n\\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\\n\\n    function getNominatedOwner() external view returns (address nominatedOwner_);\\n\\n    function getOwner() external view returns (address owner_);\\n\\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\\n\\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (uint256 secondsRemaining_);\\n\\n    function hasExecutableMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (bool hasExecutableRequest_);\\n\\n    function hasMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (bool hasMigrationRequest_);\\n\\n    function removeNominatedOwner() external;\\n\\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\\n\\n    function setMigrationTimelock(uint256 _nextTimelock) external;\\n\\n    function setNominatedOwner(address _nextNominatedOwner) external;\\n\\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\\n\\n    function signalMigration(\\n        address _vaultProxy,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib,\\n        bool _bypassFailure\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/dispatcher/IMigrationHookHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IMigrationHookHandler Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IMigrationHookHandler {\\n    enum MigrationOutHook {PreSignal, PostSignal, PreMigrate, PostMigrate, PostCancel}\\n\\n    function invokeMigrationInCancelHook(\\n        address _vaultProxy,\\n        address _prevFundDeployer,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib\\n    ) external;\\n\\n    function invokeMigrationOutHook(\\n        MigrationOutHook _hook,\\n        address _vaultProxy,\\n        address _nextFundDeployer,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/interfaces/IExternalPositionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPositionVault interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// Provides an interface to get the externalPositionLib for a given type from the Vault\\ninterface IExternalPositionVault {\\n    function getExternalPositionLibForType(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/interfaces/IFreelyTransferableSharesVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IFreelyTransferableSharesVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Provides the interface for determining whether a vault's shares\\n/// are guaranteed to be freely transferable.\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IFreelyTransferableSharesVault {\\n    function sharesAreFreelyTransferable()\\n        external\\n        view\\n        returns (bool sharesAreFreelyTransferable_);\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/interfaces/IMigratableVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IMigratableVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IMigratableVault {\\n    function canMigrate(address _who) external view returns (bool canMigrate_);\\n\\n    function init(\\n        address _owner,\\n        address _accessor,\\n        string calldata _fundName\\n    ) external;\\n\\n    function setAccessor(address _nextAccessor) external;\\n\\n    function setVaultLib(address _nextVaultLib) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund-deployer/FundDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../../persistent/dispatcher/IDispatcher.sol\\\";\\nimport \\\"../../../persistent/dispatcher/IMigrationHookHandler.sol\\\";\\nimport \\\"../../extensions/IExtension.sol\\\";\\nimport \\\"../../infrastructure/gas-relayer/GasRelayRecipientMixin.sol\\\";\\nimport \\\"../../infrastructure/protocol-fees/IProtocolFeeTracker.sol\\\";\\nimport \\\"../fund/comptroller/ComptrollerProxy.sol\\\";\\nimport \\\"../fund/comptroller/IComptroller.sol\\\";\\nimport \\\"../fund/vault/IVault.sol\\\";\\nimport \\\"./IFundDeployer.sol\\\";\\n\\n/// @title FundDeployer Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice The top-level contract of the release.\\n/// It primarily coordinates fund deployment and fund migration, but\\n/// it is also deferred to for contract access control and for allowed calls\\n/// that can be made with a fund's VaultProxy as the msg.sender.\\ncontract FundDeployer is IFundDeployer, IMigrationHookHandler, GasRelayRecipientMixin {\\n    event BuySharesOnBehalfCallerDeregistered(address caller);\\n\\n    event BuySharesOnBehalfCallerRegistered(address caller);\\n\\n    event ComptrollerLibSet(address comptrollerLib);\\n\\n    event ComptrollerProxyDeployed(\\n        address indexed creator,\\n        address comptrollerProxy,\\n        address indexed denominationAsset,\\n        uint256 sharesActionTimelock\\n    );\\n\\n    event GasLimitsForDestructCallSet(\\n        uint256 nextDeactivateFeeManagerGasLimit,\\n        uint256 nextPayProtocolFeeGasLimit\\n    );\\n\\n    event MigrationRequestCreated(\\n        address indexed creator,\\n        address indexed vaultProxy,\\n        address comptrollerProxy\\n    );\\n\\n    event NewFundCreated(address indexed creator, address vaultProxy, address comptrollerProxy);\\n\\n    event ProtocolFeeTrackerSet(address protocolFeeTracker);\\n\\n    event ReconfigurationRequestCancelled(\\n        address indexed vaultProxy,\\n        address indexed nextComptrollerProxy\\n    );\\n\\n    event ReconfigurationRequestCreated(\\n        address indexed creator,\\n        address indexed vaultProxy,\\n        address comptrollerProxy,\\n        uint256 executableTimestamp\\n    );\\n\\n    event ReconfigurationRequestExecuted(\\n        address indexed vaultProxy,\\n        address indexed prevComptrollerProxy,\\n        address indexed nextComptrollerProxy\\n    );\\n\\n    event ReconfigurationTimelockSet(uint256 nextTimelock);\\n\\n    event ReleaseIsLive();\\n\\n    event VaultCallDeregistered(\\n        address indexed contractAddress,\\n        bytes4 selector,\\n        bytes32 dataHash\\n    );\\n\\n    event VaultCallRegistered(address indexed contractAddress, bytes4 selector, bytes32 dataHash);\\n\\n    event VaultLibSet(address vaultLib);\\n\\n    struct ReconfigurationRequest {\\n        address nextComptrollerProxy;\\n        uint256 executableTimestamp;\\n    }\\n\\n    // Constants\\n    // keccak256(abi.encodePacked(\\\"mln.vaultCall.any\\\")\\n    bytes32\\n        private constant ANY_VAULT_CALL = 0x5bf1898dd28c4d29f33c4c1bb9b8a7e2f6322847d70be63e8f89de024d08a669;\\n\\n    address private immutable CREATOR;\\n    address private immutable DISPATCHER;\\n\\n    // Pseudo-constants (can only be set once)\\n    address private comptrollerLib;\\n    address private protocolFeeTracker;\\n    address private vaultLib;\\n\\n    // Storage\\n    uint32 private gasLimitForDestructCallToDeactivateFeeManager; // Can reduce to uint16\\n    uint32 private gasLimitForDestructCallToPayProtocolFee; // Can reduce to uint16\\n    bool private isLive;\\n    uint256 private reconfigurationTimelock;\\n\\n    mapping(address => bool) private acctToIsAllowedBuySharesOnBehalfCaller;\\n    mapping(bytes32 => mapping(bytes32 => bool)) private vaultCallToPayloadToIsAllowed;\\n    mapping(address => ReconfigurationRequest) private vaultProxyToReconfigurationRequest;\\n\\n    modifier onlyDispatcher() {\\n        require(msg.sender == DISPATCHER, \\\"Only Dispatcher can call this function\\\");\\n        _;\\n    }\\n\\n    modifier onlyLiveRelease() {\\n        require(releaseIsLive(), \\\"Release is not yet live\\\");\\n        _;\\n    }\\n\\n    modifier onlyMigrator(address _vaultProxy) {\\n        __assertIsMigrator(_vaultProxy, __msgSender());\\n        _;\\n    }\\n\\n    modifier onlyMigratorNotRelayable(address _vaultProxy) {\\n        __assertIsMigrator(_vaultProxy, msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == getOwner(), \\\"Only the contract owner can call this function\\\");\\n        _;\\n    }\\n\\n    modifier pseudoConstant(address _storageValue) {\\n        require(_storageValue == address(0), \\\"This value can only be set once\\\");\\n        _;\\n    }\\n\\n    function __assertIsMigrator(address _vaultProxy, address _who) private view {\\n        require(\\n            IVault(_vaultProxy).canMigrate(_who),\\n            \\\"Only a permissioned migrator can call this function\\\"\\n        );\\n    }\\n\\n    constructor(address _dispatcher, address _gasRelayPaymasterFactory)\\n        public\\n        GasRelayRecipientMixin(_gasRelayPaymasterFactory)\\n    {\\n        // Validate constants\\n        require(\\n            ANY_VAULT_CALL == keccak256(abi.encodePacked(\\\"mln.vaultCall.any\\\")),\\n            \\\"constructor: Incorrect ANY_VAULT_CALL\\\"\\n        );\\n\\n        CREATOR = msg.sender;\\n        DISPATCHER = _dispatcher;\\n\\n        // Estimated base call cost: 17k\\n        // Per fee that uses shares outstanding (default recipient): 33k\\n        // 300k accommodates up to 8 such fees\\n        gasLimitForDestructCallToDeactivateFeeManager = 300000;\\n        // Estimated cost: 50k\\n        gasLimitForDestructCallToPayProtocolFee = 200000;\\n\\n        reconfigurationTimelock = 2 days;\\n    }\\n\\n    //////////////////////////////////////\\n    // PSEUDO-CONSTANTS (only set once) //\\n    //////////////////////////////////////\\n\\n    /// @notice Sets the ComptrollerLib\\n    /// @param _comptrollerLib The ComptrollerLib contract address\\n    function setComptrollerLib(address _comptrollerLib)\\n        external\\n        onlyOwner\\n        pseudoConstant(getComptrollerLib())\\n    {\\n        comptrollerLib = _comptrollerLib;\\n\\n        emit ComptrollerLibSet(_comptrollerLib);\\n    }\\n\\n    /// @notice Sets the ProtocolFeeTracker\\n    /// @param _protocolFeeTracker The ProtocolFeeTracker contract address\\n    function setProtocolFeeTracker(address _protocolFeeTracker)\\n        external\\n        onlyOwner\\n        pseudoConstant(getProtocolFeeTracker())\\n    {\\n        protocolFeeTracker = _protocolFeeTracker;\\n\\n        emit ProtocolFeeTrackerSet(_protocolFeeTracker);\\n    }\\n\\n    /// @notice Sets the VaultLib\\n    /// @param _vaultLib The VaultLib contract address\\n    function setVaultLib(address _vaultLib) external onlyOwner pseudoConstant(getVaultLib()) {\\n        vaultLib = _vaultLib;\\n\\n        emit VaultLibSet(_vaultLib);\\n    }\\n\\n    /////////////\\n    // GENERAL //\\n    /////////////\\n\\n    /// @notice Gets the current owner of the contract\\n    /// @return owner_ The contract owner address\\n    /// @dev The owner is initially the contract's creator, for convenience in setting up configuration.\\n    /// Ownership is handed-off when the creator calls setReleaseLive().\\n    function getOwner() public view override returns (address owner_) {\\n        if (!releaseIsLive()) {\\n            return getCreator();\\n        }\\n\\n        return IDispatcher(getDispatcher()).getOwner();\\n    }\\n\\n    /// @notice Sets the amounts of gas to forward to each of the ComptrollerLib.destructActivated() external calls\\n    /// @param _nextDeactivateFeeManagerGasLimit The amount of gas to forward to deactivate the FeeManager\\n    /// @param _nextPayProtocolFeeGasLimit The amount of gas to forward to pay the protocol fee\\n    function setGasLimitsForDestructCall(\\n        uint32 _nextDeactivateFeeManagerGasLimit,\\n        uint32 _nextPayProtocolFeeGasLimit\\n    ) external onlyOwner {\\n        require(\\n            _nextDeactivateFeeManagerGasLimit > 0 && _nextPayProtocolFeeGasLimit > 0,\\n            \\\"setGasLimitsForDestructCall: Zero value not allowed\\\"\\n        );\\n\\n        gasLimitForDestructCallToDeactivateFeeManager = _nextDeactivateFeeManagerGasLimit;\\n        gasLimitForDestructCallToPayProtocolFee = _nextPayProtocolFeeGasLimit;\\n\\n        emit GasLimitsForDestructCallSet(\\n            _nextDeactivateFeeManagerGasLimit,\\n            _nextPayProtocolFeeGasLimit\\n        );\\n    }\\n\\n    /// @notice Sets the release as live\\n    /// @dev A live release allows funds to be created and migrated once this contract\\n    /// is set as the Dispatcher.currentFundDeployer\\n    function setReleaseLive() external {\\n        require(\\n            msg.sender == getCreator(),\\n            \\\"setReleaseLive: Only the creator can call this function\\\"\\n        );\\n        require(!releaseIsLive(), \\\"setReleaseLive: Already live\\\");\\n\\n        // All pseudo-constants should be set\\n        require(getComptrollerLib() != address(0), \\\"setReleaseLive: comptrollerLib is not set\\\");\\n        require(\\n            getProtocolFeeTracker() != address(0),\\n            \\\"setReleaseLive: protocolFeeTracker is not set\\\"\\n        );\\n        require(getVaultLib() != address(0), \\\"setReleaseLive: vaultLib is not set\\\");\\n\\n        isLive = true;\\n\\n        emit ReleaseIsLive();\\n    }\\n\\n    /// @dev Helper to call ComptrollerProxy.destructActivated() with the correct params\\n    function __destructActivatedComptrollerProxy(address _comptrollerProxy) private {\\n        (\\n            uint256 deactivateFeeManagerGasLimit,\\n            uint256 payProtocolFeeGasLimit\\n        ) = getGasLimitsForDestructCall();\\n        IComptroller(_comptrollerProxy).destructActivated(\\n            deactivateFeeManagerGasLimit,\\n            payProtocolFeeGasLimit\\n        );\\n    }\\n\\n    ///////////////////\\n    // FUND CREATION //\\n    ///////////////////\\n\\n    /// @notice Creates a fully-configured ComptrollerProxy instance for a VaultProxy and signals the migration process\\n    /// @param _vaultProxy The VaultProxy to migrate\\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \\\"shares actions\\\"\\n    /// (buying or selling shares) by the same user\\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\\n    /// @param _bypassPrevReleaseFailure True if should override a failure in the previous release while signaling migration\\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\\n    function createMigrationRequest(\\n        address _vaultProxy,\\n        address _denominationAsset,\\n        uint256 _sharesActionTimelock,\\n        bytes calldata _feeManagerConfigData,\\n        bytes calldata _policyManagerConfigData,\\n        bool _bypassPrevReleaseFailure\\n    )\\n        external\\n        onlyLiveRelease\\n        onlyMigratorNotRelayable(_vaultProxy)\\n        returns (address comptrollerProxy_)\\n    {\\n        // Bad _vaultProxy value is validated by Dispatcher.signalMigration()\\n\\n        require(\\n            !IDispatcher(getDispatcher()).hasMigrationRequest(_vaultProxy),\\n            \\\"createMigrationRequest: A MigrationRequest already exists\\\"\\n        );\\n\\n        comptrollerProxy_ = __deployComptrollerProxy(\\n            msg.sender,\\n            _denominationAsset,\\n            _sharesActionTimelock\\n        );\\n\\n        IComptroller(comptrollerProxy_).setVaultProxy(_vaultProxy);\\n\\n        __configureExtensions(\\n            comptrollerProxy_,\\n            _vaultProxy,\\n            _feeManagerConfigData,\\n            _policyManagerConfigData\\n        );\\n\\n        IDispatcher(getDispatcher()).signalMigration(\\n            _vaultProxy,\\n            comptrollerProxy_,\\n            getVaultLib(),\\n            _bypassPrevReleaseFailure\\n        );\\n\\n        emit MigrationRequestCreated(msg.sender, _vaultProxy, comptrollerProxy_);\\n\\n        return comptrollerProxy_;\\n    }\\n\\n    /// @notice Creates a new fund\\n    /// @param _fundOwner The address of the owner for the fund\\n    /// @param _fundName The name of the fund's shares token\\n    /// @param _fundSymbol The symbol of the fund's shares token\\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \\\"shares actions\\\"\\n    /// (buying or selling shares) by the same user\\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\\n    function createNewFund(\\n        address _fundOwner,\\n        string calldata _fundName,\\n        string calldata _fundSymbol,\\n        address _denominationAsset,\\n        uint256 _sharesActionTimelock,\\n        bytes calldata _feeManagerConfigData,\\n        bytes calldata _policyManagerConfigData\\n    ) external onlyLiveRelease returns (address comptrollerProxy_, address vaultProxy_) {\\n        // _fundOwner is validated by VaultLib.__setOwner()\\n        address canonicalSender = __msgSender();\\n\\n        comptrollerProxy_ = __deployComptrollerProxy(\\n            canonicalSender,\\n            _denominationAsset,\\n            _sharesActionTimelock\\n        );\\n\\n        vaultProxy_ = __deployVaultProxy(_fundOwner, comptrollerProxy_, _fundName, _fundSymbol);\\n\\n        IComptroller comptrollerContract = IComptroller(comptrollerProxy_);\\n        comptrollerContract.setVaultProxy(vaultProxy_);\\n\\n        __configureExtensions(\\n            comptrollerProxy_,\\n            vaultProxy_,\\n            _feeManagerConfigData,\\n            _policyManagerConfigData\\n        );\\n\\n        comptrollerContract.activate(false);\\n\\n        IProtocolFeeTracker(getProtocolFeeTracker()).initializeForVault(vaultProxy_);\\n\\n        emit NewFundCreated(canonicalSender, vaultProxy_, comptrollerProxy_);\\n\\n        return (comptrollerProxy_, vaultProxy_);\\n    }\\n\\n    /// @notice Creates a fully-configured ComptrollerProxy instance for a VaultProxy and signals the reconfiguration process\\n    /// @param _vaultProxy The VaultProxy to reconfigure\\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \\\"shares actions\\\"\\n    /// (buying or selling shares) by the same user\\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\\n    function createReconfigurationRequest(\\n        address _vaultProxy,\\n        address _denominationAsset,\\n        uint256 _sharesActionTimelock,\\n        bytes calldata _feeManagerConfigData,\\n        bytes calldata _policyManagerConfigData\\n    ) external returns (address comptrollerProxy_) {\\n        address canonicalSender = __msgSender();\\n        __assertIsMigrator(_vaultProxy, canonicalSender);\\n        require(\\n            IDispatcher(getDispatcher()).getFundDeployerForVaultProxy(_vaultProxy) ==\\n                address(this),\\n            \\\"createReconfigurationRequest: VaultProxy not on this release\\\"\\n        );\\n        require(\\n            !hasReconfigurationRequest(_vaultProxy),\\n            \\\"createReconfigurationRequest: VaultProxy has a pending reconfiguration request\\\"\\n        );\\n\\n        comptrollerProxy_ = __deployComptrollerProxy(\\n            canonicalSender,\\n            _denominationAsset,\\n            _sharesActionTimelock\\n        );\\n\\n        IComptroller(comptrollerProxy_).setVaultProxy(_vaultProxy);\\n\\n        __configureExtensions(\\n            comptrollerProxy_,\\n            _vaultProxy,\\n            _feeManagerConfigData,\\n            _policyManagerConfigData\\n        );\\n\\n        uint256 executableTimestamp = block.timestamp + getReconfigurationTimelock();\\n        vaultProxyToReconfigurationRequest[_vaultProxy] = ReconfigurationRequest({\\n            nextComptrollerProxy: comptrollerProxy_,\\n            executableTimestamp: executableTimestamp\\n        });\\n\\n        emit ReconfigurationRequestCreated(\\n            canonicalSender,\\n            _vaultProxy,\\n            comptrollerProxy_,\\n            executableTimestamp\\n        );\\n\\n        return comptrollerProxy_;\\n    }\\n\\n    /// @dev Helper function to configure the Extensions for a given ComptrollerProxy\\n    function __configureExtensions(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes memory _feeManagerConfigData,\\n        bytes memory _policyManagerConfigData\\n    ) private {\\n        // Since fees can only be set in this step, if there are no fees, there is no need to set the validated VaultProxy\\n        if (_feeManagerConfigData.length > 0) {\\n            IExtension(IComptroller(_comptrollerProxy).getFeeManager()).setConfigForFund(\\n                _comptrollerProxy,\\n                _vaultProxy,\\n                _feeManagerConfigData\\n            );\\n        }\\n\\n        // For all other extensions, we call to cache the validated VaultProxy, for simplicity.\\n        // In the future, we can consider caching conditionally.\\n        IExtension(IComptroller(_comptrollerProxy).getExternalPositionManager()).setConfigForFund(\\n            _comptrollerProxy,\\n            _vaultProxy,\\n            \\\"\\\"\\n        );\\n        IExtension(IComptroller(_comptrollerProxy).getIntegrationManager()).setConfigForFund(\\n            _comptrollerProxy,\\n            _vaultProxy,\\n            \\\"\\\"\\n        );\\n        IExtension(IComptroller(_comptrollerProxy).getPolicyManager()).setConfigForFund(\\n            _comptrollerProxy,\\n            _vaultProxy,\\n            _policyManagerConfigData\\n        );\\n    }\\n\\n    /// @dev Helper function to deploy a configured ComptrollerProxy\\n    function __deployComptrollerProxy(\\n        address _canonicalSender,\\n        address _denominationAsset,\\n        uint256 _sharesActionTimelock\\n    ) private returns (address comptrollerProxy_) {\\n        // _denominationAsset is validated by ComptrollerLib.init()\\n\\n        bytes memory constructData = abi.encodeWithSelector(\\n            IComptroller.init.selector,\\n            _denominationAsset,\\n            _sharesActionTimelock\\n        );\\n        comptrollerProxy_ = address(new ComptrollerProxy(constructData, getComptrollerLib()));\\n\\n        emit ComptrollerProxyDeployed(\\n            _canonicalSender,\\n            comptrollerProxy_,\\n            _denominationAsset,\\n            _sharesActionTimelock\\n        );\\n\\n        return comptrollerProxy_;\\n    }\\n\\n    /// @dev Helper to deploy a new VaultProxy instance during fund creation.\\n    /// Avoids stack-too-deep error.\\n    function __deployVaultProxy(\\n        address _fundOwner,\\n        address _comptrollerProxy,\\n        string calldata _fundName,\\n        string calldata _fundSymbol\\n    ) private returns (address vaultProxy_) {\\n        vaultProxy_ = IDispatcher(getDispatcher()).deployVaultProxy(\\n            getVaultLib(),\\n            _fundOwner,\\n            _comptrollerProxy,\\n            _fundName\\n        );\\n        if (bytes(_fundSymbol).length != 0) {\\n            IVault(vaultProxy_).setSymbol(_fundSymbol);\\n        }\\n\\n        return vaultProxy_;\\n    }\\n\\n    ///////////////////////////////////////////////\\n    // RECONFIGURATION (INTRA-RELEASE MIGRATION) //\\n    ///////////////////////////////////////////////\\n\\n    /// @notice Cancels a pending reconfiguration request\\n    /// @param _vaultProxy The VaultProxy contract for which to cancel the reconfiguration request\\n    function cancelReconfiguration(address _vaultProxy) external onlyMigrator(_vaultProxy) {\\n        address nextComptrollerProxy = vaultProxyToReconfigurationRequest[_vaultProxy]\\n            .nextComptrollerProxy;\\n        require(\\n            nextComptrollerProxy != address(0),\\n            \\\"cancelReconfiguration: No reconfiguration request exists for _vaultProxy\\\"\\n        );\\n\\n        // Destroy the nextComptrollerProxy\\n        IComptroller(nextComptrollerProxy).destructUnactivated();\\n\\n        // Remove the reconfiguration request\\n        delete vaultProxyToReconfigurationRequest[_vaultProxy];\\n\\n        emit ReconfigurationRequestCancelled(_vaultProxy, nextComptrollerProxy);\\n    }\\n\\n    /// @notice Executes a pending reconfiguration request\\n    /// @param _vaultProxy The VaultProxy contract for which to execute the reconfiguration request\\n    /// @dev ProtocolFeeTracker.initializeForVault() does not need to be included in a reconfiguration,\\n    /// as it refers to the vault and not the new ComptrollerProxy\\n    function executeReconfiguration(address _vaultProxy) external onlyMigrator(_vaultProxy) {\\n        ReconfigurationRequest memory request = getReconfigurationRequestForVaultProxy(\\n            _vaultProxy\\n        );\\n        require(\\n            request.nextComptrollerProxy != address(0),\\n            \\\"executeReconfiguration: No reconfiguration request exists for _vaultProxy\\\"\\n        );\\n        require(\\n            block.timestamp >= request.executableTimestamp,\\n            \\\"executeReconfiguration: The reconfiguration timelock has not elapsed\\\"\\n        );\\n        // Not technically necessary, but a nice assurance\\n        require(\\n            IDispatcher(getDispatcher()).getFundDeployerForVaultProxy(_vaultProxy) ==\\n                address(this),\\n            \\\"executeReconfiguration: _vaultProxy is no longer on this release\\\"\\n        );\\n\\n        // Unwind and destroy the prevComptrollerProxy before setting the nextComptrollerProxy as the VaultProxy.accessor\\n        address prevComptrollerProxy = IVault(_vaultProxy).getAccessor();\\n        address paymaster = IComptroller(prevComptrollerProxy).getGasRelayPaymaster();\\n        __destructActivatedComptrollerProxy(prevComptrollerProxy);\\n\\n        // Execute the reconfiguration\\n        IVault(_vaultProxy).setAccessorForFundReconfiguration(request.nextComptrollerProxy);\\n\\n        // Activate the new ComptrollerProxy\\n        IComptroller(request.nextComptrollerProxy).activate(true);\\n        if (paymaster != address(0)) {\\n            IComptroller(request.nextComptrollerProxy).setGasRelayPaymaster(paymaster);\\n        }\\n\\n        // Remove the reconfiguration request\\n        delete vaultProxyToReconfigurationRequest[_vaultProxy];\\n\\n        emit ReconfigurationRequestExecuted(\\n            _vaultProxy,\\n            prevComptrollerProxy,\\n            request.nextComptrollerProxy\\n        );\\n    }\\n\\n    /// @notice Sets a new reconfiguration timelock\\n    /// @param _nextTimelock The number of seconds for the new timelock\\n    function setReconfigurationTimelock(uint256 _nextTimelock) external onlyOwner {\\n        reconfigurationTimelock = _nextTimelock;\\n\\n        emit ReconfigurationTimelockSet(_nextTimelock);\\n    }\\n\\n    //////////////////\\n    // MIGRATION IN //\\n    //////////////////\\n\\n    /// @notice Cancels fund migration\\n    /// @param _vaultProxy The VaultProxy for which to cancel migration\\n    /// @param _bypassPrevReleaseFailure True if should override a failure in the previous release while canceling migration\\n    function cancelMigration(address _vaultProxy, bool _bypassPrevReleaseFailure)\\n        external\\n        onlyMigratorNotRelayable(_vaultProxy)\\n    {\\n        IDispatcher(getDispatcher()).cancelMigration(_vaultProxy, _bypassPrevReleaseFailure);\\n    }\\n\\n    /// @notice Executes fund migration\\n    /// @param _vaultProxy The VaultProxy for which to execute the migration\\n    /// @param _bypassPrevReleaseFailure True if should override a failure in the previous release while executing migration\\n    function executeMigration(address _vaultProxy, bool _bypassPrevReleaseFailure)\\n        external\\n        onlyMigratorNotRelayable(_vaultProxy)\\n    {\\n        IDispatcher dispatcherContract = IDispatcher(getDispatcher());\\n\\n        (, address comptrollerProxy, , ) = dispatcherContract\\n            .getMigrationRequestDetailsForVaultProxy(_vaultProxy);\\n\\n        dispatcherContract.executeMigration(_vaultProxy, _bypassPrevReleaseFailure);\\n\\n        IComptroller(comptrollerProxy).activate(true);\\n\\n        IProtocolFeeTracker(getProtocolFeeTracker()).initializeForVault(_vaultProxy);\\n    }\\n\\n    /// @notice Executes logic when a migration is canceled on the Dispatcher\\n    /// @param _nextComptrollerProxy The ComptrollerProxy created on this release\\n    function invokeMigrationInCancelHook(\\n        address,\\n        address,\\n        address _nextComptrollerProxy,\\n        address\\n    ) external override onlyDispatcher {\\n        IComptroller(_nextComptrollerProxy).destructUnactivated();\\n    }\\n\\n    ///////////////////\\n    // MIGRATION OUT //\\n    ///////////////////\\n\\n    /// @notice Allows \\\"hooking into\\\" specific moments in the migration pipeline\\n    /// to execute arbitrary logic during a migration out of this release\\n    /// @param _vaultProxy The VaultProxy being migrated\\n    function invokeMigrationOutHook(\\n        MigrationOutHook _hook,\\n        address _vaultProxy,\\n        address,\\n        address,\\n        address\\n    ) external override onlyDispatcher {\\n        if (_hook != MigrationOutHook.PreMigrate) {\\n            return;\\n        }\\n\\n        // Must use PreMigrate hook to get the ComptrollerProxy from the VaultProxy\\n        address comptrollerProxy = IVault(_vaultProxy).getAccessor();\\n\\n        // Wind down fund and destroy its config\\n        __destructActivatedComptrollerProxy(comptrollerProxy);\\n    }\\n\\n    //////////////\\n    // REGISTRY //\\n    //////////////\\n\\n    // BUY SHARES CALLERS\\n\\n    /// @notice Deregisters allowed callers of ComptrollerProxy.buySharesOnBehalf()\\n    /// @param _callers The callers to deregister\\n    function deregisterBuySharesOnBehalfCallers(address[] calldata _callers) external onlyOwner {\\n        for (uint256 i; i < _callers.length; i++) {\\n            require(\\n                isAllowedBuySharesOnBehalfCaller(_callers[i]),\\n                \\\"deregisterBuySharesOnBehalfCallers: Caller not registered\\\"\\n            );\\n\\n            acctToIsAllowedBuySharesOnBehalfCaller[_callers[i]] = false;\\n\\n            emit BuySharesOnBehalfCallerDeregistered(_callers[i]);\\n        }\\n    }\\n\\n    /// @notice Registers allowed callers of ComptrollerProxy.buySharesOnBehalf()\\n    /// @param _callers The allowed callers\\n    /// @dev Validate that each registered caller only forwards requests to buy shares that\\n    /// originate from the same _buyer passed into buySharesOnBehalf(). This is critical\\n    /// to the integrity of VaultProxy.freelyTransferableShares.\\n    function registerBuySharesOnBehalfCallers(address[] calldata _callers) external onlyOwner {\\n        for (uint256 i; i < _callers.length; i++) {\\n            require(\\n                !isAllowedBuySharesOnBehalfCaller(_callers[i]),\\n                \\\"registerBuySharesOnBehalfCallers: Caller already registered\\\"\\n            );\\n\\n            acctToIsAllowedBuySharesOnBehalfCaller[_callers[i]] = true;\\n\\n            emit BuySharesOnBehalfCallerRegistered(_callers[i]);\\n        }\\n    }\\n\\n    // VAULT CALLS\\n\\n    /// @notice De-registers allowed arbitrary contract calls that can be sent from the VaultProxy\\n    /// @param _contracts The contracts of the calls to de-register\\n    /// @param _selectors The selectors of the calls to de-register\\n    /// @param _dataHashes The keccak call data hashes of the calls to de-register\\n    /// @dev ANY_VAULT_CALL is a wildcard that allows any payload\\n    function deregisterVaultCalls(\\n        address[] calldata _contracts,\\n        bytes4[] calldata _selectors,\\n        bytes32[] memory _dataHashes\\n    ) external onlyOwner {\\n        require(_contracts.length > 0, \\\"deregisterVaultCalls: Empty _contracts\\\");\\n        require(\\n            _contracts.length == _selectors.length && _contracts.length == _dataHashes.length,\\n            \\\"deregisterVaultCalls: Uneven input arrays\\\"\\n        );\\n\\n        for (uint256 i; i < _contracts.length; i++) {\\n            require(\\n                isRegisteredVaultCall(_contracts[i], _selectors[i], _dataHashes[i]),\\n                \\\"deregisterVaultCalls: Call not registered\\\"\\n            );\\n\\n            vaultCallToPayloadToIsAllowed[keccak256(\\n                abi.encodePacked(_contracts[i], _selectors[i])\\n            )][_dataHashes[i]] = false;\\n\\n            emit VaultCallDeregistered(_contracts[i], _selectors[i], _dataHashes[i]);\\n        }\\n    }\\n\\n    /// @notice Registers allowed arbitrary contract calls that can be sent from the VaultProxy\\n    /// @param _contracts The contracts of the calls to register\\n    /// @param _selectors The selectors of the calls to register\\n    /// @param _dataHashes The keccak call data hashes of the calls to register\\n    /// @dev ANY_VAULT_CALL is a wildcard that allows any payload\\n    function registerVaultCalls(\\n        address[] calldata _contracts,\\n        bytes4[] calldata _selectors,\\n        bytes32[] memory _dataHashes\\n    ) external onlyOwner {\\n        require(_contracts.length > 0, \\\"registerVaultCalls: Empty _contracts\\\");\\n        require(\\n            _contracts.length == _selectors.length && _contracts.length == _dataHashes.length,\\n            \\\"registerVaultCalls: Uneven input arrays\\\"\\n        );\\n\\n        for (uint256 i; i < _contracts.length; i++) {\\n            require(\\n                !isRegisteredVaultCall(_contracts[i], _selectors[i], _dataHashes[i]),\\n                \\\"registerVaultCalls: Call already registered\\\"\\n            );\\n\\n            vaultCallToPayloadToIsAllowed[keccak256(\\n                abi.encodePacked(_contracts[i], _selectors[i])\\n            )][_dataHashes[i]] = true;\\n\\n            emit VaultCallRegistered(_contracts[i], _selectors[i], _dataHashes[i]);\\n        }\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @notice Checks if a contract call is allowed\\n    /// @param _contract The contract of the call to check\\n    /// @param _selector The selector of the call to check\\n    /// @param _dataHash The keccak call data hash of the call to check\\n    /// @return isAllowed_ True if the call is allowed\\n    /// @dev A vault call is allowed if the _dataHash is specifically allowed,\\n    /// or if any _dataHash is allowed\\n    function isAllowedVaultCall(\\n        address _contract,\\n        bytes4 _selector,\\n        bytes32 _dataHash\\n    ) external view override returns (bool isAllowed_) {\\n        bytes32 contractFunctionHash = keccak256(abi.encodePacked(_contract, _selector));\\n\\n        return\\n            vaultCallToPayloadToIsAllowed[contractFunctionHash][_dataHash] ||\\n            vaultCallToPayloadToIsAllowed[contractFunctionHash][ANY_VAULT_CALL];\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n\\n    /// @notice Gets the `comptrollerLib` variable value\\n    /// @return comptrollerLib_ The `comptrollerLib` variable value\\n    function getComptrollerLib() public view returns (address comptrollerLib_) {\\n        return comptrollerLib;\\n    }\\n\\n    /// @notice Gets the `CREATOR` variable value\\n    /// @return creator_ The `CREATOR` variable value\\n    function getCreator() public view returns (address creator_) {\\n        return CREATOR;\\n    }\\n\\n    /// @notice Gets the `DISPATCHER` variable value\\n    /// @return dispatcher_ The `DISPATCHER` variable value\\n    function getDispatcher() public view returns (address dispatcher_) {\\n        return DISPATCHER;\\n    }\\n\\n    /// @notice Gets the amounts of gas to forward to each of the ComptrollerLib.destructActivated() external calls\\n    /// @return deactivateFeeManagerGasLimit_ The amount of gas to forward to deactivate the FeeManager\\n    /// @return payProtocolFeeGasLimit_ The amount of gas to forward to pay the protocol fee\\n    function getGasLimitsForDestructCall()\\n        public\\n        view\\n        returns (uint256 deactivateFeeManagerGasLimit_, uint256 payProtocolFeeGasLimit_)\\n    {\\n        return (\\n            gasLimitForDestructCallToDeactivateFeeManager,\\n            gasLimitForDestructCallToPayProtocolFee\\n        );\\n    }\\n\\n    /// @notice Gets the `protocolFeeTracker` variable value\\n    /// @return protocolFeeTracker_ The `protocolFeeTracker` variable value\\n    function getProtocolFeeTracker() public view returns (address protocolFeeTracker_) {\\n        return protocolFeeTracker;\\n    }\\n\\n    /// @notice Gets the pending ReconfigurationRequest for a given VaultProxy\\n    /// @param _vaultProxy The VaultProxy instance\\n    /// @return reconfigurationRequest_ The pending ReconfigurationRequest\\n    function getReconfigurationRequestForVaultProxy(address _vaultProxy)\\n        public\\n        view\\n        returns (ReconfigurationRequest memory reconfigurationRequest_)\\n    {\\n        return vaultProxyToReconfigurationRequest[_vaultProxy];\\n    }\\n\\n    /// @notice Gets the amount of time that must pass before executing a ReconfigurationRequest\\n    /// @return reconfigurationTimelock_ The timelock value (in seconds)\\n    function getReconfigurationTimelock() public view returns (uint256 reconfigurationTimelock_) {\\n        return reconfigurationTimelock;\\n    }\\n\\n    /// @notice Gets the `vaultLib` variable value\\n    /// @return vaultLib_ The `vaultLib` variable value\\n    function getVaultLib() public view returns (address vaultLib_) {\\n        return vaultLib;\\n    }\\n\\n    /// @notice Checks whether a ReconfigurationRequest exists for a given VaultProxy\\n    /// @param _vaultProxy The VaultProxy instance\\n    /// @return hasReconfigurationRequest_ True if a ReconfigurationRequest exists\\n    function hasReconfigurationRequest(address _vaultProxy)\\n        public\\n        view\\n        override\\n        returns (bool hasReconfigurationRequest_)\\n    {\\n        return vaultProxyToReconfigurationRequest[_vaultProxy].nextComptrollerProxy != address(0);\\n    }\\n\\n    /// @notice Checks if an account is an allowed caller of ComptrollerProxy.buySharesOnBehalf()\\n    /// @param _who The account to check\\n    /// @return isAllowed_ True if the account is an allowed caller\\n    function isAllowedBuySharesOnBehalfCaller(address _who)\\n        public\\n        view\\n        override\\n        returns (bool isAllowed_)\\n    {\\n        return acctToIsAllowedBuySharesOnBehalfCaller[_who];\\n    }\\n\\n    /// @notice Checks if a contract call is registered\\n    /// @param _contract The contract of the call to check\\n    /// @param _selector The selector of the call to check\\n    /// @param _dataHash The keccak call data hash of the call to check\\n    /// @return isRegistered_ True if the call is registered\\n    function isRegisteredVaultCall(\\n        address _contract,\\n        bytes4 _selector,\\n        bytes32 _dataHash\\n    ) public view returns (bool isRegistered_) {\\n        return\\n            vaultCallToPayloadToIsAllowed[keccak256(\\n                abi.encodePacked(_contract, _selector)\\n            )][_dataHash];\\n    }\\n\\n    /// @notice Gets the `isLive` variable value\\n    /// @return isLive_ The `isLive` variable value\\n    function releaseIsLive() public view returns (bool isLive_) {\\n        return isLive;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund-deployer/IFundDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IFundDeployer Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IFundDeployer {\\n    function getOwner() external view returns (address);\\n\\n    function hasReconfigurationRequest(address) external view returns (bool);\\n\\n    function isAllowedBuySharesOnBehalfCaller(address) external view returns (bool);\\n\\n    function isAllowedVaultCall(\\n        address,\\n        bytes4,\\n        bytes32\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund/comptroller/ComptrollerProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../../utils/NonUpgradableProxy.sol\\\";\\n\\n/// @title ComptrollerProxy Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A proxy contract for all ComptrollerProxy instances\\ncontract ComptrollerProxy is NonUpgradableProxy {\\n    constructor(bytes memory _constructData, address _comptrollerLib)\\n        public\\n        NonUpgradableProxy(_constructData, _comptrollerLib)\\n    {}\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund/comptroller/IComptroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../vault/IVault.sol\\\";\\n\\n/// @title IComptroller Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IComptroller {\\n    function activate(bool) external;\\n\\n    function calcGav() external returns (uint256);\\n\\n    function calcGrossShareValue() external returns (uint256);\\n\\n    function callOnExtension(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external;\\n\\n    function destructActivated(uint256, uint256) external;\\n\\n    function destructUnactivated() external;\\n\\n    function getDenominationAsset() external view returns (address);\\n\\n    function getExternalPositionManager() external view returns (address);\\n\\n    function getFeeManager() external view returns (address);\\n\\n    function getFundDeployer() external view returns (address);\\n\\n    function getGasRelayPaymaster() external view returns (address);\\n\\n    function getIntegrationManager() external view returns (address);\\n\\n    function getPolicyManager() external view returns (address);\\n\\n    function getVaultProxy() external view returns (address);\\n\\n    function init(address, uint256) external;\\n\\n    function permissionedVaultAction(IVault.VaultAction, bytes calldata) external;\\n\\n    function preTransferSharesHook(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function preTransferSharesHookFreelyTransferable(address) external view;\\n\\n    function setGasRelayPaymaster(address) external;\\n\\n    function setVaultProxy(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund/vault/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../../../persistent/vault/interfaces/IExternalPositionVault.sol\\\";\\nimport \\\"../../../../persistent/vault/interfaces/IFreelyTransferableSharesVault.sol\\\";\\nimport \\\"../../../../persistent/vault/interfaces/IMigratableVault.sol\\\";\\n\\n/// @title IVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IVault is IMigratableVault, IFreelyTransferableSharesVault, IExternalPositionVault {\\n    enum VaultAction {\\n        None,\\n        // Shares management\\n        BurnShares,\\n        MintShares,\\n        TransferShares,\\n        // Asset management\\n        AddTrackedAsset,\\n        ApproveAssetSpender,\\n        RemoveTrackedAsset,\\n        WithdrawAssetTo,\\n        // External position management\\n        AddExternalPosition,\\n        CallOnExternalPosition,\\n        RemoveExternalPosition\\n    }\\n\\n    function addTrackedAsset(address) external;\\n\\n    function burnShares(address, uint256) external;\\n\\n    function buyBackProtocolFeeShares(\\n        uint256,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function callOnContract(address, bytes calldata) external returns (bytes memory);\\n\\n    function canManageAssets(address) external view returns (bool);\\n\\n    function canRelayCalls(address) external view returns (bool);\\n\\n    function getAccessor() external view returns (address);\\n\\n    function getOwner() external view returns (address);\\n\\n    function getActiveExternalPositions() external view returns (address[] memory);\\n\\n    function getTrackedAssets() external view returns (address[] memory);\\n\\n    function isActiveExternalPosition(address) external view returns (bool);\\n\\n    function isTrackedAsset(address) external view returns (bool);\\n\\n    function mintShares(address, uint256) external;\\n\\n    function payProtocolFee() external;\\n\\n    function receiveValidatedVaultAction(VaultAction, bytes calldata) external;\\n\\n    function setAccessorForFundReconfiguration(address) external;\\n\\n    function setSymbol(string calldata) external;\\n\\n    function transferShares(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function withdrawAssetTo(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/IExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExtension Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for all extensions\\ninterface IExtension {\\n    function activateForFund(bool _isMigration) external;\\n\\n    function deactivateForFund() external;\\n\\n    function receiveCallFromComptroller(\\n        address _caller,\\n        uint256 _actionId,\\n        bytes calldata _callArgs\\n    ) external;\\n\\n    function setConfigForFund(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes calldata _configData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/gas-relayer/GasRelayRecipientMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\nimport \\\"../../utils/beacon-proxy/IBeaconProxyFactory.sol\\\";\\nimport \\\"./IGasRelayPaymaster.sol\\\";\\n\\npragma solidity 0.6.12;\\n\\n/// @title GasRelayRecipientMixin Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A mixin that enables receiving GSN-relayed calls\\n/// @dev IMPORTANT: Do not use storage var in this contract,\\n/// unless it is no longer inherited by the VaultLib\\nabstract contract GasRelayRecipientMixin {\\n    address internal immutable GAS_RELAY_PAYMASTER_FACTORY;\\n\\n    constructor(address _gasRelayPaymasterFactory) internal {\\n        GAS_RELAY_PAYMASTER_FACTORY = _gasRelayPaymasterFactory;\\n    }\\n\\n    /// @dev Helper to parse the canonical sender of a tx based on whether it has been relayed\\n    function __msgSender() internal view returns (address payable canonicalSender_) {\\n        if (msg.data.length >= 24 && msg.sender == getGasRelayTrustedForwarder()) {\\n            assembly {\\n                canonicalSender_ := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n\\n            return canonicalSender_;\\n        }\\n\\n        return msg.sender;\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `GAS_RELAY_PAYMASTER_FACTORY` variable\\n    /// @return gasRelayPaymasterFactory_ The `GAS_RELAY_PAYMASTER_FACTORY` variable value\\n    function getGasRelayPaymasterFactory()\\n        public\\n        view\\n        returns (address gasRelayPaymasterFactory_)\\n    {\\n        return GAS_RELAY_PAYMASTER_FACTORY;\\n    }\\n\\n    /// @notice Gets the trusted forwarder for GSN relaying\\n    /// @return trustedForwarder_ The trusted forwarder\\n    function getGasRelayTrustedForwarder() public view returns (address trustedForwarder_) {\\n        return\\n            IGasRelayPaymaster(\\n                IBeaconProxyFactory(getGasRelayPaymasterFactory()).getCanonicalLib()\\n            )\\n                .trustedForwarder();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/gas-relayer/IGasRelayPaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../interfaces/IGsnPaymaster.sol\\\";\\n\\n/// @title IGasRelayPaymaster Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGasRelayPaymaster is IGsnPaymaster {\\n    function deposit() external;\\n\\n    function withdrawBalance() external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/protocol-fees/IProtocolFeeTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IProtocolFeeTracker Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IProtocolFeeTracker {\\n    function initializeForVault(address) external;\\n\\n    function payFee() external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/release/interfaces/IGsnForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IGsnForwarder interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGsnForwarder {\\n    struct ForwardRequest {\\n        address from;\\n        address to;\\n        uint256 value;\\n        uint256 gas;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 validUntil;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/interfaces/IGsnPaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IGsnTypes.sol\\\";\\n\\n/// @title IGsnPaymaster interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGsnPaymaster {\\n    struct GasAndDataLimits {\\n        uint256 acceptanceBudget;\\n        uint256 preRelayedCallGasLimit;\\n        uint256 postRelayedCallGasLimit;\\n        uint256 calldataSizeLimit;\\n    }\\n\\n    function getGasAndDataLimits() external view returns (GasAndDataLimits memory limits);\\n\\n    function getHubAddr() external view returns (address);\\n\\n    function getRelayHubDeposit() external view returns (uint256);\\n\\n    function preRelayedCall(\\n        IGsnTypes.RelayRequest calldata relayRequest,\\n        bytes calldata signature,\\n        bytes calldata approvalData,\\n        uint256 maxPossibleGas\\n    ) external returns (bytes memory context, bool rejectOnRecipientRevert);\\n\\n    function postRelayedCall(\\n        bytes calldata context,\\n        bool success,\\n        uint256 gasUseWithoutPost,\\n        IGsnTypes.RelayData calldata relayData\\n    ) external;\\n\\n    function trustedForwarder() external view returns (address);\\n\\n    function versionPaymaster() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/release/interfaces/IGsnTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IGsnForwarder.sol\\\";\\n\\n/// @title IGsnTypes Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGsnTypes {\\n    struct RelayData {\\n        uint256 gasPrice;\\n        uint256 pctRelayFee;\\n        uint256 baseRelayFee;\\n        address relayWorker;\\n        address paymaster;\\n        address forwarder;\\n        bytes paymasterData;\\n        uint256 clientId;\\n    }\\n\\n    struct RelayRequest {\\n        IGsnForwarder.ForwardRequest request;\\n        RelayData relayData;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/utils/NonUpgradableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title NonUpgradableProxy Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A proxy contract for use with non-upgradable libs\\n/// @dev The recommended constructor-fallback pattern of a proxy in EIP-1822, updated for solc 0.6.12,\\n/// and using an immutable lib value to save on gas (since not upgradable).\\n/// The EIP-1967 storage slot for the lib is still assigned,\\n/// for ease of referring to UIs that understand the pattern, i.e., Etherscan.\\nabstract contract NonUpgradableProxy {\\n    address private immutable CONTRACT_LOGIC;\\n\\n    constructor(bytes memory _constructData, address _contractLogic) public {\\n        CONTRACT_LOGIC = _contractLogic;\\n\\n        assembly {\\n            // EIP-1967 slot: `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\\n            sstore(\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\\n                _contractLogic\\n            )\\n        }\\n        (bool success, bytes memory returnData) = _contractLogic.delegatecall(_constructData);\\n        require(success, string(returnData));\\n    }\\n\\n    // solhint-disable-next-line no-complex-fallback\\n    fallback() external payable {\\n        address contractLogic = CONTRACT_LOGIC;\\n\\n        assembly {\\n            calldatacopy(0x0, 0x0, calldatasize())\\n            let success := delegatecall(\\n                sub(gas(), 10000),\\n                contractLogic,\\n                0x0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            let retSz := returndatasize()\\n            returndatacopy(0, 0, retSz)\\n            switch success\\n                case 0 {\\n                    revert(0, retSz)\\n                }\\n                default {\\n                    return(0, retSz)\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/utils/beacon-proxy/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IBeacon interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IBeacon {\\n    function getCanonicalLib() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/release/utils/beacon-proxy/IBeaconProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\nimport \\\"./IBeacon.sol\\\";\\n\\npragma solidity 0.6.12;\\n\\n/// @title IBeaconProxyFactory interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IBeaconProxyFactory is IBeacon {\\n    function deployProxy(bytes memory _constructData) external returns (address proxy_);\\n\\n    function setCanonicalLib(address _canonicalLib) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dispatcher\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gasRelayPaymasterFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"BuySharesOnBehalfCallerDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"BuySharesOnBehalfCallerRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"comptrollerLib\",\"type\":\"address\"}],\"name\":\"ComptrollerLibSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"denominationAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesActionTimelock\",\"type\":\"uint256\"}],\"name\":\"ComptrollerProxyDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextDeactivateFeeManagerGasLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextPayProtocolFeeGasLimit\",\"type\":\"uint256\"}],\"name\":\"GasLimitsForDestructCallSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"}],\"name\":\"MigrationRequestCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"}],\"name\":\"NewFundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"protocolFeeTracker\",\"type\":\"address\"}],\"name\":\"ProtocolFeeTrackerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nextComptrollerProxy\",\"type\":\"address\"}],\"name\":\"ReconfigurationRequestCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executableTimestamp\",\"type\":\"uint256\"}],\"name\":\"ReconfigurationRequestCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevComptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nextComptrollerProxy\",\"type\":\"address\"}],\"name\":\"ReconfigurationRequestExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextTimelock\",\"type\":\"uint256\"}],\"name\":\"ReconfigurationTimelockSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ReleaseIsLive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"VaultCallDeregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"VaultCallRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultLib\",\"type\":\"address\"}],\"name\":\"VaultLibSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bypassPrevReleaseFailure\",\"type\":\"bool\"}],\"name\":\"cancelMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"}],\"name\":\"cancelReconfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_denominationAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sharesActionTimelock\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_feeManagerConfigData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_policyManagerConfigData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_bypassPrevReleaseFailure\",\"type\":\"bool\"}],\"name\":\"createMigrationRequest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"comptrollerProxy_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_fundName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_fundSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_denominationAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sharesActionTimelock\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_feeManagerConfigData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_policyManagerConfigData\",\"type\":\"bytes\"}],\"name\":\"createNewFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"comptrollerProxy_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultProxy_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_denominationAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sharesActionTimelock\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_feeManagerConfigData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_policyManagerConfigData\",\"type\":\"bytes\"}],\"name\":\"createReconfigurationRequest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"comptrollerProxy_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_callers\",\"type\":\"address[]\"}],\"name\":\"deregisterBuySharesOnBehalfCallers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"_selectors\",\"type\":\"bytes4[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_dataHashes\",\"type\":\"bytes32[]\"}],\"name\":\"deregisterVaultCalls\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bypassPrevReleaseFailure\",\"type\":\"bool\"}],\"name\":\"executeMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"}],\"name\":\"executeReconfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getComptrollerLib\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"comptrollerLib_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDispatcher\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"dispatcher_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGasLimitsForDestructCall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deactivateFeeManagerGasLimit_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payProtocolFeeGasLimit_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGasRelayPaymasterFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"gasRelayPaymasterFactory_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGasRelayTrustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolFeeTracker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"protocolFeeTracker_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"}],\"name\":\"getReconfigurationRequestForVaultProxy\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nextComptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"executableTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct FundDeployer.ReconfigurationRequest\",\"name\":\"reconfigurationRequest_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReconfigurationTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reconfigurationTimelock_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultLib\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vaultLib_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"}],\"name\":\"hasReconfigurationRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasReconfigurationRequest_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nextComptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"invokeMigrationInCancelHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IMigrationHookHandler.MigrationOutHook\",\"name\":\"_hook\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"invokeMigrationOutHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"isAllowedBuySharesOnBehalfCaller\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isAllowed_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_dataHash\",\"type\":\"bytes32\"}],\"name\":\"isAllowedVaultCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isAllowed_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes32\",\"name\":\"_dataHash\",\"type\":\"bytes32\"}],\"name\":\"isRegisteredVaultCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isRegistered_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_callers\",\"type\":\"address[]\"}],\"name\":\"registerBuySharesOnBehalfCallers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"_selectors\",\"type\":\"bytes4[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_dataHashes\",\"type\":\"bytes32[]\"}],\"name\":\"registerVaultCalls\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseIsLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isLive_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerLib\",\"type\":\"address\"}],\"name\":\"setComptrollerLib\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_nextDeactivateFeeManagerGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nextPayProtocolFeeGasLimit\",\"type\":\"uint32\"}],\"name\":\"setGasLimitsForDestructCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolFeeTracker\",\"type\":\"address\"}],\"name\":\"setProtocolFeeTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextTimelock\",\"type\":\"uint256\"}],\"name\":\"setReconfigurationTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setReleaseLive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultLib\",\"type\":\"address\"}],\"name\":\"setVaultLib\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FundDeployer", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000002e25271297537b8124b8f883a92ffd95c4032733000000000000000000000000ed05786ef7b5e5bf909512f0ad46eb8f22cdc4ca", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}