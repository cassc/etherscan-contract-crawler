{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/vote/Ve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"../../lib/Base64.sol\\\";\\r\\nimport \\\"../../interface/IERC20.sol\\\";\\r\\nimport \\\"../../interface/IERC721.sol\\\";\\r\\nimport \\\"../../interface/IERC721Metadata.sol\\\";\\r\\nimport \\\"../../interface/IVe.sol\\\";\\r\\nimport \\\"../../interface/IERC721Receiver.sol\\\";\\r\\nimport \\\"../../interface/IController.sol\\\";\\r\\nimport \\\"../Reentrancy.sol\\\";\\r\\nimport \\\"../../lib/SafeERC20.sol\\\";\\r\\nimport \\\"../../lib/Math.sol\\\";\\r\\n\\r\\ncontract Ve is IERC721, IERC721Metadata, IVe, Reentrancy {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  uint internal constant WEEK = 1 weeks;\\r\\n  uint internal constant MAX_TIME = 4 * 365 * 86400;\\r\\n  int128 internal constant I_MAX_TIME = 4 * 365 * 86400;\\r\\n  uint internal constant MULTIPLIER = 1 ether;\\r\\n\\r\\n  address immutable public override token;\\r\\n  uint public supply;\\r\\n  mapping(uint => LockedBalance) public locked;\\r\\n\\r\\n  mapping(uint => uint) public ownershipChange;\\r\\n\\r\\n  uint public override epoch;\\r\\n  /// @dev epoch -> unsigned point\\r\\n  mapping(uint => Point) internal _pointHistory;\\r\\n  /// @dev user -> Point[userEpoch]\\r\\n  mapping(uint => Point[1000000000]) internal _userPointHistory;\\r\\n\\r\\n  mapping(uint => uint) public override userPointEpoch;\\r\\n  mapping(uint => int128) public slopeChanges; // time -> signed slope change\\r\\n\\r\\n  mapping(uint => uint) public attachments;\\r\\n  mapping(uint => bool) public voted;\\r\\n  address public controller;\\r\\n\\r\\n  string constant public override name = \\\"veDYST\\\";\\r\\n  string constant public override symbol = \\\"veDYST\\\";\\r\\n  string constant public version = \\\"1.0.0\\\";\\r\\n  uint8 constant public decimals = 18;\\r\\n\\r\\n  /// @dev Current count of token\\r\\n  uint internal tokenId;\\r\\n\\r\\n  /// @dev Mapping from NFT ID to the address that owns it.\\r\\n  mapping(uint => address) internal idToOwner;\\r\\n\\r\\n  /// @dev Mapping from NFT ID to approved address.\\r\\n  mapping(uint => address) internal idToApprovals;\\r\\n\\r\\n  /// @dev Mapping from owner address to count of his tokens.\\r\\n  mapping(address => uint) internal ownerToNFTokenCount;\\r\\n\\r\\n  /// @dev Mapping from owner address to mapping of index to tokenIds\\r\\n  mapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\\r\\n\\r\\n  /// @dev Mapping from NFT ID to index of owner\\r\\n  mapping(uint => uint) internal tokenToOwnerIndex;\\r\\n\\r\\n  /// @dev Mapping from owner address to mapping of operator addresses.\\r\\n  mapping(address => mapping(address => bool)) internal ownerToOperators;\\r\\n\\r\\n  /// @dev Mapping of interface id to bool about whether or not it's supported\\r\\n  mapping(bytes4 => bool) internal supportedInterfaces;\\r\\n\\r\\n  /// @dev ERC165 interface ID of ERC165\\r\\n  bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\\r\\n\\r\\n  /// @dev ERC165 interface ID of ERC721\\r\\n  bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\\r\\n\\r\\n  /// @dev ERC165 interface ID of ERC721Metadata\\r\\n  bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\\r\\n\\r\\n  event Deposit(\\r\\n    address indexed provider,\\r\\n    uint tokenId,\\r\\n    uint value,\\r\\n    uint indexed locktime,\\r\\n    DepositType depositType,\\r\\n    uint ts\\r\\n  );\\r\\n  event Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\\r\\n  event Supply(uint prevSupply, uint supply);\\r\\n\\r\\n  /// @notice Contract constructor\\r\\n  /// @param token_ `ERC20CRV` token address\\r\\n  constructor(address token_, address controller_) {\\r\\n    token = token_;\\r\\n    controller = controller_;\\r\\n    _pointHistory[0].blk = block.number;\\r\\n    _pointHistory[0].ts = block.timestamp;\\r\\n\\r\\n    supportedInterfaces[ERC165_INTERFACE_ID] = true;\\r\\n    supportedInterfaces[ERC721_INTERFACE_ID] = true;\\r\\n    supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\\r\\n\\r\\n    // mint-ish\\r\\n    emit Transfer(address(0), address(this), tokenId);\\r\\n    // burn-ish\\r\\n    emit Transfer(address(this), address(0), tokenId);\\r\\n  }\\r\\n\\r\\n  function _voter() internal view returns (address) {\\r\\n    return IController(controller).voter();\\r\\n  }\\r\\n\\r\\n  /// @dev Interface identification is specified in ERC-165.\\r\\n  /// @param _interfaceID Id of the interface\\r\\n  function supportsInterface(bytes4 _interfaceID) external view override returns (bool) {\\r\\n    return supportedInterfaces[_interfaceID];\\r\\n  }\\r\\n\\r\\n  /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\\r\\n  /// @param _tokenId token of the NFT\\r\\n  /// @return Value of the slope\\r\\n  function getLastUserSlope(uint _tokenId) external view returns (int128) {\\r\\n    uint uEpoch = userPointEpoch[_tokenId];\\r\\n    return _userPointHistory[_tokenId][uEpoch].slope;\\r\\n  }\\r\\n\\r\\n  /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\\r\\n  /// @param _tokenId token of the NFT\\r\\n  /// @param _idx User epoch number\\r\\n  /// @return Epoch time of the checkpoint\\r\\n  function userPointHistoryTs(uint _tokenId, uint _idx) external view returns (uint) {\\r\\n    return _userPointHistory[_tokenId][_idx].ts;\\r\\n  }\\r\\n\\r\\n  /// @notice Get timestamp when `_tokenId`'s lock finishes\\r\\n  /// @param _tokenId User NFT\\r\\n  /// @return Epoch time of the lock end\\r\\n  function lockedEnd(uint _tokenId) external view returns (uint) {\\r\\n    return locked[_tokenId].end;\\r\\n  }\\r\\n\\r\\n  /// @dev Returns the number of NFTs owned by `_owner`.\\r\\n  ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\\r\\n  /// @param _owner Address for whom to query the balance.\\r\\n  function _balance(address _owner) internal view returns (uint) {\\r\\n    return ownerToNFTokenCount[_owner];\\r\\n  }\\r\\n\\r\\n  /// @dev Returns the number of NFTs owned by `_owner`.\\r\\n  ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\\r\\n  /// @param _owner Address for whom to query the balance.\\r\\n  function balanceOf(address _owner) external view override returns (uint) {\\r\\n    return _balance(_owner);\\r\\n  }\\r\\n\\r\\n  /// @dev Returns the address of the owner of the NFT.\\r\\n  /// @param _tokenId The identifier for an NFT.\\r\\n  function ownerOf(uint _tokenId) public view override returns (address) {\\r\\n    return idToOwner[_tokenId];\\r\\n  }\\r\\n\\r\\n  /// @dev Get the approved address for a single NFT.\\r\\n  /// @param _tokenId ID of the NFT to query the approval of.\\r\\n  function getApproved(uint _tokenId) external view override returns (address) {\\r\\n    return idToApprovals[_tokenId];\\r\\n  }\\r\\n\\r\\n  /// @dev Checks if `_operator` is an approved operator for `_owner`.\\r\\n  /// @param _owner The address that owns the NFTs.\\r\\n  /// @param _operator The address that acts on behalf of the owner.\\r\\n  function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\\r\\n    return (ownerToOperators[_owner])[_operator];\\r\\n  }\\r\\n\\r\\n  /// @dev  Get token by index\\r\\n  function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint) {\\r\\n    return ownerToNFTokenIdList[_owner][_tokenIndex];\\r\\n  }\\r\\n\\r\\n  /// @dev Returns whether the given spender can transfer a given token ID\\r\\n  /// @param _spender address of the spender to query\\r\\n  /// @param _tokenId uint ID of the token to be transferred\\r\\n  /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\\r\\n  function _isApprovedOrOwner(address _spender, uint _tokenId) internal view returns (bool) {\\r\\n    address owner = idToOwner[_tokenId];\\r\\n    bool spenderIsOwner = owner == _spender;\\r\\n    bool spenderIsApproved = _spender == idToApprovals[_tokenId];\\r\\n    bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\\r\\n    return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\\r\\n  }\\r\\n\\r\\n  function isApprovedOrOwner(address _spender, uint _tokenId) external view override returns (bool) {\\r\\n    return _isApprovedOrOwner(_spender, _tokenId);\\r\\n  }\\r\\n\\r\\n  /// @dev Add a NFT to an index mapping to a given address\\r\\n  /// @param _to address of the receiver\\r\\n  /// @param _tokenId uint ID Of the token to be added\\r\\n  function _addTokenToOwnerList(address _to, uint _tokenId) internal {\\r\\n    uint currentCount = _balance(_to);\\r\\n\\r\\n    ownerToNFTokenIdList[_to][currentCount] = _tokenId;\\r\\n    tokenToOwnerIndex[_tokenId] = currentCount;\\r\\n  }\\r\\n\\r\\n  /// @dev Remove a NFT from an index mapping to a given address\\r\\n  /// @param _from address of the sender\\r\\n  /// @param _tokenId uint ID Of the token to be removed\\r\\n  function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\\r\\n    // Delete\\r\\n    uint currentCount = _balance(_from) - 1;\\r\\n    uint currentIndex = tokenToOwnerIndex[_tokenId];\\r\\n\\r\\n    if (currentCount == currentIndex) {\\r\\n      // update ownerToNFTokenIdList\\r\\n      ownerToNFTokenIdList[_from][currentCount] = 0;\\r\\n      // update tokenToOwnerIndex\\r\\n      tokenToOwnerIndex[_tokenId] = 0;\\r\\n    } else {\\r\\n      uint lastTokenId = ownerToNFTokenIdList[_from][currentCount];\\r\\n\\r\\n      // Add\\r\\n      // update ownerToNFTokenIdList\\r\\n      ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\\r\\n      // update tokenToOwnerIndex\\r\\n      tokenToOwnerIndex[lastTokenId] = currentIndex;\\r\\n\\r\\n      // Delete\\r\\n      // update ownerToNFTokenIdList\\r\\n      ownerToNFTokenIdList[_from][currentCount] = 0;\\r\\n      // update tokenToOwnerIndex\\r\\n      tokenToOwnerIndex[_tokenId] = 0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Add a NFT to a given address\\r\\n  ///      Throws if `_tokenId` is owned by someone.\\r\\n  function _addTokenTo(address _to, uint _tokenId) internal {\\r\\n    // assume always call on new tokenId or after _removeTokenFrom() call\\r\\n    // Change the owner\\r\\n    idToOwner[_tokenId] = _to;\\r\\n    // Update owner token index tracking\\r\\n    _addTokenToOwnerList(_to, _tokenId);\\r\\n    // Change count tracking\\r\\n    ownerToNFTokenCount[_to] += 1;\\r\\n  }\\r\\n\\r\\n  /// @dev Remove a NFT from a given address\\r\\n  ///      Throws if `_from` is not the current owner.\\r\\n  function _removeTokenFrom(address _from, uint _tokenId) internal {\\r\\n    require(idToOwner[_tokenId] == _from, \\\"!owner remove\\\");\\r\\n    // Change the owner\\r\\n    idToOwner[_tokenId] = address(0);\\r\\n    // Update owner token index tracking\\r\\n    _removeTokenFromOwnerList(_from, _tokenId);\\r\\n    // Change count tracking\\r\\n    ownerToNFTokenCount[_from] -= 1;\\r\\n  }\\r\\n\\r\\n  /// @dev Execute transfer of a NFT.\\r\\n  ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\r\\n  ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\\r\\n  ///      Throws if `_to` is the zero address.\\r\\n  ///      Throws if `_from` is not the current owner.\\r\\n  ///      Throws if `_tokenId` is not a valid NFT.\\r\\n  function _transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint _tokenId,\\r\\n    address _sender\\r\\n  ) internal {\\r\\n    require(attachments[_tokenId] == 0 && !voted[_tokenId], \\\"attached\\\");\\r\\n    require(_isApprovedOrOwner(_sender, _tokenId), \\\"!owner sender\\\");\\r\\n    require(_to != address(0), \\\"dst is zero\\\");\\r\\n    // from address will be checked in _removeTokenFrom()\\r\\n\\r\\n    if (idToApprovals[_tokenId] != address(0)) {\\r\\n      // Reset approvals\\r\\n      idToApprovals[_tokenId] = address(0);\\r\\n    }\\r\\n    _removeTokenFrom(_from, _tokenId);\\r\\n    _addTokenTo(_to, _tokenId);\\r\\n    // Set the block of ownership transfer (for Flash NFT protection)\\r\\n    ownershipChange[_tokenId] = block.number;\\r\\n    // Log the transfer\\r\\n    emit Transfer(_from, _to, _tokenId);\\r\\n  }\\r\\n\\r\\n  /* TRANSFER FUNCTIONS */\\r\\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\\r\\n  ///      Throws if `_from` is not the current owner.\\r\\n  ///      Throws if `_to` is the zero address.\\r\\n  ///      Throws if `_tokenId` is not a valid NFT.\\r\\n  /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\r\\n  ///        they maybe be permanently lost.\\r\\n  /// @param _from The current owner of the NFT.\\r\\n  /// @param _to The new owner.\\r\\n  /// @param _tokenId The NFT to transfer.\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint _tokenId\\r\\n  ) external override {\\r\\n    _transferFrom(_from, _to, _tokenId, msg.sender);\\r\\n  }\\r\\n\\r\\n  function _isContract(address account) internal view returns (bool) {\\r\\n    // This method relies on extcodesize, which returns 0 for contracts in\\r\\n    // construction, since the code is only stored at the end of the\\r\\n    // constructor execution.\\r\\n    uint size;\\r\\n    assembly {\\r\\n      size := extcodesize(account)\\r\\n    }\\r\\n    return size > 0;\\r\\n  }\\r\\n\\r\\n  /// @dev Transfers the ownership of an NFT from one address to another address.\\r\\n  ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\\r\\n  ///      approved address for this NFT.\\r\\n  ///      Throws if `_from` is not the current owner.\\r\\n  ///      Throws if `_to` is the zero address.\\r\\n  ///      Throws if `_tokenId` is not a valid NFT.\\r\\n  ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\\r\\n  ///      the return value is not `bytes4(keccak256(\\\"onERC721Received(address,address,uint,bytes)\\\"))`.\\r\\n  /// @param _from The current owner of the NFT.\\r\\n  /// @param _to The new owner.\\r\\n  /// @param _tokenId The NFT to transfer.\\r\\n  /// @param _data Additional data with no specified format, sent in call to `_to`.\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint _tokenId,\\r\\n    bytes memory _data\\r\\n  ) public override {\\r\\n    _transferFrom(_from, _to, _tokenId, msg.sender);\\r\\n\\r\\n    if (_isContract(_to)) {\\r\\n      // Throws if transfer destination is a contract which does not implement 'onERC721Received'\\r\\n      try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (\\r\\n        bytes memory reason\\r\\n      ) {\\r\\n        if (reason.length == 0) {\\r\\n          revert('ERC721: transfer to non ERC721Receiver implementer');\\r\\n        } else {\\r\\n          assembly {\\r\\n            revert(add(32, reason), mload(reason))\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Transfers the ownership of an NFT from one address to another address.\\r\\n  ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\\r\\n  ///      approved address for this NFT.\\r\\n  ///      Throws if `_from` is not the current owner.\\r\\n  ///      Throws if `_to` is the zero address.\\r\\n  ///      Throws if `_tokenId` is not a valid NFT.\\r\\n  ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\\r\\n  ///      the return value is not `bytes4(keccak256(\\\"onERC721Received(address,address,uint,bytes)\\\"))`.\\r\\n  /// @param _from The current owner of the NFT.\\r\\n  /// @param _to The new owner.\\r\\n  /// @param _tokenId The NFT to transfer.\\r\\n  function safeTransferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint _tokenId\\r\\n  ) external override {\\r\\n    safeTransferFrom(_from, _to, _tokenId, '');\\r\\n  }\\r\\n\\r\\n  /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\\r\\n  ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\\r\\n  ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\\r\\n  ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\\r\\n  /// @param _approved Address to be approved for the given NFT ID.\\r\\n  /// @param _tokenId ID of the token to be approved.\\r\\n  function approve(address _approved, uint _tokenId) public override {\\r\\n    address owner = idToOwner[_tokenId];\\r\\n    // Throws if `_tokenId` is not a valid NFT\\r\\n    require(owner != address(0), \\\"invalid id\\\");\\r\\n    // Throws if `_approved` is the current owner\\r\\n    require(_approved != owner, \\\"self approve\\\");\\r\\n    // Check requirements\\r\\n    bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\\r\\n    bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\\r\\n    require(senderIsOwner || senderIsApprovedForAll, \\\"!owner\\\");\\r\\n    // Set the approval\\r\\n    idToApprovals[_tokenId] = _approved;\\r\\n    emit Approval(owner, _approved, _tokenId);\\r\\n  }\\r\\n\\r\\n  /// @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\r\\n  ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\\r\\n  ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\\r\\n  /// @notice This works even if sender doesn't own any tokens at the time.\\r\\n  /// @param _operator Address to add to the set of authorized operators.\\r\\n  /// @param _approved True if the operators is approved, false to revoke approval.\\r\\n  function setApprovalForAll(address _operator, bool _approved) external override {\\r\\n    // Throws if `_operator` is the `msg.sender`\\r\\n    require(_operator != msg.sender, \\\"operator is sender\\\");\\r\\n    ownerToOperators[msg.sender][_operator] = _approved;\\r\\n    emit ApprovalForAll(msg.sender, _operator, _approved);\\r\\n  }\\r\\n\\r\\n  /// @dev Function to mint tokens\\r\\n  ///      Throws if `_to` is zero address.\\r\\n  ///      Throws if `_tokenId` is owned by someone.\\r\\n  /// @param _to The address that will receive the minted tokens.\\r\\n  /// @param _tokenId The token id to mint.\\r\\n  /// @return A boolean that indicates if the operation was successful.\\r\\n  function _mint(address _to, uint _tokenId) internal returns (bool) {\\r\\n    // Throws if `_to` is zero address\\r\\n    require(_to != address(0), \\\"zero dst\\\");\\r\\n    // Add NFT. Throws if `_tokenId` is owned by someone\\r\\n    _addTokenTo(_to, _tokenId);\\r\\n    emit Transfer(address(0), _to, _tokenId);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /// @notice Record global and per-user data to checkpoint\\r\\n  /// @param _tokenId NFT token ID. No user checkpoint if 0\\r\\n  /// @param oldLocked Pevious locked amount / end lock time for the user\\r\\n  /// @param newLocked New locked amount / end lock time for the user\\r\\n  function _checkpoint(\\r\\n    uint _tokenId,\\r\\n    LockedBalance memory oldLocked,\\r\\n    LockedBalance memory newLocked\\r\\n  ) internal {\\r\\n    Point memory uOld;\\r\\n    Point memory uNew;\\r\\n    int128 oldDSlope = 0;\\r\\n    int128 newDSlope = 0;\\r\\n    uint _epoch = epoch;\\r\\n\\r\\n    if (_tokenId != 0) {\\r\\n      // Calculate slopes and biases\\r\\n      // Kept at zero when they have to\\r\\n      if (oldLocked.end > block.timestamp && oldLocked.amount > 0) {\\r\\n        uOld.slope = oldLocked.amount / I_MAX_TIME;\\r\\n        uOld.bias = uOld.slope * int128(int256(oldLocked.end - block.timestamp));\\r\\n      }\\r\\n      if (newLocked.end > block.timestamp && newLocked.amount > 0) {\\r\\n        uNew.slope = newLocked.amount / I_MAX_TIME;\\r\\n        uNew.bias = uNew.slope * int128(int256(newLocked.end - block.timestamp));\\r\\n      }\\r\\n\\r\\n      // Read values of scheduled changes in the slope\\r\\n      // oldLocked.end can be in the past and in the future\\r\\n      // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\\r\\n      oldDSlope = slopeChanges[oldLocked.end];\\r\\n      if (newLocked.end != 0) {\\r\\n        if (newLocked.end == oldLocked.end) {\\r\\n          newDSlope = oldDSlope;\\r\\n        } else {\\r\\n          newDSlope = slopeChanges[newLocked.end];\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    Point memory lastPoint = Point({bias : 0, slope : 0, ts : block.timestamp, blk : block.number});\\r\\n    if (_epoch > 0) {\\r\\n      lastPoint = _pointHistory[_epoch];\\r\\n    }\\r\\n    uint lastCheckpoint = lastPoint.ts;\\r\\n    // initialLastPoint is used for extrapolation to calculate block number\\r\\n    // (approximately, for *At methods) and save them\\r\\n    // as we cannot figure that out exactly from inside the contract\\r\\n    Point memory initialLastPoint = lastPoint;\\r\\n    uint blockSlope = 0;\\r\\n    // dblock/dt\\r\\n    if (block.timestamp > lastPoint.ts) {\\r\\n      blockSlope = (MULTIPLIER * (block.number - lastPoint.blk)) / (block.timestamp - lastPoint.ts);\\r\\n    }\\r\\n    // If last point is already recorded in this block, slope=0\\r\\n    // But that's ok b/c we know the block in such case\\r\\n\\r\\n    // Go over weeks to fill history and calculate what the current point is\\r\\n    {\\r\\n      uint ti = (lastCheckpoint / WEEK) * WEEK;\\r\\n      // Hopefully it won't happen that this won't get used in 5 years!\\r\\n      // If it does, users will be able to withdraw but vote weight will be broken\\r\\n      for (uint i = 0; i < 255; ++i) {\\r\\n        ti += WEEK;\\r\\n        int128 dSlope = 0;\\r\\n        if (ti > block.timestamp) {\\r\\n          ti = block.timestamp;\\r\\n        } else {\\r\\n          dSlope = slopeChanges[ti];\\r\\n        }\\r\\n        lastPoint.bias = Math.positiveInt128(lastPoint.bias - lastPoint.slope * int128(int256(ti - lastCheckpoint)));\\r\\n        lastPoint.slope = Math.positiveInt128(lastPoint.slope + dSlope);\\r\\n        lastCheckpoint = ti;\\r\\n        lastPoint.ts = ti;\\r\\n        lastPoint.blk = initialLastPoint.blk + (blockSlope * (ti - initialLastPoint.ts)) / MULTIPLIER;\\r\\n        _epoch += 1;\\r\\n        if (ti == block.timestamp) {\\r\\n          lastPoint.blk = block.number;\\r\\n          break;\\r\\n        } else {\\r\\n          _pointHistory[_epoch] = lastPoint;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    epoch = _epoch;\\r\\n    // Now pointHistory is filled until t=now\\r\\n\\r\\n    if (_tokenId != 0) {\\r\\n      // If last point was in this block, the slope change has been applied already\\r\\n      // But in such case we have 0 slope(s)\\r\\n      lastPoint.slope = Math.positiveInt128(lastPoint.slope + (uNew.slope - uOld.slope));\\r\\n      lastPoint.bias = Math.positiveInt128(lastPoint.bias + (uNew.bias - uOld.bias));\\r\\n    }\\r\\n\\r\\n    // Record the changed point into history\\r\\n    _pointHistory[_epoch] = lastPoint;\\r\\n\\r\\n    if (_tokenId != 0) {\\r\\n      // Schedule the slope changes (slope is going down)\\r\\n      // We subtract newUserSlope from [newLocked.end]\\r\\n      // and add old_user_slope to [old_locked.end]\\r\\n      if (oldLocked.end > block.timestamp) {\\r\\n        // old_dslope was <something> - u_old.slope, so we cancel that\\r\\n        oldDSlope += uOld.slope;\\r\\n        if (newLocked.end == oldLocked.end) {\\r\\n          oldDSlope -= uNew.slope;\\r\\n          // It was a new deposit, not extension\\r\\n        }\\r\\n        slopeChanges[oldLocked.end] = oldDSlope;\\r\\n      }\\r\\n\\r\\n      if (newLocked.end > block.timestamp) {\\r\\n        if (newLocked.end > oldLocked.end) {\\r\\n          newDSlope -= uNew.slope;\\r\\n          // old slope disappeared at this point\\r\\n          slopeChanges[newLocked.end] = newDSlope;\\r\\n        }\\r\\n        // else: we recorded it already in oldDSlope\\r\\n      }\\r\\n      // Now handle user history\\r\\n      uint userEpoch = userPointEpoch[_tokenId] + 1;\\r\\n\\r\\n      userPointEpoch[_tokenId] = userEpoch;\\r\\n      uNew.ts = block.timestamp;\\r\\n      uNew.blk = block.number;\\r\\n      _userPointHistory[_tokenId][userEpoch] = uNew;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Deposit and lock tokens for a user\\r\\n  /// @param _tokenId NFT that holds lock\\r\\n  /// @param _value Amount to deposit\\r\\n  /// @param unlockTime New time when to unlock the tokens, or 0 if unchanged\\r\\n  /// @param lockedBalance Previous locked amount / timestamp\\r\\n  /// @param depositType The type of deposit\\r\\n  function _depositFor(\\r\\n    uint _tokenId,\\r\\n    uint _value,\\r\\n    uint unlockTime,\\r\\n    LockedBalance memory lockedBalance,\\r\\n    DepositType depositType\\r\\n  ) internal {\\r\\n    LockedBalance memory _locked = lockedBalance;\\r\\n    uint supplyBefore = supply;\\r\\n\\r\\n    supply = supplyBefore + _value;\\r\\n    LockedBalance memory oldLocked;\\r\\n    (oldLocked.amount, oldLocked.end) = (_locked.amount, _locked.end);\\r\\n    // Adding to existing lock, or if a lock is expired - creating a new one\\r\\n    _locked.amount += int128(int256(_value));\\r\\n    if (unlockTime != 0) {\\r\\n      _locked.end = unlockTime;\\r\\n    }\\r\\n    locked[_tokenId] = _locked;\\r\\n\\r\\n    // Possibilities:\\r\\n    // Both old_locked.end could be current or expired (>/< block.timestamp)\\r\\n    // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\\r\\n    // _locked.end > block.timestamp (always)\\r\\n    _checkpoint(_tokenId, oldLocked, _locked);\\r\\n\\r\\n    address from = msg.sender;\\r\\n    if (_value != 0 && depositType != DepositType.MERGE_TYPE) {\\r\\n      IERC20(token).safeTransferFrom(from, address(this), _value);\\r\\n    }\\r\\n\\r\\n    emit Deposit(from, _tokenId, _value, _locked.end, depositType, block.timestamp);\\r\\n    emit Supply(supplyBefore, supplyBefore + _value);\\r\\n  }\\r\\n\\r\\n  function voting(uint _tokenId) external override {\\r\\n    require(msg.sender == _voter(), \\\"!voter\\\");\\r\\n    voted[_tokenId] = true;\\r\\n  }\\r\\n\\r\\n  function abstain(uint _tokenId) external override {\\r\\n    require(msg.sender == _voter(), \\\"!voter\\\");\\r\\n    voted[_tokenId] = false;\\r\\n  }\\r\\n\\r\\n  function attachToken(uint _tokenId) external override {\\r\\n    require(msg.sender == _voter(), \\\"!voter\\\");\\r\\n    attachments[_tokenId] = attachments[_tokenId] + 1;\\r\\n  }\\r\\n\\r\\n  function detachToken(uint _tokenId) external override {\\r\\n    require(msg.sender == _voter(), \\\"!voter\\\");\\r\\n    attachments[_tokenId] = attachments[_tokenId] - 1;\\r\\n  }\\r\\n\\r\\n  function merge(uint _from, uint _to) external {\\r\\n    require(attachments[_from] == 0 && !voted[_from], \\\"attached\\\");\\r\\n    require(_from != _to, \\\"the same\\\");\\r\\n    require(_isApprovedOrOwner(msg.sender, _from), \\\"!owner from\\\");\\r\\n    require(_isApprovedOrOwner(msg.sender, _to), \\\"!owner to\\\");\\r\\n\\r\\n    LockedBalance memory _locked0 = locked[_from];\\r\\n    LockedBalance memory _locked1 = locked[_to];\\r\\n    uint value0 = uint(int256(_locked0.amount));\\r\\n    uint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\\r\\n\\r\\n    locked[_from] = LockedBalance(0, 0);\\r\\n    _checkpoint(_from, _locked0, LockedBalance(0, 0));\\r\\n    _burn(_from);\\r\\n    _depositFor(_to, value0, end, _locked1, DepositType.MERGE_TYPE);\\r\\n  }\\r\\n\\r\\n  function block_number() external view returns (uint) {\\r\\n    return block.number;\\r\\n  }\\r\\n\\r\\n  /// @notice Record global data to checkpoint\\r\\n  function checkpoint() external override {\\r\\n    _checkpoint(0, LockedBalance(0, 0), LockedBalance(0, 0));\\r\\n  }\\r\\n\\r\\n  /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\\r\\n  /// @dev Anyone (even a smart contract) can deposit for someone else, but\\r\\n  ///      cannot extend their locktime and deposit for a brand new user\\r\\n  /// @param _tokenId lock NFT\\r\\n  /// @param _value Amount to add to user's lock\\r\\n  function depositFor(uint _tokenId, uint _value) external lock override {\\r\\n    require(_value > 0, \\\"zero value\\\");\\r\\n    LockedBalance memory _locked = locked[_tokenId];\\r\\n    require(_locked.amount > 0, 'No existing lock found');\\r\\n    require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\\r\\n    _depositFor(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\\r\\n  }\\r\\n\\r\\n  /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\\r\\n  /// @param _value Amount to deposit\\r\\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\r\\n  /// @param _to Address to deposit\\r\\n  function _createLock(uint _value, uint _lockDuration, address _to) internal returns (uint) {\\r\\n    require(_value > 0, \\\"zero value\\\");\\r\\n    // Lock time is rounded down to weeks\\r\\n    uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\\r\\n    require(unlockTime > block.timestamp, 'Can only lock until time in the future');\\r\\n    require(unlockTime <= block.timestamp + MAX_TIME, 'Voting lock can be 4 years max');\\r\\n\\r\\n    ++tokenId;\\r\\n    uint _tokenId = tokenId;\\r\\n    _mint(_to, _tokenId);\\r\\n\\r\\n    _depositFor(_tokenId, _value, unlockTime, locked[_tokenId], DepositType.CREATE_LOCK_TYPE);\\r\\n    return _tokenId;\\r\\n  }\\r\\n\\r\\n  /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\\r\\n  /// @param _value Amount to deposit\\r\\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\r\\n  /// @param _to Address to deposit\\r\\n  function createLockFor(uint _value, uint _lockDuration, address _to)\\r\\n  external lock override returns (uint) {\\r\\n    return _createLock(_value, _lockDuration, _to);\\r\\n  }\\r\\n\\r\\n  /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\\r\\n  /// @param _value Amount to deposit\\r\\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\\r\\n  function createLock(uint _value, uint _lockDuration) external lock returns (uint) {\\r\\n    return _createLock(_value, _lockDuration, msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\\r\\n  /// @param _value Amount of tokens to deposit and add to the lock\\r\\n  function increaseAmount(uint _tokenId, uint _value) external lock {\\r\\n    LockedBalance memory _locked = locked[_tokenId];\\r\\n    require(_locked.amount > 0, 'No existing lock found');\\r\\n    require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\\r\\n    require(_isApprovedOrOwner(msg.sender, _tokenId), \\\"!owner\\\");\\r\\n    require(_value > 0, \\\"zero value\\\");\\r\\n\\r\\n    _depositFor(_tokenId, _value, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\\r\\n  }\\r\\n\\r\\n  /// @notice Extend the unlock time for `_tokenId`\\r\\n  /// @param _lockDuration New number of seconds until tokens unlock\\r\\n  function increaseUnlockTime(uint _tokenId, uint _lockDuration) external lock {\\r\\n    LockedBalance memory _locked = locked[_tokenId];\\r\\n    // Lock time is rounded down to weeks\\r\\n    uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\\r\\n    require(_locked.amount > 0, 'Nothing is locked');\\r\\n    require(_locked.end > block.timestamp, 'Lock expired');\\r\\n    require(unlockTime > _locked.end, 'Can only increase lock duration');\\r\\n    require(unlockTime <= block.timestamp + MAX_TIME, 'Voting lock can be 4 years max');\\r\\n    require(_isApprovedOrOwner(msg.sender, _tokenId), \\\"!owner\\\");\\r\\n\\r\\n    _depositFor(_tokenId, 0, unlockTime, _locked, DepositType.INCREASE_UNLOCK_TIME);\\r\\n  }\\r\\n\\r\\n  /// @notice Withdraw all tokens for `_tokenId`\\r\\n  /// @dev Only possible if the lock has expired\\r\\n  function withdraw(uint _tokenId) external lock {\\r\\n    require(_isApprovedOrOwner(msg.sender, _tokenId), \\\"!owner\\\");\\r\\n    require(attachments[_tokenId] == 0 && !voted[_tokenId], \\\"attached\\\");\\r\\n    LockedBalance memory _locked = locked[_tokenId];\\r\\n    require(block.timestamp >= _locked.end, \\\"The lock did not expire\\\");\\r\\n\\r\\n    uint value = uint(int256(_locked.amount));\\r\\n    locked[_tokenId] = LockedBalance(0, 0);\\r\\n    uint supplyBefore = supply;\\r\\n    supply = supplyBefore - value;\\r\\n\\r\\n    // old_locked can have either expired <= timestamp or zero end\\r\\n    // _locked has only 0 end\\r\\n    // Both can have >= 0 amount\\r\\n    _checkpoint(_tokenId, _locked, LockedBalance(0, 0));\\r\\n\\r\\n    IERC20(token).safeTransfer(msg.sender, value);\\r\\n\\r\\n    // Burn the NFT\\r\\n    _burn(_tokenId);\\r\\n\\r\\n    emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\\r\\n    emit Supply(supplyBefore, supplyBefore - value);\\r\\n  }\\r\\n\\r\\n  // The following ERC20/minime-compatible methods are not real balanceOf and supply!\\r\\n  // They measure the weights for the purpose of voting, so they don't represent\\r\\n  // real coins.\\r\\n\\r\\n  /// @notice Binary search to estimate timestamp for block number\\r\\n  /// @param _block Block to find\\r\\n  /// @param maxEpoch Don't go beyond this epoch\\r\\n  /// @return Approximate timestamp for block\\r\\n  function _findBlockEpoch(uint _block, uint maxEpoch) internal view returns (uint) {\\r\\n    // Binary search\\r\\n    uint _min = 0;\\r\\n    uint _max = maxEpoch;\\r\\n    for (uint i = 0; i < 128; ++i) {\\r\\n      // Will be always enough for 128-bit numbers\\r\\n      if (_min >= _max) {\\r\\n        break;\\r\\n      }\\r\\n      uint _mid = (_min + _max + 1) / 2;\\r\\n      if (_pointHistory[_mid].blk <= _block) {\\r\\n        _min = _mid;\\r\\n      } else {\\r\\n        _max = _mid - 1;\\r\\n      }\\r\\n    }\\r\\n    return _min;\\r\\n  }\\r\\n\\r\\n  /// @notice Get the current voting power for `_tokenId`\\r\\n  /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\\r\\n  /// @param _tokenId NFT for lock\\r\\n  /// @param _t Epoch time to return voting power at\\r\\n  /// @return User voting power\\r\\n  function _balanceOfNFT(uint _tokenId, uint _t) internal view returns (uint) {\\r\\n    uint _epoch = userPointEpoch[_tokenId];\\r\\n    if (_epoch == 0) {\\r\\n      return 0;\\r\\n    } else {\\r\\n      Point memory lastPoint = _userPointHistory[_tokenId][_epoch];\\r\\n      lastPoint.bias -= lastPoint.slope * int128(int256(_t) - int256(lastPoint.ts));\\r\\n      if (lastPoint.bias < 0) {\\r\\n        lastPoint.bias = 0;\\r\\n      }\\r\\n      return uint(int256(lastPoint.bias));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Returns current token URI metadata\\r\\n  /// @param _tokenId Token ID to fetch URI for.\\r\\n  function tokenURI(uint _tokenId) external view override returns (string memory) {\\r\\n    require(idToOwner[_tokenId] != address(0), \\\"Query for nonexistent token\\\");\\r\\n    LockedBalance memory _locked = locked[_tokenId];\\r\\n    return\\r\\n    _tokenURI(\\r\\n      _tokenId,\\r\\n      _balanceOfNFT(_tokenId, block.timestamp),\\r\\n      _locked.end,\\r\\n      uint(int256(_locked.amount))\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function balanceOfNFT(uint _tokenId) external view override returns (uint) {\\r\\n    // flash NFT protection\\r\\n    if (ownershipChange[_tokenId] == block.number) {\\r\\n      return 0;\\r\\n    }\\r\\n    return _balanceOfNFT(_tokenId, block.timestamp);\\r\\n  }\\r\\n\\r\\n  function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\\r\\n    return _balanceOfNFT(_tokenId, _t);\\r\\n  }\\r\\n\\r\\n  /// @notice Measure voting power of `_tokenId` at block height `_block`\\r\\n  /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\\r\\n  /// @param _tokenId User's wallet NFT\\r\\n  /// @param _block Block to calculate the voting power at\\r\\n  /// @return Voting power\\r\\n  function _balanceOfAtNFT(uint _tokenId, uint _block) internal view returns (uint) {\\r\\n    // Copying and pasting totalSupply code because Vyper cannot pass by\\r\\n    // reference yet\\r\\n    require(_block <= block.number, \\\"only old block\\\");\\r\\n\\r\\n    // Binary search\\r\\n    uint _min = 0;\\r\\n    uint _max = userPointEpoch[_tokenId];\\r\\n    for (uint i = 0; i < 128; ++i) {\\r\\n      // Will be always enough for 128-bit numbers\\r\\n      if (_min >= _max) {\\r\\n        break;\\r\\n      }\\r\\n      uint _mid = (_min + _max + 1) / 2;\\r\\n      if (_userPointHistory[_tokenId][_mid].blk <= _block) {\\r\\n        _min = _mid;\\r\\n      } else {\\r\\n        _max = _mid - 1;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    Point memory uPoint = _userPointHistory[_tokenId][_min];\\r\\n\\r\\n    uint maxEpoch = epoch;\\r\\n    uint _epoch = _findBlockEpoch(_block, maxEpoch);\\r\\n    Point memory point0 = _pointHistory[_epoch];\\r\\n    uint dBlock = 0;\\r\\n    uint dt = 0;\\r\\n    if (_epoch < maxEpoch) {\\r\\n      Point memory point1 = _pointHistory[_epoch + 1];\\r\\n      dBlock = point1.blk - point0.blk;\\r\\n      dt = point1.ts - point0.ts;\\r\\n    } else {\\r\\n      dBlock = block.number - point0.blk;\\r\\n      dt = block.timestamp - point0.ts;\\r\\n    }\\r\\n    uint blockTime = point0.ts;\\r\\n    if (dBlock != 0 && _block > point0.blk) {\\r\\n      blockTime += (dt * (_block - point0.blk)) / dBlock;\\r\\n    }\\r\\n\\r\\n    uPoint.bias -= uPoint.slope * int128(int256(blockTime - uPoint.ts));\\r\\n    return uint(uint128(Math.positiveInt128(uPoint.bias)));\\r\\n  }\\r\\n\\r\\n  function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\\r\\n    return _balanceOfAtNFT(_tokenId, _block);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate total voting power at some point in the past\\r\\n  /// @param point The point (bias/slope) to start search from\\r\\n  /// @param t Time to calculate the total voting power at\\r\\n  /// @return Total voting power at that time\\r\\n  function _supplyAt(Point memory point, uint t) internal view returns (uint) {\\r\\n    Point memory lastPoint = point;\\r\\n    uint ti = (lastPoint.ts / WEEK) * WEEK;\\r\\n    for (uint i = 0; i < 255; ++i) {\\r\\n      ti += WEEK;\\r\\n      int128 dSlope = 0;\\r\\n      if (ti > t) {\\r\\n        ti = t;\\r\\n      } else {\\r\\n        dSlope = slopeChanges[ti];\\r\\n      }\\r\\n      lastPoint.bias -= lastPoint.slope * int128(int256(ti - lastPoint.ts));\\r\\n      if (ti == t) {\\r\\n        break;\\r\\n      }\\r\\n      lastPoint.slope += dSlope;\\r\\n      lastPoint.ts = ti;\\r\\n    }\\r\\n    return uint(uint128(Math.positiveInt128(lastPoint.bias)));\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate total voting power\\r\\n  /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\\r\\n  /// @return Total voting power\\r\\n  function totalSupplyAtT(uint t) public view returns (uint) {\\r\\n    uint _epoch = epoch;\\r\\n    Point memory lastPoint = _pointHistory[_epoch];\\r\\n    return _supplyAt(lastPoint, t);\\r\\n  }\\r\\n\\r\\n  function totalSupply() external view returns (uint) {\\r\\n    return totalSupplyAtT(block.timestamp);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate total voting power at some point in the past\\r\\n  /// @param _block Block to calculate the total voting power at\\r\\n  /// @return Total voting power at `_block`\\r\\n  function totalSupplyAt(uint _block) external view returns (uint) {\\r\\n    require(_block <= block.number, \\\"only old blocks\\\");\\r\\n    uint _epoch = epoch;\\r\\n    uint targetEpoch = _findBlockEpoch(_block, _epoch);\\r\\n\\r\\n    Point memory point = _pointHistory[targetEpoch];\\r\\n    // it is possible only for a block before the launch\\r\\n    // return 0 as more clear answer than revert\\r\\n    if (point.blk > _block) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint dt = 0;\\r\\n    if (targetEpoch < _epoch) {\\r\\n      Point memory point_next = _pointHistory[targetEpoch + 1];\\r\\n      // next point block can not be the same or lower\\r\\n      dt = ((_block - point.blk) * (point_next.ts - point.ts)) / (point_next.blk - point.blk);\\r\\n    } else {\\r\\n      if (point.blk != block.number) {\\r\\n        dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\\r\\n      }\\r\\n    }\\r\\n    // Now dt contains info on how far are we beyond point\\r\\n    return _supplyAt(point, point.ts + dt);\\r\\n  }\\r\\n\\r\\n  function _tokenURI(uint _tokenId, uint _balanceOf, uint _locked_end, uint _value) internal pure returns (string memory output) {\\r\\n    output = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"><style>.base { fill: black; font-family: Impact; font-size: 50px; }</style><rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"#aaaaff\\\" /><text x=\\\"10\\\" y=\\\"60\\\" class=\\\"base\\\">';\\r\\n    output = string(abi.encodePacked(output, \\\"token \\\", _toString(_tokenId), '</text><text x=\\\"10\\\" y=\\\"150\\\" class=\\\"base\\\">'));\\r\\n    output = string(abi.encodePacked(output, \\\"balanceOf \\\", _toString(_balanceOf), '</text><text x=\\\"10\\\" y=\\\"230\\\" class=\\\"base\\\">'));\\r\\n    output = string(abi.encodePacked(output, \\\"locked_end \\\", _toString(_locked_end), '</text><text x=\\\"10\\\" y=\\\"310\\\" class=\\\"base\\\">'));\\r\\n    output = string(abi.encodePacked(output, \\\"value \\\", _toString(_value), '</text></svg>'));\\r\\n\\r\\n    string memory json = Base64.encode(bytes(string(abi.encodePacked('{\\\"name\\\": \\\"lock #', _toString(_tokenId), '\\\", \\\"description\\\": \\\"Dystopia locks, can be used to boost gauge yields, vote on token emission, and receive bribes\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\\\"}'))));\\r\\n    output = string(abi.encodePacked('data:application/json;base64,', json));\\r\\n  }\\r\\n\\r\\n  function _toString(uint value) internal pure returns (string memory) {\\r\\n    // Inspired by OraclizeAPI's implementation - MIT license\\r\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n    if (value == 0) {\\r\\n      return \\\"0\\\";\\r\\n    }\\r\\n    uint temp = value;\\r\\n    uint digits;\\r\\n    while (temp != 0) {\\r\\n      digits++;\\r\\n      temp /= 10;\\r\\n    }\\r\\n    bytes memory buffer = new bytes(digits);\\r\\n    while (value != 0) {\\r\\n      digits -= 1;\\r\\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\r\\n      value /= 10;\\r\\n    }\\r\\n    return string(buffer);\\r\\n  }\\r\\n\\r\\n  function _burn(uint _tokenId) internal {\\r\\n    address owner = ownerOf(_tokenId);\\r\\n    // Clear approval\\r\\n    approve(address(0), _tokenId);\\r\\n    // Remove token\\r\\n    _removeTokenFrom(msg.sender, _tokenId);\\r\\n    emit Transfer(owner, address(0), _tokenId);\\r\\n  }\\r\\n\\r\\n  function userPointHistory(uint _tokenId, uint _loc) external view override returns (Point memory) {\\r\\n    return _userPointHistory[_tokenId][_loc];\\r\\n  }\\r\\n\\r\\n  function pointHistory(uint _loc) external view override returns (Point memory) {\\r\\n    return _pointHistory[_loc];\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/// @title Base64\\r\\n/// @notice Provides a function for encoding some bytes in base64\\r\\n/// @author Brecht Devos <brecht@loopring.org>\\r\\nlibrary Base64 {\\r\\n  bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\r\\n\\r\\n  /// @notice Encodes some bytes to the base64 representation\\r\\n  function encode(bytes memory data) internal pure returns (string memory) {\\r\\n    uint len = data.length;\\r\\n    if (len == 0) return \\\"\\\";\\r\\n\\r\\n    // multiply by 4/3 rounded up\\r\\n    uint encodedLen = 4 * ((len + 2) / 3);\\r\\n\\r\\n    // Add some extra buffer at the end\\r\\n    bytes memory result = new bytes(encodedLen + 32);\\r\\n\\r\\n    bytes memory table = TABLE;\\r\\n\\r\\n    assembly {\\r\\n      let tablePtr := add(table, 1)\\r\\n      let resultPtr := add(result, 32)\\r\\n\\r\\n      for {\\r\\n        let i := 0\\r\\n      } lt(i, len) {\\r\\n\\r\\n      } {\\r\\n        i := add(i, 3)\\r\\n        let input := and(mload(add(data, i)), 0xffffff)\\r\\n\\r\\n        let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\r\\n        out := shl(8, out)\\r\\n        out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\r\\n        out := shl(8, out)\\r\\n        out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\r\\n        out := shl(8, out)\\r\\n        out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\r\\n        out := shl(224, out)\\r\\n\\r\\n        mstore(resultPtr, out)\\r\\n\\r\\n        resultPtr := add(resultPtr, 4)\\r\\n      }\\r\\n\\r\\n      switch mod(len, 3)\\r\\n      case 1 {\\r\\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\r\\n      }\\r\\n      case 2 {\\r\\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\\r\\n      }\\r\\n\\r\\n      mstore(result, encodedLen)\\r\\n    }\\r\\n\\r\\n    return string(result);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens in existence.\\r\\n   */\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens owned by `account`.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remaining number of tokens that `spender` will be\\r\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n   * zero by default.\\r\\n   *\\r\\n   * This value changes when {approve} or {transferFrom} are called.\\r\\n   */\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n   * that someone may use both the old and the new allowance by unfortunate\\r\\n   * transaction ordering. One possible solution to mitigate this race\\r\\n   * condition is to first reduce the spender's allowance to 0 and set the\\r\\n   * desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n   * allowance mechanism. `amount` is then deducted from the caller's\\r\\n   * allowance.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n   * another (`to`).\\r\\n   *\\r\\n   * Note that `value` may be zero.\\r\\n   */\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n   * a call to {approve}. `value` is the new allowance.\\r\\n   */\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 is IERC165 {\\r\\n  /**\\r\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n   */\\r\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n   */\\r\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n   */\\r\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of tokens in ``owner``'s account.\\r\\n   */\\r\\n  function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the owner of the `tokenId` token.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `tokenId` must exist.\\r\\n   */\\r\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must exist and be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n   *\\r\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n   * The approval is cleared when the token is transferred.\\r\\n   *\\r\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - The caller must own the token or be an approved operator.\\r\\n   * - `tokenId` must exist.\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the account approved for `tokenId` token.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `tokenId` must exist.\\r\\n   */\\r\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n  /**\\r\\n   * @dev Approve or remove `operator` as an operator for the caller.\\r\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - The `operator` cannot be the caller.\\r\\n   *\\r\\n   * Emits an {ApprovalForAll} event.\\r\\n   */\\r\\n  function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n   *\\r\\n   * See {setApprovalForAll}\\r\\n   */\\r\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must exist and be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    bytes calldata data\\r\\n  ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\n\\r\\n/**\\r\\n* @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n* @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n*/\\r\\ninterface IERC721Metadata is IERC721 {\\r\\n  /**\\r\\n  * @dev Returns the token collection name.\\r\\n  */\\r\\n  function name() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n  * @dev Returns the token collection symbol.\\r\\n  */\\r\\n  function symbol() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n  * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n  */\\r\\n  function tokenURI(uint tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IVe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\ninterface IVe {\\r\\n\\r\\n  enum DepositType {\\r\\n    DEPOSIT_FOR_TYPE,\\r\\n    CREATE_LOCK_TYPE,\\r\\n    INCREASE_LOCK_AMOUNT,\\r\\n    INCREASE_UNLOCK_TIME,\\r\\n    MERGE_TYPE\\r\\n  }\\r\\n\\r\\n  struct Point {\\r\\n    int128 bias;\\r\\n    int128 slope; // # -dweight / dt\\r\\n    uint ts;\\r\\n    uint blk; // block\\r\\n  }\\r\\n  /* We cannot really do block numbers per se b/c slope is per time, not per block\\r\\n  * and per block could be fairly bad b/c Ethereum changes blocktimes.\\r\\n  * What we can do is to extrapolate ***At functions */\\r\\n\\r\\n  struct LockedBalance {\\r\\n    int128 amount;\\r\\n    uint end;\\r\\n  }\\r\\n\\r\\n  function token() external view returns (address);\\r\\n\\r\\n  function balanceOfNFT(uint) external view returns (uint);\\r\\n\\r\\n  function isApprovedOrOwner(address, uint) external view returns (bool);\\r\\n\\r\\n  function createLockFor(uint, uint, address) external returns (uint);\\r\\n\\r\\n  function userPointEpoch(uint tokenId) external view returns (uint);\\r\\n\\r\\n  function epoch() external view returns (uint);\\r\\n\\r\\n  function userPointHistory(uint tokenId, uint loc) external view returns (Point memory);\\r\\n\\r\\n  function pointHistory(uint loc) external view returns (Point memory);\\r\\n\\r\\n  function checkpoint() external;\\r\\n\\r\\n  function depositFor(uint tokenId, uint value) external;\\r\\n\\r\\n  function attachToken(uint tokenId) external;\\r\\n\\r\\n  function detachToken(uint tokenId) external;\\r\\n\\r\\n  function voting(uint tokenId) external;\\r\\n\\r\\n  function abstain(uint tokenId) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ninterface IERC721Receiver {\\r\\n  /**\\r\\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\r\\n   * by `operator` from `from`, this function is called.\\r\\n   *\\r\\n   * It must return its Solidity selector to confirm the token transfer.\\r\\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\r\\n   *\\r\\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\r\\n   */\\r\\n  function onERC721Received(\\r\\n    address operator,\\r\\n    address from,\\r\\n    uint256 tokenId,\\r\\n    bytes calldata data\\r\\n  ) external returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\ninterface IController {\\r\\n\\r\\n  function veDist() external view returns (address);\\r\\n\\r\\n  function voter() external view returns (address);\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/Reentrancy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nabstract contract Reentrancy {\\r\\n\\r\\n  /// @dev simple re-entrancy check\\r\\n  uint internal _unlocked = 1;\\r\\n\\r\\n  modifier lock() {\\r\\n    require(_unlocked == 1, \\\"Reentrant call\\\");\\r\\n    _unlocked = 2;\\r\\n    _;\\r\\n    _unlocked = 1;\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"../interface/IERC20.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint value\\r\\n  ) internal {\\r\\n    uint newAllowance = token.allowance(address(this), spender) + value;\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n    // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n    if (returndata.length > 0) {\\r\\n      // Return data is optional\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nlibrary Math {\\r\\n\\r\\n  function max(uint a, uint b) internal pure returns (uint) {\\r\\n    return a >= b ? a : b;\\r\\n  }\\r\\n\\r\\n  function min(uint a, uint b) internal pure returns (uint) {\\r\\n    return a < b ? a : b;\\r\\n  }\\r\\n\\r\\n  function positiveInt128(int128 value) internal pure returns (int128) {\\r\\n    return value < 0 ? int128(0) : value;\\r\\n  }\\r\\n\\r\\n  function closeTo(uint a, uint b, uint target) internal pure returns (bool) {\\r\\n    if (a > b) {\\r\\n      if (a - b <= target) {\\r\\n        return true;\\r\\n      }\\r\\n    } else {\\r\\n      if (b - a <= target) {\\r\\n        return true;\\r\\n      }\\r\\n    }\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  function sqrt(uint y) internal pure returns (uint z) {\\r\\n    if (y > 3) {\\r\\n      z = y;\\r\\n      uint x = y / 2 + 1;\\r\\n      while (x < z) {\\r\\n        z = x;\\r\\n        x = (y / x + x) / 2;\\r\\n      }\\r\\n    } else if (y != 0) {\\r\\n      z = 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n  /**\\r\\n   * @dev Returns true if this contract implements the interface defined by\\r\\n   * `interfaceId`. See the corresponding\\r\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n   * to learn more about how these ids are created.\\r\\n   *\\r\\n   * This function call must use less than 30 000 gas.\\r\\n   */\\r\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n  /**\\r\\n   * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    // This method relies on extcodesize/address.code.length, which returns 0\\r\\n    // for contracts in construction, since the code is only stored at the end\\r\\n    // of the constructor execution.\\r\\n\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n    (bool success, bytes memory returndata) = target.call(data);\\r\\n    return verifyCallResult(success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      // Look for revert reason and bubble it up if present\\r\\n      if (returndata.length > 0) {\\r\\n        // The easiest way to bubble the revert reason is using memory via assembly\\r\\n        assembly {\\r\\n          let returndata_size := mload(returndata)\\r\\n          revert(add(32, returndata), returndata_size)\\r\\n        }\\r\\n      } else {\\r\\n        revert(errorMessage);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"locktime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IVe.DepositType\",\"name\":\"depositType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"abstain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"attachToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"attachments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"balanceOfAtNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"balanceOfNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"balanceOfNFTAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"block_number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"name\":\"createLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"createLockFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"detachToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLastUserSlope\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"increaseAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"name\":\"increaseUnlockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isApprovedOrOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"amount\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"lockedEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"merge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownershipChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loc\",\"type\":\"uint256\"}],\"name\":\"pointHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"int128\",\"name\":\"bias\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"slope\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blk\",\"type\":\"uint256\"}],\"internalType\":\"struct IVe.Point\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"slopeChanges\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenIndex\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAtT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userPointEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_loc\",\"type\":\"uint256\"}],\"name\":\"userPointHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"int128\",\"name\":\"bias\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"slope\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blk\",\"type\":\"uint256\"}],\"internalType\":\"struct IVe.Point\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"userPointHistoryTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"voting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Ve", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000039ab6574c289c3ae4d88500eec792ab5b947a5eb0000000000000000000000007377ea6afb77ba013b23306154691c231824522a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}