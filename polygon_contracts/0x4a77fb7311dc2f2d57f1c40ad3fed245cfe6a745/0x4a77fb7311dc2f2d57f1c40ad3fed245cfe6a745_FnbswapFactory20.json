{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FnbswapExchange/FnbswapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\n\\r\\nimport \\\"./FnbswapExchange20.sol\\\";\\r\\n\\r\\ncontract Ownable {\\r\\n  address internal owner;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  /**\\r\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the specied address\\r\\n   * @param _firstOwner Address of the first owner\\r\\n   */\\r\\n  constructor (address _firstOwner) {\\r\\n    owner = _firstOwner;\\r\\n    emit OwnershipTransferred(address(0), _firstOwner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the master owner.\\r\\n   */\\r\\n  modifier onlyOwner() {\\r\\n    require(msg.sender == owner, \\\"Ownable#onlyOwner: SENDER_IS_NOT_OWNER\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Transfers the ownership of the contract to new address\\r\\n   * @param _newOwner Address of the new owner\\r\\n   */\\r\\n  function transferOwnership(address _newOwner) public onlyOwner {\\r\\n    require(_newOwner != address(0), \\\"Ownable#transferOwnership: INVALID_ADDRESS\\\");\\r\\n    owner = _newOwner;\\r\\n    emit OwnershipTransferred(owner, _newOwner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the address of the owner.\\r\\n   */\\r\\n  function getOwner() public view returns (address) {\\r\\n    return owner;\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface IFnbswapFactory20 {\\r\\n\\r\\n  /***********************************|\\r\\n  |               Events              |\\r\\n  |__________________________________*/\\r\\n\\r\\n  event NewExchange(address indexed token, address indexed currency, uint256 indexed salt, uint256 lpFee, address exchange);\\r\\n\\r\\n  event MetadataContractChanged(address indexed metadataContract);\\r\\n\\r\\n  /***********************************|\\r\\n  |         Public  Functions         |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Creates a FnbSwap Exchange for given token contract\\r\\n   * @param _token      The address of the ERC-1155 token contract\\r\\n   * @param _currency   The address of the currency token contract\\r\\n   * @param _lpFee      Fee that will go to LPs\\r\\n   *                    Number between 0 and 1000, where 10 is 1.0% and 100 is 10%.\\r\\n   */\\r\\n  function createExchange(address _token, address _currency, uint256 _lpFee) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Return address of exchange for corresponding ERC-1155 token contract\\r\\n   * @param _token      The address of the ERC-1155 token contract\\r\\n   * @param _currency   The address of the currency token contract\\r\\n   * @param _lpFee      Fee that will go to LPs.\\r\\n   * @param _instance   Instance # that allows to deploy new instances of an exchange.\\r\\n   *                    This is mainly meant to be used for tokens that change their ERC-2981 support.\\r\\n   */\\r\\n  function tokensToExchange(address _token, address _currency, uint256 _lpFee, uint256 _instance) external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice Returns array of exchange instances for a given pair\\r\\n   * @param _token    The address of the ERC-1155 token contract\\r\\n   * @param _currency The address of the ERC-20 token contract\\r\\n   */\\r\\n  function getPairExchanges(address _token, address _currency) external view returns (address[] memory);\\r\\n}\\r\\n\\r\\ncontract FnbswapFactory20 is IFnbswapFactory20, Ownable, IDelegatedERC1155Metadata {\\r\\n\\r\\n  /***********************************|\\r\\n  |       Events And Variables        |\\r\\n  |__________________________________*/\\r\\n\\r\\n  // tokensToExchange[erc1155_token_address][currency_address][lp_fee][instance]\\r\\n  mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => address)))) public override tokensToExchange;\\r\\n  mapping(address => mapping(address => address[])) internal pairExchanges;\\r\\n  mapping(address => mapping(address => mapping(uint256 => uint256))) public tokenTolastIntance;\\r\\n\\r\\n  // Metadata implementation\\r\\n  IERC1155Metadata internal metadataContract; // address of the ERC-1155 Metadata contract\\r\\n\\r\\n  /**\\r\\n   * @notice Will set the initial Fnbswap admin\\r\\n   * @param _admin Address of the initial niftyswap admin to set as Owner\\r\\n   */\\r\\n  constructor(address _admin) Ownable(_admin) {}\\r\\n\\r\\n  /***********************************|\\r\\n  |             Functions             |\\r\\n  |__________________________________*/\\r\\n  /**\\r\\n   * @notice Creates a FnbSwap Exchange for given token contract\\r\\n   * @param _token    The address of the ERC-1155 token contract\\r\\n   * @param _currency The address of the ERC-20 token contract\\r\\n   * @param _lpFee    Fee that will go to LPs.\\r\\n   *                  Number between 0 and 1000, where 10 is 1.0% and 100 is 10%.\\r\\n   */\\r\\n  function createExchange(address _token, address _currency, uint256 _lpFee) public override {\\r\\n    //define instance id\\r\\n    uint256 _newInstance = tokenTolastIntance[_token][_currency][_lpFee];\\r\\n\\r\\n    if(_newInstance > 0) {\\r\\n      require(tokensToExchange[_token][_currency][_lpFee][_newInstance - 1] == address(0x0), \\\"NF20#1\\\"); // FnbswapFactory20#createExchange: EXCHANGE_ALREADY_CREATED\\r\\n    }\\r\\n\\r\\n    // Create new exchange contract\\r\\n    FnbswapExchange20 exchange = new FnbswapExchange20(_token, _currency, _lpFee);\\r\\n\\r\\n    // Store exchange and token addresses\\r\\n    tokensToExchange[_token][_currency][_lpFee][_newInstance] = address(exchange);\\r\\n    tokenTolastIntance[_token][_currency][_lpFee] = _newInstance + 1;\\r\\n    pairExchanges[_token][_currency].push(address(exchange));\\r\\n\\r\\n    // Emit event\\r\\n    emit NewExchange(_token, _currency, _newInstance, _lpFee, address(exchange));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Returns array of exchange instances for a given pair\\r\\n   * @param _token    The address of the ERC-1155 token contract\\r\\n   * @param _currency The address of the ERC-20 token contract\\r\\n   */\\r\\n  function getPairExchanges(address _token, address _currency) public override view returns (address[] memory) {\\r\\n    return pairExchanges[_token][_currency];\\r\\n  }\\r\\n\\r\\n  /***********************************|\\r\\n  |        Metadata Functions         |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Changes the implementation of the ERC-1155 Metadata contract\\r\\n   * @dev This function changes the implementation for all child exchanges of the factory\\r\\n   * @param _contract The address of the ERC-1155 Metadata contract\\r\\n   */\\r\\n  function setMetadataContract(IERC1155Metadata _contract) onlyOwner external {\\r\\n    emit MetadataContractChanged(address(_contract));\\r\\n    metadataContract = _contract;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the address of the ERC-1155 Metadata contract\\r\\n   */\\r\\n  function metadataProvider() external override view returns (IERC1155Metadata) {\\r\\n    return metadataContract;\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/FnbswapExchange/FnbswapExchange20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\npragma experimental ABIEncoderV2;\\r\\nimport \\\"./swap/contracts/interfaces/IFnbswapExchange20.sol\\\";\\r\\nimport \\\"./swap/contracts/utils/ReentrancyGuard.sol\\\";\\r\\nimport \\\"./swap/contracts/utils/DelegatedOwnable.sol\\\";\\r\\nimport \\\"./swap/contracts/interfaces/IERC2981.sol\\\";\\r\\nimport \\\"./swap/contracts/interfaces/IERC1155Metadata.sol\\\";\\r\\nimport \\\"./swap/contracts/interfaces/IDelegatedERC1155Metadata.sol\\\";\\r\\nimport \\\"./erc-1155/contracts/interfaces/IERC20.sol\\\";\\r\\nimport \\\"./erc-1155/contracts/interfaces/IERC165.sol\\\";\\r\\nimport \\\"./erc-1155/contracts/interfaces/IERC1155.sol\\\";\\r\\nimport \\\"./erc-1155/contracts/interfaces/IERC1155TokenReceiver.sol\\\";\\r\\nimport \\\"./erc-1155/contracts/tokens/ERC1155/ERC1155MintBurn.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\n\\r\\n/**\\r\\n * This Uniswap-like implementation supports ERC-1155 standard tokens\\r\\n * with an ERC-20 based token used as a currency instead of Ether.\\r\\n *\\r\\n * Liquidity tokens are also ERC-1155 tokens you can find the ERC-1155\\r\\n * implementation used here:\\r\\n *    https://github.com/horizon-games/multi-token-standard/tree/master/contracts/tokens/ERC1155\\r\\n *\\r\\n * @dev Like Uniswap, tokens with 0 decimals and low supply are susceptible to significant rounding\\r\\n *      errors when it comes to removing liquidity, possibly preventing them to be withdrawn without\\r\\n *      some collaboration between liquidity providers.\\r\\n * \\r\\n * @dev ERC-777 tokens may be vulnerable if used as currency in Fnbswap. Please review the code \\r\\n *      carefully before using it with ERC-777 tokens.\\r\\n */\\r\\ncontract FnbswapExchange20 is ReentrancyGuard, ERC1155MintBurn, IFnbswapExchange20, IERC1155Metadata, DelegatedOwnable {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  /***********************************|\\r\\n  |       Variables & Constants       |\\r\\n  |__________________________________*/\\r\\n\\r\\n  // Variables\\r\\n  IERC1155 internal immutable token;         // address of the ERC-1155 token contract\\r\\n  address internal immutable currency;       // address of the ERC-20 currency used for exchange\\r\\n  address internal immutable factory;        // address for the factory that created this contract\\r\\n  uint256 internal immutable FEE_MULTIPLIER; // multiplier that calculates the LP fee (1.0%)\\r\\n\\r\\n  // Royalty variables\\r\\n  bool internal immutable IS_ERC2981; // whether token contract supports ERC-2981\\r\\n  uint256 internal globalRoyaltyFee;        // global royalty fee multiplier if ERC2981 is not used\\r\\n  address internal globalRoyaltyRecipient;  // global royalty fee recipient if ERC2981 is not used\\r\\n\\r\\n  // Mapping variables\\r\\n  mapping(uint256 => uint256) internal totalSupplies;      // Liquidity pool token supply per Token id\\r\\n  mapping(uint256 => uint256) internal currencyReserves;   // currency Token reserve per Token id\\r\\n  mapping(address => uint256) internal royaltiesNumerator; // Mapping tracking how much royalties can be claimed per address\\r\\n\\r\\n  uint256 internal constant ROYALTIES_DENOMINATOR = 10000;\\r\\n  uint256 internal constant MAX_ROYALTY = ROYALTIES_DENOMINATOR / 4;\\r\\n\\r\\n  bool public test = true;\\r\\n\\r\\n  /***********************************|\\r\\n  |            Constructor           |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Create instance of exchange contract with respective token and currency token\\r\\n   * @dev If token supports ERC-2981, then royalty fee will be queried per token on the \\r\\n   *      token contract. Else royalty fee will need to be manually set by admin.\\r\\n   * @param _tokenAddr     The address of the ERC-1155 Token\\r\\n   * @param _currencyAddr  The address of the ERC-20 currency Token\\r\\n   * @param _currencyAddr  Address of the admin, which should be the same as the factory owner\\r\\n   * @param _lpFee    Fee that will go to LPs.\\r\\n   *                  Number between 0 and 1000, where 10 is 1.0% and 100 is 10%.\\r\\n   */\\r\\n  constructor(address _tokenAddr, address _currencyAddr, uint256 _lpFee) DelegatedOwnable(msg.sender) {\\r\\n    require(\\r\\n      _tokenAddr != address(0) && _currencyAddr != address(0),\\r\\n      \\\"NE20#1\\\" // FnbswapExchange20#constructor:INVALID_INPUT\\r\\n    );\\r\\n    require(\\r\\n      _lpFee >= 0 && _lpFee <= 1000,  \\r\\n      \\\"NE20#2\\\" // FnbswapExchange20#constructor:INVALID_LP_FEE\\r\\n    );\\r\\n\\r\\n    factory = msg.sender;\\r\\n    token = IERC1155(_tokenAddr);\\r\\n    currency = _currencyAddr;\\r\\n    FEE_MULTIPLIER = 1000 - _lpFee;\\r\\n\\r\\n    // If global royalty, lets check for ERC-2981 support\\r\\n    try IERC1155(_tokenAddr).supportsInterface(type(IERC2981).interfaceId) returns (bool supported) {\\r\\n      IS_ERC2981 = supported;\\r\\n    } catch {}\\r\\n  }\\r\\n\\r\\n  /***********************************|\\r\\n  |        Metadata Functions         |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n      @notice A distinct Uniform Resource Identifier (URI) for a given token.\\r\\n      @dev URIs are defined in RFC 3986.\\r\\n      The URI MUST point to a JSON file that conforms to the \\\"ERC-1155 Metadata URI JSON Schema\\\".        \\r\\n      @return URI string\\r\\n  */\\r\\n  function uri(uint256 _id) external override view returns (string memory) {\\r\\n    return IDelegatedERC1155Metadata(factory).metadataProvider().uri(_id);\\r\\n  }\\r\\n\\r\\n  /***********************************|\\r\\n  |        Exchange Functions         |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\\r\\n   */\\r\\n  function _currencyToToken(\\r\\n    uint256[] memory _tokenIds,\\r\\n    uint256[] memory _tokensBoughtAmounts,\\r\\n    uint256 _maxCurrency,\\r\\n    uint256 _deadline,\\r\\n    address _recipient\\r\\n  )\\r\\n    internal nonReentrant() returns (uint256[] memory currencySold)\\r\\n  {\\r\\n    // Input validation\\r\\n    require(_deadline >= block.timestamp, \\\"NE20#3\\\"); // FnbswapExchange20#_currencyToToken: DEADLINE_EXCEEDED\\r\\n\\r\\n    // Number of Token IDs to deposit\\r\\n    uint256 nTokens = _tokenIds.length;\\r\\n    uint256 totalRefundCurrency = _maxCurrency;\\r\\n\\r\\n    // Initialize variables\\r\\n    currencySold = new uint256[](nTokens); // Amount of currency tokens sold per ID\\r\\n\\r\\n    // Get token reserves\\r\\n    uint256[] memory tokenReserves = _getTokenReserves(_tokenIds);\\r\\n\\r\\n    // Assumes the currency Tokens are already received by contract, but not\\r\\n    // the Tokens Ids\\r\\n\\r\\n    // Remove liquidity for each Token ID in _tokenIds\\r\\n    for (uint256 i = 0; i < nTokens; i++) {\\r\\n      // Store current id and amount from argument arrays\\r\\n      uint256 idBought = _tokenIds[i];\\r\\n      uint256 amountBought = _tokensBoughtAmounts[i];\\r\\n      uint256 tokenReserve = tokenReserves[i];\\r\\n\\r\\n      require(amountBought > 0, \\\"NE20#4\\\"); // FnbswapExchange20#_currencyToToken: NULL_TOKENS_BOUGHT\\r\\n\\r\\n      // Load currency token and Token _id reserves\\r\\n      uint256 currencyReserve = currencyReserves[idBought];\\r\\n\\r\\n      // Get amount of currency tokens to send for purchase\\r\\n      // Neither reserves amount have been changed so far in this transaction, so\\r\\n      // no adjustment to the inputs is needed\\r\\n      uint256 currencyAmount = getBuyPrice(amountBought, currencyReserve, tokenReserve);\\r\\n\\r\\n      // If royalty, increase amount buyer will need to pay after LP fees were calculated\\r\\n      // Note: Royalty will be a bit higher since LF fees are added first\\r\\n      (address royaltyRecipient, uint256 royaltyAmount) = getRoyaltyInfo(idBought, currencyAmount);\\r\\n      if (royaltyAmount > 0) {\\r\\n        royaltiesNumerator[royaltyRecipient] = royaltiesNumerator[royaltyRecipient].add(royaltyAmount.mul(ROYALTIES_DENOMINATOR));\\r\\n      }\\r\\n\\r\\n      // Calculate currency token amount to refund (if any) where whatever is not used will be returned\\r\\n      // Will throw if total cost exceeds _maxCurrency\\r\\n      totalRefundCurrency = totalRefundCurrency.sub(currencyAmount).sub(royaltyAmount);\\r\\n\\r\\n      // Append Token id, Token id amount and currency token amount to tracking arrays\\r\\n      currencySold[i] = currencyAmount.add(royaltyAmount);\\r\\n\\r\\n      // Update individual currency reseve amount (royalty is not added to liquidity)\\r\\n      currencyReserves[idBought] = currencyReserve.add(currencyAmount);\\r\\n    }\\r\\n\\r\\n    // Send Tokens all tokens purchased\\r\\n    token.safeBatchTransferFrom(address(this), _recipient, _tokenIds, _tokensBoughtAmounts, \\\"\\\");\\r\\n    \\r\\n    // Refund currency token if any\\r\\n    if (totalRefundCurrency > 0) {\\r\\n      TransferHelper.safeTransfer(currency, _recipient, totalRefundCurrency);\\r\\n    }\\r\\n\\r\\n    return currencySold;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Pricing function used for converting between currency token to Tokens.\\r\\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\\r\\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\\r\\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\\r\\n   * @return price Amount of currency tokens to send to Fnbswap.\\r\\n   */\\r\\n  function getBuyPrice(\\r\\n    uint256 _assetBoughtAmount,\\r\\n    uint256 _assetSoldReserve,\\r\\n    uint256 _assetBoughtReserve)\\r\\n    override public view returns (uint256 price)\\r\\n  {\\r\\n    // Reserves must not be empty\\r\\n    require(_assetSoldReserve > 0 && _assetBoughtReserve > 0, \\\"NE20#5\\\"); // FnbswapExchange20#getBuyPrice: EMPTY_RESERVE\\r\\n\\r\\n    // Calculate price with fee\\r\\n    uint256 numerator = _assetSoldReserve.mul(_assetBoughtAmount).mul(1000);\\r\\n    uint256 denominator = (_assetBoughtReserve.sub(_assetBoughtAmount)).mul(FEE_MULTIPLIER);\\r\\n    (price, ) = divRound(numerator, denominator);\\r\\n    return price; // Will add 1 if rounding error\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\\r\\n   * @param _tokenId            Id ot token being sold\\r\\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\\r\\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\\r\\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\\r\\n   * @return price Amount of currency tokens to send to Fnbswap.\\r\\n   */\\r\\n  function getBuyPriceWithRoyalty(\\r\\n    uint256 _tokenId,\\r\\n    uint256 _assetBoughtAmount,\\r\\n    uint256 _assetSoldReserve,\\r\\n    uint256 _assetBoughtReserve)\\r\\n    override public view returns (uint256 price)\\r\\n  {\\r\\n    uint256 cost = getBuyPrice(_assetBoughtAmount, _assetSoldReserve, _assetBoughtReserve);\\r\\n    (, uint256 royaltyAmount) = getRoyaltyInfo(_tokenId, cost);\\r\\n    return cost.add(royaltyAmount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Convert Tokens _id to currency tokens and transfers Tokens to recipient.\\r\\n   * @dev User specifies EXACT Tokens _id sold and MINIMUM currency tokens received.\\r\\n   * @dev Assumes that all trades will be valid, or the whole tx will fail\\r\\n   * @dev Sorting _tokenIds is mandatory for efficient way of preventing duplicated IDs (which would lead to errors)\\r\\n   * @param _tokenIds           Array of Token IDs that are sold\\r\\n   * @param _tokensSoldAmounts  Array of Amount of Tokens sold for each id in _tokenIds.\\r\\n   * @param _minCurrency        Minimum amount of currency tokens to receive\\r\\n   * @param _deadline           Timestamp after which this transaction will be reverted\\r\\n   * @param _recipient          The address that receives output currency tokens.\\r\\n   * @param _extraFeeRecipients  Array of addresses that will receive extra fee\\r\\n   * @param _extraFeeAmounts     Array of amounts of currency that will be sent as extra fee\\r\\n   * @return currencyBought How much currency was actually purchased.\\r\\n   */\\r\\n  function _tokenToCurrency(\\r\\n    uint256[] memory _tokenIds,\\r\\n    uint256[] memory _tokensSoldAmounts,\\r\\n    uint256 _minCurrency,\\r\\n    uint256 _deadline,\\r\\n    address _recipient,\\r\\n    address[] memory _extraFeeRecipients,\\r\\n    uint256[] memory _extraFeeAmounts\\r\\n  )\\r\\n    internal nonReentrant() returns (uint256[] memory currencyBought)\\r\\n  {\\r\\n    // Number of Token IDs to deposit\\r\\n    uint256 nTokens = _tokenIds.length;\\r\\n\\r\\n    // Input validation\\r\\n    require(_deadline >= block.timestamp, \\\"NE20#6\\\"); // FnbswapExchange20#_tokenToCurrency: DEADLINE_EXCEEDED\\r\\n\\r\\n    // Initialize variables\\r\\n    uint256 totalCurrency = 0; // Total amount of currency tokens to transfer\\r\\n    currencyBought = new uint256[](nTokens);\\r\\n\\r\\n    // Get token reserves\\r\\n    uint256[] memory tokenReserves = _getTokenReserves(_tokenIds);\\r\\n\\r\\n    // Assumes the Tokens ids are already received by contract, but not\\r\\n    // the Tokens Ids. Will return cards not sold if invalid price.\\r\\n\\r\\n    // Remove liquidity for each Token ID in _tokenIds\\r\\n    for (uint256 i = 0; i < nTokens; i++) {\\r\\n      // Store current id and amount from argument arrays\\r\\n      uint256 idSold = _tokenIds[i];\\r\\n      uint256 amountSold = _tokensSoldAmounts[i];\\r\\n      uint256 tokenReserve = tokenReserves[i];\\r\\n\\r\\n      // If 0 tokens send for this ID, revert\\r\\n      require(amountSold > 0, \\\"NE20#7\\\"); // FnbswapExchange20#_tokenToCurrency: NULL_TOKENS_SOLD\\r\\n\\r\\n      // Load currency token and Token _id reserves\\r\\n      uint256 currencyReserve = currencyReserves[idSold];\\r\\n\\r\\n      // Get amount of currency that will be received\\r\\n      // Need to sub amountSold because tokens already added in reserve, which would bias the calculation\\r\\n      // Don't need to add it for currencyReserve because the amount is added after this calculation\\r\\n      uint256 currencyAmount = getSellPrice(amountSold, tokenReserve.sub(amountSold), currencyReserve);\\r\\n\\r\\n      // If royalty, substract amount seller will receive after LP fees were calculated\\r\\n      // Note: Royalty will be a bit lower since LF fees are substracted first\\r\\n      (address royaltyRecipient, uint256 royaltyAmount) = getRoyaltyInfo(idSold, currencyAmount);\\r\\n      if (royaltyAmount > 0) {\\r\\n        royaltiesNumerator[royaltyRecipient] = royaltiesNumerator[royaltyRecipient].add(royaltyAmount.mul(ROYALTIES_DENOMINATOR));\\r\\n      }\\r\\n\\r\\n      // Increase total amount of currency to receive (minus royalty to pay)\\r\\n      totalCurrency = totalCurrency.add(currencyAmount.sub(royaltyAmount));\\r\\n\\r\\n      // Update individual currency reseve amount\\r\\n      currencyReserves[idSold] = currencyReserve.sub(currencyAmount);\\r\\n\\r\\n      // Append Token id, Token id amount and currency token amount to tracking arrays\\r\\n      currencyBought[i] = currencyAmount.sub(royaltyAmount);\\r\\n    }\\r\\n\\r\\n    // Set the extra fees aside to recipients after sale\\r\\n    for (uint256 i = 0; i < _extraFeeAmounts.length; i++) {\\r\\n      if (_extraFeeAmounts[i] > 0) {\\r\\n        totalCurrency = totalCurrency.sub(_extraFeeAmounts[i]);\\r\\n        royaltiesNumerator[_extraFeeRecipients[i]] = royaltiesNumerator[_extraFeeRecipients[i]].add(_extraFeeAmounts[i].mul(ROYALTIES_DENOMINATOR));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // If minCurrency is not met\\r\\n    require(totalCurrency >= _minCurrency, \\\"NE20#8\\\"); // FnbswapExchange20#_tokenToCurrency: INSUFFICIENT_CURRENCY_AMOUNT\\r\\n\\r\\n    // Transfer currency here\\r\\n    TransferHelper.safeTransfer(currency, _recipient, totalCurrency);\\r\\n    return currencyBought;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Pricing function used for converting Tokens to currency token.\\r\\n   * @param _assetSoldAmount    Amount of Tokens being sold.\\r\\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\\r\\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\\r\\n   * @return price Amount of currency tokens to receive from Fnbswap.\\r\\n   */\\r\\n  function getSellPrice(\\r\\n    uint256 _assetSoldAmount,\\r\\n    uint256 _assetSoldReserve,\\r\\n    uint256 _assetBoughtReserve)\\r\\n    override public view returns (uint256 price)\\r\\n  {\\r\\n    //Reserves must not be empty\\r\\n    require(_assetSoldReserve > 0 && _assetBoughtReserve > 0, \\\"NE20#9\\\"); // FnbswapExchange20#getSellPrice: EMPTY_RESERVE\\r\\n\\r\\n    // Calculate amount to receive (with fee) before royalty\\r\\n    uint256 _assetSoldAmount_withFee = _assetSoldAmount.mul(FEE_MULTIPLIER);\\r\\n    uint256 numerator = _assetSoldAmount_withFee.mul(_assetBoughtReserve);\\r\\n    uint256 denominator = _assetSoldReserve.mul(1000).add(_assetSoldAmount_withFee);\\r\\n    return numerator / denominator; //Rounding errors will favor Fnbswap, so nothing to do\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\\r\\n   * @param _tokenId            Id ot token being sold\\r\\n   * @param _assetSoldAmount    Amount of Tokens being sold.\\r\\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\\r\\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\\r\\n   * @return price Amount of currency tokens to receive from Fnbswap.\\r\\n   */\\r\\n  function getSellPriceWithRoyalty(\\r\\n    uint256 _tokenId,\\r\\n    uint256 _assetSoldAmount,\\r\\n    uint256 _assetSoldReserve,\\r\\n    uint256 _assetBoughtReserve)\\r\\n    override public view returns (uint256 price)\\r\\n  {\\r\\n    uint256 sellAmount = getSellPrice(_assetSoldAmount, _assetSoldReserve, _assetBoughtReserve);\\r\\n    (, uint256 royaltyAmount) = getRoyaltyInfo(_tokenId, sellAmount);\\r\\n    return sellAmount.sub(royaltyAmount);\\r\\n  }\\r\\n\\r\\n  /***********************************|\\r\\n  |        Liquidity Functions        |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Deposit less than max currency tokens && exact Tokens (token ID) at current ratio to mint liquidity pool tokens.\\r\\n   * @dev min_liquidity does nothing when total liquidity pool token supply is 0.\\r\\n   * @dev Assumes that sender approved this contract on the currency\\r\\n   * @dev Sorting _tokenIds is mandatory for efficient way of preventing duplicated IDs (which would lead to errors)\\r\\n   * @param _provider      Address that provides liquidity to the reserve\\r\\n   * @param _tokenIds      Array of Token IDs where liquidity is added\\r\\n   * @param _tokenAmounts  Array of amount of Tokens deposited corresponding to each ID provided in _tokenIds\\r\\n   * @param _maxCurrency   Array of maximum number of tokens deposited for each ID provided in _tokenIds.\\r\\n   *                       Deposits max amount if total liquidity pool token supply is 0.\\r\\n   * @param _deadline      Timestamp after which this transaction will be reverted\\r\\n   */\\r\\n  function _addLiquidity(\\r\\n    address _provider,\\r\\n    uint256[] memory _tokenIds,\\r\\n    uint256[] memory _tokenAmounts,\\r\\n    uint256[] memory _maxCurrency,\\r\\n    uint256 _deadline)\\r\\n    internal nonReentrant()\\r\\n  {\\r\\n    // Requirements\\r\\n    require(_deadline >= block.timestamp, \\\"NE20#10\\\"); // FnbswapExchange20#_addLiquidity: DEADLINE_EXCEEDED\\r\\n\\r\\n    // Initialize variables\\r\\n    uint256 nTokens = _tokenIds.length; // Number of Token IDs to deposit\\r\\n    uint256 totalCurrency = 0;          // Total amount of currency tokens to transfer\\r\\n\\r\\n    // Initialize arrays\\r\\n    uint256[] memory liquiditiesToMint = new uint256[](nTokens);\\r\\n    uint256[] memory currencyAmounts = new uint256[](nTokens);\\r\\n\\r\\n    // Get token reserves\\r\\n    uint256[] memory tokenReserves = _getTokenReserves(_tokenIds);\\r\\n\\r\\n    // Assumes tokens _ids are deposited already, but not currency tokens\\r\\n    // as this is calculated and executed below.\\r\\n\\r\\n    // Loop over all Token IDs to deposit\\r\\n    for (uint256 i = 0; i < nTokens; i ++) {\\r\\n      // Store current id and amount from argument arrays\\r\\n      uint256 tokenId = _tokenIds[i];\\r\\n      uint256 amount = _tokenAmounts[i];\\r\\n\\r\\n      // Check if input values are acceptable\\r\\n      require(_maxCurrency[i] > 0, \\\"NE20#11\\\"); // FnbswapExchange20#_addLiquidity: NULL_MAX_CURRENCY\\r\\n      require(amount > 0, \\\"NE20#12\\\"); // FnbswapExchange20#_addLiquidity: NULL_TOKENS_AMOUNT\\r\\n\\r\\n      // Current total liquidity calculated in currency token\\r\\n      uint256 totalLiquidity = totalSupplies[tokenId];\\r\\n\\r\\n      // When reserve for this token already exists\\r\\n      if (totalLiquidity > 0) {\\r\\n\\r\\n        // Load currency token and Token reserve's supply of Token id\\r\\n        uint256 currencyReserve = currencyReserves[tokenId]; // Amount not yet in reserve\\r\\n        uint256 tokenReserve = tokenReserves[i];\\r\\n\\r\\n        /**\\r\\n        * Amount of currency tokens to send to token id reserve:\\r\\n        * X/Y = dx/dy\\r\\n        * dx = X*dy/Y\\r\\n        * where\\r\\n        *   X:  currency total liquidity\\r\\n        *   Y:  Token _id total liquidity (before tokens were received)\\r\\n        *   dy: Amount of token _id deposited\\r\\n        *   dx: Amount of currency to deposit\\r\\n        *\\r\\n        * Adding .add(1) if rounding errors so to not favor users incorrectly\\r\\n        */\\r\\n        (uint256 currencyAmount, bool rounded) = divRound(amount.mul(currencyReserve), tokenReserve.sub(amount));\\r\\n        require(_maxCurrency[i] >= currencyAmount, \\\"NE20#13\\\"); // FnbswapExchange20#_addLiquidity: MAX_CURRENCY_AMOUNT_EXCEEDED\\r\\n\\r\\n        // Update currency reserve size for Token id before transfer\\r\\n        currencyReserves[tokenId] = currencyReserve.add(currencyAmount);\\r\\n\\r\\n        // Update totalCurrency\\r\\n        totalCurrency = totalCurrency.add(currencyAmount);\\r\\n\\r\\n        // Proportion of the liquidity pool to give to current liquidity provider\\r\\n        // If rounding error occured, round down to favor previous liquidity providers\\r\\n        liquiditiesToMint[i] = (currencyAmount.sub(rounded ? 1 : 0)).mul(totalLiquidity) / currencyReserve;\\r\\n        currencyAmounts[i] = currencyAmount;\\r\\n\\r\\n        // Mint liquidity ownership tokens and increase liquidity supply accordingly\\r\\n        totalSupplies[tokenId] = totalLiquidity.add(liquiditiesToMint[i]);\\r\\n\\r\\n      } else {\\r\\n        uint256 maxCurrency = _maxCurrency[i];\\r\\n\\r\\n        // Otherwise rounding error could end up being significant on second deposit\\r\\n        require(maxCurrency >= 1000, \\\"NE20#14\\\"); // FnbswapExchange20#_addLiquidity: INVALID_CURRENCY_AMOUNT\\r\\n\\r\\n        // Update currency  reserve size for Token id before transfer\\r\\n        currencyReserves[tokenId] = maxCurrency;\\r\\n\\r\\n        // Update totalCurrency\\r\\n        totalCurrency = totalCurrency.add(maxCurrency);\\r\\n\\r\\n        // Initial liquidity is amount deposited (Incorrect pricing will be arbitraged)\\r\\n        // uint256 initialLiquidity = _maxCurrency;\\r\\n        totalSupplies[tokenId] = maxCurrency;\\r\\n\\r\\n        // Liquidity to mints\\r\\n        liquiditiesToMint[i] = maxCurrency;\\r\\n        currencyAmounts[i] = maxCurrency;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Transfer all currency to this contract\\r\\n    TransferHelper.safeTransferFrom(currency, _provider, address(this), totalCurrency);\\r\\n\\r\\n    // Mint liquidity pool tokens\\r\\n    _batchMint(_provider, _tokenIds, liquiditiesToMint, \\\"\\\");\\r\\n\\r\\n\\r\\n    // Emit event\\r\\n    emit LiquidityAdded(_provider, _tokenIds, _tokenAmounts, currencyAmounts);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Convert pool participation into amounts of token and currency.\\r\\n   * @dev Rounding error of the asset with lower resolution is traded for the other asset.\\r\\n   * @param _amountPool       Participation to be converted to tokens and currency.\\r\\n   * @param _tokenReserve     Amount of tokens on the AMM reserve.\\r\\n   * @param _currencyReserve  Amount of currency on the AMM reserve.\\r\\n   * @param _totalLiquidity   Total liquidity on the pool.\\r\\n   *\\r\\n   * @return currencyAmount Currency corresponding to pool amount plus rounded tokens.\\r\\n   * @return tokenAmount    Token corresponding to pool amount plus rounded currency.\\r\\n   */\\r\\n  function _toRoundedLiquidity(\\r\\n    uint256 _tokenId,\\r\\n    uint256 _amountPool,\\r\\n    uint256 _tokenReserve,\\r\\n    uint256 _currencyReserve,\\r\\n    uint256 _totalLiquidity\\r\\n  ) internal view returns (\\r\\n    uint256 currencyAmount,\\r\\n    uint256 tokenAmount,\\r\\n    uint256 soldTokenNumerator,\\r\\n    uint256 boughtCurrencyNumerator,\\r\\n    address royaltyRecipient,\\r\\n    uint256 royaltyNumerator\\r\\n  ) {\\r\\n    uint256 currencyNumerator = _amountPool.mul(_currencyReserve);\\r\\n    uint256 tokenNumerator = _amountPool.mul(_tokenReserve);\\r\\n\\r\\n    // Convert all tokenProduct rest to currency\\r\\n    soldTokenNumerator = tokenNumerator % _totalLiquidity;\\r\\n\\r\\n    if (soldTokenNumerator != 0) {\\r\\n      // The trade happens \\\"after\\\" funds are out of the pool\\r\\n      // so we need to remove these funds before computing the rate\\r\\n      uint256 virtualTokenReserve = _tokenReserve.sub(tokenNumerator / _totalLiquidity).mul(_totalLiquidity);\\r\\n      uint256 virtualCurrencyReserve = _currencyReserve.sub(currencyNumerator / _totalLiquidity).mul(_totalLiquidity);\\r\\n\\r\\n      // Skip process if any of the two reserves is left empty\\r\\n      // this step is important to avoid an error withdrawing all left liquidity\\r\\n      if (virtualCurrencyReserve != 0 && virtualTokenReserve != 0) {\\r\\n        boughtCurrencyNumerator = getSellPrice(soldTokenNumerator, virtualTokenReserve, virtualCurrencyReserve);\\r\\n\\r\\n        // Discount royalty currency\\r\\n        (royaltyRecipient, royaltyNumerator) = getRoyaltyInfo(_tokenId, boughtCurrencyNumerator);\\r\\n        boughtCurrencyNumerator = boughtCurrencyNumerator.sub(royaltyNumerator);\\r\\n\\r\\n        currencyNumerator = currencyNumerator.add(boughtCurrencyNumerator);\\r\\n\\r\\n        // Add royalty numerator (needs to be converted to ROYALTIES_DENOMINATOR)\\r\\n        royaltyNumerator = royaltyNumerator.mul(ROYALTIES_DENOMINATOR) / _totalLiquidity;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Calculate amounts\\r\\n    currencyAmount = currencyNumerator / _totalLiquidity;\\r\\n    tokenAmount = tokenNumerator / _totalLiquidity;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Burn liquidity pool tokens to withdraw currency  && Tokens at current ratio.\\r\\n   * @dev Sorting _tokenIds is mandatory for efficient way of preventing duplicated IDs (which would lead to errors)\\r\\n   * @param _provider         Address that removes liquidity to the reserve\\r\\n   * @param _tokenIds         Array of Token IDs where liquidity is removed\\r\\n   * @param _poolTokenAmounts Array of Amount of liquidity pool tokens burned for each Token id in _tokenIds.\\r\\n   * @param _minCurrency      Minimum currency withdrawn for each Token id in _tokenIds.\\r\\n   * @param _minTokens        Minimum Tokens id withdrawn for each Token id in _tokenIds.\\r\\n   * @param _deadline         Timestamp after which this transaction will be reverted\\r\\n   */\\r\\n  function _removeLiquidity(\\r\\n    address _provider,\\r\\n    uint256[] memory _tokenIds,\\r\\n    uint256[] memory _poolTokenAmounts,\\r\\n    uint256[] memory _minCurrency,\\r\\n    uint256[] memory _minTokens,\\r\\n    uint256 _deadline)\\r\\n    internal nonReentrant()\\r\\n  {\\r\\n    // Input validation\\r\\n    require(_deadline > block.timestamp, \\\"NE20#15\\\"); // FnbswapExchange20#_removeLiquidity: DEADLINE_EXCEEDED\\r\\n\\r\\n    // Initialize variables\\r\\n    uint256 nTokens = _tokenIds.length;                        // Number of Token IDs to deposit\\r\\n    uint256 totalCurrency = 0;                                 // Total amount of currency  to transfer\\r\\n    uint256[] memory tokenAmounts = new uint256[](nTokens);    // Amount of Tokens to transfer for each id\\r\\n \\r\\n    // Structs contain most information for the event\\r\\n    // notice: tokenAmounts and tokenIds are absent because we already\\r\\n    // either have those arrays constructed or we need to construct them for other reasons\\r\\n    LiquidityRemovedEventObj[] memory eventObjs = new LiquidityRemovedEventObj[](nTokens);\\r\\n\\r\\n    // Get token reserves\\r\\n    uint256[] memory tokenReserves = _getTokenReserves(_tokenIds);\\r\\n\\r\\n    // Assumes NIFTY liquidity tokens are already received by contract, but not\\r\\n    // the currency nor the Tokens Ids\\r\\n\\r\\n    // Remove liquidity for each Token ID in _tokenIds\\r\\n    for (uint256 i = 0; i < nTokens; i++) {\\r\\n      // Store current id and amount from argument arrays\\r\\n      uint256 id = _tokenIds[i];\\r\\n      uint256 amountPool = _poolTokenAmounts[i];\\r\\n\\r\\n      // Load total liquidity pool token supply for Token _id\\r\\n      uint256 totalLiquidity = totalSupplies[id];\\r\\n      require(totalLiquidity > 0, \\\"NE20#16\\\"); // FnbswapExchange20#_removeLiquidity: NULL_TOTAL_LIQUIDITY\\r\\n\\r\\n      // Load currency and Token reserve's supply of Token id\\r\\n      uint256 currencyReserve = currencyReserves[id];\\r\\n\\r\\n      // Calculate amount to withdraw for currency  and Token _id\\r\\n      uint256 currencyAmount;\\r\\n      uint256 tokenAmount;\\r\\n\\r\\n      {\\r\\n        uint256 tokenReserve = tokenReserves[i];\\r\\n        uint256 soldTokenNumerator;\\r\\n        uint256 boughtCurrencyNumerator;\\r\\n        address royaltyRecipient;\\r\\n        uint256 royaltyNumerator;\\r\\n\\r\\n        (\\r\\n          currencyAmount,\\r\\n          tokenAmount,\\r\\n          soldTokenNumerator,\\r\\n          boughtCurrencyNumerator,\\r\\n          royaltyRecipient,\\r\\n          royaltyNumerator\\r\\n        ) = _toRoundedLiquidity(id, amountPool, tokenReserve, currencyReserve, totalLiquidity);\\r\\n\\r\\n        // Add royalties\\r\\n        royaltiesNumerator[royaltyRecipient] = royaltiesNumerator[royaltyRecipient].add(royaltyNumerator);\\r\\n\\r\\n        // Add trade info to event\\r\\n        eventObjs[i].soldTokenNumerator = soldTokenNumerator;\\r\\n        eventObjs[i].boughtCurrencyNumerator = boughtCurrencyNumerator;\\r\\n        eventObjs[i].totalSupply = totalLiquidity;\\r\\n      }\\r\\n\\r\\n      // Verify if amounts to withdraw respect minimums specified\\r\\n      require(currencyAmount >= _minCurrency[i], \\\"NE20#17\\\"); // FnbswapExchange20#_removeLiquidity: INSUFFICIENT_CURRENCY_AMOUNT\\r\\n      require(tokenAmount >= _minTokens[i], \\\"NE20#18\\\"); // FnbswapExchange20#_removeLiquidity: INSUFFICIENT_TOKENS\\r\\n\\r\\n      // Update total liquidity pool token supply of Token _id\\r\\n      totalSupplies[id] = totalLiquidity.sub(amountPool);\\r\\n\\r\\n      // Update currency reserve size for Token id\\r\\n      currencyReserves[id] = currencyReserve.sub(currencyAmount);\\r\\n\\r\\n      // Update totalCurrency and tokenAmounts\\r\\n      totalCurrency = totalCurrency.add(currencyAmount);\\r\\n      tokenAmounts[i] = tokenAmount;\\r\\n\\r\\n      eventObjs[i].currencyAmount = currencyAmount;\\r\\n    }\\r\\n\\r\\n    // Burn liquidity pool tokens for offchain supplies\\r\\n    _batchBurn(address(this), _tokenIds, _poolTokenAmounts);\\r\\n\\r\\n    // Transfer total currency and all Tokens ids\\r\\n    TransferHelper.safeTransfer(currency, _provider, totalCurrency);\\r\\n    token.safeBatchTransferFrom(address(this), _provider, _tokenIds, tokenAmounts, \\\"\\\");\\r\\n\\r\\n    // Emit event\\r\\n    emit LiquidityRemoved(_provider, _tokenIds, tokenAmounts, eventObjs);\\r\\n  }\\r\\n\\r\\n  /***********************************|\\r\\n  |     Receiver Methods Handler      |\\r\\n  |__________________________________*/\\r\\n\\r\\n  // Method signatures for onReceive control logic\\r\\n\\r\\n  // bytes4(keccak256(\\r\\n  //   \\\"_tokenToCurrency(uint256[],uint256[],uint256,uint256,address,address[],uint256[])\\\"\\r\\n  // ));\\r\\n  bytes4 internal constant SELLTOKENS_SIG = 0xade79c7a;\\r\\n\\r\\n  //  bytes4(keccak256(\\r\\n  //   \\\"_addLiquidity(address,uint256[],uint256[],uint256[],uint256)\\\"\\r\\n  // ));\\r\\n  bytes4 internal constant ADDLIQUIDITY_SIG = 0x82da2b73;\\r\\n\\r\\n  // bytes4(keccak256(\\r\\n  //    \\\"_removeLiquidity(address,uint256[],uint256[],uint256[],uint256[],uint256)\\\"\\r\\n  // ));\\r\\n  bytes4 internal constant REMOVELIQUIDITY_SIG = 0x5c0bf259;\\r\\n\\r\\n  // bytes4(keccak256(\\r\\n  //   \\\"DepositTokens()\\\"\\r\\n  // ));\\r\\n  bytes4 internal constant DEPOSIT_SIG = 0xc8c323f9;\\r\\n\\r\\n  /***********************************|\\r\\n  |           Buying Tokens           |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\\r\\n   * @dev User specifies MAXIMUM inputs (_maxCurrency) and EXACT outputs.\\r\\n   * @dev Assumes that all trades will be successful, or revert the whole tx\\r\\n   * @dev Exceeding currency tokens sent will be refunded to recipient\\r\\n   * @dev Sorting IDs is mandatory for efficient way of preventing duplicated IDs (which would lead to exploit)\\r\\n   * @param _tokenIds            Array of Tokens ID that are bought\\r\\n   * @param _tokensBoughtAmounts Amount of Tokens id bought for each corresponding Token id in _tokenIds\\r\\n   * @param _maxCurrency         Total maximum amount of currency tokens to spend for all Token ids\\r\\n   * @param _deadline            Timestamp after which this transaction will be reverted\\r\\n   * @param _recipient           The address that receives output Tokens and refund\\r\\n   * @param _extraFeeRecipients  Array of addresses that will receive extra fee\\r\\n   * @param _extraFeeAmounts     Array of amounts of currency that will be sent as extra fee\\r\\n   * @return currencySold How much currency was actually sold.\\r\\n   */\\r\\n  function buyTokens(\\r\\n    uint256[] memory _tokenIds,\\r\\n    uint256[] memory _tokensBoughtAmounts,\\r\\n    uint256 _maxCurrency,\\r\\n    uint256 _deadline,\\r\\n    address _recipient,\\r\\n    address[] memory _extraFeeRecipients,\\r\\n    uint256[] memory _extraFeeAmounts\\r\\n  )\\r\\n    override external returns (uint256[] memory)\\r\\n  {\\r\\n    require(_deadline >= block.timestamp, \\\"NE20#19\\\"); // FnbswapExchange20#buyTokens: DEADLINE_EXCEEDED\\r\\n    require(_tokenIds.length > 0, \\\"NE20#20\\\"); // FnbswapExchange20#buyTokens: INVALID_CURRENCY_IDS_AMOUNT\\r\\n\\r\\n    // Transfer the tokens for purchase\\r\\n    TransferHelper.safeTransferFrom(currency, msg.sender, address(this), _maxCurrency);\\r\\n\\r\\n    address recipient = _recipient == address(0x0) ? msg.sender : _recipient;\\r\\n\\r\\n    // Set the extra fee aside to recipients ahead of purchase, if any.\\r\\n    uint256 maxCurrency = _maxCurrency;\\r\\n    uint256 nExtraFees = _extraFeeRecipients.length;\\r\\n    require(nExtraFees == _extraFeeAmounts.length, \\\"NE20#21\\\"); // FnbswapExchange20#buyTokens: EXTRA_FEES_ARRAYS_ARE_NOT_SAME_LENGTH\\r\\n    \\r\\n    for (uint256 i = 0; i < nExtraFees; i++) {\\r\\n      if (_extraFeeAmounts[i] > 0) {\\r\\n        maxCurrency = maxCurrency.sub(_extraFeeAmounts[i]);\\r\\n        royaltiesNumerator[_extraFeeRecipients[i]] = royaltiesNumerator[_extraFeeRecipients[i]].add(_extraFeeAmounts[i].mul(ROYALTIES_DENOMINATOR));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Execute trade and retrieve amount of currency spent\\r\\n    uint256[] memory currencySold = _currencyToToken(_tokenIds, _tokensBoughtAmounts, maxCurrency, _deadline, recipient);\\r\\n    emit TokensPurchase(msg.sender, recipient, _tokenIds, _tokensBoughtAmounts, currencySold, _extraFeeRecipients, _extraFeeAmounts);\\r\\n\\r\\n    return currencySold;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Handle which method is being called on transfer\\r\\n   * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\\r\\n   *   where bytes4 argument is the MethodObj object signature passed as defined\\r\\n   *   in the `Signatures for onReceive control logic` section above\\r\\n   * @param _from     The address which previously owned the Token\\r\\n   * @param _ids      An array containing ids of each Token being transferred\\r\\n   * @param _amounts  An array containing amounts of each Token being transferred\\r\\n   * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\\r\\n   * @return bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\")\\r\\n   */\\r\\n  function onERC1155BatchReceived(\\r\\n    address, // _operator,\\r\\n    address _from,\\r\\n    uint256[] memory _ids,\\r\\n    uint256[] memory _amounts,\\r\\n    bytes memory _data)\\r\\n    override public returns(bytes4)\\r\\n  {\\r\\n    // This function assumes that the ERC-1155 token contract can\\r\\n    // only call `onERC1155BatchReceived()` via a valid token transfer.\\r\\n    // Users must be responsible and only use this Fnbswap exchange\\r\\n    // contract with ERC-1155 compliant token contracts.\\r\\n\\r\\n    // Obtain method to call via object signature\\r\\n    bytes4 functionSignature = abi.decode(_data, (bytes4));\\r\\n\\r\\n    /***********************************|\\r\\n    |           Selling Tokens          |\\r\\n    |__________________________________*/\\r\\n\\r\\n    if (functionSignature == SELLTOKENS_SIG) {\\r\\n\\r\\n      // Tokens received need to be Token contract\\r\\n      require(msg.sender == address(token), \\\"NE20#22\\\"); // FnbswapExchange20#onERC1155BatchReceived: INVALID_TOKENS_TRANSFERRED\\r\\n\\r\\n      // Decode SellTokensObj from _data to call _tokenToCurrency()\\r\\n      SellTokensObj memory obj;\\r\\n      (, obj) = abi.decode(_data, (bytes4, SellTokensObj));\\r\\n      address recipient = obj.recipient == address(0x0) ? _from : obj.recipient;\\r\\n\\r\\n      // Validate fee arrays\\r\\n      require(obj.extraFeeRecipients.length == obj.extraFeeAmounts.length, \\\"NE20#23\\\"); // FnbswapExchange20#buyTokens: EXTRA_FEES_ARRAYS_ARE_NOT_SAME_LENGTH\\r\\n    \\r\\n      // Execute trade and retrieve amount of currency received\\r\\n      uint256[] memory currencyBought = _tokenToCurrency(_ids, _amounts, obj.minCurrency, obj.deadline, recipient, obj.extraFeeRecipients, obj.extraFeeAmounts);\\r\\n      emit CurrencyPurchase(_from, recipient, _ids, _amounts, currencyBought, obj.extraFeeRecipients, obj.extraFeeAmounts);\\r\\n\\r\\n    /***********************************|\\r\\n    |      Adding Liquidity Tokens      |\\r\\n    |__________________________________*/\\r\\n\\r\\n    } else if (functionSignature == ADDLIQUIDITY_SIG) {\\r\\n      // Only allow to receive ERC-1155 tokens from `token` contract\\r\\n      require(msg.sender == address(token), \\\"NE20#24\\\"); // FnbswapExchange20#onERC1155BatchReceived: INVALID_TOKEN_TRANSFERRED\\r\\n\\r\\n      // Decode AddLiquidityObj from _data to call _addLiquidity()\\r\\n      AddLiquidityObj memory obj;\\r\\n      (, obj) = abi.decode(_data, (bytes4, AddLiquidityObj));\\r\\n      _addLiquidity(_from, _ids, _amounts, obj.maxCurrency, obj.deadline);\\r\\n\\r\\n    /***********************************|\\r\\n    |      Removing iquidity Tokens     |\\r\\n    |__________________________________*/\\r\\n\\r\\n    } else if (functionSignature == REMOVELIQUIDITY_SIG) {\\r\\n      // Tokens received need to be NIFTY-1155 tokens\\r\\n      require(msg.sender == address(this), \\\"NE20#25\\\"); // FnbswapExchange20#onERC1155BatchReceived: INVALID_NIFTY_TOKENS_TRANSFERRED\\r\\n\\r\\n      // Decode RemoveLiquidityObj from _data to call _removeLiquidity()\\r\\n      RemoveLiquidityObj memory obj;\\r\\n      (, obj) = abi.decode(_data, (bytes4, RemoveLiquidityObj));\\r\\n      _removeLiquidity(_from, _ids, _amounts, obj.minCurrency, obj.minTokens, obj.deadline);\\r\\n\\r\\n    /***********************************|\\r\\n    |      Deposits & Invalid Calls     |\\r\\n    |__________________________________*/\\r\\n\\r\\n    } else if (functionSignature == DEPOSIT_SIG) {\\r\\n      // Do nothing for when contract is self depositing\\r\\n      // This could be use to deposit currency \\\"by accident\\\", which would be locked\\r\\n      require(msg.sender == address(currency), \\\"NE20#26\\\"); // FnbswapExchange20#onERC1155BatchReceived: INVALID_TOKENS_DEPOSITED\\r\\n\\r\\n    } else {\\r\\n      revert(\\\"NE20#27\\\"); // FnbswapExchange20#onERC1155BatchReceived: INVALID_METHOD\\r\\n    }\\r\\n\\r\\n    return ERC1155_BATCH_RECEIVED_VALUE;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Will pass to onERC115Batch5Received\\r\\n   */\\r\\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes memory _data)\\r\\n    override public returns(bytes4)\\r\\n  {\\r\\n    uint256[] memory ids = new uint256[](1);\\r\\n    uint256[] memory amounts = new uint256[](1);\\r\\n\\r\\n    ids[0] = _id;\\r\\n    amounts[0] = _amount;\\r\\n\\r\\n    require(\\r\\n      ERC1155_BATCH_RECEIVED_VALUE == onERC1155BatchReceived(_operator, _from, ids, amounts, _data),\\r\\n      \\\"NE20#28\\\" // FnbswapExchange20#onERC1155Received: INVALID_ONRECEIVED_MESSAGE\\r\\n    );\\r\\n\\r\\n    return ERC1155_RECEIVED_VALUE;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Prevents receiving Ether or calls to unsuported methods\\r\\n   */\\r\\n  fallback () external {\\r\\n    revert(\\\"NE20#29\\\"); // FnbswapExchange20:UNSUPPORTED_METHOD\\r\\n  }\\r\\n\\r\\n  /***********************************|\\r\\n  |         Royalty Functions         |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Will set the royalties fees and recipient for contracts that don't support ERC-2981\\r\\n   * @param _fee       Fee pourcentage with a 10000 basis (e.g. 0.3% is 3 and 1% is 10 and 100% is 1000)\\r\\n   * @param _recipient Address where to send the fees to\\r\\n   */\\r\\n  function setRoyaltyInfo(uint256 _fee, address _recipient) onlyOwner public {\\r\\n    // Don't use IS_ERC2981 in case token contract was updated\\r\\n    bool isERC2981 = token.supportsInterface(type(IERC2981).interfaceId);\\r\\n    require(!isERC2981, \\\"NE20#30\\\"); // FnbswapExchange20#setRoyaltyInfo: TOKEN SUPPORTS ERC-2981\\r\\n    require(_fee <= MAX_ROYALTY, \\\"NE20#31\\\"); // FnbswapExchange20#setRoyaltyInfo: ROYALTY_FEE_IS_TOO_HIGH\\r\\n\\r\\n    globalRoyaltyFee = _fee;\\r\\n    globalRoyaltyRecipient = _recipient;\\r\\n    emit RoyaltyChanged(_recipient, _fee);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Will send the royalties that _royaltyRecipient can claim, if any \\r\\n   * @dev Anyone can call this function such that payout could be distributed \\r\\n   *      regularly instead of being claimed. \\r\\n   * @param _royaltyRecipient Address that is able to claim royalties\\r\\n   */\\r\\n  function sendRoyalties(address _royaltyRecipient) override external {\\r\\n    uint256 royaltyAmount = royaltiesNumerator[_royaltyRecipient] / ROYALTIES_DENOMINATOR;\\r\\n    royaltiesNumerator[_royaltyRecipient] = royaltiesNumerator[_royaltyRecipient] % ROYALTIES_DENOMINATOR;\\r\\n    TransferHelper.safeTransfer(currency, _royaltyRecipient, royaltyAmount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Will return how much of currency need to be paid for the royalty\\r\\n   * @notice Royalty is capped at 25% of the total amount of currency\\r\\n   * @param _tokenId ID of the erc-1155 token being traded\\r\\n   * @param _cost    Amount of currency sent/received for the trade\\r\\n   * @return recipient Address that will be able to claim the royalty\\r\\n   * @return royalty Amount of currency that will be sent to royalty recipient\\r\\n   */\\r\\n  function getRoyaltyInfo(uint256 _tokenId, uint256 _cost) public view returns (address recipient, uint256 royalty) {\\r\\n    if (IS_ERC2981) {\\r\\n      // Add a try/catch in-case token *removed* ERC-2981 support\\r\\n      try IERC2981(address(token)).royaltyInfo(_tokenId, _cost) returns(address _r, uint256 _c) {\\r\\n        // Cap to 25% of the total amount of currency\\r\\n        uint256 max = _cost.mul(MAX_ROYALTY) / ROYALTIES_DENOMINATOR;\\r\\n        return (_r, _c > max ? max : _c);\\r\\n      } catch {\\r\\n        // Default back to global setting if error occurs\\r\\n        return (globalRoyaltyRecipient, (_cost.mul(globalRoyaltyFee)) / ROYALTIES_DENOMINATOR);\\r\\n      }\\r\\n\\r\\n    } else {\\r\\n      return (globalRoyaltyRecipient, (_cost.mul(globalRoyaltyFee)) / ROYALTIES_DENOMINATOR);\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  /***********************************|\\r\\n  |         Getter Functions          |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Get amount of currency in reserve for each Token _id in _ids\\r\\n   * @param _ids Array of ID sto query currency reserve of\\r\\n   * @return amount of currency in reserve for each Token _id\\r\\n   */\\r\\n  function getCurrencyReserves(\\r\\n    uint256[] calldata _ids)\\r\\n    override external view returns (uint256[] memory)\\r\\n  {\\r\\n    uint256 nIds = _ids.length;\\r\\n    uint256[] memory currencyReservesReturn = new uint256[](nIds);\\r\\n    for (uint256 i = 0; i < nIds; i++) {\\r\\n      currencyReservesReturn[i] = currencyReserves[_ids[i]];\\r\\n    }\\r\\n    return currencyReservesReturn;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Return price for `currency => Token _id` trades with an exact token amount.\\r\\n   * @param _ids           Array of ID of tokens bought.\\r\\n   * @param _tokensBought Amount of Tokens bought.\\r\\n   * @return Amount of currency needed to buy Tokens in _ids for amounts in _tokensBought\\r\\n   */\\r\\n  function getPrice_currencyToToken(\\r\\n    uint256[] calldata _ids,\\r\\n    uint256[] calldata _tokensBought)\\r\\n    override external view returns (uint256[] memory)\\r\\n  {\\r\\n    uint256 nIds = _ids.length;\\r\\n    uint256[] memory prices = new uint256[](nIds);\\r\\n\\r\\n    for (uint256 i = 0; i < nIds; i++) {\\r\\n      // Load Token id reserve\\r\\n      uint256 tokenReserve = token.balanceOf(address(this), _ids[i]);\\r\\n      prices[i] = getBuyPriceWithRoyalty(_ids[i], _tokensBought[i], currencyReserves[_ids[i]], tokenReserve);\\r\\n    }\\r\\n\\r\\n    // Return prices\\r\\n    return prices;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Return price for `Token _id => currency` trades with an exact token amount.\\r\\n   * @param _ids        Array of IDs  token sold.\\r\\n   * @param _tokensSold Array of amount of each Token sold.\\r\\n   * @return Amount of currency that can be bought for Tokens in _ids for amounts in _tokensSold\\r\\n   */\\r\\n  function getPrice_tokenToCurrency(\\r\\n    uint256[] calldata _ids,\\r\\n    uint256[] calldata _tokensSold)\\r\\n    override external view returns (uint256[] memory)\\r\\n  {\\r\\n    uint256 nIds = _ids.length;\\r\\n    uint256[] memory prices = new uint256[](nIds);\\r\\n\\r\\n    for (uint256 i = 0; i < nIds; i++) {\\r\\n      // Load Token id reserve\\r\\n      uint256 tokenReserve = token.balanceOf(address(this), _ids[i]);\\r\\n      prices[i] = getSellPriceWithRoyalty(_ids[i], _tokensSold[i], tokenReserve, currencyReserves[_ids[i]]);\\r\\n    }\\r\\n\\r\\n    // Return price\\r\\n    return prices;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Address of Token that is sold on this exchange.\\r\\n   */\\r\\n  function getTokenAddress() override external view returns (address) {\\r\\n    return address(token);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return LP fee per 1000 units\\r\\n   */\\r\\n  function getLPFee() override external view returns (uint256) {\\r\\n    return 1000-FEE_MULTIPLIER;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Address of the currency contract that is used as currency\\r\\n   */\\r\\n  function getCurrencyInfo() override external view returns (address) {\\r\\n    return (address(currency));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Get total supply of liquidity tokens\\r\\n   * @param _ids ID of the Tokens\\r\\n   * @return The total supply of each liquidity token id provided in _ids\\r\\n   */\\r\\n  function getTotalSupply(uint256[] calldata _ids)\\r\\n    override external view returns (uint256[] memory)\\r\\n  {\\r\\n    // Number of ids\\r\\n    uint256 nIds = _ids.length;\\r\\n\\r\\n    // Variables\\r\\n    uint256[] memory batchTotalSupplies = new uint256[](nIds);\\r\\n\\r\\n    // Iterate over each owner and token ID\\r\\n    for (uint256 i = 0; i < nIds; i++) {\\r\\n      batchTotalSupplies[i] = totalSupplies[_ids[i]];\\r\\n    }\\r\\n\\r\\n    return batchTotalSupplies;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Address of factory that created this exchange.\\r\\n   */\\r\\n  function getFactoryAddress() override external view returns (address) {\\r\\n    return factory;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Global royalty fee % if not supporting ERC-2981\\r\\n   */\\r\\n  function getGlobalRoyaltyFee() override external view returns (uint256) {\\r\\n    return globalRoyaltyFee;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Global royalty recipient if token not supporting ERC-2981\\r\\n   */\\r\\n  function getGlobalRoyaltyRecipient() override external view returns (address) {\\r\\n    return globalRoyaltyRecipient;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Get amount of currency in royalty an address can claim\\r\\n   * @param _royaltyRecipient Address to check the claimable royalties\\r\\n   */\\r\\n  function getRoyalties(address _royaltyRecipient) override external view returns (uint256) {\\r\\n    return royaltiesNumerator[_royaltyRecipient] / ROYALTIES_DENOMINATOR;\\r\\n  }\\r\\n\\r\\n  function getRoyaltiesNumerator(address _royaltyRecipient) override external view returns (uint256) {\\r\\n    return royaltiesNumerator[_royaltyRecipient];\\r\\n  }\\r\\n\\r\\n  /***********************************|\\r\\n  |         Utility Functions         |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Divides two numbers and add 1 if there is a rounding error\\r\\n   * @param a Numerator\\r\\n   * @param b Denominator\\r\\n   */\\r\\n  function divRound(uint256 a, uint256 b) internal pure returns (uint256, bool) {\\r\\n    return a % b == 0 ? (a/b, false) : ((a/b).add(1), true);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Return Token reserves for given Token ids\\r\\n   * @dev Assumes that ids are sorted from lowest to highest with no duplicates.\\r\\n   *      This assumption allows for checking the token reserves only once, otherwise\\r\\n   *      token reserves need to be re-checked individually or would have to do more expensive\\r\\n   *      duplication checks.\\r\\n   * @param _tokenIds Array of IDs to query their Reserve balance.\\r\\n   * @return Array of Token ids' reserves\\r\\n   */\\r\\n  function _getTokenReserves(\\r\\n    uint256[] memory _tokenIds)\\r\\n    internal view returns (uint256[] memory)\\r\\n  {\\r\\n    uint256 nTokens = _tokenIds.length;\\r\\n\\r\\n    // Regular balance query if only 1 token, otherwise batch query\\r\\n    if (nTokens == 1) {\\r\\n      uint256[] memory tokenReserves = new uint256[](1);\\r\\n      tokenReserves[0] = token.balanceOf(address(this), _tokenIds[0]);\\r\\n      return tokenReserves;\\r\\n\\r\\n    } else {\\r\\n      // Lazy check preventing duplicates & build address array for query\\r\\n      address[] memory thisAddressArray = new address[](nTokens);\\r\\n      thisAddressArray[0] = address(this);\\r\\n\\r\\n      for (uint256 i = 1; i < nTokens; i++) {\\r\\n        require(_tokenIds[i-1] < _tokenIds[i], \\\"NE20#32\\\"); // FnbswapExchange20#_getTokenReserves: UNSORTED_OR_DUPLICATE_TOKEN_IDS\\r\\n        thisAddressArray[i] = address(this);\\r\\n      }\\r\\n      return token.balanceOfBatch(thisAddressArray, _tokenIds);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\\r\\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\\r\\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\\r\\n   *      This function MUST NOT consume more thsan 5,000 gas.\\r\\n   * @return Whether a given interface is supported\\r\\n   */\\r\\n  function supportsInterface(bytes4 interfaceID) public override pure returns (bool) {\\r\\n    return interfaceID == type(IERC20).interfaceId ||\\r\\n      interfaceID == type(IERC165).interfaceId || \\r\\n      interfaceID == type(IERC1155).interfaceId || \\r\\n      interfaceID == type(IERC1155TokenReceiver).interfaceId ||\\r\\n      interfaceID == type(IERC1155Metadata).interfaceId;\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/FnbswapExchange/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper::safeApprove: approve failed'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper::safeTransfer: transfer failed'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(\\r\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\r\\n            'TransferHelper::transferFrom: transferFrom failed'\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/swap/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity 0.7.4;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/FnbswapExchange/swap/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\nimport \\\"contracts/FnbswapExchange/erc-1155/contracts/interfaces/IERC165.sol\\\";\\r\\n\\r\\n/** \\r\\n * @dev Interface for the NFT Royalty Standard\\r\\n */\\r\\ninterface IERC2981 is IERC165 {\\r\\n  /** \\r\\n   * @notice Called with the sale price to determine how much royalty\\r\\n   *         is owed and to whom.\\r\\n   * @param _tokenId - the NFT asset queried for royalty information\\r\\n   * @param _salePrice - the sale price of the NFT asset specified by _tokenId\\r\\n   * @return receiver - address of who should be sent the royalty payment\\r\\n   * @return royaltyAmount - the royalty payment amount for _salePrice\\r\\n   */\\r\\n  function royaltyInfo(\\r\\n      uint256 _tokenId,\\r\\n      uint256 _salePrice\\r\\n  ) external view returns (\\r\\n      address receiver,\\r\\n      uint256 royaltyAmount\\r\\n  );\\r\\n}\"\r\n    },\r\n    \"contracts/FnbswapExchange/swap/contracts/interfaces/IFnbswapExchange20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IFnbswapExchange20 {\\r\\n\\r\\n  /***********************************|\\r\\n  |               Events              |\\r\\n  |__________________________________*/\\r\\n\\r\\n  event TokensPurchase(\\r\\n    address indexed buyer,\\r\\n    address indexed recipient,\\r\\n    uint256[] tokensBoughtIds,\\r\\n    uint256[] tokensBoughtAmounts,\\r\\n    uint256[] currencySoldAmounts,\\r\\n    address[] extraFeeRecipients,\\r\\n    uint256[] extraFeeAmounts\\r\\n  );\\r\\n\\r\\n  event CurrencyPurchase(\\r\\n    address indexed buyer,\\r\\n    address indexed recipient,\\r\\n    uint256[] tokensSoldIds,\\r\\n    uint256[] tokensSoldAmounts,\\r\\n    uint256[] currencyBoughtAmounts,\\r\\n    address[] extraFeeRecipients,\\r\\n    uint256[] extraFeeAmounts\\r\\n  );\\r\\n\\r\\n  event LiquidityAdded(\\r\\n    address indexed provider,\\r\\n    uint256[] tokenIds,\\r\\n    uint256[] tokenAmounts,\\r\\n    uint256[] currencyAmounts\\r\\n  );\\r\\n\\r\\n  struct LiquidityRemovedEventObj {\\r\\n    uint256 currencyAmount;\\r\\n    uint256 soldTokenNumerator;\\r\\n    uint256 boughtCurrencyNumerator;\\r\\n    uint256 totalSupply;\\r\\n  }\\r\\n\\r\\n  event LiquidityRemoved(\\r\\n    address indexed provider,\\r\\n    uint256[] tokenIds,\\r\\n    uint256[] tokenAmounts,\\r\\n    LiquidityRemovedEventObj[] details\\r\\n  );\\r\\n\\r\\n  event RoyaltyChanged(\\r\\n    address indexed royaltyRecipient,\\r\\n    uint256 royaltyFee\\r\\n  );\\r\\n\\r\\n  struct SellTokensObj {\\r\\n    address recipient;            // Who receives the currency\\r\\n    uint256 minCurrency;          // Total minimum number of currency  expected for all tokens sold\\r\\n    address[] extraFeeRecipients; // Array of addresses that will receive extra fee\\r\\n    uint256[] extraFeeAmounts;    // Array of amounts of currency that will be sent as extra fee\\r\\n    uint256 deadline;             // Timestamp after which the tx isn't valid anymore\\r\\n  }\\r\\n\\r\\n  struct AddLiquidityObj {\\r\\n    uint256[] maxCurrency; // Maximum number of currency to deposit with tokens\\r\\n    uint256 deadline;      // Timestamp after which the tx isn't valid anymore\\r\\n  }\\r\\n\\r\\n  struct RemoveLiquidityObj {\\r\\n    uint256[] minCurrency; // Minimum number of currency to withdraw\\r\\n    uint256[] minTokens;   // Minimum number of tokens to withdraw\\r\\n    uint256 deadline;      // Timestamp after which the tx isn't valid anymore\\r\\n  }\\r\\n\\r\\n\\r\\n  /***********************************|\\r\\n  |        Purchasing Functions       |\\r\\n  |__________________________________*/\\r\\n  \\r\\n  /**\\r\\n   * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\\r\\n   * @dev User specifies MAXIMUM inputs (_maxCurrency) and EXACT outputs.\\r\\n   * @dev Assumes that all trades will be successful, or revert the whole tx\\r\\n   * @dev Exceeding currency tokens sent will be refunded to recipient\\r\\n   * @dev Sorting IDs is mandatory for efficient way of preventing duplicated IDs (which would lead to exploit)\\r\\n   * @param _tokenIds            Array of Tokens ID that are bought\\r\\n   * @param _tokensBoughtAmounts Amount of Tokens id bought for each corresponding Token id in _tokenIds\\r\\n   * @param _maxCurrency         Total maximum amount of currency tokens to spend for all Token ids\\r\\n   * @param _deadline            Timestamp after which this transaction will be reverted\\r\\n   * @param _recipient           The address that receives output Tokens and refund\\r\\n   * @param _extraFeeRecipients  Array of addresses that will receive extra fee\\r\\n   * @param _extraFeeAmounts     Array of amounts of currency that will be sent as extra fee\\r\\n   * @return currencySold How much currency was actually sold.\\r\\n   */\\r\\n  function buyTokens(\\r\\n    uint256[] memory _tokenIds,\\r\\n    uint256[] memory _tokensBoughtAmounts,\\r\\n    uint256 _maxCurrency,\\r\\n    uint256 _deadline,\\r\\n    address _recipient,\\r\\n    address[] memory _extraFeeRecipients,\\r\\n    uint256[] memory _extraFeeAmounts\\r\\n  ) external returns (uint256[] memory);\\r\\n\\r\\n  /***********************************|\\r\\n  |         Royalties Functions       |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Will send the royalties that _royaltyRecipient can claim, if any \\r\\n   * @dev Anyone can call this function such that payout could be distributed \\r\\n   *      regularly instead of being claimed. \\r\\n   * @param _royaltyRecipient Address that is able to claim royalties\\r\\n   */\\r\\n  function sendRoyalties(address _royaltyRecipient) external;\\r\\n\\r\\n  /***********************************|\\r\\n  |        OnReceive Functions        |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Handle which method is being called on Token transfer\\r\\n   * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\\r\\n   *   where bytes4 argument is the MethodObj object signature passed as defined\\r\\n   *   in the `Signatures for onReceive control logic` section above\\r\\n   * @param _operator The address which called the `safeTransferFrom` function\\r\\n   * @param _from     The address which previously owned the token\\r\\n   * @param _id       The id of the token being transferred\\r\\n   * @param _amount   The amount of tokens being transferred\\r\\n   * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\\r\\n   * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n   */\\r\\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\\r\\n\\r\\n  /**\\r\\n   * @notice Handle which method is being called on transfer\\r\\n   * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\\r\\n   *   where bytes4 argument is the MethodObj object signature passed as defined\\r\\n   *   in the `Signatures for onReceive control logic` section above\\r\\n   * @param _from     The address which previously owned the Token\\r\\n   * @param _ids      An array containing ids of each Token being transferred\\r\\n   * @param _amounts  An array containing amounts of each Token being transferred\\r\\n   * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\\r\\n   * @return bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\")\\r\\n   */\\r\\n  function onERC1155BatchReceived(address, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\\r\\n\\r\\n\\r\\n  /***********************************|\\r\\n  |         Getter Functions          |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @dev Pricing function used for converting between currency token to Tokens.\\r\\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\\r\\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\\r\\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\\r\\n   * @return Amount of currency tokens to send to Niftyswap.\\r\\n   */\\r\\n  function getBuyPrice(uint256 _assetBoughtAmount, uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\\r\\n   * @param _tokenId            Id ot token being sold\\r\\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\\r\\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\\r\\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\\r\\n   * @return price Amount of currency tokens to send to Niftyswap.\\r\\n   */\\r\\n  function getBuyPriceWithRoyalty(uint256 _tokenId, uint256 _assetBoughtAmount, uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external view returns (uint256 price);\\r\\n\\r\\n  /**\\r\\n   * @dev Pricing function used for converting Tokens to currency token.\\r\\n   * @param _assetSoldAmount    Amount of Tokens being sold.\\r\\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\\r\\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\\r\\n   * @return Amount of currency tokens to receive from Niftyswap.\\r\\n   */\\r\\n  function getSellPrice(uint256 _assetSoldAmount,uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\\r\\n   * @param _tokenId            Id ot token being sold\\r\\n   * @param _assetSoldAmount    Amount of Tokens being sold.\\r\\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\\r\\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\\r\\n   * @return price Amount of currency tokens to receive from Niftyswap.\\r\\n   */\\r\\n  function getSellPriceWithRoyalty(uint256 _tokenId, uint256 _assetSoldAmount, uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external view returns (uint256 price);\\r\\n\\r\\n  /**\\r\\n   * @notice Get amount of currency in reserve for each Token _id in _ids\\r\\n   * @param _ids Array of ID sto query currency reserve of\\r\\n   * @return amount of currency in reserve for each Token _id\\r\\n   */\\r\\n  function getCurrencyReserves(uint256[] calldata _ids) external view returns (uint256[] memory);\\r\\n\\r\\n  /**\\r\\n   * @notice Return price for `currency => Token _id` trades with an exact token amount.\\r\\n   * @param _ids          Array of ID of tokens bought.\\r\\n   * @param _tokensBought Amount of Tokens bought.\\r\\n   * @return Amount of currency needed to buy Tokens in _ids for amounts in _tokensBought\\r\\n   */\\r\\n  function getPrice_currencyToToken(uint256[] calldata _ids, uint256[] calldata _tokensBought) external view returns (uint256[] memory);\\r\\n\\r\\n  /**\\r\\n   * @notice Return price for `Token _id => currency` trades with an exact token amount.\\r\\n   * @param _ids        Array of IDs  token sold.\\r\\n   * @param _tokensSold Array of amount of each Token sold.\\r\\n   * @return Amount of currency that can be bought for Tokens in _ids for amounts in _tokensSold\\r\\n   */\\r\\n  function getPrice_tokenToCurrency(uint256[] calldata _ids, uint256[] calldata _tokensSold) external view returns (uint256[] memory);\\r\\n\\r\\n  /**\\r\\n   * @notice Get total supply of liquidity tokens\\r\\n   * @param _ids ID of the Tokens\\r\\n   * @return The total supply of each liquidity token id provided in _ids\\r\\n   */\\r\\n  function getTotalSupply(uint256[] calldata _ids) external view returns (uint256[] memory);\\r\\n\\r\\n  /**\\r\\n   * @return Address of Token that is sold on this exchange.\\r\\n   */\\r\\n  function getTokenAddress() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @return LP fee per 1000 units\\r\\n   */\\r\\n  function getLPFee() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @return Address of the currency contract that is used as currency\\r\\n   */\\r\\n  function getCurrencyInfo() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @return Address of factory that created this exchange.\\r\\n   */\\r\\n  function getFactoryAddress() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @return Global royalty fee % if not supporting ERC-2981\\r\\n   */\\r\\n  function getGlobalRoyaltyFee() external view returns (uint256);  \\r\\n\\r\\n  /**\\r\\n   * @return Global royalty recipient if token not supporting ERC-2981\\r\\n   */\\r\\n  function getGlobalRoyaltyRecipient() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @return Get amount of currency in royalty an address can claim\\r\\n   * @param _royaltyRecipient Address to check the claimable royalties\\r\\n   */\\r\\n  function getRoyalties(address _royaltyRecipient) external view returns (uint256);\\r\\n\\r\\n  function getRoyaltiesNumerator(address _royaltyRecipient) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/swap/contracts/utils/DelegatedOwnable.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"../interfaces/IOwnable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract inherits the owner of a parent contract as its owner, \\r\\n * and provides basic authorization control functions, this simplifies the \\r\\n * implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract DelegatedOwnable {\\r\\n  address internal ownableParent;\\r\\n\\r\\n  event ParentOwnerChanged(address indexed previousParent, address indexed newParent);\\r\\n\\r\\n  /**\\r\\n   * @dev The Ownable constructor sets the original `ownableParent` of the contract to the specied address\\r\\n   * @param _firstOwnableParent Address of the first ownable parent contract\\r\\n   */\\r\\n  constructor (address _firstOwnableParent) {\\r\\n    try IOwnable(_firstOwnableParent).getOwner() {\\r\\n      // Do nothing if parent has ownable function\\r\\n    } catch {\\r\\n      revert(\\\"DO#1\\\"); // PARENT IS NOT OWNABLE\\r\\n    }\\r\\n    ownableParent = _firstOwnableParent;\\r\\n    emit ParentOwnerChanged(address(0), _firstOwnableParent);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the master owner.\\r\\n   */\\r\\n  modifier onlyOwner() {\\r\\n    require(msg.sender == getOwner(), \\\"DO#2\\\"); // DelegatedOwnable#onlyOwner: SENDER_IS_NOT_OWNER\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Will use the owner address of another parent contract\\r\\n   * @param _newParent Address of the new owner\\r\\n   */\\r\\n  function changeOwnableParent(address _newParent) public onlyOwner {\\r\\n    require(_newParent != address(0), \\\"D3\\\"); // DelegatedOwnable#changeOwnableParent: INVALID_ADDRESS\\r\\n    ownableParent = _newParent;\\r\\n    emit ParentOwnerChanged(ownableParent, _newParent);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the address of the owner.\\r\\n   */\\r\\n  function getOwner() public view returns (address) {\\r\\n    return IOwnable(ownableParent).getOwner();\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/FnbswapExchange/swap/contracts/interfaces/IERC1155Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\n/**\\r\\n    Note: The ERC-165 identifier for this interface is 0x0e89341c.\\r\\n*/\\r\\ninterface IERC1155Metadata {\\r\\n    /**\\r\\n        @notice A distinct Uniform Resource Identifier (URI) for a given token.\\r\\n        @dev URIs are defined in RFC 3986.\\r\\n        The URI MUST point to a JSON file that conforms to the \\\"ERC-1155 Metadata URI JSON Schema\\\".        \\r\\n        @return URI string\\r\\n    */\\r\\n    function uri(uint256 _id) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/swap/contracts/interfaces/IDelegatedERC1155Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./IERC1155Metadata.sol\\\";\\r\\n\\r\\n\\r\\ninterface IDelegatedERC1155Metadata {\\r\\n  function metadataProvider() external view returns (IERC1155Metadata);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/erc-1155/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC165\\r\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\r\\n */\\r\\ninterface IERC165 {\\r\\n\\r\\n    /**\\r\\n     * @notice Query if a contract implements an interface\\r\\n     * @dev Interface identification is specified in ERC-165. This function\\r\\n     * uses less than 30,000 gas\\r\\n     * @param _interfaceId The interface identifier, as specified in ERC-165\\r\\n     */\\r\\n    function supportsInterface(bytes4 _interfaceId)\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/erc-1155/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\n\\r\\n/**\\r\\n * @title ERC20 interface\\r\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\r\\n */\\r\\ninterface IERC20 {\\r\\n  function transfer(address to, uint256 value) external returns (bool);\\r\\n  function approve(address spender, uint256 value) external returns (bool);\\r\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function balanceOf(address who) external view returns (uint256);\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/erc-1155/contracts/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\n\\r\\n/**\\r\\n * @dev ERC-1155 interface for accepting safe transfers.\\r\\n */\\r\\ninterface IERC1155TokenReceiver {\\r\\n\\r\\n  /**\\r\\n   * @notice Handle the receipt of a single ERC1155 token type\\r\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\r\\n   * This function MAY throw to revert and reject the transfer\\r\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\r\\n   * Note: The token contract address is always the message sender\\r\\n   * @param _operator  The address which called the `safeTransferFrom` function\\r\\n   * @param _from      The address which previously owned the token\\r\\n   * @param _id        The id of the token being transferred\\r\\n   * @param _amount    The amount of tokens being transferred\\r\\n   * @param _data      Additional data with no specified format\\r\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n   */\\r\\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\\r\\n\\r\\n  /**\\r\\n   * @notice Handle the receipt of multiple ERC1155 token types\\r\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\r\\n   * This function MAY throw to revert and reject the transfer\\r\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\r\\n   * Note: The token contract address is always the message sender\\r\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\r\\n   * @param _from      The address which previously owned the token\\r\\n   * @param _ids       An array containing ids of each token being transferred\\r\\n   * @param _amounts   An array containing amounts of each token being transferred\\r\\n   * @param _data      Additional data with no specified format\\r\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n   */\\r\\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/erc-1155/contracts/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\nimport './IERC165.sol';\\r\\n\\r\\n\\r\\ninterface IERC1155 is IERC165 {\\r\\n\\r\\n  /****************************************|\\r\\n  |                 Events                 |\\r\\n  |_______________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\r\\n   *   Operator MUST be msg.sender\\r\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\r\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\r\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\r\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\r\\n   */\\r\\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\r\\n\\r\\n  /**\\r\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\r\\n   *   Operator MUST be msg.sender\\r\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\r\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\r\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\r\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\r\\n   */\\r\\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\r\\n\\r\\n  /**\\r\\n   * @dev MUST emit when an approval is updated\\r\\n   */\\r\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n\\r\\n  /****************************************|\\r\\n  |                Functions               |\\r\\n  |_______________________________________*/\\r\\n\\r\\n  /**\\r\\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\\r\\n    * @dev MUST emit TransferSingle event on success\\r\\n    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\r\\n    * MUST throw if `_to` is the zero address\\r\\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\r\\n    * MUST throw on any other error\\r\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n    * @param _from    Source address\\r\\n    * @param _to      Target address\\r\\n    * @param _id      ID of the token type\\r\\n    * @param _amount  Transfered amount\\r\\n    * @param _data    Additional data with no specified format, sent in call to `_to`\\r\\n    */\\r\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\\r\\n\\r\\n  /**\\r\\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\r\\n    * @dev MUST emit TransferBatch event on success\\r\\n    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\r\\n    * MUST throw if `_to` is the zero address\\r\\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\\r\\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\r\\n    * MUST throw on any other error\\r\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\r\\n    * @param _from     Source addresses\\r\\n    * @param _to       Target addresses\\r\\n    * @param _ids      IDs of each token type\\r\\n    * @param _amounts  Transfer amounts per token type\\r\\n    * @param _data     Additional data with no specified format, sent in call to `_to`\\r\\n  */\\r\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Get the balance of an account's Tokens\\r\\n   * @param _owner  The address of the token holder\\r\\n   * @param _id     ID of the Token\\r\\n   * @return        The _owner's balance of the Token type requested\\r\\n   */\\r\\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @notice Get the balance of multiple account/token pairs\\r\\n   * @param _owners The addresses of the token holders\\r\\n   * @param _ids    ID of the Tokens\\r\\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\r\\n   */\\r\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\\r\\n\\r\\n  /**\\r\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\r\\n   * @dev MUST emit the ApprovalForAll event on success\\r\\n   * @param _operator  Address to add to the set of authorized operators\\r\\n   * @param _approved  True if the operator is approved, false to revoke approval\\r\\n   */\\r\\n  function setApprovalForAll(address _operator, bool _approved) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Queries the approval status of an operator for a given owner\\r\\n   * @param _owner     The owner of the Tokens\\r\\n   * @param _operator  Address of authorized operator\\r\\n   * @return isOperator True if the operator is approved, false if not\\r\\n   */\\r\\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/erc-1155/contracts/tokens/ERC1155/ERC1155MintBurn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\nimport \\\"./ERC1155.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\\r\\n *      a parent contract to be executed as they are `internal` functions\\r\\n */\\r\\ncontract ERC1155MintBurn is ERC1155 {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  /****************************************|\\r\\n  |            Minting Functions           |\\r\\n  |_______________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Mint _amount of tokens of a given id\\r\\n   * @param _to      The address to mint tokens to\\r\\n   * @param _id      Token id to mint\\r\\n   * @param _amount  The amount to be minted\\r\\n   * @param _data    Data to pass if receiver is contract\\r\\n   */\\r\\n  function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\\r\\n    internal\\r\\n  {\\r\\n    // Add _amount\\r\\n    balances[_to][_id] = balances[_to][_id].add(_amount);\\r\\n\\r\\n    // Emit event\\r\\n    emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\\r\\n\\r\\n    // Calling onReceive method if recipient is contract\\r\\n    _callonERC1155Received(address(0x0), _to, _id, _amount, gasleft(), _data);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Mint tokens for each ids in _ids\\r\\n   * @param _to       The address to mint tokens to\\r\\n   * @param _ids      Array of ids to mint\\r\\n   * @param _amounts  Array of amount of tokens to mint per id\\r\\n   * @param _data    Data to pass if receiver is contract\\r\\n   */\\r\\n  function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\\r\\n    internal\\r\\n  {\\r\\n    require(_ids.length == _amounts.length, \\\"ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH\\\");\\r\\n\\r\\n    // Number of mints to execute\\r\\n    uint256 nMint = _ids.length;\\r\\n\\r\\n     // Executing all minting\\r\\n    for (uint256 i = 0; i < nMint; i++) {\\r\\n      // Update storage balance\\r\\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\\r\\n    }\\r\\n\\r\\n    // Emit batch mint event\\r\\n    emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\\r\\n\\r\\n    // Calling onReceive method if recipient is contract\\r\\n    _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, gasleft(), _data);\\r\\n  }\\r\\n\\r\\n\\r\\n  /****************************************|\\r\\n  |            Burning Functions           |\\r\\n  |_______________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Burn _amount of tokens of a given token id\\r\\n   * @param _from    The address to burn tokens from\\r\\n   * @param _id      Token id to burn\\r\\n   * @param _amount  The amount to be burned\\r\\n   */\\r\\n  function _burn(address _from, uint256 _id, uint256 _amount)\\r\\n    internal\\r\\n  {\\r\\n    //Substract _amount\\r\\n    balances[_from][_id] = balances[_from][_id].sub(_amount);\\r\\n\\r\\n    // Emit event\\r\\n    emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\\r\\n   * @param _from     The address to burn tokens from\\r\\n   * @param _ids      Array of token ids to burn\\r\\n   * @param _amounts  Array of the amount to be burned\\r\\n   */\\r\\n  function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\\r\\n    internal\\r\\n  {\\r\\n    // Number of mints to execute\\r\\n    uint256 nBurn = _ids.length;\\r\\n    require(nBurn == _amounts.length, \\\"ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH\\\");\\r\\n\\r\\n    // Executing all minting\\r\\n    for (uint256 i = 0; i < nBurn; i++) {\\r\\n      // Update storage balance\\r\\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\\r\\n    }\\r\\n\\r\\n    // Emit batch mint event\\r\\n    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/swap/contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IOwnable {\\r\\n  /**\\r\\n   * @notice Transfers the ownership of the contract to new address\\r\\n   * @param _newOwner Address of the new owner\\r\\n   */\\r\\n  function transferOwnership(address _newOwner) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the address of the owner.\\r\\n   */\\r\\n  function getOwner() external view returns (address);\\r\\n}\"\r\n    },\r\n    \"contracts/FnbswapExchange/erc-1155/contracts/tokens/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.7.4;\\r\\n\\r\\nimport \\\"../../utils/SafeMath.sol\\\";\\r\\nimport \\\"../../interfaces/IERC1155TokenReceiver.sol\\\";\\r\\nimport \\\"../../interfaces/IERC1155.sol\\\";\\r\\nimport \\\"../../utils/Address.sol\\\";\\r\\nimport \\\"../../utils/ERC165.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Implementation of Multi-Token Standard contract\\r\\n */\\r\\ncontract ERC1155 is IERC1155, ERC165 {\\r\\n  using SafeMath for uint256;\\r\\n  using Address for address;\\r\\n\\r\\n  /***********************************|\\r\\n  |        Variables and Events       |\\r\\n  |__________________________________*/\\r\\n\\r\\n  // onReceive function signatures\\r\\n  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\\r\\n  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\\r\\n\\r\\n  // Objects balances\\r\\n  mapping (address => mapping(uint256 => uint256)) internal balances;\\r\\n\\r\\n  // Operator Functions\\r\\n  mapping (address => mapping(address => bool)) internal operators;\\r\\n\\r\\n\\r\\n  /***********************************|\\r\\n  |     Public Transfer Functions     |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\\r\\n   * @param _from    Source address\\r\\n   * @param _to      Target address\\r\\n   * @param _id      ID of the token type\\r\\n   * @param _amount  Transfered amount\\r\\n   * @param _data    Additional data with no specified format, sent in call to `_to`\\r\\n   */\\r\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\\r\\n    public override\\r\\n  {\\r\\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \\\"ERC1155#safeTransferFrom: INVALID_OPERATOR\\\");\\r\\n    require(_to != address(0),\\\"ERC1155#safeTransferFrom: INVALID_RECIPIENT\\\");\\r\\n    // require(_amount <= balances[_from][_id]) is not necessary since checked with safemath operations\\r\\n\\r\\n    _safeTransferFrom(_from, _to, _id, _amount);\\r\\n    _callonERC1155Received(_from, _to, _id, _amount, gasleft(), _data);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\r\\n   * @param _from     Source addresses\\r\\n   * @param _to       Target addresses\\r\\n   * @param _ids      IDs of each token type\\r\\n   * @param _amounts  Transfer amounts per token type\\r\\n   * @param _data     Additional data with no specified format, sent in call to `_to`\\r\\n   */\\r\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\\r\\n    public override\\r\\n  {\\r\\n    // Requirements\\r\\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \\\"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\\\");\\r\\n    require(_to != address(0), \\\"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\\\");\\r\\n\\r\\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\\r\\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasleft(), _data);\\r\\n  }\\r\\n\\r\\n\\r\\n  /***********************************|\\r\\n  |    Internal Transfer Functions    |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\\r\\n   * @param _from    Source address\\r\\n   * @param _to      Target address\\r\\n   * @param _id      ID of the token type\\r\\n   * @param _amount  Transfered amount\\r\\n   */\\r\\n  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\\r\\n    internal\\r\\n  {\\r\\n    // Update balances\\r\\n    balances[_from][_id] = balances[_from][_id].sub(_amount); // Subtract amount\\r\\n    balances[_to][_id] = balances[_to][_id].add(_amount);     // Add amount\\r\\n\\r\\n    // Emit event\\r\\n    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\\r\\n   */\\r\\n  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, uint256 _gasLimit, bytes memory _data)\\r\\n    internal\\r\\n  {\\r\\n    // Check if recipient is contract\\r\\n    if (_to.isContract()) {\\r\\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received{gas: _gasLimit}(msg.sender, _from, _id, _amount, _data);\\r\\n      require(retval == ERC1155_RECEIVED_VALUE, \\\"ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE\\\");\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\r\\n   * @param _from     Source addresses\\r\\n   * @param _to       Target addresses\\r\\n   * @param _ids      IDs of each token type\\r\\n   * @param _amounts  Transfer amounts per token type\\r\\n   */\\r\\n  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\\r\\n    internal\\r\\n  {\\r\\n    require(_ids.length == _amounts.length, \\\"ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH\\\");\\r\\n\\r\\n    // Number of transfer to execute\\r\\n    uint256 nTransfer = _ids.length;\\r\\n\\r\\n    // Executing all transfers\\r\\n    for (uint256 i = 0; i < nTransfer; i++) {\\r\\n      // Update storage balance of previous bin\\r\\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\\r\\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\\r\\n    }\\r\\n\\r\\n    // Emit event\\r\\n    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\\r\\n   */\\r\\n  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, uint256 _gasLimit, bytes memory _data)\\r\\n    internal\\r\\n  {\\r\\n    // Pass data if recipient is contract\\r\\n    if (_to.isContract()) {\\r\\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived{gas: _gasLimit}(msg.sender, _from, _ids, _amounts, _data);\\r\\n      require(retval == ERC1155_BATCH_RECEIVED_VALUE, \\\"ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE\\\");\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  /***********************************|\\r\\n  |         Operator Functions        |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\r\\n   * @param _operator  Address to add to the set of authorized operators\\r\\n   * @param _approved  True if the operator is approved, false to revoke approval\\r\\n   */\\r\\n  function setApprovalForAll(address _operator, bool _approved)\\r\\n    external override\\r\\n  {\\r\\n    // Update operator status\\r\\n    operators[msg.sender][_operator] = _approved;\\r\\n    emit ApprovalForAll(msg.sender, _operator, _approved);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Queries the approval status of an operator for a given owner\\r\\n   * @param _owner     The owner of the Tokens\\r\\n   * @param _operator  Address of authorized operator\\r\\n   * @return isOperator True if the operator is approved, false if not\\r\\n   */\\r\\n  function isApprovedForAll(address _owner, address _operator)\\r\\n    public override view returns (bool isOperator)\\r\\n  {\\r\\n    return operators[_owner][_operator];\\r\\n  }\\r\\n\\r\\n\\r\\n  /***********************************|\\r\\n  |         Balance Functions         |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Get the balance of an account's Tokens\\r\\n   * @param _owner  The address of the token holder\\r\\n   * @param _id     ID of the Token\\r\\n   * @return The _owner's balance of the Token type requested\\r\\n   */\\r\\n  function balanceOf(address _owner, uint256 _id)\\r\\n    public override view returns (uint256)\\r\\n  {\\r\\n    return balances[_owner][_id];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @notice Get the balance of multiple account/token pairs\\r\\n   * @param _owners The addresses of the token holders\\r\\n   * @param _ids    ID of the Tokens\\r\\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\r\\n   */\\r\\n  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\\r\\n    public override view returns (uint256[] memory)\\r\\n  {\\r\\n    require(_owners.length == _ids.length, \\\"ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH\\\");\\r\\n\\r\\n    // Variables\\r\\n    uint256[] memory batchBalances = new uint256[](_owners.length);\\r\\n\\r\\n    // Iterate over each owner and token ID\\r\\n    for (uint256 i = 0; i < _owners.length; i++) {\\r\\n      batchBalances[i] = balances[_owners[i]][_ids[i]];\\r\\n    }\\r\\n\\r\\n    return batchBalances;\\r\\n  }\\r\\n\\r\\n\\r\\n  /***********************************|\\r\\n  |          ERC165 Functions         |\\r\\n  |__________________________________*/\\r\\n\\r\\n  /**\\r\\n   * @notice Query if a contract implements an interface\\r\\n   * @param _interfaceID  The interface identifier, as specified in ERC-165\\r\\n   * @return `true` if the contract implements `_interfaceID` and\\r\\n   */\\r\\n  function supportsInterface(bytes4 _interfaceID) public override(ERC165, IERC165) virtual pure returns (bool) {\\r\\n    if (_interfaceID == type(IERC1155).interfaceId) {\\r\\n      return true;\\r\\n    }\\r\\n    return super.supportsInterface(_interfaceID);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/FnbswapExchange/erc-1155/contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Unsigned math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n   * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n   */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n    // benefit is lost if 'b' is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, \\\"SafeMath#mul: OVERFLOW\\\");\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n   */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Solidity only automatically asserts when dividing by 0\\r\\n    require(b > 0, \\\"SafeMath#div: DIVISION_BY_ZERO\\\");\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n   */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b <= a, \\\"SafeMath#sub: UNDERFLOW#!\\\");\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Adds two unsigned integers, reverts on overflow.\\r\\n   */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, \\\"SafeMath#add: OVERFLOW\\\");\\r\\n\\r\\n    return c; \\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n   * reverts when dividing by zero.\\r\\n   */\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0, \\\"SafeMath#mod: DIVISION_BY_ZERO\\\");\\r\\n    return a % b;\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/FnbswapExchange/erc-1155/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\r\\n\\r\\n\\r\\n/**\\r\\n * Utility library of inline functions on addresses\\r\\n */\\r\\nlibrary Address {\\r\\n\\r\\n  // Default hash for EOA accounts returned by extcodehash\\r\\n  bytes32 constant internal ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n\\r\\n  /**\\r\\n   * Returns whether the target address is a contract\\r\\n   * @dev This function will return false if invoked during the constructor of a contract.\\r\\n   * @param _address address of the account to check\\r\\n   * @return Whether the target address is a contract\\r\\n   */\\r\\n  function isContract(address _address) internal view returns (bool) {\\r\\n    bytes32 codehash;\\r\\n\\r\\n    // Currently there is no better way to check if there is a contract in an address\\r\\n    // than to check the size of the code at that address or if it has a non-zero code hash or account hash\\r\\n    assembly { codehash := extcodehash(_address) }\\r\\n    return (codehash != 0x0 && codehash != ACCOUNT_HASH);\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/FnbswapExchange/erc-1155/contracts/utils/ERC165.sol\": {\r\n      \"content\": \"pragma solidity 0.7.4;\\r\\nimport \\\"../interfaces/IERC165.sol\\\";\\r\\n\\r\\nabstract contract ERC165 is IERC165 {\\r\\n  /**\\r\\n   * @notice Query if a contract implements an interface\\r\\n   * @param _interfaceID The interface identifier, as specified in ERC-165\\r\\n   * @return `true` if the contract implements `_interfaceID`\\r\\n   */\\r\\n  function supportsInterface(bytes4 _interfaceID) virtual override public pure returns (bool) {\\r\\n    return _interfaceID == this.supportsInterface.selector;\\r\\n  }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"metadataContract\",\"type\":\"address\"}],\"name\":\"MetadataContractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"name\":\"NewExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lpFee\",\"type\":\"uint256\"}],\"name\":\"createExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"name\":\"getPairExchanges\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataProvider\",\"outputs\":[{\"internalType\":\"contract IERC1155Metadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC1155Metadata\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setMetadataContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenTolastIntance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensToExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FnbswapFactory20", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d134a7d9485c1aac0cbf82718cf6d6e3fd130945", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}