{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.9;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        } else if (error == RecoverError.InvalidSignatureV) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n    }\r\n\r\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n            return tryRecover(hash, r, vs);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address, RecoverError) {\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\r\n            v := add(shr(255, vs), 27)\r\n        }\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return (address(0), RecoverError.InvalidSignatureV);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract IERC20Token is IERC20 {\r\n    function upgrade(uint256 value) public virtual;\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender || _owner == address(0x0), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract FundsRecovery is Ownable, ReentrancyGuard {\r\n    address payable internal fundsDestination;\r\n    IERC20Token public token;\r\n\r\n    event DestinationChanged(address indexed previousDestination, address indexed newDestination);\r\n\r\n    /**\r\n     * Setting new destination of funds recovery.\r\n     */\r\n    function setFundsDestination(address payable _newDestination) public virtual onlyOwner {\r\n        require(_newDestination != address(0));\r\n        emit DestinationChanged(fundsDestination, _newDestination);\r\n        fundsDestination = _newDestination;\r\n    }\r\n\r\n    /**\r\n     * Getting funds destination address.\r\n     */\r\n    function getFundsDestination() public view returns (address) {\r\n        return fundsDestination;\r\n    }\r\n\r\n    /**\r\n     * Possibility to recover funds in case they were sent to this address before smart contract deployment\r\n     */\r\n    function claimNativeCoin() public nonReentrant {\r\n        require(fundsDestination != address(0));\r\n        fundsDestination.transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n       Transfers selected tokens into owner address.\r\n    */\r\n    function claimTokens(address _token) public nonReentrant {\r\n        require(fundsDestination != address(0));\r\n        require(_token != address(token), \"native token funds can't be recovered\");\r\n        uint256 _amount = IERC20Token(_token).balanceOf(address(this));\r\n        IERC20Token(_token).transfer(fundsDestination, _amount);\r\n    }\r\n}\r\n\r\ncontract Utils {\r\n    function getChainID() internal view returns (uint256) {\r\n        uint256 chainID;\r\n        assembly {\r\n            chainID := chainid()\r\n        }\r\n        return chainID;\r\n    }\r\n\r\n    function max(uint a, uint b) internal pure returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    function min(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function round(uint a, uint m) internal pure returns (uint ) {\r\n        return ((a + m - 1) / m) * m;\r\n    }\r\n}\r\n\r\ninterface IdentityRegistry {\r\n    function isRegistered(address _identity) external view returns (bool);\r\n    function minimalHermesStake() external view returns (uint256);\r\n    function getChannelAddress(address _identity, address _hermesId) external view returns (address);\r\n    function getBeneficiary(address _identity) external view returns (address);\r\n    function setBeneficiary(address _identity, address _newBeneficiary, bytes memory _signature) external;\r\n}\r\n\r\n// Hermes (channel balance provided by Herms, no staking/loans)\r\ncontract HermesImplementation is FundsRecovery, Utils {\r\n    using ECDSA for bytes32;\r\n\r\n    string constant STAKE_RETURN_PREFIX = \"Stake return request\";\r\n    uint256 constant DELAY_SECONDS = 259200;   // 3 days\r\n    uint256 constant UNIT_SECONDS = 3600;      // 1 unit = 1 hour = 3600 seconds\r\n    uint16 constant PUNISHMENT_PERCENT = 4;    // 0.04%\r\n\r\n    IdentityRegistry internal registry;\r\n    address internal operator;                 // TODO have master operator who could change operator or manage funds\r\n\r\n    uint256 internal totalStake;               // total amount staked by providers\r\n\r\n    uint256 internal minStake;                 // minimal possible provider's stake (channel opening during promise settlement will use it)\r\n    uint256 internal maxStake;                 // maximal allowed provider's stake\r\n    uint256 internal hermesStake;              // hermes stake is used to prove hermes' sustainability\r\n    uint256 internal closingTimelock;          // blocknumber after which getting stake back will become possible\r\n    IUniswapV2Router internal dex;             // any uniswap v2 compatible dex router address\r\n\r\n    enum Status { Active, Paused, Punishment, Closed } // hermes states\r\n    Status internal status;\r\n\r\n    struct HermesFee {\r\n        uint16 value;                      // subprocent amount. e.g. 2.5% = 250\r\n        uint64 validFrom;                  // timestamp from which fee is valid\r\n    }\r\n    HermesFee public lastFee;              // default fee to look for\r\n    HermesFee public previousFee;          // previous fee is used if last fee is still not active\r\n\r\n    // Our channel don't have balance, because we're always rebalancing into stake amount.\r\n    struct Channel {\r\n        uint256 settled;                   // total amount already settled by provider\r\n        uint256 stake;                     // amount staked by identity to guarante channel size, it also serves as channel balance\r\n        uint256 lastUsedNonce;             // last known nonce, is used to protect signature based calls from replay attack\r\n        uint256 timelock;                  // blocknumber after which channel balance can be decreased\r\n    }\r\n    mapping(bytes32 => Channel) public channels;\r\n\r\n    struct Punishment {\r\n        uint256 activationBlockTime;       // block timestamp in which punishment was activated\r\n        uint256 amount;                    // total amount of tokens locked because of punishment\r\n    }\r\n    Punishment public punishment;\r\n\r\n    function getOperator() public view returns (address) {\r\n        return operator;\r\n    }\r\n\r\n    function getChannelId(address _identity) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_identity, address(this)));\r\n    }\r\n\r\n    function getChannelId(address _identity, string memory _type) public view returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_identity, address(this), _type));\r\n    }\r\n\r\n    function getRegistry() public view returns (address) {\r\n        return address(registry);\r\n    }\r\n\r\n    function getActiveFee() public view returns (uint256) {\r\n        HermesFee memory _activeFee = (block.timestamp >= lastFee.validFrom) ? lastFee : previousFee;\r\n        return uint256(_activeFee.value);\r\n    }\r\n\r\n    function getHermesStake() public view returns (uint256) {\r\n        return hermesStake;\r\n    }\r\n\r\n    function getStakeThresholds() public view returns (uint256, uint256) {\r\n        return (minStake, maxStake);\r\n    }\r\n\r\n    // Returns hermes state\r\n    // Active - all operations are allowed.\r\n    // Paused - no new channel openings.\r\n    // Punishment - don't allow to open new channels, rebalance and withdraw funds.\r\n    // Closed - no new channels, no rebalance, no stake increase.\r\n    function getStatus() public view returns (Status) {\r\n        return status;\r\n    }\r\n\r\n    event PromiseSettled(address indexed identity, bytes32 indexed channelId, address indexed beneficiary, uint256 amountSentToBeneficiary, uint256 fees, bytes32 lock);\r\n    event NewStake(bytes32 indexed channelId, uint256 stakeAmount);\r\n    event MinStakeValueUpdated(uint256 newMinStake);\r\n    event MaxStakeValueUpdated(uint256 newMaxStake);\r\n    event HermesFeeUpdated(uint16 newFee, uint64 validFrom);\r\n    event HermesClosed(uint256 blockTimestamp);\r\n    event ChannelOpeningPaused();\r\n    event ChannelOpeningActivated();\r\n    event FundsWithdrawned(uint256 amount, address beneficiary);\r\n    event HermesStakeIncreased(uint256 newStake);\r\n    event HermesPunishmentActivated(uint256 activationBlockTime);\r\n    event HermesPunishmentDeactivated();\r\n    event HermesStakeReturned(address beneficiary);\r\n\r\n    /*\r\n      ------------------------------------------- SETUP -------------------------------------------\r\n    */\r\n\r\n    // Because of proxy pattern this function is used insted of constructor.\r\n    // Have to be called right after proxy deployment.\r\n    function initialize(address _token, address _operator, uint16 _fee, uint256 _minStake, uint256 _maxStake, address payable _dexAddress) public virtual {\r\n        require(!isInitialized(), \"Hermes: have to be not initialized\");\r\n        require(_token != address(0), \"Hermes: token can't be deployd into zero address\");\r\n        require(_operator != address(0), \"Hermes: operator have to be set\");\r\n        require(_fee <= 5000, \"Hermes: fee can't be bigger than 50%\");\r\n        require(_maxStake > _minStake, \"Hermes: maxStake have to be bigger than minStake\");\r\n\r\n        registry = IdentityRegistry(msg.sender);\r\n        token = IERC20Token(_token);\r\n        operator = _operator;\r\n        lastFee = HermesFee(_fee, uint64(block.timestamp));\r\n        minStake = _minStake;\r\n        maxStake = _maxStake;\r\n        hermesStake = token.balanceOf(address(this));\r\n\r\n        // Approving all myst for dex, because MYST token's `transferFrom` is cheaper when there is approval of uint(-1)\r\n        token.approve(_dexAddress, type(uint256).max);\r\n        dex = IUniswapV2Router(_dexAddress);\r\n\r\n        transferOwnership(_operator);\r\n    }\r\n\r\n    function isInitialized() public view returns (bool) {\r\n        return operator != address(0);\r\n    }\r\n\r\n    /*\r\n      -------------------------------------- MAIN FUNCTIONALITY -----------------------------------\r\n    */\r\n\r\n    // Open incoming payments (also known as provider) channel. Can be called only by Registry.\r\n    function openChannel(address _identity, uint256 _amountToStake) public {\r\n        require(msg.sender == address(registry), \"Hermes: only registry can open channels\");\r\n        require(getStatus() == Status.Active, \"Hermes: have to be in active state\");\r\n        require(_amountToStake >= minStake, \"Hermes: min stake amount not reached\");\r\n        _increaseStake(getChannelId(_identity), _amountToStake, false);\r\n    }\r\n\r\n    // Settle promise\r\n    // _preimage is random number generated by receiver used in HTLC\r\n    function _settlePromise(\r\n        bytes32 _channelId,\r\n        uint256 _amount,\r\n        uint256 _transactorFee,\r\n        bytes32 _preimage,\r\n        bytes memory _signature,\r\n        bool _takeFee,\r\n        bool _ignoreStake\r\n    ) private returns (uint256, uint256) {\r\n        require(\r\n            isHermesActive(),\r\n            \"Hermes: hermes have to be in active state\"\r\n        ); // if hermes is not active, then users can only take stake back\r\n        require(\r\n            validatePromise(_channelId, _amount, _transactorFee, _preimage, _signature),\r\n            \"Hermes: have to be properly signed payment promise\"\r\n        );\r\n\r\n        Channel storage _channel = channels[_channelId];\r\n        require(_channel.settled > 0 || _channel.stake >= minStake || _ignoreStake, \"Hermes: not enough stake\");\r\n\r\n        // If there are not enough funds to rebalance we have to enable punishment mode.\r\n        uint256 _availableBalance = availableBalance();\r\n        if (_availableBalance < _channel.stake) {\r\n            status = Status.Punishment;\r\n            punishment.activationBlockTime = block.timestamp;\r\n            emit HermesPunishmentActivated(block.timestamp);\r\n        }\r\n\r\n        // Calculate amount of tokens to be claimed.\r\n        uint256 _unpaidAmount = _amount - _channel.settled;\r\n        require(_unpaidAmount > _transactorFee, \"Hermes: amount to settle should cover transactor fee\");\r\n\r\n        // It is not allowed to settle more than maxStake / _channel.stake and than available balance.\r\n        uint256 _maxSettlementAmount = max(maxStake, _channel.stake);\r\n        if (_unpaidAmount > _availableBalance || _unpaidAmount > _maxSettlementAmount) {\r\n               _unpaidAmount = min(_availableBalance, _maxSettlementAmount);\r\n        }\r\n\r\n        _channel.settled = _channel.settled + _unpaidAmount; // Increase already paid amount.\r\n        uint256 _fees = _transactorFee + (_takeFee ? calculateHermesFee(_unpaidAmount) : 0);\r\n\r\n        // Pay transactor fee\r\n        if (_transactorFee > 0) {\r\n            token.transfer(msg.sender, _transactorFee);\r\n        }\r\n\r\n        uint256 _amountToTransfer = _unpaidAmount -_fees;\r\n\r\n        return (_amountToTransfer, _fees);\r\n    }\r\n\r\n    function settlePromise(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature) public {\r\n        address _beneficiary = registry.getBeneficiary(_identity);\r\n        require(_beneficiary != address(0), \"Hermes: identity have to be registered, beneficiary have to be set\");\r\n\r\n        // Settle promise and transfer calculated amount into beneficiary wallet\r\n        bytes32 _channelId = getChannelId(_identity);\r\n        (uint256 _amountToTransfer, uint256 _fees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _signature, true, false);\r\n        token.transfer(_beneficiary, _amountToTransfer);\r\n\r\n        emit PromiseSettled(_identity, _channelId, _beneficiary, _amountToTransfer, _fees, _preimage);\r\n    }\r\n\r\n    function payAndSettle(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature, address _beneficiary, bytes memory _beneficiarySignature) public {\r\n        bytes32 _channelId = getChannelId(_identity, \"withdrawal\");\r\n\r\n        // Validate beneficiary to be signed by identity and be attached to given promise\r\n        address _signer = keccak256(abi.encodePacked(getChainID(), _channelId, _amount, _preimage, _beneficiary)).recover(_beneficiarySignature);\r\n        require(_signer == _identity, \"Hermes: payAndSettle request should be properly signed\");\r\n\r\n        (uint256 _amountToTransfer, uint256 _fees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _signature, false, true);\r\n        token.transfer(_beneficiary, _amountToTransfer);\r\n\r\n        emit PromiseSettled(_identity, _channelId, _beneficiary, _amountToTransfer, _fees, _preimage);\r\n    }\r\n\r\n    function settleWithBeneficiary(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _promiseSignature, address _newBeneficiary, bytes memory _beneficiarySignature) public {\r\n        // Update beneficiary address\r\n        registry.setBeneficiary(_identity, _newBeneficiary, _beneficiarySignature);\r\n\r\n        // Settle promise and transfer calculated amount into beneficiary wallet\r\n        bytes32 _channelId = getChannelId(_identity);\r\n        (uint256 _amountToTransfer, uint256 _fees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _promiseSignature, true, false);\r\n        token.transfer(_newBeneficiary, _amountToTransfer);\r\n\r\n        emit PromiseSettled(_identity, _channelId, _newBeneficiary, _amountToTransfer, _fees, _preimage);\r\n    }\r\n\r\n    function settleWithDEX(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature) public {\r\n        address _beneficiary = registry.getBeneficiary(_identity);\r\n        require(_beneficiary != address(0), \"Hermes: identity have to be registered, beneficiary have to be set\");\r\n\r\n        // Calculate amount to transfer and settle promise\r\n        bytes32 _channelId = getChannelId(_identity);\r\n        (uint256 _amountToTransfer, uint256 _fees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _signature, true, false);\r\n\r\n        // Transfer funds into beneficiary wallet via DEX\r\n        uint amountOutMin = 0;\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(token);\r\n        path[1] = dex.WETH();\r\n\r\n        dex.swapExactTokensForETH(_amountToTransfer, amountOutMin, path, _beneficiary, block.timestamp);\r\n\r\n        emit PromiseSettled(_identity, _channelId, _beneficiary, _amountToTransfer, _fees, _preimage);\r\n    }\r\n\r\n    /*\r\n      -------------------------------------- STAKE MANAGEMENT --------------------------------------\r\n    */\r\n\r\n    function _increaseStake(bytes32 _channelId, uint256 _amountToAdd, bool _duringSettlement) internal {\r\n        Channel storage _channel = channels[_channelId];\r\n        uint256 _newStakeAmount = _channel.stake +_amountToAdd;\r\n        require(_newStakeAmount <= maxStake, \"Hermes: total amount to stake can't be bigger than maximally allowed\");\r\n        require(_newStakeAmount >= minStake, \"Hermes: stake can't be less than required min stake\");\r\n\r\n        // We don't transfer tokens during settlements, they already locked in hermes contract.\r\n        if (!_duringSettlement) {\r\n            require(token.transferFrom(msg.sender, address(this), _amountToAdd), \"Hermes: token transfer should succeed\");\r\n        }\r\n\r\n        _channel.stake = _newStakeAmount;\r\n        totalStake = totalStake + _amountToAdd;\r\n\r\n        emit NewStake(_channelId, _newStakeAmount);\r\n    }\r\n\r\n    // Anyone can increase channel's capacity by staking more into hermes\r\n    function increaseStake(bytes32 _channelId, uint256 _amount) public {\r\n        require(getStatus() != Status.Closed, \"Hermes: should be not closed\");\r\n        _increaseStake(_channelId, _amount, false);\r\n    }\r\n\r\n    // Settlement which will increase channel stake instead of transfering funds into beneficiary wallet.\r\n    function settleIntoStake(address _identity, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature) public {\r\n        bytes32 _channelId = getChannelId(_identity);\r\n        (uint256 _stakeIncreaseAmount, uint256 _paidFees) = _settlePromise(_channelId, _amount, _transactorFee, _preimage, _signature, true, true);\r\n        emit PromiseSettled(_identity, _channelId, address(this), _stakeIncreaseAmount, _paidFees, _preimage);\r\n        _increaseStake(_channelId, _stakeIncreaseAmount, true);\r\n    }\r\n\r\n    // Withdraw part of stake. This will also decrease channel balance.\r\n    function decreaseStake(address _identity, uint256 _amount, uint256 _transactorFee, bytes memory _signature) public {\r\n        bytes32 _channelId = getChannelId(_identity);\r\n        require(isChannelOpened(_channelId), \"Hermes: channel has to be opened\");\r\n        require(_amount >= _transactorFee, \"Hermes: amount should be bigger than transactor fee\");\r\n\r\n        Channel storage _channel = channels[_channelId];\r\n        require(_amount <= _channel.stake, \"Hermes: can't withdraw more than the current stake\");\r\n\r\n        // Verify signature\r\n        _channel.lastUsedNonce = _channel.lastUsedNonce + 1;\r\n        address _signer = keccak256(abi.encodePacked(STAKE_RETURN_PREFIX, getChainID(), _channelId, _amount, _transactorFee, _channel.lastUsedNonce)).recover(_signature);\r\n        require(getChannelId(_signer) == _channelId, \"Hermes: have to be signed by channel party\");\r\n\r\n        uint256 _newStakeAmount = _channel.stake - _amount;\r\n        require(_newStakeAmount == 0 || _newStakeAmount >= minStake, \"Hermes: stake can't be less than required min stake\");\r\n\r\n        // Update channel state\r\n        _channel.stake = _newStakeAmount;\r\n        totalStake = totalStake - _amount;\r\n\r\n        // Pay transactor fee then withdraw the rest\r\n        if (_transactorFee > 0) {\r\n            token.transfer(msg.sender, _transactorFee);\r\n        }\r\n\r\n        address _beneficiary = registry.getBeneficiary(_identity);\r\n        token.transfer(_beneficiary, _amount - _transactorFee);\r\n\r\n        emit NewStake(_channelId, _newStakeAmount);\r\n    }\r\n\r\n    /*\r\n      ---------------------------------------------------------------------------------------------\r\n    */\r\n\r\n    // Hermes is in Emergency situation when its status is `Punishment`.\r\n    function resolveEmergency() public {\r\n        require(getStatus() == Status.Punishment, \"Hermes: should be in punishment status\");\r\n\r\n        // No punishment during first time unit\r\n        uint256 _unit = getUnitTime();\r\n        uint256 _timePassed = block.timestamp - punishment.activationBlockTime;\r\n        uint256 _punishmentUnits = round(_timePassed, _unit) / _unit - 1;\r\n\r\n        // Using 0.04% of total channels amount per time unit\r\n        uint256 _punishmentAmount = _punishmentUnits * round(totalStake * PUNISHMENT_PERCENT, 100) / 100;\r\n        punishment.amount = punishment.amount + _punishmentAmount;  // XXX alternativelly we could send tokens into BlackHole (0x0000000...)\r\n\r\n        uint256 _shouldHave = minimalExpectedBalance() + maxStake;  // hermes should have funds for at least one maxStake settlement\r\n        uint256 _currentBalance = token.balanceOf(address(this));\r\n\r\n        // If there are not enough available funds, they have to be topupped from msg.sender.\r\n        if (_currentBalance < _shouldHave) {\r\n            token.transferFrom(msg.sender, address(this), _shouldHave - _currentBalance);\r\n        }\r\n\r\n        // Disable punishment mode\r\n        status = Status.Active;\r\n\r\n        emit HermesPunishmentDeactivated();\r\n    }\r\n\r\n    function getUnitTime() internal pure virtual returns (uint256) {\r\n        return UNIT_SECONDS;\r\n    }\r\n\r\n    function setMinStake(uint256 _newMinStake) public onlyOwner {\r\n        require(isHermesActive(), \"Hermes: has to be active\");\r\n        require(_newMinStake < maxStake, \"Hermes: minStake has to be smaller than maxStake\");\r\n        minStake = _newMinStake;\r\n        emit MinStakeValueUpdated(_newMinStake);\r\n    }\r\n\r\n    function setMaxStake(uint256 _newMaxStake) public onlyOwner {\r\n        require(isHermesActive(), \"Hermes: has to be active\");\r\n        require(_newMaxStake > minStake, \"Hermes: maxStake has to be bigger than minStake\");\r\n        maxStake = _newMaxStake;\r\n        emit MaxStakeValueUpdated(_newMaxStake);\r\n    }\r\n\r\n    function setHermesFee(uint16 _newFee) public onlyOwner {\r\n        require(getStatus() != Status.Closed, \"Hermes: should be not closed\");\r\n        require(_newFee <= 5000, \"Hermes: fee can't be bigger than 50%\");\r\n        require(block.timestamp >= lastFee.validFrom, \"Hermes: can't update inactive fee\");\r\n\r\n        // New fee will start be valid after delay time will pass\r\n        uint64 _validFrom = uint64(getTimelock());\r\n\r\n        previousFee = lastFee;\r\n        lastFee = HermesFee(_newFee, _validFrom);\r\n\r\n        emit HermesFeeUpdated(_newFee, _validFrom);\r\n    }\r\n\r\n    function increaseHermesStake(uint256 _additionalStake) public onlyOwner {\r\n        if (availableBalance() < _additionalStake) {\r\n            uint256 _diff = _additionalStake - availableBalance();\r\n            token.transferFrom(msg.sender, address(this), _diff);\r\n        }\r\n\r\n        hermesStake = hermesStake + _additionalStake;\r\n\r\n        emit HermesStakeIncreased(hermesStake);\r\n    }\r\n\r\n    // Hermes's available funds withdrawal. Can be done only if hermes is not closed and not in punishment mode.\r\n    // Hermes can't withdraw stake, locked in channel funds and funds lended to him.\r\n    function withdraw(address _beneficiary, uint256 _amount) public onlyOwner {\r\n        require(isHermesActive(), \"Hermes: have to be active\");\r\n        require(availableBalance() >= _amount, \"Hermes: should be enough funds available to withdraw\");\r\n\r\n        token.transfer(_beneficiary, _amount);\r\n\r\n        emit FundsWithdrawned(_amount, _beneficiary);\r\n    }\r\n\r\n    // Returns funds amount not locked in any channel, not staked and not lended from providers.\r\n    function availableBalance() public view returns (uint256) {\r\n        uint256 _totalLockedAmount = minimalExpectedBalance();\r\n        uint256 _currentBalance = token.balanceOf(address(this));\r\n        if (_totalLockedAmount > _currentBalance) {\r\n            return uint256(0);\r\n        }\r\n        return _currentBalance - _totalLockedAmount;\r\n    }\r\n\r\n    // Returns true if channel is opened.\r\n    function isChannelOpened(bytes32 _channelId) public view returns (bool) {\r\n        return channels[_channelId].settled != 0 || channels[_channelId].stake != 0;\r\n    }\r\n\r\n    // If Hermes is not closed and is not in punishment mode, he is active.\r\n    function isHermesActive() public view returns (bool) {\r\n        Status _status = getStatus();\r\n        return _status != Status.Punishment && _status != Status.Closed;\r\n    }\r\n\r\n    function pauseChannelOpening() public onlyOwner {\r\n        require(getStatus() == Status.Active, \"Hermes: have to be in active state\");\r\n        status = Status.Paused;\r\n        emit ChannelOpeningPaused();\r\n    }\r\n\r\n    function activateChannelOpening() public onlyOwner {\r\n        require(getStatus() == Status.Paused, \"Hermes: have to be in paused state\");\r\n        status = Status.Active;\r\n        emit ChannelOpeningActivated();\r\n    }\r\n\r\n    function closeHermes() public onlyOwner {\r\n        require(isHermesActive(), \"Hermes: should be active\");\r\n        status = Status.Closed;\r\n        closingTimelock = getEmergencyTimelock();\r\n        emit HermesClosed(block.timestamp);\r\n    }\r\n\r\n    function getStakeBack(address _beneficiary) public onlyOwner {\r\n        require(getStatus() == Status.Closed, \"Hermes: have to be closed\");\r\n        require(block.timestamp > closingTimelock, \"Hermes: timelock period should be already passed\");\r\n\r\n        uint256 _amount = token.balanceOf(address(this)) - punishment.amount;\r\n        token.transfer(_beneficiary, _amount);\r\n\r\n        emit HermesStakeReturned(_beneficiary);\r\n    }\r\n\r\n    /*\r\n      ------------------------------------------ HELPERS ------------------------------------------\r\n    */\r\n    // Returns timestamp until which exit request should be locked\r\n    function getTimelock() internal view virtual returns (uint256) {\r\n        return block.timestamp + DELAY_SECONDS;\r\n    }\r\n\r\n    function calculateHermesFee(uint256 _amount) public view returns (uint256) {\r\n        return round((_amount * getActiveFee() / 100), 100) / 100;\r\n    }\r\n\r\n    // Funds which always have to be holded in hermes smart contract.\r\n    function minimalExpectedBalance() public view returns (uint256) {\r\n        return max(hermesStake, punishment.amount) + totalStake;\r\n    }\r\n\r\n    function getEmergencyTimelock() internal view virtual returns (uint256) {\r\n        return block.timestamp + DELAY_SECONDS * 100; // 300 days\r\n    }\r\n\r\n    function validatePromise(bytes32 _channelId, uint256 _amount, uint256 _transactorFee, bytes32 _preimage, bytes memory _signature) public view returns (bool) {\r\n        bytes32 _hashlock = keccak256(abi.encodePacked(_preimage));\r\n        address _signer = keccak256(abi.encodePacked(getChainID(), _channelId, _amount, _transactorFee, _hashlock)).recover(_signature);\r\n        return _signer == operator;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[],\"name\":\"ChannelOpeningActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ChannelOpeningPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousDestination\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDestination\",\"type\":\"address\"}],\"name\":\"DestinationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"FundsWithdrawned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"HermesClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"newFee\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"validFrom\",\"type\":\"uint64\"}],\"name\":\"HermesFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"activationBlockTime\",\"type\":\"uint256\"}],\"name\":\"HermesPunishmentActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HermesPunishmentDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStake\",\"type\":\"uint256\"}],\"name\":\"HermesStakeIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"HermesStakeReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxStake\",\"type\":\"uint256\"}],\"name\":\"MaxStakeValueUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinStake\",\"type\":\"uint256\"}],\"name\":\"MinStakeValueUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"identity\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"channelId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSentToBeneficiary\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"lock\",\"type\":\"bytes32\"}],\"name\":\"PromiseSettled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activateChannelOpening\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateHermesFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"channels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"settled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUsedNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimNativeCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeHermes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transactorFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"decreaseStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"}],\"name\":\"getChannelId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"}],\"name\":\"getChannelId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFundsDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHermesStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getStakeBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"enum HermesImplementation.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_additionalStake\",\"type\":\"uint256\"}],\"name\":\"increaseHermesStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_channelId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"increaseStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_minStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxStake\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_dexAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_channelId\",\"type\":\"bytes32\"}],\"name\":\"isChannelOpened\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isHermesActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastFee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"value\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"validFrom\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimalExpectedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountToStake\",\"type\":\"uint256\"}],\"name\":\"openChannel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseChannelOpening\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transactorFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_preimage\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_beneficiarySignature\",\"type\":\"bytes\"}],\"name\":\"payAndSettle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousFee\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"value\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"validFrom\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"punishment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"activationBlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolveEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newDestination\",\"type\":\"address\"}],\"name\":\"setFundsDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_newFee\",\"type\":\"uint16\"}],\"name\":\"setHermesFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxStake\",\"type\":\"uint256\"}],\"name\":\"setMaxStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMinStake\",\"type\":\"uint256\"}],\"name\":\"setMinStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transactorFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_preimage\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"settleIntoStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transactorFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_preimage\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"settlePromise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transactorFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_preimage\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_promiseSignature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_newBeneficiary\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_beneficiarySignature\",\"type\":\"bytes\"}],\"name\":\"settleWithBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transactorFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_preimage\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"settleWithDEX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_channelId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transactorFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_preimage\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"validatePromise\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HermesImplementation", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ba2df96ddfa2d03e881c02f5854b3537750bc5ac7329d159840a07843612ebcb"}