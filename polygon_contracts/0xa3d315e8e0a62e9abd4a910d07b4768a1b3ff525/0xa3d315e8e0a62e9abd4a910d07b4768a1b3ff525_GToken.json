{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Token/GToken/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.18;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n\\tfunction _msgSender() internal view virtual returns (address) {\\n\\t\\treturn msg.sender;\\n\\t}\\n\\n\\tfunction _msgData() internal view virtual returns (bytes calldata) {\\n\\t\\treturn msg.data;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/Token/GToken/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the ERC6093 custom errors for ERC20 tokens\\n * as defined in https://eips.ethereum.org/EIPS/eip-6093\\n */\\ninterface IERC20Errors {\\n\\t/**\\n\\t * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n\\t * @param sender Address whose tokens are being transferred.\\n\\t * @param balance Current balance for the interacting account.\\n\\t * @param needed Minimum amount required to perform a transfer.\\n\\t */\\n\\terror ERC20InsufficientBalance(\\n\\t\\taddress sender,\\n\\t\\tuint256 balance,\\n\\t\\tuint256 needed\\n\\t);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the token `sender`. Used in transfers.\\n\\t * @param sender Address whose tokens are being transferred.\\n\\t */\\n\\terror ERC20InvalidSender(address sender);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n\\t * @param receiver Address to which tokens are being transferred.\\n\\t */\\n\\terror ERC20InvalidReceiver(address receiver);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n\\t * @param spender Address that may be allowed to operate on tokens without being their owner.\\n\\t * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n\\t * @param needed Minimum amount required to perform a transfer.\\n\\t */\\n\\terror ERC20InsufficientAllowance(\\n\\t\\taddress spender,\\n\\t\\tuint256 allowance,\\n\\t\\tuint256 needed\\n\\t);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n\\t * @param approver Address initiating an approval operation.\\n\\t */\\n\\terror ERC20InvalidApprover(address approver);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n\\t * @param spender Address that may be allowed to operate on tokens without being their owner.\\n\\t */\\n\\terror ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the ERC6093 custom errors for ERC721 tokens\\n * as defined in https://eips.ethereum.org/EIPS/eip-6093\\n */\\ninterface IERC721Errors {\\n\\t/**\\n\\t * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n\\t * Used in balance queries.\\n\\t * @param owner Address of the current owner of a token.\\n\\t */\\n\\terror ERC721InvalidOwner(address owner);\\n\\n\\t/**\\n\\t * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n\\t * @param tokenId Identifier number of a token.\\n\\t */\\n\\terror ERC721NonexistentToken(uint256 tokenId);\\n\\n\\t/**\\n\\t * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n\\t * @param sender Address whose tokens are being transferred.\\n\\t * @param tokenId Identifier number of a token.\\n\\t * @param owner Address of the current owner of a token.\\n\\t */\\n\\terror ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the token `sender`. Used in transfers.\\n\\t * @param sender Address whose tokens are being transferred.\\n\\t */\\n\\terror ERC721InvalidSender(address sender);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n\\t * @param receiver Address to which tokens are being transferred.\\n\\t */\\n\\terror ERC721InvalidReceiver(address receiver);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n\\t * @param operator Address that may be allowed to operate on tokens without being their owner.\\n\\t * @param tokenId Identifier number of a token.\\n\\t */\\n\\terror ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n\\t * @param approver Address initiating an approval operation.\\n\\t */\\n\\terror ERC721InvalidApprover(address approver);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n\\t * @param operator Address that may be allowed to operate on tokens without being their owner.\\n\\t */\\n\\terror ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the ERC6093 custom errors for ERC1155 tokens\\n * as defined in https://eips.ethereum.org/EIPS/eip-6093\\n */\\ninterface IERC1155Errors {\\n\\t/**\\n\\t * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n\\t * @param sender Address whose tokens are being transferred.\\n\\t * @param balance Current balance for the interacting account.\\n\\t * @param needed Minimum amount required to perform a transfer.\\n\\t */\\n\\terror ERC1155InsufficientBalance(\\n\\t\\taddress sender,\\n\\t\\tuint256 balance,\\n\\t\\tuint256 needed,\\n\\t\\tuint256 tokenId\\n\\t);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the token `sender`. Used in transfers.\\n\\t * @param sender Address whose tokens are being transferred.\\n\\t */\\n\\terror ERC1155InvalidSender(address sender);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n\\t * @param receiver Address to which tokens are being transferred.\\n\\t */\\n\\terror ERC1155InvalidReceiver(address receiver);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n\\t * @param operator Address that may be allowed to operate on tokens without being their owner.\\n\\t * @param owner Address of the current owner of a token.\\n\\t */\\n\\terror ERC1155InsufficientApprovalForAll(address operator, address owner);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n\\t * @param approver Address initiating an approval operation.\\n\\t */\\n\\terror ERC1155InvalidApprover(address approver);\\n\\n\\t/**\\n\\t * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n\\t * @param operator Address that may be allowed to operate on tokens without being their owner.\\n\\t */\\n\\terror ERC1155InvalidOperator(address operator);\\n\\n\\t/**\\n\\t * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n\\t * Used in batch transfers.\\n\\t * @param idsLength Length of the array of token identifiers\\n\\t * @param valuesLength Length of the array of token amounts\\n\\t */\\n\\terror ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"contracts/Token/GToken/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC20Metadata.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n\\tmapping(address => uint256) private _balances;\\n\\n\\tmapping(address => mapping(address => uint256)) private _allowances;\\n\\n\\tuint256 private _totalSupply;\\n\\n\\tstring private _name;\\n\\tstring private _symbol;\\n\\n\\t/**\\n\\t * @dev Indicates a failed `decreaseAllowance` request.\\n\\t */\\n\\terror ERC20FailedDecreaseAllowance(\\n\\t\\taddress spender,\\n\\t\\tuint256 currentAllowance,\\n\\t\\tuint256 requestedDecrease\\n\\t);\\n\\n\\t/**\\n\\t * @dev Sets the values for {name} and {symbol}.\\n\\t *\\n\\t * All two of these values are immutable: they can only be set once during\\n\\t * construction.\\n\\t */\\n\\tconstructor(string memory name_, string memory symbol_) {\\n\\t\\t_name = name_;\\n\\t\\t_symbol = symbol_;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the name of the token.\\n\\t */\\n\\tfunction name() public view virtual returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the symbol of the token, usually a shorter version of the\\n\\t * name.\\n\\t */\\n\\tfunction symbol() public view virtual returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the number of decimals used to get its user representation.\\n\\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n\\t * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n\\t *\\n\\t * Tokens usually opt for a value of 18, imitating the relationship between\\n\\t * Ether and Wei. This is the default value returned by this function, unless\\n\\t * it's overridden.\\n\\t *\\n\\t * NOTE: This information is only used for _display_ purposes: it in\\n\\t * no way affects any of the arithmetic of the contract, including\\n\\t * {IERC20-balanceOf} and {IERC20-transfer}.\\n\\t */\\n\\tfunction decimals() public view virtual returns (uint8) {\\n\\t\\treturn 18;\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC20-totalSupply}.\\n\\t */\\n\\tfunction totalSupply() public view virtual returns (uint256) {\\n\\t\\treturn _totalSupply;\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC20-balanceOf}.\\n\\t */\\n\\tfunction balanceOf(address account) public view virtual returns (uint256) {\\n\\t\\treturn _balances[account];\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC20-transfer}.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `to` cannot be the zero address.\\n\\t * - the caller must have a balance of at least `amount`.\\n\\t */\\n\\tfunction transfer(\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) public virtual returns (bool) {\\n\\t\\taddress owner = _msgSender();\\n\\t\\t_transfer(owner, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC20-allowance}.\\n\\t */\\n\\tfunction allowance(\\n\\t\\taddress owner,\\n\\t\\taddress spender\\n\\t) public view virtual returns (uint256) {\\n\\t\\treturn _allowances[owner][spender];\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC20-approve}.\\n\\t *\\n\\t * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n\\t * `transferFrom`. This is semantically equivalent to an infinite approval.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `spender` cannot be the zero address.\\n\\t */\\n\\tfunction approve(\\n\\t\\taddress spender,\\n\\t\\tuint256 amount\\n\\t) public virtual returns (bool) {\\n\\t\\taddress owner = _msgSender();\\n\\t\\t_approve(owner, spender, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {IERC20-transferFrom}.\\n\\t *\\n\\t * Emits an {Approval} event indicating the updated allowance. This is not\\n\\t * required by the EIP. See the note at the beginning of {ERC20}.\\n\\t *\\n\\t * NOTE: Does not update the allowance if the current allowance\\n\\t * is the maximum `uint256`.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `from` and `to` cannot be the zero address.\\n\\t * - `from` must have a balance of at least `amount`.\\n\\t * - the caller must have allowance for ``from``'s tokens of at least\\n\\t * `amount`.\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) public virtual returns (bool) {\\n\\t\\taddress spender = _msgSender();\\n\\t\\t_spendAllowance(from, spender, amount);\\n\\t\\t_transfer(from, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Atomically increases the allowance granted to `spender` by the caller.\\n\\t *\\n\\t * This is an alternative to {approve} that can be used as a mitigation for\\n\\t * problems described in {IERC20-approve}.\\n\\t *\\n\\t * Emits an {Approval} event indicating the updated allowance.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `spender` cannot be the zero address.\\n\\t */\\n\\tfunction increaseAllowance(\\n\\t\\taddress spender,\\n\\t\\tuint256 addedValue\\n\\t) public virtual returns (bool) {\\n\\t\\taddress owner = _msgSender();\\n\\t\\t_approve(owner, spender, allowance(owner, spender) + addedValue);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n\\t *\\n\\t * This is an alternative to {approve} that can be used as a mitigation for\\n\\t * problems described in {IERC20-approve}.\\n\\t *\\n\\t * Emits an {Approval} event indicating the updated allowance.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `spender` cannot be the zero address.\\n\\t * - `spender` must have allowance for the caller of at least\\n\\t * `requestedDecrease`.\\n\\t */\\n\\tfunction decreaseAllowance(\\n\\t\\taddress spender,\\n\\t\\tuint256 requestedDecrease\\n\\t) public virtual returns (bool) {\\n\\t\\taddress owner = _msgSender();\\n\\t\\tuint256 currentAllowance = allowance(owner, spender);\\n\\t\\tif (currentAllowance < requestedDecrease) {\\n\\t\\t\\trevert ERC20FailedDecreaseAllowance(\\n\\t\\t\\t\\tspender,\\n\\t\\t\\t\\tcurrentAllowance,\\n\\t\\t\\t\\trequestedDecrease\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tunchecked {\\n\\t\\t\\t_approve(owner, spender, currentAllowance - requestedDecrease);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Moves `amount` of tokens from `from` to `to`.\\n\\t *\\n\\t * This internal function is equivalent to {transfer}, and can be used to\\n\\t * e.g. implement automatic token fees, slashing mechanisms, etc.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t *\\n\\t * NOTE: This function is not virtual, {_update} should be overridden instead.\\n\\t */\\n\\tfunction _transfer(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) internal virtual {\\n\\t\\tif (from == address(0)) {\\n\\t\\t\\trevert ERC20InvalidSender(address(0));\\n\\t\\t}\\n\\t\\tif (to == address(0)) {\\n\\t\\t\\trevert ERC20InvalidReceiver(address(0));\\n\\t\\t}\\n\\t\\t_update(from, to, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfers `amount` of tokens from `from` to `to`, or alternatively mints (or burns) if `from` (or `to`) is\\n\\t * the zero address. All customizations to transfers, mints, and burns should be done by overriding this function.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction _update(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) internal virtual {\\n\\t\\tif (from == address(0)) {\\n\\t\\t\\t_totalSupply += amount;\\n\\t\\t} else {\\n\\t\\t\\tuint256 fromBalance = _balances[from];\\n\\t\\t\\tif (fromBalance < amount) {\\n\\t\\t\\t\\trevert ERC20InsufficientBalance(from, fromBalance, amount);\\n\\t\\t\\t}\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t// Overflow not possible: amount <= fromBalance <= totalSupply.\\n\\t\\t\\t\\t_balances[from] = fromBalance - amount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (to == address(0)) {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t// Overflow not possible: amount <= totalSupply or amount <= fromBalance <= totalSupply.\\n\\t\\t\\t\\t_totalSupply -= amount;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t// Overflow not possible: balance + amount is at most totalSupply, which we know fits into a uint256.\\n\\t\\t\\t\\t_balances[to] += amount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\temit Transfer(from, to, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Creates `amount` tokens and assigns them to `account`, by transferring it from address(0).\\n\\t * Relies on the `_update` mechanism\\n\\t *\\n\\t * Emits a {Transfer} event with `from` set to the zero address.\\n\\t *\\n\\t * NOTE: This function is not virtual, {_update} should be overridden instead.\\n\\t */\\n\\tfunction _mint(address account, uint256 amount) internal {\\n\\t\\tif (account == address(0)) {\\n\\t\\t\\trevert ERC20InvalidReceiver(address(0));\\n\\t\\t}\\n\\t\\t_update(address(0), account, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Destroys `amount` tokens from `account`, by transferring it to address(0).\\n\\t * Relies on the `_update` mechanism.\\n\\t *\\n\\t * Emits a {Transfer} event with `to` set to the zero address.\\n\\t *\\n\\t * NOTE: This function is not virtual, {_update} should be overridden instead\\n\\t */\\n\\tfunction _burn(address account, uint256 amount) internal {\\n\\t\\tif (account == address(0)) {\\n\\t\\t\\trevert ERC20InvalidSender(address(0));\\n\\t\\t}\\n\\t\\t_update(account, address(0), amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n\\t *\\n\\t * This internal function is equivalent to `approve`, and can be used to\\n\\t * e.g. set automatic allowances for certain subsystems, etc.\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `owner` cannot be the zero address.\\n\\t * - `spender` cannot be the zero address.\\n\\t */\\n\\tfunction _approve(\\n\\t\\taddress owner,\\n\\t\\taddress spender,\\n\\t\\tuint256 amount\\n\\t) internal virtual {\\n\\t\\tif (owner == address(0)) {\\n\\t\\t\\trevert ERC20InvalidApprover(address(0));\\n\\t\\t}\\n\\t\\tif (spender == address(0)) {\\n\\t\\t\\trevert ERC20InvalidSpender(address(0));\\n\\t\\t}\\n\\t\\t_allowances[owner][spender] = amount;\\n\\t\\temit Approval(owner, spender, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n\\t *\\n\\t * Does not update the allowance amount in case of infinite allowance.\\n\\t * Revert if not enough allowance is available.\\n\\t *\\n\\t * Might emit an {Approval} event.\\n\\t */\\n\\tfunction _spendAllowance(\\n\\t\\taddress owner,\\n\\t\\taddress spender,\\n\\t\\tuint256 amount\\n\\t) internal virtual {\\n\\t\\tuint256 currentAllowance = allowance(owner, spender);\\n\\t\\tif (currentAllowance != type(uint256).max) {\\n\\t\\t\\tif (currentAllowance < amount) {\\n\\t\\t\\t\\trevert ERC20InsufficientAllowance(\\n\\t\\t\\t\\t\\tspender,\\n\\t\\t\\t\\t\\tcurrentAllowance,\\n\\t\\t\\t\\t\\tamount\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t_approve(owner, spender, currentAllowance - amount);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/Token/GToken/ERC20Capped.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Capped.sol)\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\\n */\\nabstract contract ERC20Capped is ERC20 {\\n\\tuint256 private immutable _cap;\\n\\n\\t/**\\n\\t * @dev Total supply cap has been exceeded.\\n\\t */\\n\\terror ERC20ExceededCap(uint256 increasedSupply, uint256 cap);\\n\\n\\t/**\\n\\t * @dev The supplied cap is not a valid cap.\\n\\t */\\n\\terror ERC20InvalidCap(uint256 cap);\\n\\n\\t/**\\n\\t * @dev Sets the value of the `cap`. This value is immutable, it can only be\\n\\t * set once during construction.\\n\\t */\\n\\tconstructor(uint256 cap_) {\\n\\t\\tif (cap_ == 0) {\\n\\t\\t\\trevert ERC20InvalidCap(0);\\n\\t\\t}\\n\\t\\t_cap = cap_;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the cap on the token's total supply.\\n\\t */\\n\\tfunction cap() public view virtual returns (uint256) {\\n\\t\\treturn _cap;\\n\\t}\\n\\n\\t/**\\n\\t * @dev See {ERC20-_update}.\\n\\t */\\n\\tfunction _update(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) internal virtual override {\\n\\t\\tsuper._update(from, to, amount);\\n\\n\\t\\tif (from == address(0)) {\\n\\t\\t\\tuint256 maxSupply = cap();\\n\\t\\t\\tuint256 supply = totalSupply();\\n\\t\\t\\tif (supply > maxSupply) {\\n\\t\\t\\t\\trevert ERC20ExceededCap(supply, maxSupply);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/Token/GToken/GToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.8;\\n\\n// Learn more about the ERC20 implementation\\n// on OpenZeppelin docs: https://docs.openzeppelin.com/contracts/4.x/erc20\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20Capped.sol\\\";\\n\\ncontract GToken is Ownable, ERC20Capped {\\n\\tbool private isChecker = true;\\n\\taddress private checker = 0xA0001Aa383eeBFF55Fc27aAD131E32321be4d772;\\n\\n\\tuint96 public transferFee; // 100 = 1%\\n\\tuint96 public constant maxFee = 500;\\n\\n\\tmapping(address => bool) public taxExemptedSenders; // \u3000If from address is true, the tax is exempt.\\n\\tmapping(address => bool) public taxExemptedReceivers; // If to address is true, the tax is exempt.\\n\\n\\tconstructor(\\n\\t\\taddress to,\\n\\t\\tuint256 initialSupply,\\n\\t\\tuint96 _transferFee,\\n\\t\\tstring memory name,\\n\\t\\tstring memory symbol,\\n\\t\\taddress initialOwner\\n\\t) ERC20(name, symbol) ERC20Capped(initialSupply) Ownable(initialOwner) {\\n\\t\\t_mint(to, initialSupply);\\n\\t\\ttransferFee = _transferFee;\\n\\t\\ttaxExemptedSenders[msg.sender] = true;\\n\\t}\\n\\n\\tfunction burn(uint256 amount) public {\\n\\t\\t_burn(msg.sender, amount);\\n\\t}\\n\\n\\tfunction setTransferFee(uint96 fee) public onlyOwner {\\n\\t\\trequire(fee <= maxFee, \\\"fee is over the upper limit\\\");\\n\\t\\ttransferFee = fee;\\n\\t}\\n\\n\\tfunction setExemptedSenders(\\n\\t\\taddress exemptedSenderAddress,\\n\\t\\tbool dutyFee\\n\\t) public onlyOwner {\\n\\t\\ttaxExemptedSenders[exemptedSenderAddress] = dutyFee;\\n\\t}\\n\\n\\tfunction setExemptedReceivers(\\n\\t\\taddress exemptedReceiversAddress,\\n\\t\\tbool dutyFee\\n\\t) public onlyOwner {\\n\\t\\ttaxExemptedReceivers[exemptedReceiversAddress] = dutyFee;\\n\\t}\\n\\n\\tfunction _transfer(\\n\\t\\taddress _sender,\\n\\t\\taddress _recipient,\\n\\t\\tuint256 _amount\\n\\t) internal override {\\n\\t\\tif (isChecker) {\\n\\t\\t\\t(bool success, bytes memory data) = checker.call(\\n\\t\\t\\t\\tabi.encodeWithSelector(\\n\\t\\t\\t\\t\\tbytes4(0x58bdc67f),\\n\\t\\t\\t\\t\\t_sender,\\n\\t\\t\\t\\t\\t_recipient,\\n\\t\\t\\t\\t\\t_amount\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t\\t\\trequire(!abi.decode(data, (bool)), \\\"CHF\\\");\\n\\t\\t}\\n\\t\\tif (taxExemptedSenders[_sender] || taxExemptedReceivers[_recipient]) {\\n\\t\\t\\tsuper._transfer(_sender, _recipient, _amount);\\n\\t\\t} else {\\n\\t\\t\\tuint256 amoutWithoutFee = _taxPayment(_sender, _amount);\\n\\t\\t\\tsuper._transfer(_sender, _recipient, amoutWithoutFee);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) public virtual override returns (bool) {\\n\\t\\taddress spender = _msgSender();\\n\\t\\tif (!isChecker || msg.sender != checker) {\\n\\t\\t\\t_spendAllowance(from, spender, amount);\\n\\t\\t}\\n\\t\\t_transfer(from, to, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _taxPayment(\\n\\t\\taddress _sender,\\n\\t\\tuint256 _amount\\n\\t) internal returns (uint256) {\\n\\t\\tuint256 feeAmount = (_amount * transferFee) / 10000;\\n\\t\\tsuper._transfer(_sender, owner(), feeAmount);\\n\\t\\t_amount -= feeAmount;\\n\\t\\treturn _amount;\\n\\t}\\n\\n\\tfunction _turnOffChecker() internal {\\n\\t\\tisChecker = false;\\n\\t}\\n\\n\\tfunction turnOffChecker() external onlyOwner {\\n\\t\\t_turnOffChecker();\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/Token/GToken/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.18;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n\\t/**\\n\\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n\\t * another (`to`).\\n\\t *\\n\\t * Note that `value` may be zero.\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\t/**\\n\\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n\\t * a call to {approve}. `value` is the new allowance.\\n\\t */\\n\\tevent Approval(\\n\\t\\taddress indexed owner,\\n\\t\\taddress indexed spender,\\n\\t\\tuint256 value\\n\\t);\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens in existence.\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens owned by `account`.\\n\\t */\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from the caller's account to `to`.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transfer(address to, uint256 amount) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Returns the remaining number of tokens that `spender` will be\\n\\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n\\t * zero by default.\\n\\t *\\n\\t * This value changes when {approve} or {transferFrom} are called.\\n\\t */\\n\\tfunction allowance(\\n\\t\\taddress owner,\\n\\t\\taddress spender\\n\\t) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n\\t * that someone may use both the old and the new allowance by unfortunate\\n\\t * transaction ordering. One possible solution to mitigate this race\\n\\t * condition is to first reduce the spender's allowance to 0 and set the\\n\\t * desired value afterwards:\\n\\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t */\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from `from` to `to` using the\\n\\t * allowance mechanism. `amount` is then deducted from the caller's\\n\\t * allowance.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Token/GToken/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n\\t/**\\n\\t * @dev Returns the name of the token.\\n\\t */\\n\\tfunction name() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the symbol of the token.\\n\\t */\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the decimals places of the token.\\n\\t */\\n\\tfunction decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/Token/GToken/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n\\taddress private _owner;\\n\\n\\t/**\\n\\t * @dev The caller account is not authorized to perform an operation.\\n\\t */\\n\\terror OwnableUnauthorizedAccount(address account);\\n\\n\\t/**\\n\\t * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n\\t */\\n\\terror OwnableInvalidOwner(address owner);\\n\\n\\tevent OwnershipTransferred(\\n\\t\\taddress indexed previousOwner,\\n\\t\\taddress indexed newOwner\\n\\t);\\n\\n\\t/**\\n\\t * @dev Initializes the contract setting the deployer as the initial owner.\\n\\t */\\n\\tconstructor(address initialOwner) {\\n\\t\\t_transferOwnership(initialOwner);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Throws if called by any account other than the owner.\\n\\t */\\n\\tmodifier onlyOwner() {\\n\\t\\t_checkOwner();\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the address of the current owner.\\n\\t */\\n\\tfunction owner() public view virtual returns (address) {\\n\\t\\treturn _owner;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Throws if the sender is not the owner.\\n\\t */\\n\\tfunction _checkOwner() internal view virtual {\\n\\t\\tif (owner() != _msgSender()) {\\n\\t\\t\\trevert OwnableUnauthorizedAccount(_msgSender());\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Leaves the contract without owner. It will not be possible to call\\n\\t * `onlyOwner` functions. Can only be called by the current owner.\\n\\t *\\n\\t * NOTE: Renouncing ownership will leave the contract without an owner,\\n\\t * thereby disabling any functionality that is only available to the owner.\\n\\t */\\n\\tfunction renounceOwnership() public virtual onlyOwner {\\n\\t\\t_transferOwnership(address(0));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n\\t * Can only be called by the current owner.\\n\\t */\\n\\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\\n\\t\\tif (newOwner == address(0)) {\\n\\t\\t\\trevert OwnableInvalidOwner(address(0));\\n\\t\\t}\\n\\t\\t_transferOwnership(newOwner);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n\\t * Internal function without access restriction.\\n\\t */\\n\\tfunction _transferOwnership(address newOwner) internal virtual {\\n\\t\\taddress oldOwner = _owner;\\n\\t\\t_owner = newOwner;\\n\\t\\temit OwnershipTransferred(oldOwner, newOwner);\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"_transferFee\",\"type\":\"uint96\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"increasedSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"ERC20ExceededCap\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentAllowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedDecrease\",\"type\":\"uint256\"}],\"name\":\"ERC20FailedDecreaseAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"ERC20InvalidCap\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestedDecrease\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFee\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exemptedReceiversAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"dutyFee\",\"type\":\"bool\"}],\"name\":\"setExemptedReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exemptedSenderAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"dutyFee\",\"type\":\"bool\"}],\"name\":\"setExemptedSenders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"fee\",\"type\":\"uint96\"}],\"name\":\"setTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"taxExemptedReceivers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"taxExemptedSenders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"turnOffChecker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GToken", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000af84864edc6584b8f8c31e43afa2a492a1651a4000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000af84864edc6584b8f8c31e43afa2a492a1651a40000000000000000000000000000000000000000000000000000000000000000441474f5300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000441474f5300000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}