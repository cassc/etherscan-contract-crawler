{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"draft-EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS \\u0026\\u0026 block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"},\"ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature \\u0027s\\u0027 value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature \\u0027v\\u0027 value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs \\u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) \\u003e\\u003e 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 \\u003c s \\u003c secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) \\u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 \\u0026\\u0026 v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"},\"ICurrencyManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface ICurrencyManager {\\r\\n  function addCurrency(address collection, address currency) external;\\r\\n\\r\\n  function removeCurrency(address collection, address currency) external;\\r\\n\\r\\n  function isCurrencyWhitelisted(address collection, address currency)\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n\\r\\n  function viewWhitelistedCurrencies(address collection)\\r\\n    external\\r\\n    view\\r\\n    returns (address[] memory);\\r\\n}\\r\\n\"},\"IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"},\"IExecutionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IExecutionManager {\\r\\n  function addStrategy(address collection, address strategy) external;\\r\\n\\r\\n  function removeStrategy(address collection, address strategy) external;\\r\\n\\r\\n  function isStrategyWhitelisted(address collection, address strategy)\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n\\r\\n  function viewWhitelistedStrategies(address collection)\\r\\n    external\\r\\n    view\\r\\n    returns (address[] memory);\\r\\n}\\r\\n\"},\"IExecutionStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./LibOrder.sol\\\";\\r\\n\\r\\ninterface IExecutionStrategy {\\r\\n  function canExecute(\\r\\n    LibOrder.Order calldata left,\\r\\n    LibOrder.Order calldata right\\r\\n  ) external view returns (bool);\\r\\n}\\r\\n\"},\"IFeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IFeeManager {\\r\\n  function calculateFee(\\r\\n    address collection,\\r\\n    uint256 tokenId,\\r\\n    uint256 amount\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256,\\r\\n      address,\\r\\n      uint256\\r\\n    );\\r\\n}\\r\\n\"},\"IMarketplace.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./LibOrder.sol\\\";\\r\\n\\r\\ninterface IMarketplace {\\r\\n  function cancel(LibOrder.Order calldata order) external;\\r\\n\\r\\n  function cancelMultipleOrders(LibOrder.Order[] calldata orders) external;\\r\\n\\r\\n  function matchOrders(\\r\\n    LibOrder.Order calldata orderLeft,\\r\\n    LibOrder.Order calldata orderRight\\r\\n  ) external payable;\\r\\n\\r\\n  function isOrderCancelledOrFinalized(LibOrder.Order calldata order)\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n}\\r\\n\"},\"ITransferProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface ITransferProxy {\\r\\n  function erc20safeTransferFrom(\\r\\n    address token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) external;\\r\\n\\r\\n  function erc721safeTransferFrom(\\r\\n    address collection,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    bytes calldata data\\r\\n  ) external;\\r\\n\\r\\n  function erc1155safeTransferFrom(\\r\\n    address collection,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    uint256 amount,\\r\\n    bytes calldata data\\r\\n  ) external;\\r\\n}\\r\\n\"},\"ITransferSelectorNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface ITransferSelectorNFT {\\r\\n  function checkTransferManagerForToken(address collection)\\r\\n    external\\r\\n    view\\r\\n    returns (address);\\r\\n}\\r\\n\"},\"LibOrder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary LibOrder {\\r\\n  bytes32 internal constant ASSET_HASH =\\r\\n    keccak256(\\\"Asset(address collection,uint256 tokenId,uint256 amount)\\\");\\r\\n  bytes32 internal constant ORDER_HASH =\\r\\n    keccak256(\\r\\n      \\\"Order(bool isMaker,address account,Asset[] assets,uint256 price,address currency,address strategy,uint32 salt,uint256 start,uint256 end,bytes params)Asset(address collection,uint256 tokenId,uint256 amount)\\\"\\r\\n    );\\r\\n\\r\\n  struct Asset {\\r\\n    address collection;\\r\\n    uint256 tokenId;\\r\\n    uint256 amount;\\r\\n  }\\r\\n\\r\\n  struct Order {\\r\\n    bool isMaker;\\r\\n    address account;\\r\\n    Asset[] assets;\\r\\n    uint256 price;\\r\\n    address currency;\\r\\n    address strategy;\\r\\n    uint32 salt;\\r\\n    uint256 start;\\r\\n    uint256 end;\\r\\n    bytes params;\\r\\n    bytes signature;\\r\\n    bytes marketplaceSignature;\\r\\n  }\\r\\n\\r\\n  function hash(Asset[] memory assets) internal pure returns (bytes32) {\\r\\n    bytes32[] memory assetBytes = new bytes32[](assets.length);\\r\\n    for (uint256 i = 0; i \\u003c assets.length; i++) {\\r\\n      assetBytes[i] = keccak256(\\r\\n        abi.encode(\\r\\n          ASSET_HASH,\\r\\n          assets[i].collection,\\r\\n          assets[i].tokenId,\\r\\n          assets[i].amount\\r\\n        )\\r\\n      );\\r\\n    }\\r\\n    return keccak256(abi.encodePacked(assetBytes));\\r\\n  }\\r\\n\\r\\n  function hash(Order memory order) internal pure returns (bytes32) {\\r\\n    return\\r\\n      keccak256(\\r\\n        abi.encode(\\r\\n          ORDER_HASH,\\r\\n          order.isMaker,\\r\\n          order.account,\\r\\n          hash(order.assets),\\r\\n          order.price,\\r\\n          order.currency,\\r\\n          order.strategy,\\r\\n          order.salt,\\r\\n          order.start,\\r\\n          order.end,\\r\\n          keccak256(order.params)\\r\\n        )\\r\\n      );\\r\\n  }\\r\\n}\\r\\n\"},\"Marketplace.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./ReentrancyGuard.sol\\\";\\r\\nimport \\\"./IERC165.sol\\\";\\r\\nimport \\\"./IERC20Metadata.sol\\\";\\r\\nimport \\\"./ICurrencyManager.sol\\\";\\r\\nimport \\\"./IExecutionManager.sol\\\";\\r\\nimport \\\"./IExecutionStrategy.sol\\\";\\r\\nimport \\\"./IFeeManager.sol\\\";\\r\\nimport \\\"./IMarketplace.sol\\\";\\r\\nimport \\\"./ITransferProxy.sol\\\";\\r\\nimport \\\"./ITransferSelectorNFT.sol\\\";\\r\\nimport \\\"./LibOrder.sol\\\";\\r\\nimport \\\"./SignatureChecker.sol\\\";\\r\\n\\r\\nerror NotMaker();\\r\\nerror SaltZero();\\r\\nerror OrderCancelledOrFinalized(bytes32);\\r\\nerror InvalidCancelOrder();\\r\\nerror LeftRightSameMaker(address);\\r\\nerror LeftMustBeSender();\\r\\nerror MakerAddressZero();\\r\\nerror EmptyAssetsOrder(uint256);\\r\\nerror InvalidSignature(bytes32);\\r\\nerror InvalidMarketplaceSignature(bytes32);\\r\\nerror StrategyExecuteFailed(address);\\r\\nerror InvalidCurrency(address);\\r\\nerror ReturnEthChangesFailed(uint256);\\r\\nerror TransferProtocolEthFailed(uint256);\\r\\nerror TransferFeeEthFailed(uint256);\\r\\nerror TransferEthFailed(uint256);\\r\\nerror InvalidToken(address);\\r\\nerror NullAddress();\\r\\nerror CurrencyNotWhitelisted(address);\\r\\nerror StrategyNotWhitelisted(address);\\r\\n\\r\\ncontract MarketplaceV3 is\\r\\n  SignatureChecker,\\r\\n  IMarketplace,\\r\\n  ReentrancyGuard,\\r\\n  Ownable\\r\\n{\\r\\n  using LibOrder for LibOrder.Order;\\r\\n\\r\\n  bytes4 public constant INTERFACE_ID_ERC721 = 0x80ac58cd;\\r\\n  bytes4 public constant INTERFACE_ID_ERC1155 = 0xd9b67a26;\\r\\n\\r\\n  address public protocolFeeRecipient;\\r\\n  address public marketplaceSigner;\\r\\n\\r\\n  ICurrencyManager public currencyManager;\\r\\n  IExecutionManager public executionManager;\\r\\n  IFeeManager public feeManager;\\r\\n  ITransferProxy public transferProxy;\\r\\n\\r\\n  mapping(bytes32 =\\u003e bool) private cancelledOrFinalized;\\r\\n\\r\\n  event NewSigner(address indexed marketplaceSigner);\\r\\n  event NewCurrencyManager(address indexed currencyManager);\\r\\n  event NewExecutionManager(address indexed executionManager);\\r\\n  event NewProtocolFeeRecipient(address indexed protocolFeeRecipient);\\r\\n  event NewFeeManager(address indexed feeManager);\\r\\n  event NewTransferProxy(address indexed transferProxy);\\r\\n  event RoyaltyPayment(\\r\\n    address indexed collection,\\r\\n    uint256 indexed tokenId,\\r\\n    address indexed royaltyRecipient,\\r\\n    address currency,\\r\\n    uint256 amount\\r\\n  );\\r\\n  event Cancel(bytes32 indexed orderHash, address account);\\r\\n  event Match(\\r\\n    bytes32 indexed orderHash,\\r\\n    address bidder,\\r\\n    address asker,\\r\\n    bool makerAsk\\r\\n  );\\r\\n  event MarketplaceTransfer(\\r\\n    address indexed collection,\\r\\n    address strategy,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    uint256 amount,\\r\\n    bool makerAsk\\r\\n  );\\r\\n\\r\\n  constructor(\\r\\n    address _currencyManager,\\r\\n    address _executionManager,\\r\\n    address _feeManager,\\r\\n    address _protocolFeeRecipient,\\r\\n    address _marketplaceSigner\\r\\n  ) EIP712(\\\"Alchemist\\\", \\\"1.0.0\\\") {\\r\\n    currencyManager = ICurrencyManager(_currencyManager);\\r\\n    executionManager = IExecutionManager(_executionManager);\\r\\n    feeManager = IFeeManager(_feeManager);\\r\\n    protocolFeeRecipient = _protocolFeeRecipient;\\r\\n    marketplaceSigner = _marketplaceSigner;\\r\\n  }\\r\\n\\r\\n  function cancel(LibOrder.Order calldata order) external {\\r\\n    if (msg.sender != order.account) revert NotMaker();\\r\\n    if (order.salt == 0) revert SaltZero();\\r\\n    bytes32 orderHash = order.hash();\\r\\n    if (cancelledOrFinalized[orderHash])\\r\\n      revert OrderCancelledOrFinalized(orderHash);\\r\\n    cancelledOrFinalized[orderHash] = true;\\r\\n    emit Cancel(orderHash, msg.sender);\\r\\n  }\\r\\n\\r\\n  function cancelMultipleOrders(LibOrder.Order[] calldata orders) external {\\r\\n    if (orders.length == 0) revert InvalidCancelOrder();\\r\\n\\r\\n    for (uint256 i; i \\u003c orders.length; i++) {\\r\\n      if (msg.sender != orders[i].account) revert NotMaker();\\r\\n      if (orders[i].salt == 0) revert SaltZero();\\r\\n      bytes32 orderHash = orders[i].hash();\\r\\n      if (cancelledOrFinalized[orderHash])\\r\\n        revert OrderCancelledOrFinalized(orderHash);\\r\\n      cancelledOrFinalized[orderHash] = true;\\r\\n      emit Cancel(orderHash, msg.sender);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function matchOrders(\\r\\n    LibOrder.Order calldata orderLeft,\\r\\n    LibOrder.Order calldata orderRight\\r\\n  ) external payable override nonReentrant {\\r\\n    if (orderLeft.account == orderRight.account)\\r\\n      revert LeftRightSameMaker(orderLeft.account);\\r\\n    if (msg.sender != orderLeft.account) revert LeftMustBeSender();\\r\\n\\r\\n    bytes32 rightHash = orderRight.hash();\\r\\n    _validateOrder(orderRight, rightHash);\\r\\n\\r\\n    if (\\r\\n      !IExecutionStrategy(orderRight.strategy).canExecute(orderLeft, orderRight)\\r\\n    ) revert StrategyExecuteFailed(orderRight.strategy);\\r\\n\\r\\n    cancelledOrFinalized[rightHash] = true;\\r\\n\\r\\n    if (!orderLeft.isMaker \\u0026\\u0026 orderRight.isMaker) {\\r\\n      _transferFeesAndFunds(\\r\\n        orderRight.assets,\\r\\n        orderRight.currency,\\r\\n        msg.sender,\\r\\n        orderRight.account,\\r\\n        orderRight.price\\r\\n      );\\r\\n\\r\\n      _transferNFT(\\r\\n        orderRight.assets,\\r\\n        orderRight.strategy,\\r\\n        orderRight.account,\\r\\n        orderLeft.account,\\r\\n        orderRight.isMaker\\r\\n      );\\r\\n    } else if (orderLeft.isMaker \\u0026\\u0026 !orderRight.isMaker) {\\r\\n      if (!(IERC20Metadata(orderRight.currency).decimals() \\u003e 0))\\r\\n        revert InvalidCurrency(orderRight.currency);\\r\\n      _transferNFT(\\r\\n        orderRight.assets,\\r\\n        orderRight.strategy,\\r\\n        msg.sender,\\r\\n        orderRight.account,\\r\\n        orderRight.isMaker\\r\\n      );\\r\\n\\r\\n      _transferFeesAndFunds(\\r\\n        orderRight.assets,\\r\\n        orderRight.currency,\\r\\n        orderRight.account,\\r\\n        orderLeft.account,\\r\\n        orderRight.price\\r\\n      );\\r\\n    }\\r\\n    emit Match(rightHash, msg.sender, orderRight.account, orderRight.isMaker);\\r\\n  }\\r\\n\\r\\n  function updateMarketplaceSigner(address _marketplaceSigner)\\r\\n    external\\r\\n    onlyOwner\\r\\n  {\\r\\n    if (_marketplaceSigner == address(0)) revert NullAddress();\\r\\n    marketplaceSigner = _marketplaceSigner;\\r\\n    emit NewSigner(_marketplaceSigner);\\r\\n  }\\r\\n\\r\\n  function updateCurrencyManager(address _currencyManager) external onlyOwner {\\r\\n    if (_currencyManager == address(0)) revert NullAddress();\\r\\n    currencyManager = ICurrencyManager(_currencyManager);\\r\\n    emit NewCurrencyManager(_currencyManager);\\r\\n  }\\r\\n\\r\\n  function updateExecutionManager(address _executionManager)\\r\\n    external\\r\\n    onlyOwner\\r\\n  {\\r\\n    if (_executionManager == address(0)) revert NullAddress();\\r\\n    executionManager = IExecutionManager(_executionManager);\\r\\n    emit NewExecutionManager(_executionManager);\\r\\n  }\\r\\n\\r\\n  function updateFeeManager(address _feeManager) external onlyOwner {\\r\\n    if (_feeManager == address(0)) revert NullAddress();\\r\\n    feeManager = IFeeManager(_feeManager);\\r\\n    emit NewFeeManager(_feeManager);\\r\\n  }\\r\\n\\r\\n  function updateTransferProxy(address _transferProxy) external onlyOwner {\\r\\n    if (_transferProxy == address(0)) revert NullAddress();\\r\\n    transferProxy = ITransferProxy(_transferProxy);\\r\\n    emit NewTransferProxy(_transferProxy);\\r\\n  }\\r\\n\\r\\n  function updateProtocolFeeRecipient(address _protocolFeeRecipient)\\r\\n    external\\r\\n    onlyOwner\\r\\n  {\\r\\n    protocolFeeRecipient = _protocolFeeRecipient;\\r\\n    emit NewProtocolFeeRecipient(_protocolFeeRecipient);\\r\\n  }\\r\\n\\r\\n  function isOrderCancelledOrFinalized(LibOrder.Order calldata order)\\r\\n    external\\r\\n    view\\r\\n    override\\r\\n    returns (bool)\\r\\n  {\\r\\n    return cancelledOrFinalized[order.hash()];\\r\\n  }\\r\\n\\r\\n  function _transferFeesAndFunds(\\r\\n    LibOrder.Asset[] calldata assets,\\r\\n    address currency,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount\\r\\n  ) internal {\\r\\n    uint256 finalSellerAmount = amount;\\r\\n\\r\\n    (\\r\\n      uint256 protocolFeeAmount,\\r\\n      address royaltyFeeRecipient,\\r\\n      uint256 royaltyFeeAmount\\r\\n    ) = feeManager.calculateFee(\\r\\n      assets.length \\u003e 1 ? address(0) : assets[0].collection,\\r\\n      assets.length \\u003e 1 ? 0 : assets[0].tokenId,\\r\\n      amount\\r\\n    );\\r\\n\\r\\n    if (currency != address(0)) {\\r\\n      if (msg.value \\u003e 0) {\\r\\n        (bool os, ) = payable(from).call{ value: msg.value }(\\\"\\\");\\r\\n        if (!os) revert ReturnEthChangesFailed(msg.value);\\r\\n      }\\r\\n\\r\\n      if (protocolFeeRecipient != address(0) \\u0026\\u0026 protocolFeeAmount != 0) {\\r\\n        transferProxy.erc20safeTransferFrom(\\r\\n          currency,\\r\\n          from,\\r\\n          protocolFeeRecipient,\\r\\n          protocolFeeAmount\\r\\n        );\\r\\n        finalSellerAmount -= protocolFeeAmount;\\r\\n      }\\r\\n\\r\\n      if (royaltyFeeRecipient != address(0) \\u0026\\u0026 royaltyFeeAmount != 0) {\\r\\n        transferProxy.erc20safeTransferFrom(\\r\\n          currency,\\r\\n          from,\\r\\n          royaltyFeeRecipient,\\r\\n          royaltyFeeAmount\\r\\n        );\\r\\n        finalSellerAmount -= royaltyFeeAmount;\\r\\n\\r\\n        emit RoyaltyPayment(\\r\\n          assets.length \\u003e 1 ? address(0) : assets[0].collection,\\r\\n          assets.length \\u003e 1 ? 0 : assets[0].tokenId,\\r\\n          royaltyFeeRecipient,\\r\\n          currency,\\r\\n          royaltyFeeAmount\\r\\n        );\\r\\n      }\\r\\n      transferProxy.erc20safeTransferFrom(\\r\\n        currency,\\r\\n        from,\\r\\n        to,\\r\\n        finalSellerAmount\\r\\n      );\\r\\n    } else {\\r\\n      bool os;\\r\\n      if (msg.value \\u003e finalSellerAmount) {\\r\\n        (os, ) = payable(from).call{ value: msg.value - finalSellerAmount }(\\\"\\\");\\r\\n        if (!os) revert ReturnEthChangesFailed(msg.value - finalSellerAmount);\\r\\n      }\\r\\n\\r\\n      if (protocolFeeRecipient != address(0) \\u0026\\u0026 protocolFeeAmount != 0) {\\r\\n        (os, ) = payable(protocolFeeRecipient).call{ value: protocolFeeAmount }(\\r\\n          \\\"\\\"\\r\\n        );\\r\\n        if (!os) revert TransferProtocolEthFailed(protocolFeeAmount);\\r\\n\\r\\n        finalSellerAmount -= protocolFeeAmount;\\r\\n      }\\r\\n\\r\\n      if (royaltyFeeRecipient != address(0) \\u0026\\u0026 royaltyFeeAmount != 0) {\\r\\n        (os, ) = payable(royaltyFeeRecipient).call{ value: royaltyFeeAmount }(\\r\\n          \\\"\\\"\\r\\n        );\\r\\n        if (!os) revert TransferFeeEthFailed(royaltyFeeAmount);\\r\\n\\r\\n        finalSellerAmount -= royaltyFeeAmount;\\r\\n\\r\\n        emit RoyaltyPayment(\\r\\n          assets.length \\u003e 1 ? address(0) : assets[0].collection,\\r\\n          assets.length \\u003e 1 ? 0 : assets[0].tokenId,\\r\\n          royaltyFeeRecipient,\\r\\n          currency,\\r\\n          royaltyFeeAmount\\r\\n        );\\r\\n      }\\r\\n\\r\\n      (os, ) = payable(to).call{ value: finalSellerAmount }(\\\"\\\");\\r\\n      if (!os) revert TransferEthFailed(finalSellerAmount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _transferNFT(\\r\\n    LibOrder.Asset[] calldata assets,\\r\\n    address strategy,\\r\\n    address from,\\r\\n    address to,\\r\\n    bool makerAsk\\r\\n  ) internal {\\r\\n    for (uint256 i; i \\u003c assets.length; i++) {\\r\\n      if (\\r\\n        IERC165(assets[i].collection).supportsInterface(INTERFACE_ID_ERC721)\\r\\n      ) {\\r\\n        transferProxy.erc721safeTransferFrom(\\r\\n          assets[i].collection,\\r\\n          from,\\r\\n          to,\\r\\n          assets[i].tokenId,\\r\\n          \\\"\\\"\\r\\n        );\\r\\n      } else if (\\r\\n        IERC165(assets[i].collection).supportsInterface(INTERFACE_ID_ERC1155)\\r\\n      ) {\\r\\n        transferProxy.erc1155safeTransferFrom(\\r\\n          assets[i].collection,\\r\\n          from,\\r\\n          to,\\r\\n          assets[i].tokenId,\\r\\n          assets[i].amount,\\r\\n          \\\"\\\"\\r\\n        );\\r\\n      } else {\\r\\n        revert InvalidToken(assets[i].collection);\\r\\n      }\\r\\n      emit MarketplaceTransfer(\\r\\n        assets[i].collection,\\r\\n        strategy,\\r\\n        from,\\r\\n        to,\\r\\n        assets[i].tokenId,\\r\\n        assets[i].amount,\\r\\n        makerAsk\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _validateOrder(LibOrder.Order calldata order, bytes32 orderHash)\\r\\n    internal\\r\\n    view\\r\\n  {\\r\\n    if (cancelledOrFinalized[orderHash])\\r\\n      revert OrderCancelledOrFinalized(orderHash);\\r\\n\\r\\n    if (order.account == address(0)) revert MakerAddressZero();\\r\\n    if (order.assets.length == 0) revert EmptyAssetsOrder(order.assets.length);\\r\\n    if (order.salt == 0) revert SaltZero();\\r\\n\\r\\n    if (!verify(orderHash, order.account, order.signature))\\r\\n      revert InvalidSignature(orderHash);\\r\\n    if (!verify(orderHash, marketplaceSigner, order.marketplaceSignature))\\r\\n      revert InvalidMarketplaceSignature(orderHash);\\r\\n\\r\\n    address collection = order.assets.length \\u003e 1\\r\\n      ? address(0)\\r\\n      : order.assets[0].collection;\\r\\n\\r\\n    if (!currencyManager.isCurrencyWhitelisted(collection, order.currency))\\r\\n      revert CurrencyNotWhitelisted(order.currency);\\r\\n\\r\\n    if (!executionManager.isStrategyWhitelisted(collection, order.strategy))\\r\\n      revert StrategyNotWhitelisted(order.strategy);\\r\\n  }\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"},\"SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./IERC1271.sol\\\";\\r\\nimport \\\"./draft-EIP712.sol\\\";\\r\\nimport \\\"./LibOrder.sol\\\";\\r\\n\\r\\nerror MakerNotSender(address);\\r\\nerror OrderSignatureError(address);\\r\\nerror ContractOrderSignatureError(bytes);\\r\\n\\r\\nabstract contract SignatureChecker is EIP712 {\\r\\n  using ECDSA for bytes32;\\r\\n\\r\\n  bytes4 internal constant MAGICVALUE = 0x1626ba7e;\\r\\n\\r\\n  function verify(\\r\\n    bytes32 orderHash,\\r\\n    address signer,\\r\\n    bytes memory signature\\r\\n  ) internal view returns (bool) {\\r\\n    if (Address.isContract(signer)) {\\r\\n      if (\\r\\n        IERC1271(signer).isValidSignature(\\r\\n          _hashTypedDataV4(orderHash),\\r\\n          signature\\r\\n        ) != MAGICVALUE\\r\\n      ) revert ContractOrderSignatureError(signature);\\r\\n    } else {\\r\\n      return _hashTypedDataV4(orderHash).recover(signature) == signer;\\r\\n    }\\r\\n    return true;\\r\\n  }\\r\\n}\\r\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp \\u003e\\u003e= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currencyManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_executionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketplaceSigner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"ContractOrderSignatureError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"CurrencyNotWhitelisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"EmptyAssetsOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCancelOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"InvalidCurrency\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"InvalidMarketplaceSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LeftMustBeSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LeftRightSameMaker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MakerAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMaker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"OrderCancelledOrFinalized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ReturnEthChangesFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaltZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"StrategyExecuteFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"StrategyNotWhitelisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TransferEthFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TransferFeeEthFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TransferProtocolEthFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"makerAsk\",\"type\":\"bool\"}],\"name\":\"MarketplaceTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"makerAsk\",\"type\":\"bool\"}],\"name\":\"Match\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currencyManager\",\"type\":\"address\"}],\"name\":\"NewCurrencyManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executionManager\",\"type\":\"address\"}],\"name\":\"NewExecutionManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeManager\",\"type\":\"address\"}],\"name\":\"NewFeeManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocolFeeRecipient\",\"type\":\"address\"}],\"name\":\"NewProtocolFeeRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"marketplaceSigner\",\"type\":\"address\"}],\"name\":\"NewSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transferProxy\",\"type\":\"address\"}],\"name\":\"NewTransferProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RoyaltyPayment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INTERFACE_ID_ERC1155\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTERFACE_ID_ERC721\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isMaker\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LibOrder.Asset[]\",\"name\":\"assets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"salt\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"marketplaceSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isMaker\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LibOrder.Asset[]\",\"name\":\"assets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"salt\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"marketplaceSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"cancelMultipleOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyManager\",\"outputs\":[{\"internalType\":\"contract ICurrencyManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executionManager\",\"outputs\":[{\"internalType\":\"contract IExecutionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeManager\",\"outputs\":[{\"internalType\":\"contract IFeeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isMaker\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LibOrder.Asset[]\",\"name\":\"assets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"salt\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"marketplaceSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"isOrderCancelledOrFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplaceSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isMaker\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LibOrder.Asset[]\",\"name\":\"assets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"salt\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"marketplaceSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order\",\"name\":\"orderLeft\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isMaker\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LibOrder.Asset[]\",\"name\":\"assets\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"salt\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"marketplaceSignature\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order\",\"name\":\"orderRight\",\"type\":\"tuple\"}],\"name\":\"matchOrders\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferProxy\",\"outputs\":[{\"internalType\":\"contract ITransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currencyManager\",\"type\":\"address\"}],\"name\":\"updateCurrencyManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_executionManager\",\"type\":\"address\"}],\"name\":\"updateExecutionManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeManager\",\"type\":\"address\"}],\"name\":\"updateFeeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketplaceSigner\",\"type\":\"address\"}],\"name\":\"updateMarketplaceSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolFeeRecipient\",\"type\":\"address\"}],\"name\":\"updateProtocolFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transferProxy\",\"type\":\"address\"}],\"name\":\"updateTransferProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MarketplaceV3", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000047ac888e965c62377e0360a37abdef69dda36e2d000000000000000000000000265012e5c945d2b67b8087059e94827a011767fc00000000000000000000000019c9a7fbcb9a7a6980579b12245d5bf52461983e000000000000000000000000b880cd9cc3ff6d21a0f1a2d5c64ccc26071e7d4f000000000000000000000000865515f201a511da9dea4ffe9250657e54dbd915", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://14c0404e07a3d70532f0e9e7f4523906cce9088d17d27a44814540c04af52d8e"}