{"SourceCode": "/**\r\n *Submitted for verification at PolygonScan.com on 2023-09-26\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\ncontract BMG {\r\n    using SafeMath for uint256; \r\n    uint256 private constant timeStep = 1 days;\r\n     uint256 private constant dayPerCycle = 10 days; \r\n     uint256 private constant maxAddFreeze = 30 days;\r\n\r\n    uint256 private constant maxSearchDepth = 3000;\r\n    uint256 private constant baseDividend = 10000;\r\n    uint256 private constant incomeFeePercents1 = 600;\r\n\r\n    uint256 private constant incomeFeePercents2 = 400;\r\n\r\n    uint256 private constant splitPercents = 3000;\r\n    uint256 private constant dayRewardPercents = 100;\r\n    uint256 private constant unfreezeWithoutIncomePercents = 15000;\r\n    uint256 private constant unfreezeWithIncomePercents = 20000;\r\n    uint256[5] private levelDeposit = [50e6, 500e6, 1000e6, 2000e6, 3000e6];\r\n    uint256[5] private balReached = [10e10, 30e10, 80e10, 20e11, 50e11];\r\n    uint256[5] private balFreeze = [50e9, 15e10, 60e10, 15e11, 30e11];\r\n    uint256[5] private balUnfreeze = [15e10, 50e10, 10e11, 30e11, 80e11];\r\n    uint256[20] private invitePercents = [500, 200, 100, 200, 100, 100, 100, 100, 100, 100, 50, 50, 50, 50, 50, 20, 20, 20, 20, 20];\r\n\r\n    IERC20 private usdt;\r\n    address private feeReceiver;\r\n    address private marketing_wallet;\r\n    address private defaultRefer;\r\n    uint256 private startTime;\r\n    uint256 private lastDistribute;\r\n    uint256 private totalUsers;\r\n    uint256 private totalDeposit;\r\n    uint256 private freezedTimes;\r\n    uint256 private predictPool;\r\n    uint256 private totalPredictPool;\r\n\r\n\r\n    uint256 private insuranceFund;\r\n    uint256 private mainFund;\r\n    bool private isFreezing;\r\n    address[] private depositors;\r\n  \r\n\r\n      address[] public silverGoldUsers;\r\n      uint256 public silverGoldPoolAmt;\r\n      uint256 public sgp_last_draw;\r\n \r\n    \r\n\r\n    mapping(uint256=>bool) private balStatus;\r\n    mapping(uint256=>uint256) private freezeTime;\r\n    mapping(uint256=>uint256) private unfreezeTime;\r\n    mapping(uint256=>uint256) private dayPredictPool;\r\n    mapping(address=>mapping(uint256=>bool)) private isUnfreezedReward;\r\n    \r\n    struct UserInfo {\r\n        address referrer;\r\n        uint256 level;\r\n        uint256 maxDeposit;\r\n        uint256 maxDepositable;\r\n        uint256 teamNum;\r\n        uint256 teamTotalDeposit;\r\n        uint256 totalFreezed;\r\n        uint256 totalRevenue;\r\n        uint256 unfreezeIndex;\r\n        uint256 startTime;\r\n        bool isMaxFreezing;\r\n    }\r\n    struct RewardInfo{\r\n        uint256 capitals;\r\n        uint256 statics;\r\n        uint256 invited;\r\n        uint256 sgpwin;\r\n        uint256 sgpwinTotal;\r\n        uint256 split;\r\n        uint256 lastWithdaw;\r\n        uint256 total_deposit;\r\n        uint256 total_withdrawals;\r\n    }\r\n    struct OrderInfo {\r\n        uint256 amount;\r\n        uint256 start;\r\n        uint256 unfreeze;\r\n        bool isUnfreezed;\r\n    }\r\n    struct PredictInfo {\r\n        uint256 time;\r\n        uint256 number;\r\n    }\r\n    mapping(address=>UserInfo) private userInfo;\r\n    mapping(address=>RewardInfo) private rewardInfo;\r\n    mapping(address=>OrderInfo[]) private orderInfos;\r\n    mapping(address=>mapping(uint256=>uint256)) private userCycleMax;\r\n    mapping(address=>mapping(uint256=>address[])) private teamUsers;\r\n\r\n    mapping(address=>bool) private insuranceBeneficiary;\r\n\r\n    event Register(address user, address referral);\r\n    event Deposit(address user, uint256 types, uint256 amount, bool isFreezing);\r\n    event TransferBySplit(address user, uint256 subBal, address receiver, uint256 amount);\r\n    event Withdraw(address user, uint256 incomeFee,uint256 split, uint256 withdraw);\r\n    event Predict(uint256 time, address user, uint256 amount);\r\n    event DistributePredictPool(uint256 day, uint256 reward, uint256 pool, uint256 time);\r\n\r\n    constructor(address _usdtAddr, address _defaultRefer, address _feeReceiver, uint256 _startTime, address _marketing ) {\r\n        usdt = IERC20(_usdtAddr);\r\n        defaultRefer = _defaultRefer;\r\n        feeReceiver = _feeReceiver;\r\n        startTime = _startTime;\r\n        lastDistribute = _startTime;\r\n        sgp_last_draw = _startTime;\r\n        marketing_wallet = _marketing;\r\n    }\r\n\r\n    function register(address _referral) external {\r\n        require(userInfo[_referral].maxDeposit > 0 || _referral == defaultRefer, \"invalid refer\");\r\n        require(userInfo[msg.sender].referrer == address(0), \"Already referrer bonded\");\r\n        userInfo[msg.sender].referrer = _referral;\r\n        emit Register(msg.sender, _referral);\r\n    }\r\n\r\n    function deposit(uint256 _amount) external {\r\n        _deposit(msg.sender, _amount, 0);\r\n    }\r\n\r\n    function depositBySplit(uint256 _amount) public {\r\n        _deposit(msg.sender, _amount, 1);\r\n\r\n    }\r\n\r\n    function redeposit() public {\r\n        _deposit(msg.sender, 0, 2);\r\n    }\r\n\r\n    function _deposit(address _userAddr, uint256 _amount, uint256 _types) private {\r\n        require(block.timestamp >= startTime, \"not start\");\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        require(user.referrer != address(0), \"not register\");\r\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\r\n        if(_types == 0){\r\n            usdt.transferFrom(_userAddr, address(this), _amount);\r\n                userRewards.total_deposit = userRewards.total_deposit.add(_amount);\r\n                //0.5% to insurance fund \r\n                uint256 insuredAmt = _amount.mul(50).div(baseDividend);\r\n                insuranceFund =  insuranceFund.add(insuredAmt);\r\n                uint256 remainingFund = _amount.sub(insuredAmt);\r\n                mainFund = mainFund.add(remainingFund);\r\n\r\n           _balActived();\r\n        }else if(_types == 1){\r\n            userRewards.total_deposit = userRewards.total_deposit.add(_amount);\r\n            require(user.level == 0, \"actived\");\r\n            require(userRewards.split >= _amount, \"insufficient\");\r\n            require(_amount % (levelDeposit[0].mul(2)) == 0, \"amount err\");\r\n            userRewards.split = userRewards.split.sub(_amount);\r\n        }else{\r\n            // renew\r\n            _amount = orderInfos[_userAddr][user.unfreezeIndex].amount;\r\n        }\r\n\r\n        uint256 curCycle = getCurCycle();\r\n        (uint256 userCurMin, uint256 userCurMax) = getUserCycleDepositable(_userAddr, curCycle);\r\n        require(_amount >= userCurMin && _amount <= userCurMax && _amount % (levelDeposit[0]) == 0, \"amount err\");\r\n\r\n\r\n        if(isFreezing && !isUnfreezedReward[_userAddr][freezedTimes]) isUnfreezedReward[_userAddr][freezedTimes] = true;\r\n        \r\n        totalDeposit = totalDeposit.add(_amount);\r\n        depositors.push(_userAddr);\r\n\r\n        if(user.level == 0){ \r\n         \r\n           \r\n            totalUsers = totalUsers + 1;\r\n            user.startTime = block.timestamp;\r\n        }\r\n          _updateUplineReward(_userAddr, _amount,_types); \r\n        _unfreezeCapitalOrReward(_userAddr, _amount, _types); \r\n\r\n        bool isMaxFreezing = _addNewOrder(_userAddr, _amount, _types, user.startTime, user.isMaxFreezing);\r\n        user.isMaxFreezing = isMaxFreezing;\r\n        \r\n        _updateUserMax(_userAddr, _amount, userCurMax, curCycle); \r\n        _updateLevel(_userAddr);\r\n        if(isFreezing) _setFreezeReward();\r\n\r\n       \r\n            if(_types == 0){\r\n\r\n               uint256 pool_share =  _amount.mul(50).div(baseDividend);\r\n               silverGoldPoolAmt+= pool_share;\r\n            }\r\n\r\n \r\n\r\n\r\n                 if((block.timestamp > sgp_last_draw + 1 days) && silverGoldUsers.length > 0)\r\n                {\r\n                    _draw_sgp_pool();\r\n                }\r\n            \r\n\r\n        emit Deposit(_userAddr, _types, _amount, isFreezing);\r\n    }\r\n\r\n    function _updateUplineReward(address _userAddr, uint256 _amount,uint256 _types) private {\r\n        address upline = userInfo[_userAddr].referrer;\r\n        for(uint256 i = 0; i < invitePercents.length; i++){ \r\n            if(upline != address(0)){\r\n                if(!isFreezing || isUnfreezedReward[upline][freezedTimes]){\r\n\r\n                    OrderInfo[] storage upOrders = orderInfos[upline];   \r\n                    if(upOrders.length > 0){ \r\n\r\n\r\n                        uint256 latestUnFreezeTime = getOrderUnfreezeTime(upline, upOrders.length - 1); \r\n                        uint256 maxFreezing = latestUnFreezeTime > block.timestamp ? upOrders[upOrders.length - 1].amount : 0;\r\n                        uint256 newAmount = maxFreezing < _amount ? maxFreezing : _amount;\r\n                    \r\n                        if(newAmount > 0){\r\n                            RewardInfo storage upRewards = rewardInfo[upline];\r\n                            uint256 reward = newAmount.mul(invitePercents[i]).div(baseDividend);\r\n\r\n                                if(i == 0 && _types != 2)  \r\n                                {\r\n                                    upRewards.invited = upRewards.invited.add(reward);\r\n                                    userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                 \r\n                                }else if(i < 5 ){\r\n\r\n                                       uint256 direct_users =  getDirectusers(upline);\r\n                                \r\n                                       if(direct_users >  i )  \r\n                                       {    \r\n                                           if( _types != 2)\r\n                                           {\r\n                            \r\n                                                upRewards.invited = upRewards.invited.add(reward);\r\n                                                userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                           }\r\n\r\n                                           if(_types == 2   && userInfo[upline].level == 1)\r\n                                           {\r\n                                             \r\n                                             \r\n                                                    upRewards.invited = upRewards.invited.add(reward);\r\n                                                    userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                                \r\n\r\n                                           }\r\n                                           \r\n                                           \r\n                                       }\r\n\r\n                                }else if(i > 4 && i < 10  && userInfo[upline].level == 2 && _types == 2){ \r\n\r\n                                            \r\n                                                upRewards.invited = upRewards.invited.add(reward);\r\n                                                userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                            \r\n                                    \r\n                                }else if(i > 9 && i < 15 && userInfo[upline].level == 3 && _types == 2){ \r\n\r\n                                       \r\n                                            upRewards.invited = upRewards.invited.add(reward);\r\n                                            userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                        \r\n                                }else if(i > 14  && userInfo[upline].level == 4  && _types == 2 ){ \r\n                                    \r\n                                        upRewards.invited = upRewards.invited.add(reward);\r\n                                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                                     \r\n                                    \r\n                                }\r\n                             \r\n                        }\r\n                    }\r\n                }\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _unfreezeCapitalOrReward(address _userAddr, uint256 _amount, uint256 _types) private { \r\n        (uint256 unfreezed, uint256 rewards) = _unfreezeOrder(_userAddr, _amount); \r\n        if(_types == 0){\r\n            require(_amount > unfreezed, \"redeposit only\");\r\n        }else if(_types >= 2){\r\n            require(_amount == unfreezed, \"redeposit err\");\r\n        }\r\n\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\r\n        if(unfreezed > 0){\r\n            user.unfreezeIndex = user.unfreezeIndex + 1;\r\n            if(rewards > 0) userRewards.statics = userRewards.statics.add(rewards); \r\n            if(_types < 2) userRewards.capitals = userRewards.capitals.add(unfreezed);\r\n        }\r\n        user.totalRevenue = user.totalRevenue.add(rewards);\r\n        _updateFreezeAndTeamDeposit(_userAddr, _amount, unfreezed);\r\n    }\r\n\r\n    function _unfreezeOrder(address _userAddr, uint256 _amount) private returns(uint256 unfreezed, uint256 rewards){\r\n        if(orderInfos[_userAddr].length > 0){\r\n            UserInfo storage user = userInfo[_userAddr];\r\n            OrderInfo storage order = orderInfos[_userAddr][user.unfreezeIndex];\r\n            uint256 orderUnfreezeTime = getOrderUnfreezeTime(_userAddr, user.unfreezeIndex);\r\n            if(user.level > 0 && user.level < 5) require(block.timestamp >= orderUnfreezeTime, \"freezing\");\r\n            if(order.isUnfreezed == false && block.timestamp >= orderUnfreezeTime && _amount >= order.amount){\r\n                order.isUnfreezed = true;\r\n                unfreezed = order.amount;\r\n                rewards = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDividend);\r\n                if(isFreezing){\r\n                    if(user.totalFreezed > user.totalRevenue){\r\n                        uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\r\n                        if(rewards > leftCapital){\r\n                            rewards = leftCapital;\r\n                        }\r\n                    }else{\r\n                        rewards = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateFreezeAndTeamDeposit(address _userAddr, uint256 _amount, uint256 _unfreezed) private {\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        if(_amount > _unfreezed){\r\n            uint256 incAmount = _amount.sub(_unfreezed);\r\n            user.totalFreezed = user.totalFreezed.add(incAmount);\r\n            address upline = user.referrer;\r\n            for(uint256 i = 0; i < invitePercents.length; i++){\r\n                if(upline != address(0)){\r\n                    UserInfo storage upUser = userInfo[upline];\r\n                    if(user.level == 0 && _userAddr != upline){\r\n                        upUser.teamNum = upUser.teamNum + 1;\r\n                        teamUsers[upline][i].push(_userAddr); \r\n                    }\r\n                    upUser.teamTotalDeposit = upUser.teamTotalDeposit.add(incAmount);\r\n\r\n                    if(upline == defaultRefer) break;\r\n                    upline = upUser.referrer;\r\n                }else{\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _addNewOrder(address _userAddr, uint256 _amount, uint256 _types, uint256 _startTime, bool _isMaxFreezing) private returns(bool isMaxFreezing){\r\n        uint256 addFreeze;\r\n        OrderInfo[] storage orders = orderInfos[_userAddr];\r\n        if(_isMaxFreezing){\r\n            isMaxFreezing = true;\r\n        }else{\r\n\r\n            if((freezedTimes > 0 && _types == 1) || (!isFreezing && _startTime < freezeTime[freezedTimes])){\r\n                isMaxFreezing = true;\r\n            }else{\r\n                addFreeze = (orders.length).mul(timeStep);\r\n                if(addFreeze > maxAddFreeze) isMaxFreezing = true;\r\n            }\r\n        }\r\n        uint256 unfreeze = isMaxFreezing ? block.timestamp.add(dayPerCycle).add(maxAddFreeze) : block.timestamp.add(dayPerCycle).add(addFreeze);\r\n        orders.push(OrderInfo(_amount, block.timestamp, unfreeze, false));\r\n    }\r\n\r\n    function _updateUserMax(address _userAddr, uint256 _amount, uint256 _userCurMax, uint256 _curCycle) internal {\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        if(_amount > user.maxDeposit) user.maxDeposit = _amount;\r\n        userCycleMax[_userAddr][_curCycle] = _userCurMax; \r\n        uint256 nextMaxDepositable;\r\n        if(_amount == _userCurMax){ \r\n            uint256 curMaxDepositable = getCurMaxDepositable();\r\n            if(_userCurMax >= curMaxDepositable){\r\n                nextMaxDepositable = curMaxDepositable;\r\n            }else{\r\n\r\n                if(_userCurMax < levelDeposit[3]){ \r\n                    nextMaxDepositable = _userCurMax.add(levelDeposit[1]);\r\n                }else{\r\n                    nextMaxDepositable = _userCurMax.add(levelDeposit[2]);\r\n                }\r\n\r\n               \r\n\r\n            }\r\n        }else{\r\n            nextMaxDepositable = _userCurMax;\r\n        }\r\n\r\n        userCycleMax[_userAddr][_curCycle + 1] = nextMaxDepositable;\r\n        user.maxDepositable = nextMaxDepositable;\r\n    }\r\n\r\n    function _updateLevel(address _userAddr) private { \r\n        UserInfo storage user = userInfo[_userAddr];\r\n                                 (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_userAddr);\r\n\r\n\r\n            if(user.maxDeposit >= 1000e6 && user.teamNum >= 50 && maxTeam >= 10000e6 && otherTeam >= 10000e6 && user.level < 1 ){\r\n                user.level = 1;\r\n\r\n            }\r\n\r\n            if(user.maxDeposit >= 1500e6 && user.teamNum >= 120 && maxTeam >= 30000e6 && otherTeam >= 30000e6 && user.level < 2 ){\r\n                user.level = 2;\r\n                 silverGoldUsers.push(_userAddr);\r\n            }\r\n\r\n            if(user.maxDeposit >= 2000e6 && user.teamNum >= 200 && maxTeam >= 50000e6 && otherTeam >= 50000e6 && user.level < 3 ){\r\n                user.level = 3;\r\n            }\r\n\r\n            if(user.maxDeposit >= 3000e6 && user.teamNum >= 300 && maxTeam >= 100000e6 && otherTeam >= 100000e6 && user.level < 4 ){\r\n                user.level = 4;\r\n            }\r\n    }\r\n\r\n    function withdraw() external {\r\n\r\n        \r\n            RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n            uint256 rewardsStatic = userRewards.statics.add(userRewards.invited).add(userRewards.sgpwin);\r\n\r\n            \r\n            uint256 total_deposit = userRewards.total_deposit;\r\n            uint256 total_withdrawals = userRewards.total_withdrawals;\r\n\r\n            if(userInfo[msg.sender].level > 0)\r\n            {\r\n                require(total_withdrawals <  total_deposit.mul(40).div(10),\"Reached to 4X cap\" );\r\n                if(total_withdrawals.add(rewardsStatic) > total_deposit.mul(40).div(10)){\r\n                    rewardsStatic =   total_deposit.mul(40).div(10).sub(total_withdrawals);\r\n                }\r\n            }else{\r\n                require(total_withdrawals < total_deposit.mul(25).div(10),\"Reached to 2X cap\" );\r\n                 if(total_withdrawals.add(rewardsStatic) > total_deposit.mul(25).div(10)){\r\n                    rewardsStatic =  total_deposit.mul(25).div(10).sub(total_withdrawals);\r\n                }\r\n\r\n            }\r\n            userRewards.total_withdrawals = userRewards.total_withdrawals.add(rewardsStatic);\r\n\r\n            uint256 incomeFee = rewardsStatic.mul(incomeFeePercents1).div(baseDividend);\r\n             uint256 marketing = rewardsStatic.mul(incomeFeePercents2).div(baseDividend);\r\n\r\n\r\n\r\n            if(mainFund >= incomeFee.add(marketing) )\r\n            {\r\n                usdt.transfer(feeReceiver, incomeFee);\r\n                usdt.transfer(marketing_wallet, marketing);\r\n                mainFund = mainFund.sub(incomeFee);\r\n                mainFund = mainFund.sub(marketing);\r\n            }else{\r\n\r\n                usdt.transfer(feeReceiver, incomeFee);\r\n                 usdt.transfer(marketing_wallet, marketing);\r\n                insuranceFund = insuranceFund.sub(incomeFee);\r\n                insuranceFund = insuranceFund.sub(marketing);\r\n\r\n            }\r\n           \r\n            uint256 leftReward = rewardsStatic.sub(incomeFee).sub(marketing); \r\n            uint256 split = leftReward.mul(splitPercents).div(baseDividend);\r\n            uint256 withdrawable = leftReward.sub(split);\r\n            uint256 capitals = userRewards.capitals; \r\n            userRewards.capitals = 0;\r\n            userRewards.statics = 0;\r\n            userRewards.invited = 0;\r\n          \r\n\r\n            userRewards.sgpwinTotal += userRewards.sgpwin;\r\n            userRewards.sgpwin = 0;\r\n            \r\n            userRewards.split = userRewards.split.add(split);\r\n            userRewards.lastWithdaw = block.timestamp;\r\n            withdrawable = withdrawable.add(capitals);\r\n\r\n            if(mainFund >= withdrawable )\r\n            {\r\n                usdt.transfer(msg.sender, withdrawable);\r\n                mainFund = mainFund.sub(withdrawable);\r\n            }else{\r\n                if(userRewards.lastWithdaw == 0 ||  insuranceBeneficiary[msg.sender] == true ){\r\n                    usdt.transfer(msg.sender, withdrawable);\r\n                    insuranceFund = insuranceFund.sub(withdrawable);\r\n                    insuranceBeneficiary[msg.sender] = true;\r\n                }\r\n\r\n            }\r\n            \r\n            if(!isFreezing) _setFreezeReward();\r\n            emit Withdraw(msg.sender, incomeFee, split, withdrawable);\r\n       \r\n    }\r\n\r\n  \r\n\r\n    function transferBySplit(address _receiver, uint256 _amount) external {\r\n        require(_amount == 55e6 || _amount == 110e6,\"Split amt error\");\r\n        uint256 subBal;\r\n        if(_amount == 55e6)\r\n        {\r\n             subBal = 50e6;\r\n        }else{\r\n                   subBal = 100e6;\r\n        }\r\n        \r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        require(userRewards.split >= subBal, \"insufficient split\");\r\n        userRewards.split = userRewards.split.sub(_amount);\r\n        rewardInfo[_receiver].split = rewardInfo[_receiver].split.add(subBal);\r\n        emit TransferBySplit(msg.sender, subBal, _receiver, _amount);\r\n    }\r\n\r\n    \r\n\r\n    function _draw_sgp_pool() private {\r\n         if(block.timestamp >= sgp_last_draw.add(timeStep)){\r\n            uint256 share = silverGoldPoolAmt.div(silverGoldUsers.length);\r\n            for(uint256 i =0; i < silverGoldUsers.length; i++)\r\n            {\r\n                rewardInfo[silverGoldUsers[i]].sgpwin =  rewardInfo[silverGoldUsers[i]].sgpwin.add(share);\r\n            }\r\n            silverGoldPoolAmt = 0;\r\n            sgp_last_draw = block.timestamp;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function _balActived() private {\r\n        uint256 bal = usdt.balanceOf(address(this));\r\n        for(uint256 i = balReached.length; i > 0; i--){\r\n            if(bal >= balReached[i - 1]){\r\n                balStatus[balReached[i - 1]] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setFreezeReward() private {\r\n        uint256 bal = usdt.balanceOf(address(this));\r\n        for(uint256 i = balReached.length; i > 0; i--){\r\n            if(balStatus[balReached[i - 1]]){\r\n                if(!isFreezing){\r\n                    if(bal < balFreeze[i - 1]){\r\n                        isFreezing = true;\r\n                        freezedTimes = freezedTimes + 1;\r\n                        freezeTime[freezedTimes] = block.timestamp;\r\n                    }\r\n                }else{\r\n                    if(bal >= balUnfreeze[i - 1]){\r\n                        isFreezing = false;\r\n                        unfreezeTime[freezedTimes] = block.timestamp;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getOrderUnfreezeTime(address _userAddr, uint256 _index) public view returns(uint256 orderUnfreezeTime) {\r\n        OrderInfo storage order = orderInfos[_userAddr][_index];\r\n        orderUnfreezeTime = order.unfreeze;\r\n        if(!isFreezing && !order.isUnfreezed && userInfo[_userAddr].startTime < freezeTime[freezedTimes]){\r\n            orderUnfreezeTime =  order.start.add(dayPerCycle).add(maxAddFreeze);\r\n        }\r\n    }\r\n\r\n    function getUserCycleDepositable(address _userAddr, uint256 _cycle) public view returns(uint256 cycleMin, uint256 cycleMax) {\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        if(user.maxDeposit > 0){ \r\n            cycleMin = user.maxDeposit;\r\n            cycleMax = userCycleMax[_userAddr][_cycle];\r\n            if(cycleMax == 0) cycleMax = user.maxDepositable;\r\n            uint256 curMaxDepositable = getCurMaxDepositable();\r\n            if(isFreezing){\r\n                if(user.startTime < freezeTime[freezedTimes] && !isUnfreezedReward[_userAddr][freezedTimes]){\r\n                    cycleMin = user.totalFreezed > user.totalRevenue ? cycleMin.mul(unfreezeWithoutIncomePercents).div(baseDividend) : cycleMin.mul(unfreezeWithIncomePercents).div(baseDividend);\r\n                    cycleMax = curMaxDepositable;\r\n                }\r\n            }else{\r\n                if(user.startTime < freezeTime[freezedTimes]) cycleMax = curMaxDepositable;\r\n            }\r\n        }else{\r\n            cycleMin = levelDeposit[0];\r\n            cycleMax = levelDeposit[1];\r\n        }\r\n\r\n        if(cycleMin > cycleMax) cycleMin = cycleMax;\r\n    }\r\n\r\n   \r\n\r\n    function getTeamDeposit(address _userAddr) public view returns(uint256 maxTeam, uint256 otherTeam, uint256 totalTeam){\r\n        address[] memory directTeamUsers = teamUsers[_userAddr][0];\r\n        for(uint256 i = 0; i < directTeamUsers.length; i++){\r\n            UserInfo storage user = userInfo[directTeamUsers[i]];\r\n            uint256 userTotalTeam = user.teamTotalDeposit.add(user.totalFreezed);\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if(userTotalTeam > maxTeam) maxTeam = userTotalTeam;            \r\n\r\n            if(i >= maxSearchDepth) break;\r\n        }\r\n        otherTeam = totalTeam.sub(maxTeam);\r\n    }\r\n\r\n\r\n    function getCurCycle() public view returns(uint256) {\r\n        return (block.timestamp.sub(startTime)).div(dayPerCycle);\r\n    }\r\n\r\n    function getCurMaxDepositable() public view returns(uint256) {\r\n        return levelDeposit[4].mul(2**freezedTimes);\r\n    }\r\n\r\n    \r\n\r\n    function getOrderLength(address _userAddr) public view returns(uint256) {\r\n        return orderInfos[_userAddr].length;\r\n    }\r\n\r\n    function getLatestDepositors(uint256 _length) public view returns(address[] memory latestDepositors) {\r\n        uint256 totalCount = depositors.length;\r\n        if(_length > totalCount) _length = totalCount;\r\n        latestDepositors = new address[](_length);\r\n        for(uint256 i = totalCount; i > totalCount - _length; i--){\r\n            latestDepositors[totalCount - i] = depositors[i - 1];\r\n        }\r\n    }\r\n\r\n    function getTeamUsers(address _userAddr, uint256 _layer) public view returns(address[] memory) {\r\n        return teamUsers[_userAddr][_layer];\r\n    }\r\n\r\n    \r\n\r\n    function getBalStatus(uint256 _bal) external view returns(bool) {\r\n        return balStatus[_bal];\r\n    }\r\n\r\n    function getDirectusers(address _addr) public view  returns(uint256)\r\n    {\r\n        return  teamUsers[_addr][0].length;\r\n    }\r\n\r\n    function getUserCycleMax(address _userAddr, uint256 _cycle) external view returns(uint256){\r\n        return userCycleMax[_userAddr][_cycle];\r\n    }\r\n\r\n    function getUserInfos(address _userAddr) external view returns(UserInfo memory user, RewardInfo memory reward, OrderInfo[] memory orders, bool unfreeze) {\r\n        user = userInfo[_userAddr];\r\n        reward = rewardInfo[_userAddr];\r\n        orders = orderInfos[_userAddr];\r\n        unfreeze = isUnfreezedReward[_userAddr][freezedTimes];\r\n    }\r\n\r\n    function getContractInfos() external view returns(address[4] memory infos0, uint256[10] memory infos1, bool freezing) {\r\n        infos0[0] = address(usdt);\r\n        infos0[1] = feeReceiver;\r\n        infos0[2] = defaultRefer;\r\n        infos0[3] = marketing_wallet;\r\n        infos1[0] = startTime;\r\n        infos1[1] = lastDistribute;\r\n        infos1[2] = totalUsers;\r\n        infos1[3] = totalDeposit;\r\n        infos1[4] = insuranceFund;\r\n        infos1[5] = mainFund;\r\n        infos1[7] = freezedTimes;\r\n        infos1[8] = freezeTime[freezedTimes];\r\n        infos1[9] = unfreezeTime[freezedTimes];\r\n        freezing = isFreezing;\r\n    }\r\n\r\n    \r\n}\r\n\r\n\r\n    library SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address BepSegment, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed BepSegment, address indexed spender, uint256 value);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_marketing\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"types\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFreezing\",\"type\":\"bool\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"DistributePredictPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Predict\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subBal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdraw\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bal\",\"type\":\"uint256\"}],\"name\":\"getBalStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractInfos\",\"outputs\":[{\"internalType\":\"address[4]\",\"name\":\"infos0\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[10]\",\"name\":\"infos1\",\"type\":\"uint256[10]\"},{\"internalType\":\"bool\",\"name\":\"freezing\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurMaxDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getDirectusers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"getLatestDepositors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"latestDepositors\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getOrderUnfreezeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderUnfreezeTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"otherTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleMax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getUserInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreezeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMaxFreezing\",\"type\":\"bool\"}],\"internalType\":\"struct BMG.UserInfo\",\"name\":\"user\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sgpwin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sgpwinTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_withdrawals\",\"type\":\"uint256\"}],\"internalType\":\"struct BMG.RewardInfo\",\"name\":\"reward\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"internalType\":\"struct BMG.OrderInfo[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"unfreeze\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sgp_last_draw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"silverGoldPoolAmt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"silverGoldUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BMG", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000914bf3a64ac93e67ac4a689b7303a24887ac233f00000000000000000000000016ee5ef5bb6184046e1ef23ebecb18f0b3a3f28c000000000000000000000000000000000000000000000000000000006512fc9a000000000000000000000000e82a7240a23d6bba5b1849927366fc485e845bd9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2489f70626bd4f3bafd4d79f5db611c43d5bef599b563c1ad638006411ca3fc5"}