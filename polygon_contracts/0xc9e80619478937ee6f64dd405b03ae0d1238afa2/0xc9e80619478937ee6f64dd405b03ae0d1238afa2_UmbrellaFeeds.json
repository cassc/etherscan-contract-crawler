{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n\\ninterface IRegistry {\\n    event LogRegistered(address indexed destination, bytes32 name);\\n\\n    /// @dev imports new contract addresses and override old addresses, if they exist under provided name\\n    /// This method can be used for contracts that for some reason do not have `getName` method\\n    /// @param  _names array of contract names that we want to register\\n    /// @param  _destinations array of contract addresses\\n    function importAddresses(bytes32[] calldata _names, address[] calldata _destinations) external;\\n\\n    /// @dev imports new contracts and override old addresses, if they exist.\\n    /// Names of contracts are fetched directly from each contract by calling `getName`\\n    /// @param  _destinations array of contract addresses\\n    function importContracts(address[] calldata _destinations) external;\\n\\n    /// @dev this method ensure, that old and new contract is aware of it state in registry\\n    /// Note: BSC registry does not have this method. This method was introduced in later stage.\\n    /// @param _newContract address of contract that will replace old one\\n    function atomicUpdate(address _newContract) external;\\n\\n    /// @dev similar to `getAddress` but throws when contract name not exists\\n    /// @param name contract name\\n    /// @return contract address registered under provided name or throws, if does not exists\\n    function requireAndGetAddress(bytes32 name) external view returns (address);\\n\\n    /// @param name contract name in a form of bytes32\\n    /// @return contract address registered under provided name\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    /// @param _name contract name\\n    /// @return contract address assigned to the name or address(0) if not exists\\n    function getAddressByString(string memory _name) external view returns (address);\\n\\n    /// @dev helper method that converts string to bytes32,\\n    /// you can use to to generate contract name\\n    function stringToBytes32(string memory _string) external pure returns (bytes32 result);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingBank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IStakingBank is IERC20 {\\n    /// @param id address of validator wallet\\n    /// @param location URL of the validator API\\n    struct Validator {\\n        address id;\\n        string location;\\n    }\\n\\n    event LogValidatorRegistered(address indexed id);\\n    event LogValidatorUpdated(address indexed id);\\n    event LogValidatorRemoved(address indexed id);\\n    event LogMinAmountForStake(uint256 minAmountForStake);\\n\\n    /// @dev setter for `minAmountForStake`\\n    function setMinAmountForStake(uint256 _minAmountForStake) external;\\n\\n    /// @dev allows to stake `token` by validators\\n    /// Validator needs to approve StakingBank beforehand\\n    /// @param _value amount of tokens to stake\\n    function stake(uint256 _value) external;\\n\\n    /// @dev notification about approval from `_from` address on UMB token\\n    /// Staking bank will stake max approved amount from `_from` address\\n    /// @param _from address which approved token spend for IStakingBank\\n    function receiveApproval(address _from) external returns (bool success);\\n\\n    /// @dev withdraws stake tokens\\n    /// it throws, when balance will be less than required minimum for stake\\n    /// to withdraw all use `exit`\\n    function withdraw(uint256 _value) external returns (bool success);\\n\\n    /// @dev unstake and withdraw all tokens\\n    function exit() external returns (bool success);\\n\\n    /// @dev creates (register) new validator\\n    /// @param _id validator address\\n    /// @param _location location URL of the validator API\\n    function create(address _id, string calldata _location) external;\\n\\n    /// @dev removes validator\\n    /// @param _id validator wallet\\n    function remove(address _id) external;\\n\\n    /// @dev updates validator location\\n    /// @param _id validator wallet\\n    /// @param _location new validator URL\\n    function update(address _id, string calldata _location) external;\\n\\n    /// @return total number of registered validators (with and without balance)\\n    function getNumberOfValidators() external view returns (uint256);\\n\\n    /// @dev gets validator address for provided index\\n    /// @param _ix index in array of list of all validators wallets\\n    function addresses(uint256 _ix) external view returns (address);\\n\\n    /// @param _id address of validator\\n    /// @return id address of validator\\n    /// @return location URL of validator\\n    function validators(address _id) external view returns (address id, string memory location);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingBankStatic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./IStakingBank.sol\\\";\\n\\n\\ninterface IStakingBankStatic is IStakingBank {\\n    /// @param _validators array of validators addresses to verify\\n    /// @return TRUE when all validators are valid, FALSE otherwise\\n    function verifyValidators(address[] calldata _validators) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUmbrellaFeeds.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUmbrellaFeeds {\\n    struct PriceData {\\n        /// @dev this is placeholder, that can be used for some additional data\\n        /// atm of creating this smart contract, it is only used as marker for removed data (when == type(uint8).max)\\n        uint8 data;\\n        /// @dev heartbeat: how often price data will be refreshed in case price stay flat\\n        uint24 heartbeat;\\n        /// @dev timestamp: price time, at this time validators run consensus\\n        uint32 timestamp;\\n        /// @dev price\\n        uint128 price;\\n    }\\n\\n    struct Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    /// @dev method for submitting consensus data\\n    /// @param _priceKeys array of keys for `_priceDatas`\\n    /// @param _priceDatas PriceData signed by validators\\n    /// @param _signatures validators signatures\\n    function update(\\n        bytes32[] calldata _priceKeys,\\n        PriceData[] calldata _priceDatas,\\n        Signature[] calldata _signatures\\n    ) external;\\n\\n    /// @dev it will return array of price datas for provided `_keys`\\n    /// In case ony of feed does not exist, fallback call will be executed for that feed.\\n    /// @notice If data for any key not exists, function will revert. Use `getManyPriceDataRaw` method if you don't\\n    /// want revert.\\n    /// @param _keys array of feed keys\\n    /// @return data PriceData array\\n    function getManyPriceData(bytes32[] calldata _keys) external view returns (PriceData[] memory data);\\n\\n    /// @dev same as getManyPriceData() but does not revert on empty data.\\n    /// @notice This method does no revert if some data does not exists.\\n    /// Check `data.timestamp` to see if price exist, if it is 0, then it does not exist.\\n    function getManyPriceDataRaw(bytes32[] calldata _keys) external view returns (PriceData[] memory data);\\n\\n    /// @dev this is main endpoint for reading feeds.\\n    /// In case timestamp is empty (that means there is no data), contract will revert.\\n    /// If you do not need whole data from `PriceData` struct, you can save some gas by using other view methods that\\n    /// returns just what you need.\\n    /// @notice method will revert if data for `_key` not exists.\\n    /// @param _key hash of feed name\\n    /// @return data full PriceData struct\\n    function getPriceData(bytes32 _key) external view returns (PriceData memory data);\\n\\n    /// @notice reader for mapping\\n    /// @param _key hash of feed name\\n    /// @return data full PriceData struct\\n    function prices(bytes32 _key) external view returns (PriceData memory data);\\n\\n    /// @notice method will revert if data for `_key` not exists.\\n    /// @param _key hash of feed name\\n    /// @return price\\n    function getPrice(bytes32 _key) external view returns (uint128 price);\\n\\n    /// @notice method will revert if data for `_key` not exists.\\n    /// @param _key hash of feed name\\n    /// @return price\\n    /// @return timestamp\\n    function getPriceTimestamp(bytes32 _key) external view returns (uint128 price, uint32 timestamp);\\n\\n    /// @notice method will revert if data for `_key` not exists.\\n    /// @param _key hash of feed name\\n    /// @return price\\n    /// @return timestamp\\n    /// @return heartbeat\\n    function getPriceTimestampHeartbeat(bytes32 _key)\\n        external\\n        view\\n        returns (uint128 price, uint32 timestamp, uint24 heartbeat);\\n\\n    /// @dev This method should be used only for Layer2 as it is more gas consuming than others views.\\n    /// @notice It does not revert on empty data.\\n    /// @param _name string feed name\\n    /// @return data PriceData\\n    function getPriceDataByName(string calldata _name) external view returns (PriceData memory data);\\n\\n    /// @dev decimals for prices stored in this contract\\n    function DECIMALS() external view returns (uint8); // solhint-disable-line func-name-mixedcase\\n}\\n\"\r\n    },\r\n    \"contracts/onChainFeeds/UmbrellaFeeds.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../interfaces/IUmbrellaFeeds.sol\\\";\\nimport \\\"../interfaces/IRegistry.sol\\\";\\nimport \\\"../interfaces/IStakingBankStatic.sol\\\";\\n\\n/// @dev Main contract for all on-chain data.\\n/// Check `UmbrellaFeedsReader` to see how to integrate.\\n///\\n/// @notice This contract can be destroyed and replaced with new one (with new address).\\n/// For best gas efficiency you should pick one of two ways of integration:\\n/// 1. make `UmbrellaFeeds` immutable and use fallback in case of selfdestruct. After new deployment, it is recommended\\n/// to update address to avoid fallback and reduce gas cost to minimum. In long run this is most efficient solution,\\n/// better than any proxy.\\n/// 2. always check newest `UmbrellaFeeds` via `Regostry` and fallback will not be needed.\\ncontract UmbrellaFeeds is IUmbrellaFeeds {\\n    bytes constant public ETH_PREFIX = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n    string constant public NAME = \\\"UmbrellaFeeds\\\";\\n\\n    /// @dev deployment time, used for protect for unintentional destroy\\n    uint256 public immutable DEPLOYED_AT;  // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev Registry contract where list of all addresses is stored. Fallback feature uses this registry to\\n    /// resolve newest `UmbrellaFeeds` address\\n    IRegistry public immutable REGISTRY;  // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev StakingBank contract where list of validators is stored\\n    IStakingBankStatic public immutable STAKING_BANK;  // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev minimal number of signatures required for accepting price submission (PoA)\\n    uint16 public immutable REQUIRED_SIGNATURES; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev decimals for prices stored in this contract\\n    uint8 public immutable DECIMALS;  // solhint-disable-line var-name-mixedcase\\n\\n    /// @notice map of all prices stored in this contract, key for map is hash of feed name\\n    /// eg for \\\"ETH-USD\\\" feed, key will be hash(\\\"ETH-USD\\\")\\n    mapping (bytes32 => PriceData) private _prices;\\n\\n    error ArraysDataDoNotMatch();\\n    error FeedNotExist();\\n    error NotEnoughSignatures();\\n    error InvalidSigner();\\n    error InvalidRequiredSignatures();\\n    error SignaturesOutOfOrder();\\n    error ECDSAInvalidSignatureS();\\n    error ECDSAInvalidSignatureV();\\n    error OldData();\\n    error ContractInUse();\\n    error ContractNotInitialised();\\n\\n    /// @param _contractRegistry Registry address\\n    /// @param _requiredSignatures number of required signatures for accepting consensus submission\\n    /// @param _decimals decimals for prices stored in this contract\\n    constructor(\\n        IRegistry _contractRegistry,\\n        uint16 _requiredSignatures,\\n        uint8 _decimals\\n    ) {\\n        if (_requiredSignatures == 0) revert InvalidRequiredSignatures();\\n\\n        REGISTRY = _contractRegistry;\\n        REQUIRED_SIGNATURES = _requiredSignatures;\\n        STAKING_BANK = IStakingBankStatic(_contractRegistry.requireAndGetAddress(\\\"StakingBank\\\"));\\n        DECIMALS = _decimals;\\n        DEPLOYED_AT = block.timestamp;\\n    }\\n\\n    /// @dev destroys old contract\\n    /// there is sanity check that prevents abuse of destroy method\\n    /// @param _name string feed key to verify, that contract was initialised\\n    function destroy(string calldata _name) external {\\n        if (REGISTRY.getAddressByString(NAME) == address(this)) revert ContractInUse();\\n\\n        if (_prices[keccak256(abi.encodePacked(_name))].timestamp == 0 && DEPLOYED_AT + 3 days > block.timestamp) {\\n            revert ContractNotInitialised();\\n        }\\n\\n        selfdestruct(payable(msg.sender));\\n    }\\n\\n    /// @inheritdoc IUmbrellaFeeds\\n    function update(\\n        bytes32[] calldata _priceKeys,\\n        PriceData[] calldata _priceDatas,\\n        Signature[] calldata _signatures\\n    ) external {\\n        if (_priceKeys.length != _priceDatas.length) revert ArraysDataDoNotMatch();\\n\\n        bytes32 priceDataHash = keccak256(abi.encode(getChainId(), address(this), _priceKeys, _priceDatas));\\n        verifySignatures(priceDataHash, _signatures);\\n\\n        uint256 i;\\n\\n        while (i < _priceDatas.length) {\\n            bytes32 priceKey = _priceKeys[i];\\n\\n            // we do not allow for older prices\\n            // at the same time it prevents from reusing signatures\\n            if (_prices[priceKey].timestamp >= _priceDatas[i].timestamp) revert OldData();\\n\\n            _prices[priceKey] = _priceDatas[i];\\n\\n            // atm there is no need for events, so in order to save gas, we do not emit any\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    /// @inheritdoc IUmbrellaFeeds\\n    function getManyPriceData(bytes32[] calldata _keys) external view returns (PriceData[] memory data) {\\n        data = new PriceData[](_keys.length);\\n\\n        for (uint256 i; i < _keys.length;) {\\n            data[i] = _prices[_keys[i]];\\n            if (data[i].timestamp == 0) revert FeedNotExist();\\n\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    /// @inheritdoc IUmbrellaFeeds\\n    function getManyPriceDataRaw(bytes32[] calldata _keys) external view returns (PriceData[] memory data) {\\n        data = new PriceData[](_keys.length);\\n\\n        for (uint256 i; i < _keys.length;) {\\n            data[i] = _prices[_keys[i]];\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    /// @inheritdoc IUmbrellaFeeds\\n    function prices(bytes32 _key) external view returns (PriceData memory data) {\\n        data = _prices[_key];\\n    }\\n\\n    /// @inheritdoc IUmbrellaFeeds\\n    function getPriceData(bytes32 _key) external view returns (PriceData memory data) {\\n        data = _prices[_key];\\n        if (data.timestamp == 0) revert FeedNotExist();\\n    }\\n\\n    /// @inheritdoc IUmbrellaFeeds\\n    function getPrice(bytes32 _key) external view returns (uint128 price) {\\n        PriceData memory data = _prices[_key];\\n        if (data.timestamp == 0) revert FeedNotExist();\\n\\n        return data.price;\\n    }\\n\\n    /// @inheritdoc IUmbrellaFeeds\\n    function getPriceTimestamp(bytes32 _key) external view returns (uint128 price, uint32 timestamp) {\\n        PriceData memory data = _prices[_key];\\n        if (data.timestamp == 0) revert FeedNotExist();\\n\\n        return (data.price, data.timestamp);\\n    }\\n\\n    function getPriceTimestampHeartbeat(bytes32 _key)\\n        external\\n        view\\n        returns (uint128 price, uint32 timestamp, uint24 heartbeat)\\n    {\\n        PriceData memory data = _prices[_key];\\n        if (data.timestamp == 0) revert FeedNotExist();\\n\\n        return (data.price, data.timestamp, data.heartbeat);\\n    }\\n\\n    /// @inheritdoc IUmbrellaFeeds\\n    function getPriceDataByName(string calldata _name) external view returns (PriceData memory data) {\\n        bytes32 key = keccak256(abi.encodePacked(_name));\\n        data = _prices[key];\\n    }\\n\\n    /// @dev helper method for QA purposes\\n    /// @return hash of data that are signed by validators (keys and priced data)\\n    function hashData(bytes32[] calldata _priceKeys, PriceData[] calldata _priceDatas)\\n        external\\n        view\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encode(getChainId(), address(this), _priceKeys, _priceDatas));\\n    }\\n\\n    /// @param _hash hash of signed data\\n    /// @param _signatures array of validators signatures\\n    function verifySignatures(bytes32 _hash, Signature[] calldata _signatures) public view {\\n        address prevSigner = address(0x0);\\n\\n        if (_signatures.length < REQUIRED_SIGNATURES) revert NotEnoughSignatures();\\n\\n        address[] memory validators = new address[](REQUIRED_SIGNATURES);\\n\\n        // to save gas we check only required number of signatures\\n        // case, where you can have part of signatures invalid but still enough valid in total is not supported\\n        for (uint256 i; i < REQUIRED_SIGNATURES;) {\\n            (uint8 v, bytes32 r, bytes32 s) = (_signatures[i].v, _signatures[i].r, _signatures[i].s);\\n\\n            if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n                revert ECDSAInvalidSignatureS();\\n            }\\n\\n            if (uint8(v) != 27 && uint8(v) != 28) revert ECDSAInvalidSignatureV();\\n\\n            address signer = recoverSigner(_hash, v, r, s);\\n            if (prevSigner >= signer) revert SignaturesOutOfOrder();\\n\\n            // because we check only required number of signatures, any invalid one will cause revert\\n            prevSigner = signer;\\n            validators[i] = signer;\\n\\n            unchecked { i++; }\\n        }\\n\\n        // bulk verification can optimise gas when we have 5 or more validators\\n        if (!STAKING_BANK.verifyValidators(validators)) revert InvalidSigner();\\n    }\\n\\n    function getChainId() public view returns (uint256 id) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    /// @param _hash hashed of data\\n    /// @param _v part of signature\\n    /// @param _r part of signature\\n    /// @param _s part of signature\\n    /// @return signer address\\n    function recoverSigner(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {\\n        bytes32 hash = keccak256(abi.encodePacked(ETH_PREFIX, _hash));\\n        return ecrecover(hash, _v, _r, _s);\\n    }\\n\\n    /// @dev to follow Registrable interface\\n    function getName() public pure returns (bytes32) {\\n        return \\\"UmbrellaFeeds\\\";\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_requiredSignatures\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArraysDataDoNotMatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractInUse\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractNotInitialised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignatureV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeedNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRequiredSignatures\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughSignatures\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OldData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignaturesOutOfOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPLOYED_AT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_PREFIX\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REGISTRY\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUIRED_SIGNATURES\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING_BANK\",\"outputs\":[{\"internalType\":\"contract IStakingBankStatic\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_keys\",\"type\":\"bytes32[]\"}],\"name\":\"getManyPriceData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"data\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"heartbeat\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"internalType\":\"struct IUmbrellaFeeds.PriceData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_keys\",\"type\":\"bytes32[]\"}],\"name\":\"getManyPriceDataRaw\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"data\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"heartbeat\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"internalType\":\"struct IUmbrellaFeeds.PriceData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getPriceData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"data\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"heartbeat\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"internalType\":\"struct IUmbrellaFeeds.PriceData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getPriceDataByName\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"data\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"heartbeat\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"internalType\":\"struct IUmbrellaFeeds.PriceData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getPriceTimestamp\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getPriceTimestampHeartbeat\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"heartbeat\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_priceKeys\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"data\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"heartbeat\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"internalType\":\"struct IUmbrellaFeeds.PriceData[]\",\"name\":\"_priceDatas\",\"type\":\"tuple[]\"}],\"name\":\"hashData\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"prices\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"data\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"heartbeat\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"internalType\":\"struct IUmbrellaFeeds.PriceData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_priceKeys\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"data\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"heartbeat\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"internalType\":\"struct IUmbrellaFeeds.PriceData[]\",\"name\":\"_priceDatas\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IUmbrellaFeeds.Signature[]\",\"name\":\"_signatures\",\"type\":\"tuple[]\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IUmbrellaFeeds.Signature[]\",\"name\":\"_signatures\",\"type\":\"tuple[]\"}],\"name\":\"verifySignatures\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UmbrellaFeeds", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000455acbbc2c15c086978083968a69b2e7e4d38d3400000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000008", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}