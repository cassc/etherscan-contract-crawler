{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/assetToken/AssetToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"../interfaces/IAssetTokenData.sol\\\";\\n\\n/// @author Swarm Markets\\n/// @title AssetToken\\n/// @notice Main Asset Token Contract\\ncontract AssetToken is ERC20, ReentrancyGuard {\\n    /// @dev Used to check access to functions as a kindof modifiers\\n    uint256 private constant ACTIVE_CONTRACT = 1 << 0;\\n    uint256 private constant UNFROZEN_CONTRACT = 1 << 1;\\n    uint256 private constant ONLY_ISSUER = 1 << 2;\\n    uint256 private constant ONLY_ISSUER_OR_GUARDIAN = 1 << 3;\\n    uint256 private constant ONLY_ISSUER_OR_AGENT = 1 << 4;\\n\\n    uint8 private immutable _decimals;\\n\\n    /// @dev This is a WAD on DSMATH representing 1\\n    uint256 public constant DECIMALS = 10 ** 18;\\n    /// @dev This is a proportion of 1 representing 100%, equal to a WAD\\n    uint256 public constant HUNDRED_PERCENT = 10 ** 18;\\n\\n    /// @notice AssetTokenData Address\\n    address public assetTokenDataAddress;\\n\\n    /// @notice Structure to hold the Mint Requests\\n    struct MintRequest {\\n        address destination;\\n        uint256 amount;\\n        string referenceTo;\\n        bool completed;\\n    }\\n    /// @notice Mint Requests mapping and last ID\\n    mapping(uint256 => MintRequest) public mintRequests;\\n    uint256 public mintRequestID;\\n\\n    /// @notice Structure to hold the Redemption Requests\\n    struct RedemptionRequest {\\n        address sender;\\n        string receipt;\\n        uint256 assetTokenAmount;\\n        uint256 underlyingAssetAmount;\\n        bool completed;\\n        bool fromStake;\\n        string approveTxID;\\n        address canceledBy;\\n    }\\n    /// @notice Redemption Requests mapping and last ID\\n    mapping(uint256 => RedemptionRequest) public redemptionRequests;\\n    uint256 public redemptionRequestID;\\n\\n    /// @notice stakedRedemptionRequests is map from requester to request ID\\n    /// @notice exists to detect that sender already has request from stake function\\n    mapping(address => uint256) public stakedRedemptionRequests;\\n\\n    /// @notice mapping to hold each user safeguardStake amoun\\n    mapping(address => uint256) public safeguardStakes;\\n\\n    /// @notice sum of the total stakes amounts\\n    uint256 public totalStakes;\\n\\n    /// @notice the percetage (on 18 digits)\\n    /// @notice if this gets overgrown the contract change state\\n    uint256 public statePercent;\\n\\n    /// @notice know your asset string\\n    string public kya;\\n\\n    /// @notice minimum Redemption Amount (in Asset token value)\\n    uint256 public minimumRedemptionAmount;\\n\\n    /// @notice Emitted when the address of the asset token data is set\\n    event AssetTokenDataChanged(address indexed _oldAddress, address indexed _newAddress, address indexed _caller);\\n\\n    /// @notice Emitted when kya string is set\\n    event KyaChanged(string _kya, address indexed _caller);\\n\\n    /// @notice Emitted when minimumRedemptionAmount is set\\n    event MinimumRedemptionAmountChanged(uint256 _newAmount, address indexed _caller);\\n\\n    /// @notice Emitted when a mint request is requested\\n    event MintRequested(\\n        uint256 indexed _mintRequestID,\\n        address indexed _destination,\\n        uint256 _amount,\\n        address indexed _caller\\n    );\\n\\n    /// @notice Emitted when a mint request gets approved\\n    event MintApproved(\\n        uint256 indexed _mintRequestID,\\n        address indexed _destination,\\n        uint256 _amountMinted,\\n        address indexed _caller\\n    );\\n\\n    /// @notice Emitted when a redemption request is requested\\n    event RedemptionRequested(\\n        uint256 indexed _redemptionRequestID,\\n        uint256 _assetTokenAmount,\\n        uint256 _underlyingAssetAmount,\\n        bool _fromStake,\\n        address indexed _caller\\n    );\\n\\n    /// @notice Emitted when a redemption request is cancelled\\n    event RedemptionCanceled(\\n        uint256 indexed _redemptionRequestID,\\n        address indexed _requestReceiver,\\n        string _motive,\\n        address indexed _caller\\n    );\\n\\n    /// @notice Emitted when a redemption request is approved\\n    event RedemptionApproved(\\n        uint256 indexed _redemptionRequestID,\\n        uint256 _assetTokenAmount,\\n        uint256 _underlyingAssetAmount,\\n        address indexed _requestReceiver,\\n        address indexed _caller\\n    );\\n\\n    /// @notice Emitted when the token gets bruned\\n    event TokenBurned(uint256 _amount, address indexed _caller);\\n\\n    /// @notice Emitted when the contract change to safeguard\\n    event SafeguardUnstaked(uint256 _amount, address indexed _caller);\\n\\n    /// @notice Constructor: sets the state variables and provide proper checks to deploy\\n    /// @param _assetTokenData the asset token data contract address\\n    /// @param _statePercent the state percent to check the safeguard convertion\\n    /// @param _kya verification link\\n    /// @param _minimumRedemptionAmount less than this value is not allowed\\n    /// @param _name of the token\\n    /// @param _symbol of the token\\n    constructor(\\n        address _assetTokenData,\\n        uint256 _statePercent,\\n        string memory _kya,\\n        uint256 _minimumRedemptionAmount,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol) {\\n        require(_assetTokenData != address(0), \\\"AssetToken: assetTokenData is address 0\\\");\\n        require(_statePercent > 0, \\\"AssetToken: statePercent must be > 0\\\");\\n        require(_statePercent <= HUNDRED_PERCENT, \\\"AssetToken: statePercent <= HUNDRED_PERCENT\\\");\\n        require(bytes(_kya).length > 3, \\\"AssetToken: incorrect kya passed\\\");\\n\\n        // IT IS THE WAD EQUIVALENT USED IN DSMATH\\n        _decimals = 18;\\n        assetTokenDataAddress = _assetTokenData;\\n        statePercent = _statePercent;\\n        kya = _kya;\\n        minimumRedemptionAmount = _minimumRedemptionAmount;\\n    }\\n\\n    /// @notice kindof modifier to frist-check data on functions\\n    /// @param modifiers an array containing the modifiers to check (the enums)\\n    function checkAccessToFunction(uint256 modifiers) internal view {\\n        bool found;\\n        IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n        if (modifiers & ACTIVE_CONTRACT != 0) {\\n            assetTknDtaContract.onlyActiveContract(address(this));\\n            found = true;\\n        }\\n        if (modifiers & UNFROZEN_CONTRACT != 0) {\\n            assetTknDtaContract.onlyUnfrozenContract(address(this));\\n            found = true;\\n        }\\n        if (modifiers & ONLY_ISSUER != 0) {\\n            assetTknDtaContract.onlyIssuer(address(this), _msgSender());\\n            found = true;\\n        }\\n        if (modifiers & ONLY_ISSUER_OR_GUARDIAN != 0) {\\n            assetTknDtaContract.onlyIssuerOrGuardian(address(this), _msgSender());\\n            found = true;\\n        }\\n        if (modifiers & ONLY_ISSUER_OR_AGENT != 0) {\\n            assetTknDtaContract.onlyIssuerOrAgent(address(this), _msgSender());\\n            found = true;\\n        }\\n        require(found, \\\"AssetToken: access not found\\\");\\n    }\\n\\n    /// @notice Hook to be executed before every transfer and mint\\n    /// @notice This overrides the ERC20 defined function\\n    /// @param _from the sender\\n    /// @param _to the receipent\\n    /// @param _amount the amount (it is not used  but needed to be defined to override)\\n    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal virtual override {\\n        //  on safeguard the only available transfers are from allowed addresses and guardian\\n        //  or from an authorized user to this contract\\n        //  address(this) is added as the _from for approving redemption (burn)\\n        //  address(this) is added as the _to for requesting redemption (transfer to this contract)\\n        //  address(0) is added to the condition to allow burn on safeguard\\n        checkAccessToFunction(UNFROZEN_CONTRACT);\\n        IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n\\n        if (assetTknDtaContract.isOnSafeguard(address(this))) {\\n            /// @dev  State is SAFEGUARD\\n            if (\\n                // receiver is NOT this contract AND sender is NOT this contract AND sender is NOT guardian\\n                _to != address(this) &&\\n                _from != address(this) &&\\n                _from != assetTknDtaContract.getGuardian(address(this))\\n            ) {\\n                require(\\n                    assetTknDtaContract.isAllowedTransferOnSafeguard(address(this), _from),\\n                    \\\"AssetToken: beforeTokenTransfer: not allowed (onSafeguard)\\\"\\n                );\\n            } else {\\n                require(\\n                    assetTknDtaContract.mustBeAuthorizedHolders(address(this), _from, _to, _amount),\\n                    \\\"AssetToken: beforeTokenTransfer: not authorized (onActive)\\\"\\n                );\\n            }\\n        } else {\\n            /// @dev State is ACTIVE\\n            // this is mint or transfer\\n            // mint signature: ==> _beforeTokenTransfer(address(0), account, amount);\\n            // burn signature: ==> _beforeTokenTransfer(account, address(0), amount);\\n            require(\\n                assetTknDtaContract.mustBeAuthorizedHolders(address(this), _from, _to, _amount),\\n                \\\"AssetToken: beforeTokenTransfer: not authorized (onActive)\\\"\\n            );\\n        }\\n\\n        super._beforeTokenTransfer(_from, _to, _amount);\\n    }\\n\\n    /// @notice Sets Asset Token Data Address\\n    /// @param _newAddress value to be set\\n    function setAssetTokenData(address _newAddress) external {\\n        checkAccessToFunction(UNFROZEN_CONTRACT | ONLY_ISSUER_OR_GUARDIAN);\\n        require(_newAddress != address(0), \\\"AssetToken: newAddress is address 0\\\");\\n        emit AssetTokenDataChanged(assetTokenDataAddress, _newAddress, _msgSender());\\n        assetTokenDataAddress = _newAddress;\\n    }\\n\\n    /// @notice Sets the verification link\\n    /// @param _kya value to be set\\n    function setKya(string calldata _kya) external {\\n        checkAccessToFunction(ONLY_ISSUER_OR_GUARDIAN | UNFROZEN_CONTRACT);\\n        require(bytes(_kya).length > 3, \\\"AssetToken: incorrect kya passed\\\");\\n        emit KyaChanged(_kya, _msgSender());\\n        kya = _kya;\\n    }\\n\\n    /// @notice Sets the _minimumRedemptionAmount\\n    /// @param _minimumRedemptionAmount value to be set\\n    function setMinimumRedemptionAmount(uint256 _minimumRedemptionAmount) external {\\n        checkAccessToFunction(ONLY_ISSUER_OR_GUARDIAN | UNFROZEN_CONTRACT);\\n        emit MinimumRedemptionAmountChanged(_minimumRedemptionAmount, _msgSender());\\n        minimumRedemptionAmount = _minimumRedemptionAmount;\\n    }\\n\\n    /// @notice Freeze the contract\\n    function freezeContract() external {\\n        checkAccessToFunction(ONLY_ISSUER_OR_GUARDIAN);\\n        IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n        require(!assetTknDtaContract.isContractFrozen(address(this)), \\\"AssetToken: contract is frozen\\\");\\n        require(assetTknDtaContract.freezeContract(address(this)), \\\"AssetToken: freezing failed\\\");\\n    }\\n\\n    /// @notice unfreeze the contract\\n    function unfreezeContract() external {\\n        checkAccessToFunction(ONLY_ISSUER_OR_GUARDIAN);\\n        IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n        require(assetTknDtaContract.isContractFrozen(address(this)), \\\"AssetToken: contract is not frozen\\\");\\n        require(assetTknDtaContract.unfreezeContract(address(this)), \\\"AssetToken: unfreezing failed\\\");\\n    }\\n\\n    /// @notice Requests a mint to the caller\\n    /// @param _amount the amount to mint in asset token format\\n    /// @return uint256 request ID to be referenced in the mapping\\n    function requestMint(uint256 _amount) external returns (uint256) {\\n        return _requestMint(_amount, _msgSender());\\n    }\\n\\n    /// @notice Requests a mint to the _destination address\\n    /// @param _amount the amount to mint in asset token format\\n    /// @param _destination the receiver of the tokens\\n    /// @return uint256 request ID to be referenced in the mapping\\n    function requestMint(uint256 _amount, address _destination) external returns (uint256) {\\n        return _requestMint(_amount, _destination);\\n    }\\n\\n    /// @notice Performs the Mint Request to the destination address\\n    /// @param _amount entered in the external functions\\n    /// @param _destination the receiver of the tokens\\n    /// @return uint256 request ID to be referenced in the mapping\\n    function _requestMint(uint256 _amount, address _destination) private returns (uint256) {\\n        checkAccessToFunction(ACTIVE_CONTRACT | UNFROZEN_CONTRACT | ONLY_ISSUER_OR_AGENT);\\n        require(_amount > 0, \\\"AssetToken: amount must be > 0\\\");\\n\\n        mintRequestID++;\\n        emit MintRequested(mintRequestID, _destination, _amount, _msgSender());\\n\\n        mintRequests[mintRequestID] = MintRequest(_destination, _amount, \\\"\\\", false);\\n\\n        IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n        if (_msgSender() == assetTknDtaContract.getIssuer(address(this))) {\\n            approveMint(mintRequestID, \\\"IssuerMint\\\");\\n        }\\n        return mintRequestID;\\n    }\\n\\n    /// @notice Approves the Mint Request\\n    /// @param _mintRequestID the ID to be referenced in the mapping\\n    /// @param _referenceTo reference comment for the issuer\\n    function approveMint(uint256 _mintRequestID, string memory _referenceTo) public nonReentrant {\\n        checkAccessToFunction(ACTIVE_CONTRACT | ONLY_ISSUER);\\n        require(mintRequests[_mintRequestID].destination != address(0), \\\"AssetToken: requestID does not exist\\\");\\n        require(!mintRequests[_mintRequestID].completed, \\\"AssetToken: request is completed\\\");\\n\\n        mintRequests[_mintRequestID].completed = true;\\n        mintRequests[_mintRequestID].referenceTo = _referenceTo;\\n\\n        IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n        assetTknDtaContract.update(address(this));\\n        uint256 currentRate = assetTknDtaContract.getCurrentRate(address(this));\\n\\n        uint256 amountToMint = (mintRequests[_mintRequestID].amount * (DECIMALS)) / (currentRate);\\n        emit MintApproved(_mintRequestID, mintRequests[_mintRequestID].destination, amountToMint, _msgSender());\\n\\n        _mint(mintRequests[_mintRequestID].destination, amountToMint);\\n    }\\n\\n    /// @notice Requests an amount of assetToken Redemption\\n    /// @param _assetTokenAmount the amount of Asset Token to be redeemed\\n    /// @param _destination the off chain hash of the redemption transaction\\n    /// @return uint256 redemptionRequest ID to be referenced in the mapping\\n    function requestRedemption(\\n        uint256 _assetTokenAmount,\\n        string memory _destination\\n    ) external nonReentrant returns (uint256) {\\n        require(_assetTokenAmount > 0, \\\"AssetToken: assetTokenAmount must be > 0\\\");\\n        require(balanceOf(_msgSender()) >= _assetTokenAmount, \\\"AssetToken: caller has insufficient funds\\\");\\n\\n        IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n        address issuer = assetTknDtaContract.getIssuer(address(this));\\n        address guardian = assetTknDtaContract.getGuardian(address(this));\\n        bool isOnSafeguard = assetTknDtaContract.isOnSafeguard(address(this));\\n\\n        if ((!isOnSafeguard && _msgSender() != issuer) || (isOnSafeguard && _msgSender() != guardian)) {\\n            require(\\n                _assetTokenAmount >= minimumRedemptionAmount,\\n                \\\"AssetToken: minimumRedemptionAmount not reached yet\\\"\\n            );\\n        }\\n\\n        assetTknDtaContract.update(address(this));\\n        uint256 currentRate = assetTknDtaContract.getCurrentRate(address(this));\\n        uint256 underlyingAssetAmount = (_assetTokenAmount * (currentRate)) / (DECIMALS);\\n\\n        redemptionRequestID++;\\n        emit RedemptionRequested(redemptionRequestID, _assetTokenAmount, underlyingAssetAmount, false, _msgSender());\\n\\n        redemptionRequests[redemptionRequestID] = RedemptionRequest(\\n            _msgSender(),\\n            _destination,\\n            _assetTokenAmount,\\n            underlyingAssetAmount,\\n            false,\\n            false,\\n            \\\"\\\",\\n            address(0)\\n        );\\n\\n        /// @dev make the transfer to the contract for the amount requested (18 digits)\\n        _transfer(_msgSender(), address(this), _assetTokenAmount);\\n\\n        /// @dev approve instantly when called by issuer or guardian\\n        if ((!isOnSafeguard && _msgSender() == issuer) || (isOnSafeguard && _msgSender() == guardian)) {\\n            approveRedemption(redemptionRequestID, \\\"AutomaticRedemptionApproval\\\");\\n        }\\n\\n        return redemptionRequestID;\\n    }\\n\\n    /// @notice Approves the Redemption Requests\\n    /// @param _redemptionRequestID redemption request ID to be referenced in the mapping\\n    /// @param _motive motive of the cancelation\\n    function cancelRedemptionRequest(uint256 _redemptionRequestID, string memory _motive) external {\\n        require(\\n            redemptionRequests[_redemptionRequestID].sender != address(0),\\n            \\\"AssetToken: redemptionRequestID does not exist\\\"\\n        );\\n        require(\\n            redemptionRequests[_redemptionRequestID].canceledBy == address(0),\\n            \\\"AssetToken: redemption has been cancelled\\\"\\n        );\\n        require(!redemptionRequests[_redemptionRequestID].completed, \\\"AssetToken: redemption already completed\\\");\\n        require(!redemptionRequests[_redemptionRequestID].fromStake, \\\"AssetToken: staked request - unstake to redeem\\\");\\n        IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n        if (_msgSender() != redemptionRequests[_redemptionRequestID].sender) {\\n            // not owner of the redemption so guardian or issuer should be the caller\\n            assetTknDtaContract.onlyIssuerOrGuardian(address(this), _msgSender());\\n        }\\n\\n        uint256 refundAmount = redemptionRequests[_redemptionRequestID].assetTokenAmount;\\n        emit RedemptionCanceled(\\n            _redemptionRequestID,\\n            redemptionRequests[_redemptionRequestID].sender,\\n            _motive,\\n            _msgSender()\\n        );\\n\\n        redemptionRequests[_redemptionRequestID].assetTokenAmount = 0;\\n        redemptionRequests[_redemptionRequestID].underlyingAssetAmount = 0;\\n        redemptionRequests[_redemptionRequestID].canceledBy = _msgSender();\\n\\n        _transfer(address(this), redemptionRequests[_redemptionRequestID].sender, refundAmount);\\n    }\\n\\n    /// @notice Approves the Redemption Requests\\n    /// @param _redemptionRequestID redemption request ID to be referenced in the mapping\\n    /// @param _approveTxID the transaction ID\\n    function approveRedemption(uint256 _redemptionRequestID, string memory _approveTxID) public {\\n        checkAccessToFunction(ONLY_ISSUER_OR_GUARDIAN);\\n        require(\\n            redemptionRequests[_redemptionRequestID].canceledBy == address(0),\\n            \\\"AssetToken: redemptionRequestID has been cancelled\\\"\\n        );\\n        require(\\n            redemptionRequests[_redemptionRequestID].sender != address(0),\\n            \\\"AssetToken: redemptionRequestID is incorrect\\\"\\n        );\\n        require(!redemptionRequests[_redemptionRequestID].completed, \\\"AssetToken: redemptionRequestID completed\\\");\\n\\n        if (redemptionRequests[_redemptionRequestID].fromStake) {\\n            IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n            require(\\n                assetTknDtaContract.isOnSafeguard(address(this)),\\n                \\\"AssetToken: contract is active (not onSafeguard)\\\"\\n            );\\n        }\\n\\n        emit RedemptionApproved(\\n            _redemptionRequestID,\\n            redemptionRequests[_redemptionRequestID].assetTokenAmount,\\n            redemptionRequests[_redemptionRequestID].underlyingAssetAmount,\\n            redemptionRequests[_redemptionRequestID].sender,\\n            _msgSender()\\n        );\\n        redemptionRequests[_redemptionRequestID].completed = true;\\n        redemptionRequests[_redemptionRequestID].approveTxID = _approveTxID;\\n\\n        // burn tokens from the contract\\n        _burn(address(this), redemptionRequests[_redemptionRequestID].assetTokenAmount);\\n    }\\n\\n    /// @notice Burns a certain amount of tokens\\n    /// @param _amount qty of assetTokens to be burned\\n    function burn(uint256 _amount) external {\\n        emit TokenBurned(_amount, _msgSender());\\n        _burn(_msgSender(), _amount);\\n    }\\n\\n    /// @notice Performs the Safeguard Stake\\n    /// @param _amount the assetToken amount to be staked\\n    /// @param _receipt the off chain hash of the redemption transaction\\n    function safeguardStake(uint256 _amount, string calldata _receipt) external nonReentrant {\\n        checkAccessToFunction(ACTIVE_CONTRACT);\\n        require(balanceOf(_msgSender()) >= _amount, \\\"AssetToken: caller has insufficient funds\\\");\\n\\n        safeguardStakes[_msgSender()] = safeguardStakes[_msgSender()] + _amount;\\n        totalStakes = totalStakes + (_amount);\\n        uint256 stakedPercent = (totalStakes * (HUNDRED_PERCENT)) / (totalSupply());\\n\\n        IAssetTokenData assetTknDtaContract = IAssetTokenData(assetTokenDataAddress);\\n        if (stakedPercent >= statePercent) {\\n            require(assetTknDtaContract.setContractToSafeguard(address(this)), \\\"AssetToken: error on safeguard change\\\");\\n            /// @dev now the contract is on safeguard\\n        }\\n\\n        uint256 _requestID = stakedRedemptionRequests[_msgSender()];\\n        if (_requestID == 0) {\\n            /// @dev zero means that it's new request\\n            redemptionRequestID++;\\n            redemptionRequests[redemptionRequestID] = RedemptionRequest(\\n                _msgSender(),\\n                _receipt,\\n                _amount,\\n                0,\\n                false,\\n                true,\\n                \\\"\\\",\\n                address(0)\\n            );\\n\\n            stakedRedemptionRequests[_msgSender()] = redemptionRequestID;\\n            _requestID = redemptionRequestID;\\n        } else {\\n            /// @dev non zero means the request already exist and need only add amount\\n            redemptionRequests[_requestID].assetTokenAmount =\\n                redemptionRequests[_requestID].assetTokenAmount +\\n                (_amount);\\n        }\\n\\n        emit RedemptionRequested(\\n            _requestID,\\n            redemptionRequests[_requestID].assetTokenAmount,\\n            redemptionRequests[_requestID].underlyingAssetAmount,\\n            true,\\n            _msgSender()\\n        );\\n        _transfer(_msgSender(), address(this), _amount);\\n    }\\n\\n    /// @notice Calls to UnStake all the funds\\n    function safeguardUnstake() external {\\n        _safeguardUnstake(safeguardStakes[_msgSender()]);\\n    }\\n\\n    /// @notice Calls to UnStake with a certain amount\\n    /// @param _amount to be unStaked in asset token\\n    function safeguardUnstake(uint256 _amount) external {\\n        _safeguardUnstake(_amount);\\n    }\\n\\n    /// @notice Performs the UnStake with a certain amount\\n    /// @param _amount to be unStaked in asset token\\n    function _safeguardUnstake(uint256 _amount) private {\\n        checkAccessToFunction(ACTIVE_CONTRACT | UNFROZEN_CONTRACT);\\n        require(_amount > 0, \\\"AssetToken: amount must be > 0\\\");\\n        require(safeguardStakes[_msgSender()] >= _amount, \\\"AssetToken: amount exceeds staked\\\");\\n\\n        emit SafeguardUnstaked(_amount, _msgSender());\\n        safeguardStakes[_msgSender()] = safeguardStakes[_msgSender()] - (_amount);\\n        totalStakes = totalStakes - (_amount);\\n\\n        uint256 _requestID = stakedRedemptionRequests[_msgSender()];\\n        redemptionRequests[_requestID].assetTokenAmount = redemptionRequests[_requestID].assetTokenAmount - _amount;\\n\\n        _transfer(address(this), _msgSender(), _amount);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAssetTokenData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @author Swarm Markets\\n/// @title\\n/// @notice\\n/// @notice\\n\\ninterface IAssetTokenData {\\n    function getIssuer(address _tokenAddress) external view returns (address);\\n\\n    function getGuardian(address _tokenAddress) external view returns (address);\\n\\n    function setContractToSafeguard(address _tokenAddress) external returns (bool);\\n\\n    function freezeContract(address _tokenAddress) external returns (bool);\\n\\n    function unfreezeContract(address _tokenAddress) external returns (bool);\\n\\n    function isOnSafeguard(address _tokenAddress) external view returns (bool);\\n\\n    function isContractFrozen(address _tokenAddress) external view returns (bool);\\n\\n    function beforeTokenTransfer(address, address) external;\\n\\n    function onlyStoredToken(address _tokenAddress) external view;\\n\\n    function onlyActiveContract(address _tokenAddress) external view;\\n\\n    function onlyUnfrozenContract(address _tokenAddress) external view;\\n\\n    function onlyIssuer(address _tokenAddress, address _functionCaller) external view;\\n\\n    function onlyIssuerOrGuardian(address _tokenAddress, address _functionCaller) external view;\\n\\n    function onlyIssuerOrAgent(address _tokenAddress, address _functionCaller) external view;\\n\\n    function checkIfTransactionIsAllowed(\\n        address _caller,\\n        address _from,\\n        address _to,\\n        address _tokenAddress,\\n        bytes4 _operation,\\n        bytes calldata _data\\n    ) external view returns (bool);\\n\\n    function mustBeAuthorizedHolders(\\n        address _tokenAddress,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external returns (bool);\\n\\n    function update(address _tokenAddress) external;\\n\\n    function getCurrentRate(address _tokenAddress) external view returns (uint256);\\n\\n    function getInterestRate(address _tokenAddress) external view returns (uint256, bool);\\n\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function isAllowedTransferOnSafeguard(address _tokenAddress, address _account) external view returns (bool);\\n\\n    function registerAssetToken(address _tokenAddress, address _issuer, address _guardian) external returns (bool);\\n\\n    function transferIssuer(address _tokenAddress, address _newIssuer) external;\\n\\n    function setInterestRate(address _tokenAddress, uint256 _interestRate, bool _positiveInterest) external;\\n\\n    function addAgent(address _tokenAddress, address _newAgent) external;\\n\\n    function removeAgent(address _tokenAddress, address _agent) external;\\n\\n    function addMemberToBlacklist(address _tokenAddress, address _account) external;\\n\\n    function removeMemberFromBlacklist(address _tokenAddress, address _account) external;\\n\\n    function allowTransferOnSafeguard(address _tokenAddress, address _account) external;\\n\\n    function preventTransferOnSafeguard(address _tokenAddress, address _account) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetTokenData\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_statePercent\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_kya\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_minimumRedemptionAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"AssetTokenDataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_kya\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"KyaChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"MinimumRedemptionAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_mintRequestID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"MintApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_mintRequestID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"MintRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_redemptionRequestID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_underlyingAssetAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_requestReceiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"RedemptionApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_redemptionRequestID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_requestReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_motive\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"RedemptionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_redemptionRequestID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_underlyingAssetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_fromStake\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"RedemptionRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"SafeguardUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"TokenBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HUNDRED_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintRequestID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_referenceTo\",\"type\":\"string\"}],\"name\":\"approveMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_redemptionRequestID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_approveTxID\",\"type\":\"string\"}],\"name\":\"approveRedemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetTokenDataAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_redemptionRequestID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_motive\",\"type\":\"string\"}],\"name\":\"cancelRedemptionRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freezeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kya\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumRedemptionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintRequestID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintRequests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"referenceTo\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redemptionRequestID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"redemptionRequests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"receipt\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"assetTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"fromStake\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"approveTxID\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"canceledBy\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"requestMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"requestMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_assetTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_destination\",\"type\":\"string\"}],\"name\":\"requestRedemption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_receipt\",\"type\":\"string\"}],\"name\":\"safeguardStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"safeguardStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeguardUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"safeguardUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setAssetTokenData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_kya\",\"type\":\"string\"}],\"name\":\"setKya\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumRedemptionAmount\",\"type\":\"uint256\"}],\"name\":\"setMinimumRedemptionAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedRedemptionRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"statePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreezeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AssetToken", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000044fd5ecb21380db8fbac8c2e0f0ae5f86c0c335b00000000000000000000000000000000000000000000000006f05b59d3b2000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000a697066733a2f2f74626400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a4150504c4520494e432e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044141504c00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}