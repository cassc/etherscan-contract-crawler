{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0-rc.1) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/ProxyFront.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"../interface/ICoreBase.sol\\\";\\nimport \\\"../interface/ILP.sol\\\";\\nimport \\\"../interface/IProxyFront.sol\\\";\\nimport \\\"../interface/IWNative.sol\\\";\\nimport \\\"../libraries/SafeCast.sol\\\";\\nimport \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\n\\n/**\\n * @title  ProxyFront is a proxy contract designed to facilitate interaction with a Liquidity Pool contract.\\n * @notice The contract provides functions for making bets and withdrawing payouts in batches.\\n */\\ncontract ProxyFront is IProxyFront {\\n    using SafeCast for *;\\n\\n    receive() external payable {}\\n\\n    /**\\n     * @notice An alternative version {ILP-withdrawLiquidity} that allows for deposit liquidity to the Liquidity Pool\\n     *         in the native currency of the network.\\n     * @notice To deposit the native currency, you need to send the deposit amount in {msg.value}.\\n     * @param  lp The address of the LP contract to use for withdrawal liquidity.\\n     */\\n    function addLiquidityNative(address lp, bytes calldata data)\\n        external\\n        payable\\n    {\\n        ILP lp_ = ILP(lp);\\n        address token = lp_.token();\\n        IWNative(token).deposit{value: msg.value}();\\n\\n        TransferHelper.safeApprove(token, lp, msg.value);\\n        uint48 depositId = lp_.addLiquidity((msg.value).toUint128(), data);\\n        lp_.transferFrom(address(this), msg.sender, depositId);\\n    }\\n\\n    /**\\n     * @notice The batch version of {ILP-bet} with additional feature to pay for bet in the native currency of the\\n     *         network.\\n     * @notice To pay bets in the native currency, you need to send the total amount of bids in {msg.value}.\\n     * @param  lp The address of the LP contract to use for making bets.\\n     * @param  data An array of input data structures for making bets using the `bet` function of the specified LP.\\n     */\\n    function bet(address lp, BetData[] calldata data) external payable {\\n        uint256 totalAmount;\\n        for (uint256 i = 0; i < data.length; ++i) {\\n            totalAmount += data[i].amount;\\n        }\\n\\n        ILP lp_ = ILP(lp);\\n        address token = lp_.token();\\n        if (msg.value > 0) {\\n            if (msg.value != totalAmount) revert IncorrectValue();\\n            IWNative(token).deposit{value: msg.value}();\\n        } else {\\n            TransferHelper.safeTransferFrom(\\n                token,\\n                msg.sender,\\n                address(this),\\n                totalAmount\\n            );\\n        }\\n\\n        TransferHelper.safeApprove(token, lp, totalAmount);\\n        for (uint256 i = 0; i < data.length; ++i) {\\n            lp_.betFor(\\n                msg.sender,\\n                data[i].core,\\n                data[i].amount,\\n                data[i].expiresAt,\\n                data[i].extraData\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice An alternative version {ILP-withdrawLiquidity} that allows for withdrawal of liquidity in the\\n     *         native currency of the network.\\n     * @param  lp The address of the LP contract to use for withdrawal liquidity.\\n     * @param  depositId The ID of the liquidity deposit.\\n     * @param  percent The % of the liquidity to withdraw, where `FixedMath.ONE` represents 100% of the deposit.\\n     */\\n    function withdrawLiquidityNative(\\n        address lp,\\n        uint48 depositId,\\n        uint40 percent\\n    ) external payable {\\n        ILP lp_ = ILP(lp);\\n        lp_.transferFrom(msg.sender, address(this), depositId);\\n\\n        uint256 withdrawnAmount = lp_.withdrawLiquidity(depositId, percent);\\n        _withdrawNative(lp_.token(), msg.sender, withdrawnAmount);\\n\\n        if (lp_.isDepositExists(depositId))\\n            lp_.transferFrom(address(this), msg.sender, depositId);\\n    }\\n\\n    /**\\n     * @notice The batch version of {ILP-withdrawPayout} with additional feature to withdraw payout in the native\\n     *         currency of the network.\\n     * @param  data An array of input data structures for withdrawing payouts using the `withdrawPayout` function.\\n     */\\n    function withdrawPayouts(WithdrawPayoutData[] calldata data) external {\\n        for (uint256 i = 0; i < data.length; ++i) {\\n            ICoreBase core = ICoreBase(data[i].core);\\n            ILP lp = core.lp();\\n            uint256 payout = lp.withdrawPayout(data[i].core, data[i].tokenId);\\n            if (data[i].isNative && payout > 0) {\\n                address account = core.azuroBet().ownerOf(data[i].tokenId);\\n                address token = lp.token();\\n                //slither-disable-next-line arbitrary-send-erc20\\n                TransferHelper.safeTransferFrom(\\n                    token,\\n                    account,\\n                    address(this),\\n                    payout\\n                );\\n                _withdrawNative(token, account, payout);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Unwraps the specified amount of wrapped native currency of the network represented as token and sends it\\n     *         to `to` address.\\n     */\\n    function _withdrawNative(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        IWNative(token).withdraw(amount);\\n        TransferHelper.safeTransferETH(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IAzuroBet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IOwnable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\\\";\\n\\ninterface IAzuroBet is IOwnable, IERC721EnumerableUpgradeable {\\n    function initialize(address core) external;\\n\\n    function burn(uint256 id) external;\\n\\n    function mint(address account) external returns (uint256);\\n\\n    error OnlyCore();\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IBet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\ninterface IBet {\\n    struct BetData {\\n        address affiliate; // address indicated as an affiliate when placing bet\\n        uint64 minOdds;\\n        bytes data; // core-specific customized bet data\\n    }\\n\\n    error BetNotExists();\\n    error SmallOdds();\\n\\n    /**\\n     * @notice Register new bet.\\n     * @param  bettor wallet for emitting bet token\\n     * @param  amount amount of tokens to bet\\n     * @param  betData customized bet data\\n     */\\n    function putBet(\\n        address bettor,\\n        uint128 amount,\\n        BetData calldata betData\\n    ) external returns (uint256 tokenId);\\n\\n    function resolvePayout(uint256 tokenId)\\n        external\\n        returns (address account, uint128 payout);\\n\\n    function viewPayout(uint256 tokenId) external view returns (uint128 payout);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ICondition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\ninterface ICondition {\\n    enum ConditionState {\\n        CREATED,\\n        RESOLVED,\\n        CANCELED,\\n        PAUSED\\n    }\\n\\n    struct Condition {\\n        uint256 gameId;\\n        uint128[] payouts;\\n        uint128[] virtualFunds;\\n        uint128 totalNetBets;\\n        uint128 reinforcement;\\n        uint128 fund;\\n        uint64 margin;\\n        uint64 endsAt;\\n        uint48 lastDepositId;\\n        uint8 winningOutcomesCount;\\n        ConditionState state;\\n        address oracle;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ICoreBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IBet.sol\\\";\\nimport \\\"./ICondition.sol\\\";\\nimport \\\"./ILP.sol\\\";\\nimport \\\"./IOwnable.sol\\\";\\nimport \\\"./IAzuroBet.sol\\\";\\n\\ninterface ICoreBase is ICondition, IOwnable, IBet {\\n    struct Bet {\\n        uint256 conditionId;\\n        uint128 amount;\\n        uint128 payout;\\n        uint64 outcome;\\n        bool isPaid;\\n    }\\n\\n    struct CoreBetData {\\n        uint256 conditionId; // The match or game ID\\n        uint64 outcomeId; // ID of predicted outcome\\n    }\\n\\n    event ConditionCreated(\\n        uint256 indexed gameId,\\n        uint256 indexed conditionId,\\n        uint64[] outcomes\\n    );\\n    event ConditionResolved(\\n        uint256 indexed conditionId,\\n        uint8 state,\\n        uint64[] winningOutcomes,\\n        int128 lpProfit\\n    );\\n    event ConditionStopped(uint256 indexed conditionId, bool flag);\\n\\n    event ReinforcementChanged(\\n        uint256 indexed conditionId,\\n        uint128 newReinforcement\\n    );\\n    event MarginChanged(uint256 indexed conditionId, uint64 newMargin);\\n    event OddsChanged(uint256 indexed conditionId, uint256[] newOdds);\\n\\n    error OnlyLp();\\n\\n    error AlreadyPaid();\\n    error DuplicateOutcomes(uint64 outcome);\\n    error IncorrectConditionId();\\n    error IncorrectMargin();\\n    error IncorrectReinforcement();\\n    error NothingChanged();\\n    error IncorrectTimestamp();\\n    error IncorrectWinningOutcomesCount();\\n    error IncorrectOutcomesCount();\\n    error NoPendingReward();\\n    error OnlyOracle(address);\\n    error OutcomesAndOddsCountDiffer();\\n    error StartOutOfRange(uint256 pendingRewardsCount);\\n    error WrongOutcome();\\n    error ZeroOdds();\\n\\n    error CantChangeFlag();\\n    error ConditionAlreadyCreated();\\n    error ConditionAlreadyResolved();\\n    error ConditionNotFinished();\\n    error ConditionNotExists();\\n    error ConditionNotRunning();\\n    error GameAlreadyStarted();\\n    error InsufficientFund();\\n    error ResolveTooEarly(uint64 waitTime);\\n\\n    function lp() external view returns (ILP);\\n\\n    function azuroBet() external view returns (IAzuroBet);\\n\\n    function initialize(address azuroBet, address lp) external;\\n\\n    function calcOdds(\\n        uint256 conditionId,\\n        uint128 amount,\\n        uint64 outcome\\n    ) external view returns (uint64 odds);\\n\\n    /**\\n     * @notice Change the current condition `conditionId` margin.\\n     */\\n    function changeMargin(uint256 conditionId, uint64 newMargin) external;\\n\\n    /**\\n     * @notice Change the current condition `conditionId` odds.\\n     */\\n    function changeOdds(uint256 conditionId, uint256[] calldata newOdds)\\n        external;\\n\\n    /**\\n     * @notice Change the current condition `conditionId` reinforcement.\\n     */\\n    function changeReinforcement(uint256 conditionId, uint128 newReinforcement)\\n        external;\\n\\n    function getCondition(uint256 conditionId)\\n        external\\n        view\\n        returns (Condition memory);\\n\\n    /**\\n     * @notice Indicate the condition `conditionId` as canceled.\\n     * @notice The condition creator can always cancel it regardless of granted access tokens.\\n     */\\n    function cancelCondition(uint256 conditionId) external;\\n\\n    /**\\n     * @notice Indicate the status of condition `conditionId` bet lock.\\n     * @param  conditionId the match or condition ID\\n     * @param  flag if stop receiving bets for the condition or not\\n     */\\n    function stopCondition(uint256 conditionId, bool flag) external;\\n\\n    /**\\n     * @notice Register new condition.\\n     * @param  gameId the game ID the condition belongs\\n     * @param  conditionId the match or condition ID according to oracle's internal numbering\\n     * @param  odds start odds for [team 1, ..., team N]\\n     * @param  outcomes unique outcomes for the condition [outcome 1, ..., outcome N]\\n     * @param  reinforcement maximum amount of liquidity intended to condition reinforcement\\n     * @param  margin bookmaker commission\\n     * @param  winningOutcomesCount the number of winning outcomes of the Condition\\n     */\\n    function createCondition(\\n        uint256 gameId,\\n        uint256 conditionId,\\n        uint256[] calldata odds,\\n        uint64[] calldata outcomes,\\n        uint128 reinforcement,\\n        uint64 margin,\\n        uint8 winningOutcomesCount\\n    ) external;\\n\\n    function getOutcomeIndex(uint256 conditionId, uint64 outcome)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function isOutcomeWinning(uint256 conditionId, uint64 outcome)\\n        external\\n        view\\n        returns (bool);\\n\\n    function isConditionCanceled(uint256 conditionId)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ILP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IBet.sol\\\";\\nimport \\\"./IOwnable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\\\";\\n\\ninterface ILP is IOwnable, IERC721EnumerableUpgradeable {\\n    enum FeeType {\\n        DAO,\\n        DATA_PROVIDER\\n    }\\n\\n    enum CoreState {\\n        UNKNOWN,\\n        ACTIVE,\\n        INACTIVE\\n    }\\n\\n    struct Condition {\\n        address core;\\n        uint256 conditionId;\\n    }\\n\\n    struct CoreData {\\n        CoreState state;\\n        uint64 reinforcementAbility;\\n        uint128 minBet;\\n        uint128 lockedLiquidity;\\n    }\\n\\n    struct Game {\\n        bytes32 unusedVariable;\\n        uint128 lockedLiquidity;\\n        uint64 startsAt;\\n        bool canceled;\\n    }\\n\\n    struct Reward {\\n        int128 amount;\\n        uint64 claimedAt;\\n    }\\n\\n    event CoreSettingsUpdated(\\n        address indexed core,\\n        CoreState state,\\n        uint64 reinforcementAbility,\\n        uint128 minBet\\n    );\\n\\n    event BettorWin(\\n        address indexed core,\\n        address indexed bettor,\\n        uint256 tokenId,\\n        uint256 amount\\n    );\\n    event ClaimTimeoutChanged(uint64 newClaimTimeout);\\n    event DataProviderChanged(address newDataProvider);\\n    event FeeChanged(FeeType feeType, uint64 fee);\\n    event GameCanceled(uint256 indexed gameId);\\n    event GameShifted(uint256 indexed gameId, uint64 newStart);\\n    event LiquidityAdded(\\n        address indexed account,\\n        uint48 indexed depositId,\\n        uint256 amount\\n    );\\n    event LiquidityDonated(\\n        address indexed account,\\n        uint48 indexed depositId,\\n        uint256 amount\\n    );\\n    event LiquidityManagerChanged(address newLiquidityManager);\\n    event LiquidityRemoved(\\n        address indexed account,\\n        uint48 indexed depositId,\\n        uint256 amount\\n    );\\n    event MinBetChanged(address core, uint128 newMinBet);\\n    event MinDepoChanged(uint128 newMinDepo);\\n    event NewGame(uint256 indexed gameId, uint64 startsAt, bytes data);\\n    event ReinforcementAbilityChanged(uint128 newReinforcementAbility);\\n    event WithdrawTimeoutChanged(uint64 newWithdrawTimeout);\\n\\n    error OnlyFactory();\\n\\n    error SmallDepo();\\n    error SmallDonation();\\n\\n    error BetExpired();\\n    error CoreNotActive();\\n    error ClaimTimeout(uint64 waitTime);\\n    error DepositDoesNotExist();\\n    error GameAlreadyCanceled();\\n    error GameAlreadyCreated();\\n    error GameCanceled_();\\n    error GameNotExists();\\n    error IncorrectCoreState();\\n    error IncorrectFee();\\n    error IncorrectGameId();\\n    error IncorrectMinBet();\\n    error IncorrectMinDepo();\\n    error IncorrectReinforcementAbility();\\n    error IncorrectTimestamp();\\n    error LiquidityNotOwned();\\n    error LiquidityIsLocked();\\n    error NoLiquidity();\\n    error NotEnoughLiquidity();\\n    error SmallBet();\\n    error UnknownCore();\\n    error WithdrawalTimeout(uint64 waitTime);\\n\\n    function initialize(\\n        address access,\\n        address dataProvider,\\n        address token,\\n        uint128 minDepo,\\n        uint64 daoFee,\\n        uint64 dataProviderFee\\n    ) external;\\n\\n    function addCore(address core) external;\\n\\n    function addLiquidity(uint128 amount, bytes calldata data)\\n        external\\n        returns (uint48);\\n\\n    function withdrawLiquidity(uint48 depositId, uint40 percent)\\n        external\\n        returns (uint128);\\n\\n    function viewPayout(address core, uint256 tokenId)\\n        external\\n        view\\n        returns (uint128 payout);\\n\\n    function betFor(\\n        address bettor,\\n        address core,\\n        uint128 amount,\\n        uint64 expiresAt,\\n        IBet.BetData calldata betData\\n    ) external returns (uint256 tokenId);\\n\\n    /**\\n     * @notice Make new bet.\\n     * @notice Emits bet token to `msg.sender`.\\n     * @param  core address of the Core the bet is intended\\n     * @param  amount amount of tokens to bet\\n     * @param  expiresAt the time before which bet should be made\\n     * @param  betData customized bet data\\n     */\\n    function bet(\\n        address core,\\n        uint128 amount,\\n        uint64 expiresAt,\\n        IBet.BetData calldata betData\\n    ) external returns (uint256 tokenId);\\n\\n    function changeDataProvider(address newDataProvider) external;\\n\\n    function claimReward() external returns (uint128);\\n\\n    function getReserve() external view returns (uint128);\\n\\n    function addReserve(\\n        uint256 gameId,\\n        uint128 lockedReserve,\\n        uint128 profitReserve,\\n        uint48 depositId\\n    ) external;\\n\\n    function addCondition(uint256 gameId) external view returns (uint64);\\n\\n    function withdrawPayout(address core, uint256 tokenId)\\n        external\\n        returns (uint128);\\n\\n    function changeLockedLiquidity(uint256 gameId, int128 deltaReserve)\\n        external;\\n\\n    /**\\n     * @notice Indicate the game `gameId` as canceled.\\n     * @param  gameId the game ID\\n     */\\n    function cancelGame(uint256 gameId) external;\\n\\n    /**\\n     * @notice Create new game.\\n     * @param  gameId the match or condition ID according to oracle's internal numbering\\n     * @param  startsAt timestamp when the game starts\\n     * @param  data the additional data to emit in the `NewGame` event\\n     */\\n    function createGame(\\n        uint256 gameId,\\n        uint64 startsAt,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @notice Set `startsAt` as new game `gameId` start time.\\n     * @param  gameId the game ID\\n     * @param  startsAt new timestamp when the game starts\\n     */\\n    function shiftGame(uint256 gameId, uint64 startsAt) external;\\n\\n    function getGameInfo(uint256 gameId)\\n        external\\n        view\\n        returns (uint64 startsAt, bool canceled);\\n\\n    function getLockedLiquidityLimit(address core)\\n        external\\n        view\\n        returns (uint128);\\n\\n    function isGameCanceled(uint256 gameId)\\n        external\\n        view\\n        returns (bool canceled);\\n\\n    function checkAccess(\\n        address account,\\n        address target,\\n        bytes4 selector\\n    ) external;\\n\\n    function checkCore(address core) external view;\\n\\n    function getLastDepositId() external view returns (uint48 depositId);\\n\\n    function isDepositExists(uint256 depositId) external view returns (bool);\\n\\n    function token() external view returns (address);\\n\\n    function fees(uint256) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\ninterface IOwnable {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    function owner() external view returns (address);\\n\\n    function checkOwner(address account) external view;\\n\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IProxyFront.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IBet.sol\\\";\\n\\ninterface IProxyFront {\\n    struct BetData {\\n        address core;\\n        uint128 amount;\\n        uint64 expiresAt;\\n        IBet.BetData extraData;\\n    }\\n\\n    struct WithdrawPayoutData {\\n        address core;\\n        uint256 tokenId;\\n        bool isNative;\\n    }\\n\\n    error IncorrectValue();\\n\\n    function bet(address lp, BetData[] calldata data) external payable;\\n\\n    function withdrawPayouts(WithdrawPayoutData[] calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IWNative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n/**\\n * @dev interface for canonical wrapped native contract based on WETH9.sol\\n */\\npragma solidity ^0.8.9;\\n\\ninterface IWNative {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.9;\\n\\nlibrary SafeCast {\\n    enum Type {\\n        BYTES32,\\n        INT128,\\n        UINT64,\\n        UINT128\\n    }\\n    error SafeCastError(Type to);\\n\\n    function toBytes32(string calldata value) internal pure returns (bytes32) {\\n        bytes memory value_ = bytes(value);\\n        if (value_.length > 32) revert SafeCastError(Type.BYTES32);\\n        return bytes32(value_);\\n    }\\n\\n    function toInt128(uint128 value) internal pure returns (int128) {\\n        if (value > uint128(type(int128).max))\\n            revert SafeCastError(Type.INT128);\\n        return int128(value);\\n    }\\n\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) revert SafeCastError(Type.UINT64);\\n        return uint64(value);\\n    }\\n\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) revert SafeCastError(Type.UINT128);\\n        return uint128(value);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"IncorrectValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum SafeCast.Type\",\"name\":\"to\",\"type\":\"uint8\"}],\"name\":\"SafeCastError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"addLiquidityNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"core\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"expiresAt\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"minOdds\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct IBet.BetData\",\"name\":\"extraData\",\"type\":\"tuple\"}],\"internalType\":\"struct IProxyFront.BetData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"name\":\"bet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"depositId\",\"type\":\"uint48\"},{\"internalType\":\"uint40\",\"name\":\"percent\",\"type\":\"uint40\"}],\"name\":\"withdrawLiquidityNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"core\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isNative\",\"type\":\"bool\"}],\"internalType\":\"struct IProxyFront.WithdrawPayoutData[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"name\":\"withdrawPayouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ProxyFront", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "2", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}