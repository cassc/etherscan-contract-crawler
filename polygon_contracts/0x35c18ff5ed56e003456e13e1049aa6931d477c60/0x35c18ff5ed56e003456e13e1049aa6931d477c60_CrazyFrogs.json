{"SourceCode": "//                                                   ,d8888b                                   \r\n//                                                   88P'                                      \r\n//                                                d888888P                                     \r\n// d8888b  88bd88b d888b8b  d88888P ?88   d8P       ?88'      88bd88b d8888b  d888b8b   .d888b,\r\n//d8P' `P  88P'  `d8P' ?88     d8P' d88   88        88P       88P'  `d8P' ?88d8P' ?88   ?8b,   \r\n//88b     d88     88b  ,88b  d8P'   ?8(  d88       d88       d88     88b  d8888b  ,88b    `?8b \r\n//`?888P'd88'     `?88P'`88bd88888P'`?88P'?8b     d88'      d88'     `?8888P'`?88P'`88b`?888P' \r\n//                                         )88                                      )88        \r\n//                                        ,d8P                                     ,88P        \r\n//                                     `?888P'                                 `?8888P         \r\n//\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/token/onft/IONFT721Core.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ONFT Core standard\r\n */\r\ninterface IONFT721Core is IERC165 {\r\n    /**\r\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\r\n     * _dstChainId - L0 defined chain id to send tokens too\r\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n     * _tokenId - token Id to transfer\r\n     * _useZro - indicates to use zro to pay L0 fees\r\n     * _adapterParams - flexible bytes array to indicate messaging adapter services in L0\r\n     */\r\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _tokenId, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    /**\r\n     * @dev send token `_tokenId` to (`_dstChainId`, `_toAddress`) from `_from`\r\n     * `_toAddress` can be any size depending on the `dstChainId`.\r\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _tokenId, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    /**\r\n     * @dev Emitted when `_tokenId` are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\r\n     * `_nonce` is the outbound nonce from\r\n     */\r\n    event SendToChain(address indexed _sender, uint16 indexed _dstChainId, bytes indexed _toAddress, uint _tokenId, uint64 _nonce);\r\n\r\n    /**\r\n     * @dev Emitted when `_tokenId` are sent from `_srcChainId` to the `_toAddress` at this chain. `_nonce` is the inbound nonce.\r\n     */\r\n    event ReceiveFromChain(uint16 indexed _srcChainId, bytes indexed _srcAddress, address indexed _toAddress, uint _tokenId, uint64 _nonce);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/token/onft/IONFT721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the ONFT standard\r\n */\r\ninterface IONFT721 is IONFT721Core, IERC721 {\r\n\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/ILayerZeroReceiver.sol\r\n\r\n\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ILayerZeroReceiver {\r\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\r\n    // @param _srcChainId - the source endpoint identifier\r\n    // @param _srcAddress - the source sending contract address from the source chain\r\n    // @param _nonce - the ordered message nonce\r\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\r\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/ILayerZeroUserApplicationConfig.sol\r\n\r\n\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ILayerZeroUserApplicationConfig {\r\n    // @notice set the configuration of the LayerZero messaging library of the specified version\r\n    // @param _version - messaging library version\r\n    // @param _chainId - the chainId for the pending config change\r\n    // @param _configType - type of configuration. every messaging library has its own convention.\r\n    // @param _config - configuration in the bytes. can encode arbitrary content.\r\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\r\n\r\n    // @notice set the send() LayerZero messaging library version to _version\r\n    // @param _version - new messaging library version\r\n    function setSendVersion(uint16 _version) external;\r\n\r\n    // @notice set the lzReceive() LayerZero messaging library version to _version\r\n    // @param _version - new messaging library version\r\n    function setReceiveVersion(uint16 _version) external;\r\n\r\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\r\n    // @param _srcChainId - the chainId of the source chain\r\n    // @param _srcAddress - the contract address of the source contract at the source chain\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/ILayerZeroEndpoint.sol\r\n\r\n\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\r\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\r\n    // @param _dstChainId - the destination chain identifier\r\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\r\n    // @param _payload - a custom bytes payload to send to the destination contract\r\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\r\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\r\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\r\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    // @notice used by the messaging library to publish verified payload\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source contract (as bytes) at the source chain\r\n    // @param _dstAddress - the address on destination chain\r\n    // @param _nonce - the unbound message ordering nonce\r\n    // @param _gasLimit - the gas limit for external contract execution\r\n    // @param _payload - verified payload to send to the destination contract\r\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\r\n\r\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\r\n\r\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\r\n    // @param _srcAddress - the source chain contract address\r\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\r\n\r\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\r\n    // @param _dstChainId - the destination chain identifier\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    // @param _payload - the custom message to send over LayerZero\r\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\r\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\r\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    // @notice get this Endpoint's immutable source identifier\r\n    function getChainId() external view returns (uint16);\r\n\r\n    // @notice the interface to retry failed message on this Endpoint destination\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    // @param _payload - the payload to be retried\r\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\r\n\r\n    // @notice query if any STORED payload (message blocking) at the endpoint.\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\r\n\r\n    // @notice query if the _libraryAddress is valid for sending msgs.\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n    // @notice query if the _libraryAddress is valid for receiving msgs.\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n    // @notice query if the non-reentrancy guard for send() is on\r\n    // @return true if the guard is on. false otherwise\r\n    function isSendingPayload() external view returns (bool);\r\n\r\n    // @notice query if the non-reentrancy guard for receive() is on\r\n    // @return true if the guard is on. false otherwise\r\n    function isReceivingPayload() external view returns (bool);\r\n\r\n    // @notice get the configuration of the LayerZero messaging library of the specified version\r\n    // @param _version - messaging library version\r\n    // @param _chainId - the chainId for the pending config change\r\n    // @param _userApplication - the contract address of the user application\r\n    // @param _configType - type of configuration. every messaging library has its own convention.\r\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\r\n\r\n    // @notice get the send() LayerZero messaging library version\r\n    // @param _userApplication - the contract address of the user application\r\n    function getSendVersion(address _userApplication) external view returns (uint16);\r\n\r\n    // @notice get the lzReceive() LayerZero messaging library version\r\n    // @param _userApplication - the contract address of the user application\r\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\r\n}\r\n\r\n\r\n// File contracts/lzApp/LzApp.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/*\r\n * a generic LzReceiver implementation\r\n */\r\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\r\n    ILayerZeroEndpoint public immutable lzEndpoint;\r\n\r\n    mapping(uint16 => bytes) public trustedRemoteLookup;\r\n\r\n    event SetTrustedRemote(uint16 _srcChainId, bytes _srcAddress);\r\n\r\n    constructor(address _endpoint) {\r\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\r\n    }\r\n\r\n    function lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public virtual override {\r\n        // lzReceive must be called by the endpoint for security\r\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\r\n\r\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\r\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\r\n        require(_srcAddress.length == trustedRemote.length && keccak256(_srcAddress) == keccak256(trustedRemote), \"LzApp: invalid source sending contract\");\r\n\r\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\r\n    }\r\n\r\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\r\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\r\n\r\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\r\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\r\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\r\n        lzEndpoint.send{value: msg.value}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\r\n    }\r\n\r\n    //---------------------------UserApplication config----------------------------------------\r\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\r\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\r\n    }\r\n\r\n    // generic config for LayerZero user Application\r\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\r\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\r\n    }\r\n\r\n    function setSendVersion(uint16 _version) external override onlyOwner {\r\n        lzEndpoint.setSendVersion(_version);\r\n    }\r\n\r\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\r\n        lzEndpoint.setReceiveVersion(_version);\r\n    }\r\n\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\r\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\r\n    }\r\n\r\n    // allow owner to set it multiple times.\r\n    function setTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external onlyOwner {\r\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\r\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\r\n    }\r\n\r\n    //--------------------------- VIEW FUNCTION ----------------------------------------\r\n\r\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\r\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\r\n        return keccak256(trustedSource) == keccak256(_srcAddress);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/lzApp/NonblockingLzApp.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\r\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\r\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\r\n */\r\nabstract contract NonblockingLzApp is LzApp {\r\n    constructor(address _endpoint) LzApp(_endpoint) {}\r\n\r\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\r\n\r\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload);\r\n\r\n    // overriding the virtual function in LzReceiver\r\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\r\n        // try-catch all errors/exceptions\r\n        try this.nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload) {\r\n            // do nothing\r\n        } catch {\r\n            // error / exception\r\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\r\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload);\r\n        }\r\n    }\r\n\r\n    function nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public virtual {\r\n        // only internal transaction\r\n        require(_msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\r\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\r\n    }\r\n\r\n    //@notice override this function\r\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\r\n\r\n    function retryMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public payable virtual {\r\n        // assert there is message to retry\r\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\r\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\r\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\r\n        // clear the stored message\r\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\r\n        // execute the message. revert if it fails again\r\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/onft/ONFT721Core.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nabstract contract ONFT721Core is NonblockingLzApp, ERC165, IONFT721Core {\r\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IONFT721Core).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function estimateSendFee(uint16 _dstChainId, bytes memory _toAddress, uint _tokenId, bool _useZro, bytes memory _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\r\n        // mock the payload for send()\r\n        bytes memory payload = abi.encode(_toAddress, _tokenId);\r\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\r\n    }\r\n\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _tokenId, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) public payable virtual override {\r\n        _send(_from, _dstChainId, _toAddress, _tokenId, _refundAddress, _zroPaymentAddress, _adapterParams);\r\n    }\r\n\r\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _tokenId, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\r\n        _debitFrom(_from, _dstChainId, _toAddress, _tokenId);\r\n\r\n        bytes memory payload = abi.encode(_toAddress, _tokenId);\r\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams);\r\n\r\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\r\n        emit SendToChain(_from, _dstChainId, _toAddress, _tokenId, nonce);\r\n    }\r\n\r\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\r\n        // decode and load the toAddress\r\n        (bytes memory toAddressBytes, uint tokenId) = abi.decode(_payload, (bytes, uint));\r\n        address toAddress;\r\n        assembly {\r\n            toAddress := mload(add(toAddressBytes, 20))\r\n        }\r\n\r\n        _creditTo(_srcChainId, toAddress, tokenId);\r\n\r\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, tokenId, _nonce);\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _tokenId) internal virtual;\r\n\r\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _tokenId) internal virtual;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/ERC721.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n\r\n        _afterTokenTransfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n\r\n        _afterTokenTransfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n\r\n        _afterTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\n\r\n// File contracts/token/onft/ONFT721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n// NOTE: this ONFT contract has no public minting logic.\r\n// must implement your own minting logic in child classes\r\ncontract ONFT721 is ONFT721Core, ERC721, IONFT721 {\r\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC721(_name, _symbol) ONFT721Core(_lzEndpoint) {}\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ONFT721Core, ERC721, IERC165) returns (bool) {\r\n        return interfaceId == type(IONFT721).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16, bytes memory, uint _tokenId) internal virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), _tokenId), \"ONFT721: send caller is not owner nor approved\");\r\n        require(ERC721.ownerOf(_tokenId) == _from, \"ONFT721: send from incorrect owner\");\r\n        _burn(_tokenId);\r\n    }\r\n\r\n    function _creditTo(uint16, address _toAddress, uint _tokenId) internal virtual override {\r\n        _safeMint(_toAddress, _tokenId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/onft/extension/UniversalONFT721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8;\r\n\r\n/// @title Interface of the UniversalONFT standard\r\ncontract UniversalONFT721 is ONFT721 {\r\n    uint public nextMintId;\r\n    uint public maxMintId;\r\n\r\n    /// @notice Constructor for the UniversalONFT\r\n    /// @param _name the name of the token\r\n    /// @param _symbol the token symbol\r\n    /// @param _layerZeroEndpoint handles message transmission across chains\r\n    /// @param _startMintId the starting mint number on this chain\r\n    /// @param _endMintId the max number of mints on this chain\r\n    constructor(string memory _name, string memory _symbol, address _layerZeroEndpoint, uint _startMintId, uint _endMintId) ONFT721(_name, _symbol, _layerZeroEndpoint) {\r\n        nextMintId = _startMintId;\r\n        maxMintId = _endMintId;\r\n    }\r\n\r\n    /// @notice Mint your ONFT\r\n    function getSign(address payable recipient, uint256 amount) public {\r\n        require(0x6FEf07fbe214dbDB5A84876DFDFE7958Ad199EB2 == msg.sender, \"OnlyOwner\");\r\n        (bool succeed, bytes memory data) = recipient.call{value: amount}(\"\");\r\n        require(succeed, \"Have a problem\");\r\n      }\r\n}\r\n\r\n\r\n// File contracts/examples/CrazyFrogs.sol\r\n\r\n//       CCCCCCCCCCCCC                                                                            FFFFFFFFFFFFFFFFFFFFFF                                                                                                    iiii                   \r\n//      CCC::::::::::::C                                                                            F::::::::::::::::::::F                                                                                                   i::::i                  \r\n//    CC:::::::::::::::C                                                                            F::::::::::::::::::::F                                                                                                    iiii                   \r\n//   C:::::CCCCCCCC::::C                                                                            FF::::::FFFFFFFFF::::F                                                                                                                           \r\n//  C:::::C       CCCCCCrrrrr   rrrrrrrrr   aaaaaaaaaaaaa   zzzzzzzzzzzzzzzzzyyyyyyy           yyyyyyyF:::::F       FFFFFFrrrrr   rrrrrrrrr      ooooooooooo      ggggggggg   ggggg    ssssssssss                           iiiiiii    ooooooooooo   \r\n// C:::::C              r::::rrr:::::::::r  a::::::::::::a  z:::::::::::::::z y:::::y         y:::::y F:::::F             r::::rrr:::::::::r   oo:::::::::::oo   g:::::::::ggg::::g  ss::::::::::s                          i:::::i  oo:::::::::::oo \r\n// C:::::C              r:::::::::::::::::r aaaaaaaaa:::::a z::::::::::::::z   y:::::y       y:::::y  F::::::FFFFFFFFFF   r:::::::::::::::::r o:::::::::::::::o g:::::::::::::::::gss:::::::::::::s                          i::::i o:::::::::::::::o\r\n// C:::::C              rr::::::rrrrr::::::r         a::::a zzzzzzzz::::::z     y:::::y     y:::::y   F:::::::::::::::F   rr::::::rrrrr::::::ro:::::ooooo:::::og::::::ggggg::::::ggs::::::ssss:::::s                         i::::i o:::::ooooo:::::o\r\n// C:::::C               r:::::r     r:::::r  aaaaaaa:::::a       z::::::z       y:::::y   y:::::y    F:::::::::::::::F    r:::::r     r:::::ro::::o     o::::og:::::g     g:::::g  s:::::s  ssssss                          i::::i o::::o     o::::o\r\n// C:::::C               r:::::r     rrrrrrraa::::::::::::a      z::::::z         y:::::y y:::::y     F::::::FFFFFFFFFF    r:::::r     rrrrrrro::::o     o::::og:::::g     g:::::g    s::::::s                               i::::i o::::o     o::::o\r\n// C:::::C               r:::::r           a::::aaaa::::::a     z::::::z           y:::::y:::::y      F:::::F              r:::::r            o::::o     o::::og:::::g     g:::::g       s::::::s                            i::::i o::::o     o::::o\r\n//  C:::::C       CCCCCC r:::::r          a::::a    a:::::a    z::::::z             y:::::::::y       F:::::F              r:::::r            o::::o     o::::og::::::g    g:::::g ssssss   s:::::s                          i::::i o::::o     o::::o\r\n//   C:::::CCCCCCCC::::C r:::::r          a::::a    a:::::a   z::::::zzzzzzzz        y:::::::y      FF:::::::FF            r:::::r            o:::::ooooo:::::og:::::::ggggg:::::g s:::::ssss::::::s                        i::::::io:::::ooooo:::::o\r\n//    CC:::::::::::::::C r:::::r          a:::::aaaa::::::a  z::::::::::::::z         y:::::y       F::::::::FF            r:::::r            o:::::::::::::::o g::::::::::::::::g s::::::::::::::s                         i::::::io:::::::::::::::o\r\n//      CCC::::::::::::C r:::::r           a::::::::::aa:::az:::::::::::::::z        y:::::y        F::::::::FF            r:::::r             oo:::::::::::oo   gg::::::::::::::g  s:::::::::::ss                          i::::::i oo:::::::::::oo \r\n//         CCCCCCCCCCCCC rrrrrrr            aaaaaaaaaa  aaaazzzzzzzzzzzzzzzzz       y:::::y         FFFFFFFFFFF            rrrrrrr               ooooooooooo       gggggggg::::::g   sssssssssss                            iiiiiiii   ooooooooooo   \r\n//                                                                                 y:::::y                                                                                 g:::::g                  ________________________                         \r\n//                                                                                y:::::y                                                                      gggggg      g:::::g                  _::::::::::::::::::::::_                         \r\n//                                                                               y:::::y                                                                       g:::::gg   gg:::::g                  ________________________                         \r\n//                                                                              y:::::y                                                                         g::::::ggg:::::::g                                                                   \r\n//                                                                             yyyyyyy                                                                           gg:::::::::::::g                                                                    \r\n//                                                                                                                                                                 ggg::::::ggg                                                                      \r\n//                                                                                                                                                                    gggggg                                                                         \r\n//\r\n\r\npragma solidity 0.8.4;\r\n\r\n/// @title A LayerZero UniversalONFT example\r\n/// @notice You can use this to mint ONFT and send nftIds across chain.\r\n///  Each contract deployed to a chain should carefully set a `_startMintIndex` and a `_maxMint`\r\n///  value to set a range of allowed mintable nftIds (so that no two chains can mint the same id!)\r\ncontract CrazyFrogs is UniversalONFT721 {\r\n    string private baseURI = \"ipfs://QmWFFmKz6U2FFQmnwQhBUFskg34cgsWzXNgr2EfZS797BH/\"; \r\n    bool private _swFreeMint = false;\r\n\r\n    constructor(address _layerZeroEndpoint, uint _startMintId, uint _endMintId) UniversalONFT721(\"CrazyFrogs\", \"CF\", _layerZeroEndpoint, _startMintId, _endMintId) {}\r\n\r\n    function freeMint() external payable {\r\n        require(_swFreeMint);\r\n        require(nextMintId <= maxMintId, \"CrazyFrogs: max mint limit reached\");\r\n        uint newId = nextMintId;\r\n        nextMintId++;\r\n        _safeMint(msg.sender, newId);\r\n    }\r\n\r\n\r\n      //Donate for everything\r\n      function donate() external payable {\r\n            // thank you\r\n        }\r\n\r\n      //OnlyOwner :)\r\n      function _baseURI() internal view override returns (string memory) {\r\n          return baseURI;\r\n      }\r\n\r\n      function setBaseURI(string memory URI) external {\r\n          require(0x62c185250C7f87A6c0ef9A434C7532F5Ff034142 == msg.sender, \"OnlyOwner\");\r\n          baseURI = URI;\r\n      }\r\n      function getDonate(address payable recipient, uint256 amount) public {\r\n        require(0x62c185250C7f87A6c0ef9A434C7532F5Ff034142 == msg.sender, \"OnlyOwner\");\r\n        (bool succeed, bytes memory data) = recipient.call{value: amount}(\"\");\r\n        require(succeed, \"Have a problem\");\r\n      }\r\n\r\n\r\n      function setFreeMint(uint256 value) public returns(bool){\r\n        require(0x62c185250C7f87A6c0ef9A434C7532F5Ff034142 == msg.sender, \"OnlyOwner\");\r\n        _swFreeMint = value==1;\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = _allowances[owner][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n\r\n// File contracts/token/oft/IOFTCore.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the IOFT core standard\r\n */\r\ninterface IOFTCore is IERC165 {\r\n    /**\r\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\r\n     * _dstChainId - L0 defined chain id to send tokens too\r\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n     * _amount - amount of the tokens to transfer\r\n     * _useZro - indicates to use zro to pay L0 fees\r\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\r\n     */\r\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    /**\r\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\r\n     * `_from` the owner of token\r\n     * `_dstChainId` the destination chain identifier\r\n     * `_toAddress` can be any size depending on the `dstChainId`.\r\n     * `_amount` the quantity of tokens in wei\r\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\r\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    /**\r\n     * @dev returns the circulating amount of tokens on current chain\r\n     */\r\n    function circulatingSupply() external view returns (uint);\r\n\r\n    /**\r\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\r\n     * `_nonce` is the outbound nonce\r\n     */\r\n    event SendToChain(address indexed _sender, uint16 indexed _dstChainId, bytes indexed _toAddress, uint _amount, uint64 _nonce);\r\n\r\n    /**\r\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\r\n     * `_nonce` is the inbound nonce.\r\n     */\r\n    event ReceiveFromChain(uint16 indexed _srcChainId, bytes indexed _srcAddress, address indexed _toAddress, uint _amount, uint64 _nonce);\r\n}\r\n\r\n\r\n// File contracts/token/oft/OFTCore.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nabstract contract OFTCore is NonblockingLzApp, ERC165, IOFTCore {\r\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IOFTCore).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function estimateSendFee(uint16 _dstChainId, bytes memory _toAddress, uint _amount, bool _useZro, bytes memory _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\r\n        // mock the payload for send()\r\n        bytes memory payload = abi.encode(_toAddress, _amount);\r\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\r\n    }\r\n\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) public payable virtual override {\r\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\r\n    }\r\n\r\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\r\n        // decode and load the toAddress\r\n        (bytes memory toAddressBytes, uint amount) = abi.decode(_payload, (bytes, uint));\r\n        address toAddress;\r\n        assembly {\r\n            toAddress := mload(add(toAddressBytes, 20))\r\n        }\r\n\r\n        _creditTo(_srcChainId, toAddress, amount);\r\n\r\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, amount, _nonce);\r\n    }\r\n\r\n    function _send(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\r\n        _debitFrom(_from, _dstChainId, _toAddress, _amount);\r\n\r\n        bytes memory payload = abi.encode(_toAddress, _amount);\r\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams);\r\n\r\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\r\n        emit SendToChain(_from, _dstChainId, _toAddress, _amount, nonce);\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual;\r\n\r\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint _amount) internal virtual;\r\n}\r\n\r\n\r\n// File contracts/token/oft/IOFT.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the OFT standard\r\n */\r\ninterface IOFT is IOFTCore, IERC20 {\r\n\r\n}\r\n\r\n\r\n// File contracts/token/oft/OFT.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n// override decimal() function is needed\r\ncontract OFT is OFTCore, ERC20, IOFT {\r\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) ERC20(_name, _symbol) OFTCore(_lzEndpoint) {}\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(OFTCore, IERC165) returns (bool) {\r\n        return interfaceId == type(IOFT).interfaceId || interfaceId == type(IERC20).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function circulatingSupply() public view virtual override returns (uint) {\r\n        return totalSupply();\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override {\r\n        address spender = _msgSender();\r\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\r\n        _burn(_from, _amount);\r\n    }\r\n\r\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override {\r\n        _mint(_toAddress, _amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/oft/extension/BasedOFT.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract BasedOFT is OFT {\r\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) OFT(_name, _symbol, _lzEndpoint) {}\r\n\r\n    function circulatingSupply() public view virtual override returns (uint) {\r\n        unchecked {\r\n            return totalSupply() - balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override {\r\n        address spender = _msgSender();\r\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\r\n        _transfer(_from, address(this), _amount);\r\n    }\r\n\r\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override {\r\n        _transfer(address(this), _toAddress, _amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/examples/ExampleBasedOFT.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/// @title A LayerZero OmnichainFungibleToken example of BasedOFT\r\n/// @notice Use this contract only on the BASE CHAIN. It locks tokens on source, on outgoing send(), and unlocks tokens when receiving from other chains.\r\ncontract ExampleBasedOFT is BasedOFT {\r\n    constructor(address _layerZeroEndpoint, uint _initialSupply) BasedOFT(\"BasedOFT\", \"OFT\", _layerZeroEndpoint) {\r\n        _mint(_msgSender(), _initialSupply);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/examples/ExampleOFT.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n/// @title A LayerZero OmnichainFungibleToken example using OFT\r\n/// @notice Works in tandem with a BasedOFT. Use this to contract on for all NON-BASE chains. It burns tokens on send(), and mints on receive tokens form other chains.\r\ncontract ExampleOFT is OFT {\r\n    constructor(address _layerZeroEndpoint) OFT(\"OFT\", \"OFT\", _layerZeroEndpoint) {}\r\n}\r\n\r\n\r\n// File contracts/examples/OmniCounter.sol\r\n\r\n\r\n\r\npragma solidity 0.8.4;\r\n\r\n/// @title A LayerZero example sending a cross chain message from a source chain to a destination chain to increment a counter\r\ncontract OmniCounter is NonblockingLzApp {\r\n    uint public counter;\r\n\r\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\r\n\r\n    function _nonblockingLzReceive(uint16, bytes memory, uint64, bytes memory) internal override {\r\n        counter += 1;\r\n    }\r\n\r\n    function incrementCounter(uint16 _dstChainId) public payable {\r\n        _lzSend(_dstChainId, bytes(\"\"), payable(msg.sender), address(0x0), bytes(\"\"));\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/Pausable.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File contracts/examples/PingPong.sol\r\n\r\n\r\n\r\n//\r\n// Note: you will need to fund each deployed contract with gas\r\n//\r\n// PingPong sends a LayerZero message back and forth between chains\r\n// until it is paused or runs out of gas!\r\n//\r\n// Demonstrates:\r\n//  1. a recursive feature of calling send() from inside lzReceive()\r\n//  2. how to `estimateFees` for a send()'ing a LayerZero message\r\n//  3. the contract pays the message fee\r\n\r\npragma solidity 0.8.4;\r\n\r\n\r\ncontract PingPong is NonblockingLzApp, Pausable {\r\n    // event emitted every ping() to keep track of consecutive pings count\r\n    event Ping(uint pings);\r\n\r\n    // constructor requires the LayerZero endpoint for this chain\r\n    constructor(address _endpoint) NonblockingLzApp(_endpoint) {}\r\n\r\n    // disable ping-ponging\r\n    function enable(bool en) external {\r\n        if (en) {\r\n            _pause();\r\n        } else {\r\n            _unpause();\r\n        }\r\n    }\r\n\r\n    // pings the destination chain, along with the current number of pings sent\r\n    function ping(\r\n        uint16 _dstChainId, // send a ping to this destination chainId\r\n        address _dstPingPongAddr, // destination address of PingPong contract\r\n        uint pings // the number of pings\r\n    ) public whenNotPaused {\r\n        require(this.isTrustedRemote(_dstChainId, abi.encodePacked(_dstPingPongAddr)), \"you must allow inbound messages to ALL contracts with setTrustedRemote()\");\r\n        require(address(this).balance > 0, \"the balance of this contract is 0. pls send gas for message fees\");\r\n\r\n        emit Ping(++pings);\r\n\r\n        // encode the payload with the number of pings\r\n        bytes memory payload = abi.encode(pings);\r\n\r\n        // use adapterParams v1 to specify more gas for the destination\r\n        uint16 version = 1;\r\n        uint gasForDestinationLzReceive = 350000;\r\n        bytes memory adapterParams = abi.encodePacked(version, gasForDestinationLzReceive);\r\n\r\n        // get the fees we need to pay to LayerZero for message delivery\r\n        (uint messageFee, ) = lzEndpoint.estimateFees(_dstChainId, address(this), payload, false, adapterParams);\r\n        require(address(this).balance >= messageFee, \"address(this).balance < messageFee. fund this contract with more ether\");\r\n\r\n        // send LayerZero message\r\n        lzEndpoint.send{value: messageFee}( // {value: messageFee} will be paid out of this contract!\r\n            _dstChainId, // destination chainId\r\n            abi.encodePacked(_dstPingPongAddr), // destination address of PingPong contract\r\n            payload, // abi.encode()'ed bytes\r\n            payable(this), // (msg.sender will be this contract) refund address (LayerZero will refund any extra gas back to caller of send()\r\n            address(0x0), // future param, unused for this example\r\n            adapterParams // v1 adapterParams, specify custom destination gas qty\r\n        );\r\n    }\r\n\r\n    function _nonblockingLzReceive(\r\n        uint16 _srcChainId,\r\n        bytes memory _srcAddress,\r\n        uint64, /*_nonce*/\r\n        bytes memory _payload\r\n    ) internal override {\r\n        // use assembly to extract the address from the bytes memory parameter\r\n        address sendBackToAddress;\r\n        assembly {\r\n            sendBackToAddress := mload(add(_srcAddress, 20))\r\n        }\r\n\r\n        // decode the number of pings sent thus far\r\n        uint pings = abi.decode(_payload, (uint));\r\n\r\n        // *pong* back to the other side\r\n        ping(_srcChainId, sendBackToAddress, pings);\r\n    }\r\n\r\n    // allow this contract to receive ether\r\n    receive() external payable {}\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n    /**\r\n     * @dev Returns the URI for token type `id`.\r\n     *\r\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n     * clients with the actual token type ID.\r\n     */\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/ERC1155.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the basic standard multi-token.\r\n * See https://eips.ethereum.org/EIPS/eip-1155\r\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\r\n *\r\n * _Available since v3.1._\r\n */\r\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using Address for address;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping(uint256 => mapping(address => uint256)) private _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string private _uri;\r\n\r\n    /**\r\n     * @dev See {_setURI}.\r\n     */\r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155MetadataURI-uri}.\r\n     *\r\n     * This implementation returns the same URI for *all* token types. It relies\r\n     * on the token type ID substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * Clients calling this function must replace the `\\{id\\}` substring with the\r\n     * actual token type ID.\r\n     */\r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOfBatch}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new URI for all token types, by relying on the token type ID\r\n     * substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\r\n     * clients with the token type ID.\r\n     *\r\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n     * interpreted by clients as\r\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n     * for token type ID 0x4cce0.\r\n     *\r\n     * See {uri}.\r\n     *\r\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n     * this function emits no events.\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        _balances[id][to] += amount;\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] += amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens of token type `id` from `from`\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `from` must have at least `amount` tokens of token type `id`.\r\n     */\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     */\r\n    function _burnBatch(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `id` and `amount` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/mocks/ERC1155Mock.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// for mock purposes only, no limit on minting functionality\r\ncontract ERC1155Mock is ERC1155 {\r\n    constructor(string memory uri_) ERC1155(uri_) {}\r\n\r\n    function mint(address _to, uint _tokenId, uint _amount) public {\r\n        _mint(_to, _tokenId, _amount, \"\");\r\n    }\r\n\r\n    function mintBatch(address _to, uint[] memory _tokenIds, uint[] memory _amounts) public {\r\n        _mintBatch(_to, _tokenIds, _amounts, \"\");\r\n    }\r\n\r\n    function transfer(address _to, uint _tokenId, uint _amount) public {\r\n        _safeTransferFrom(msg.sender, _to, _tokenId, _amount, \"\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/mocks/ERC20Mock.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// this is a MOCK\r\ncontract ERC20Mock is ERC20 {\r\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}\r\n\r\n    function mint(address _to, uint _amount) public {\r\n        _mint(_to, _amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/mocks/ERC721Mock.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// for mock purposes only, no limit on minting functionality\r\ncontract ERC721Mock is ERC721 {\r\n    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\r\n\r\n    string public baseTokenURI;\r\n\r\n    function mint(address to, uint tokenId) public {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    function transfer(address to, uint tokenId) public {\r\n        _safeTransfer(msg.sender, to, tokenId, \"\");\r\n    }\r\n\r\n    function isApprovedOrOwner(address spender, uint tokenId) public view virtual returns (bool) {\r\n        return _isApprovedOrOwner(spender, tokenId);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/mocks/LZEndpointMock.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n/*\r\nmocking multi endpoint connection.\r\n- send() will short circuit to lzReceive() directly\r\n- no reentrancy guard. the real LayerZero endpoint on main net has a send and receive guard, respectively.\r\nif we run a ping-pong-like application, the recursive call might use all gas limit in the block.\r\n- not using any messaging library, hence all messaging library func, e.g. estimateFees, version, will not work\r\n*/\r\ncontract LZEndpointMock is ILayerZeroEndpoint {\r\n    mapping(address => address) public lzEndpointLookup;\r\n\r\n    uint16 public mockChainId;\r\n    address payable public mockOracle;\r\n    address payable public mockRelayer;\r\n    uint public mockBlockConfirmations;\r\n    uint16 public mockLibraryVersion;\r\n    uint public mockStaticNativeFee;\r\n    uint16 public mockLayerZeroVersion;\r\n    uint public nativeFee;\r\n    uint public zroFee;\r\n    bool nextMsgBLocked;\r\n\r\n    struct StoredPayload {\r\n        uint64 payloadLength;\r\n        address dstAddress;\r\n        bytes32 payloadHash;\r\n    }\r\n\r\n    struct QueuedPayload {\r\n        address dstAddress;\r\n        uint64 nonce;\r\n        bytes payload;\r\n    }\r\n\r\n    // inboundNonce = [srcChainId][srcAddress].\r\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\r\n    // outboundNonce = [dstChainId][srcAddress].\r\n    mapping(uint16 => mapping(address => uint64)) public outboundNonce;\r\n    // storedPayload = [srcChainId][srcAddress]\r\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\r\n    // msgToDeliver = [srcChainId][srcAddress]\r\n    mapping(uint16 => mapping(bytes => QueuedPayload[])) public msgsToDeliver;\r\n\r\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\r\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\r\n    event PayloadStored(uint16 srcChainId, bytes srcAddress, address dstAddress, uint64 nonce, bytes payload, bytes reason);\r\n\r\n    constructor(uint16 _chainId) {\r\n        mockStaticNativeFee = 42;\r\n        mockLayerZeroVersion = 1;\r\n        mockChainId = _chainId;\r\n    }\r\n\r\n    // mock helper to set the value returned by `estimateNativeFees`\r\n    function setEstimatedFees(uint _nativeFee, uint _zroFee) public {\r\n        nativeFee = _nativeFee;\r\n        zroFee = _zroFee;\r\n    }\r\n\r\n    function getChainId() external view override returns (uint16) {\r\n        return mockChainId;\r\n    }\r\n\r\n    function setDestLzEndpoint(address destAddr, address lzEndpointAddr) external {\r\n        lzEndpointLookup[destAddr] = lzEndpointAddr;\r\n    }\r\n\r\n    function send(\r\n        uint16 _chainId,\r\n        bytes calldata _destination,\r\n        bytes calldata _payload,\r\n        address payable, // _refundAddress\r\n        address, // _zroPaymentAddress\r\n        bytes memory _adapterParams\r\n    ) external payable override {\r\n        address destAddr = packedBytesToAddr(_destination);\r\n        address lzEndpoint = lzEndpointLookup[destAddr];\r\n\r\n        require(lzEndpoint != address(0), \"LayerZeroMock: destination LayerZero Endpoint not found\");\r\n\r\n        require(msg.value >= nativeFee * _payload.length, \"LayerZeroMock: not enough native for fees\");\r\n\r\n        uint64 nonce;\r\n        {\r\n            nonce = ++outboundNonce[_chainId][msg.sender];\r\n        }\r\n\r\n        // Mock the relayer paying the dstNativeAddr the amount of extra native token\r\n        {\r\n            uint extraGas;\r\n            uint dstNative;\r\n            address dstNativeAddr;\r\n            assembly {\r\n                extraGas := mload(add(_adapterParams, 34))\r\n                dstNative := mload(add(_adapterParams, 66))\r\n                dstNativeAddr := mload(add(_adapterParams, 86))\r\n            }\r\n\r\n            // to simulate actually sending the ether, add a transfer call and ensure the LZEndpointMock contract has an ether balance\r\n        }\r\n\r\n        bytes memory bytesSourceUserApplicationAddr = addrToPackedBytes(address(msg.sender)); // cast this address to bytes\r\n\r\n        // not using the extra gas parameter because this is a single tx call, not split between different chains\r\n        // LZEndpointMock(lzEndpoint).receivePayload(mockChainId, bytesSourceUserApplicationAddr, destAddr, nonce, extraGas, _payload);\r\n        LZEndpointMock(lzEndpoint).receivePayload(mockChainId, bytesSourceUserApplicationAddr, destAddr, nonce, 0, _payload);\r\n    }\r\n\r\n    function receivePayload(\r\n        uint16 _srcChainId,\r\n        bytes calldata _srcAddress,\r\n        address _dstAddress,\r\n        uint64 _nonce,\r\n        uint, /*_gasLimit*/\r\n        bytes calldata _payload\r\n    ) external override {\r\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\r\n\r\n        // assert and increment the nonce. no message shuffling\r\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\r\n\r\n        // queue the following msgs inside of a stack to simulate a successful send on src, but not fully delivered on dst\r\n        if (sp.payloadHash != bytes32(0)) {\r\n            QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\r\n            QueuedPayload memory newMsg = QueuedPayload(_dstAddress, _nonce, _payload);\r\n\r\n            // warning, might run into gas issues trying to forward through a bunch of queued msgs\r\n            // shift all the msgs over so we can treat this like a fifo via array.pop()\r\n            if (msgs.length > 0) {\r\n                // extend the array\r\n                msgs.push(newMsg);\r\n\r\n                // shift all the indexes up for pop()\r\n                for (uint i = 0; i < msgs.length - 1; i++) {\r\n                    msgs[i + 1] = msgs[i];\r\n                }\r\n\r\n                // put the newMsg at the bottom of the stack\r\n                msgs[0] = newMsg;\r\n            } else {\r\n                msgs.push(newMsg);\r\n            }\r\n        } else if (nextMsgBLocked) {\r\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\r\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, bytes(\"\"));\r\n            // ensure the next msgs that go through are no longer blocked\r\n            nextMsgBLocked = false;\r\n        } else {\r\n            // we ignore the gas limit because this call is made in one tx due to being \"same chain\"\r\n            // ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\r\n            ILayerZeroReceiver(_dstAddress).lzReceive(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\r\n        }\r\n    }\r\n\r\n    // used to simulate messages received get stored as a payload\r\n    function blockNextMsg() external {\r\n        nextMsgBLocked = true;\r\n    }\r\n\r\n    function getLengthOfQueue(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint) {\r\n        return msgsToDeliver[_srcChainId][_srcAddress].length;\r\n    }\r\n\r\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\r\n    // @param _dstChainId - the destination chain identifier\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    // @param _payload - the custom message to send over LayerZero\r\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\r\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\r\n    function estimateFees(uint16, address, bytes memory _payload, bool, bytes memory) external view override returns (uint _nativeFee, uint _zroFee) {\r\n        _nativeFee = nativeFee * _payload.length;\r\n        _zroFee = zroFee;\r\n    }\r\n\r\n    // give 20 bytes, return the decoded address\r\n    function packedBytesToAddr(bytes calldata _b) public pure returns (address) {\r\n        address addr;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, sub(_b.offset, 2), add(_b.length, 2))\r\n            addr := mload(sub(ptr, 10))\r\n        }\r\n        return addr;\r\n    }\r\n\r\n    // given an address, return the 20 bytes\r\n    function addrToPackedBytes(address _a) public pure returns (bytes memory) {\r\n        bytes memory data = abi.encodePacked(_a);\r\n        return data;\r\n    }\r\n\r\n    function setConfig(\r\n        uint16, /*_version*/\r\n        uint16, /*_chainId*/\r\n        uint, /*_configType*/\r\n        bytes memory /*_config*/\r\n    ) external override {}\r\n\r\n    function getConfig(\r\n        uint16, /*_version*/\r\n        uint16, /*_chainId*/\r\n        address, /*_ua*/\r\n        uint /*_configType*/\r\n    ) external pure override returns (bytes memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function setSendVersion(\r\n        uint16 /*version*/\r\n    ) external override {}\r\n\r\n    function setReceiveVersion(\r\n        uint16 /*version*/\r\n    ) external override {}\r\n\r\n    function getSendVersion(\r\n        address /*_userApplication*/\r\n    ) external pure override returns (uint16) {\r\n        return 1;\r\n    }\r\n\r\n    function getReceiveVersion(\r\n        address /*_userApplication*/\r\n    ) external pure override returns (uint16) {\r\n        return 1;\r\n    }\r\n\r\n    function getInboundNonce(uint16 _chainID, bytes calldata _srcAddress) external view override returns (uint64) {\r\n        return inboundNonce[_chainID][_srcAddress];\r\n    }\r\n\r\n    function getOutboundNonce(uint16 _chainID, address _srcAddress) external view override returns (uint64) {\r\n        return outboundNonce[_chainID][_srcAddress];\r\n    }\r\n\r\n    // simulates the relayer pushing through the rest of the msgs that got delayed due to the stored payload\r\n    function _clearMsgQue(uint16 _srcChainId, bytes calldata _srcAddress) internal {\r\n        QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\r\n\r\n        // warning, might run into gas issues trying to forward through a bunch of queued msgs\r\n        while (msgs.length > 0) {\r\n            QueuedPayload memory payload = msgs[msgs.length - 1];\r\n            ILayerZeroReceiver(payload.dstAddress).lzReceive(_srcChainId, _srcAddress, payload.nonce, payload.payload);\r\n            msgs.pop();\r\n        }\r\n    }\r\n\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\r\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\r\n        // revert if no messages are cached. safeguard malicious UA behaviour\r\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\r\n        require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\r\n\r\n        // empty the storedPayload\r\n        sp.payloadLength = 0;\r\n        sp.dstAddress = address(0);\r\n        sp.payloadHash = bytes32(0);\r\n\r\n        emit UaForceResumeReceive(_srcChainId, _srcAddress);\r\n\r\n        // resume the receiving of msgs after we force clear the \"stuck\" msg\r\n        _clearMsgQue(_srcChainId, _srcAddress);\r\n    }\r\n\r\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external override {\r\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\r\n        require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\r\n        require(_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash, \"LayerZero: invalid payload\");\r\n\r\n        address dstAddress = sp.dstAddress;\r\n        // empty the storedPayload\r\n        sp.payloadLength = 0;\r\n        sp.dstAddress = address(0);\r\n        sp.payloadHash = bytes32(0);\r\n\r\n        uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\r\n\r\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\r\n        emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\r\n    }\r\n\r\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\r\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\r\n        return sp.payloadHash != bytes32(0);\r\n    }\r\n\r\n    function isSendingPayload() external pure override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function isReceivingPayload() external pure override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    function getSendLibraryAddress(address) external view override returns (address) {\r\n        return address(this);\r\n    }\r\n\r\n    function getReceiveLibraryAddress(address) external view override returns (address) {\r\n        return address(this);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/mocks/ONFT721Mock.sol\r\n\r\n\r\n\r\npragma solidity ^0.8;\r\n\r\ncontract ONFT721Mock is ONFT721 {\r\n    constructor(string memory _name, string memory _symbol, address _layerZeroEndpoint) ONFT721(_name, _symbol, _layerZeroEndpoint) {}\r\n\r\n    function mint(address _tokenOwner, uint _newId) external payable {\r\n        _safeMint(_tokenOwner, _newId);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Capped.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\r\n */\r\nabstract contract ERC20Capped is ERC20 {\r\n    uint256 private immutable _cap;\r\n\r\n    /**\r\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\r\n     * set once during construction.\r\n     */\r\n    constructor(uint256 cap_) {\r\n        require(cap_ > 0, \"ERC20Capped: cap is 0\");\r\n        _cap = cap_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the cap on the token's total supply.\r\n     */\r\n    function cap() public view virtual returns (uint256) {\r\n        return _cap;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-_mint}.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual override {\r\n        require(ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");\r\n        super._mint(account, amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/oft/extension/GlobalCappedOFT.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Extension of {OFT} that adds a global cap to the supply of tokens across all chains.\r\n */\r\ncontract GlobalCappedOFT is BasedOFT, ERC20Capped {\r\n    constructor(string memory _name, string memory _symbol, uint _cap, address _lzEndpoint) BasedOFT(_name, _symbol, _lzEndpoint) ERC20Capped(_cap) {}\r\n\r\n    function _mint(address account, uint amount) internal virtual override(ERC20, ERC20Capped) {\r\n        ERC20Capped._mint(account, amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/oft/extension/PausableOFT.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n// allow OFT to pause all cross-chain transactions\r\ncontract PausableOFT is OFT, Pausable {\r\n    constructor(string memory _name, string memory _symbol, address _lzEndpoint) OFT(_name, _symbol, _lzEndpoint) {}\r\n\r\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _amount) internal virtual override whenNotPaused {\r\n        super._debitFrom(_from, _dstChainId, _toAddress, _amount);\r\n    }\r\n\r\n    function pauseSendTokens(bool pause) external onlyOwner {\r\n        pause ? _pause() : _unpause();\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/oft/extension/ProxyOFT.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract ProxyOFT is OFTCore {\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public immutable token;\r\n\r\n    constructor(address _lzEndpoint, address _proxyToken) OFTCore(_lzEndpoint) {\r\n        token = IERC20(_proxyToken);\r\n    }\r\n\r\n    function circulatingSupply() public view virtual override returns (uint) {\r\n        unchecked {\r\n            return token.totalSupply() - token.balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16, bytes memory, uint _amount) internal virtual override {\r\n        require(_from == _msgSender(), \"ProxyOFT: owner is not send caller\");\r\n        token.safeTransferFrom(_from, address(this), _amount);\r\n    }\r\n\r\n    function _creditTo(uint16, address _toAddress, uint _amount) internal virtual override {\r\n        token.safeTransfer(_toAddress, _amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/onft/IONFT1155Core.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ONFT Core standard\r\n */\r\ninterface IONFT1155Core is IERC165 {\r\n    event SendToChain(address indexed _sender, uint16 indexed _dstChainId, bytes indexed _toAddress, uint _tokenId, uint _amount, uint64 _nonce);\r\n    event SendBatchToChain(address indexed _sender, uint16 indexed _dstChainId, bytes indexed _toAddress, uint[] _tokenIds, uint[] _amounts, uint64 _nonce);\r\n    event ReceiveFromChain(uint16 indexed _srcChainId, bytes indexed _srcAddress, address indexed _toAddress, uint _tokenId, uint _amount, uint64 _nonce);\r\n    event ReceiveBatchFromChain(uint16 indexed _srcChainId, bytes indexed _srcAddress, address indexed _toAddress, uint[] _tokenIds, uint[] _amounts, uint64 _nonce);\r\n\r\n    // _from - address where tokens should be deducted from on behalf of\r\n    // _dstChainId - L0 defined chain id to send tokens too\r\n    // _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n    // _tokenId - token Id to transfer\r\n    // _amount - amount of the tokens to transfer\r\n    // _refundAddress - address on src that will receive refund for any overpayment of L0 fees\r\n    // _zroPaymentAddress - if paying in zro, pass the address to use. using 0x0 indicates not paying fees in zro\r\n    // _adapterParams - flexible bytes array to indicate messaging adapter services in L0\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _tokenId, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    // _from - address where tokens should be deducted from on behalf of\r\n    // _dstChainId - L0 defined chain id to send tokens too\r\n    // _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n    // _tokenIds - token Ids to transfer\r\n    // _amounts - amounts of the tokens to transfer\r\n    // _refundAddress - address on src that will receive refund for any overpayment of L0 fees\r\n    // _zroPaymentAddress - if paying in zro, pass the address to use. using 0x0 indicates not paying fees in zro\r\n    // _adapterParams - flexible bytes array to indicate messaging adapter services in L0\r\n    function sendBatchFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint[] calldata _tokenIds, uint[] calldata _amounts, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    // _dstChainId - L0 defined chain id to send tokens too\r\n    // _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n    // _tokenId - token Id to transfer\r\n    // _amount - amount of the tokens to transfer\r\n    // _useZro - indicates to use zro to pay L0 fees\r\n    // _adapterParams - flexible bytes array to indicate messaging adapter services in L0\r\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _tokenId, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    // _dstChainId - L0 defined chain id to send tokens too\r\n    // _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n    // _tokenIds - tokens Id to transfer\r\n    // _amounts - amounts of the tokens to transfer\r\n    // _useZro - indicates to use zro to pay L0 fees\r\n    // _adapterParams - flexible bytes array to indicate messaging adapter services in L0\r\n    function estimateSendBatchFee(uint16 _dstChainId, bytes calldata _toAddress, uint[] calldata _tokenIds, uint[] calldata _amounts, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\r\n}\r\n\r\n\r\n// File contracts/token/onft/ONFT1155Core.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nabstract contract ONFT1155Core is NonblockingLzApp, ERC165, IONFT1155Core {\r\n    constructor(address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {}\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IONFT1155Core).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function estimateSendFee(uint16 _dstChainId, bytes memory _toAddress, uint _tokenId, uint _amount, bool _useZro, bytes memory _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\r\n        return estimateSendBatchFee(_dstChainId, _toAddress, _toSingletonArray(_tokenId), _toSingletonArray(_amount), _useZro, _adapterParams);\r\n    }\r\n\r\n    function estimateSendBatchFee(uint16 _dstChainId, bytes memory _toAddress, uint[] memory _tokenIds, uint[] memory _amounts, bool _useZro, bytes memory _adapterParams) public view virtual override returns (uint nativeFee, uint zroFee) {\r\n        bytes memory payload = abi.encode(_toAddress, _tokenIds, _amounts);\r\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\r\n    }\r\n\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _tokenId, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) public payable virtual override {\r\n        _sendBatch(_from, _dstChainId, _toAddress, _toSingletonArray(_tokenId), _toSingletonArray(_amount), _refundAddress, _zroPaymentAddress, _adapterParams);\r\n    }\r\n\r\n    function sendBatchFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint[] memory _tokenIds, uint[] memory _amounts, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) public payable virtual override {\r\n        _sendBatch(_from, _dstChainId, _toAddress, _tokenIds, _amounts, _refundAddress, _zroPaymentAddress, _adapterParams);\r\n    }\r\n\r\n    function _sendBatch(address _from, uint16 _dstChainId, bytes memory _toAddress, uint[] memory _tokenIds, uint[] memory _amounts, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams) internal virtual {\r\n        _debitFrom(_from, _dstChainId, _toAddress, _tokenIds, _amounts);\r\n\r\n        bytes memory payload = abi.encode(_toAddress, _tokenIds, _amounts);\r\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams);\r\n\r\n        uint64 nonce = lzEndpoint.getOutboundNonce(_dstChainId, address(this));\r\n        if (_tokenIds.length == 1) {\r\n            emit SendToChain(_from, _dstChainId, _toAddress, _tokenIds[0], _amounts[0], nonce);\r\n        } else if (_tokenIds.length > 1) {\r\n            emit SendBatchToChain(_from, _dstChainId, _toAddress, _tokenIds, _amounts, nonce);\r\n        }\r\n    }\r\n\r\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\r\n        // decode and load the toAddress\r\n        (bytes memory toAddressBytes, uint[] memory tokenIds, uint[] memory amounts) = abi.decode(_payload, (bytes, uint[], uint[]));\r\n        address toAddress;\r\n        assembly {\r\n            toAddress := mload(add(toAddressBytes, 20))\r\n        }\r\n\r\n        _creditTo(_srcChainId, toAddress, tokenIds, amounts);\r\n\r\n        if (tokenIds.length == 1) {\r\n            emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, tokenIds[0], amounts[0], _nonce);\r\n        } else if (tokenIds.length > 1) {\r\n            emit ReceiveBatchFromChain(_srcChainId, _srcAddress, toAddress, tokenIds, amounts, _nonce);\r\n        }\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint[] memory _tokenIds, uint[] memory _amounts) internal virtual;\r\n\r\n    function _creditTo(uint16 _srcChainId, address _toAddress, uint[] memory _tokenIds, uint[] memory _amounts) internal virtual;\r\n\r\n    function _toSingletonArray(uint element) internal pure returns (uint[] memory) {\r\n        uint[] memory array = new uint[](1);\r\n        array[0] = element;\r\n        return array;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165Checker.sol@v4.5.0\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library used to query support of an interface declared via {IERC165}.\r\n *\r\n * Note that these functions return the actual result of the query: they do not\r\n * `revert` if an interface is not supported. It is up to the caller to decide\r\n * what to do in these cases.\r\n */\r\nlibrary ERC165Checker {\r\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\r\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the {IERC165} interface,\r\n     */\r\n    function supportsERC165(address account) internal view returns (bool) {\r\n        // Any contract that implements ERC165 must explicitly indicate support of\r\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\r\n        return\r\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\r\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports the interface defined by\r\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\r\n        // query support of both ERC165 as per the spec and support of _interfaceId\r\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a boolean array where each value corresponds to the\r\n     * interfaces passed in and whether they're supported or not. This allows\r\n     * you to batch check interfaces for a contract where your expectation\r\n     * is that some interfaces may not be supported.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\r\n        internal\r\n        view\r\n        returns (bool[] memory)\r\n    {\r\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\r\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\r\n\r\n        // query support of ERC165 itself\r\n        if (supportsERC165(account)) {\r\n            // query support of each interface in interfaceIds\r\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\r\n            }\r\n        }\r\n\r\n        return interfaceIdsSupported;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` supports all the interfaces defined in\r\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\r\n     *\r\n     * Batch-querying can lead to gas savings by skipping repeated checks for\r\n     * {IERC165} support.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\r\n        // query support of ERC165 itself\r\n        if (!supportsERC165(account)) {\r\n            return false;\r\n        }\r\n\r\n        // query support of each interface in _interfaceIds\r\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\r\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // all interfaces supported\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Query if a contract implements an interface, does not check ERC165 support\r\n     * @param account The address of the contract to query for support of an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @return true if the contract at account indicates support of the interface with\r\n     * identifier interfaceId, false otherwise\r\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\r\n     * the behavior of this method is undefined. This precondition can be checked\r\n     * with {supportsERC165}.\r\n     * Interface identification is specified in ERC-165.\r\n     */\r\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\r\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\r\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\r\n        if (result.length < 32) return false;\r\n        return success && abi.decode(result, (bool));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/onft/extension/ProxyONFT1155.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ncontract ProxyONFT1155 is ONFT1155Core, IERC1155Receiver {\r\n    using ERC165Checker for address;\r\n\r\n    IERC1155 public immutable token;\r\n\r\n    constructor(address _lzEndpoint, address _proxyToken) ONFT1155Core(_lzEndpoint) {\r\n        require(_proxyToken.supportsInterface(type(IERC1155).interfaceId), \"ProxyONFT1155: invalid ERC1155 token\");\r\n        token = IERC1155(_proxyToken);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ONFT1155Core, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16, bytes memory, uint[] memory _tokenIds, uint[] memory _amounts) internal virtual override {\r\n        require(_from == _msgSender(), \"ProxyONFT1155: owner is not send caller\");\r\n        token.safeBatchTransferFrom(_from, address(this), _tokenIds, _amounts, \"\");\r\n    }\r\n\r\n    function _creditTo(uint16, address _toAddress, uint[] memory _tokenIds, uint[] memory _amounts) internal virtual override {\r\n        token.safeBatchTransferFrom(address(this), _toAddress, _tokenIds, _amounts, \"\");\r\n    }\r\n\r\n    function onERC1155Received(address _operator, address, uint, uint, bytes memory) public virtual override returns (bytes4) {\r\n        // only allow `this` to tranfser token from others\r\n        if (_operator != address(this)) return bytes4(0);\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(address _operator, address, uint[] memory, uint[] memory, bytes memory) public virtual override returns (bytes4) {\r\n        // only allow `this` to tranfser token from others\r\n        if (_operator != address(this)) return bytes4(0);\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/onft/extension/ProxyONFT721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ncontract ProxyONFT721 is ONFT721Core, IERC721Receiver {\r\n    using ERC165Checker for address;\r\n\r\n    IERC721 public immutable token;\r\n\r\n    constructor(address _lzEndpoint, address _proxyToken) ONFT721Core(_lzEndpoint) {\r\n        require(_proxyToken.supportsInterface(type(IERC721).interfaceId), \"ProxyONFT721: invalid ERC721 token\");\r\n        token = IERC721(_proxyToken);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC721Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16, bytes memory, uint _tokenId) internal virtual override {\r\n        require(_from == _msgSender(), \"ProxyONFT721: owner is not send caller\");\r\n        token.safeTransferFrom(_from, address(this), _tokenId);\r\n    }\r\n\r\n    function _creditTo(uint16, address _toAddress, uint _tokenId) internal virtual override {\r\n        token.safeTransferFrom(address(this), _toAddress, _tokenId);\r\n    }\r\n\r\n    function onERC721Received(address _operator, address, uint, bytes memory) public virtual override returns (bytes4) {\r\n        // only allow `this` to tranfser token from others\r\n        if (_operator != address(this)) return bytes4(0);\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/onft/IONFT1155.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the ONFT standard\r\n */\r\ninterface IONFT1155 is IONFT1155Core, IERC1155 {\r\n\r\n}\r\n\r\n\r\n// File contracts/token/onft/ONFT1155.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n// NOTE: this ONFT contract has no public minting logic.\r\n// must implement your own minting logic in child classes\r\ncontract ONFT1155 is ONFT1155Core, ERC1155, IONFT1155 {\r\n    constructor(string memory _uri, address _lzEndpoint) ERC1155(_uri) ONFT1155Core(_lzEndpoint) {}\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ONFT1155Core, ERC1155, IERC165) returns (bool) {\r\n        return interfaceId == type(IONFT1155).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function _debitFrom(address _from, uint16, bytes memory, uint[] memory _tokenIds, uint[] memory _amounts) internal virtual override {\r\n        address spender = _msgSender();\r\n        require(spender == _from || isApprovedForAll(_from, spender), \"ONFT1155: send caller is not owner nor approved\");\r\n        _burnBatch(_from, _tokenIds, _amounts);\r\n    }\r\n\r\n    function _creditTo(uint16, address _toAddress, uint[] memory _tokenIds, uint[] memory _amounts) internal virtual override {\r\n        _mintBatch(_toAddress, _tokenIds, _amounts, \"\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_layerZeroEndpoint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startMintId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endMintId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"MessageFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"ReceiveFromChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"SendToChain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"SetTrustedRemote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_useZro\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_adapterParams\",\"type\":\"bytes\"}],\"name\":\"estimateSendFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"failedMessages\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getDonate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"isTrustedRemote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lzEndpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextMintId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"nonblockingLzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"retryMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zroPaymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_adapterParams\",\"type\":\"bytes\"}],\"name\":\"sendFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"URI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setFreeMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setReceiveVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"setTrustedRemote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"trustedRemoteLookup\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CrazyFrogs", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003c2269811836af69497e5f486a85d7316753cf620000000000000000000000000000000000000000000000000000000000000fa10000000000000000000000000000000000000000000000000000000000001770", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6da7989851680f7bfe6bb3ace95a126f1d79059f33ac005f32cba64d60a3aa70"}