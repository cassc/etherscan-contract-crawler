{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/automation/Automation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\\\";\\nimport \\\"../controller/IAccount.sol\\\";\\nimport \\\"../verifier/IERC2612Verifier.sol\\\";\\nimport \\\"../verifier/ITokenApprovalVerifier.sol\\\";\\n\\ncontract Automation {\\n    address public immutable verifier;\\n    address public immutable tokenApprovalVerifier;\\n    address public immutable loanProvider;\\n    mapping(address => address) public customizedLoanProviders;\\n\\n    event SetLoanProvider(address account, address loanProvider);\\n\\n    constructor(\\n        address _verifier,\\n        address _tokenApprovalVerifier,\\n        address _loanProvider\\n    ) {\\n        verifier = _verifier;\\n        tokenApprovalVerifier = _tokenApprovalVerifier;\\n        loanProvider = _loanProvider;\\n    }\\n\\n    function setLoanProvider(address account, address customizedLoanProvider)\\n        external\\n    {\\n        require(IAccount(account).owner() == msg.sender, \\\"Owner check failed.\\\");\\n        customizedLoanProviders[account] = customizedLoanProvider;\\n        emit SetLoanProvider(account, customizedLoanProvider);\\n    }\\n\\n    function getLoanProvider(address account) public view returns (address) {\\n        return\\n            customizedLoanProviders[account] == address(0)\\n                ? loanProvider\\n                : customizedLoanProviders[account];\\n    }\\n\\n    function _executeVerifyBasic(address account, uint256 operation)\\n        internal\\n        view\\n    {\\n        require(\\n            IERC2612Verifier(verifier).isTxPermitted(\\n                account,\\n                msg.sender,\\n                operation\\n            ),\\n            \\\"denied\\\"\\n        );\\n    }\\n\\n    function _executeVerifyAdapter(address account, bytes memory callBytes)\\n        internal\\n        view\\n    {\\n        address adapter;\\n        assembly {\\n            adapter := mload(add(callBytes, 32))\\n        }\\n        require(\\n            IERC2612Verifier(verifier).isTxPermitted(\\n                account,\\n                msg.sender,\\n                adapter\\n            ),\\n            \\\"denied\\\"\\n        );\\n    }\\n\\n    function _executeVerifyApproval(address account, address spender)\\n        internal\\n        view\\n    {\\n        require(\\n            ITokenApprovalVerifier(tokenApprovalVerifier).isWhitelisted(\\n                account,\\n                spender\\n            ),\\n            \\\"denied\\\"\\n        );\\n    }\\n\\n    function _autoExecute(\\n        address account,\\n        bytes calldata callBytes,\\n        bool callType\\n    ) internal returns (bytes memory returnData) {\\n        _executeVerifyAdapter(account, callBytes);\\n        returnData = IAccount(account).executeOnAdapter(callBytes, callType);\\n    }\\n\\n    function autoExecute(\\n        address account,\\n        bytes calldata callBytes,\\n        bool callType\\n    ) external returns (bytes memory) {\\n        return _autoExecute(account, callBytes, callType);\\n    }\\n\\n    function autoExecuteWithPermit(\\n        address account,\\n        bytes calldata callBytes,\\n        bool callType,\\n        bytes32 approvalType,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (bytes memory) {\\n        IERC2612Verifier(verifier).permit(\\n            account,\\n            msg.sender,\\n            approvalType,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n        return _autoExecute(account, callBytes, callType);\\n    }\\n\\n    function autoExecuteMultiCall(\\n        address account,\\n        bool[] memory callType,\\n        bytes[] memory callBytes,\\n        bool[] memory isNeedCallback\\n    ) external {\\n        require(\\n            callType.length == callBytes.length &&\\n                callBytes.length == isNeedCallback.length\\n        );\\n        for (uint256 i = 0; i < callType.length; i++) {\\n            _executeVerifyAdapter(account, callBytes[i]);\\n        }\\n        IAccount(payable(account)).multiCall(\\n            callType,\\n            callBytes,\\n            isNeedCallback\\n        );\\n    }\\n\\n    function autoApprove(\\n        address account,\\n        address token,\\n        address spender,\\n        uint256 amount\\n    ) external {\\n        _executeVerifyBasic(account, 0);\\n        _executeVerifyApproval(account, spender);\\n        IAccount(payable(account)).approve(token, spender, amount);\\n    }\\n\\n    function autoApproveWithPermit(\\n        address account,\\n        address[] memory tokens,\\n        address[] memory spenders,\\n        uint256[] memory amounts,\\n        address[] memory permitSpenders,\\n        bool enable,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(\\n            tokens.length == spenders.length &&\\n                spenders.length == amounts.length,\\n            \\\"approve length error.\\\"\\n        );\\n        _executeVerifyBasic(account, 0);\\n        ITokenApprovalVerifier(tokenApprovalVerifier).permit(\\n            account,\\n            permitSpenders,\\n            enable,\\n            deadline,\\n            v,\\n            r,\\n            s\\n        );\\n        for (uint256 i = 0; i < spenders.length; i++) {\\n            _executeVerifyApproval(account, spenders[i]);\\n        }\\n        IAccount(payable(account)).approveTokens(tokens, spenders, amounts);\\n    }\\n\\n    function doFlashLoan(\\n        address account,\\n        address token,\\n        uint256 amount,\\n        bytes calldata payload\\n    ) external {\\n        _executeVerifyBasic(account, 1);\\n        (\\n            bool[] memory _callType,\\n            bytes[] memory _callBytes,\\n            bool[] memory _isNeedCallback\\n        ) = abi.decode(payload, (bool[], bytes[], bool[]));\\n        require(\\n            _callType.length == _callBytes.length &&\\n                _callBytes.length == _isNeedCallback.length\\n        );\\n        for (uint256 i = 0; i < _callBytes.length; i++) {\\n            _executeVerifyAdapter(account, _callBytes[i]);\\n        }\\n        IERC3156FlashLender(getLoanProvider(account)).flashLoan(\\n            IERC3156FlashBorrower(account),\\n            token,\\n            amount,\\n            payload\\n        );\\n    }\\n\\n    function autoExecuteOnSubAccount(\\n        address account,\\n        address subAccount,\\n        bytes calldata callArgs,\\n        uint256 amountETH\\n    ) external {\\n        _executeVerifyBasic(account, 2);\\n        require(Ownable(subAccount).owner() == account, \\\"invalid account!\\\");\\n        IAccount(payable(account)).callOnSubAccount(\\n            subAccount,\\n            callArgs,\\n            amountETH\\n        );\\n    }\\n\\n    function doFlashLoanOnSubAccount(\\n        address account,\\n        address subAccount,\\n        address token,\\n        uint256 amount,\\n        bytes calldata payload\\n    ) external {\\n        _executeVerifyBasic(account, 3);\\n        require(Ownable(subAccount).owner() == account, \\\"invalid account!\\\");\\n        IERC3156FlashLender(getLoanProvider(account)).flashLoan(\\n            IERC3156FlashBorrower(subAccount),\\n            token,\\n            amount,\\n            payload\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/verifier/IERC2612Verifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\ninterface IERC2612Verifier {\\n    event OperatorUpdate(\\n        address account,\\n        address operator,\\n        bytes32 approvalType\\n    );\\n\\n    function approve(\\n        address account,\\n        address operator,\\n        bytes32 approvalType,\\n        uint256 deadline\\n    ) external;\\n\\n    function permit(\\n        address account,\\n        address operator,\\n        bytes32 approvalType,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function isTxPermitted(\\n        address account,\\n        address operator,\\n        address adapter\\n    ) external view returns (bool);\\n\\n    function isTxPermitted(\\n        address account,\\n        address operator,\\n        uint256 operation\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/core/verifier/ITokenApprovalVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\ninterface ITokenApprovalVerifier {\\n    event ApprovalUpdate(address account, address[] spenders, bool isAllowed);\\n\\n    function approve(\\n        address account,\\n        address[] memory spenders,\\n        bool enable,\\n        uint256 deadline\\n    ) external;\\n\\n    function permit(\\n        address account,\\n        address[] memory spenders,\\n        bool enable,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function isWhitelisted(address account, address operator)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/core/controller/IAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\ninterface IAccount {\\n    function owner() external view returns (address);\\n\\n    function createSubAccount(bytes memory _data, uint256 _costETH)\\n        external\\n        payable\\n        returns (address newSubAccount);\\n\\n    function executeOnAdapter(bytes calldata _callBytes, bool _callType)\\n        external\\n        payable\\n        returns (bytes memory);\\n\\n    function multiCall(\\n        bool[] calldata _callType,\\n        bytes[] calldata _callArgs,\\n        bool[] calldata _isNeedCallback\\n    ) external;\\n\\n    function setAdvancedOption(bool val) external;\\n\\n    function callOnSubAccount(\\n        address _target,\\n        bytes calldata _callArgs,\\n        uint256 amountETH\\n    ) external;\\n\\n    function withdrawAssets(\\n        address[] calldata _tokens,\\n        address _receiver,\\n        uint256[] calldata _amounts\\n    ) external;\\n\\n    function approve(\\n        address tokenAddr,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function approveTokens(\\n        address[] calldata _tokens,\\n        address[] calldata _spenders,\\n        uint256[] calldata _amounts\\n    ) external;\\n\\n    function isSubAccount(address subAccount) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC3156 FlashLender, as defined in\\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC3156FlashLender {\\n    /**\\n     * @dev The amount of currency available to be lended.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(address token, uint256 amount) external view returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashBorrower.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenApprovalVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_loanProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loanProvider\",\"type\":\"address\"}],\"name\":\"SetLoanProvider\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"autoApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"spenders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"permitSpenders\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"autoApproveWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callBytes\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"callType\",\"type\":\"bool\"}],\"name\":\"autoExecute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"callType\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"callBytes\",\"type\":\"bytes[]\"},{\"internalType\":\"bool[]\",\"name\":\"isNeedCallback\",\"type\":\"bool[]\"}],\"name\":\"autoExecuteMultiCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"subAccount\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callArgs\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"autoExecuteOnSubAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callBytes\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"callType\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"approvalType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"autoExecuteWithPermit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"customizedLoanProviders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"doFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"subAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"doFlashLoanOnSubAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLoanProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loanProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"customizedLoanProvider\",\"type\":\"address\"}],\"name\":\"setLoanProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenApprovalVerifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Automation", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000e946dd7d03f6f5c440f68c84808ca88d26475fc50000000000000000000000009b2316cfe980515de7430f1c4e831b89a5921137000000000000000000000000f1a5710a91183e317b17d1a314227b36d1a30b95", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}