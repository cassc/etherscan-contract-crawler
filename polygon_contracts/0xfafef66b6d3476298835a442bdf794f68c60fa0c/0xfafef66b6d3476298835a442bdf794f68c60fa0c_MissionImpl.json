{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/polygon/missions/Sailing4/MissionImpl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport {MissionBase} from \\\"./MissionBase.sol\\\";\\r\\n\\r\\ncontract MissionImpl is MissionBase {\\r\\n    \\r\\n    uint public constant DISTANCE = 80000;\\r\\n    uint public constant RENTAL_COST = 20000 ether;\\r\\n    uint public constant MISSION_COST = 50000 ether;\\r\\n    address public constant DAO_WALLET_POLYGON = 0x1725C76d16F2cEB1413825F2d7f21e3aCb2C588c;\\r\\n    \\r\\n    uint public ethRewardAmount = 0.03 ether;\\r\\n\\r\\n    uint public ggold_burned = 0;\\r\\n    uint public wood_burned = 0;\\r\\n\\r\\n    uint[] public goldRewards;\\r\\n    uint HOUSE = 1;\\r\\n    uint ETH_REWARD = 3;\\r\\n    uint SHIP = 4;\\r\\n    uint PIRATE = 5;\\r\\n    uint LEGENDARY_GOVERNOR = 12;\\r\\n    uint ULTRA_RARE_GOVERNOR = 13;\\r\\n    uint RARE_GOVERNOR = 14;\\r\\n    uint LEGENDARY_ERNESTO = 18;\\r\\n    uint ULTRA_RARE_ERNESTO = 19;\\r\\n    uint RARE_ERNESTO = 20;\\r\\n    \\r\\n    uint[] public silverRewards;\\r\\n    uint SILVER_MINER = 1;\\r\\n    uint COMMON_GOVERNOR = 16;\\r\\n    uint COMMON_ERNESTO = 22;\\r\\n    uint WOOD80 = 4;\\r\\n\\r\\n    uint[] public bronzeRewards;\\r\\n    uint BRONZE_MINER = 1;\\r\\n    uint WOOD60 = 2;\\r\\n    uint WOOD50 = 3;\\r\\n\\r\\n    address[] public houseWinners;\\r\\n    address[] public ethWinners;\\r\\n    uint[] shipPrizeIds;\\r\\n    uint public shipPrizeIx = 0;\\r\\n    uint[] piratePrizeIds;\\r\\n    uint public piratePrizeIx = 0;\\r\\n    uint[] minerPrizeIds;\\r\\n    uint public minerPrizeIx = 0;\\r\\n\\r\\n    bool bronzeMinted;\\r\\n    bool silverMinted;\\r\\n    bool goldMinted;\\r\\n\\r\\n    constructor(\\r\\n        address _wood,\\r\\n        address _ggold,\\r\\n        address _goldhunters, \\r\\n        address _ships, \\r\\n        address _cards,\\r\\n        address _metadata,\\r\\n        address _speedCalculator,\\r\\n        address _cardsManager,\\r\\n        address _vrfCoordinator, \\r\\n        address _linkToken,\\r\\n        bytes32 _keyHash\\r\\n    ) MissionBase(\\r\\n        _wood,\\r\\n        _ggold,\\r\\n        _goldhunters, \\r\\n        _ships, \\r\\n        _cards, \\r\\n        _metadata,\\r\\n        _speedCalculator,\\r\\n        _cardsManager,\\r\\n        _vrfCoordinator, \\r\\n        _linkToken, \\r\\n        _keyHash\\r\\n    ) {}\\r\\n    ///// MODIFIERS /////\\r\\n    modifier whenValidCrewSize(uint16[] memory _goldhunterIds, uint16[] memory _shipIds, uint[] memory _cardIds, bool _rentedShip) {\\r\\n        require((_shipIds.length == 1 && !_rentedShip) || (_shipIds.length == 0 && _rentedShip));\\r\\n        require(_goldhunterIds.length >= 1);\\r\\n        \\r\\n        if (!_rentedShip && !metadata.shipIsPirate(_shipIds[0])) {\\r\\n            require(_goldhunterIds.length <= 5);\\r\\n        } else if (!_rentedShip) {\\r\\n            require(_goldhunterIds.length <= 7);\\r\\n        } else {\\r\\n            require(_goldhunterIds.length <= 5);\\r\\n        }\\r\\n\\r\\n        require(_cardIds.length <= 3);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    ///// GAMEPLAY /////\\r\\n\\r\\n    function startMission(\\r\\n        uint16[] memory _goldhunterIds, \\r\\n        uint16[] memory _shipIds,\\r\\n        uint[] memory _cardIds,\\r\\n        bool _rentedShip\\r\\n    ) public whenValidCrewSize(_goldhunterIds, _shipIds, _cardIds, _rentedShip) {\\r\\n        uint speed = speedCalculator.getCrewSpeed(_goldhunterIds, _shipIds, _cardIds);\\r\\n\\r\\n        // Charge Mission Fee\\r\\n        wood.burn(msg.sender, MISSION_COST);\\r\\n        wood.mint(DAO_WALLET_POLYGON, MISSION_COST);\\r\\n        wood_burned += MISSION_COST;\\r\\n\\r\\n        // Charge Rental Fee if Applicable\\r\\n        if (_rentedShip) {\\r\\n            ggold.burn(msg.sender, RENTAL_COST);\\r\\n            ggold.mint(DAO_WALLET_POLYGON, RENTAL_COST);\\r\\n            ggold_burned += RENTAL_COST;\\r\\n            // base speed of rented ship is 0 so skip speed update\\r\\n        }\\r\\n\\r\\n        _startMission(_goldhunterIds, _shipIds, _cardIds, speed, DISTANCE);\\r\\n    }\\r\\n\\r\\n    function abortMissions(\\r\\n        uint[] calldata _missionIds\\r\\n    ) public {\\r\\n        for(uint i = 0; i < _missionIds.length; i++) {\\r\\n            _abortMission(_missionIds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function finishMissions(\\r\\n        uint[] calldata _missionIds\\r\\n    ) public {\\r\\n        for(uint i = 0; i < _missionIds.length; i++) {\\r\\n            finishMission(_missionIds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function finishMission(\\r\\n        uint _missionId\\r\\n    ) public {\\r\\n        uint randomOutcome = _finishMission(_missionId);\\r\\n\\r\\n        // 3 Outcomes, Earned Reward Yes/No, Class of Prize, Prize itself\\r\\n        uint INDEPENDENT_OUTCOMES = 3;\\r\\n        uint[] memory expandedValues = new uint[](INDEPENDENT_OUTCOMES);\\r\\n\\r\\n        for (uint i = 0; i < INDEPENDENT_OUTCOMES; i++) {\\r\\n            expandedValues[i] = uint(keccak256(abi.encode(randomOutcome, i)));\\r\\n        }\\r\\n\\r\\n        // 60% CHANCE OF SUCCESS\\r\\n        if ((expandedValues[0] % 100) + 1 > (40)) {\\r\\n            _sendReward(expandedValues[1], expandedValues[2], msg.sender);\\r\\n        } else {\\r\\n            emit NoRewardWon(msg.sender);\\r\\n        }   \\r\\n    }\\r\\n\\r\\n    ///// REWARD MANAGEMENT /////\\r\\n    event WonHouse(address _winner);\\r\\n    event WonEth(address _winner);\\r\\n    event WonGHGCard(address _winner, string _cardName);\\r\\n    event WonShip(address _winner);\\r\\n    event WonPirate(address _winner);\\r\\n    event WonMiner(address _winner);\\r\\n    event WonWood(address _winner, uint _amount);\\r\\n    event OutOfBronzeRewards(address _unlucky);\\r\\n    event OutOfSilverRewards(address _unlucky);\\r\\n    event OutOfGoldRewards(address _unlucky);\\r\\n    event NoRewardWon(address _loser);\\r\\n\\r\\n    function getHouseWinners() public view returns (address[] memory) {\\r\\n        return houseWinners;\\r\\n    }\\r\\n\\r\\n    function getEthWinners() public view returns (address[] memory) {\\r\\n        return ethWinners;\\r\\n    }\\r\\n\\r\\n    function _sendReward(uint _tierOutcome, uint _rewardIxOutcome, address _winner) internal {\\r\\n        if ((_tierOutcome % 100) + 1 <= 15) { // gold\\r\\n            uint reward = _getReward(1, _rewardIxOutcome);\\r\\n\\r\\n            if (reward == PIRATE) { // UNIT\\r\\n                goldhunters.transferFrom(address(this), msg.sender, piratePrizeIds[piratePrizeIx]);\\r\\n                piratePrizeIx += 1;\\r\\n                emit WonPirate(_winner);\\r\\n            } else if (reward == SHIP) { // UNIT\\r\\n                ships.transferFrom(address(this), msg.sender, shipPrizeIds[shipPrizeIx]);\\r\\n                shipPrizeIx += 1;\\r\\n                emit WonShip(_winner);\\r\\n            } else if (reward == RARE_ERNESTO) { // CARD\\r\\n                cards.mint(_winner, RARE_ERNESTO, 1);\\r\\n                emit WonGHGCard(_winner, \\\"CHARACTER_ERNESTO_RARE\\\");\\r\\n            } else if (reward == RARE_GOVERNOR) { // CARD\\r\\n                cards.mint(_winner, RARE_GOVERNOR, 1);\\r\\n                emit WonGHGCard(_winner, \\\"CHARACTER_GOVERNOR_RARE\\\");\\r\\n            } else if (reward == ULTRA_RARE_ERNESTO) { // CARD\\r\\n                cards.mint(_winner, ULTRA_RARE_ERNESTO, 1);\\r\\n                emit WonGHGCard(_winner, \\\"CHARACTER_ERNESTO_ULTRA_RARE\\\");\\r\\n            } else if (reward == ULTRA_RARE_GOVERNOR) { // CARD\\r\\n                cards.mint(_winner, ULTRA_RARE_GOVERNOR, 1);\\r\\n                emit WonGHGCard(_winner, \\\"CHARACTER_GOVERNOR_ULTRA_RARE\\\");\\r\\n            } else if (reward == LEGENDARY_ERNESTO) { // CARD\\r\\n                cards.mint(_winner, LEGENDARY_ERNESTO, 1);\\r\\n                emit WonGHGCard(_winner, \\\"CHARACTER_ERNESTO_LEGENDARY\\\");\\r\\n            } else if (reward == LEGENDARY_GOVERNOR) { // CARD\\r\\n                cards.mint(_winner, LEGENDARY_GOVERNOR, 1);\\r\\n                emit WonGHGCard(_winner, \\\"CHARACTER_GOVERNOR_LEGENDARY\\\");\\r\\n            } else if (reward == ETH_REWARD) { // ETH\\r\\n                payable(msg.sender).transfer(ethRewardAmount);\\r\\n                ethWinners.push(_winner);\\r\\n                emit WonEth(_winner);\\r\\n            } else if (reward == HOUSE) { // MANUAL LIST\\r\\n                houseWinners.push(_winner);\\r\\n                emit WonHouse(_winner);\\r\\n            } else {\\r\\n                emit OutOfGoldRewards(_winner);\\r\\n            }\\r\\n\\r\\n        } else if ((_tierOutcome % 100) + 1 < 50) { // silver\\r\\n            uint reward = _getReward(2, _rewardIxOutcome);\\r\\n\\r\\n            if (reward == SILVER_MINER) { // UNIT \\r\\n                goldhunters.transferFrom(address(this), msg.sender, minerPrizeIds[minerPrizeIx]);\\r\\n                minerPrizeIx += 1;\\r\\n                emit WonMiner(_winner);\\r\\n            } else if (reward == COMMON_GOVERNOR) { // CARD\\r\\n                cards.mint(_winner, COMMON_GOVERNOR, 1);\\r\\n                emit WonGHGCard(_winner, \\\"CHARACTER_GOVERNOR_COMMON\\\");\\r\\n            } else if (reward == COMMON_ERNESTO) { // CARD\\r\\n                cards.mint(_winner, COMMON_ERNESTO, 1);\\r\\n                emit WonGHGCard(_winner, \\\"CHARACTER_ERNESTO_COMMON\\\");\\r\\n            } else if (reward == WOOD80) { // COIN\\r\\n                wood.mint(_winner, 120000 ether);\\r\\n                emit WonWood(_winner, 120000 ether);\\r\\n            } else {\\r\\n                emit OutOfSilverRewards(_winner);\\r\\n            }\\r\\n\\r\\n        } else {\\r\\n            uint reward = _getReward(3, _rewardIxOutcome);\\r\\n\\r\\n            if (reward == BRONZE_MINER) { // UNIT\\r\\n                goldhunters.transferFrom(address(this), msg.sender, minerPrizeIds[minerPrizeIx]);\\r\\n                minerPrizeIx += 1;\\r\\n                emit WonMiner(_winner);\\r\\n            } else if (reward == WOOD60) { // COIN\\r\\n                wood.mint(_winner, 80000 ether);\\r\\n                emit WonWood(_winner, 80000 ether);\\r\\n            } else if (reward == WOOD50) { // COIN\\r\\n                wood.mint(_winner, 20000 ether);\\r\\n                emit WonWood(_winner, 20000 ether);\\r\\n            } else {\\r\\n                emit OutOfBronzeRewards(_winner);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getReward(uint _rewardTier, uint _seed) internal returns (uint reward) {\\r\\n        if (_rewardTier == 3) { // bronze\\r\\n            if ( bronzeRewards.length != 0 ) {\\r\\n                uint rewardIx = _seed % bronzeRewards.length;\\r\\n                reward = bronzeRewards[rewardIx];\\r\\n\\r\\n                bronzeRewards[rewardIx] = bronzeRewards[bronzeRewards.length - 1];\\r\\n                bronzeRewards.pop();\\r\\n            } else { \\r\\n                return 0;\\r\\n            }\\r\\n        } else if (_rewardTier == 2) { // silver\\r\\n            if ( silverRewards.length != 0 ) {\\r\\n                uint rewardIx = _seed % silverRewards.length;\\r\\n                reward = silverRewards[rewardIx];\\r\\n\\r\\n                silverRewards[rewardIx] = silverRewards[silverRewards.length - 1];\\r\\n                silverRewards.pop();\\r\\n            } else {\\r\\n                return 0;\\r\\n            }\\r\\n        } else { // gold\\r\\n            if ( goldRewards.length != 0 ) {\\r\\n                uint rewardIx = _seed % goldRewards.length;\\r\\n                reward = goldRewards[rewardIx];\\r\\n\\r\\n                goldRewards[rewardIx] = goldRewards[goldRewards.length - 1];\\r\\n                goldRewards.pop();\\r\\n            } else {\\r\\n                return 0;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mintGoldRewards() external {\\r\\n        require(!goldMinted, \\\"ERROR: GOLD REWARDS HAVE BEEN MINTED\\\");\\r\\n\\r\\n        for (uint i = 0; i < 2; i++) {\\r\\n            goldRewards.push(HOUSE);\\r\\n        }\\r\\n        goldRewards.push(LEGENDARY_GOVERNOR);\\r\\n        goldRewards.push(LEGENDARY_ERNESTO);\\r\\n\\r\\n        for (uint i = 0; i < 8; i++) {\\r\\n            goldRewards.push(ETH_REWARD);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 6; i++) {\\r\\n            goldRewards.push(SHIP);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 6; i++) {\\r\\n            goldRewards.push(PIRATE);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 10; i++) {\\r\\n            goldRewards.push(ULTRA_RARE_GOVERNOR);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 10; i++) {\\r\\n            goldRewards.push(ULTRA_RARE_ERNESTO);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 55; i++) {\\r\\n            goldRewards.push(RARE_GOVERNOR);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 55; i++) {\\r\\n            goldRewards.push(RARE_ERNESTO);\\r\\n        }\\r\\n\\r\\n        goldMinted = true;\\r\\n    }\\r\\n\\r\\n    function mintSilverRewards() external {\\r\\n        require(!silverMinted, \\\"ERROR: SILVER REWARDS HAVE BEEN MINTED\\\");\\r\\n\\r\\n        for (uint i = 0; i < 13; i++) {\\r\\n            silverRewards.push(SILVER_MINER);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 100; i++) {\\r\\n            silverRewards.push(COMMON_GOVERNOR);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 100; i++) {\\r\\n            silverRewards.push(COMMON_ERNESTO);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 120; i++) {\\r\\n            silverRewards.push(WOOD80);\\r\\n        }\\r\\n\\r\\n        silverMinted = true;\\r\\n    }\\r\\n\\r\\n    function mintBronzeRewards() external {\\r\\n        require(!bronzeMinted, \\\"ERROR: BRONZE REWARDS HAVE BEEN MINTED\\\");\\r\\n\\r\\n        for (uint i = 0; i < 5; i++) {\\r\\n            bronzeRewards.push(BRONZE_MINER);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 175; i++) {\\r\\n            bronzeRewards.push(WOOD60);\\r\\n        }\\r\\n\\r\\n        for (uint i = 0; i < 295; i++) {\\r\\n            bronzeRewards.push(WOOD50);\\r\\n        }\\r\\n\\r\\n        bronzeMinted = true;\\r\\n    }\\r\\n\\r\\n    function loadNFTPrizes(\\r\\n        uint[] calldata _shipPrizeIds,\\r\\n        uint[] calldata _piratePrizeIds,\\r\\n        uint[] calldata _minerPrizeIds\\r\\n    ) public onlyOwner {\\r\\n        shipPrizeIds = _shipPrizeIds;\\r\\n        piratePrizeIds = _piratePrizeIds;\\r\\n        minerPrizeIds = _minerPrizeIds;\\r\\n    }\\r\\n\\r\\n    ///// ETH REWARD MANAGEMENT /////\\r\\n    // Method to receive eth\\r\\n    receive() external payable {}\\r\\n\\r\\n    // Just in case of withdrawal\\r\\n    function withdrawEth(address to) external onlyOwner {\\r\\n        payable(to).transfer(address(this).balance);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/polygon/missions/Sailing4/MissionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport {InterfaceManager} from \\\"./InterfaceManager.sol\\\";\\r\\nimport {Recoverable} from \\\"../../../utils/Recoverable.sol\\\";\\r\\n\\r\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport {VRFConsumerBase} from \\\"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\\\";\\r\\nimport {ICardsManager} from \\\"./ICardsManager.sol\\\";\\r\\n\\r\\nabstract contract MissionBase is Pausable, Recoverable, VRFConsumerBase, InterfaceManager {\\r\\n\\r\\n    ///// STRUCTS /////\\r\\n    struct Mission {\\r\\n        address owner;\\r\\n        uint missionId;\\r\\n        uint completionTime;\\r\\n        uint16[] goldhunterIds;\\r\\n        uint16[] shipIds;\\r\\n        uint[] cardIds;\\r\\n        uint randomOutcome;\\r\\n        bool gotChainlinkResponse;\\r\\n    }\\r\\n\\r\\n    ///// EVENTS /////\\r\\n    event MissionStarted(uint missionId, uint crewSpeed, uint16[] goldhunterIds, uint16[] shipIds);\\r\\n\\r\\n    uint public missionIdCounter = 1;\\r\\n    mapping(uint => uint) missionIxById;\\r\\n    mapping(uint => Mission) public missionsById;\\r\\n    mapping(address => uint[]) public playerMissionIds;\\r\\n    mapping(bytes32 => uint) public requestIdToMissionId;\\r\\n    \\r\\n    bytes32 internal keyHash;\\r\\n    uint256 internal fee;\\r\\n    ICardsManager cardsManager;\\r\\n\\r\\n    constructor(\\r\\n        address _wood,\\r\\n        address _ggold,\\r\\n        address _goldhunters, \\r\\n        address _ships, \\r\\n        address _cards, \\r\\n        address _metadata,\\r\\n        address _speedCalculator,\\r\\n        address _cardsManager,\\r\\n        address _vrfCoordinator, \\r\\n        address _linkToken, \\r\\n        bytes32 _keyHash\\r\\n    )   VRFConsumerBase(\\r\\n            _vrfCoordinator,\\r\\n            _linkToken\\r\\n        )\\r\\n        InterfaceManager(\\r\\n            _wood,\\r\\n            _ggold,\\r\\n            _goldhunters,\\r\\n            _ships,\\r\\n            _cards,\\r\\n            _metadata,\\r\\n            _speedCalculator\\r\\n        )\\r\\n    {\\r\\n        keyHash = _keyHash;\\r\\n        fee = .0001 * 10 ** 18;\\r\\n\\r\\n        missionIdCounter = 0;\\r\\n        cardsManager = ICardsManager(_cardsManager);\\r\\n    }\\r\\n\\r\\n    ///// VIEW FUNCTIONS /////\\r\\n    function getPlayerMissions(address _player) public view returns (Mission[] memory) {\\r\\n        uint[] memory missionIds = playerMissionIds[_player];\\r\\n        Mission[] memory result = new Mission[](missionIds.length);\\r\\n\\r\\n        for(uint i=0; i < missionIds.length; i++) {\\r\\n            result[i] = (missionsById[missionIds[i]]);\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    ///// OWNER FUNCTIONS /////\\r\\n    function unpause() external onlyOwner {\\r\\n        require(LINK.balanceOf(address(this)) >= fee, \\\"ERROR: Contract is out of LINK - please alert the developers if you encounter this\\\");\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    function pause() external onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function deleteMission(address[] calldata _players, uint[] calldata _missionIds) external onlyOwner {\\r\\n        for(uint i = 0; i < _players.length; i++) {\\r\\n            _deleteMission(_players[i], _missionIds[i]);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    ///// MISSION FUNCTIONS /////\\r\\n    function _startMission(\\r\\n        uint16[] memory _goldhunterIds, \\r\\n        uint16[] memory _shipIds,\\r\\n        uint[] memory _cardIds,\\r\\n        uint _crewSpeed, \\r\\n        uint _distance\\r\\n    ) internal whenNotPaused {\\r\\n        missionsById[missionIdCounter] = Mission({\\r\\n            owner: msg.sender,\\r\\n            missionId: missionIdCounter,\\r\\n            completionTime: block.timestamp + _distance / _crewSpeed * 1 hours,\\r\\n            goldhunterIds: _goldhunterIds,\\r\\n            shipIds: _shipIds,\\r\\n            cardIds: _cardIds,\\r\\n            randomOutcome: 0,\\r\\n            gotChainlinkResponse: false\\r\\n        });\\r\\n\\r\\n        // Save the index position for a given player's mission in missionIxById to reference when unstaking\\r\\n        missionIxById[missionIdCounter] = playerMissionIds[msg.sender].length; \\r\\n        playerMissionIds[msg.sender].push(missionIdCounter);\\r\\n\\r\\n        for(uint i = 0; i < _goldhunterIds.length; i++) {\\r\\n            goldhunters.safeTransferFrom(msg.sender, address(this), _goldhunterIds[i]);\\r\\n        }\\r\\n\\r\\n        for(uint i = 0; i < _shipIds.length; i++) {\\r\\n            ships.safeTransferFrom(msg.sender, address(this), _shipIds[i]);\\r\\n        }\\r\\n\\r\\n        for(uint i = 0; i < _cardIds.length; i++) {\\r\\n            cards.safeTransferFrom(msg.sender, address(this), _cardIds[i], 1, \\\"\\\");\\r\\n        }\\r\\n\\r\\n        _getRandomNumber(missionIdCounter);\\r\\n        emit MissionStarted(missionIdCounter, _crewSpeed, _goldhunterIds, _shipIds);\\r\\n\\r\\n        missionIdCounter ++;\\r\\n    }\\r\\n\\r\\n    function _finishMission(uint _missionId) internal returns (uint randomOutcome) {\\r\\n        Mission memory mission = missionsById[_missionId];\\r\\n        \\r\\n        require(mission.owner == msg.sender, \\\"ERROR: Transaction Sender is not Mission Owner\\\");\\r\\n        require(mission.gotChainlinkResponse, \\\"ERROR: Have not received response from Chainlink\\\");\\r\\n        require(block.timestamp >= mission.completionTime, \\\"ERROR: The mission has not concluded yet\\\");\\r\\n\\r\\n        _returnMissionUnits(_missionId);\\r\\n        _deleteMission(mission.owner, _missionId);\\r\\n\\r\\n        return mission.randomOutcome;\\r\\n    }\\r\\n\\r\\n    function _abortMission(uint _missionId) internal {\\r\\n        Mission memory mission = missionsById[_missionId];\\r\\n        \\r\\n        require(mission.owner == msg.sender, \\\"ERROR: Transaction Sender is not Mission Owner\\\");\\r\\n\\r\\n        _returnMissionUnits(_missionId);\\r\\n        _deleteMission(mission.owner, _missionId);\\r\\n    }\\r\\n\\r\\n    function _returnMissionUnits(uint _missionId) internal {\\r\\n        Mission memory mission = missionsById[_missionId];\\r\\n\\r\\n        uint[] memory filteredCards = cardsManager.burnCards(mission.cardIds);\\r\\n        \\r\\n        for(uint i = 0; i < mission.goldhunterIds.length; i++) {\\r\\n            goldhunters.safeTransferFrom(address(this), mission.owner, mission.goldhunterIds[i]);\\r\\n        }\\r\\n\\r\\n        for(uint i = 0; i < mission.shipIds.length; i++) {\\r\\n            ships.safeTransferFrom(address(this), mission.owner, mission.shipIds[i]);\\r\\n        }\\r\\n\\r\\n        for(uint i = 0; i < filteredCards.length; i++) {\\r\\n            cards.safeTransferFrom(address(this), mission.owner, filteredCards[i], 1, \\\"\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _deleteMission(address _player, uint _missionId) internal {\\r\\n        uint missionIx = missionIxById[_missionId];\\r\\n        uint lastMissionId = playerMissionIds[_player][playerMissionIds[_player].length - 1];\\r\\n\\r\\n        // Replace finished mission with last mission, then pop last element\\r\\n        playerMissionIds[_player][missionIx] = lastMissionId;\\r\\n        missionIxById[lastMissionId] = missionIx;\\r\\n\\r\\n        playerMissionIds[_player].pop();\\r\\n    }\\r\\n\\r\\n    ///// CHAINLINK RANDOMNESS FUNCTIONS /////\\r\\n    function withdraw() external onlyOwner {\\r\\n        LINK.transferFrom(address(this), msg.sender, LINK.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function _getRandomNumber(uint _missionId) internal returns (bytes32 requestId) {\\r\\n        require(LINK.balanceOf(address(this)) >= fee, \\\"ERROR: Contract is out of LINK - please alert the developers if you encounter this\\\");\\r\\n        requestId =  requestRandomness(keyHash, fee);\\r\\n        requestIdToMissionId[requestId] = _missionId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Callback function used by VRF Coordinator\\r\\n     */\\r\\n    function fulfillRandomness(bytes32 requestId, uint256 _randomness) internal override {\\r\\n        missionsById[requestIdToMissionId[requestId]].randomOutcome = _randomness;\\r\\n        missionsById[requestIdToMissionId[requestId]].gotChainlinkResponse = true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/polygon/missions/Sailing4/InterfaceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport {ICoin, IToken, ICard, IGHGMetadata, SpeedCalculator} from \\\"../../../interfaces/Interfaces.sol\\\";\\r\\n\\r\\ncontract InterfaceManager {\\r\\n\\r\\n    ICoin public wood;\\r\\n    ICoin public ggold;\\r\\n    IToken public goldhunters;\\r\\n    IToken public ships;\\r\\n    ICard public cards;\\r\\n    IGHGMetadata public metadata;\\r\\n    SpeedCalculator public speedCalculator;\\r\\n\\r\\n    constructor(\\r\\n        address _wood,\\r\\n        address _ggold,\\r\\n        address _goldhunters,\\r\\n        address _ships,\\r\\n        address _cards,\\r\\n        address _metadata,\\r\\n        address _speedCalculator\\r\\n    ) {\\r\\n        wood = ICoin(_wood);\\r\\n        ggold = ICoin(_ggold);\\r\\n        goldhunters = IToken(_goldhunters);\\r\\n        ships = IToken(_ships);\\r\\n        cards = ICard(_cards);\\r\\n        metadata = IGHGMetadata(_metadata);\\r\\n        speedCalculator = SpeedCalculator(_speedCalculator);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/utils/Recoverable.sol\": {\r\n      \"content\": \"\\r\\n// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IToken, ICard} from \\\"../interfaces/Interfaces.sol\\\";\\r\\n\\r\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport {ERC721Holder} from \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\r\\nimport {ERC1155Holder} from \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC721Receiver} and {IERC1155Receiver} interfaces.\\r\\n *\\r\\n * Accepts all token transfers.\\r\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\r\\n */\\r\\ncontract Recoverable is Ownable, ERC721Holder, ERC1155Holder {\\r\\n\\r\\n    /**\\r\\n     * @dev Allows for the safeTransfer of ALL assets from this contract to a list of recipients\\r\\n     */\\r\\n    function transferOut(\\r\\n        bool[] calldata _isERC721,\\r\\n        address[] calldata _tokenAddressesToTransfer, \\r\\n        address[] calldata _recipients, \\r\\n        uint[] calldata _tokenIds, \\r\\n        uint[] calldata _amounts, \\r\\n        bytes[] calldata _data\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            (_isERC721.length == _tokenAddressesToTransfer.length) \\r\\n            && (_tokenAddressesToTransfer.length == _recipients.length) \\r\\n            && (_recipients.length == _tokenIds.length)\\r\\n            && (_tokenIds.length == _amounts.length) \\r\\n            && (_amounts.length == _data.length), \\\"ERROR: INVALID INPUT DATA - MISMATCHED LENGTHS\\\");\\r\\n\\r\\n        for(uint i = 0; i < _recipients.length; i++) {\\r\\n            if (_isERC721[i]) {\\r\\n                IToken(_tokenAddressesToTransfer[i]).safeTransferFrom(address(this), _recipients[i], _tokenIds[i]);\\r\\n            } else {\\r\\n                ICard(_tokenAddressesToTransfer[i]).safeTransferFrom(address(this), _recipients[i], _tokenIds[i], _amounts[i], _data[i]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Allows for the safeTransfer of all ERC721 assets from this contract to a list of recipients\\r\\n     */\\r\\n    function transferOut721(\\r\\n        address[] calldata _tokenAddressesToTransfer, \\r\\n        address[] calldata _recipients, \\r\\n        uint[] calldata _tokenIds\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            (_tokenAddressesToTransfer.length == _recipients.length) \\r\\n            && (_recipients.length == _tokenIds.length), \\r\\n            \\\"ERROR: INVALID INPUT DATA - MISMATCHED LENGTHS\\\");\\r\\n\\r\\n        for(uint i = 0; i < _recipients.length; i++) {\\r\\n            IToken(_tokenAddressesToTransfer[i]).safeTransferFrom(address(this), _recipients[i], _tokenIds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows for the safeTransfer of all ERC1155 assets from this contract to a list of recipients\\r\\n     */\\r\\n    function transferOut1155(\\r\\n        address[] calldata _tokenAddressesToTransfer, \\r\\n        address[] calldata _recipients, \\r\\n        uint[] calldata _tokenIds, \\r\\n        uint[] calldata _amounts, \\r\\n        bytes[] calldata _data\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            (_tokenAddressesToTransfer.length == _recipients.length) \\r\\n            && (_recipients.length == _tokenIds.length)\\r\\n            && (_tokenIds.length == _amounts.length) \\r\\n            && (_amounts.length == _data.length), \\r\\n            \\\"ERROR: INVALID INPUT DATA - MISMATCHED LENGTHS\\\");\\r\\n\\r\\n        for(uint i = 0; i < _recipients.length; i++) {\\r\\n            ICard(_tokenAddressesToTransfer[i]).safeTransferFrom(address(this), _recipients[i], _tokenIds[i], _amounts[i], _data[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows for the safeTransfer of a batch of ERC1155 assets from this contract to a recipient\\r\\n     */\\r\\n    function transferOut1155Batch(\\r\\n        address _tokenAddressToTransfer, \\r\\n        address _recipient, \\r\\n        uint[] calldata _tokenIds, \\r\\n        uint[] calldata _amounts, \\r\\n        bytes calldata _data\\r\\n    ) external onlyOwner {\\r\\n        require(_tokenIds.length == _amounts.length, \\\"ERROR: INVALID INPUT DATA - MISMATCHED LENGTHS\\\");\\r\\n        ICard(_tokenAddressToTransfer).safeBatchTransferFrom(address(this), _recipient, _tokenIds, _amounts, _data);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\n\\nimport \\\"./VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\\n\\n  /**\\n   * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\\n\\n  /**\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n    // the hash of the block containing this request to obtain the seed/input\\n    // which is finally passed to the VRF cryptographic machinery.\\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n    // nonces[_keyHash] must stay in sync with\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n    // This provides protection against the user repeating their input seed,\\n    // which would result in a predictable/duplicate output, if multiple such\\n    // requests appeared in the same block.\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface internal immutable LINK;\\n  address private immutable vrfCoordinator;\\n\\n  // Nonces for each VRF key from which randomness has been requested.\\n  //\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\\n    private nonces;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n  constructor(address _vrfCoordinator, address _link) {\\n    vrfCoordinator = _vrfCoordinator;\\n    LINK = LinkTokenInterface(_link);\\n  }\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/polygon/missions/Sailing4/ICardsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface ICardsManager {\\r\\n    function burnCards(uint[] memory _cardIds) external returns(uint[] memory);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface ICoin {\\r\\n    function mint(address account, uint amount) external;\\r\\n    function burn(address _from, uint _amount) external;\\r\\n    function balanceOf(address account) external returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IToken {\\r\\n    function ownerOf(uint id) external view returns (address);\\r\\n    function transferFrom(address from, address to, uint tokenId) external;\\r\\n    function safeTransferFrom(address from, address to, uint tokenId) external;\\r\\n    function isApprovedForAll(address owner, address operator) external returns(bool);\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n}\\r\\n\\r\\ninterface ICard {\\r\\n    function getSeriesName(uint _id) external view returns (string memory _name);\\r\\n    function safeTransferFrom(address from, address to, uint tokenId, uint amount, bytes memory data) external;\\r\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\r\\n    function mint(address _to, uint _id, uint _amount) external;\\r\\n    function burn(address _from, uint _id, uint _amount) external;\\r\\n}\\r\\n\\r\\ninterface IGHGMetadata {\\r\\n    ///// GENERIC GETTERS /////\\r\\n    function getGoldhunterMetadata(uint16 _tokenId) external view returns (string memory);\\r\\n    function getShipMetadata(uint16 _tokenId) external view returns (string memory);\\r\\n    function getHouseMetadata(uint16 _tokenId) external view returns (string memory);\\r\\n\\r\\n    ///// TRAIT GETTERS - SHIPS /////\\r\\n    function shipIsPirate(uint16 _tokenId) external view returns (bool);\\r\\n    function shipIsCrossedTheOcean(uint16 _tokenId) external view returns (bool);\\r\\n    function getShipBackground(uint16 _tokenId) external view returns (string memory);\\r\\n    function getShipShip(uint16 _tokenId) external view returns (string memory);\\r\\n    function getShipFlag(uint16 _tokenId) external view returns (string memory);\\r\\n    function getShipMast(uint16 _tokenId) external view returns (string memory);\\r\\n    function getShipAnchor(uint16 _tokenId) external view returns (string memory);\\r\\n    function getShipSail(uint16 _tokenId) external view returns (string memory);\\r\\n    function getShipWaves(uint16 _tokenId) external view returns (string memory);\\r\\n\\r\\n    ///// TRAIT GETTERS - HOUSES /////\\r\\n    function getHouseBackground(uint16 _tokenId) external view returns (string memory);\\r\\n    function getHouseType(uint16 _tokenId) external view returns (string memory);\\r\\n    function getHouseWindow(uint16 _tokenId) external view returns (string memory);\\r\\n    function getHouseDoor(uint16 _tokenId) external view returns (string memory);\\r\\n    function getHouseRoof(uint16 _tokenId) external view returns (string memory);\\r\\n    function getHouseForeground(uint16 _tokenId) external view returns (string memory);\\r\\n\\r\\n    ///// TRAIT GETTERS - GOLDHUNTERS /////\\r\\n    function goldhunterIsCrossedTheOcean(uint16 _tokenId) external view returns (bool);\\r\\n    function goldhunterIsPirate(uint16 _tokenId) external view returns (bool);\\r\\n    function getGoldhunterIsGen0(uint16 _tokenId) external pure returns (bool);\\r\\n    function getGoldhunterSkin(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterLegs(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterFeet(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterTshirt(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterHeadwear(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterMouth(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterNeck(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterSunglasses(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterTool(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterPegleg(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterHook(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterDress(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterFace(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterPatch(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterEars(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterHead(uint16 _tokenId) external view returns (string memory);\\r\\n    function getGoldhunterArm(uint16 _tokenId) external view returns (string memory);\\r\\n}\\r\\n\\r\\ninterface SpeedCalculator {\\r\\n    function getCrewSpeed(uint16[] calldata _goldhunterIds, uint[] calldata _cardIds) external view returns (uint speed);\\r\\n    function getCrewSpeed(uint16[] calldata _goldhunterIds, uint16[] calldata _shipIds, uint[] calldata _cardIds) external view returns (uint speed);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract VRFRequestIDBase {\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  ) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wood\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ggold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_goldhunters\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ships\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_metadata\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_speedCalculator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cardsManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_linkToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"missionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"crewSpeed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16[]\",\"name\":\"goldhunterIds\",\"type\":\"uint16[]\"},{\"indexed\":false,\"internalType\":\"uint16[]\",\"name\":\"shipIds\",\"type\":\"uint16[]\"}],\"name\":\"MissionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_loser\",\"type\":\"address\"}],\"name\":\"NoRewardWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_unlucky\",\"type\":\"address\"}],\"name\":\"OutOfBronzeRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_unlucky\",\"type\":\"address\"}],\"name\":\"OutOfGoldRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_unlucky\",\"type\":\"address\"}],\"name\":\"OutOfSilverRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"WonEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_cardName\",\"type\":\"string\"}],\"name\":\"WonGHGCard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"WonHouse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"WonMiner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"WonPirate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"WonShip\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WonWood\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAO_WALLET_POLYGON\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DISTANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MISSION_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RENTAL_COST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_missionIds\",\"type\":\"uint256[]\"}],\"name\":\"abortMissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bronzeRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cards\",\"outputs\":[{\"internalType\":\"contract ICard\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_players\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_missionIds\",\"type\":\"uint256[]\"}],\"name\":\"deleteMission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethWinners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_missionId\",\"type\":\"uint256\"}],\"name\":\"finishMission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_missionIds\",\"type\":\"uint256[]\"}],\"name\":\"finishMissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEthWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHouseWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getPlayerMissions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"missionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"completionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint16[]\",\"name\":\"goldhunterIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"shipIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"cardIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"randomOutcome\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"gotChainlinkResponse\",\"type\":\"bool\"}],\"internalType\":\"struct MissionBase.Mission[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ggold\",\"outputs\":[{\"internalType\":\"contract ICoin\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ggold_burned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"goldRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goldhunters\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"houseWinners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_shipPrizeIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_piratePrizeIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_minerPrizeIds\",\"type\":\"uint256[]\"}],\"name\":\"loadNFTPrizes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"contract IGHGMetadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minerPrizeIx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintBronzeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintGoldRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintSilverRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"missionIdCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"missionsById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"missionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"completionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"randomOutcome\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"gotChainlinkResponse\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piratePrizeIx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerMissionIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestIdToMissionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shipPrizeIx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ships\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"silverRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"speedCalculator\",\"outputs\":[{\"internalType\":\"contract SpeedCalculator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_goldhunterIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_shipIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_cardIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_rentedShip\",\"type\":\"bool\"}],\"name\":\"startMission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool[]\",\"name\":\"_isERC721\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"_tokenAddressesToTransfer\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"}],\"name\":\"transferOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenAddressesToTransfer\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_data\",\"type\":\"bytes[]\"}],\"name\":\"transferOut1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddressToTransfer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferOut1155Batch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenAddressesToTransfer\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"transferOut721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wood\",\"outputs\":[{\"internalType\":\"contract ICoin\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wood_burned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MissionImpl", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000006910e3e129523c9576061334ca650ea4c4456a0b00000000000000000000000006217a2e76604cb63451ac98401b898af038d4b2000000000000000000000000ef3700275e147c69af6a2e27e1f384c821cfc662000000000000000000000000d26c4aac84bec285ed9c8ef56b62283f78d2105c0000000000000000000000006025e879419ea497f5c0e438bc49adebfaf540fd000000000000000000000000bf90c483e8a2e8435cb7fcfc5dc3165c45eaf631000000000000000000000000eecc50cf191f94982aa4beb706d4220688fb90c00000000000000000000000000f0b5c734f4f11d14d9bf3c34b1a86a70d1a41ce0000000000000000000000003d2341adb2d31f1c5530cdc622016af293177ae0000000000000000000000000b0897686c545045afc77cf20ec7a532e3120e0f1f86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}