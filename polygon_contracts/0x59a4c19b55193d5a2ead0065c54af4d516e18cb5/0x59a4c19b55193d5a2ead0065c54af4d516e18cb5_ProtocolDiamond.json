{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/diamond/ProtocolDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../domain/BosonConstants.sol\\\";\\nimport { IAccessControl } from \\\"../interfaces/IAccessControl.sol\\\";\\nimport { IDiamondLoupe } from \\\"../interfaces/diamond/IDiamondLoupe.sol\\\";\\nimport { IDiamondCut } from \\\"../interfaces/diamond/IDiamondCut.sol\\\";\\nimport { DiamondLib } from \\\"./DiamondLib.sol\\\";\\nimport { JewelerLib } from \\\"./JewelerLib.sol\\\";\\n\\n/**\\n * @title ProtocolDiamond\\n *\\n * @notice Provides Diamond functionality based on Nick Mudge's gas-optimized diamond-2 reference,\\n * with modifications to support role-based access and management of\\n * supported interfaces. Also added copious code comments throughout.\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ncontract ProtocolDiamond {\\n    /**\\n     * @notice Constructor\\n     *\\n     * - Stores the access controller\\n     * - Makes the initial facet cuts\\n     * - Declares support for interfaces\\n     *\\n     * @param _accessController - the Boson Protocol AccessController\\n     * @param _facetCuts - the initial facet cuts to make\\n     * @param _interfaceIds - the initially supported ERC-165 interface ids\\n     */\\n    constructor(\\n        IAccessControl _accessController,\\n        IDiamondCut.FacetCut[] memory _facetCuts,\\n        bytes4[] memory _interfaceIds\\n    ) {\\n        require(address(_accessController) != address(0), INVALID_ADDRESS);\\n\\n        // Get the DiamondStorage struct\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n\\n        // Set the AccessController instance\\n        ds.accessController = _accessController;\\n\\n        // Cut the diamond with the given facets\\n        JewelerLib.diamondCut(_facetCuts, address(0), new bytes(0));\\n\\n        // Add supported interfaces\\n        for (uint8 x = 0; x < _interfaceIds.length; x++) {\\n            DiamondLib.addSupportedInterface(_interfaceIds[x]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Fallback function. Is called when the specified function doesn't exist.\\n     *\\n     * Finds facet for function that is called and executes the\\n     * function if a facet is found and returns any value.\\n     */\\n    fallback() external payable {\\n        // Get the DiamondStorage struct\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n\\n        // Make sure the function exists\\n        address facet = address(bytes20(ds.facets[msg.sig]));\\n        require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n\\n        // Invoke the function with delagatecall\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// Contract can receive ETH\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/domain/BosonConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.9;\\n\\n// Access Control Roles\\nbytes32 constant ADMIN = keccak256(\\\"ADMIN\\\"); // Role Admin\\nbytes32 constant PAUSER = keccak256(\\\"PAUSER\\\"); // Role for pausing the protocol\\nbytes32 constant PROTOCOL = keccak256(\\\"PROTOCOL\\\"); // Role for facets of the ProtocolDiamond\\nbytes32 constant CLIENT = keccak256(\\\"CLIENT\\\"); // Role for clients of the ProtocolDiamond\\nbytes32 constant UPGRADER = keccak256(\\\"UPGRADER\\\"); // Role for performing contract and config upgrades\\nbytes32 constant FEE_COLLECTOR = keccak256(\\\"FEE_COLLECTOR\\\"); // Role for collecting fees from the protocol\\n\\n// Revert Reasons: Pause related\\nstring constant NO_REGIONS_SPECIFIED = \\\"Must specify at least one region to pause\\\";\\nstring constant REGION_DUPLICATED = \\\"A region may only be specified once\\\";\\nstring constant ALREADY_PAUSED = \\\"Protocol is already paused\\\";\\nstring constant NOT_PAUSED = \\\"Protocol is not currently paused\\\";\\nstring constant REGION_PAUSED = \\\"This region of the protocol is currently paused\\\";\\n\\n// Revert Reasons: General\\nstring constant INVALID_ADDRESS = \\\"Invalid address\\\";\\nstring constant INVALID_STATE = \\\"Invalid state\\\";\\nstring constant ARRAY_LENGTH_MISMATCH = \\\"Array length mismatch\\\";\\n\\n// Reentrancy guard\\nstring constant REENTRANCY_GUARD = \\\"ReentrancyGuard: reentrant call\\\";\\nuint256 constant NOT_ENTERED = 1;\\nuint256 constant ENTERED = 2;\\n\\n// Revert Reasons: Facet initializer related\\nstring constant ALREADY_INITIALIZED = \\\"Already initialized\\\";\\n\\n// Revert Reasons: Access related\\nstring constant ACCESS_DENIED = \\\"Access denied, caller doesn't have role\\\";\\nstring constant NOT_OPERATOR = \\\"Not seller's operator\\\";\\nstring constant NOT_ADMIN = \\\"Not admin\\\";\\nstring constant NOT_OPERATOR_AND_CLERK = \\\"Not operator and clerk\\\";\\nstring constant NOT_ADMIN_OPERATOR_AND_CLERK = \\\"Not admin, operator and clerk\\\";\\nstring constant NOT_BUYER_OR_SELLER = \\\"Not buyer or seller\\\";\\nstring constant NOT_VOUCHER_HOLDER = \\\"Not current voucher holder\\\";\\nstring constant NOT_BUYER_WALLET = \\\"Not buyer's wallet address\\\";\\nstring constant NOT_AGENT_WALLET = \\\"Not agent's wallet address\\\";\\nstring constant NOT_DISPUTE_RESOLVER_OPERATOR = \\\"Not dispute resolver's operator address\\\";\\n\\n// Revert Reasons: Account-related\\nstring constant NO_SUCH_SELLER = \\\"No such seller\\\";\\nstring constant MUST_BE_ACTIVE = \\\"Account must be active\\\";\\nstring constant SELLER_ADDRESS_MUST_BE_UNIQUE = \\\"Seller address cannot be assigned to another seller Id\\\";\\nstring constant BUYER_ADDRESS_MUST_BE_UNIQUE = \\\"Buyer address cannot be assigned to another buyer Id\\\";\\nstring constant DISPUTE_RESOLVER_ADDRESS_MUST_BE_UNIQUE = \\\"Dispute resolver address cannot be assigned to another dispute resolver Id\\\";\\nstring constant AGENT_ADDRESS_MUST_BE_UNIQUE = \\\"Agent address cannot be assigned to another agent Id\\\";\\nstring constant NO_SUCH_BUYER = \\\"No such buyer\\\";\\nstring constant NO_SUCH_AGENT = \\\"No such agent\\\";\\nstring constant WALLET_OWNS_VOUCHERS = \\\"Wallet address owns vouchers\\\";\\nstring constant NO_SUCH_DISPUTE_RESOLVER = \\\"No such dispute resolver\\\";\\nstring constant INVALID_ESCALATION_PERIOD = \\\"Invalid escalation period\\\";\\nstring constant INVALID_AMOUNT_DISPUTE_RESOLVER_FEES = \\\"Dispute resolver fees are not present or exceed maximum dispute resolver fees in a single transaction\\\";\\nstring constant DUPLICATE_DISPUTE_RESOLVER_FEES = \\\"Duplicate dispute resolver fee\\\";\\nstring constant DISPUTE_RESOLVER_FEE_NOT_FOUND = \\\"Dispute resolver fee not found\\\";\\nstring constant SELLER_ALREADY_APPROVED = \\\"Seller id is approved already\\\";\\nstring constant SELLER_NOT_APPROVED = \\\"Seller id is not approved\\\";\\nstring constant INVALID_AMOUNT_ALLOWED_SELLERS = \\\"Allowed sellers are not present or exceed maximum allowed sellers in a single transaction\\\";\\nstring constant INVALID_AUTH_TOKEN_TYPE = \\\"Invalid AuthTokenType\\\";\\nstring constant ADMIN_OR_AUTH_TOKEN = \\\"An admin address or an auth token is required\\\";\\nstring constant AUTH_TOKEN_MUST_BE_UNIQUE = \\\"Auth token cannot be assigned to another entity of the same type\\\";\\nstring constant INVALID_AGENT_FEE_PERCENTAGE = \\\"Sum of agent fee percentage and protocol fee percentage should be <= max fee percentage limit\\\";\\n\\n// Revert Reasons: Offer related\\nstring constant NO_SUCH_OFFER = \\\"No such offer\\\";\\nstring constant OFFER_PERIOD_INVALID = \\\"Offer period invalid\\\";\\nstring constant OFFER_PENALTY_INVALID = \\\"Offer penalty invalid\\\";\\nstring constant OFFER_MUST_BE_ACTIVE = \\\"Offer must be active\\\";\\nstring constant OFFER_MUST_BE_UNIQUE = \\\"Offer must be unique to a group\\\";\\nstring constant OFFER_HAS_BEEN_VOIDED = \\\"Offer has been voided\\\";\\nstring constant OFFER_HAS_EXPIRED = \\\"Offer has expired\\\";\\nstring constant OFFER_NOT_AVAILABLE = \\\"Offer is not yet available\\\";\\nstring constant OFFER_SOLD_OUT = \\\"Offer has sold out\\\";\\nstring constant CANNOT_COMMIT = \\\"Caller cannot commit\\\";\\nstring constant EXCHANGE_FOR_OFFER_EXISTS = \\\"Exchange for offer exists\\\";\\nstring constant AMBIGUOUS_VOUCHER_EXPIRY = \\\"Exactly one of voucherRedeemableUntil and voucherValid must be non zero\\\";\\nstring constant REDEMPTION_PERIOD_INVALID = \\\"Redemption period invalid\\\";\\nstring constant INVALID_DISPUTE_PERIOD = \\\"Invalid dispute period\\\";\\nstring constant INVALID_RESOLUTION_PERIOD = \\\"Invalid resolution period\\\";\\nstring constant INVALID_DISPUTE_RESOLVER = \\\"Invalid dispute resolver\\\";\\nstring constant INVALID_QUANTITY_AVAILABLE = \\\"Invalid quantity available\\\";\\nstring constant DR_UNSUPPORTED_FEE = \\\"Dispute resolver does not accept this token\\\";\\nstring constant AGENT_FEE_AMOUNT_TOO_HIGH = \\\"Sum of agent fee amount and protocol fee amount should be <= offer fee limit\\\";\\n\\n// Revert Reasons: Group related\\nstring constant NO_SUCH_GROUP = \\\"No such group\\\";\\nstring constant OFFER_NOT_IN_GROUP = \\\"Offer not part of the group\\\";\\nstring constant TOO_MANY_OFFERS = \\\"Exceeded maximum offers in a single transaction\\\";\\nstring constant NOTHING_UPDATED = \\\"Nothing updated\\\";\\nstring constant INVALID_CONDITION_PARAMETERS = \\\"Invalid condition parameters\\\";\\n\\n// Revert Reasons: Exchange related\\nstring constant NO_SUCH_EXCHANGE = \\\"No such exchange\\\";\\nstring constant DISPUTE_PERIOD_NOT_ELAPSED = \\\"Dispute period has not yet elapsed\\\";\\nstring constant VOUCHER_NOT_REDEEMABLE = \\\"Voucher not yet valid or already expired\\\";\\nstring constant VOUCHER_EXTENSION_NOT_VALID = \\\"Proposed date is not later than the current one\\\";\\nstring constant VOUCHER_STILL_VALID = \\\"Voucher still valid\\\";\\nstring constant VOUCHER_HAS_EXPIRED = \\\"Voucher has expired\\\";\\nstring constant TOO_MANY_EXCHANGES = \\\"Exceeded maximum exchanges in a single transaction\\\";\\nstring constant EXCHANGE_IS_NOT_IN_A_FINAL_STATE = \\\"Exchange is not in a final state\\\";\\n\\n// Revert Reasons: Twin related\\nstring constant NO_SUCH_TWIN = \\\"No such twin\\\";\\nstring constant NO_TRANSFER_APPROVED = \\\"No transfer approved\\\";\\nstring constant TWIN_TRANSFER_FAILED = \\\"Twin could not be transferred\\\";\\nstring constant UNSUPPORTED_TOKEN = \\\"Unsupported token\\\";\\nstring constant BUNDLE_FOR_TWIN_EXISTS = \\\"Bundle for twin exists\\\";\\nstring constant INVALID_SUPPLY_AVAILABLE = \\\"supplyAvailable can't be zero\\\";\\nstring constant INVALID_AMOUNT = \\\"Invalid twin amount\\\";\\nstring constant INVALID_TWIN_PROPERTY = \\\"Invalid property for selected token type\\\";\\nstring constant INVALID_TWIN_TOKEN_RANGE = \\\"Token range is already being used in another twin\\\";\\nstring constant INVALID_TOKEN_ADDRESS = \\\"Token address is a contract that doesn't implement the interface for selected token type\\\";\\n\\n// Revert Reasons: Bundle related\\nstring constant NO_SUCH_BUNDLE = \\\"No such bundle\\\";\\nstring constant TWIN_NOT_IN_BUNDLE = \\\"Twin not part of the bundle\\\";\\nstring constant OFFER_NOT_IN_BUNDLE = \\\"Offer not part of the bundle\\\";\\nstring constant TOO_MANY_TWINS = \\\"Exceeded maximum twins in a single transaction\\\";\\nstring constant BUNDLE_OFFER_MUST_BE_UNIQUE = \\\"Offer must be unique to a bundle\\\";\\nstring constant BUNDLE_TWIN_MUST_BE_UNIQUE = \\\"Twin must be unique to a bundle\\\";\\nstring constant EXCHANGE_FOR_BUNDLED_OFFERS_EXISTS = \\\"Exchange for the bundled offers exists\\\";\\nstring constant INSUFFICIENT_TWIN_SUPPLY_TO_COVER_BUNDLE_OFFERS = \\\"Insufficient twin supplyAvailable to cover total quantity of bundle offers\\\";\\nstring constant BUNDLE_REQUIRES_AT_LEAST_ONE_TWIN_AND_ONE_OFFER = \\\"Bundle must have at least one twin and one offer\\\";\\n\\n// Revert Reasons: Funds related\\nstring constant NATIVE_WRONG_ADDRESS = \\\"Native token address must be 0\\\";\\nstring constant NATIVE_WRONG_AMOUNT = \\\"Transferred value must match amount\\\";\\nstring constant TOKEN_NAME_UNSPECIFIED = \\\"Token name unspecified\\\";\\nstring constant NATIVE_CURRENCY = \\\"Native currency\\\";\\nstring constant TOO_MANY_TOKENS = \\\"Too many tokens\\\";\\nstring constant TOKEN_AMOUNT_MISMATCH = \\\"Number of amounts should match number of tokens\\\";\\nstring constant NOTHING_TO_WITHDRAW = \\\"Nothing to withdraw\\\";\\nstring constant NOT_AUTHORIZED = \\\"Not authorized to withdraw\\\";\\nstring constant TOKEN_TRANSFER_FAILED = \\\"Token transfer failed\\\";\\nstring constant INSUFFICIENT_VALUE_RECEIVED = \\\"Insufficient value received\\\";\\nstring constant INSUFFICIENT_AVAILABLE_FUNDS = \\\"Insufficient available funds\\\";\\nstring constant NATIVE_NOT_ALLOWED = \\\"Transfer of native currency not allowed\\\";\\n\\n// Revert Reasons: Meta-Transactions related\\nstring constant NONCE_USED_ALREADY = \\\"Nonce used already\\\";\\nstring constant FUNCTION_CALL_NOT_SUCCESSFUL = \\\"Function call not successful\\\";\\nstring constant INVALID_FUNCTION_SIGNATURE = \\\"functionSignature can not be of executeMetaTransaction method\\\";\\nstring constant SIGNER_AND_SIGNATURE_DO_NOT_MATCH = \\\"Signer and signature do not match\\\";\\nstring constant INVALID_FUNCTION_NAME = \\\"Invalid function name\\\";\\nstring constant INVALID_SIGNATURE = \\\"Invalid signature\\\";\\n\\n// Revert Reasons: Dispute related\\nstring constant DISPUTE_PERIOD_HAS_ELAPSED = \\\"Dispute period has already elapsed\\\";\\nstring constant DISPUTE_HAS_EXPIRED = \\\"Dispute has expired\\\";\\nstring constant INVALID_BUYER_PERCENT = \\\"Invalid buyer percent\\\";\\nstring constant DISPUTE_STILL_VALID = \\\"Dispute still valid\\\";\\nstring constant INVALID_DISPUTE_TIMEOUT = \\\"Invalid dispute timeout\\\";\\nstring constant TOO_MANY_DISPUTES = \\\"Exceeded maximum disputes in a single transaction\\\";\\nstring constant ESCALATION_NOT_ALLOWED = \\\"Disputes without dispute resolver cannot be escalated\\\";\\n\\n// Revert Reasons: Config related\\nstring constant FEE_PERCENTAGE_INVALID = \\\"Percentage representation must be less than 10000\\\";\\nstring constant VALUE_ZERO_NOT_ALLOWED = \\\"Value must be greater than 0\\\";\\n\\n// EIP712Lib\\nstring constant PROTOCOL_NAME = \\\"Boson Protocol\\\";\\nstring constant PROTOCOL_VERSION = \\\"V2\\\";\\nbytes32 constant EIP712_DOMAIN_TYPEHASH = keccak256(\\n    bytes(\\\"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\\\")\\n);\\n\\n// BosonVoucher\\nstring constant VOUCHER_NAME = \\\"Boson Voucher\\\";\\nstring constant VOUCHER_SYMBOL = \\\"BOSON_VOUCHER\\\";\\n\\n// Meta Transactions - Structs\\nbytes32 constant META_TRANSACTION_TYPEHASH = keccak256(\\n    bytes(\\n        \\\"MetaTransaction(uint256 nonce,address from,address contractAddress,string functionName,bytes functionSignature)\\\"\\n    )\\n);\\nbytes32 constant OFFER_DETAILS_TYPEHASH = keccak256(\\\"MetaTxOfferDetails(address buyer,uint256 offerId)\\\");\\nbytes32 constant META_TX_COMMIT_TO_OFFER_TYPEHASH = keccak256(\\n    \\\"MetaTxCommitToOffer(uint256 nonce,address from,address contractAddress,string functionName,MetaTxOfferDetails offerDetails)MetaTxOfferDetails(address buyer,uint256 offerId)\\\"\\n);\\nbytes32 constant EXCHANGE_DETAILS_TYPEHASH = keccak256(\\\"MetaTxExchangeDetails(uint256 exchangeId)\\\");\\nbytes32 constant META_TX_EXCHANGE_TYPEHASH = keccak256(\\n    \\\"MetaTxExchange(uint256 nonce,address from,address contractAddress,string functionName,MetaTxExchangeDetails exchangeDetails)MetaTxExchangeDetails(uint256 exchangeId)\\\"\\n);\\nbytes32 constant FUND_DETAILS_TYPEHASH = keccak256(\\n    \\\"MetaTxFundDetails(uint256 entityId,address[] tokenList,uint256[] tokenAmounts)\\\"\\n);\\nbytes32 constant META_TX_FUNDS_TYPEHASH = keccak256(\\n    \\\"MetaTxFund(uint256 nonce,address from,address contractAddress,string functionName,MetaTxFundDetails fundDetails)MetaTxFundDetails(uint256 entityId,address[] tokenList,uint256[] tokenAmounts)\\\"\\n);\\nbytes32 constant DISPUTE_RESOLUTION_DETAILS_TYPEHASH = keccak256(\\n    \\\"MetaTxDisputeResolutionDetails(uint256 exchangeId,uint256 buyerPercentBasisPoints,bytes32 sigR,bytes32 sigS,uint8 sigV)\\\"\\n);\\nbytes32 constant META_TX_DISPUTE_RESOLUTIONS_TYPEHASH = keccak256(\\n    \\\"MetaTxDisputeResolution(uint256 nonce,address from,address contractAddress,string functionName,MetaTxDisputeResolutionDetails disputeResolutionDetails)MetaTxDisputeResolutionDetails(uint256 exchangeId,uint256 buyerPercentBasisPoints,bytes32 sigR,bytes32 sigS,uint8 sigV)\\\"\\n);\\n\\n// Function names\\nstring constant COMMIT_TO_OFFER = \\\"commitToOffer(address,uint256)\\\";\\nstring constant CANCEL_VOUCHER = \\\"cancelVoucher(uint256)\\\";\\nstring constant REDEEM_VOUCHER = \\\"redeemVoucher(uint256)\\\";\\nstring constant COMPLETE_EXCHANGE = \\\"completeExchange(uint256)\\\";\\nstring constant WITHDRAW_FUNDS = \\\"withdrawFunds(uint256,address[],uint256[])\\\";\\nstring constant RETRACT_DISPUTE = \\\"retractDispute(uint256)\\\";\\nstring constant RAISE_DISPUTE = \\\"raiseDispute(uint256)\\\";\\nstring constant ESCALATE_DISPUTE = \\\"escalateDispute(uint256)\\\";\\nstring constant RESOLVE_DISPUTE = \\\"resolveDispute(uint256,uint256,bytes32,bytes32,uint8)\\\";\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/diamond/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/**\\n * @title IDiamondLoupe\\n *\\n * @notice Provides Diamond Facet inspection functionality.\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * The ERC-165 identifier for this interface is: 0x48e2b093\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n */\\ninterface IDiamondLoupe {\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /**\\n     *  @notice Gets all facets and their selectors.\\n     *\\n     *  @return facets_ - array of Facets\\n     */\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /**\\n     * @notice Gets all the function selectors supported by a specific facet.\\n     *\\n     * @param _facet  - the facet address\\n     * @return facetFunctionSelectors_ - the selectors associated with a facet address\\n     */\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /**\\n     * @notice Gets all the facet addresses used by a diamond.\\n     *\\n     * @return facetAddresses_ - array of addresses\\n     */\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    /**\\n     * @notice Gets the facet that supports the given selector.\\n     *\\n     * @dev If facet is not found return address(0).\\n     *\\n     * @param _functionSelector - the function selector.\\n     * @return facetAddress_ - the facet address.\\n     */\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/diamond/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/**\\n * @title IDiamondCut\\n *\\n * @notice Manages Diamond Facets.\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * The ERC-165 identifier for this interface is: 0x1f931c1c\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n */\\ninterface IDiamondCut {\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /**\\n     * @notice Cuts facets of the Diamond.\\n     *\\n     * Adds/replaces/removes any number of function selectors.\\n     *\\n     * If populated, _calldata is executed with delegatecall on _init\\n     *\\n     * Reverts if caller does not have UPGRADER role\\n     *\\n     * @param _facetCuts - contains the facet addresses and function selectors\\n     * @param _init - the address of the contract or facet to execute _calldata\\n     * @param _calldata - a function call, including function selector and arguments\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata _facetCuts,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/DiamondLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport { IAccessControl } from \\\"../interfaces/IAccessControl.sol\\\";\\nimport { IDiamondCut } from \\\"../interfaces/diamond/IDiamondCut.sol\\\";\\n\\n/**\\n * @title DiamondLib\\n *\\n * @notice Provides Diamond storage slot and supported interface checks.\\n *\\n * @notice Based on Nick Mudge's gas-optimized diamond-2 reference,\\n * with modifications to support role-based access and management of\\n * supported interfaces. Also added copious code comments throughout.\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * N.B. Facet management functions from original `DiamondLib` were refactored/extracted\\n * to JewelerLib, since business facets also use this library for access control and\\n * managing supported interfaces.\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\nlibrary DiamondLib {\\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // Maps function selectors to the facets that execute the functions\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // Array of slots of function selectors.\\n        // Each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // Used to query if a contract implement is an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // The Boson Protocol AccessController\\n        IAccessControl accessController;\\n    }\\n\\n    /**\\n     * @notice Gets the Diamond storage slot.\\n     *\\n     * @return ds - Diamond storage slot cast to DiamondStorage\\n     */\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @notice Adds a supported interface to the Diamond.\\n     *\\n     * @param _interfaceId - the interface to add\\n     */\\n    function addSupportedInterface(bytes4 _interfaceId) internal {\\n        // Get the DiamondStorage struct\\n        DiamondStorage storage ds = diamondStorage();\\n\\n        // Flag the interfaces as supported\\n        ds.supportedInterfaces[_interfaceId] = true;\\n    }\\n\\n    /**\\n     * @notice Checks if a specific interface is supported.\\n     * Implementation of ERC-165 interface detection standard.\\n     *\\n     * @param _interfaceId - the sighash of the given interface\\n     * @return - whether or not the interface is supported\\n     */\\n    function supportsInterface(bytes4 _interfaceId) internal view returns (bool) {\\n        // Get the DiamondStorage struct\\n        DiamondStorage storage ds = diamondStorage();\\n\\n        // Return the value\\n        return ds.supportedInterfaces[_interfaceId];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/JewelerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport { DiamondLib } from \\\"./DiamondLib.sol\\\";\\nimport { IDiamondCut } from \\\"../interfaces/diamond/IDiamondCut.sol\\\";\\n\\n/**\\n * @title JewelerLib\\n *\\n * @notice Provides facet management functions\\n *\\n * @notice Based on Nick Mudge's gas-optimized diamond-2 reference,\\n * with modifications to support role-based access and management of\\n * supported interfaces. Also added copious code comments throughout.\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * N.B. The original `LibDiamond` contract used single-owner security scheme,\\n * but this one uses role-based access via the Boson Protocol AccessController.\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\n\\nlibrary JewelerLib {\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    bytes32 internal constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 internal constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    /**\\n     * @notice Cuts facets of the Diamond.\\n     *\\n     * Adds/replaces/removes any number of function selectors.\\n     *\\n     * If populated, _calldata is executed with delegatecall on _init.\\n     *\\n     * @param _facetCuts - contains the facet addresses and function selectors\\n     * @param _init - the address of the contract or facet to execute _calldata\\n     * @param _calldata - a function call, including function selector and arguments\\n     */\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _facetCuts,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        // Get the diamond storage slot\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n\\n        // Determine how many existing selectors we have\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n\\n        // Check if last selector slot is full\\n        // N.B.: selectorCount & 7 is a gas-efficient equivalent to selectorCount % 8\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // N.B.: selectorCount >> 3 is a gas-efficient equivalent to selectorCount / 8\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n        }\\n\\n        // Cut the facets\\n        for (uint256 facetIndex; facetIndex < _facetCuts.length; facetIndex++) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _facetCuts[facetIndex].facetAddress,\\n                _facetCuts[facetIndex].action,\\n                _facetCuts[facetIndex].functionSelectors\\n            );\\n        }\\n\\n        // Update the selector count if it changed\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n\\n        // Update last selector slot\\n        // N.B.: selectorCount & 7 is a gas-efficient equivalent to selectorCount % 8\\n        if (selectorCount & 7 > 0) {\\n            // N.B.: selectorCount >> 3 is a gas-efficient equivalent to selectorCount / 8\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n\\n        // Notify listeners of state change\\n        emit DiamondCut(_facetCuts, _init, _calldata);\\n\\n        // Initialize the facet\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /**\\n     * @notice Maintains the selectors in a FacetCut.\\n     *\\n     * N.B. This method is unbelievably long and dense.\\n     * It hails from the diamond-2 reference and works\\n     * under test.\\n     *\\n     * I've added comments to try and reason about it.\\n     * - CLH\\n     *\\n     * @param _selectorCount - the current selectorCount\\n     * @param _selectorSlot - the selector slot\\n     * @param _newFacetAddress - the facet address of the new or replacement function\\n     * @param _action - the action to perform. See: {IDiamondCut.FacetCutAction}\\n     * @param _selectors - the selectors to modify\\n     */\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        // Make sure there are some selectors to work with\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n\\n        // Add a selector\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            // Make sure facet being added has code\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n\\n            // Iterate selectors\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                // Make sure function doesn't already exist\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(\\n                    address(bytes20(oldFacet)) == address(0),\\n                    \\\"LibDiamondCut: Can't add function that already exists\\\"\\n                );\\n\\n                // add facet for selector\\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n\\n                // clear selector position in slot and add selector\\n                _selectorSlot =\\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n\\n                // Increment selector count\\n                _selectorCount++;\\n            }\\n\\n            // Replace a selector\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            // Make sure replacement facet has code\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n\\n            // Iterate selectors\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                // Make sure function doesn't already exist\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(\\n                    oldFacetAddress != _newFacetAddress,\\n                    \\\"LibDiamondCut: Can't replace function with same function\\\"\\n                );\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n\\n                // replace old facet address\\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n            }\\n\\n            // Remove a selector\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            // Make sure facet address is zero address\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n\\n            // Get the selector slot count and index to selector in slot\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n\\n            // Iterate selectors\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\\n                // Get previous selector slot, wrapping around to last from zero\\n                if (_selectorSlot == 0) {\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n\\n                // Remove selector, swapping in with last selector in last slot\\n                // N.B. adding a block here prevents stack too deep error\\n                {\\n                    // get selector and facet, making sure it exists\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(\\n                        address(bytes20(oldFacet)) != address(0),\\n                        \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n                    );\\n\\n                    // only useful if immutable functions exist\\n                    require(\\n                        address(bytes20(oldFacet)) != address(this),\\n                        \\\"LibDiamondCut: Can't remove immutable function\\\"\\n                    );\\n\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n\\n                // Update selector slot if count changed\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n\\n                // delete selector\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n            }\\n\\n            // Update selector count\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        }\\n\\n        // return updated selector count and selector slot for\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    /**\\n     * @notice Calls a facet's initializer.\\n     *\\n     * @param _init - the address of the facet to be initialized\\n     * @param _calldata - the initializer function call, including function selector and arguments\\n     */\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        // If _init is not populated, then _calldata must also be unpopulated\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but _calldata is not empty\\\");\\n        } else {\\n            // Revert if _calldata is not populated\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n\\n            // Make sure address to be initialized has code\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n\\n            // If _init and _calldata are populated, call initializer\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n\\n            // Handle result\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks that the given address has code.\\n     *\\n     * Reverts if address has no contract code\\n     *\\n     * @param _contract - the contract to check\\n     * @param _errorMessage - the revert reason to throw\\n     */\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IAccessControl\",\"name\":\"_accessController\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"_interfaceIds\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ProtocolDiamond", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009c867632dfe6b70d83dfe7865cf8510c168afd40000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000003200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000200000000000000000000000000ba596ee5c051faf6b263d457835e65a26661382c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000004cdffacc60000000000000000000000000000000000000000000000000000000052ef6b2c00000000000000000000000000000000000000000000000000000000adfca15e000000000000000000000000000000000000000000000000000000007a0ed627000000000000000000000000000000000000000000000000000000000000000000000000000000003ce6a434dad2ace6c8dbec6dc007d6a8fad068e90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000011f931c1c00000000000000000000000000000000000000000000000000000000000000000000000000000000b5e1d2c4cc71d44a601efc94fe68c9202ce6b29400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000101ffc9a700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000348e2b093000000000000000000000000000000000000000000000000000000001f931c1c0000000000000000000000000000000000000000000000000000000001ffc9a700000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x85a52d353027e28739f57a212324ccd05ef83008", "SwarmSource": ""}