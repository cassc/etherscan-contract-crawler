{"SourceCode": "{\"AppBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// AppBase.sol : CryptoStacks(tm) Stacks721 by j0zf at ApogeeINVENT 2021-02-28\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\nimport \\\"./SafeMath.sol\\\"; \\nimport \\\"./Strings.sol\\\"; \\nimport \\\"./Market.sol\\\";\\nimport \\\"./Holdings.sol\\\";\\n\\nabstract contract AppBase { \\n\\tusing SafeMath for uint256;\\n\\tusing Strings for uint256;\\n\\tusing Market for Market.TokenContract;\\n\\tusing Market for Market.Listing;\\n\\tusing Holdings for Holdings.HoldingsTable;\\n\\n\\t//\\tfrom Library Holdings.sol\\n\\tevent AccountCredited(uint32 indexed accountType, address indexed account, uint256 amount, uint256 balance);\\n\\tevent AccountDebited(uint32 indexed accountType, address indexed account, uint256 amount, uint256 balance);\\n\\tevent PoolCredited(uint32 poolType, uint256 amount, uint256 balance);\\n\\tevent PoolDebited(uint32 indexed poolType, uint256 amount, uint256 balance);\\n\\n\\tbool internal _paused;\\n\\tuint32 internal _networkId;\\n\\tmapping(string =\\u003e string) internal _values; // version, banner, whatever, etc..\\n\\tMarket.TokenContract[] internal _tokenContracts;\\n\\tMarket.Listing[] internal _listings; // indexed by listingId\\n\\tmapping(address =\\u003e uint256[]) internal _activeListingIds; // address(0) is ALL active listings\\n\\tmapping(address =\\u003e mapping(uint256 =\\u003e uint256)) internal _activeListingIdIndexes; // address(0) is ALL active listings, Maintains Index into _activeListingIds \\n\\tmapping(uint256 =\\u003e mapping(string =\\u003e mapping(uint256 =\\u003e uint256))) internal _contractListingIds; // __[contractId][\\\"token\\\"|\\\"series\\\"][id] =\\u003e listingId\\n\\n\\tHoldings.HoldingsTable internal _holdingsTable;\\n\\n\\tmapping(uint32 =\\u003e uint256) internal _conversionTable;\\n\\t// ^^ _conversionTable[peg] =\\u003e conversion multiplier so Value * Multiplier = Approx Value in Wei\\n\\t// ^^ peg is the index for the container of the conversion multiplier: 0:Wei 1:USD\\n\\n\\tmapping(uint32 =\\u003e mapping(address =\\u003e bool)) internal _roles; \\n\\t// ^^ _roles[roleType][address] =\\u003e true : \\\"Has Role\\\"\\n\\t// ^^ roleType 0:Null 1:Admin 2:Manager 3:Publisher\\n\\tuint32 constant _Admin_Role_ = 1;\\n\\tuint32 constant _Manager_Role_ = 2;\\n\\tuint32 constant _Publisher_Role_ = 3;\\n\\tuint32 constant _Banker_Role_ = 4;\\n\\n\\tmapping(bytes4 =\\u003e address) internal _logicFunctionContracts; // for mapping specific functions to contract addresses\\n\\n\\t// Generalized Storage Containers for Proxy Logic expansions\\n\\tmapping(string =\\u003e uint256) internal uint256Db;\\n\\tmapping(string =\\u003e mapping(uint256 =\\u003e uint256)) internal uint256MapDb;\\n\\tmapping(string =\\u003e string) internal stringDb;\\n\\tmapping(string =\\u003e mapping(uint256 =\\u003e string)) internal stringMapDb;\\n\\tmapping(string =\\u003e address) internal addressDb;\\n\\tmapping(string =\\u003e mapping(uint256 =\\u003e address)) internal addressMapDb;\\n\\tmapping(string =\\u003e bytes) internal bytesDb;\\n\\tmapping(string =\\u003e mapping(uint256 =\\u003e bytes)) internal bytesMapDb;\\n\\n\\tmapping(uint256 =\\u003e mapping(string =\\u003e uint32)) internal _listingDataInt; // listingId =\\u003e \\\"name\\\" =\\u003e uint32\\n\\tmapping(uint256 =\\u003e mapping(string =\\u003e uint256)) internal _listingDataNumber;\\n\\tmapping(uint256 =\\u003e mapping(string =\\u003e string)) internal _listingDataString;\\n\\n\\tfunction installLogic(address logicContract, bool allowOverride) external {\\n\\t\\trequire(_roles[_Admin_Role_][msg.sender], \\\"DENIED\\\"); // 1:Admin\\n\\t\\t(bool success, ) = logicContract.delegatecall(abi.encodeWithSignature(\\\"installProxy(address,bool)\\\", logicContract, allowOverride));\\n\\t\\tif (!success) {\\n\\t\\t\\trevert(\\\"FAILED_INSTALL\\\");\\n\\t\\t}\\n\\t}\\n\\n\\tbool internal reentrancyLock = false;\\n\\tmodifier nonReentrant() {\\n\\t\\trequire(!reentrancyLock);\\n\\t\\treentrancyLock = true;\\n\\t\\t_;\\n\\t\\treentrancyLock = false;\\n\\t}\\n\\n\\tfunction _setLogicFunction(string memory functionSignature, address functionContract, bool allowOverride) internal {\\n\\t\\trequire(_roles[_Admin_Role_][msg.sender], \\\"DENIED\\\"); // 1:Admin\\n\\t\\tbytes4 sig = bytes4(keccak256(bytes(functionSignature)));\\n\\t\\trequire(sig != bytes4(keccak256(bytes(\\\"installLogic(address)\\\"))), \\\"CRASH!\\\");\\n\\t\\trequire(sig != bytes4(keccak256(bytes(\\\"installProxy(address)\\\"))), \\\"BOOM!\\\");\\n\\t\\trequire(allowOverride || _logicFunctionContracts[sig] == address(0), \\\"OVERRIDE\\\");\\n\\t\\t_logicFunctionContracts[sig] = functionContract;\\n\\t\\temit LogicFunctionSet(functionSignature, sig, functionContract, allowOverride);\\n\\t}\\n\\tevent LogicFunctionSet(string functionSignature, bytes4 indexed sig, address functionContract, bool allowOverride);\\n\\n\\tfunction _delegateLogic() internal {\\n\\t\\taddress _delegateContract = _logicFunctionContracts[msg.sig];\\n\\t\\trequire(_delegateContract != address(0), \\\"NO_LOGIC\\\"); // No Logic Function found in the lookup table\\n\\t\\trequire(!_paused || _roles[_Admin_Role_][msg.sender], \\\"PAUSED\\\");  // 1:Admin\\n\\t\\tassembly {\\n\\t\\t\\tlet ptr := mload(0x40)\\n\\t\\t\\tcalldatacopy(ptr, 0, calldatasize())\\n\\t\\t\\tlet result := delegatecall(gas(), _delegateContract, ptr, calldatasize(), 0, 0)\\n\\t\\t\\tlet size := returndatasize()\\n\\t\\t\\treturndatacopy(ptr, 0, size)\\n\\t\\t\\tswitch result\\n\\t\\t\\t\\tcase 0 { revert(ptr, size) }\\n\\t\\t\\t\\tdefault { return(ptr, size) }\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _setConversion(uint32 peg, uint256 multiplier) internal {\\n\\t\\t// ENFORCE EXTERNALLY\\n\\t\\t// Currency Value X multiplier = nativePrice in Wei\\n\\t\\t// peg 0 is native Wei, peg 1 is USD, etc.\\n\\t\\t_conversionTable[peg] = multiplier;\\n\\t}\\n\\n\\tfunction _getConversion(uint32 peg, uint256 value) internal view returns (uint256) {\\n\\t\\t// @returns the nativePrice. A value in Wei converted by using a multiplier in a currency conversion-table\\n\\t\\t// if the peg is not set. 0 will be returned\\n\\t\\t// \\t^ (note the \\\"0\\\" nativePrice or askingPrice should be \\\"not for sale\\\")\\n\\t\\t// peg 0 is always native Wei peg 1 is USD and so on\\n\\t\\treturn ( peg == 0 ? value : value.mul(_conversionTable[peg]) );\\n\\t}\\n\\n\\tfunction _percentOf(uint256 percent, uint256 x) internal pure returns (uint256) {\\n\\t\\t// get truncated percentage of x, discards remainder. (percent is a whole number percent)\\n\\t\\treturn x.mul(percent).div(100);\\n\\t}\\n\\n\\tfunction _removeActiveListing(address owner, uint256 listingId) internal returns (bool) {\\n\\t\\t// @param address(0) for ALL active listings\\n\\t\\tif (listingId \\u003c 1 || _activeListingIds[owner].length \\u003c 1) return false;\\n\\t\\tuint256 endListingIndex = _activeListingIds[owner].length - 1;\\n\\t\\tif (_activeListingIds[owner][endListingIndex] == listingId) { // it\\u0027s on the end so pop it off\\n\\t\\t\\t_activeListingIdIndexes[owner][listingId] = uint256(-1); // Max uint256 is Non-Indexed\\n\\t\\t\\t_activeListingIds[owner].pop();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tuint256 index = _getActiveListingIdIndex(owner, listingId);\\n\\t\\tif (index != uint256(-1)) { // replace it with the one on the end\\n\\t\\t\\tuint256 endListingId = _activeListingIds[owner][endListingIndex]; \\n\\t\\t\\t_activeListingIds[owner][index] = endListingId;\\n\\t\\t\\t_activeListingIdIndexes[owner][listingId] = uint256(-1);  // Max uint256 is Non-Indexed\\n\\t\\t\\t_activeListingIdIndexes[owner][endListingId] = index; \\n\\t\\t\\t_activeListingIds[owner].pop();\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfunction _addActiveListing(address owner, uint256 listingId) internal returns (bool) {\\n\\t\\t// @param address(0) for ALL active listings\\n\\t\\tif (_getActiveListingIdIndex(owner, listingId) == uint256(-1)) {\\n\\t\\t\\t_activeListingIdIndexes[owner][listingId] = _activeListingIds[owner].length; // track index into the _activeListingIds\\n\\t\\t\\t_activeListingIds[owner].push(listingId);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfunction _getActiveListingIdIndex(address owner, uint256 listingId) internal view returns (uint256) {\\n\\t\\tuint256 index = _activeListingIdIndexes[owner][listingId];\\n\\t\\tif ( index \\u003c _activeListingIds[owner].length \\u0026\\u0026 _activeListingIds[owner][index] == listingId ) {\\n\\t\\t\\treturn index;\\n\\t\\t}\\n\\t\\treturn uint256(-1); // Max value means not found\\n\\t}\\n\\n}\\n\"},\"Holdings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Holdings.sol - j0zf 2021-03-14\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\nimport \\\"./SafeMath.sol\\\"; // import \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary Holdings {\\n\\tusing SafeMath for uint256;\\n\\n\\t// 0:Null 1:Royalties 2:Sales 3:General 4:Bonuses 5:Refunds 6:Bids Escrow 7:Trades Escrow 8:Auction Escrow 9:Tax Escrow 10:Withdrawal Escrow\\n\\tuint32 constant _Royalties_ = 1;\\n\\tuint32 constant _Sales_ = 2;\\n\\tuint32 constant _General_ = 3;\\n\\tuint32 constant _Bonuses_ = 4;\\n\\tuint32 constant _Refunds_ = 5;\\n\\tuint32 constant _Bids_Escrow_ = 6;\\n\\tuint32 constant _Trades_Escrow_ = 7;\\n\\tuint32 constant _Auctions_Escrow_ = 8;\\n\\tuint32 constant _Tax_Escrow_ = 9;\\n\\tuint32 constant _Withdrawal_Escrow_ = 10;\\n\\n\\t// pools poolType 0:Null 1:House Pool 2:Bonus Pool 3:Tax Pool 4:Withdrawal Pool\\n\\tuint32 constant _House_Pool_ = 1;\\n\\tuint32 constant _Bonus_Pool_ = 2;\\n\\tuint32 constant _Tax_Pool_ = 3;\\n\\tuint32 constant _Withdrawal_Pool_ = 4;\\n\\n\\tstruct HoldingsTable {\\n\\t\\tmapping(uint32 =\\u003e mapping(address =\\u003e uint256)) _holdings; // holdings[accountType][address] =\\u003e balance;\\n\\t\\tmapping(uint32 =\\u003e uint256) _holdingsTotals; // holdingsTotals[accountType] =\\u003e total; (accounts for _holdings)\\n\\t\\tmapping(uint32 =\\u003e uint256) _pools; // pools[poolType] =\\u003e balance;\\n\\t}\\n\\n\\tfunction creditAccount(HoldingsTable storage holdingsTable, uint32 accountType, address account, uint256 amount) internal {\\n\\t\\trequire(accountType \\u003e 0 \\u0026\\u0026 account != address(0), \\\"BAD_INPUT\\\"); // allowing amount of 0\\n\\t\\tif (amount == 0) return;\\n\\t\\tuint256 balance = holdingsTable._holdings[accountType][account];\\n\\t\\tuint256 total = holdingsTable._holdingsTotals[accountType];\\n\\t\\tbalance = balance.add(amount);\\n\\t\\ttotal = total.add(amount);\\n\\t\\tholdingsTable._holdings[accountType][account] = balance;\\n\\t\\tholdingsTable._holdingsTotals[accountType] = total;\\n\\t\\temit AccountCredited(accountType, account, amount, balance);\\n\\t}\\n\\tevent AccountCredited(uint32 indexed accountType, address indexed account, uint256 amount, uint256 balance);\\n\\n\\tfunction debitAccount(HoldingsTable storage holdingsTable, uint32 accountType, address account, uint256 amount) internal {\\n\\t\\trequire(accountType \\u003e 0 \\u0026\\u0026 account != address(0), \\\"BAD_INPUT\\\"); // allowing amount of 0\\n\\t\\tif (amount == 0) return;\\n\\t\\tuint256 balance = holdingsTable._holdings[accountType][account];\\n\\t\\tuint256 total = holdingsTable._holdingsTotals[accountType];\\n\\t\\trequire(balance \\u003e= amount \\u0026\\u0026 total \\u003e= amount, \\\"NOT_ENOUGH\\\");\\n\\t\\tbalance = balance.sub(amount);\\n\\t\\ttotal = total.sub(amount);\\n\\t\\tholdingsTable._holdings[accountType][account] = balance;\\n\\t\\tholdingsTable._holdingsTotals[accountType] = total;\\n\\t\\temit AccountDebited(accountType, account, amount, balance);\\n\\t}\\n\\tevent AccountDebited(uint32 indexed accountType, address indexed account, uint256 amount, uint256 balance);\\n\\n\\tfunction transferAmount(HoldingsTable storage holdingsTable, uint32 fromAccountType, address fromAccount, uint32 toAccountType, address toAccount, uint256 amount) internal {\\n\\t\\tHoldings.debitAccount(holdingsTable, fromAccountType, fromAccount, amount);\\n\\t\\tHoldings.creditAccount(holdingsTable, toAccountType, toAccount, amount);\\n\\t}\\n\\tfunction transferPoolAmount(HoldingsTable storage holdingsTable, uint32 fromPoolType, uint32 toAccountType, address toAccount, uint256 amount) internal {\\n\\t\\tHoldings.debitPool(holdingsTable, fromPoolType, amount);\\n\\t\\tHoldings.creditAccount(holdingsTable, toAccountType, toAccount, amount);\\n\\t}\\n\\n\\tfunction getAccountBalance(HoldingsTable storage holdingsTable, uint32 accountType, address account) internal view returns (uint256) {\\n\\t\\trequire(accountType \\u003e 0 \\u0026\\u0026 account != address(0), \\\"BAD_INPUT\\\");\\n\\t\\treturn holdingsTable._holdings[accountType][account];\\n\\t}\\n\\n\\tfunction getHoldingsTotal(HoldingsTable storage holdingsTable, uint32 accountType) internal view returns (uint256) {\\n\\t\\t// @returns totals of all accounts for each accountType in the holdingsTable\\n\\t\\trequire(accountType \\u003e 0, \\\"BAD_INPUT\\\");\\n\\t\\treturn holdingsTable._holdingsTotals[accountType];\\n\\t}\\n\\n\\tfunction creditPool(HoldingsTable storage holdingsTable, uint32 poolType, uint256 amount) internal {\\n\\t\\trequire(poolType \\u003e 0, \\\"BAD_INPUT\\\"); // allowing amount of 0\\n\\t\\tif (amount == 0) return;\\n\\t\\tuint256 balance = holdingsTable._pools[poolType];\\n\\t\\tbalance = balance.add(amount);\\n\\t\\tholdingsTable._pools[poolType] = balance;\\n\\t\\temit PoolCredited(poolType, amount, balance);\\n\\t}\\n\\tevent PoolCredited(uint32 poolType, uint256 amount, uint256 balance);\\n\\n\\tfunction debitPool(HoldingsTable storage holdingsTable, uint32 poolType, uint256 amount) internal {\\n\\t\\trequire(poolType \\u003e 0, \\\"BAD_INPUT\\\"); // allowing amount of 0\\n\\t\\tif (amount == 0) return;\\n\\t\\tuint256 balance = holdingsTable._pools[poolType];\\n\\t\\trequire(balance \\u003e= amount, \\\"NOT_ENOUGH\\\");\\n\\t\\tbalance = balance.sub(amount);\\n\\t\\tholdingsTable._pools[poolType] = balance;\\n\\t\\temit PoolDebited(poolType, amount, balance);\\n\\t}\\n\\tevent PoolDebited(uint32 indexed poolType, uint256 amount, uint256 balance);\\n\\n\\tfunction getPoolBalance(HoldingsTable storage holdingsTable, uint32 poolType) internal view returns (uint256) {\\n\\t\\trequire(poolType \\u003e 0, \\\"BAD_INPUT\\\");\\n\\t\\treturn holdingsTable._pools[poolType];\\n\\t}\\n\\n}\\n\"},\"Market.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// 20220612 j0zf - Market\\n// 2021-02-25 Media Library for CryptoStacks - j0zf\\n// 2020-07-06 MediaTokens Library for CryptoMedia - j0zf\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nlibrary Market {\\n\\n\\t// Status Types\\n\\tuint32 constant _Open_ = 1;\\n\\tuint32 constant _Complete_ = 2;\\n\\tuint32 constant _Cancelled_ = 3;\\n\\n\\t// Listing Types\\n\\tuint32 constant _Mintable_ = 1;\\n\\tuint32 constant _Sale_  = 2;\\n\\tuint32 constant _Bid_  = 3;\\n\\tuint32 constant _DutchAuction_  = 4;\\n\\tuint32 constant _EnglishAuction_  = 5;\\n\\tuint32 constant _Trade_  = 6;\\n\\tuint32 constant _ClaimCode_  = 7;\\n\\tuint32 constant _Free_  = 8;\\n\\n\\tstruct TokenContract {\\n\\t\\tstring name;\\n\\t\\taddress location;\\n\\t\\tuint32 contractType;\\n\\t}\\n\\n\\tstruct Listing {\\n\\t\\tuint256 contractId;\\n\\t\\taddress owner;\\n\\t\\tuint32 listingType;\\n\\t\\tuint32 status;\\n\\t}\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c \\u003c a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b \\u003e a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"StacksStore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// StacksStore Marketplace - Proxy - Stacks721(tm) / StacksNET(tm) : Stacks and Stacks of Multimedia\\n// CryptoComics.com - A media token library marketplace built for blockchain networks.\\n// (c) Copyright 2022, j0zf at apogeeinvent.com\\n// StacksStore.sol : j0zf 2022-04-23\\n// Stacks721.sol : CryptoStacks(tm) Stacks721 by j0zf at ApogeeINVENT(tm) 2021-02-28\\n// StacksNET(tm) : Stacks and Stacks of Multimedia a Library Marketplace built upon an Ethereum sidechain PoA (proof of authority) Blockchain Network.\\n// .   .       .:      ...   .     * .         ..   :    .        .       .  + .     .  .  +\\n//   .   . x      . -      . ..       .  ...   .       .    + .          .    .    *        \\n//      .        .   .   .        ---=*{[ CryptoComics.com ]}*=--    .  x   .   .       .. \\n//  .     .  .   . .   *   . .    +  .   .      .   .  .      :.       .              .    .\\n//    .  .   . .       . .       .   .      .   .  .       .       .      .     ..    .    .\\n//  .  :     .    ..        ____  __ __      .   *  .   :       ;  .     -=-              . \\n// .        .    .   . .\\\"_\\\".^ .^ ^. \\\"\\u0027.^`:`-_  .    .    .    .      .       .    :.     .  \\n//  .   .    +.    ,:\\\".   .    .    \\\"   . . .:`    .  +  .  *    .   .   . ..  .        .   \\n//   .     . _   ./:           `   .  ^ .  . .:``   _ .       :.     .   .  .       .       \\n// .   . -      ./.                   .    .  .:`\\\\      . -      .    .  .   .    .     o  :\\n//   .     .   .\\u0027:                       .   . .:!.   .        -+-     + + . . ..  .       :\\n//   O  .      .!                            . !::.      .   .         .   . .:  .     .   +\\n//  . . .  :.  :!    ^                    ^  . ::!:  .   .      .   :     .   .         .   \\n//     - .     .:.  .o..               ...o.   ::|. .   : .  .   :  .  .  .   .    .  x     \\n//   :     .   `: .ooooooo.          .ooooooo :::.   :.   :  _____________                :.\\n// .  ..  .  .. `! .ooOooooo        .ooooOooo .:\\u0027  ..  .   /   .   .       :\\\\ .  . - .   .  \\n//     .+    : -. \\\\ .ooO*Ooo.      .ooO*Oooo .:\\u0027  -     ./   ____________ ,::\\\\ :  .  . .  . \\n// .+   .   . .  . \\\\. .oooOoo      :oOooooo..:\\u0027 .  . . .!| / .   .      `::\\\\::!\\\" .    .  ,  \\n// : .     .     .. .\\\\ .ooooo      :ooooo.::\\u0027   . .   . ( \\u0027  .  .         ::!:.)    .  .    \\n// .   .  .. :  -    .\\\\    ..   .   .. ::.:\\u0027 . .    : . | !   . .        .::|:|)    -      .\\n//   +     .  .- .\\\" .  .\\\\      ||     ..:\\u0027. .  .  -.  .  . .    .        ::/ //.  .    +    \\n//  -.   . ` . .  .   . .\\\\.    ``     .:\\u0027 .  . :. . . .  _\\\\ \\\\___________.:` //___    . - .  \\n//  .  :        .  .  _ ..:\\\\  .___/  :\\u0027. .: _ . .  .    /  \\\\.__ :  : _. ___/ ::\\\"\\\"\\\\\\\\     .   \\n// .  .   . . .. .  .:  . .:\\\\       :\\u0027: . .    . .  .  !     \\u0027\\u0027..:.:::/`      `:::||       .\\n//   .   .     .   .  . . .:.`\\\\_(__/ ::. . :.: .  :.   |     ! :  !  .===   ..  ::||.   x + \\n//\\\\___________-...:::::::::::!|    .:\\\\;::::::::::::::::|:   .!  + !!  BOB :.``   :.|::..-___\\n//            \\\\\\\\:::::::::::../.  ^.: :.;:::::::::::::::!   :!`.  .!.   ^   :::   :!:::://   \\n//             \\\\\\\\::::::.::::/  .  .:: ::\\\\:::::::::::::.:. .:|`    !! .| |  ::: . :.!:://    \\n//              \\\\\\\\:_________________________________________________________________://     \\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\nimport \\\"./AppBase.sol\\\";\\n\\ncontract StacksStore is AppBase {\\n    constructor (uint32 networkId) public {\\n        _values[\\\"name\\\"] = \\\"StacksNET Marketplace\\\";\\n        _values[\\\"version\\\"] = \\\"1.2.1\\\";\\n        _networkId = networkId;\\n        _roles[_Admin_Role_][msg.sender] = true; // 1:Admin\\n        _roles[_Manager_Role_][msg.sender] = true; // 2:Manager\\n        _roles[_Publisher_Role_][msg.sender] = true; // 3:Publisher\\n    }\\n\\n    receive () external payable {\\n        _holdingsTable.creditAccount(Holdings._Refunds_, msg.sender, msg.value);\\n    }\\n\\n    fallback () external payable {\\n        return _delegateLogic();\\n    }\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"networkId\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountType\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"AccountCredited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"accountType\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"AccountDebited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"functionSignature\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"functionContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowOverride\",\"type\":\"bool\"}],\"name\":\"LogicFunctionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"poolType\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"PoolCredited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"poolType\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"PoolDebited\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"logicContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowOverride\",\"type\":\"bool\"}],\"name\":\"installLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StacksStore", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000089", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4713cf51d4961f7faaa62f3cb52769961ce68e70d87753fbac05d22ab7bc18c2"}