{"SourceCode": "// Sources flattened with hardhat v2.12.3 https://hardhat.org\r\n\r\n// File contracts/IPlatformSFT.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPlatformSFT {\r\n    function mint(address mintTo_, uint256 slot_, uint256 value_) external returns (uint256);\r\n\r\n    function mintValue(uint256 tokenId_, uint256 value_) external;\r\n\r\n    // function burn(uint256 tokenId_) external; // to avoid exceed size\r\n\r\n    function burnValue(uint256 tokenId_, uint256 burnValue_) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.7.3\r\n\r\n// \r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/IERC721.sol\r\n\r\n// \r\n\r\npragma solidity ^0.8.1;\r\n\r\n/** \r\n * @title ERC-721 Non-Fungible Token Standard\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n *  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /** \r\n     * @dev This emits when ownership of any NFT changes by any mechanism.\r\n     *  This event emits when NFTs are created (`from` == 0) and destroyed\r\n     *  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n     *  may be created and assigned without emitting Transfer. At the time of\r\n     *  any transfer, the approved address for that NFT (if any) is reset to none.\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when the approved address for an NFT is changed or\r\n     *  reaffirmed. The zero address indicates there is no approved address.\r\n     *  When a Transfer event emits, this also indicates that the approved\r\n     *  address for that NFT (if any) is reset to none.\r\n     */\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when an operator is enabled or disabled for an owner.\r\n     *  The operator can manage all NFTs of the owner.\r\n     */\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n     * @notice Count all NFTs assigned to an owner\r\n     * @dev NFTs assigned to the zero address are considered invalid, and this\r\n     *  function throws for queries about the zero address.\r\n     * @param _owner An address for whom to query the balance\r\n     * @return The number of NFTs owned by `_owner`, possibly zero\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Find the owner of an NFT\r\n     * @dev NFTs assigned to zero address are considered invalid, and queries\r\n     *  about them do throw.\r\n     * @param _tokenId The identifier for an NFT\r\n     * @return The address of the owner of the NFT\r\n     */\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /**\r\n     * @notice Transfers the ownership of an NFT from one address to another address\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n     *  operator, or the approved address for this NFT. Throws if `_from` is\r\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n     *  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n     *  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n     *  `onERC721Received` on `_to` and throws if the return value is not\r\n     *  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     * @param data Additional data with no specified format, sent in call to `_to`\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /**\r\n     * @notice Transfers the ownership of an NFT from one address to another address\r\n     * @dev This works identically to the other function with an extra data parameter,\r\n     *  except this function just sets data to \"\".\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /**\r\n     * @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n     *  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n     *  THEY MAY BE PERMANENTLY LOST\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n     *  operator, or the approved address for this NFT. Throws if `_from` is\r\n     *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n     *  `_tokenId` is not a valid NFT.\r\n     * @param _from The current owner of the NFT\r\n     * @param _to The new owner\r\n     * @param _tokenId The NFT to transfer\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /**\r\n     * @notice Change or reaffirm the approved address for an NFT\r\n     * @dev The zero address indicates there is no approved address.\r\n     *  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n     *  operator of the current owner.\r\n     * @param _approved The new approved NFT controller\r\n     * @param _tokenId The NFT to approve\r\n     */\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /**\r\n     * @notice Enable or disable approval for a third party (\"operator\") to manage\r\n     *  all of `msg.sender`'s assets\r\n     * @dev Emits the ApprovalForAll event. The contract MUST allow\r\n     *  multiple operators per owner.\r\n     * @param _operator Address to add to the set of authorized operators\r\n     * @param _approved True if the operator is approved, false to revoke approval\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /**\r\n     * @notice Get the approved address for a single NFT\r\n     * @dev Throws if `_tokenId` is not a valid NFT.\r\n     * @param _tokenId The NFT to find the approved address for\r\n     * @return The approved address for this NFT, or the zero address if there is none\r\n     */\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /**\r\n     * @notice Query if an address is an authorized operator for another address\r\n     * @param _owner The address that owns the NFTs\r\n     * @param _operator The address that acts on behalf of the owner\r\n     * @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/IERC3525.sol\r\n\r\n// \r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-3525 Semi-Fungible Token Standard\r\n * @dev See https://eips.ethereum.org/EIPS/eip-3525\r\n * Note: the ERC-165 identifier for this interface is 0xd5358140.\r\n */\r\ninterface IERC3525 is IERC165, IERC721 {\r\n    /**\r\n     * @dev MUST emit when value of a token is transferred to another token with the same slot,\r\n     *  including zero value transfers (_value == 0) as well as transfers when tokens are created\r\n     *  (`_fromTokenId` == 0) or destroyed (`_toTokenId` == 0).\r\n     * @param _fromTokenId The token id to transfer value from\r\n     * @param _toTokenId The token id to transfer value to\r\n     * @param _value The transferred value\r\n     */\r\n    event TransferValue(uint256 indexed _fromTokenId, uint256 indexed _toTokenId, uint256 _value);\r\n\r\n    /**\r\n     * @dev MUST emits when the approval value of a token is set or changed.\r\n     * @param _tokenId The token to approve\r\n     * @param _operator The operator to approve for\r\n     * @param _value The maximum value that `_operator` is allowed to manage\r\n     */\r\n    event ApprovalValue(uint256 indexed _tokenId, address indexed _operator, uint256 _value);\r\n\r\n    /**\r\n     * @dev MUST emit when the slot of a token is set or changed.\r\n     * @param _tokenId The token of which slot is set or changed\r\n     * @param _oldSlot The previous slot of the token\r\n     * @param _newSlot The updated slot of the token\r\n     */ \r\n    event SlotChanged(uint256 indexed _tokenId, uint256 indexed _oldSlot, uint256 indexed _newSlot);\r\n\r\n    /**\r\n     * @notice Get the number of decimals the token uses for value - e.g. 6, means the user\r\n     *  representation of the value of a token can be calculated by dividing it by 1,000,000.\r\n     *  Considering the compatibility with third-party wallets, this function is defined as\r\n     *  `valueDecimals()` instead of `decimals()` to avoid conflict with ERC20 tokens.\r\n     * @return The number of decimals for value\r\n     */\r\n    function valueDecimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @notice Get the value of a token.\r\n     * @param _tokenId The token for which to query the balance\r\n     * @return The value of `_tokenId`\r\n     */\r\n    function balanceOf(uint256 _tokenId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get the slot of a token.\r\n     * @param _tokenId The identifier for a token\r\n     * @return The slot of the token\r\n     */\r\n    function slotOf(uint256 _tokenId) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Allow an operator to manage the value of a token, up to the `_value` amount.\r\n     * @dev MUST revert unless caller is the current owner, an authorized operator, or the approved\r\n     *  address for `_tokenId`.\r\n     *  MUST emit ApprovalValue event.\r\n     * @param _tokenId The token to approve\r\n     * @param _operator The operator to be approved\r\n     * @param _value The maximum value of `_toTokenId` that `_operator` is allowed to manage\r\n     */\r\n    function approve(\r\n        uint256 _tokenId,\r\n        address _operator,\r\n        uint256 _value\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Get the maximum value of a token that an operator is allowed to manage.\r\n     * @param _tokenId The token for which to query the allowance\r\n     * @param _operator The address of an operator\r\n     * @return The current approval value of `_tokenId` that `_operator` is allowed to manage\r\n     */\r\n    function allowance(uint256 _tokenId, address _operator) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Transfer value from a specified token to another specified token with the same slot.\r\n     * @dev Caller MUST be the current owner, an authorized operator or an operator who has been\r\n     *  approved the whole `_fromTokenId` or part of it.\r\n     *  MUST revert if `_fromTokenId` or `_toTokenId` is zero token id or does not exist.\r\n     *  MUST revert if slots of `_fromTokenId` and `_toTokenId` do not match.\r\n     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the\r\n     *  operator.\r\n     *  MUST emit `TransferValue` event.\r\n     * @param _fromTokenId The token to transfer value from\r\n     * @param _toTokenId The token to transfer value to\r\n     * @param _value The transferred value\r\n     */\r\n    function transferFrom(\r\n        uint256 _fromTokenId,\r\n        uint256 _toTokenId,\r\n        uint256 _value\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Transfer value from a specified token to an address. The caller should confirm that\r\n     *  `_to` is capable of receiving ERC3525 tokens.\r\n     * @dev This function MUST create a new ERC3525 token with the same slot for `_to` to receive\r\n     *  the transferred value.\r\n     *  MUST revert if `_fromTokenId` is zero token id or does not exist.\r\n     *  MUST revert if `_to` is zero address.\r\n     *  MUST revert if `_value` exceeds the balance of `_fromTokenId` or its allowance to the\r\n     *  operator.\r\n     *  MUST emit `Transfer` and `TransferValue` events.\r\n     * @param _fromTokenId The token to transfer value from\r\n     * @param _to The address to transfer value to\r\n     * @param _value The transferred value\r\n     * @return ID of the new token created for `_to` which receives the transferred value\r\n     */\r\n    function transferFrom(\r\n        uint256 _fromTokenId,\r\n        address _to,\r\n        uint256 _value\r\n    ) external payable returns (uint256);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.7.3\r\n\r\n// \r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.7.3\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.7.3\r\n\r\n// \r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/IAccessControl.sol@v4.7.3\r\n\r\n// \r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/AccessControl.sol@v4.7.3\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with a standardized message including the required role.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\r\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\r\n     *\r\n     * Format of the revert message is described in {_checkRole}.\r\n     *\r\n     * _Available since v4.6._\r\n     */\r\n    function _checkRole(bytes32 role) internal view virtual {\r\n        _checkRole(role, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `account` is missing `role`.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(uint160(account), 20),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function renounceRole(bytes32 role, address account) public virtual override {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     *\r\n     * NOTE: This function is deprecated in favor of {_grantRole}.\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Roles.sol\r\n\r\n// \r\npragma solidity >0.8.0;\r\n\r\ncontract Roles is AccessControl {\r\n    error NotAuthorizedError(address sender);\r\n\r\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\r\n\r\n    constructor(address _owner) {\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        if (!hasRole(DEFAULT_ADMIN_ROLE, _msgSender())) {\r\n            revert NotAuthorizedError(_msgSender());\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        if (!hasRole(MANAGER_ROLE, _msgSender())) {\r\n            revert NotAuthorizedError(_msgSender());\r\n        }\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/extensions/IERC721Enumerable.sol\r\n\r\n// \r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n *  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /** \r\n     * @notice Count NFTs tracked by this contract\r\n     * @return A count of valid NFTs tracked by this contract, where each one of\r\n     *  them has an assigned and queryable owner not equal to the zero address\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /** \r\n     * @notice Enumerate valid NFTs\r\n     * @dev Throws if `_index` >= `totalSupply()`.\r\n     * @param _index A counter less than `totalSupply()`\r\n     * @return The token identifier for the `_index`th NFT,\r\n     *  (sort order not specified)\r\n     */\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /** \r\n     * @notice Enumerate NFTs assigned to an owner\r\n     * @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n     *  `_owner` is the zero address, representing invalid NFTs.\r\n     * @param _owner An address where we are interested in NFTs owned by them\r\n     * @param _index A counter less than `balanceOf(_owner)`\r\n     * @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n     *  (sort order not specified)\r\n     */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.7.3\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/Platform.sol\r\n\r\n// \r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\ninterface IGame {\r\n    function startGame(address player, uint256 dollar, uint256 tokenId, bytes memory gameArgs)\r\n        external\r\n        payable\r\n        returns (uint256);\r\n}\r\n\r\ninterface IDistributeFT {\r\n    function distributeFT(address ft, uint64 mainType, uint64 subType, address player, uint256 amount) external;\r\n}\r\n\r\ninterface ICalculateShare {\r\n    function calculateShare(uint64 mainType, uint64 subType, address player, uint256 dollar)\r\n        external\r\n        returns (uint256);\r\n}\r\n\r\ninterface IClean {\r\n    function clean(address SFT) external returns (uint256);\r\n}\r\n\r\n// Roles to allow multi-admin to avoid upgrade error\r\ncontract Platform is Roles {\r\n    uint256 public constant PRECISION = 1e6;\r\n    address public SFT;\r\n    address public defaultSuperNode;\r\n\r\n    uint256 public constant minWeightedDollar = 300 * (10 ** 36);\r\n\r\n    mapping(address => bool) public isAnyNode;\r\n\r\n    address[] public superNodeList; // not include defaultSuperNode\r\n    address[] public nodeList; // not include selfNode\r\n\r\n    // player => agent\r\n    mapping(address => address) public agentOf;\r\n\r\n    // agent => child-player's total dollars\r\n    mapping(address => uint256) public weightedDollar;\r\n    // mapping(uint64 => mapping(uint256 => uint256));\r\n\r\n    // agent => child-player's account\r\n    mapping(address => uint64) public level2nd;\r\n\r\n    // agent => grandchild-player's account\r\n    mapping(address => uint64) public level3th;\r\n\r\n    // Node => SuperNode // L2 >= 2 && L3 >= 4 Mount/Bind\r\n    mapping(address => address) public superOf;\r\n    // Player/Node => Node // Node => NodeSelf // Player => Node;\r\n    mapping(address => address) public channelOf;\r\n\r\n    // superNode => selfNode // superNode and selfNode belong to the same person\r\n    mapping(address => address) public selfNodeOf;\r\n\r\n    // dailyRecord[node or superNode][date] += wd;\r\n    mapping(address => mapping(uint256 => uint256)) public dailyRecord;\r\n\r\n    // playerDailyRecord[player][date] += wd;\r\n    mapping(address => mapping(uint256 => uint256)) public playerDailyRecord;\r\n\r\n    mapping(uint64 => mapping(uint64 => bool)) public pause;\r\n\r\n    event SwitchPause(uint64 mainType, uint64 subType, bool state);\r\n    event AddGame(uint64 mainType, uint64 subType, address game);\r\n    event SetSFT(address sft);\r\n    event SetDefaultSuperNode(address superNode);\r\n    event SetSuperNode(address superNode, address selfNode);\r\n    event UpgradeAndBind(address node, address superNode);\r\n    event ChannelUpdated(address addr, address channel);\r\n    event ConfigMainType(uint64 mainType, address FT, address shareCalc, address[] pools, uint256[] ratios);\r\n\r\n    constructor(address superNode, address owner) Roles(owner) {\r\n        require(superNode != address(0), \"Zero address\");\r\n        defaultSuperNode = superNode;\r\n        selfNodeOf[superNode] = superNode;\r\n        isAnyNode[superNode] = true;\r\n    }\r\n\r\n    function superNodeListLength() external view returns (uint256) {\r\n        return superNodeList.length;\r\n    }\r\n\r\n    function nodeListLength() external view returns (uint256) {\r\n        return nodeList.length;\r\n    }\r\n\r\n    function isNode(address addr) public view returns (bool) {\r\n        return addr != address(0) && channelOf[addr] == addr;\r\n    }\r\n\r\n    function isSuperNode(address addr) public view returns (bool) {\r\n        return addr != address(0) && selfNodeOf[addr] != address(0);\r\n    }\r\n\r\n    function areBothNodes(address addr) external view returns (bool, bool, address) {\r\n        address agent = agentOf[addr];\r\n        return (isNode(addr), isNode(agent), agent);\r\n    }\r\n\r\n    // considering special player (1. selfNode of a superNode; 2.common Node)\r\n    function relationOf(address player) external view returns (address superNode, address node, address agent) {\r\n        agent = agentOf[player];\r\n        node = channelOf[player];\r\n        superNode = superOf[node];\r\n        if (superNode == address(0)) {\r\n            superNode = defaultSuperNode;\r\n        }\r\n    }\r\n\r\n    function switchPause(uint64 mainType, uint64 subType, bool state) external onlyOwner {\r\n        pause[mainType][subType] = state;\r\n        emit SwitchPause(mainType, subType, state);\r\n    }\r\n\r\n    function addGames(uint64 mainType, uint64 subType, address game) external onlyOwner {\r\n        require(!closed[mainType], \"Already closed\");\r\n        require(address(games[mainType][subType]) == address(0), \"Already initialized\");\r\n        games[mainType][subType] = IGame(game);\r\n        emit AddGame(mainType, subType, game);\r\n    }\r\n\r\n    function initSFT(address sft) external onlyOwner {\r\n        require(SFT == address(0), \"Already initialized\");\r\n        SFT = sft;\r\n        emit SetSFT(sft);\r\n    }\r\n\r\n    // no need to delete selfNodeOf[defaultSuperNode];\r\n    function setDefaultSuperNode(address superNode) external onlyOwner {\r\n        require(superNode != address(0), \"Args error\");\r\n        require(!isAnyNode[superNode], \"Already set as Node or SuperNode\"); // to avoid a node as superNode\r\n\r\n        defaultSuperNode = superNode;\r\n        selfNodeOf[superNode] = superNode; // to record history defaultSuperNode\r\n\r\n        emit SetDefaultSuperNode(superNode);\r\n        isAnyNode[superNode] = true;\r\n    }\r\n\r\n    // considering msg.sender is a selfNode\r\n    function upgradeAndBind(address superNode) external {\r\n        require(\r\n            level2nd[msg.sender] >= 2 && level3th[msg.sender] >= 4 && weightedDollar[msg.sender] >= minWeightedDollar,\r\n            \"Can not upgrade\"\r\n        );\r\n        require(superOf[msg.sender] == address(0), \"Already Upgraded\");\r\n        // history defaultSuperNode is forbidden\r\n        require(isSuperNode(superNode) && selfNodeOf[superNode] != superNode, \"Super node error\");\r\n        superOf[msg.sender] = superNode;\r\n        channelOf[msg.sender] = msg.sender; // cut the old channel if have, force to set the new channel\r\n        nodeList.push(msg.sender);\r\n        emit ChannelUpdated(msg.sender, msg.sender);\r\n        emit UpgradeAndBind(msg.sender, superNode);\r\n\r\n        isAnyNode[msg.sender] = true;\r\n    }\r\n\r\n    // superNode and defaultNode belong to the same person\r\n    function setSuperNode(address superNode, address selfNode) external onlyManager {\r\n        require(\r\n            superNode != selfNode && superNode != address(0) && selfNode != address(0) && selfNode != address(this),\r\n            \"Args error\"\r\n        );\r\n        require(agentOf[superNode] == address(0) && level2nd[superNode] == 0, \"Super node has relation\");\r\n        require((!isAnyNode[superNode]) && (!isAnyNode[selfNode]), \"Already set\");\r\n\r\n        // superNode not have any relation, totally new address\r\n        // selfNode is not a node, has no channel, may be a agent or player\r\n        superOf[selfNode] = superNode;\r\n        selfNodeOf[superNode] = selfNode;\r\n        channelOf[selfNode] = selfNode;\r\n        superNodeList.push(superNode);\r\n\r\n        emit ChannelUpdated(selfNode, selfNode);\r\n        emit SetSuperNode(superNode, selfNode);\r\n\r\n        isAnyNode[superNode] = true;\r\n        isAnyNode[selfNode] = true;\r\n    }\r\n\r\n    event PlayGame(\r\n        address player,\r\n        address agent,\r\n        uint256 dollar,\r\n        uint64 mainType,\r\n        uint64 subType,\r\n        uint256 tokenId,\r\n        uint256 requestId,\r\n        bytes gameArgs\r\n    );\r\n\r\n    event PassiveAgent(address agent, address sAgent);\r\n\r\n    function play(\r\n        address agent, // input by frontend\r\n        uint256 dollar,\r\n        uint64 mainType,\r\n        uint64 subType,\r\n        uint256 tokenId, // for receive share, address(0) means to mint\r\n        bytes memory gameArgs // abi.encode() by frontend, abi.decode by game contract if needed\r\n    ) public payable {\r\n        require(!pause[mainType][subType], \"Paused\");\r\n        require(!closed[mainType], \"Closed\");\r\n\r\n        // Step1 build relation (player, agent) tree\r\n        address player = msg.sender;\r\n        require(player.code.length == 0, \"Contract player not allowed\");\r\n        require(agent != player, \"Agent and player are same\");\r\n        require(selfNodeOf[player] == address(0), \"Player is a super node\");\r\n        require(selfNodeOf[agent] == address(0), \"Agent is a super node\");\r\n\r\n        address _agent = agentOf[player];\r\n        if (agent == address(0)) {\r\n            agent = _agent;\r\n        }\r\n        if (_agent != address(0)) {\r\n            require(agent == _agent, \"Agent mismatch\");\r\n        }\r\n\r\n        uint256 wd = dollar * weight[mainType];\r\n        if (agent != address(0)) {\r\n            weightedDollar[agent] += wd;\r\n            buildRelation(player, agent, _agent);\r\n        }\r\n\r\n        record(player, wd);\r\n\r\n        // Step2 calculate share\r\n        uint256 shareAmount = ICalculateShare(shareCalc[mainType]).calculateShare(mainType, subType, player, dollar);\r\n\r\n        // Step3 mint nft of slot(mainType), if tokenId == 0; or revert for invalid tokenId;\r\n        tokenId = mintSFT(player, tokenId, mainType, shareAmount);\r\n\r\n        // Step4 distribute to several pools\r\n        distributeFT(mainType, subType, player, dollar);\r\n\r\n        // Step5 trigger the game -> random-oracle\r\n        IGame game = games[mainType][subType];\r\n        require(address(game) != address(0), \"Game is not existed\");\r\n        uint256 requestId = game.startGame{value: msg.value}(player, dollar, tokenId, gameArgs);\r\n\r\n        emit PlayGame(player, agent, dollar, mainType, subType, tokenId, requestId, gameArgs);\r\n    }\r\n\r\n    function record(address player, uint256 wd) private {\r\n        uint256 _date = block.timestamp/(1 days);\r\n        playerDailyRecord[player][_date] += wd;\r\n        address _node = channelOf[player];\r\n        if (_node != address(0)) {\r\n            dailyRecord[superOf[_node]][_date] += wd; // SuperNode\r\n            dailyRecord[_node][_date] += wd;\r\n        }\r\n    }\r\n\r\n    function buildRelation(address player, address agent, address _agent) internal {\r\n        // Make sure that Player is not a [Common-Node or Self-Node]\r\n        // build agent\r\n        if (_agent == address(0)) {\r\n            agentOf[player] = agent;\r\n            level2nd[agent] += 1;\r\n            address sAgent = agentOf[agent];\r\n            if (sAgent != address(0)) {\r\n                level3th[sAgent] += 1;\r\n            } else {\r\n                agentOf[agent] = address(this);\r\n                emit PassiveAgent(agent, address(this));\r\n            }\r\n        }\r\n        // build channel\r\n        if (channelOf[player] == address(0)) {\r\n            address channel = channelOf[agent];\r\n            if (channel != address(0)) {\r\n                channelOf[player] = channel;\r\n                emit ChannelUpdated(player, channel);\r\n            }\r\n        }\r\n    }\r\n\r\n    // divide to different pools, Pools(Game-Returns), (2%) to Jack-Pool if opened\r\n    function distributeFT(uint64 mainType, uint64 subType, address player, uint256 amount) internal {\r\n        // (address FT, address[] memory _pools, uint256[] memory _ratios) = poolList(mainType);\r\n        address FT = payment[mainType];\r\n        address[] memory _pools = pools[mainType];\r\n        uint256[] memory _ratios = ratios[mainType];\r\n        // IERC20(FT).transferFrom(player, address(this), amount);\r\n        // BE CAREFUL, part1 + part2 ... != amount due to directly distribute to pools\r\n        uint256 length = _pools.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            uint256 part = amount * _ratios[i] / PRECISION;\r\n            IERC20(FT).transferFrom(player, _pools[i], part);\r\n            IDistributeFT(_pools[i]).distributeFT(FT, mainType, subType, player, part);\r\n        }\r\n    }\r\n\r\n    function mintSFT(address player, uint256 tokenId, uint256 slot, uint256 share) internal returns (uint256) {\r\n        if (tokenId == 0) {\r\n            uint256 balance = IERC3525(SFT).balanceOf(player);\r\n            if (balance > 0) {\r\n                // to find the first matched tokenId\r\n                for (uint256 i = 0; i < balance; i++) {\r\n                    tokenId = IERC721Enumerable(SFT).tokenOfOwnerByIndex(player, i);\r\n                    if (IERC3525(SFT).slotOf(tokenId) == slot) {\r\n                        IPlatformSFT(SFT).mintValue(tokenId, share);\r\n                        return tokenId;\r\n                    }\r\n                }\r\n            }\r\n            tokenId = IPlatformSFT(SFT).mint(player, slot, share);\r\n        } else if (IERC3525(SFT).ownerOf(tokenId) == player && IERC3525(SFT).slotOf(tokenId) == slot) {\r\n            IPlatformSFT(SFT).mintValue(tokenId, share);\r\n        } else {\r\n            revert(\"Token is not owned by the player\");\r\n        }\r\n        return tokenId;\r\n    }\r\n\r\n    mapping(uint64 => bool) public closed;\r\n    mapping(uint64 => address) public payment;\r\n    mapping(uint64 => uint256) public weight;\r\n    mapping(uint64 => address[]) public pools;\r\n    mapping(uint64 => uint256[]) public ratios;\r\n    mapping(uint64 => address) public shareCalc;\r\n    mapping(uint64 => mapping(uint64 => IGame)) public games;\r\n\r\n    // might set Oracle as Manager, frequently update this\r\n    function setWeight(uint64 mainType, uint256 _weight) external onlyManager {\r\n        // No need to require(_weight != 0) for some mainTypes not count into score\r\n        weight[mainType] = _weight;\r\n    }\r\n\r\n    function poolList(uint64 mainType)\r\n        external\r\n        view\r\n        returns (address FT, address[] memory _pools, uint256[] memory _ratios)\r\n    {\r\n        FT = payment[mainType];\r\n        uint256 length = ratios[mainType].length;\r\n        _pools = new address[](length);\r\n        _ratios = new uint256[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _pools[i] = pools[mainType][i];\r\n            _ratios[i] = ratios[mainType][i];\r\n        }\r\n    }\r\n\r\n    function configMainType(\r\n        uint64 mainType,\r\n        uint256 _weight,\r\n        address FT,\r\n        address _shareCalc,\r\n        address[] memory _pools,\r\n        uint256[] memory _ratios\r\n    ) external onlyOwner {\r\n        require(_ratios.length == _pools.length, \"Length error\");\r\n        require(payment[mainType] == address(0), \"Already Configured\");\r\n        require(FT != address(0) && _shareCalc != address(0), \"Wrong address\");\r\n\r\n        payment[mainType] = FT;\r\n        weight[mainType] = _weight;\r\n        shareCalc[mainType] = _shareCalc;\r\n        delete pools[mainType];\r\n        delete ratios[mainType];\r\n        uint256 length = _ratios.length;\r\n        uint256 acc;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            require(_pools[i] != address(0), \"Wrong address\");\r\n            pools[mainType].push(_pools[i]);\r\n            ratios[mainType].push(_ratios[i]);\r\n            acc += _ratios[i];\r\n        }\r\n        require(acc == PRECISION, \"Ratios error\");\r\n        emit ConfigMainType(mainType, FT, _shareCalc, _pools, _ratios);\r\n    }\r\n\r\n    // function clean(address receiver) external onlyPlatform returns (uint256);\r\n    function shutDown(uint64 mainType, address gamePool) external onlyOwner {\r\n        // require(gamePool != address(0), \"Zero address\");\r\n        bool checked = false;\r\n        for (uint256 i = 0; i < pools[mainType].length; i++) {\r\n            if (pools[mainType][i] == gamePool) {\r\n                checked = true;\r\n                break;\r\n            }\r\n        }\r\n        require(checked, \"Wrong address\");\r\n\r\n        address FT = payment[mainType];\r\n        uint256 balance = IClean(gamePool).clean(SFT);\r\n        IDistributeFT(SFT).distributeFT(FT, mainType, 0, address(0), balance);\r\n        // payment[mainType] = address(this);\r\n        // do not modify payment[mainType], SFT need it to burn value and withdraw shares\r\n        delete pools[mainType];\r\n        delete ratios[mainType];\r\n        delete shareCalc[mainType];\r\n        closed[mainType] = true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superNode\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotAuthorizedError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"subType\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"game\",\"type\":\"address\"}],\"name\":\"AddGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"}],\"name\":\"ChannelUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"FT\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"shareCalc\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ratios\",\"type\":\"uint256[]\"}],\"name\":\"ConfigMainType\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sAgent\",\"type\":\"address\"}],\"name\":\"PassiveAgent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dollar\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"subType\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"gameArgs\",\"type\":\"bytes\"}],\"name\":\"PlayGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"superNode\",\"type\":\"address\"}],\"name\":\"SetDefaultSuperNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sft\",\"type\":\"address\"}],\"name\":\"SetSFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"superNode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"selfNode\",\"type\":\"address\"}],\"name\":\"SetSuperNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"subType\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"SwitchPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"superNode\",\"type\":\"address\"}],\"name\":\"UpgradeAndBind\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"subType\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"game\",\"type\":\"address\"}],\"name\":\"addGames\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"agentOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"areBothNodes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"channelOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"closed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"FT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_shareCalc\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ratios\",\"type\":\"uint256[]\"}],\"name\":\"configMainType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultSuperNode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"games\",\"outputs\":[{\"internalType\":\"contract IGame\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sft\",\"type\":\"address\"}],\"name\":\"initSFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAnyNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isSuperNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"level2nd\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"level3th\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minWeightedDollar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"payment\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dollar\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"subType\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"gameArgs\",\"type\":\"bytes\"}],\"name\":\"play\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerDailyRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"}],\"name\":\"poolList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"FT\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ratios\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ratios\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"relationOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"superNode\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"selfNodeOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superNode\",\"type\":\"address\"}],\"name\":\"setDefaultSuperNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superNode\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"selfNode\",\"type\":\"address\"}],\"name\":\"setSuperNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"setWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"shareCalc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"gamePool\",\"type\":\"address\"}],\"name\":\"shutDown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"superNodeList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superNodeListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"superOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"mainType\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"subType\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"switchPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superNode\",\"type\":\"address\"}],\"name\":\"upgradeAndBind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weightedDollar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Platform", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000563ad18caf76d327eae5c365e2e663b6f78d482d000000000000000000000000563ad18caf76d327eae5c365e2e663b6f78d482d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b6dc56735641c006690db593cc46618dc615b7b6251c4acbc7649720abe6f57d"}