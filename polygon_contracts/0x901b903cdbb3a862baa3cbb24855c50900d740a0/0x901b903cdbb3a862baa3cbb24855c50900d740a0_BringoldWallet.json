{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Team/BringoldWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMultisigOwner {\\n    function isOwnerExternal(address) external view returns (bool);\\n\\n    function getNumConfirmationsRequired() external view returns (uint);\\n}\\n\\ncontract BringoldWallet {\\n    event Deposit(address indexed sender, uint amount, uint balance);\\n    event SubmitTransaction(\\n        address indexed owner,\\n        uint indexed txIndex,\\n        address indexed to,\\n        uint amount,\\n        TokenType tokenType\\n    );\\n    event ConfirmTransaction(address indexed owner, uint indexed txIndex);\\n    event RevokeConfirmation(address indexed owner, uint indexed txIndex);\\n    event ExecuteTransaction(address indexed owner, uint indexed txIndex);\\n\\n    mapping(TokenType => IERC20) tokens;\\n    IERC20 BRIN;\\n    IERC20 BRING;\\n    IERC20 BRLD;\\n    IERC20 USDT;\\n    IMultisigOwner multisigOwner;\\n\\n    struct Transaction {\\n        address to;\\n        uint amount;\\n        bool executed;\\n        uint numConfirmations;\\n        TokenType tokenType;\\n    }\\n    struct TokenBalances {\\n        uint256 BRINBalance;\\n        uint256 BRINGBalance;\\n        uint256 BRLDBalance;\\n        uint256 USDTBalance;\\n    }\\n    // mapping from tx index => owner => bool\\n    mapping(uint => mapping(address => bool)) public isConfirmed;\\n\\n    Transaction[] public transactions;\\n\\n    modifier onlyOwner() {\\n        require(multisigOwner.isOwnerExternal(msg.sender), \\\"not owner\\\");\\n        _;\\n    }\\n\\n    modifier txExists(uint _txIndex) {\\n        require(_txIndex < transactions.length, \\\"tx does not exist\\\");\\n        _;\\n    }\\n\\n    modifier notExecuted(uint _txIndex) {\\n        require(!transactions[_txIndex].executed, \\\"tx already executed\\\");\\n        _;\\n    }\\n\\n    modifier notConfirmed(uint _txIndex) {\\n        require(!isConfirmed[_txIndex][msg.sender], \\\"tx already confirmed\\\");\\n        _;\\n    }\\n    enum TokenType {\\n        BRIN,\\n        BRING,\\n        BRLD,\\n        USDT\\n    }\\n\\n    constructor(\\n        address _brin,\\n        address _bring,\\n        address _brld,\\n        address _usdt,\\n        address _multisigOwner\\n    ) {\\n        multisigOwner = IMultisigOwner(_multisigOwner);\\n        BRIN = IERC20(_brin);\\n        BRING = IERC20(_bring);\\n        BRLD = IERC20(_brld);\\n        USDT = IERC20(_usdt);\\n        tokens[TokenType.BRIN] = BRIN;\\n        tokens[TokenType.BRING] = BRING;\\n        tokens[TokenType.BRLD] = BRLD;\\n        tokens[TokenType.USDT] = USDT;\\n    }\\n\\n    function DepositFunds(\\n        address _account,\\n        uint256 _amount\\n    ) public returns (bool) {\\n        require(_amount > 0, \\\"amount cannot be zero\\\");\\n        bool success = BRIN.transferFrom(_account, address(this), _amount);\\n        emit Deposit(msg.sender, _amount, BRIN.balanceOf(address(this)));\\n        return success;\\n    }\\n\\n    function fetchTransactions() public view returns (Transaction[] memory) {\\n        return transactions;\\n    }\\n\\n    function submitTransaction(\\n        address _to,\\n        uint _amount,\\n        TokenType _tokenType\\n    ) public onlyOwner {\\n        uint txIndex = transactions.length;\\n\\n        transactions.push(\\n            Transaction({\\n                to: _to,\\n                amount: _amount,\\n                executed: false,\\n                numConfirmations: 0,\\n                tokenType: _tokenType\\n            })\\n        );\\n\\n        emit SubmitTransaction(msg.sender, txIndex, _to, _amount, _tokenType);\\n    }\\n\\n    function confirmTransaction(\\n        uint _txIndex\\n    )\\n        public\\n        onlyOwner\\n        txExists(_txIndex)\\n        notExecuted(_txIndex)\\n        notConfirmed(_txIndex)\\n    {\\n        Transaction storage transaction = transactions[_txIndex];\\n        transaction.numConfirmations += 1;\\n        isConfirmed[_txIndex][msg.sender] = true;\\n\\n        emit ConfirmTransaction(msg.sender, _txIndex);\\n    }\\n\\n    function executeTransaction(\\n        uint _txIndex\\n    ) public onlyOwner txExists(_txIndex) notExecuted(_txIndex) {\\n        Transaction storage transaction = transactions[_txIndex];\\n\\n        require(\\n            transaction.amount <= BRIN.balanceOf(address(this)),\\n            \\\"Vault has insufficient balance for this transaction\\\"\\n        );\\n        require(\\n            transaction.numConfirmations >=\\n                multisigOwner.getNumConfirmationsRequired(),\\n            \\\"cannot execute tx\\\"\\n        );\\n\\n        transaction.executed = true;\\n\\n        bool success = tokens[transaction.tokenType].transfer(\\n            transaction.to,\\n            transaction.amount\\n        );\\n        require(success, \\\"tx failed\\\");\\n\\n        emit ExecuteTransaction(msg.sender, _txIndex);\\n    }\\n\\n    function revokeConfirmation(\\n        uint _txIndex\\n    ) public onlyOwner txExists(_txIndex) notExecuted(_txIndex) {\\n        Transaction storage transaction = transactions[_txIndex];\\n\\n        require(isConfirmed[_txIndex][msg.sender], \\\"tx not confirmed\\\");\\n\\n        transaction.numConfirmations -= 1;\\n        isConfirmed[_txIndex][msg.sender] = false;\\n\\n        emit RevokeConfirmation(msg.sender, _txIndex);\\n    }\\n\\n    function getTransactionCount() public view returns (uint) {\\n        return transactions.length;\\n    }\\n\\n    function getTransaction(\\n        uint _txIndex\\n    )\\n        public\\n        view\\n        returns (\\n            address to,\\n            uint amount,\\n            bool executed,\\n            uint numConfirmations,\\n            TokenType tokenType\\n        )\\n    {\\n        Transaction storage transaction = transactions[_txIndex];\\n\\n        return (\\n            transaction.to,\\n            transaction.amount,\\n            transaction.executed,\\n            transaction.numConfirmations,\\n            transaction.tokenType\\n        );\\n    }\\n\\n    function getTokenBalances() external view returns (TokenBalances memory) {\\n        return\\n            TokenBalances(\\n                BRIN.balanceOf(address(this)),\\n                BRING.balanceOf(address(this)),\\n                BRLD.balanceOf(address(this)),\\n                USDT.balanceOf(address(this))\\n            );\\n    }\\n\\n    function getBRINBalance() external view returns (uint) {\\n        return BRIN.balanceOf(address(this));\\n    }\\n\\n    function getBRINGBalance() external view returns (uint) {\\n        return BRING.balanceOf(address(this));\\n    }\\n\\n    function getBRLDBalance() external view returns (uint) {\\n        return BRLD.balanceOf(address(this));\\n    }\\n\\n    function getUSDTBalance() external view returns (uint) {\\n        return USDT.balanceOf(address(this));\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_brin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bring\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_brld\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_multisigOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"ConfirmTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"ExecuteTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"}],\"name\":\"RevokeConfirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum BringoldWallet.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"}],\"name\":\"SubmitTransaction\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"DepositFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"numConfirmations\",\"type\":\"uint256\"},{\"internalType\":\"enum BringoldWallet.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"}],\"internalType\":\"struct BringoldWallet.Transaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBRINBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBRINGBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBRLDBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"BRINBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"BRINGBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"BRLDBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"USDTBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct BringoldWallet.TokenBalances\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"}],\"name\":\"getTransaction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"numConfirmations\",\"type\":\"uint256\"},{\"internalType\":\"enum BringoldWallet.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUSDTBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"}],\"name\":\"revokeConfirmation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"enum BringoldWallet.TokenType\",\"name\":\"_tokenType\",\"type\":\"uint8\"}],\"name\":\"submitTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"numConfirmations\",\"type\":\"uint256\"},{\"internalType\":\"enum BringoldWallet.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BringoldWallet", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000bc0b7de316f4e57c677370ccd3a36697d6fc5de2000000000000000000000000b67b696a7f55a52723d80f62bb5f8532abdbc67400000000000000000000000009a89f63023ac7ea03c8e8810a95e19ef150e2f2000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f0000000000000000000000009a0551fe055675126c63178b0a6fdbb3e49cb2ae", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}