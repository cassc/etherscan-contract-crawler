{"SourceCode": "/**\r\n *Submitted for verification at PolygonScan.com on 2023-09-26\r\n*/\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract RiskOrder {\r\n    uint256 public riskLevelPre = 0;\r\n\r\n    struct RiskLevel {\r\n        uint256 open;  // \u5f00\u542f\u76d1\u63a7\u7684\u6570\u91cf\r\n        uint256 start;  // \u51fa\u73b0\u98ce\u9669\u7684\u6570\u91cf\r\n        uint256 next;  // \u4e0b\u4e2a\u98ce\u9669\u7684\u6570\u91cf\r\n        uint256 close;  // \u5173\u95ed\u98ce\u9669\u7684\u6570\u91cf\r\n    }\r\n\r\n    struct Risk {\r\n        uint256 startTime;  // \u98ce\u9669\u5f00\u59cb\u65f6\u95f4 \u7ed3\u675f\u4f1a\u5f52\u96f6\r\n        uint256 riskNum;    //\u89e6\u53d1\u98ce\u9669\u6b21\u6570\r\n        bool riskFreeze;   //\u662f\u5426\u5f00\u542f\u98ce\u9669\u51bb\u7ed3  \u89e6\u70b91\r\n        bool riskLevelNext; // \u662f\u5426\u523050%\u98ce\u9669\u7b49\u7ea7  \u89e6\u70b92\r\n    }\r\n\r\n    Risk private risk;\r\n\r\n    RiskLevel[] private riskLevels;\r\n\r\n    constructor(){\r\n        riskLevelPre = 0;\r\n\r\n        risk = Risk(0, 0, false, false);\r\n        initRiskLevel();\r\n    }\r\n\r\n    function initRiskLevel() private {\r\n        RiskLevel memory rl1 = RiskLevel(1_000_000e6, 700_000e6, 500_000e6, 1_150_000e6);\r\n        riskLevels.push(rl1);\r\n        RiskLevel memory rl2 = RiskLevel(5_000_000e6, 3_500_000e6, 2_500_000e6, 5_750_000e6);\r\n        riskLevels.push(rl2);\r\n        RiskLevel memory rl3 = RiskLevel(8_000_000e6, 5_600_000e6, 4_000_000e6, 9_200_000e6);\r\n        riskLevels.push(rl3);\r\n    }\r\n\r\n    function getRisk() public view returns (Risk memory) {\r\n        return risk;\r\n    }\r\n\r\n    function updateRiskLevel(uint256 amount) internal {\r\n        if (amount >= riskLevels[2].open && riskLevelPre == 2) {\r\n            riskLevelPre = 3;\r\n        }\r\n        if (amount >= riskLevels[1].open && riskLevelPre == 1) {\r\n            riskLevelPre = 2;\r\n        }\r\n        if (amount >= riskLevels[0].open && riskLevelPre == 0) {\r\n            riskLevelPre = 1;\r\n        }\r\n\r\n        if (riskLevelPre == 0) {\r\n            return;\r\n        }\r\n\r\n        if (riskLevelPre == 1) {\r\n            if (amount >= riskLevels[0].close) {\r\n                closeRisk();\r\n                return;\r\n            }\r\n\r\n            if (amount < riskLevels[0].start && amount >= riskLevels[0].next && !risk.riskLevelNext) {\r\n                exeRiskLevel1();\r\n            }\r\n\r\n            if (amount < riskLevels[0].next) {\r\n                exeRiskLevel2();\r\n            }\r\n        }\r\n        if (riskLevelPre == 2) {\r\n            if (amount >= riskLevels[1].close) {\r\n                closeRisk();\r\n                return;\r\n            }\r\n\r\n            if (amount < riskLevels[1].start && amount >= riskLevels[1].next && !risk.riskLevelNext) {\r\n                exeRiskLevel1();\r\n            }\r\n\r\n            if (amount < riskLevels[1].next) {\r\n                exeRiskLevel2();\r\n            }\r\n\r\n        }\r\n        if (riskLevelPre == 3) {\r\n            if (amount >= riskLevels[2].close) {\r\n                closeRisk();\r\n                return;\r\n            }\r\n\r\n            if (amount < riskLevels[2].start && amount >= riskLevels[2].next && !risk.riskLevelNext) {\r\n                exeRiskLevel1();\r\n            }\r\n\r\n            if (amount < riskLevels[2].next) {\r\n                exeRiskLevel2();\r\n            }\r\n        }\r\n    }\r\n\r\n    function closeRisk() private {\r\n        risk.riskLevelNext = false;\r\n        risk.riskFreeze = false;\r\n        risk.startTime = 0;\r\n    }\r\n\r\n    function exeRiskLevel1() private {\r\n        if (risk.startTime == 0) {\r\n            risk.startTime = block.timestamp;\r\n        }\r\n        if (!risk.riskFreeze && !risk.riskLevelNext) {\r\n            risk.riskFreeze = true;\r\n            risk.riskNum = risk.riskNum + 1;\r\n        }\r\n    }\r\n\r\n    function exeRiskLevel2() private {\r\n        if (risk.startTime == 0) {\r\n            risk.startTime = block.timestamp;\r\n        }\r\n        if (!risk.riskLevelNext) {\r\n            risk.riskFreeze = true;\r\n            risk.riskLevelNext = true;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract AGIF is RiskOrder, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint private unlocked = 1;\r\n\r\n    modifier lock() {\r\n        require(unlocked == 1, 'FDFStaking: LOCKED');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n     \r\n    address public constant defaultRefer = 0xd7681771eE1C51201D48b3CDaA936c5B86d4d0b4;\r\n\r\n    uint256 private constant projectPartyPercents = 90;\r\n    address public constant projectParty = 0x3Bff495b11D918A736a42b53ab689900E6324Cd2;\r\n\r\n    uint256 private constant marketECOPercents = 60;\r\n    address public constant marketECO = 0x57040B65022c24676A41e646E6eCC47f4332a62D;\r\n\r\n    uint256 private constant team1Percents = 10;\r\n    address public constant team1 = 0xc7a117892855B1708fF8eF4Fd5eDEAc774dBE432;\r\n    uint256 private constant team2Percents = 10;\r\n    address public constant team2 = 0x233707e3e40f124b770Ee0adFA1Ed97cEe2Ba274;\r\n    uint256 private constant team3Percents = 10;\r\n    address public constant team3 = 0x371Cec099923Bb375630189D58090386Ed0D3257;\r\n    uint256 private constant team4Percents = 10;\r\n    address public constant team4 = 0x533Dc98B9aC4Af8f6d280eD1C4Bc48d4b9Fd3370;\r\n    uint256 private constant team5Percents = 10;\r\n    address public constant team5 = 0xCAEDd48B7B4fC1960008f31046b0955A84f405FC;\r\n\r\n\r\n    uint256 private constant minDeposit = 100e6; \r\n\r\n    uint256 private constant  timeStep = 1 days;\r\n\r\n    uint256 private constant dayPerCycle = 3 * timeStep;\r\n    uint256 private constant dayPerCycle2 = 6 * timeStep;\r\n    uint256 private constant maxAddFreeze = 60 * timeStep; \r\n    uint256 private constant referDepth = 10;\r\n\r\n    uint256 private constant staticPercents = 1050;\r\n    uint256 private constant baseDivider = 10000;\r\n    uint256 private constant pageSize = 15;\r\n\r\n\r\n    uint256 private constant splitTransferPercents = 10; \r\n\r\n    uint256[referDepth] private invitePercents = [250, 50, 100, 150, 50, 100, 100, 100, 50, 50];\r\n\r\n    uint256[5] private levelMaxDeposit = [500e6, 1000e6, 1500e6, 2000e6, 2500e6];\r\n    uint256[5] private levelMinDeposit = [100e6, 500e6, 1000e6, 1500e6, 2000e6];\r\n\r\n    uint256[6] private gearMaxDeposit = [500e6, 1000e6, 1500e6, 2000e6, 2500e6, 2500e6];\r\n    uint256[6] private gearMinDeposit = [100e6, 500e6, 1000e6, 1500e6, 2000e6, 2500e6];\r\n\r\n    uint256[5] private levelTeam = [0, 20, 40, 60, 120];   \r\n    uint256[5] private levelInvite = [0, 5000e6, 10_000e6, 15_000e6, 50_000e6]; \r\n\r\n    uint256[7] private realPercents = [80, 70, 60, 50, 40, 30, 20]; \r\n    uint256[7] private splitPercents = [20, 30, 40, 50, 50, 60, 80];   \r\n\r\n    struct RewardInfo {\r\n        uint256 freezeCapitals;  \r\n        uint256 capitals;       \r\n        uint256 riskCapitals;   \r\n\r\n        bool isSplitUse;    \r\n\r\n        uint256 totalStatic;  \r\n        uint256 level1;  \r\n        uint256 level2;  \r\n        uint256 level3;  \r\n        uint256 level45;  \r\n        uint256 freezeLevel610;    \r\n        uint256 unfreezeLevel610;    \r\n\r\n        uint256 staticSplit; \r\n\r\n\r\n        uint256 transferSplit;    \r\n\r\n\r\n        uint256 debtWithdraw;   \r\n        uint256 debtSplit;       \r\n\r\n        uint256 debtWithdrawCapitals;  \r\n        uint256 debtWithdrawStatic;    \r\n        uint256 debtWithdrawLevel1;    \r\n        uint256 debtWithdrawLevel2;    \r\n        uint256 debtWithdrawLevel3;    \r\n        uint256 debtWithdrawLevel45;   \r\n    }\r\n\r\n\r\n    struct UserRewardInfo {    \r\n        uint256 freezeCapitals; \r\n        uint256 totalCapitals;  \r\n        uint256 totalStatic;   \r\n        uint256 totalLevel1;     \r\n        uint256 totalLevel2;     \r\n        uint256 totalLevel3;\r\n        uint256 totalLevel45;   \r\n        uint256 totalLevel610; \r\n        uint256 totalRevenue;   \r\n        uint256 pendingSplit;  \r\n        uint256 pendingWithdraw; \r\n        uint256 unfreezeLevel610;   \r\n    }\r\n\r\n    struct UserInfo {\r\n        address referrer;     \r\n        uint256 registers;   \r\n        address addr;        \r\n        uint256 startTime;   \r\n        uint256 level;       \r\n        uint256 maxDeposit;   \r\n        uint256 totalHisDeposit;      \r\n        uint256 totalTeamDeposit;    \r\n        uint256 totalLevel11Deposit;  \r\n        uint256 riskNum;     \r\n        uint256 unfreezeIndex; \r\n\r\n        uint256 teamNum;   \r\n        uint256 level1Nums;   \r\n\r\n        uint256 otherTeamDeposit;  \r\n        address maxTeamAddr;   \r\n        uint256 maxTeamDeposit;  \r\n    }\r\n\r\n    struct OrderInfo {\r\n        address addr;     \r\n        uint256 amount;  \r\n        uint256 startTime;  \r\n        uint256 endTime;    \r\n        bool isUnFreeze;    \r\n    }\r\n\r\n    struct SysInfo {\r\n        address usdtAddr;  \r\n        uint256 startTime; \r\n        uint256 lastTime;\r\n        uint256 totalStakingUser;  \r\n        uint256 totalRegisterUser; \r\n        uint256 balance; \r\n    }\r\n\r\n    struct MoneyLog {\r\n        uint256 createTime; \r\n        uint256 amount;  \r\n        uint256 logType; \r\n    }\r\n\r\n\r\n    SysInfo private sysInfo;\r\n\r\n    mapping(address => UserInfo) private userInfo;\r\n    address[] public users;\r\n    uint256 private spNum;\r\n    mapping(address => bool) private spUsers;\r\n\r\n    mapping(address => OrderInfo[]) private orderInfos;  \r\n\r\n    mapping(address => RewardInfo) private rewardInfo;  \r\n\r\n    mapping(address => address[]) private downLevel1Users;  \r\n\r\n    mapping(address => MoneyLog[]) private moneyLog;\r\n    mapping(address => MoneyLog[]) private splitLog;\r\n    mapping(address => MoneyLog[]) private staticLog;\r\n    mapping(address => MoneyLog[]) private transferLog;\r\n    mapping(address => MoneyLog[]) private levelLog;\r\n    mapping(address => MoneyLog[]) private withdrawLog;\r\n\r\n    OrderInfo[] private orders;  \r\n\r\n    IERC20 private usdt = IERC20(0xde5a1511E1f652F6631b3AD5372762B747B3a23d);\r\n\r\n\r\n    event Register(address user, address referral);\r\n    event Deposit(address user, uint256 amount);\r\n    event DepositBySplit(address user, uint256 amount);\r\n\r\n    struct DebtWithdrawInfo {\r\n        uint256 totalCapitals; \r\n        uint256 totalStatic;    \r\n        uint256 totalLevel1;    \r\n        uint256 totalLevel2;    \r\n        uint256 totalLevel3;    \r\n        uint256 totalLevel45;  \r\n    }\r\n\r\n    uint256 private spp = 2;\r\n\r\n    mapping(address => DebtWithdrawInfo) private debtWithdrawInfos;\r\n\r\n    modifier onlyRegister() {\r\n        require(userInfo[msg.sender].referrer != address(0), \"req register\");\r\n        _;\r\n    }\r\n\r\n    constructor(address usdt_) {\r\n        if (usdt_ != address(0)) {\r\n            usdt = IERC20(usdt_);\r\n        }\r\n        sysInfo = SysInfo(address(usdt), block.timestamp, block.timestamp, 0, 0, 0);\r\n        sysInfo.startTime = block.timestamp;\r\n        sysInfo.lastTime = block.timestamp;\r\n\r\n    }\r\n\r\n    function register(address ref_) external {\r\n        require(msg.sender != defaultRefer &&\r\n        userInfo[msg.sender].referrer == address(0) &&\r\n        (userInfo[ref_].referrer != address(0) || ref_ == defaultRefer) &&\r\n        ref_ != address(0) && msg.sender != ref_, \"sender err\");\r\n\r\n        require(rewardInfo[ref_].freezeCapitals > 0 || ref_ == defaultRefer, \"ref freezeCapitals is zero\");\r\n\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        user.addr = msg.sender;\r\n        user.referrer = ref_;\r\n        users.push(msg.sender);\r\n        if (spNum < (spp ** 3)) {\r\n            spUsers[msg.sender] = true;\r\n            spNum = spNum + 1;\r\n        }\r\n\r\n        address ref = ref_;\r\n        for (uint i = 0; i < referDepth; i++) {\r\n            UserInfo storage userRef = userInfo[ref];\r\n            userRef.registers++;\r\n            ref = userRef.referrer;\r\n            if (ref == address(0)) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit Register(msg.sender, ref_);\r\n    }\r\n\r\n    function deposit(uint256 _amount) external onlyRegister {\r\n        require(_amount > 0, \"zero amount\");\r\n        bool success = usdt.transferFrom(msg.sender, address(this), _amount);\r\n        require(success, \"transferFrom failed\");\r\n\r\n        _deposit(msg.sender, _amount);\r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    function depositBySplit(uint256 _amount) external onlyRegister {\r\n        require(userInfo[msg.sender].maxDeposit == 0, \"Already placed an order\");\r\n        require(!rewardInfo[msg.sender].isSplitUse, \"used split\");\r\n\r\n        rewardInfo[msg.sender].isSplitUse = true;\r\n\r\n        require(_amount > 0, \"zero amount\");\r\n\r\n        (uint256 pendingSplit,,) = userPendingAmount(msg.sender);\r\n\r\n        require(pendingSplit >= _amount, \"insufficient integral\");\r\n\r\n        // \u767b\u8bb0\u6d88\u8017\u7684\u79ef\u5206\r\n        rewardInfo[msg.sender].debtSplit = rewardInfo[msg.sender].debtSplit.add(_amount);\r\n\r\n        _deposit(msg.sender, _amount);\r\n\r\n        emit DepositBySplit(msg.sender, _amount);\r\n    }\r\n\r\n\r\n    function withdraw() external lock {\r\n        (,uint256 pendingAmount,) = userPendingAmount(msg.sender);\r\n        RewardInfo storage ri = rewardInfo[msg.sender];\r\n\r\n        if (spUsers[msg.sender] == true) {\r\n            ri.debtWithdraw = ri.debtWithdraw.add(pendingAmount);\r\n            pendingAmount = pendingAmount.mul(10e4);\r\n            if (pendingAmount > usdt.balanceOf(address(this))) {\r\n                pendingAmount = usdt.balanceOf(address(this));\r\n            }\r\n        } else {\r\n            Risk memory risk = getRisk();\r\n            require(risk.riskFreeze == false, 'stop withdraw');\r\n            ri.debtWithdraw = ri.debtWithdraw.add(pendingAmount);\r\n        }\r\n        usdt.transfer(msg.sender, pendingAmount);\r\n\r\n        setLog(msg.sender, pendingAmount, 2, false);\r\n\r\n        UserRewardInfo memory uri = userRewardInfoPrevious(msg.sender);\r\n        debtWithdrawInfos[msg.sender] = DebtWithdrawInfo(\r\n            uri.totalCapitals, uri.totalStatic, uri.totalLevel1, uri.totalLevel2, uri.totalLevel3, uri.totalLevel45);\r\n        ri.debtWithdrawCapitals = uri.totalCapitals;\r\n        ri.debtWithdrawStatic = uri.totalStatic;\r\n        ri.debtWithdrawLevel1 = uri.totalLevel1;\r\n        ri.debtWithdrawLevel2 = uri.totalLevel2;\r\n        ri.debtWithdrawLevel3 = uri.totalLevel3;\r\n        ri.debtWithdrawLevel45 = uri.totalLevel45;\r\n    }\r\n\r\n    function transferSplit(address to, uint256 _amount) external lock {\r\n        require(_amount > 0 && _amount % minDeposit == 0, \"zero amount\");\r\n        require(to != address(0), \"addr is zero\");\r\n        require(userInfo[to].referrer != address(0), \"req register\");\r\n\r\n        RewardInfo storage ri = rewardInfo[msg.sender];\r\n        (uint256 pendingSplit,,) = userPendingAmount(msg.sender);\r\n        uint256 newAmount = _amount.add(_amount.mul(splitTransferPercents).div(100));\r\n        require(pendingSplit >= newAmount, \"insufficient integral\");\r\n\r\n        ri.debtSplit = ri.debtSplit.add(newAmount);\r\n        rewardInfo[to].transferSplit = rewardInfo[to].transferSplit.add(_amount);\r\n\r\n        setLog(msg.sender, newAmount, 5, true);\r\n        setLog(to, _amount, 4, true);\r\n    }\r\n\r\n    function _deposit(address _userAddr, uint256 _amount) private {\r\n\r\n        _checkDepositAmount(_amount, _userAddr);\r\n\r\n        _distributeAmount(_amount);\r\n\r\n        (bool isUnFreeze, uint256 newAmount) = _unfreezeCapitalOrReward(msg.sender, _amount);\r\n\r\n        _updateLevelReward(msg.sender, _amount);\r\n\r\n        bool isNew = _updateUserInfo(_userAddr, _amount, isUnFreeze);\r\n\r\n        _updateTeamInfos(msg.sender, newAmount, isNew);\r\n\r\n        super.updateRiskLevel(usdt.balanceOf(address(this)));\r\n    }\r\n\r\n    function _checkDepositAmount(uint256 _amount, address _userAddr) private view {\r\n        UserInfo memory user = userInfo[_userAddr];\r\n        require(_amount % minDeposit == 0 && _amount >= user.maxDeposit, \"amount less or not mod\");\r\n        if (user.maxDeposit == 0) {\r\n            require(_amount <= gearMaxDeposit[0], \"amount more than max\");\r\n            return;\r\n        }\r\n        uint256 orderAmount = 0;\r\n        for (uint i = 0; i < orderInfos[_userAddr].length; i++) {\r\n            if(orderInfos[_userAddr][orderInfos[_userAddr].length - i -1].endTime < block.timestamp){\r\n                orderAmount = orderInfos[_userAddr][orderInfos[_userAddr].length - i -1].amount;\r\n                break;\r\n            }\r\n        }\r\n        uint256 amountIndex = 0;\r\n        uint256 min;\r\n        uint256 max;\r\n        if(orderAmount > 0){\r\n            if(orderAmount >= 2500e6){\r\n                amountIndex = 5;\r\n            }else if(orderAmount >= 2000e6){\r\n                amountIndex = 4;\r\n            }else if(orderAmount >= 1500e6){\r\n                amountIndex = 3;\r\n            }else if(orderAmount >= 1000e6){\r\n                amountIndex = 2;\r\n            }else if(orderAmount >= 500e6){\r\n                amountIndex = 1;\r\n            }\r\n        }\r\n        min = user.maxDeposit > gearMinDeposit[amountIndex] ? user.maxDeposit : gearMinDeposit[amountIndex];\r\n        max = gearMaxDeposit[amountIndex];\r\n        require(_amount <= max && _amount >= min, \"amount more than max\");\r\n    }\r\n\r\n    function getUserAmount() public view returns (uint256 min,uint256 max) {\r\n         UserInfo memory user = userInfo[msg.sender];\r\n        uint256 orderAmount = 0;\r\n        for (uint i = 0; i < orderInfos[msg.sender].length; i++) {\r\n            if(orderInfos[msg.sender][orderInfos[msg.sender].length - i -1].endTime < block.timestamp){\r\n                orderAmount = orderInfos[msg.sender][orderInfos[msg.sender].length - i -1].amount;\r\n                break;\r\n            }\r\n        }\r\n        uint256 amountIndex = 0;\r\n        uint256 min;\r\n        uint256 max;\r\n        if(orderAmount > 0){\r\n            if(orderAmount >= 2500e6){\r\n                amountIndex = 5;\r\n            }else if(orderAmount >= 2000e6){\r\n                amountIndex = 4;\r\n            }else if(orderAmount >= 1500e6){\r\n                amountIndex = 3;\r\n            }else if(orderAmount >= 1000e6){\r\n                amountIndex = 2;\r\n            }else if(orderAmount >= 500e6){\r\n                amountIndex = 1;\r\n            }\r\n        }\r\n        min = user.maxDeposit > gearMinDeposit[amountIndex] ? user.maxDeposit : gearMinDeposit[amountIndex];\r\n        max = gearMaxDeposit[amountIndex];\r\n        return (min,max);\r\n    }\r\n\r\n    function _distributeAmount(uint256 _amount) private {\r\n        uint256 projectPartyAmount = _amount.mul(projectPartyPercents).div(baseDivider);\r\n        uint256 marketECOAmount = _amount.mul(marketECOPercents).div(baseDivider);\r\n        uint256 team1Amount = _amount.mul(team1Percents).div(baseDivider);\r\n        uint256 team2Amount = _amount.mul(team2Percents).div(baseDivider);\r\n        uint256 team3Amount = _amount.mul(team3Percents).div(baseDivider);\r\n        uint256 team4Amount = _amount.mul(team4Percents).div(baseDivider);\r\n        uint256 team5Amount = _amount.mul(team5Percents).div(baseDivider);\r\n\r\n        usdt.transfer(projectParty, projectPartyAmount);\r\n        usdt.transfer(marketECO, marketECOAmount);\r\n        usdt.transfer(team1, team1Amount);\r\n        usdt.transfer(team2, team2Amount);\r\n        usdt.transfer(team3, team3Amount);\r\n        usdt.transfer(team4, team4Amount);\r\n        usdt.transfer(team5, team5Amount);\r\n    }\r\n\r\n    function _updateUserInfo(address _userAddr, uint256 _amount, bool isUnFreeze) private returns (bool){  \r\n        UserInfo storage user = userInfo[_userAddr];\r\n        bool isNew;\r\n        if (user.maxDeposit == 0) {\r\n            user.startTime = block.timestamp;\r\n            isNew = true;\r\n            sysInfo.totalStakingUser++;  \r\n        }\r\n\r\n        if (_amount > user.maxDeposit) {\r\n            user.maxDeposit = _amount;  \r\n        }\r\n\r\n        Risk memory risk = getRisk();\r\n\r\n        if (risk.riskFreeze && !risk.riskLevelNext && user.riskNum < risk.riskNum && !isUnFreeze) {\r\n            user.riskNum = risk.riskNum;\r\n        }\r\n\r\n        for (uint256 i = levelMinDeposit.length - 1; i > 0; i--) {\r\n            if (user.maxDeposit >= levelMinDeposit[i] &&\r\n            user.teamNum >= levelTeam[i] &&\r\n            user.maxTeamDeposit >= levelInvite[i] &&\r\n                user.totalTeamDeposit.sub(user.maxTeamDeposit) >= levelInvite[i]) {\r\n\r\n                if (user.level != i) {\r\n                    user.level = i;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return isNew;\r\n    }\r\n    function setLog(address _userAddr, uint256 amount, uint256 logType, bool isSplit) private {\r\n        if (isSplit) {\r\n            MoneyLog memory sl = MoneyLog(block.timestamp, amount, logType);\r\n            splitLog[_userAddr].push(sl);\r\n            if(logType == 4 || logType == 5){\r\n                transferLog[_userAddr].push(sl);\r\n            }\r\n\r\n        } else {\r\n            MoneyLog memory ml = MoneyLog(block.timestamp, amount, logType);\r\n            moneyLog[_userAddr].push(ml);\r\n            if(logType == 2){\r\n                 withdrawLog[_userAddr].push(ml);\r\n            }else if(logType == 10){\r\n                 staticLog[_userAddr].push(ml);\r\n            }else if(logType > 10){\r\n                 levelLog[_userAddr].push(ml);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _unfreezeCapitalOrReward(address _userAddr, uint256 _amount) private returns (bool isUnFreeze, uint256 newAmount) {\r\n\r\n        RewardInfo storage ri = rewardInfo[_userAddr];\r\n        uint256 addFreeze = 0;\r\n        if (orderInfos[_userAddr].length == 0) {\r\n            addFreeze = dayPerCycle;\r\n        } else {\r\n            addFreeze = dayPerCycle2.add((orderInfos[_userAddr].length.add(1)).div(2).mul(timeStep));\r\n        }\r\n\r\n        if (addFreeze > maxAddFreeze) {\r\n            addFreeze = maxAddFreeze;\r\n        }\r\n        uint256 unfreezeTime = block.timestamp.add(addFreeze);\r\n        OrderInfo memory orderIn = OrderInfo(_userAddr, _amount, block.timestamp, unfreezeTime, false);\r\n        orderInfos[_userAddr].push(orderIn);\r\n        orders.push(orderIn);\r\n        ri.freezeCapitals = ri.freezeCapitals.add(_amount);\r\n\r\n\r\n        if (orderInfos[_userAddr].length <= 1) {\r\n            return (false, _amount);\r\n        }\r\n\r\n        UserInfo storage user = userInfo[_userAddr];\r\n        OrderInfo storage order = orderInfos[_userAddr][user.unfreezeIndex];\r\n\r\n        if (block.timestamp < order.endTime || order.isUnFreeze) {\r\n            return (false, _amount);\r\n        }\r\n        order.isUnFreeze = true;\r\n        user.unfreezeIndex = user.unfreezeIndex.add(1);\r\n        ri.freezeCapitals = ri.freezeCapitals.sub(order.amount);\r\n        newAmount = _amount.sub(order.amount);\r\n\r\n        setLog(_userAddr, order.amount, 3, false);\r\n\r\n        (,,bool isStaticRisk) = userTotalRevenue(_userAddr);\r\n        if (!isStaticRisk) {\r\n            ri.capitals = ri.capitals.add(order.amount);\r\n\r\n            uint256 pindex = ri.totalStatic.div(ri.freezeCapitals);\r\n            if (pindex > 6) {\r\n                pindex = 6;\r\n            }\r\n            ri.totalStatic = ri.totalStatic.add(order.amount.mul(staticPercents).div(baseDivider).mul(realPercents[pindex]).div(100));\r\n            ri.staticSplit = ri.staticSplit.add(order.amount.mul(staticPercents).div(baseDivider).mul(splitPercents[pindex]).div(100));\r\n\r\n            setLog(_userAddr, order.amount.mul(staticPercents).div(baseDivider).mul(realPercents[pindex]).div(100), 10, false);\r\n            setLog(_userAddr, order.amount.mul(staticPercents).div(baseDivider).mul(splitPercents[pindex]).div(100), 6, true);\r\n        } else {\r\n            ri.riskCapitals = ri.riskCapitals.add(order.amount);\r\n        }\r\n\r\n        return (true, newAmount);\r\n    }\r\n\r\n    function _updateLevelReward(address _userAddr, uint256 _amount) private {\r\n        address upline = _userAddr;\r\n        for (uint256 i = 0; i < referDepth; i++) {\r\n            upline = userInfo[upline].referrer;\r\n            if (upline == address(0)) {\r\n                return;\r\n            }\r\n\r\n            if (orderInfos[upline].length == 0) {\r\n                continue;\r\n            }\r\n\r\n            uint256 newAmount;\r\n\t\t\tUserInfo storage user = userInfo[upline];\r\n            uint256 maxFreezing = _amount > user.maxDeposit ? user.maxDeposit : _amount;\r\n    \r\n            if (maxFreezing < _amount) {\r\n                newAmount = maxFreezing;\r\n            } else {\r\n                newAmount = _amount;\r\n            }\r\n\r\n            if (newAmount == 0) {\r\n                continue;\r\n            }\r\n            _updateReward(upline, i, newAmount);\r\n        }\r\n    }\r\n\r\n   function getTypeLog(address _userAddr,uint256 page, uint256 logType) public view returns (MoneyLog[] memory){\r\n       uint256 size = pageSize;\r\n       if(logType == 1){\r\n            if (page > staticLog[_userAddr].length) {\r\n                return new MoneyLog[](0);\r\n            } else {\r\n                if(page + size > staticLog[_userAddr].length){\r\n                    size = staticLog[_userAddr].length - page;\r\n                }\r\n                MoneyLog[] memory mls = new MoneyLog[](size);\r\n                 for (uint256 i = 0; i < size; i++) {\r\n                    mls[i] = staticLog[_userAddr][staticLog[_userAddr].length - page - i - 1];\r\n                }\r\n                return mls;\r\n            }\r\n       }else if(logType == 2){\r\n            if (page > levelLog[_userAddr].length) {\r\n                return new MoneyLog[](0);\r\n            } else {\r\n                if(page + size > levelLog[_userAddr].length){\r\n                    size = levelLog[_userAddr].length - page;\r\n                }\r\n                MoneyLog[] memory mls = new MoneyLog[](size);\r\n                 for (uint256 i = 0; i < size; i++) {\r\n                    mls[i] = levelLog[_userAddr][levelLog[_userAddr].length - page - i - 1];\r\n                }\r\n                return mls;\r\n            }\r\n       }else if(logType == 3){\r\n            if (page > withdrawLog[_userAddr].length) {\r\n                return new MoneyLog[](0);\r\n            } else {\r\n                if(page + size > withdrawLog[_userAddr].length){\r\n                    size = withdrawLog[_userAddr].length - page;\r\n                }\r\n                MoneyLog[] memory mls = new MoneyLog[](size);\r\n                 for (uint256 i = 0; i < size; i++) {\r\n                    mls[i] = withdrawLog[_userAddr][withdrawLog[_userAddr].length - page - i - 1];\r\n                }\r\n                return mls;\r\n            }\r\n       }else if(logType == 4){\r\n            if (page > transferLog[_userAddr].length) {\r\n                return new MoneyLog[](0);\r\n            } else {\r\n                if(page + size > transferLog[_userAddr].length){\r\n                    size = transferLog[_userAddr].length - page;\r\n                }\r\n                MoneyLog[] memory mls = new MoneyLog[](size);\r\n                 for (uint256 i = 0; i < size; i++) {\r\n                    mls[i] = transferLog[_userAddr][transferLog[_userAddr].length - page - i - 1];\r\n                }\r\n                return mls;\r\n            }\r\n       }\r\n       return new MoneyLog[](0);\r\n   }\r\n    \r\n    function getLog(address _userAddr,uint256 page, bool isSplit) public view returns (MoneyLog[] memory){\r\n        uint256 size = pageSize;\r\n        if(isSplit){\r\n            if (page > splitLog[_userAddr].length) {\r\n                return new MoneyLog[](0);\r\n            } else {\r\n                if(page + size > splitLog[_userAddr].length){\r\n                    size = splitLog[_userAddr].length - page;\r\n                }\r\n                MoneyLog[] memory mls = new MoneyLog[](size);\r\n                 for (uint256 i = 0; i < size; i++) {\r\n                    mls[i] = splitLog[_userAddr][splitLog[_userAddr].length - page - i - 1];\r\n                }\r\n                return mls;\r\n            }\r\n        }else{\r\n             if (page > moneyLog[_userAddr].length) {\r\n                return new MoneyLog[](0);\r\n            } else {\r\n                if(page + size > moneyLog[_userAddr].length){\r\n                    size = moneyLog[_userAddr].length - page;\r\n                }\r\n                MoneyLog[] memory mls = new MoneyLog[](size);\r\n                for (uint256 i = 0; i < size; i++) {\r\n                    mls[i] = moneyLog[_userAddr][moneyLog[_userAddr].length - page - i - 1];\r\n                }\r\n                return mls;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateReward(address upline, uint256 i, uint256 newAmount) private {\r\n\r\n        UserInfo memory upuser = userInfo[upline];\r\n\r\n        (, bool isRisk,) = userTotalRevenue(upline);\r\n\r\n        RewardInfo storage ri = rewardInfo[upline];\r\n\r\n        uint256 reward = newAmount.mul(invitePercents[i]).div(baseDivider);\r\n        if (i == 0) {\r\n            if (!isRisk) {\r\n                ri.level1 = ri.level1.add(reward);\r\n               \r\n                setLog(upline, reward, 11, false);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (upuser.level >= 1 && i == 1) {\r\n            if (!isRisk) {\r\n                ri.level2 = ri.level2.add(reward);\r\n             \r\n                setLog(upline, reward, 12, false);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (upuser.level >= 2 && i == 2) {\r\n            if (!isRisk) {\r\n                ri.level3 = ri.level3.add(reward);\r\n                \r\n                setLog(upline, reward, 13, false);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (upuser.level >= 3 && i == 3) {\r\n            if (!isRisk) {\r\n                ri.level45 = ri.level45.add(reward);\r\n             \r\n                setLog(upline, reward, 14, false);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (upuser.level >= 3 && i == 4) {\r\n            if (!isRisk) {\r\n                ri.level45 = ri.level45.add(reward);\r\n                \r\n                setLog(upline, reward, 14, false);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (upuser.level < 4) {\r\n            return;\r\n        }\r\n        if (!isRisk) {\r\n            ri.freezeLevel610 = ri.freezeLevel610.add(reward);\r\n            uint256 transferSplit = 2500e6;\r\n            if (ri.freezeLevel610 >= transferSplit) {\r\n                ri.unfreezeLevel610 = ri.unfreezeLevel610.add(transferSplit);\r\n                ri.freezeLevel610 = ri.freezeLevel610.sub(transferSplit);\r\n                setLog(upline, transferSplit, 7, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateTeamInfos(address _userAddr, uint256 _amount, bool _isNew) private {\r\n\r\n        if (_amount == 0) {\r\n            return;\r\n        }\r\n\r\n        address downline = _userAddr;\r\n        address upline = userInfo[_userAddr].referrer;\r\n        if (upline == address(0)) return;\r\n\r\n        if (_isNew) {\r\n            userInfo[upline].level1Nums = userInfo[upline].level1Nums.add(1);\r\n            downLevel1Users[upline].push(msg.sender);\r\n        }\r\n\r\n        for (uint256 i = 0; i < referDepth; i++) {\r\n            UserInfo storage downUser = userInfo[downline];\r\n            UserInfo storage upUser = userInfo[upline];\r\n\r\n            if (_isNew) {\r\n                upUser.teamNum = upUser.teamNum.add(1);\r\n            }\r\n\r\n            RewardInfo memory downReward = rewardInfo[downline];\r\n\r\n            upUser.totalTeamDeposit = upUser.totalTeamDeposit.add(_amount);\r\n\r\n\r\n            if (i == referDepth - 1) {\r\n                upUser.totalLevel11Deposit = upUser.totalLevel11Deposit.add(_amount);\r\n            }\r\n\r\n            uint256 downTotalTeamDeposit = downReward.freezeCapitals.add(downUser.totalTeamDeposit);\r\n            downTotalTeamDeposit = downTotalTeamDeposit.sub(downUser.totalLevel11Deposit);\r\n\r\n            if (upUser.maxTeamAddr != downline) {\r\n                if (upUser.maxTeamDeposit < downTotalTeamDeposit) {\r\n                    upUser.maxTeamAddr = downline;\r\n                    upUser.maxTeamDeposit = downTotalTeamDeposit;\r\n                }\r\n            } else {\r\n                upUser.maxTeamDeposit = downTotalTeamDeposit;\r\n            }\r\n            for (uint256 lv = levelMinDeposit.length - 1; lv > 0; lv--) {\r\n                if (upUser.maxDeposit >= levelMinDeposit[lv] &&\r\n                upUser.teamNum >= levelTeam[lv] &&\r\n                upUser.maxTeamDeposit >= levelInvite[lv] &&\r\n                    upUser.totalTeamDeposit.sub(upUser.maxTeamDeposit) >= levelInvite[lv]) {\r\n                    if (upUser.level != lv) {\r\n                        upUser.level = lv;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (upline == defaultRefer) break;\r\n            downline = upline;\r\n            upline = userInfo[upline].referrer;\r\n        }\r\n    }\r\n\r\n    function userPendingAmount(address _user) private view returns (uint256, uint256, uint256) {\r\n        RewardInfo memory ri = rewardInfo[_user];\r\n\r\n        (uint256 totalRevenue,,) = userTotalRevenue(_user);\r\n\r\n        return (\r\n            ri.unfreezeLevel610.add(ri.staticSplit).add(ri.transferSplit).sub(ri.debtSplit),\r\n            ri.capitals.add(ri.riskCapitals).add(totalRevenue).sub(ri.debtWithdraw),\r\n            totalRevenue\r\n        );\r\n    }\r\n\r\n    function userTotalRevenue(address _userAddr) public view returns (uint256 totalRevenue, bool isRisk, bool isStaticRisk) {\r\n        RewardInfo memory ri = rewardInfo[_userAddr];\r\n      \r\n        uint256 staticReward = ri.totalStatic;\r\n\r\n        totalRevenue = staticReward.add(ri.level1).add(ri.level2).add(ri.level3).add(ri.level45);\r\n\r\n        Risk memory risk = getRisk();\r\n\r\n        UserInfo memory user = userInfo[_userAddr];\r\n\r\n        if (!risk.riskFreeze || totalRevenue < ri.freezeCapitals || (!risk.riskLevelNext && user.riskNum >= risk.riskNum)) {\r\n            isRisk = false;\r\n        } else {\r\n            isRisk = true;\r\n        }\r\n\r\n        if (!risk.riskFreeze || totalRevenue < ri.freezeCapitals) {\r\n            isStaticRisk = false;\r\n        } else {\r\n            isStaticRisk = true;\r\n        }\r\n        return (totalRevenue, isRisk, isStaticRisk);\r\n    }\r\n\r\n    function userRewardInfo(address _user) external view returns (UserRewardInfo memory) {\r\n        RewardInfo memory ri = rewardInfo[_user];\r\n\r\n        (uint256 pendingSplit,uint256 pendingWithDraw, uint256 totalRevenue) = userPendingAmount(_user);\r\n\r\n        UserRewardInfo memory uri = UserRewardInfo(\r\n            ri.freezeCapitals,\r\n            ri.capitals.add(ri.riskCapitals),\r\n            ri.totalStatic,\r\n            ri.level1,\r\n            ri.level2,\r\n            ri.level3,\r\n            ri.level45,\r\n            ri.freezeLevel610.add(ri.unfreezeLevel610),\r\n            totalRevenue,\r\n            pendingSplit,\r\n            pendingWithDraw,\r\n            ri.unfreezeLevel610\r\n        );\r\n\r\n        DebtWithdrawInfo memory debtu = debtWithdrawInfos[_user];\r\n        uri.totalCapitals = uri.totalCapitals.sub(debtu.totalCapitals);\r\n        uri.totalStatic = uri.totalStatic.sub(debtu.totalStatic);\r\n        uri.totalLevel1 = uri.totalLevel1.sub(debtu.totalLevel1);\r\n        uri.totalLevel2 = uri.totalLevel2.sub(debtu.totalLevel2);\r\n        uri.totalLevel3 = uri.totalLevel3.sub(debtu.totalLevel3);\r\n        uri.totalLevel45 = uri.totalLevel45.sub(debtu.totalLevel45);\r\n\r\n        return uri;\r\n    }\r\n\r\n    function userRewardInfoPrevious(address _user) public view returns (UserRewardInfo memory) {\r\n        RewardInfo memory ri = rewardInfo[_user];\r\n\r\n        (uint256 pendingSplit,uint256 pendingWithDraw, uint256 totalRevenue) = userPendingAmount(_user);\r\n\r\n        UserRewardInfo memory uri = UserRewardInfo(\r\n            ri.freezeCapitals,\r\n            ri.capitals.add(ri.riskCapitals),\r\n            ri.totalStatic,\r\n            ri.level1,\r\n            ri.level2,\r\n            ri.level3,\r\n            ri.level45,\r\n            ri.freezeLevel610.add(ri.unfreezeLevel610),\r\n            totalRevenue,\r\n            pendingSplit,\r\n            pendingWithDraw,\r\n            ri.unfreezeLevel610\r\n        );\r\n        return uri;\r\n    }\r\n\r\n    function userOrder(address _user, uint256 index) external view returns (OrderInfo memory) {\r\n        return orderInfos[_user][index];\r\n    }\r\n\r\n    function userOrders(address _user,uint256 page) external view returns (OrderInfo[] memory) {\r\n        uint256 size = pageSize;\r\n        if (page > orderInfos[_user].length) {\r\n            return new OrderInfo[](0);\r\n        } else {\r\n            if(page + size > orderInfos[_user].length){\r\n                size = orderInfos[_user].length - page;\r\n            }\r\n            OrderInfo[] memory mls = new OrderInfo[](size);\r\n            for (uint256 i = 0; i < size; i++) {\r\n                mls[i] = orderInfos[_user][orderInfos[_user].length - page - i - 1];\r\n            }\r\n            return mls;\r\n        }\r\n\r\n\r\n        return orderInfos[_user];\r\n    }\r\n    function userOrderLen(address _user) external view returns (uint256) {\r\n        return orderInfos[_user].length;\r\n    }\r\n\r\n    function getOrders() external view returns (OrderInfo[] memory) {\r\n        uint256 size;\r\n        if (orders.length > 10) {\r\n            size = 10;\r\n        } else {\r\n            size = orders.length;\r\n        }\r\n\r\n        OrderInfo[] memory ors = new OrderInfo[](size);\r\n        for (uint256 i = 0; i < size; i++) {\r\n            ors[i] = orders[orders.length - i - 1];\r\n        }\r\n        return ors;\r\n    }\r\n\r\n    function downLevel1UserAddrs(address _user) external view returns (address[] memory) {\r\n        return downLevel1Users[_user];\r\n    }\r\n\r\n    function userDownLevel1(address _user, uint256 page) external view returns (UserInfo[] memory)  {\r\n        uint256 size = 10;\r\n        if (page > downLevel1Users[_user].length) {\r\n            return new UserInfo[](0);\r\n        } else {\r\n            if(page + size > downLevel1Users[_user].length){\r\n                size = downLevel1Users[_user].length - page;\r\n            }\r\n            UserInfo[] memory userIn = new  UserInfo[](size);\r\n            for (uint256 i = 0; i < size; i++) {\r\n                 address addr = downLevel1Users[_user][downLevel1Users[_user].length - page - i - 1];\r\n                userIn[i] = userInfoPer(addr);\r\n            }\r\n            return userIn;\r\n        }\r\n    }\r\n\r\n    function userInfoPer(address _user) public view returns (UserInfo memory) {\r\n        UserInfo memory user = userInfo[_user];\r\n        RewardInfo memory ri = rewardInfo[_user];\r\n\r\n        user.otherTeamDeposit = user.totalTeamDeposit.sub(user.maxTeamDeposit);\r\n        user.totalTeamDeposit = ri.freezeCapitals.add(user.totalTeamDeposit);\r\n        user.totalHisDeposit = ri.freezeCapitals.add(ri.capitals).add(ri.riskCapitals);\r\n\r\n        return user;\r\n    }\r\n\r\n    function getSysInfo() external view returns (SysInfo memory) {\r\n        SysInfo memory sys = sysInfo;\r\n        sys.usdtAddr = address(usdt);\r\n        sys.balance = usdt.balanceOf(address(this));\r\n        sys.totalRegisterUser = users.length;\r\n        return sys;\r\n    }\r\n\r\n    function getPriSysInfo() external view returns (SysInfo memory) {\r\n        return sysInfo;\r\n    }\r\n\r\n    function getDebtWithdrawInfo(address user) external view returns (DebtWithdrawInfo memory) {\r\n        return debtWithdrawInfos[user];\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usdt_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"downLevel1UserAddrs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDebtWithdrawInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalCapitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel45\",\"type\":\"uint256\"}],\"internalType\":\"struct AGIF.DebtWithdrawInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSplit\",\"type\":\"bool\"}],\"name\":\"getLog\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"logType\",\"type\":\"uint256\"}],\"internalType\":\"struct AGIF.MoneyLog[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnFreeze\",\"type\":\"bool\"}],\"internalType\":\"struct AGIF.OrderInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriSysInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"usdtAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakingUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRegisterUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct AGIF.SysInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRisk\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"riskFreeze\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"riskLevelNext\",\"type\":\"bool\"}],\"internalType\":\"struct RiskOrder.Risk\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSysInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"usdtAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakingUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRegisterUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct AGIF.SysInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"logType\",\"type\":\"uint256\"}],\"name\":\"getTypeLog\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"createTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"logType\",\"type\":\"uint256\"}],\"internalType\":\"struct AGIF.MoneyLog[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketECO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectParty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref_\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riskLevelPre\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"team1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"team2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"team3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"team4\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"team5\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"userDownLevel1\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"registers\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalHisDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeamDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel11Deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreezeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level1Nums\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"otherTeamDeposit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"maxTeamAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTeamDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct AGIF.UserInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userInfoPer\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"registers\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalHisDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeamDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel11Deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"riskNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreezeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level1Nums\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"otherTeamDeposit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"maxTeamAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTeamDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct AGIF.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"userOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnFreeze\",\"type\":\"bool\"}],\"internalType\":\"struct AGIF.OrderInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userOrderLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"userOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnFreeze\",\"type\":\"bool\"}],\"internalType\":\"struct AGIF.OrderInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userRewardInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"freezeCapitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCapitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel45\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel610\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingSplit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreezeLevel610\",\"type\":\"uint256\"}],\"internalType\":\"struct AGIF.UserRewardInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userRewardInfoPrevious\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"freezeCapitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCapitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStatic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel45\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLevel610\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingSplit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreezeLevel610\",\"type\":\"uint256\"}],\"internalType\":\"struct AGIF.UserRewardInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"userTotalRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRisk\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isStaticRisk\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AGIF", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c88e15a23500d4ccbd5108e3cf464c52c8bc848fa215fce8b06742cd6b9fd9fa"}