{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.8.12;\r\n\r\n/// @title Interface for price gates, one of the two gates that NFT minters must pass thru\r\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\r\ninterface IPriceGate {\r\n\r\n    /// @notice This function should return how much ether or tokens the minter must pay to mint an NFT\r\n    function getCost(uint) external view returns (uint ethCost);\r\n\r\n    /// @notice This function is called by MerkleIdentity when minting an NFT. It is where funds get collected.\r\n    function passThruGate(uint, address) external payable;\r\n}\r\n\r\n/// @title A factory pattern for the simplest price gates, what's the price and who does it go to?\r\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\r\n/// @notice This contract has a management key that can add new gates\r\n/// @dev Note passing thru the gate forwards all gas, so beneficiary can be a contract, possibly malicious\r\ncontract FixedPricePassThruGate is IPriceGate {\r\n\r\n    // this represents a single gate\r\n    struct Gate {\r\n        uint ethCost;  // how much does it cost to pass thru it\r\n        address beneficiary;  // who gets the eth that is paid\r\n    }\r\n\r\n    // count the gates\r\n    uint public numGates;\r\n    // array-like map of gate structs\r\n    mapping (uint => Gate) public gates;\r\n\r\n    error NotEnoughETH(address from, uint price, uint paid);\r\n    error TransferETHFailed(address from, address to, uint amount);\r\n\r\n    /// @notice This adds a price gate to the list of available price gates\r\n    /// @dev Anyone can call this, adding gates that don't get connected to merkleIndex isn't useful\r\n    /// @param _ethCost amount of ether required to pass thru the gate\r\n    /// @param _beneficiary who receives the ether\r\n    function addGate(uint _ethCost, address _beneficiary) external {\r\n        // prefix operator increments then evaluates, first gate is at index 1\r\n        Gate storage gate = gates[++numGates];\r\n        gate.ethCost = _ethCost;\r\n        gate.beneficiary = _beneficiary;\r\n    }\r\n\r\n    /// @notice Get the cost of passing thru this gate\r\n    /// @param index which gate are we talking about?\r\n    /// @return _ethCost the amount of ether required to pass thru this gate\r\n    function getCost(uint index) override external view returns (uint) {\r\n        return gates[index].ethCost;\r\n    }\r\n\r\n    /// @notice Pass thru this gate, should be called by MerkleIndex\r\n    /// @dev This can be called by anyone, devs can call it to test it on mainnet\r\n    /// @param index which gate are we passing thru?\r\n    function passThruGate(uint index, address sender) override external payable {\r\n        Gate memory gate = gates[index];\r\n        if (msg.value < gate.ethCost) {\r\n            revert NotEnoughETH(sender, gate.ethCost, msg.value);\r\n        }\r\n\r\n        // pass thru ether\r\n        if (msg.value > 0) {\r\n            // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\r\n            (bool sent,) = gate.beneficiary.call{value: gate.ethCost}(\"\");\r\n            if (sent == false) {\r\n                revert TransferETHFailed(address(this), gate.beneficiary, gate.ethCost);\r\n            }\r\n\r\n            uint leftover = msg.value - gate.ethCost;\r\n            if (leftover > 0) {\r\n                (bool sent2,) = sender.call{value: leftover}(\"\");\r\n                if (sent2 == false) {\r\n                    revert TransferETHFailed(address(this), sender, leftover);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"}],\"name\":\"NotEnoughETH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferETHFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"addGate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numGates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"passThruGate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "FixedPricePassThruGate", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fd4c467984e8e413ab5b747c19ce78fedb84b29a1da785eb08a3e292766e2c44"}