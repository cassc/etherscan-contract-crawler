{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BasePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport {SafeTransferLib} from \\\"./libs/SafeTransferLib.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {IWETH} from \\\"./interfaces/IWETH.sol\\\";\\nimport {IERC20Permit} from \\\"./interfaces/IERC20Permit.sol\\\";\\n\\ncontract BasePool {\\n    using SafeTransferLib for IERC20;\\n\\n    struct DisperseData {\\n        address token;\\n        address payable[] recipients;\\n        uint256[] values;\\n    }\\n\\n    struct PermitData {\\n        address token;\\n        uint256 value;\\n        uint256 deadline;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    IWETH immutable wNATIVE;\\n\\n    /// @notice Contract owner.\\n    // can not be transferred to another address\\n    address public owner;\\n\\n\\n    event DisperseToken(address token, uint256 totalAmount);\\n\\n    constructor(address _wNATIVE) {\\n        wNATIVE = IWETH(_wNATIVE);\\n    }\\n\\n    receive() external payable {}\\n\\n    /// @notice Modifier to only allow the contract owner to call a function\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"only-owner\\\");\\n        _;\\n    }\\n\\n    function initialize(address _owner) virtual public {\\n        require(owner == address(0), \\\"initialized\\\");\\n        owner = _owner;\\n    }\\n\\n    function disperseEther(\\n        address payable[] calldata recipients,\\n        uint256[] calldata values\\n    ) external payable onlyOwner {\\n        _disperseEther(recipients, values);\\n    }\\n\\n    function _disperseEther(\\n        address payable[] calldata recipients,\\n        uint256[] calldata values\\n    ) internal {\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < recipients.length; ++i) { \\n            _safeTransferETHWithFallback(recipients[i], values[i]);\\n            total += values[i];\\n        }\\n        require(msg.value == total, \\\"must send exact amount\\\");\\n        emit DisperseToken(address(0), total);\\n    }\\n\\n    function disperseToken(\\n        IERC20 token,\\n        address payable[] calldata recipients,\\n        uint256[] calldata values\\n    ) external onlyOwner {\\n        _disperseToken(token, recipients, values);\\n    }\\n\\n    function disperseTokenWithPermit(\\n        IERC20 token,\\n        address payable[] calldata recipients,\\n        uint256[] calldata values, \\n        PermitData calldata permitData\\n    )\\n        external\\n        payable\\n        onlyOwner\\n    {\\n        selfPermit(permitData);\\n        _disperseToken(token, recipients, values);\\n    }\\n\\n    function _disperseToken(\\n        IERC20 token,\\n        address payable[] calldata recipients,\\n        uint256[] calldata values\\n    ) internal {\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < recipients.length; ++i) total += values[i];\\n        token.safeTransferFrom(msg.sender, address(this), total);\\n        emit DisperseToken(address(token), total);\\n        for (uint256 i = 0; i < recipients.length; ++i)\\n            token.safeTransfer(recipients[i], values[i]);\\n    }\\n\\n    function batchDisperse(DisperseData[] calldata disperseDatas)\\n        external\\n        payable\\n        onlyOwner\\n    {\\n        _batchDisperse(disperseDatas);\\n    }\\n\\n    function batchDisperseWithPermit(\\n        DisperseData[] calldata disperseDatas,\\n        PermitData[] calldata permitDatas\\n    ) \\n        external\\n        payable\\n        onlyOwner\\n    {\\n        batchSelfPermit(permitDatas);\\n        _batchDisperse(disperseDatas);\\n    }\\n\\n    function _batchDisperse(DisperseData[] calldata disperseDatas) internal {\\n        uint256 disperseCount = disperseDatas.length;\\n        bool nativePoolAlreadyExist;\\n        for (uint256 i = 0; i < disperseCount; ++i) {\\n            if (address(disperseDatas[i].token) == address(0)) {\\n                if (nativePoolAlreadyExist) revert(\\\"Only one native disperse is allowed\\\");\\n                nativePoolAlreadyExist = true;\\n                _disperseEther(\\n                    disperseDatas[i].recipients,\\n                    disperseDatas[i].values\\n                );\\n            } else {\\n                _disperseToken(\\n                    IERC20(disperseDatas[i].token),\\n                    disperseDatas[i].recipients,\\n                    disperseDatas[i].values\\n                );\\n            }\\n        }\\n    }\\n\\n    // this method is identical to `disperseToken()` feature wise\\n    // the difference between `disperseToken()` and this method is that: \\n    // instead of `transferFrom()` the caller only once, and using `transfer()` for each of the recipients; this method will call `transferFrom()` for each recipients.\\n    // `disperseToken()` choose to use `transfer()` for the recipients to save the gas costs for allowance checks, at the cost of one extra external call (`transferFrom` the caller to `address(this)`)\\n    // however, the saved amount can be less than the cost of the extra `transferFrom()`\\n    // this is where `disperseTokenSimple()` comes in, when the number of recipients is rather small, this method will be cheaper than `disperseToken()`\\n    // and the frontend should compare the gas costs of the two methods to choose which one to be used.\\n    function disperseTokenSimple(\\n        IERC20 token,\\n        address[] calldata recipients,\\n        uint256[] calldata values\\n    ) external onlyOwner {\\n        for (uint256 i = 0; i < recipients.length; ++i)\\n            token.transferFrom(msg.sender, recipients[i], values[i]);\\n    }\\n\\n    // Functionality to call permit on any EIP-2612-compliant token\\n    function selfPermit(PermitData calldata permitData) public {\\n        IERC20Permit(permitData.token).permit(\\n            msg.sender,\\n            address(this),\\n            permitData.value,\\n            permitData.deadline,\\n            permitData.v,\\n            permitData.r,\\n            permitData.s\\n        );\\n    }\\n\\n    function batchSelfPermit(\\n        PermitData[] calldata permitDatas\\n    ) public {\\n        for (uint256 i = 0; i < permitDatas.length; ++i) {\\n            selfPermit(permitDatas[i]);\\n        }\\n    }\\n\\n    function sweepToken(\\n        address token,\\n        uint256 amount,\\n        address recipient\\n    ) external onlyOwner {\\n        if (token == address(0)) {\\n            _safeTransferETHWithFallback(recipient, amount);\\n        } else {\\n            IERC20(token).safeTransfer(recipient, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer ETH. If the ETH transfer fails, wrap the ETH and try send it as WETH.\\n     * @param to account who to send the ETH or WETH to\\n     * @param amount uint256 how much ETH or WETH to send\\n     */\\n    function _safeTransferETHWithFallback(address to, uint256 amount) internal {\\n        if (!_safeTransferETH(to, amount)) {\\n            wNATIVE.deposit{value: amount}();\\n            wNATIVE.transfer(to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer ETH and return the success status.\\n     * @dev This function only forwards 30,000 gas to the callee.\\n     * @param to account who to send the ETH to\\n     * @param value uint256 how much ETH to send\\n     */\\n    function _safeTransferETH(address to, uint256 value)\\n        internal\\n        returns (bool)\\n    {\\n        (bool success, ) = to.call{value: value, gas: 30_000}(new bytes(0));\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    event Debug(bool one, bool two, uint256 retsize);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\"\r\n    },\r\n    \"contracts/DistributionPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.15;\\n\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {IWETH} from \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./BasePool.sol\\\";\\n\\ncontract DistributionPool is BasePool {\\n    using SafeTransferLib for IERC20;\\n\\n    enum PoolStatus {\\n        None, // not exists\\n        Initialized, // unfunded\\n        Funded, // funded\\n        Closed // canceled or fully distributed\\n    }\\n\\n    struct PoolData {\\n        string name;\\n        address distributor;\\n        IERC20 token;\\n        uint48 startTime;\\n        uint48 deadline;\\n        uint128 totalAmount;\\n        uint128 claimedAmount;\\n        uint128 fundedAmount;\\n        address[] claimers;\\n        uint128[] amounts;\\n    }\\n\\n    struct PoolInfo {\\n        string name;\\n        IERC20 token;\\n        address distributor;\\n        bool fundNow;\\n        address[] claimers;\\n        uint128[] amounts;\\n        uint48 startTime;\\n        uint48 deadline;\\n    }\\n\\n    uint256 private locked = 1;\\n\\n    uint256 public lastPoolId;\\n\\n    mapping(uint256 => PoolData) public pools;\\n    mapping(uint256 => PoolStatus) public poolsStatus;\\n    mapping(address => mapping(uint256 => uint256)) public userClaimedAmount;\\n\\n    event Created(uint256 indexed poolId);\\n    event Canceled(uint256 indexed poolId);\\n    event Claimed(uint256 indexed poolId, address claimer);\\n    event Funded(uint256 indexed poolId, address funder);\\n    event Distributed(uint256 indexed poolId);\\n\\n    constructor(address _wNATIVE) BasePool(_wNATIVE) {\\n    }\\n\\n    function initialize(address _owner) override public {\\n        super.initialize(_owner);\\n        // initialize ReentrancyGuard\\n        locked = 1;\\n    }\\n\\n    modifier nonReentrant() {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n        locked = 2;\\n        _;\\n        locked = 1;\\n    }\\n\\n    /// Create a new distribution pool\\n    function create(PoolInfo calldata poolInfo)\\n        external\\n        payable\\n        nonReentrant\\n        onlyOwner\\n        returns (uint256)\\n    {\\n        return _create(poolInfo);\\n    }\\n\\n    function createWithPermit(\\n        PoolInfo calldata poolInfo,\\n        PermitData calldata permitData\\n    ) \\n        external\\n        payable\\n        nonReentrant\\n        onlyOwner\\n        returns (uint256)\\n    {\\n        selfPermit(permitData);\\n        return _create(poolInfo);\\n    }\\n\\n    function batchCreate(PoolInfo[] calldata poolInfos)\\n        external\\n        payable\\n        nonReentrant\\n        onlyOwner\\n        returns (uint256[] memory)\\n    {\\n        return _batchCreate(poolInfos);\\n    }\\n\\n    function batchCreateWithPermit(PoolInfo[] calldata poolInfos, PermitData[] calldata permitDatas)\\n        external\\n        payable\\n        nonReentrant\\n        onlyOwner\\n        returns (uint256[] memory)\\n    {\\n        batchSelfPermit(permitDatas);\\n        return _batchCreate(poolInfos);\\n    }\\n\\n    function _create(PoolInfo calldata poolInfo)\\n        internal\\n        returns (uint256 poolId)\\n    {\\n        require(\\n            poolInfo.startTime > block.timestamp,\\n            \\\"startTime must be in the future\\\"\\n        );\\n        // set `deadline` = `startTime` means that the user cannot claim by themselves (but distributor can distribute, and owner can cancel)\\n        require(\\n            poolInfo.deadline >= poolInfo.startTime,\\n            \\\"deadline must be after startTime\\\"\\n        );\\n        uint128 totalAmount;\\n        {\\n            uint256 claimersLength = poolInfo.claimers.length;\\n            require(claimersLength > 0, \\\"must specify at least one claimer\\\");\\n            uint256 amountsLength = poolInfo.amounts.length;\\n            require(\\n                claimersLength == amountsLength,\\n                \\\"length of claimers and amounts must be equal\\\"\\n            );\\n            require(\\n                poolInfo.claimers[0] != address(0),\\n                \\\"claimer must be a valid address\\\"\\n            );\\n            require(\\n                poolInfo.amounts[0] > 0,\\n                \\\"amount must be greater than 0\\\"\\n            );\\n\\n            // set totalAmount to first claimer\\n            totalAmount = poolInfo.amounts[0];\\n            \\n            // then start iterating from second claimer onwards (if claimersLength >= 2)\\n            for (uint256 i = 1; i < claimersLength; ++i) {\\n                require(\\n                    poolInfo.amounts[i] > 0,\\n                    \\\"amount must be greater than 0\\\"\\n                );\\n                // address 0 check is not needed because the first claimer address already checked above \\n                require(\\n                    poolInfo.claimers[i] > poolInfo.claimers[i - 1],\\n                    \\\"Not sorted or duplicate\\\"\\n                );\\n                // will revert on overflow when `totalAmount + poolInfo.amounts[i] > type(uint128).max`\\n                totalAmount += poolInfo.amounts[i];\\n            }\\n        }\\n        poolId = ++lastPoolId;\\n        uint128 receivedAmount;\\n        if (poolInfo.fundNow) {\\n            receivedAmount = _receiveOrPullFundsFromMsgSender(\\n                poolInfo.token,\\n                totalAmount\\n            );\\n            poolsStatus[poolId] = PoolStatus.Funded;\\n        } else {\\n            poolsStatus[poolId] = PoolStatus.Initialized;\\n        }\\n        pools[poolId] = PoolData({\\n            name: poolInfo.name,\\n            distributor: poolInfo.distributor,\\n            token: poolInfo.token,\\n            startTime: poolInfo.startTime,\\n            deadline: poolInfo.deadline,\\n            totalAmount: totalAmount,\\n            fundedAmount: receivedAmount,\\n            claimedAmount: 0,\\n            claimers: poolInfo.claimers,\\n            amounts: poolInfo.amounts\\n        });\\n        emit Created(poolId);\\n        return poolId;\\n    }\\n\\n    function _batchCreate(PoolInfo[] calldata poolInfos)\\n        internal\\n        returns (uint256[] memory)\\n    {\\n        uint256 poolCount = poolInfos.length;\\n        uint256[] memory poolIds = new uint256[](poolCount);\\n        bool nativePoolAlreadyExist;\\n        for (uint256 i = 0; i < poolCount; ++i) {\\n            // only one native pool is allowed in batch create\\n            // because `msg.value` is used to fund the pool\\n            if (address(poolInfos[i].token) == address(0)) {\\n                if (nativePoolAlreadyExist) revert(\\\"Only one native pool is allowed\\\");\\n                nativePoolAlreadyExist = true;\\n            }\\n            poolIds[i] = _create(poolInfos[i]);\\n        }\\n        return poolIds;\\n    }\\n\\n    /// @notice claim tokens from a pool\\n    /// @dev nonReentrant check in single method.\\n    function claim(uint256[] calldata _poolIds, uint256[] calldata _indexes) external nonReentrant {\\n        uint256 poolIdsLength = _poolIds.length;\\n        for (uint256 i = 0; i < poolIdsLength; ++i) {\\n            _claimSinglePool(_poolIds[i], _indexes[i]);\\n        }\\n    }\\n\\n    function claimSinglePool(uint256 _poolId, uint256 _index) external nonReentrant {\\n        _claimSinglePool(_poolId, _index);\\n    }\\n\\n    function _claimSinglePool(uint256 _poolId, uint256 _index) internal {\\n        require(\\n            poolsStatus[_poolId] == PoolStatus.Funded,\\n            \\\"pool must be funded\\\"\\n        );\\n        PoolData storage pool = pools[_poolId];\\n        require(block.timestamp > pool.startTime, \\\"claim not started yet\\\");\\n        require(block.timestamp < pool.deadline, \\\"claim deadline passed\\\");\\n        if (pool.claimers[_index] == msg.sender) {\\n            return\\n                _claimTokenIfUnclaimed(\\n                    _poolId,\\n                    msg.sender,\\n                    pool.amounts[_index],\\n                    pool\\n                );\\n        }\\n    }\\n\\n    function _claimTokenIfUnclaimed(\\n        uint256 _poolId,\\n        address _claimer,\\n        uint128 _amount,\\n        PoolData storage pool\\n    ) internal {\\n        if (userClaimedAmount[_claimer][_poolId] == 0) {\\n            pool.claimedAmount += _amount;\\n            // if all the tokens are claimed, so we can close the pool (in some cases there may left some tokens, owner can make a `sweepToken` to get them back)\\n            if (pool.claimedAmount == pool.totalAmount) {\\n                poolsStatus[_poolId] = PoolStatus.Closed;\\n            }\\n            userClaimedAmount[_claimer][_poolId] = _amount;\\n            if (address(pool.token) == address(0)) {\\n                _safeTransferETHWithFallback(_claimer, _amount);\\n            } else {\\n                pool.token.safeTransfer(_claimer, _amount);\\n            }\\n            emit Claimed(_poolId, _claimer);\\n        }\\n    }\\n\\n    /// fund a pool\\n    function fund(uint256 _poolId) external payable nonReentrant {\\n        _fundSinglePool(pools[_poolId], _poolId);\\n    }\\n\\n    function fundWithPermit(\\n        uint256 _poolId,\\n        PermitData calldata permitData\\n    )\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        selfPermit(permitData);\\n        _fundSinglePool(pools[_poolId], _poolId);\\n    }\\n\\n    function batchFund(uint256[] calldata _poolIds) external payable nonReentrant {\\n        _batchFund(_poolIds);\\n    }\\n\\n    function batchFundWithPermit(\\n        uint256[] calldata _poolIds,\\n        PermitData[] calldata permitDatas\\n    )\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        batchSelfPermit(permitDatas);\\n        return _batchFund(_poolIds);\\n    }\\n\\n    function _fundSinglePool(PoolData storage pool, uint256 _poolId) internal {\\n        require(\\n            poolsStatus[_poolId] == PoolStatus.Initialized,\\n            \\\"pool must be pending\\\"\\n        );\\n        pool.fundedAmount = _receiveOrPullFundsFromMsgSender(\\n            pool.token,\\n            pool.totalAmount\\n        );\\n        poolsStatus[_poolId] = PoolStatus.Funded;\\n        emit Funded(_poolId, msg.sender);\\n    }\\n\\n    function _batchFund(uint256[] calldata _poolIds)\\n        internal\\n    {\\n        bool nativePoolAlreadyExist;\\n        for (uint256 i = 0; i < _poolIds.length; ++i) {\\n            PoolData storage pool = pools[_poolIds[i]];\\n            if (address(pool.token) == address(0)) {\\n                if (nativePoolAlreadyExist) revert(\\\"Only one native is allowed\\\");\\n                nativePoolAlreadyExist = true;\\n            }\\n            _fundSinglePool(pool, _poolIds[i]);\\n        }\\n    }\\n\\n    /// distribute tokens\\n    function distribute(uint256 _poolId) external payable nonReentrant {\\n        _distributeSinglePool(_poolId);\\n    }\\n\\n    function distributeWithPermit(\\n        uint256 _poolId,\\n        PermitData calldata permitData\\n    )\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        selfPermit(permitData);\\n        _distributeSinglePool(_poolId);\\n    }\\n\\n    function batchDistribute(uint256[] calldata _poolIds) external nonReentrant {\\n        for (uint256 i = 0; i < _poolIds.length; ++i) {\\n            _distributeSinglePool(_poolIds[i]);\\n        }\\n    }\\n\\n    function _distributeSinglePool(uint256 _poolId) internal {\\n        PoolData storage pool = pools[_poolId];\\n        //  If no distributor is specified, anyone can distribute\\n        require(\\n            pool.distributor == address(0) || pool.distributor == msg.sender,\\n            \\\"only distributor can distribute\\\"\\n        );\\n        if (poolsStatus[_poolId] == PoolStatus.Initialized) {\\n            _fundSinglePool(pool, _poolId);\\n        } else {\\n            require(\\n                poolsStatus[_poolId] == PoolStatus.Funded,\\n                \\\"pool must be funded\\\"\\n            );\\n        }\\n        uint256 claimerLength = pool.claimers.length;\\n        for (uint256 i = 0; i < claimerLength; ++i) {\\n            _claimTokenIfUnclaimed(\\n                _poolId,\\n                pool.claimers[i],\\n                pool.amounts[i],\\n                pool\\n            );\\n        }\\n        emit Distributed(_poolId);\\n    }\\n\\n    /// @dev cancel a pool and get unclaimed tokens back\\n    function cancel(uint256[] calldata _poolIds) external onlyOwner nonReentrant {\\n        for (uint256 i = 0; i < _poolIds.length; ++i) {\\n            _cancelSinglePool(_poolIds[i]);\\n        }\\n    }\\n\\n    /// @notice refundable tokens will return to msg.sender\\n    function _cancelSinglePool(uint256 _poolId) internal {\\n        require(\\n            poolsStatus[_poolId] != PoolStatus.Closed,\\n            \\\"pool already closed\\\"\\n        );\\n        PoolData storage pool = pools[_poolId];\\n        require(\\n            pool.startTime > block.timestamp || pool.deadline < block.timestamp,\\n            \\\"ongoing pool can not be canceled\\\"\\n        );\\n        poolsStatus[_poolId] = PoolStatus.Closed;\\n        uint128 refundableAmount = pool.fundedAmount - pool.claimedAmount;\\n        if (refundableAmount > 0) {\\n            if (address(pool.token) == address(0)) {\\n                _safeTransferETHWithFallback(msg.sender, refundableAmount);\\n            } else {\\n                pool.token.safeTransfer(msg.sender, refundableAmount);\\n            }\\n        }\\n        emit Canceled(_poolId);\\n    }\\n\\n    function _receiveOrPullFundsFromMsgSender(IERC20 token, uint128 wantAmount)\\n        internal\\n        returns (uint128 receivedAmount)\\n    {\\n        if (address(token) == address(0)) {\\n            require(msg.value == wantAmount, \\\"!msg.value\\\");\\n            receivedAmount = wantAmount;\\n        } else {\\n            // no need to require msg.value == 0 here\\n            // the owner can always use `sweepToken` to get eth back\\n            uint128 tokenBalanceBefore = _safeUint128(\\n                token.balanceOf(address(this))\\n            );\\n            token.safeTransferFrom(msg.sender, address(this), wantAmount);\\n            receivedAmount =\\n                _safeUint128(token.balanceOf(address(this))) -\\n                tokenBalanceBefore;\\n            // this check ensures the token is not a fee-on-transfer token\\n            // which is not supported yet\\n            require(\\n                receivedAmount >= wantAmount,\\n                \\\"received token amount must be greater than or equal to wantAmount\\\"\\n            );\\n        }\\n    }\\n\\n    // internal utils\\n    function _safeUint128(uint256 x) internal pure returns (uint128) {\\n        require(x < type(uint128).max, \\\"!uint128.max\\\");\\n        return uint128(x);\\n    }\\n\\n    function getPoolById(uint256 poolId)\\n        external\\n        view\\n        returns (PoolData memory, PoolStatus)\\n    {\\n        return (pools[poolId], poolsStatus[poolId]);\\n    }\\n}\"\r\n    },\r\n    \"contracts/PoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\nimport \\\"./DistributionPool.sol\\\";\\n\\n/// @title The PoolFactory allows users to create own dPool very cheaply.\\ncontract PoolFactory {\\n    /// @notice The instance to which all proxies will point.\\n    DistributionPool public immutable distributionPoolImp;\\n\\n    /// contract _owner => dPool contract address\\n    mapping(address => address) public distributionPoolOf;\\n    \\n    event DistributionPoolCreated(\\n        address indexed creator,\\n        address contractAddress\\n    );\\n\\n    /// @notice Contract constructor.\\n    constructor(address _wNATIVE) {\\n        distributionPoolImp = new DistributionPool(_wNATIVE);\\n        distributionPoolImp.initialize(address(this));\\n    }\\n\\n    /**\\n     * @notice Creates a clone.\\n     * @return The newly created contract address\\n     */\\n    function create() external returns (address) {\\n        address _dPool = Clones.clone(address(distributionPoolImp));\\n        DistributionPool(payable(_dPool)).initialize(msg.sender);\\n\\n        distributionPoolOf[msg.sender] = _dPool;\\n        emit DistributionPoolCreated(msg.sender, _dPool);\\n\\n        return _dPool;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wNATIVE\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"Canceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"DisperseToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fundNow\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"claimers\",\"type\":\"address[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"deadline\",\"type\":\"uint48\"}],\"internalType\":\"struct DistributionPool.PoolInfo[]\",\"name\":\"poolInfos\",\"type\":\"tuple[]\"}],\"name\":\"batchCreate\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fundNow\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"claimers\",\"type\":\"address[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"deadline\",\"type\":\"uint48\"}],\"internalType\":\"struct DistributionPool.PoolInfo[]\",\"name\":\"poolInfos\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct BasePool.PermitData[]\",\"name\":\"permitDatas\",\"type\":\"tuple[]\"}],\"name\":\"batchCreateWithPermit\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"internalType\":\"struct BasePool.DisperseData[]\",\"name\":\"disperseDatas\",\"type\":\"tuple[]\"}],\"name\":\"batchDisperse\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"internalType\":\"struct BasePool.DisperseData[]\",\"name\":\"disperseDatas\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct BasePool.PermitData[]\",\"name\":\"permitDatas\",\"type\":\"tuple[]\"}],\"name\":\"batchDisperseWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_poolIds\",\"type\":\"uint256[]\"}],\"name\":\"batchDistribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_poolIds\",\"type\":\"uint256[]\"}],\"name\":\"batchFund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_poolIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct BasePool.PermitData[]\",\"name\":\"permitDatas\",\"type\":\"tuple[]\"}],\"name\":\"batchFundWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct BasePool.PermitData[]\",\"name\":\"permitDatas\",\"type\":\"tuple[]\"}],\"name\":\"batchSelfPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_poolIds\",\"type\":\"uint256[]\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_poolIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_indexes\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claimSinglePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fundNow\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"claimers\",\"type\":\"address[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"deadline\",\"type\":\"uint48\"}],\"internalType\":\"struct DistributionPool.PoolInfo\",\"name\":\"poolInfo\",\"type\":\"tuple\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fundNow\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"claimers\",\"type\":\"address[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"deadline\",\"type\":\"uint48\"}],\"internalType\":\"struct DistributionPool.PoolInfo\",\"name\":\"poolInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct BasePool.PermitData\",\"name\":\"permitData\",\"type\":\"tuple\"}],\"name\":\"createWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"disperseEther\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"disperseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"disperseTokenSimple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct BasePool.PermitData\",\"name\":\"permitData\",\"type\":\"tuple\"}],\"name\":\"disperseTokenWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct BasePool.PermitData\",\"name\":\"permitData\",\"type\":\"tuple\"}],\"name\":\"distributeWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct BasePool.PermitData\",\"name\":\"permitData\",\"type\":\"tuple\"}],\"name\":\"fundWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getPoolById\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"deadline\",\"type\":\"uint48\"},{\"internalType\":\"uint128\",\"name\":\"totalAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"claimedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"fundedAmount\",\"type\":\"uint128\"},{\"internalType\":\"address[]\",\"name\":\"claimers\",\"type\":\"address[]\"},{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"}],\"internalType\":\"struct DistributionPool.PoolData\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"enum DistributionPool.PoolStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"startTime\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"deadline\",\"type\":\"uint48\"},{\"internalType\":\"uint128\",\"name\":\"totalAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"claimedAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"fundedAmount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolsStatus\",\"outputs\":[{\"internalType\":\"enum DistributionPool.PoolStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct BasePool.PermitData\",\"name\":\"permitData\",\"type\":\"tuple\"}],\"name\":\"selfPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userClaimedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DistributionPool", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://824e6fbc2ed02884c0e9cde0d70df6c644089be28534edb18c33aeeb7de73050"}