{"SourceCode": "// File: xvmc-contracts/libs/standard/Address.sol\r\n\r\n\r\npragma solidity >=0.6.12 <=0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: xvmc-contracts/libs/standard/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: xvmc-contracts/libs/standard/SafeERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: xvmc-contracts/governor.sol\r\n\r\n\r\n\r\npragma solidity 0.8.0;\r\n\r\n\r\n\r\n\r\ninterface IacPool {\r\n    function setCallFee(uint256 _callFee) external;\r\n    function totalShares() external returns (uint256);\r\n    function totalVotesFor(uint256 proposalID) external returns (uint256);\r\n    function setAdmin(address _admin, address _treasury) external;\r\n    function setTreasury(address _treasury) external;\r\n\tfunction addAndExtendStake(address _recipientAddr, uint256 _amount, uint256 _stakeID, uint256 _lockUpTokensInSeconds) external;\r\n    function giftDeposit(uint256 _amount, address _toAddress, uint256 _minToServeInSecs) external;\r\n    function harvest() external;\r\n\tfunction calculateHarvestXVMCRewards() external view returns (uint256);\r\n}\r\n\r\ninterface IMasterChef {\r\n    function set(uint256 _pid, uint256 _allocPoint, uint16 _depositFeeBP, bool _withUpdate) external;\r\n    function updateEmissionRate(uint256 _gajPerBlock) external;\r\n    function setFeeAddress(address _feeAddress) external;\r\n    function dev(address _devaddr) external;\r\n    function transferOwnership(address newOwner) external;\r\n    function XVMCPerBlock() external returns (uint256);\r\n    function totalAllocPoint() external returns (uint256);\r\n    function updatePool(uint256 _pid) external;\r\n    function owner() external returns (address);\r\n\tfunction setGovernorFee(uint256 _amount) external;\r\n}\r\n\r\ninterface IXVMCtreasury {\r\n    function requestWithdraw(address _token, address _receiver, uint _value) external;\r\n}\r\n\r\ninterface IOldChef {\r\n\tfunction burnTokens(uint256 _amount) external;\r\n}\r\n\r\ninterface IConsensus {\r\n\tfunction totalXVMCStaked() external view returns(uint256);\r\n\tfunction tokensCastedPerVote(uint256 _forID) external view returns(uint256);\r\n\tfunction isGovInvalidated(address _failedGov) external view returns(bool, bool);\r\n}\r\n\r\ninterface IPolygonMultisig {\r\n\tfunction isOwner(address) external view returns(bool);\r\n}\r\n\r\ninterface IRewardBoost {\r\n\tfunction updateDelayBetweenEvents(uint256 _delay) external;\r\n\tfunction updateGrandEventLength(uint256 _length) external;\r\n}\r\n\r\n    /**\r\n     * XVMC governor is a decentralized masterchef governed by it's users\r\n     * Works as a decentralized cryptocurrency with no third-party control\r\n     * Effectively creating a DAO through time-deposits\r\n     *\r\n     * In order to earn staking rewards, users must lock up their tokens.\r\n     * Certificates of deposit or time deposit are the biggest market in the world\r\n     * The longer the lockup period, the higher the rewards(APY) and voting power \r\n     * The locked up stakers create the governance council, through which\r\n     * the protocol can be upgraded in a decentralized manner.\r\n     *\r\n     * Users are utilized as oracles through on-chain voting regulating the entire system(events,\r\n     * rewards, APYs, fees, bonuses,...)\r\n     * The token voting is overpowered by the consensus mechanism(locked up stakers)\r\n     *\r\n     * It is a real DAO creating an actual decentralized finance ecosystem\r\n     *\r\n     * https://macncheese.finance/\r\n    */\r\n\r\ncontract XVMCgovernor {\r\n    using SafeERC20 for IERC20;\r\n    \r\n    uint256 public immutable goldenRatio = 1618; //1.618 is the golden ratio\r\n\taddress public immutable oldToken = 0x6d0c966c8A09e354Df9C48b446A474CE3343D912;\r\n    address public immutable token = 0x970ccEe657Dd831e9C37511Aa3eb5302C1Eb5EEe; //XVMC token\r\n    \r\n    //masterchef address\r\n    address public immutable masterchef = 0x6ff40a8a1fe16075bD6008A48befB768BE08b4b0;\r\n    address public immutable oldChefOwner = 0x27771BB243c37B35091b0A1e8b69C816249c2E71;\r\n\t\r\n\t//https://docs.polygon.technology/docs/faq/commit-chain-multisigs/\r\n\taddress public immutable polygonMultisig = 0x355b8E02e7F5301E6fac9b7cAc1D6D9c86C0343f; \r\n\t\r\n    address public immutable consensusContract = 0xDDd4982e3E9e5C5C489321D2143b8a027f535112;\r\n    address public immutable farmContract = 0xdf47e7a036A6a85F92898176b5A8B4B4b9fBF25A;\r\n    address public immutable fibonacceningContract = 0xff5a8072565726A055690bd14924022DE020623A; //reward boost contract\r\n    address public immutable basicContract = 0xEBD2e542F593d8E03543661BCc70ad2474e6DBad;\r\n\t\r\n\taddress public immutable nftStakingContract = 0xD7bf9953d090D6Eb5fC8f6707e88Ea057beD08cB;\r\n\taddress public immutable nftAllocationContract = 0x765A3045902B164dA1a7619BEc58DE64cf7Bdfe2;\r\n    \r\n    //Addresses for treasuryWallet and NFT wallet\r\n    address public treasuryWallet = 0xC44D3FB20a7fA7eff7437c1C39d34A68A2046BA7;\r\n    address public nftWallet = 0xcCb906C2233A39aA14f60d2F836EB24492D83713;\r\n    \r\n    //addresses for time-locked deposits(autocompounding pools)\r\n    address public immutable acPool1 = 0xfFB71361dD8Fc3ef0831871Ec8dd51B413ed093C;\r\n    address public immutable acPool2 = 0x9a9AEF66624C3fa77DaACcA9B51DE307FA09bd50;\r\n    address public immutable acPool3 = 0x1F8a5D98f1e2F10e93331D27CF22eD7985EF6a12;\r\n    address public immutable acPool4 = 0x30019481FC501aFa449781ac671103Feb0d6363C;\r\n    address public immutable acPool5 = 0x8c96105ea574727e94d9C199c632128f1cA584cF;\r\n    address public immutable acPool6 = 0x605c5AA14BdBf0d50a99836e7909C631cf3C8d46;\r\n        \r\n    //pool ID in the masterchef for respective Pool address and dummy token\r\n    uint256 public immutable acPool1ID = 2;\r\n    uint256 public immutable acPool2ID = 3;\r\n    uint256 public immutable acPool3ID = 4;\r\n    uint256 public immutable acPool4ID = 5;\r\n    uint256 public immutable acPool5ID = 6;\r\n    uint256 public immutable acPool6ID = 7;\r\n\t\r\n\tuint256 public immutable nftStakingPoolID = 10;\r\n    \r\n    mapping(address => uint256) private _rollBonus;\r\n\t\r\n\tmapping(address => address[]) public signaturesConfirmed; //for multi-sig\r\n\tmapping(address => mapping(address => bool)) public alreadySigned; //alreadySigned[owner][newGovernor]\r\n\t\r\n\tuint256 public newGovernorBlockDelay = 189000; //in blocks (roughly 5 days at beginning)\r\n    \r\n    uint256 public costToVote = 500000 * 1e18;  // 500K coins. All proposals are valid unless rejected. This is a minimum to prevent spam\r\n    uint256 public delayBeforeEnforce = 3 days; //minimum number of TIME between when proposal is initiated and executed\r\n\r\n    uint256 public maximumVoteTokens; // maximum tokens that can be voted with to prevent tyrany\r\n    \r\n    //fibonaccening event can be scheduled once minimum threshold of tokens have been collected\r\n    uint256 public thresholdFibonaccening = 10000000000 * 1e18; //10B coins\r\n    \r\n    //delays for Fibonnaccening Events\r\n    uint256 public immutable minDelay = 1 days; // has to be called minimum 1 day in advance\r\n    uint256 public immutable maxDelay = 31 days; //1month.. is that good? i think yes\r\n    \r\n    uint256 public lastRegularReward = 33333000000000000000000; //remembers the last reward used(outside of boost)\r\n    bool public eventFibonacceningActive = true; // prevent some functions if event is active ..threshold and durations for fibonaccening\r\n\t//NOT: IS set to active at launch as the reward boost is already active!\r\n    \r\n    uint256 public blocksPerSecond = 434783; // divide by a million\r\n    uint256 public durationForCalculation= 12 hours; //period used to calculate block time\r\n    uint256  public lastBlockHeight; //block number when counting is activated\r\n    uint256 public recordTimeStart; //timestamp when counting is activated\r\n    bool public countingBlocks;\r\n\r\n\tbool public isInflationStatic; // if static, inflation stays perpetually at 1.618% annually. If dynamic, it reduces by 1.618% on each reward boost\r\n    uint256  public totalFibonacciEventsAfterGrand; //used for rebalancing inflation after Grand Fib\r\n    \r\n    uint256 public newGovernorRequestBlock;\r\n    address public eligibleNewGovernor; //used for changing smart contract\r\n    bool public changeGovernorActivated;\r\n\r\n\tbool public fibonacciDelayed; //used to delay fibonaccening events through vote\r\n\t\r\n\tuint256 public lastHarvestedTime;\r\n\r\n\tbool public setFarmRewards;\r\n\r\n    event SetInflation(uint256 rewardPerBlock);\r\n    event TransferOwner(address newOwner, uint256 timestamp);\r\n    event EnforceGovernor(address _newGovernor, address indexed enforcer);\r\n    event GiveRolloverBonus(address recipient, uint256 amount, address poolInto);\r\n\tevent Harvest(address indexed sender, uint256 callFee);\r\n\tevent Multisig(address signer, address newGovernor, bool sign, uint256 idToVoteFor);\r\n    \r\n    constructor(\r\n\t\taddress _acPool1,\r\n\t\taddress _acPool2,\r\n\t\taddress _acPool3,\r\n\t\taddress _acPool4,\r\n\t\taddress _acPool5,\r\n\t\taddress _acPool6) {\r\n\t\t\t_rollBonus[_acPool1] = 75;\r\n\t\t\t_rollBonus[_acPool2] = 100;\r\n\t\t\t_rollBonus[_acPool3] = 150;\r\n\t\t\t_rollBonus[_acPool4] = 250;\r\n\t\t\t_rollBonus[_acPool5] = 350;\r\n\t\t\t_rollBonus[_acPool6] = 500;\r\n    }    \r\n\r\n    \r\n    /**\r\n     * Updates circulating supply and maximum vote token variables\r\n     */\r\n    function updateMaximumVotetokens() external {\r\n        maximumVoteTokens = getTotalSupply() / 10000;\r\n    }\r\n    \r\n\r\n    /**\r\n     * Calculates average block time\r\n     * No decimals so we keep track of \"100blocks\" per second\r\n\t * It will be used in the future to keep inflation static, while block production can be dynamic\r\n\t * (bitcoin adjusts to 1 block per 10minutes, XVMC inflation is dependant on the production of blocks on Polygon which can vary)\r\n     */\r\n    function startCountingBlocks() external {\r\n        require(!countingBlocks, \"already counting blocks\");\r\n        countingBlocks = true;\r\n        lastBlockHeight = block.number;\r\n        recordTimeStart = block.timestamp;\r\n    } \r\n    function calculateAverageBlockTime() external {\r\n        require(countingBlocks && (recordTimeStart + durationForCalculation) <= block.timestamp);\r\n        blocksPerSecond = 1000000 * (block.number - lastBlockHeight) / (block.timestamp - recordTimeStart);\r\n        countingBlocks = false;\r\n    }\r\n    \r\n    function getRollBonus(address _bonusForPool) external view returns (uint256) {\r\n        return _rollBonus[_bonusForPool];\r\n    }\r\n    \r\n    /**\r\n     * Return total(circulating) supply.\r\n     * Total supply = total supply of XVMC token(new) + (total supply of oldToken - supply of old token inside contract of new token) * 1000\r\n\t * New XVMC token = 1000 * old token (can be swapped inside the token contract, contract holds old tokens)\r\n\t * Old XVMC tokens held inside the contract of token are basically tokens that have been swapped to new token at a ratio of (1:1000)\r\n    */\r\n    function getTotalSupply() public view returns(uint256) {\r\n        return (IERC20(token).totalSupply() +\r\n\t\t\t\t\t1000 * (IERC20(oldToken).totalSupply() - IERC20(oldToken).balanceOf(token)));\r\n    }\r\n    \r\n    /**\r\n     * Mass equivalent to massUpdatePools in masterchef, but only for relevant pools\r\n    */\r\n    function updateAllPools() external {\r\n        IMasterChef(masterchef).updatePool(0); // XVMC-USDC and XVMC-wmatic\r\n    \tIMasterChef(masterchef).updatePool(1); \r\n    \tIMasterChef(masterchef).updatePool(8); //meme pool 8,9\r\n    \tIMasterChef(masterchef).updatePool(9);\r\n\t\tIMasterChef(masterchef).updatePool(10); // NFT staking\r\n        IMasterChef(masterchef).updatePool(acPool1ID);\r\n    \tIMasterChef(masterchef).updatePool(acPool2ID); \r\n    \tIMasterChef(masterchef).updatePool(acPool3ID); \r\n    \tIMasterChef(masterchef).updatePool(acPool4ID); \r\n    \tIMasterChef(masterchef).updatePool(acPool5ID); \r\n    \tIMasterChef(masterchef).updatePool(acPool6ID); \r\n    }\r\n    \r\n     /**\r\n     * Rebalances farms in masterchef\r\n     */\r\n    function rebalanceFarms() external {\r\n    \tIMasterChef(masterchef).updatePool(0);\r\n    \tIMasterChef(masterchef).updatePool(1); \r\n    }\r\n   \r\n     /**\r\n     * Rebalances Pools and allocates rewards in masterchef\r\n     * Pools with higher time-lock must always pay higher rewards in relative terms\r\n     * Eg. for 1XVMC staked in the pool 6, you should always be receiving\r\n     * 50% more rewards compared to staking in pool 4\r\n     * \r\n     * QUESTION: should we create a modifier to prevent rebalancing during inflation events?\r\n     * Longer pools compound on their interests and earn much faster?\r\n     * On the other hand it could also be an incentive to hop to pools with longer lockup\r\n\t * Could also make it changeable through voting\r\n     */\r\n    function rebalancePools() public {\r\n\t    uint256 balancePool1 = IERC20(token).balanceOf(acPool1);\r\n    \tuint256 balancePool2 = IERC20(token).balanceOf(acPool2);\r\n    \tuint256 balancePool3 = IERC20(token).balanceOf(acPool3);\r\n    \tuint256 balancePool4 = IERC20(token).balanceOf(acPool4);\r\n    \tuint256 balancePool5 = IERC20(token).balanceOf(acPool5);\r\n    \tuint256 balancePool6 = IERC20(token).balanceOf(acPool6);\r\n\t\t\r\n    \tIMasterChef(masterchef).set(acPool1ID, (balancePool1 * 2 / 1e26), 0, false);\r\n    \tIMasterChef(masterchef).set(acPool2ID, (balancePool2 * 3 / 1e26), 0, false);\r\n    \tIMasterChef(masterchef).set(acPool3ID, (balancePool3 * 5 / 1e26), 0, false);\r\n    \tIMasterChef(masterchef).set(acPool4ID, (balancePool4 * 10 / 1e26), 0, false);\r\n    \tIMasterChef(masterchef).set(acPool5ID, (balancePool5 * 13 / 1e26), 0, false);\r\n    \tIMasterChef(masterchef).set(acPool6ID, (balancePool6 * 15 / 1e26), 0, false); \r\n    \t\r\n    \t//equivalent to massUpdatePools() in masterchef, but we loop just through relevant pools\r\n    \tIMasterChef(masterchef).updatePool(acPool1ID);\r\n    \tIMasterChef(masterchef).updatePool(acPool2ID); \r\n    \tIMasterChef(masterchef).updatePool(acPool3ID); \r\n    \tIMasterChef(masterchef).updatePool(acPool4ID); \r\n    \tIMasterChef(masterchef).updatePool(acPool5ID); \r\n    \tIMasterChef(masterchef).updatePool(acPool6ID); \r\n    }\r\n\t\r\n\tfunction harvestAll() public {\r\n\t\tIacPool(acPool1).harvest();\r\n\t\tIacPool(acPool2).harvest();\r\n\t\tIacPool(acPool3).harvest();\r\n\t\tIacPool(acPool4).harvest();\r\n\t\tIacPool(acPool5).harvest();\r\n\t\tIacPool(acPool6).harvest();\r\n\t}\r\n\r\n    /**\r\n     * Harvests from all pools and rebalances rewards\r\n     */\r\n    function harvest() external {\r\n        require(msg.sender == tx.origin, \"no proxy/contracts\");\r\n\r\n        uint256 totalFee = pendingHarvestRewards();\r\n\r\n\t\tharvestAll();\r\n        rebalancePools();\r\n\t\t\r\n\t\tlastHarvestedTime = block.timestamp;\r\n\t\r\n\t\tIERC20(token).safeTransfer(msg.sender, totalFee);\r\n\r\n\t\temit Harvest(msg.sender, totalFee);\r\n    }\r\n\t\r\n\t// Shifting the decimal on pool rebalancing and have to increase farm rewards as well\r\n\tfunction initiatePools() external {\r\n\t\trequire(!setFarmRewards, \"already set\");\r\n\t\tIMasterChef(masterchef).set(0, 4000, 0, false); \r\n\t\tIMasterChef(masterchef).set(1, 2000, 0, false); \r\n\t\tsetFarmRewards = true;\r\n\t}\r\n\r\n\tfunction pendingHarvestRewards() public view returns (uint256) {\r\n\t\tuint256 totalRewards = IacPool(acPool1).calculateHarvestXVMCRewards() + IacPool(acPool2).calculateHarvestXVMCRewards() + IacPool(acPool3).calculateHarvestXVMCRewards() +\r\n        \t\t\t\t\tIacPool(acPool4).calculateHarvestXVMCRewards() + IacPool(acPool5).calculateHarvestXVMCRewards() + IacPool(acPool6).calculateHarvestXVMCRewards();\r\n\t\treturn totalRewards;\r\n\t}\r\n    \r\n    /**\r\n     * Mechanism, where the governor gives the bonus \r\n     * to user for extending(re-commiting) their stake\r\n     * tldr; sends the gift deposit, which resets the timer\r\n     * the pool is responsible for calculating the bonus\r\n     */\r\n    function stakeRolloverBonus(address _toAddress, address _depositToPool, uint256 _bonusToPay, uint256 _stakeID) external {\r\n        require(\r\n            msg.sender == acPool1 || msg.sender == acPool2 || msg.sender == acPool3 ||\r\n            msg.sender == acPool4 || msg.sender == acPool5 || msg.sender == acPool6);\r\n        \r\n        IacPool(_depositToPool).addAndExtendStake(_toAddress, _bonusToPay, _stakeID, 0);\r\n        \r\n        emit GiveRolloverBonus(_toAddress, _bonusToPay, _depositToPool);\r\n    }\r\n\r\n    /**\r\n     * Sets inflation in Masterchef\r\n     */\r\n    function setInflation(uint256 rewardPerBlock) external {\r\n        require(msg.sender == fibonacceningContract);\r\n    \tIMasterChef(masterchef).updateEmissionRate(rewardPerBlock);\r\n\r\n        emit SetInflation(rewardPerBlock);\r\n    }\r\n\t\r\n\tfunction rememberReward() external {\r\n\t\trequire(msg.sender == fibonacceningContract);\r\n\t\tlastRegularReward = IMasterChef(masterchef).XVMCPerBlock();\r\n\t}\r\n    \r\n    \r\n    function enforceGovernor() external {\r\n        require(msg.sender == consensusContract);\r\n\t\trequire(newGovernorRequestBlock + newGovernorBlockDelay < block.number, \"time delay not yet passed\");\r\n\r\n\t\tIMasterChef(masterchef).setFeeAddress(eligibleNewGovernor);\r\n        IMasterChef(masterchef).dev(eligibleNewGovernor);\r\n        IMasterChef(masterchef).transferOwnership(eligibleNewGovernor); //transfer masterchef ownership\r\n\t\t\r\n\t\tIERC20(token).safeTransfer(eligibleNewGovernor, IERC20(token).balanceOf(address(this))); // send collected XVMC tokens to new governor\r\n        \r\n\t\temit EnforceGovernor(eligibleNewGovernor, msg.sender);\r\n    }\r\n\t\r\n    function setNewGovernor(address beneficiary) external {\r\n        require(msg.sender == consensusContract);\r\n        newGovernorRequestBlock = block.number;\r\n        eligibleNewGovernor = beneficiary;\r\n        changeGovernorActivated = true;\r\n    }\r\n\t\r\n\tfunction governorRejected() external {\r\n\t\trequire(changeGovernorActivated, \"not active\");\r\n\t\t\r\n\t\t(bool _govInvalidated, ) = IConsensus(consensusContract).isGovInvalidated(eligibleNewGovernor);\r\n\t\tif(_govInvalidated) {\r\n\t\t\tchangeGovernorActivated = false;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction treasuryRequest(address _tokenAddr, address _recipient, uint256 _amountToSend) external {\r\n\t\trequire(msg.sender == consensusContract);\r\n\t\tIXVMCtreasury(treasuryWallet).requestWithdraw(\r\n\t\t\t_tokenAddr, _recipient, _amountToSend\r\n\t\t);\r\n\t}\r\n\t\r\n\tfunction updateDurationForCalculation(uint256 _newDuration) external {\r\n\t    require(msg.sender == basicContract);\r\n\t    durationForCalculation = _newDuration;\r\n\t}\r\n\t\r\n\tfunction delayFibonacci(bool _arg) external {\r\n\t    require(msg.sender == consensusContract);\r\n\t    fibonacciDelayed = _arg;\r\n\t}\r\n\t\r\n\tfunction setActivateFibonaccening(bool _arg) external {\r\n\t\trequire(msg.sender == fibonacceningContract);\r\n\t\teventFibonacceningActive = _arg;\r\n\t}\r\n\r\n\tfunction setPool(uint256 _pid, uint256 _allocPoint, uint16 _depositFeeBP, bool _withUpdate) external {\r\n\t    require(msg.sender == farmContract);\r\n\t    IMasterChef(masterchef).set(_pid, _allocPoint, _depositFeeBP, _withUpdate);\r\n\t}\r\n\t\r\n\tfunction setThresholdFibonaccening(uint256 newThreshold) external {\r\n\t    require(msg.sender == basicContract);\r\n\t    thresholdFibonaccening = newThreshold;\r\n\t}\r\n\t\r\n\tfunction updateDelayBeforeEnforce(uint256 newDelay) external {\r\n\t    require(msg.sender == basicContract);\r\n\t    delayBeforeEnforce = newDelay;\r\n\t}\r\n\t\r\n\tfunction setCallFee(address _acPool, uint256 _newCallFee) external {\r\n\t    require(msg.sender == basicContract);\r\n\t    IacPool(_acPool).setCallFee(_newCallFee);\r\n\t}\r\n\t\r\n\tfunction updateCostToVote(uint256 newCostToVote) external {\r\n\t    require(msg.sender == basicContract);\r\n\t    costToVote = newCostToVote;\r\n\t}\r\n\t\r\n\tfunction updateRolloverBonus(address _forPool, uint256 _bonus) external {\r\n\t    require(msg.sender == basicContract);\r\n\t\trequire(_bonus <= 1500, \"15% hard limit\");\r\n\t    _rollBonus[_forPool] = _bonus;\r\n\t}\r\n\t\r\n\tfunction burnFromOldChef(uint256 _amount) external {\r\n\t\trequire(msg.sender == farmContract || msg.sender == fibonacceningContract);\r\n\t\tIOldChef(oldChefOwner).burnTokens(_amount);\r\n\t}\r\n\t\r\n\tfunction setGovernorTax(uint256 _amount) external {\r\n\t\trequire(msg.sender == farmContract);\r\n\t\tIMasterChef(masterchef).setGovernorFee(_amount);\r\n\t}\r\n\t\r\n\tfunction postGrandFibIncreaseCount() external {\r\n\t\trequire(msg.sender == fibonacceningContract);\r\n\t\ttotalFibonacciEventsAfterGrand++;\r\n\t}\r\n\t\r\n\tfunction updateDelayBetweenEvents(uint256 _amount) external {\r\n\t    require(msg.sender == basicContract);\r\n\t\tIRewardBoost(fibonacceningContract).updateDelayBetweenEvents(_amount);\r\n\t}\r\n\tfunction updateGrandEventLength(uint256 _amount) external {\r\n\t    require(msg.sender == basicContract);\r\n\t\tIRewardBoost(fibonacceningContract).updateGrandEventLength(_amount);\r\n\t}\r\n\t    \r\n\t\r\n    /**\r\n     * Transfers collected fees into treasury wallet(but not XVMC...for now)\r\n     */\r\n    function transferCollectedFees(address _tokenContract) external {\r\n        require(msg.sender == tx.origin);\r\n\t\trequire(_tokenContract != token, \"not XVMC!\");\r\n\t\t\r\n        uint256 amount = IERC20(_tokenContract).balanceOf(address(this));\r\n        \r\n        IERC20(_tokenContract).safeTransfer(treasuryWallet, amount);\r\n    }\r\n\t\r\n\t\r\n\t/*\r\n\t * newGovernorBlockDelay is the delay during which the governor proposal can be voted against\r\n\t * As the time passes, changes should take longer to enforce(greater security)\r\n\t * Prioritize speed and efficiency at launch. Prioritize security once established\r\n\t * Delay increases by 2500 blocks(roughly 1.6hours) per each day after launch\r\n\t * Delay starts at 189000 blocks(roughly 5 days)\r\n\t * After a month, delay will be roughly 7 days (increases 2days/month)\r\n\t * After a year, 29 days. After 2 years, 53 days,...\r\n\t * Can be ofcourse changed by replacing governor contract\r\n\t */\r\n\tfunction updateGovernorChangeDelay() external {\r\n\t\tnewGovernorBlockDelay = 189000 + (((block.timestamp - 1654528957) / 86400) * 2500);\r\n\t}\r\n\r\n    \r\n    /**\r\n     * The weak point, Polygon-ETH bridge is secured by a 5/8 multisig.\r\n\t * Can change governing contract thru a multisig(without consensus) and 42% of weighted votes voting in favor\r\n\t * https://docs.polygon.technology/docs/faq/commit-chain-multisigs/\r\n     */\r\n    function multiSigGovernorChange(address _newGovernor) external {\r\n\t\tuint _signatureCount = 0;\r\n\t\tuint _ownersLength = signaturesConfirmed[_newGovernor].length;\r\n\t\trequire(_ownersLength >= 5, \"minimum 5 signatures required\");\r\n\t\tfor(uint i=0; i< _ownersLength; i++) {//owners can change, must check if still active\r\n\t\t\tif(IPolygonMultisig(polygonMultisig).isOwner(signaturesConfirmed[_newGovernor][i])) {\r\n\t\t\t\t_signatureCount++;\r\n\t\t\t}\r\n\t\t}\r\n        require(_signatureCount >= 5, \"Minimum 5/8 signatures required\");\r\n\t\t\r\n\t\tuint256 _totalStaked = IConsensus(consensusContract).totalXVMCStaked();\r\n\t\tuint256 _totalVotedInFavor = IConsensus(consensusContract).tokensCastedPerVote(uint256(uint160(_newGovernor)));\r\n\t\t\r\n\t\trequire(_totalVotedInFavor >= (_totalStaked * 42 / 100), \"Minimum 42% weighted vote required\");\r\n        \r\n        IMasterChef(masterchef).setFeeAddress(_newGovernor);\r\n        IMasterChef(masterchef).dev(_newGovernor);\r\n        IMasterChef(masterchef).transferOwnership(_newGovernor);\r\n\t\tIERC20(token).safeTransfer(_newGovernor, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n\tfunction signMultisig(address _newGovernor) external {\r\n\t\tbool _isOwner = IPolygonMultisig(polygonMultisig).isOwner(msg.sender);\r\n\t\trequire(_isOwner, \"Signer is not multisig owner\");\r\n\t\t\r\n\t\trequire(!alreadySigned[msg.sender][_newGovernor], \"already signed\");\r\n\t\talreadySigned[msg.sender][_newGovernor] = true;\r\n\t\tsignaturesConfirmed[_newGovernor].push(msg.sender); //adds vote\r\n\t\t\r\n\t\temit Multisig(msg.sender, _newGovernor, true, uint256(uint160(_newGovernor)));\r\n\t}\r\n\t\r\n\tfunction unSignMultisig(address _newGovernor) external {\r\n\t\trequire(alreadySigned[msg.sender][_newGovernor], \"not signed\");\r\n\t\tuint256 _lastIndex = signaturesConfirmed[_newGovernor].length - 1;\r\n\t\tuint256 _index;\r\n\t\twhile(signaturesConfirmed[_newGovernor][_index] != msg.sender) {\r\n\t\t\t_index++;\r\n\t\t}\r\n\t\talreadySigned[msg.sender][_newGovernor] = false;\r\n\t\tif(_index != _lastIndex) {\r\n\t\t\tsignaturesConfirmed[_newGovernor][_index] = signaturesConfirmed[_newGovernor][_lastIndex];\r\n\t\t} \r\n\t\tsignaturesConfirmed[_newGovernor].pop();\r\n\t\t\r\n\t\temit Multisig(msg.sender, _newGovernor, false, uint256(uint160(_newGovernor)));\r\n\t}\r\n\t\r\n\tfunction addressToUint256(address _address) external pure returns(uint256) {\r\n\t\treturn(uint256(uint160(_address)));\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_acPool1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_acPool2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_acPool3\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_acPool4\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_acPool5\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_acPool6\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"enforcer\",\"type\":\"address\"}],\"name\":\"EnforceGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolInto\",\"type\":\"address\"}],\"name\":\"GiveRolloverBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"callFee\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sign\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idToVoteFor\",\"type\":\"uint256\"}],\"name\":\"Multisig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"SetInflation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"TransferOwner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acPool1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool1ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool2ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool3ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool4\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool4ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool5\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool5ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool6\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acPool6ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addressToUint256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"alreadySigned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basicContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnFromOldChef\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateAverageBlockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeGovernorActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"consensusContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"costToVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countingBlocks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayBeforeEnforce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_arg\",\"type\":\"bool\"}],\"name\":\"delayFibonacci\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"durationForCalculation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eligibleNewGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enforceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eventFibonacceningActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fibonacceningContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fibonacciDelayed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bonusForPool\",\"type\":\"address\"}],\"name\":\"getRollBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goldenRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governorRejected\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInflationStatic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlockHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastHarvestedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRegularReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterchef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumVoteTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"multiSigGovernorChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newGovernorBlockDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newGovernorRequestBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftAllocationContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftStakingContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftStakingPoolID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldChefOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingHarvestRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"polygonMultisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"postGrandFibIncreaseCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalanceFarms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalancePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recordTimeStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rememberReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_arg\",\"type\":\"bool\"}],\"name\":\"setActivateFibonaccening\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_acPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newCallFee\",\"type\":\"uint256\"}],\"name\":\"setCallFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setFarmRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setGovernorTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"setInflation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"setNewGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_depositFeeBP\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"setThresholdFibonaccening\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"signMultisig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signaturesConfirmed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositToPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bonusToPay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeID\",\"type\":\"uint256\"}],\"name\":\"stakeRolloverBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startCountingBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thresholdFibonaccening\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFibonacciEventsAfterGrand\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"name\":\"transferCollectedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountToSend\",\"type\":\"uint256\"}],\"name\":\"treasuryRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"unSignMultisig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAllPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCostToVote\",\"type\":\"uint256\"}],\"name\":\"updateCostToVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDelay\",\"type\":\"uint256\"}],\"name\":\"updateDelayBeforeEnforce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateDelayBetweenEvents\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDuration\",\"type\":\"uint256\"}],\"name\":\"updateDurationForCalculation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateGovernorChangeDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateGrandEventLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateMaximumVotetokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_forPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"updateRolloverBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "XVMCgovernor", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ffb71361dd8fc3ef0831871ec8dd51b413ed093c0000000000000000000000009a9aef66624c3fa77daacca9b51de307fa09bd500000000000000000000000001f8a5d98f1e2f10e93331d27cf22ed7985ef6a1200000000000000000000000030019481fc501afa449781ac671103feb0d6363c0000000000000000000000008c96105ea574727e94d9c199c632128f1ca584cf000000000000000000000000605c5aa14bdbf0d50a99836e7909c631cf3c8d46", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ca697cadc0b7783e7a8d6c1a71ff20320028e27a361c90b262260f294548fada"}