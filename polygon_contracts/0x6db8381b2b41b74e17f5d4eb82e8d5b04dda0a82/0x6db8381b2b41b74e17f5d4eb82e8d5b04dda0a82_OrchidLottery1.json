{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lottery1.sol\": {\r\n      \"content\": \"/* Orchid - WebRTC P2P VPN Market (on Ethereum)\\n * Copyright (C) 2017-2021  The Orchid Authors\\n*/\\n\\n/* GNU Affero General Public License, Version 3 {{{ */\\n/* SPDX-License-Identifier: AGPL-3.0-or-later */\\n/*\\n * This program is free software: you can redistribute it and/or modify\\n * it under the terms of the GNU Affero General Public License as published by\\n * the Free Software Foundation, either version 3 of the License, or\\n * (at your option) any later version.\\n\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU Affero General Public License for more details.\\n\\n * You should have received a copy of the GNU Affero General Public License\\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n**/\\n/* }}} */\\n\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\ninterface IERC20 {}\\n\\ncontract OrchidLottery1 {\\n    uint64 private immutable day_;\\n\\n    constructor(uint64 day) {\\n        day_ = day;\\n    }\\n\\n\\n    struct Account {\\n        uint256 escrow_amount_;\\n        uint256 unlock_warned_;\\n    }\\n\\n    mapping(bytes32 => Account) accounts_;\\n\\n    event Create(IERC20 indexed token, address indexed funder, address indexed signer);\\n    event Update(bytes32 indexed key, uint256 escrow_amount);\\n    event Delete(bytes32 indexed key, uint256 unlock_warned);\\n\\n    function read(IERC20 token, address funder, address signer) external view returns (uint256, uint256) {\\n        Account storage account = accounts_[keccak256(abi.encodePacked(token, funder, signer))];\\n        return (account.escrow_amount_, account.unlock_warned_);\\n    }\\n\\n\\n    function send_(address sender, IERC20 token, uint256 retrieve) private {\\n        if (retrieve != 0) {\\n            (bool success, bytes memory result) = address(token).call(\\n                abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", sender, retrieve));\\n            require(success && (result.length == 0 || abi.decode(result, (bool))));\\n        }\\n    }\\n\\n    function edit(IERC20 token, uint256 amount, address signer, int256 adjust, int256 warn, uint256 retrieve) external {\\n        require(token != IERC20(0));\\n        (bool success, bytes memory result) = address(token).call(\\n            abi.encodeWithSignature(\\\"transferFrom(address,address,uint256)\\\", msg.sender, this, amount));\\n        require(success && abi.decode(result, (bool)));\\n\\n        edit_(msg.sender, token, amount, signer, adjust, warn, retrieve);\\n        send_(msg.sender, token, retrieve);\\n    }\\n\\n    function tokenFallback(address sender, uint256 amount, bytes calldata data) public {\\n        require(data.length >= 4);\\n        bytes4 selector; assembly { selector := calldataload(data.offset) }\\n\\n        if (false) {\\n        } else if (selector == bytes4(keccak256(\\\"edit(address,int256,int256,uint256)\\\"))) {\\n            address signer; int256 adjust; int256 warn; uint256 retrieve;\\n            (signer, adjust, warn, retrieve) = abi.decode(data[4:],\\n                (address, int256, int256, uint256));\\n            edit_(sender, IERC20(msg.sender), amount, signer, adjust, warn, retrieve);\\n            send_(sender, IERC20(msg.sender), retrieve);\\n        } else require(false);\\n    }\\n\\n    function onTokenTransfer(address sender, uint256 amount, bytes calldata data) external returns (bool) {\\n        tokenFallback(sender, amount, data);\\n        return true;\\n    }\\n\\n    function edit(address signer, int256 adjust, int256 warn, uint256 retrieve) external payable {\\n        edit_(msg.sender, IERC20(0), msg.value, signer, adjust, warn, retrieve);\\n\\n        if (retrieve != 0) {\\n            (bool success,) = msg.sender.call{value: retrieve}(\\\"\\\");\\n            require(success);\\n        }\\n    }\\n\\n    function edit_(address funder, IERC20 token, uint256 amount, address signer, int256 adjust, int256 warn, uint256 retrieve) private {\\n        bytes32 key = keccak256(abi.encodePacked(token, funder, signer));\\n        Account storage account = accounts_[key];\\n\\n        uint256 backup;\\n        uint256 escrow;\\n\\n        if (adjust != 0 || amount != retrieve) {\\n            backup = account.escrow_amount_;\\n            if (backup == 0)\\n                emit Create(token, funder, signer);\\n            escrow = backup >> 128;\\n            amount += uint128(backup);\\n        }\\n    {\\n        uint256 marked;\\n        uint256 warned;\\n        uint256 unlock;\\n\\n        if (adjust < 0 || warn != 0) {\\n            warned = account.unlock_warned_;\\n            marked = warned >> 192;\\n            unlock = uint64(warned >> 128);\\n            warned = uint128(warned);\\n        }\\n\\n        if (warn > 0) {\\n            unlock = block.timestamp + day_;\\n\\n            warned += uint256(warn);\\n            require(warned >= uint256(warn));\\n        }\\n\\n        if (adjust < 0) {\\n            require(unlock - 1 < block.timestamp);\\n\\n            uint256 recover = uint256(-adjust);\\n            require(int256(recover) != adjust);\\n\\n            require(recover <= escrow);\\n            amount += recover;\\n            escrow -= recover;\\n\\n            require(recover <= warned);\\n            warned -= recover;\\n        } else if (adjust != 0) {\\n            uint256 transfer = uint256(adjust);\\n\\n            require(transfer <= amount);\\n            amount -= transfer;\\n            escrow += transfer;\\n        }\\n\\n        if (warn < 0) {\\n            uint256 decrease = uint256(-warn);\\n            require(int256(decrease) != warn);\\n\\n            require(decrease <= warned);\\n            warned -= decrease;\\n        }\\n\\n        if (retrieve != 0) {\\n            require(retrieve <= amount);\\n            amount -= retrieve;\\n        }\\n\\n        if (unlock != 0) {\\n            require(warned < 1 << 128);\\n\\n            uint256 cache = marked << 192 | (warned == 0 ? 0 : unlock << 128 | warned);\\n            account.unlock_warned_ = cache;\\n            emit Delete(key, cache);\\n        }\\n    } {\\n        require(amount < 1 << 128);\\n        require(escrow < 1 << 128);\\n\\n        uint256 cache = escrow << 128 | amount;\\n        if (cache != backup) {\\n            account.escrow_amount_ = cache;\\n            emit Update(key, cache);\\n        }\\n    } }\\n\\n\\n    struct Loop {\\n        uint256 closed_;\\n        mapping(address => uint256) merchants_;\\n    }\\n\\n    mapping(address => Loop) private loops_;\\n\\n    event Enroll(address indexed funder, address indexed recipient);\\n\\n    function enroll(bool cancel, address[] calldata recipients) external {\\n        Loop storage loop = loops_[msg.sender];\\n\\n        uint i = recipients.length;\\n        if (i == 0) {\\n            loop.closed_ = cancel ? 0 : block.timestamp + day_;\\n            emit Enroll(msg.sender, address(0));\\n        } else {\\n            uint256 value = cancel ? uint256(-1) : block.timestamp + day_;\\n            do {\\n                address recipient = recipients[--i];\\n                require(recipient != address(0));\\n                loop.merchants_[recipient] = value;\\n                emit Enroll(msg.sender, recipient);\\n            } while (i != 0);\\n        }\\n    }\\n\\n    function enrolled(address funder, address recipient) external view returns (uint256) {\\n        Loop storage loop = loops_[funder];\\n        if (recipient == address(0))\\n            return loop.closed_;\\n        else\\n            return loop.merchants_[recipient];\\n    }\\n\\n    function mark(IERC20 token, address signer, uint64 marked) external {\\n        require(marked <= block.timestamp);\\n        bytes32 key = keccak256(abi.encodePacked(token, msg.sender, signer));\\n        Account storage account = accounts_[key];\\n        uint256 cache = account.unlock_warned_;\\n        cache = uint256(marked) << 192 | uint192(cache);\\n        account.unlock_warned_ = cache;\\n        emit Delete(key, cache);\\n    }\\n\\n\\n    /*struct Track {\\n        uint96 expire;\\n        address owner;\\n    }*/\\n\\n    struct Track {\\n        uint256 packed;\\n    }\\n\\n    mapping(bytes32 => Track) private tracks_;\\n\\n    function save(uint256 count, bytes32 seed) external {\\n        for (seed = keccak256(abi.encodePacked(\\n            keccak256(abi.encodePacked(seed, msg.sender))\\n        , address(0))); count-- != 0; seed = keccak256(abi.encodePacked(seed)))\\n            tracks_[seed].packed = uint256(msg.sender);\\n    }\\n\\n    function spend_(bytes32 refund) private {\\n        Track storage track = tracks_[refund];\\n        uint256 packed = track.packed;\\n        if (packed >> 160 <= block.timestamp)\\n            if (address(packed) == msg.sender)\\n                delete track.packed;\\n    }\\n\\n\\n    /*struct Ticket {\\n        uint256 data;\\n        uint256 reveal;\\n\\n        uint64 issued;\\n        uint64 nonce;\\n        uint128 amount;\\n\\n        uint31 expire;\\n        uint64 ratio;\\n        address funder;\\n        uint1 v;\\n\\n        bytes32 r;\\n        bytes32 s;\\n    }*/\\n\\n    struct Ticket {\\n        bytes32 data;\\n        bytes32 reveal;\\n        uint256 packed0;\\n        uint256 packed1;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    function claim_(IERC20 token, address recipient, Ticket calldata ticket) private returns (uint256) {\\n        uint256 expire = (ticket.packed0 >> 192) + (ticket.packed1 >> 225);\\n        if (expire <= block.timestamp)\\n            return 0;\\n\\n        if (uint64(ticket.packed1 >> 161) < uint64(uint256(keccak256(abi.encodePacked(ticket.reveal, uint128(ticket.packed0 >> 128))))))\\n            return 0;\\n\\n        bytes32 digest; assembly { digest := chainid() }\\n        digest = keccak256(abi.encodePacked(\\n            byte(0x19), byte(0x00), this, digest, token,\\n            recipient, keccak256(abi.encodePacked(ticket.reveal)),\\n            ticket.packed0, ticket.packed1 >> 1, ticket.data));\\n\\n        address signer = ecrecover(digest, uint8((ticket.packed1 & 1) + 27), ticket.r, ticket.s);\\n\\n        address funder = address(ticket.packed1 >> 1);\\n        bytes32 key = keccak256(abi.encodePacked(token, funder, signer));\\n        Account storage account = accounts_[key];\\n    {\\n        Loop storage loop = loops_[funder];\\n        if (loop.closed_ - 1 < block.timestamp)\\n            if (loop.merchants_[recipient] <= account.unlock_warned_ >> 192)\\n                return 0;\\n    } {\\n        Track storage track = tracks_[keccak256(abi.encodePacked(digest, signer))];\\n        if (track.packed != 0)\\n            return 0;\\n        track.packed = expire << 160 | uint256(msg.sender);\\n    }\\n        uint256 amount = uint128(ticket.packed0);\\n        uint256 cache = account.escrow_amount_;\\n\\n        if (uint128(cache) >= amount)\\n            cache -= amount;\\n        else {\\n            amount = uint128(cache);\\n            cache = 0;\\n        }\\n\\n        account.escrow_amount_ = cache;\\n        emit Update(key, cache);\\n        return amount;\\n    }\\n\\n    function claim(IERC20 token, address recipient, Ticket[] calldata tickets, bytes32[] calldata refunds) external {\\n        for (uint256 i = refunds.length; i != 0; )\\n            spend_(refunds[--i]);\\n\\n        uint256 segment; assembly { segment := mload(0x40) }\\n\\n        uint256 amount = 0;\\n        for (uint256 i = tickets.length; i != 0; ) {\\n            amount += claim_(token, recipient, tickets[--i]);\\n            assembly { mstore(0x40, segment) }\\n        }\\n\\n        if (amount != 0) {\\n            bytes32 key = keccak256(abi.encodePacked(token, recipient, recipient));\\n            Account storage account = accounts_[key];\\n\\n            uint256 cache = account.escrow_amount_;\\n            if (cache == 0)\\n                emit Create(token, recipient, recipient);\\n\\n            require(uint128(cache) + amount < 1 << 128);\\n            cache += amount;\\n            account.escrow_amount_ = cache;\\n            emit Update(key, cache);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"day\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlock_warned\",\"type\":\"uint256\"}],\"name\":\"Delete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Enroll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"escrow_amount\",\"type\":\"uint256\"}],\"name\":\"Update\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"data\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"reveal\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"packed0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packed1\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct OrchidLottery1.Ticket[]\",\"name\":\"tickets\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"refunds\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"adjust\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"warn\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"retrieve\",\"type\":\"uint256\"}],\"name\":\"edit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"adjust\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"warn\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"retrieve\",\"type\":\"uint256\"}],\"name\":\"edit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"cancel\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"}],\"name\":\"enroll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"enrolled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"marked\",\"type\":\"uint64\"}],\"name\":\"mark\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"read\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"}],\"name\":\"save\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrchidLottery1", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "99999999", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000015180", "EVMVersion": "istanbul", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "none://164736f6c6343000706000a"}