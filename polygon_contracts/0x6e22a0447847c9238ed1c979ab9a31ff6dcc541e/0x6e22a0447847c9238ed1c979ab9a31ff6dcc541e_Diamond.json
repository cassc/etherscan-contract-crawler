{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Diamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* Implementation of a diamond.\\n/******************************************************************************/\\n\\nimport {LibDiamond} from \\\"./libraries/LibDiamond.sol\\\";\\nimport {IDiamondCut} from \\\"./interfaces/IDiamondCut.sol\\\";\\n\\ncontract Diamond {\\n  constructor(address _contractOwner, address _diamondCutFacet) payable {\\n    LibDiamond.setContractOwner(_contractOwner);\\n    LibDiamond.diamondAddress().diamondAddress = payable(this); // The address of the diamond\\n    IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1); // Add the diamondCut external function from the diamondCutFacet\\n\\n    bytes4[] memory functionSelectors = new bytes4[](1);\\n    functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n    cut[0] = IDiamondCut.FacetCut({\\n      facetAddress: _diamondCutFacet,\\n      action: IDiamondCut.FacetCutAction.Add,\\n      functionSelectors: functionSelectors\\n    });\\n    LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n  }\\n\\n  fallback() external payable {\\n    _fallback();\\n  }\\n\\n  // Find facet for function that is called and execute the\\n  // function if a facet is found and return any value.\\n  function _fallback() internal {\\n    LibDiamond.DiamondStorage storage ds;\\n    bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n    // get diamond storage\\n    assembly {\\n      ds.slot := position\\n    }\\n    // get facet from function selector\\n    address facet = address(bytes20(ds.facets[msg.sig]));\\n    require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n    // Execute external function from facet using delegatecall and return any value.\\n    assembly {\\n      // copy function selector and any arguments\\n      calldatacopy(0, 0, calldatasize())\\n      // execute function call using the facet\\n      let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n      // get any return value\\n      returndatacopy(0, 0, returndatasize())\\n      // return any return value or error back to the caller\\n      switch result\\n      case 0 {\\n        revert(0, returndatasize())\\n      }\\n      default {\\n        return(0, returndatasize())\\n      }\\n    }\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721A-Upgradeable/IERC721AUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// ERC721A Contracts v4.2.3\\r\\n// Creator: Chiru Labs\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\n/**\\r\\n * @dev Interface of ERC721A.\\r\\n */\\r\\ninterface IERC721AUpgradeable {\\r\\n    /**\\r\\n     * The caller must own the token or be an approved operator.\\r\\n     */\\r\\n    error ApprovalCallerNotOwnerNorApproved();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error ApprovalQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * Cannot query the balance for the zero address.\\r\\n     */\\r\\n    error BalanceQueryForZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * Cannot mint to the zero address.\\r\\n     */\\r\\n    error MintToZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * The quantity of tokens minted must be more than zero.\\r\\n     */\\r\\n    error MintZeroQuantity();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error OwnerQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * The caller must own the token or be an approved operator.\\r\\n     */\\r\\n    error TransferCallerNotOwnerNorApproved();\\r\\n\\r\\n    /**\\r\\n     * The token must be owned by `from`.\\r\\n     */\\r\\n    error TransferFromIncorrectOwner();\\r\\n\\r\\n    /**\\r\\n     * Cannot safely transfer to a contract that does not implement the\\r\\n     * ERC721Receiver interface.\\r\\n     */\\r\\n    error TransferToNonERC721ReceiverImplementer();\\r\\n\\r\\n    /**\\r\\n     * Cannot transfer to the zero address.\\r\\n     */\\r\\n    error TransferToZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error URIQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\r\\n     */\\r\\n    error MintERC2309QuantityExceedsLimit();\\r\\n\\r\\n    /**\\r\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\r\\n     */\\r\\n    error OwnershipNotInitializedForExtraData();\\r\\n\\r\\n    // =============================================================\\r\\n    //                            STRUCTS\\r\\n    // =============================================================\\r\\n\\r\\n    struct TokenOwnership {\\r\\n        // The address of the owner.\\r\\n        address addr;\\r\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\r\\n        uint64 startTimestamp;\\r\\n        // Whether the token has been burned.\\r\\n        bool burned;\\r\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\r\\n        uint24 extraData;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                         TOKEN COUNTERS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total number of tokens in existence.\\r\\n     * Burned tokens will reduce the count.\\r\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    // =============================================================\\r\\n    //                            IERC165\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n\\r\\n    // =============================================================\\r\\n    //                            IERC721\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables or disables\\r\\n     * (`approved`) `operator` to manage all of its assets.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in `owner`'s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\r\\n     * checking first that contract recipients are aware of the ERC721 protocol\\r\\n     * to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move\\r\\n     * this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement\\r\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\r\\n     * whenever possible.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token\\r\\n     * by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the\\r\\n     * zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\r\\n     * for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n    // =============================================================\\r\\n    //                        IERC721Metadata\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection name.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n\\r\\n    // =============================================================\\r\\n    //                           IERC2309\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\r\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\r\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\r\\n     *\\r\\n     * See {_mintERC2309} for more details.\\r\\n     */\\r\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/facets/AccessControlFacet.sol\": {\r\n      \"content\": \"// Contract name: AccessControlFacet\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {Modifiers} from \\\"../utils/Modifiers.sol\\\";\\nimport {LibDiamond} from \\\"../libraries/LibDiamond.sol\\\";\\nimport {LibERC721A} from \\\"../libraries/LibERC721A.sol\\\";\\nimport {IERC721AUpgradeable as IERC721} from \\\"../ERC721A-Upgradeable/IERC721AUpgradeable.sol\\\";\\nimport {LibAccessControl} from \\\"../libraries/LibAccessControl.sol\\\";\\n\\nstruct SetRoleItem {\\n  address user;\\n  bytes32 role;\\n  bool hasRole;\\n}\\n\\n/// @title Errors that can be emitted by AccessControlFacet functions\\nlibrary AccessControlError {\\n  /// @notice If the user is missing the role required to perform the action\\n  string public constant MissingRequiredRole = \\\"MISSING_REQUIRED_ROLE\\\";\\n}\\n\\n/// @title Role-based access control for limiting access to some functions of the contract\\n/// @notice Assign roles to grant access to otherwise limited functions of the contract\\ncontract AccessControlFacet is Modifiers {\\n  /// @notice Emitted when a role is granted to a user\\n  /// @param role The role that was granted\\n  /// @param user The user that was granted a role\\n  event RoleGranted(bytes32 indexed role, address indexed user);\\n\\n  /// @notice Emitted when a role is revoked from a user\\n  /// @param role The role that was revoked\\n  /// @param user The user that was revoked\\n  event RoleRevoked(bytes32 indexed role, address indexed user);\\n\\n  /// @notice Emitted when the admin contract address is set\\n  /// @param adminContract The address of the new admin contract\\n  event AdminContractSet(address indexed adminContract);\\n\\n  /// @notice An admin of the contract.\\n  /// @return Hashed value that represents this role.\\n  function ADMIN_ROLE() public pure returns (bytes32) {\\n    return LibAccessControl.ADMIN_ROLE;\\n  }\\n\\n  /// @notice A contract upgrader\\n  /// @return Hashed value that represents this role.\\n  function UPGRADER_ROLE() public pure returns (bytes32) {\\n    return LibAccessControl.UPGRADER_ROLE;\\n  }\\n\\n  /// @notice A team member\\n  /// @return Hashed value that represents this role.\\n  function TEAM_ROLE() public pure returns (bytes32) {\\n    return LibAccessControl.TEAM_ROLE;\\n  }\\n\\n  /// @notice A gaffer role\\n  /// @return Hashed value that represents this role.\\n  function GAFFER_ROLE() public pure returns (bytes32) {\\n    return LibAccessControl.GAFFER_ROLE;\\n  }\\n\\n  /// @notice A diamond hand holder role\\n  /// @return Hashed value that represents this role.\\n  function DIAMOND_HOLDER_ROLE() public pure returns (bytes32) {\\n    return LibAccessControl.DIAMOND_HOLDER_ROLE;\\n  }\\n\\n  /// @notice Check if a user has access to upgrade the contract\\n  /// @param upgrader The wallet address of the upgrader\\n  /// @return bool of whether the user can upgrade the contract\\n  function canUpgradeContract(address upgrader) public view returns (bool) {\\n    AccessControlFacet ac = AccessControlFacet(address(this));\\n    if (ac.hasRole(LibAccessControl.UPGRADER_ROLE, upgrader)) {\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /// @notice Bulk assign roles\\n  /// @param items The roles to assign / remove\\n  function bulkSetRoles(SetRoleItem[] memory items) public {\\n    LibDiamond.enforceCanUpgrade();\\n    for (uint256 i = 0; i < items.length; i++) {\\n      SetRoleItem memory item = items[i];\\n      if (item.hasRole) {\\n        LibAccessControl._grantRole(item.role, item.user);\\n      } else {\\n        LibAccessControl._revokeRole(item.role, item.user);\\n      }\\n    }\\n  }\\n\\n  /// @notice Grant a role to a user. The granting user must have the ADMIN_ROLE\\n  /// @param user The wallet address of the user to grant the role to\\n  /// @param role The role to grant\\n  function grantRole(bytes32 role, address user) public {\\n    AccessControlFacet ac = AccessControlFacet(address(this));\\n    ac.requireRole(LibAccessControl.ADMIN_ROLE, msg.sender);\\n    if (role == LibAccessControl.UPGRADER_ROLE) {\\n      LibDiamond.enforceIsContractOwner();\\n    }\\n    if (role == LibAccessControl.ADMIN_ROLE) {\\n      LibDiamond.enforceIsContractOwner();\\n      LibERC721A.adminStorage().admins.push(user);\\n    }\\n    LibAccessControl._grantRole(role, user);\\n    emit RoleGranted(role, user);\\n  }\\n\\n  /// @notice Grant a role to a user. The granting user must have the ADMIN_ROLE\\n  /// @param user The wallet address of the user to revoke the role from\\n  /// @param role The role to revoke\\n  function revokeRole(bytes32 role, address user) public {\\n    AccessControlFacet ac = AccessControlFacet(address(this));\\n    ac.requireRole(LibAccessControl.ADMIN_ROLE, msg.sender);\\n    if (role == LibAccessControl.UPGRADER_ROLE) {\\n      LibDiamond.enforceIsContractOwner();\\n    }\\n    if (role == LibAccessControl.ADMIN_ROLE) {\\n      LibDiamond.enforceIsContractOwner();\\n      LibERC721A.AdminStorage storage aS = LibERC721A.adminStorage();\\n      for (uint i = 0; i < aS.admins.length; i++) {\\n        if (aS.admins[i] == user) {\\n          // Replace the admin at index i with the last admin in the array\\n          aS.admins[i] = aS.admins[aS.admins.length - 1];\\n          // Delete the last element of the array (the duplicate admin)\\n          aS.admins.pop();\\n        }\\n      }\\n    }\\n    LibAccessControl._revokeRole(role, user);\\n    emit RoleRevoked(role, user);\\n  }\\n\\n  /// @notice Check if a user has a role\\n  /// @param user The wallet address of the user\\n  /// @param role The role\\n  function hasAssignedRole(bytes32 role, address user) public view returns (bool) {\\n    return LibAccessControl.dataStore().roles[role].members[user];\\n  }\\n\\n  /// @notice Check if a user has a role\\n  /// @param user The wallet address of the user\\n  /// @param role The role\\n  function hasRole(bytes32 role, address user) public view returns (bool) {\\n    LibAccessControl.DataStore storage s = LibAccessControl.dataStore();\\n\\n    // Check explicitly assigned roles\\n    if (s.roles[role].members[user]) {\\n      return true;\\n    }\\n\\n    // Owner always has permission / all roles\\n    if (LibDiamond.contractOwner() == user) {\\n      return true;\\n    }\\n\\n    // Check if the user has the role via a token\\n    if (s.adminContract != address(0) && role == LibAccessControl.ADMIN_ROLE) {\\n      uint256 balance = IERC721(s.adminContract).balanceOf(user);\\n\\n      if (balance > 0) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  /// @notice Get the list of users with a role\\n  /// @param role The role to fetch\\n  /// @return address[] of the users with the role\\n  function getRoles(bytes32 role) public view returns (address[] memory) {\\n    return LibAccessControl.dataStore().rolesList[role];\\n  }\\n\\n  /// @notice Requires that a user has a role\\n  /// @param role The role to check\\n  /// @param user The user to check\\n  function requireRole(bytes32 role, address user) public view {\\n    AccessControlFacet ac = AccessControlFacet(address(this));\\n    if (!ac.hasRole(role, user)) {\\n      revert(AccessControlError.MissingRequiredRole);\\n    }\\n  }\\n\\n  /// @notice Gets the admin contract address\\n  /// @return The admin contract address (or address(0) if not set)\\n  function adminContract() public view returns (address) {\\n    return LibAccessControl.dataStore().adminContract;\\n  }\\n\\n  /// @notice Set the admin contract address\\n  function setAdminContract(address newAdminContract) public {\\n    AccessControlFacet ac = AccessControlFacet(address(this));\\n    ac.requireRole(LibAccessControl.ADMIN_ROLE, msg.sender);\\n\\n    LibAccessControl.dataStore().adminContract = newAdminContract;\\n\\n    emit AdminContractSet(newAdminContract);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n  enum FacetCutAction {\\n    Add,\\n    Replace,\\n    Remove\\n  }\\n  // Add=0, Replace=1, Remove=2\\n\\n  struct FacetCut {\\n    address facetAddress;\\n    FacetCutAction action;\\n    bytes4[] functionSelectors;\\n  }\\n\\n  /// @notice Add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n\\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPaperKeyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @title Paper Key Manager\\n/// @author Winston Yeo\\n/// @notice PaperKeyManager makes it easy for developers to restrict certain functions to Paper.\\n/// @dev Developers are in charge of registering the contract with the initial Paper key. Paper will then help you  automatically rotate and update your key in line with good security hygiene\\ninterface IPaperKeyManager {\\n  /// @notice Registers a Paper Key to a contract\\n  /// @dev Registers the @param _paperKey with the caller of the function\\n  /// @param _paperKey The Paper key that is associated with the checkout. You should be able to find this in the response of the checkout API or on the checkout dashbaord.\\n  /// @return bool indicating if the @param _paperKey was successfully registered with the calling address\\n  function register(address _paperKey) external returns (bool);\\n\\n  /// @notice Verifies if the given @param _data is from Paper and have not been used before\\n  /// @dev Called as the first line in your function or extracted in a modifier. Refer to the Documentation for more usage details.\\n  /// @param _hash The bytes32 encoding of the data passed into your function\\n  /// @param _nonce a random set of bytes Paper passes your function which you forward. This helps ensure that the @param _hash has not been used before.\\n  /// @param _signature used to verify that Paper was the one who sent the @param _hash\\n  /// @return bool indicating if the @param _hash was successfully verified\\n  function verify(bytes32 _hash, bytes32 _nonce, bytes calldata _signature) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Array.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nlibrary Array {\\n  function removeAt(uint256[] storage array, uint256 index) internal returns (uint256[] memory) {\\n    if (index >= array.length) {\\n      revert(\\\"Index out of range\\\");\\n    }\\n\\n    for (uint256 i = index; i < array.length - 1; i++) {\\n      array[i] = array[i + 1];\\n    }\\n    array.pop();\\n    return array;\\n  }\\n\\n  function removeAt(address[] storage array, uint256 index) internal returns (address[] memory) {\\n    if (index >= array.length) {\\n      revert(\\\"Index out of range\\\");\\n    }\\n\\n    for (uint256 i = index; i < array.length - 1; i++) {\\n      array[i] = array[i + 1];\\n    }\\n    array.pop();\\n    return array;\\n  }\\n\\n  function removeAt(string[] storage array, uint256 index) internal returns (string[] memory) {\\n    if (index >= array.length) {\\n      revert(\\\"Index out of range\\\");\\n    }\\n\\n    for (uint256 i = index; i < array.length - 1; i++) {\\n      array[i] = array[i + 1];\\n    }\\n    array.pop();\\n    return array;\\n  }\\n\\n  function isEqual(address[] memory arr1, address[] memory arr2) internal pure returns (bool) {\\n    if (arr1.length != arr2.length) {\\n      return false;\\n    }\\n\\n    for (uint256 i = 0; i < arr1.length; i++) {\\n      if (arr1[i] != arr2[i]) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {Array} from \\\"./Array.sol\\\";\\n\\nlibrary LibAccessControl {\\n  bytes32 internal constant STORAGE_SLOT = keccak256(\\\"gnar.contracts.storage.AccessControl\\\");\\n\\n  bytes32 constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n  bytes32 constant TEAM_ROLE = keccak256(\\\"TEAM_ROLE\\\");\\n  bytes32 constant UPGRADER_ROLE = keccak256(\\\"UPGRADER_ROLE\\\");\\n  bytes32 constant GAFFER_ROLE = keccak256(\\\"GAFFER_ROLE\\\");\\n  bytes32 constant DIAMOND_HOLDER_ROLE = keccak256(\\\"DIAMOND_HOLDER_ROLE\\\");\\n\\n  struct RoleData {\\n    mapping(address => bool) members;\\n  }\\n\\n  struct DataStore {\\n    // /** Keeps track of assigned roles */\\n    mapping(bytes32 => RoleData) roles;\\n    mapping(bytes32 => address[]) rolesList;\\n    mapping(bytes32 => mapping(address => uint256)) rolesListIndex;\\n    address adminContract;\\n  }\\n\\n  function dataStore() internal pure returns (DataStore storage l) {\\n    bytes32 slot = STORAGE_SLOT;\\n    assembly {\\n      l.slot := slot\\n    }\\n  }\\n\\n  function _grantRoles(bytes32 role, address[] memory accounts) internal {\\n    for (uint i = 0; i < accounts.length; i++) {\\n      _grantRole(role, accounts[i]);\\n    }\\n  }\\n\\n  function _grantRole(bytes32 role, address account) internal {\\n    DataStore storage s = dataStore();\\n    if (!s.roles[role].members[account]) {\\n      s.roles[role].members[account] = true;\\n      s.rolesList[role].push(account);\\n      s.rolesListIndex[role][account] = s.rolesList[role].length - 1;\\n    }\\n  }\\n\\n  function _revokeRole(bytes32 role, address account) internal {\\n    DataStore storage s = dataStore();\\n    if (!s.roles[role].members[account]) {\\n      s.roles[role].members[account] = false;\\n      uint256 idx = s.rolesListIndex[role][account];\\n      Array.removeAt(s.rolesList[role], idx);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport {AccessControlFacet} from \\\"../facets/AccessControlFacet.sol\\\";\\nimport {LibAccessControl} from \\\"./LibAccessControl.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n  bytes32 constant FACETDATA_STORAGE_POSITION = keccak256(\\\"facetdata.standard.diamond.storage\\\");\\n  bytes32 constant GNAR_DIAMOND_ADDRESS_POSITION = keccak256(\\\"gnar.diamond.address.diamond.storage\\\");\\n\\n  struct Diamond {\\n    address diamondAddress;\\n  }\\n\\n  struct DiamondStorage {\\n    // facet initialation data\\n    mapping(address => bytes) facetInitData;\\n    // maps function selectors to the facets that execute the functions.\\n    // and maps the selectors to their position in the selectorSlots array.\\n    // func selector => address facet, selector position\\n    mapping(bytes4 => bytes32) facets;\\n    // array of slots of function selectors.\\n    // each slot holds 8 function selectors.\\n    mapping(uint256 => bytes32) selectorSlots;\\n    // The number of function selectors in selectorSlots\\n    uint16 selectorCount;\\n    // Used to query if a contract implements an interface.\\n    // Used to implement ERC-165.\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    // owner of the contract\\n    address contractOwner;\\n    //\\n    Diamond diamond;\\n  }\\n\\n  struct FacetData {\\n    bytes4[] functionSelectors;\\n    bytes callData;\\n  }\\n\\n  function facetData() internal pure returns (FacetData storage fd) {\\n    bytes32 position = FACETDATA_STORAGE_POSITION;\\n    assembly {\\n      fd.slot := position\\n    }\\n  }\\n\\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  function diamondAddress() internal pure returns (Diamond storage d) {\\n    bytes32 position = GNAR_DIAMOND_ADDRESS_POSITION;\\n    assembly {\\n      d.slot := position\\n    }\\n  }\\n\\n  event _OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  function setContractOwner(address _newOwner) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    address previousOwner = ds.contractOwner;\\n    ds.contractOwner = _newOwner;\\n    emit _OwnershipTransferred(previousOwner, _newOwner);\\n  }\\n\\n  function contractOwner() internal view returns (address contractOwner_) {\\n    contractOwner_ = diamondStorage().contractOwner;\\n  }\\n\\n  function enforceIsContractOwner() internal view {\\n    require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n  }\\n\\n  function enforceCanUpgrade() internal view {\\n    AccessControlFacet ac = AccessControlFacet(address(this));\\n    require(\\n      msg.sender == diamondStorage().contractOwner || ac.canUpgradeContract(msg.sender),\\n      \\\"LibDiamond: Must be owner or have UPGRADER_ROLE\\\"\\n    );\\n  }\\n\\n  function enforceIsAdmin() internal view {\\n    AccessControlFacet ac = AccessControlFacet(address(this));\\n    require(\\n      msg.sender == diamondStorage().contractOwner || ac.hasRole(LibAccessControl.ADMIN_ROLE, msg.sender),\\n      \\\"LibDiamond: Must be owner or have ADMIN_ROLE\\\"\\n    );\\n  }\\n\\n  function enforceIsTeam() internal view {\\n    AccessControlFacet ac = AccessControlFacet(address(this));\\n    require(\\n      msg.sender == diamondStorage().contractOwner || ac.hasRole(LibAccessControl.TEAM_ROLE, msg.sender),\\n      \\\"LibDiamond: Must be owner or have TEAM_ROLE\\\"\\n    );\\n  }\\n\\n  function enforceIsAllowed() internal view {\\n    AccessControlFacet ac = AccessControlFacet(address(this));\\n    require(\\n      msg.sender == diamondStorage().contractOwner ||\\n        ac.hasRole(LibAccessControl.TEAM_ROLE, msg.sender) ||\\n        ac.hasRole(LibAccessControl.ADMIN_ROLE, msg.sender),\\n      \\\"LibDiamond: Must be owner or have TEAM_ROLE or ADMIN_ROLE\\\"\\n    );\\n  }\\n\\n  event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n  bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n  bytes32 constant CLEAR_SELECTOR = CLEAR_ADDRESS_MASK | CLEAR_SELECTOR_MASK;\\n  bytes32 constant SELECTOR_SIZE = bytes32(uint256(0xffffffff << 224));\\n  bytes32 constant SELECTOR_SHIFT =\\n    bytes32(uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) << 224);\\n  bytes32 constant SELECTOR_MASK = CLEAR_ADDRESS_MASK | SELECTOR_SIZE;\\n  bytes32 constant SELECTOR_OFFSET = bytes32(uint256(0xffffffff << 224) >> 1);\\n  bytes32 constant DIAMOND_STORAGE_OFFSET = bytes32(uint256(0xffffffff << 224) >> 2);\\n  bytes32 constant DIAMOND_STORAGE_SIZE = bytes32(uint256(0xffffffff << 224) >> 3);\\n  bytes32 constant DIAMOND_STORAGE_MASK = CLEAR_ADDRESS_MASK | DIAMOND_STORAGE_SIZE;\\n  bytes32 constant DIAMOND_STORAGE_SHIFT =\\n    bytes32(uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) << 224) >> 4;\\n  bytes32 constant DIAMOND_STORAGE = DIAMOND_STORAGE_OFFSET | DIAMOND_STORAGE_SIZE;\\n\\n  // Internal function version of diamondCut\\n  // This code is almost the same as the external diamondCut,\\n  // except it is using 'Facet[] memory _diamondCut' instead of\\n  // 'Facet[] calldata _diamondCut'.\\n  // The code is duplicated to prevent copying calldata to memory which\\n  // causes an error for a two dimensional array.\\n  function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    uint256 originalSelectorCount = ds.selectorCount;\\n    uint256 selectorCount = originalSelectorCount;\\n    bytes32 selectorSlot;\\n    // Check if last selector slot is not full\\n    // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n    if (selectorCount & 7 > 0) {\\n      // get last selectorSlot\\n      // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n      selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n    }\\n    // loop through diamond cut\\n    for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n      (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n        selectorCount,\\n        selectorSlot,\\n        _diamondCut[facetIndex].facetAddress,\\n        _diamondCut[facetIndex].action,\\n        _diamondCut[facetIndex].functionSelectors\\n      );\\n\\n      unchecked {\\n        facetIndex++;\\n      }\\n    }\\n    if (selectorCount != originalSelectorCount) {\\n      ds.selectorCount = uint16(selectorCount);\\n    }\\n    // If last selector slot is not full\\n    // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n    if (selectorCount & 7 > 0) {\\n      // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n      ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n    }\\n    emit DiamondCut(_diamondCut, _init, _calldata);\\n    initializeDiamondCut(_init, _calldata);\\n  }\\n\\n  function addReplaceRemoveFacetSelectors(\\n    uint256 _selectorCount,\\n    bytes32 _selectorSlot,\\n    address _newFacetAddress,\\n    IDiamondCut.FacetCutAction _action,\\n    bytes4[] memory _selectors\\n  ) internal returns (uint256, bytes32) {\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    if (_action == IDiamondCut.FacetCutAction.Add) {\\n      enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n      for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n        bytes4 selector = _selectors[selectorIndex];\\n        bytes32 oldFacet = ds.facets[selector];\\n        require(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n        // add facet for selector\\n        ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n        // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n        // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n        uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n        // clear selector position in slot and add selector\\n        _selectorSlot =\\n          (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n          (bytes32(selector) >> selectorInSlotPosition);\\n        // if slot is full then write it to storage\\n        if (selectorInSlotPosition == 224) {\\n          // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n          ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n          _selectorSlot = 0;\\n        }\\n        _selectorCount++;\\n\\n        unchecked {\\n          selectorIndex++;\\n        }\\n      }\\n    } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n      enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n      for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n        bytes4 selector = _selectors[selectorIndex];\\n        bytes32 oldFacet = ds.facets[selector];\\n        address oldFacetAddress = address(bytes20(oldFacet));\\n        // only useful if immutable functions exist\\n        require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n        require(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n        require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n        // replace old facet address\\n        ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n\\n        unchecked {\\n          selectorIndex++;\\n        }\\n      }\\n    } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n      require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n      // \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n      uint256 selectorSlotCount = _selectorCount >> 3;\\n      // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n      uint256 selectorInSlotIndex = _selectorCount & 7;\\n      for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n        if (_selectorSlot == 0) {\\n          // get last selectorSlot\\n          selectorSlotCount--;\\n          _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n          selectorInSlotIndex = 7;\\n        } else {\\n          selectorInSlotIndex--;\\n        }\\n        bytes4 lastSelector;\\n        uint256 oldSelectorsSlotCount;\\n        uint256 oldSelectorInSlotPosition;\\n        // adding a block here prevents stack too deep error\\n        {\\n          bytes4 selector = _selectors[selectorIndex];\\n          bytes32 oldFacet = ds.facets[selector];\\n          require(address(bytes20(oldFacet)) != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n          // only useful if immutable functions exist\\n          require(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n          // replace selector with last selector in ds.facets\\n          // gets the last selector\\n          // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n          lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n          if (lastSelector != selector) {\\n            // update last selector slot position info\\n            ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n          }\\n          delete ds.facets[selector];\\n          uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n          // \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n          oldSelectorsSlotCount = oldSelectorCount >> 3;\\n          // \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n          // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n          oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n        }\\n        if (oldSelectorsSlotCount != selectorSlotCount) {\\n          bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n          // clears the selector we are deleting and puts the last selector in its place.\\n          oldSelectorSlot =\\n            (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n            (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n          // update storage with the modified slot\\n          ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n        } else {\\n          // clears the selector we are deleting and puts the last selector in its place.\\n          _selectorSlot =\\n            (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n            (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n        }\\n        if (selectorInSlotIndex == 0) {\\n          delete ds.selectorSlots[selectorSlotCount];\\n          _selectorSlot = 0;\\n        }\\n\\n        unchecked {\\n          selectorIndex++;\\n        }\\n      }\\n      _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n    } else {\\n      revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n    }\\n    return (_selectorCount, _selectorSlot);\\n  }\\n\\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n    if (_init == address(0)) {\\n      return;\\n    }\\n    enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n    if (!success) {\\n      if (error.length > 0) {\\n        // bubble up error\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n          let returndata_size := mload(error)\\n          revert(add(32, error), returndata_size)\\n        }\\n      } else {\\n        revert InitializationFunctionReverted(_init, _calldata);\\n      }\\n    }\\n  }\\n\\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_contract)\\n    }\\n    require(contractSize > 0, _errorMessage);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n// Copyright (c) 2023, GSKNNFT Inc\\npragma solidity ^0.8.19;\\n\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport {LibDiamond} from \\\"./LibDiamond.sol\\\";\\nimport {IPaperKeyManager} from \\\"../interfaces/IPaperKeyManager.sol\\\";\\n\\nlibrary LibERC721A {\\n  using LibDiamond for LibDiamond.DiamondStorage;\\n\\n  bytes32 constant ERC721A_STORAGE_POSITION = keccak256(\\\"erc721a.standard.erc2535.diamond.storage\\\");\\n  bytes32 constant ERC721A_ADMIN_STORAGE_POSITION = keccak256(\\\"erc721a.admin.diamond.storage\\\");\\n  bytes32 constant INIT_STORAGE_POSITION = keccak256(\\\"erc721a.init.diamond.storage\\\");\\n  uint256 constant MAX_SUPPLY = 666;\\n\\n  enum SupportedToken {\\n    MATIC, // [0]\\n    USDC, // [1]\\n    UNKNOWN // [2]\\n  }\\n\\n  struct TokenAddresses {\\n    mapping(SupportedToken => address) tokenAddresses;\\n  }\\n\\n  struct ERC721AStruct {\\n    // Mapping from token ID to metadata URI\\n    uint8 batchSizePerTx; // Number of tokens to mint per batch\\n    uint8 batchSizePerMint; // Number of tokens to mint per batch\\n    uint8 attributes;\\n    uint16 mintedCount;\\n    uint96 royaltyFee;\\n    uint96 tokenCount;\\n    bool admininitialized;\\n    bool isActive;\\n    bool isTokenBurnActive;\\n    bool isPaused;\\n    bool isSpecial;\\n    bool isPublicSaleActive;\\n    bool isClaimActive;\\n    bool metadataFrozen; // Permanently freezes metadata so it can never be changed\\n    bool payoutAddressesFrozen; // If true, payout addresses and basis points are permanently frozen and can never be updated\\n    bool holderRoyaltiesActive;\\n    bool collectionRevealed;\\n    bool[50] __gapBool;\\n    uint256 _tokenIds;\\n    uint256 _totalSupply;\\n    uint256 pubSalePrice;\\n    uint256 tokensPerBatch; // Number of tokens to reveal per batch\\n    uint256 totalRevealed; // Keep track of total number of tokens already revealed\\n    uint256 holderPercents;\\n    uint256 publicCloseTokenId;\\n    uint16[] payoutBasisPoints; // The respective share of funds to be sent to each address in payoutAddresses in basis points\\n    uint256[50] __gapUint256;\\n    string baseURI;\\n    string baseCID;\\n    string fullURI;\\n    string name;\\n    string symbol;\\n    string uriPrefix;\\n    string uriSuffix;\\n    string version;\\n    string[50] __gapString;\\n    address[] payoutAddresses;\\n    address[50] __gapAddress;\\n    address payable diamondAddress;\\n    address _paperKeyManager;\\n    address crossmintManager;\\n    address royaltyAddress;\\n    IPaperKeyManager paperKeyManager;\\n    // AdminFacet state variables\\n    AdminStorage _adminStorage;\\n    TokenAddresses _tokenAddresses;\\n  }\\n\\n  struct AdminStorage {\\n    uint256 nonce;\\n    // Supported interfaces\\n    mapping(bytes4 => bool) _supportedInterfaces;\\n    // Allowed facets\\n    mapping(address => bool) allowedFacets;\\n    // Admin addresses\\n    address[] admins;\\n    // Balances\\n    mapping(address => uint256) balances;\\n    // Token ownership\\n    mapping(uint256 => address) _owners;\\n    // Token approvals\\n    mapping(uint256 => mapping(address => bool)) tokenApprovals;\\n    // Extra NFT data storage\\n    mapping(uint256 => string[]) _tokenIPFSHashes;\\n    // Token URIs\\n    mapping(uint256 => string) _tokenURIs;\\n    // Owned token IDs\\n    mapping(address => uint256[]) _ownedTokens;\\n    // Index of owned token IDs\\n    mapping(uint256 => uint256) _ownedTokensIndex;\\n    // Proxy mapping for projects\\n    mapping(address => bool) projectProxy;\\n    // Proxy mapping\\n    mapping(address => bool) proxyAddress;\\n  }\\n\\n  struct Init {\\n    bool _initialized;\\n    mapping(string => mapping(address => bool)) initialized;\\n    bool adminInitialized;\\n    bool approvalsInitialized;\\n  }\\n\\n  bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n  bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n  bytes32 constant CLEAR_SELECTOR = CLEAR_ADDRESS_MASK | CLEAR_SELECTOR_MASK;\\n  bytes32 constant SELECTOR_SIZE = bytes32(uint256(0xffffffff << 224));\\n  bytes32 constant SELECTOR_SHIFT =\\n    bytes32(uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) << 224);\\n  bytes32 constant SELECTOR_MASK = CLEAR_ADDRESS_MASK | SELECTOR_SIZE;\\n  bytes32 constant SELECTOR_OFFSET = bytes32(uint256(0xffffffff << 224) >> 1);\\n  bytes32 constant DIAMOND_STORAGE_OFFSET = bytes32(uint256(0xffffffff << 224) >> 2);\\n  bytes32 constant DIAMOND_STORAGE_SIZE = bytes32(uint256(0xffffffff << 224) >> 3);\\n  bytes32 constant DIAMOND_STORAGE_MASK = CLEAR_ADDRESS_MASK | DIAMOND_STORAGE_SIZE;\\n  bytes32 constant DIAMOND_STORAGE_SHIFT =\\n    bytes32(uint256(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) << 224) >> 4;\\n  bytes32 constant DIAMOND_STORAGE = DIAMOND_STORAGE_OFFSET | DIAMOND_STORAGE_SIZE;\\n\\n  function erc721aStorage() internal pure returns (ERC721AStruct storage erc) {\\n    bytes32 position = ERC721A_STORAGE_POSITION;\\n    assembly {\\n      erc.slot := position\\n    }\\n  }\\n\\n  function adminStorage() internal pure returns (AdminStorage storage aStore) {\\n    bytes32 position = ERC721A_ADMIN_STORAGE_POSITION;\\n    assembly {\\n      aStore.slot := position\\n    }\\n  }\\n\\n  function initStorage() internal pure returns (Init storage init) {\\n    bytes32 position = INIT_STORAGE_POSITION;\\n    assembly {\\n      init.slot := position\\n    }\\n  }\\n\\n  // Function to set a proxy address\\n  function setProxy(address _proxyAddress) internal {\\n    LibDiamond.enforceIsContractOwner();\\n    adminStorage().proxyAddress[_proxyAddress] = true;\\n  }\\n\\n  // Function to remove a proxy address\\n  function removeProxy(address _proxyAddress) internal {\\n    LibDiamond.enforceIsContractOwner();\\n    delete adminStorage().proxyAddress[_proxyAddress];\\n  }\\n\\n  // Function to activate a proxy\\n  function activateProxy(address _proxyAddress) internal {\\n    require(adminStorage().proxyAddress[_proxyAddress], \\\"Proxy address not found\\\");\\n    adminStorage().proxyAddress[_proxyAddress] = true;\\n  }\\n\\n  // Function to deactivate a proxy\\n  function deactivateProxy(address _proxyAddress) internal {\\n    require(adminStorage().proxyAddress[_proxyAddress], \\\"Proxy address not found\\\");\\n    adminStorage().proxyAddress[_proxyAddress] = false;\\n  }\\n\\n  function _setPrefixBaseURI(string memory _baseURI_, string memory uriPrefix_) internal {\\n    ERC721AStruct storage erc = erc721aStorage();\\n    require(!erc.metadataFrozen, \\\"METADATA_HAS_BEEN_FROZEN\\\");\\n    if (bytes(uriPrefix_).length > 0) {\\n      erc.uriPrefix = uriPrefix_;\\n    }\\n    if (bytes(_baseURI_).length > 0) {\\n      erc.baseURI = _baseURI_;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the smaller of two numbers.\\n   * @param a The first number.\\n   * @param b The second number.\\n   * @return The smaller of the two numbers.\\n   */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Modifiers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {LibDiamond} from \\\"../libraries/LibDiamond.sol\\\";\\nimport {LibERC721A} from \\\"../libraries/LibERC721A.sol\\\";\\n\\nabstract contract Modifiers {\\n  modifier onlyOnce() {\\n    LibERC721A.Init storage init = LibERC721A.initStorage();\\n    require(!init._initialized);\\n    _;\\n  }\\n\\n  modifier onlyOwner() {\\n    LibDiamond.enforceIsContractOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice This modifier allows Admins and Owners access to any function\\n   */\\n  modifier onlyAdminAllowed() {\\n    LibDiamond.enforceIsAdmin();\\n    _;\\n  }\\n\\n  /**\\n   * @notice This modifier allows Admins and Owners access to any function\\n   */\\n  modifier onlyTeamAllowed() {\\n    LibDiamond.enforceIsTeam();\\n    _;\\n  }\\n\\n  modifier onlyAllowed() {\\n    LibDiamond.enforceIsAllowed();\\n    _;\\n  }\\n\\n  modifier onlyCrossmint() {\\n    require(LibERC721A.erc721aStorage().crossmintManager == msg.sender, \\\"Unauthorized\\\");\\n    _;\\n  }\\n\\n  modifier onlyPaper(\\n    bytes32 _hash,\\n    bytes32 _nonce,\\n    bytes calldata _signature\\n  ) {\\n    bool success = LibERC721A.erc721aStorage().paperKeyManager.verify(_hash, _nonce, _signature);\\n    require(success, \\\"Unauthorized\\\");\\n    _;\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initializationContractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"InitializationFunctionReverted\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Diamond", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a726d98e8970301d54bfb1cb5b596d2cc97cccc0000000000000000000000000a5506a219f152dfc60f62d9f3a0f825643655b47", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}