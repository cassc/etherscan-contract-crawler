{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.9;\\n\\nlibrary math {\\n/**\\n      * @dev Compute the largest integer smaller than or equal to the cubic root of `n`\\n    */\\n    function floorCbrt(uint256 n) internal pure returns (uint256) { unchecked {\\n        uint256 x = 0;\\n        for (uint256 y = 1 << 255; y > 0; y >>= 3) {\\n            x <<= 1;\\n            uint256 z = 3 * x * (x + 1) + 1;\\n            if (n / y >= z) {\\n                n -= y * z;\\n                x += 1;\\n            }\\n        }\\n        return x;\\n    }}\\n\\n    /**\\n      * @dev Compute the smallest integer larger than or equal to the cubic root of `n`\\n    */\\n    function ceilCbrt(uint256 n) internal pure returns (uint256) { unchecked {\\n        uint256 x = floorCbrt(n);\\n        return x ** 3 == n ? x : x + 1;\\n    }}\\n}\"\r\n    },\r\n    \"contracts/v2/crossspace_content_v2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./crossspace_user_v2.sol\\\";\\n\\ncontract CrossSpaceShareContentV2 is Ownable, ReentrancyGuard {\\n    address public parentProtocolAddress;\\n\\n    address public protocolFeeDestination;\\n    uint256 public protocolFeePercent = 500;\\n    uint256 public subjectFeePercent = 500;\\n    uint256 public PRICE_DIVIDER = 32000;\\n    bool public allowAuthorSellLastShare = false;\\n\\n    uint256 public constant PERCENT_BASE = 10000;\\n    uint256 public constant MAX_FEE_PERCENT = 1000; // 10% cap\\n\\n    event TradeContent(address trader, address author, string subject, bool isBuy, uint256 shareAmount, uint256 maticAmount, uint256 protocolMaticAmount, uint256 subjectMaticAmount, uint256 supply);\\n    event ParentProtocolAddressUpdated(address parentProtocolAddress);\\n    event ProtocolFeeDestinationUpdated(address protocolFeeDestination);\\n    event ProtocolFeePercentUpdated(uint256 protocolFeePercent);\\n    event SubjectFeePercentUpdated(uint256 subjectFeePercent);\\n\\n\\n    constructor(uint256 _priceDivider, bool _allowAuthorSellLastShare) {\\n        protocolFeeDestination = _msgSender();\\n        allowAuthorSellLastShare = _allowAuthorSellLastShare;\\n        PRICE_DIVIDER = _priceDivider;\\n    }\\n\\n    // Author => Subject => (Holder => Balance)\\n    mapping(address => mapping(string => mapping(address => uint256))) public sharesBalance;\\n\\n    // Author => Subject => Supply\\n    mapping(address => mapping(string => uint256)) public sharesSupply;\\n\\n    function setParentProtocolAddress(address _parentProtocolAddress) public onlyOwner {\\n        parentProtocolAddress = _parentProtocolAddress;\\n        emit ParentProtocolAddressUpdated(_parentProtocolAddress);\\n    }\\n\\n    function setFeeDestination(address _feeDestination) public onlyOwner {\\n        protocolFeeDestination = _feeDestination;\\n        emit ProtocolFeeDestinationUpdated(_feeDestination);\\n    }\\n\\n    function setProtocolFeePercent(uint256 _feePercent) public onlyOwner {\\n        // Requie the fee percent to be less than or equal to 10%\\n        require(_feePercent <= MAX_FEE_PERCENT, \\\"Fee percent is greater than 10%\\\");\\n\\n        protocolFeePercent = _feePercent;\\n        emit ProtocolFeePercentUpdated(_feePercent);\\n    }\\n\\n    function setSubjectFeePercent(uint256 _feePercent) public onlyOwner {\\n        // Requie the fee percent to be less than or equal to 10%\\n        require(_feePercent <= MAX_FEE_PERCENT, \\\"Fee percent is greater than 10%\\\");\\n\\n        subjectFeePercent = _feePercent;\\n        emit SubjectFeePercentUpdated(_feePercent);\\n    }\\n\\n    function getPrice(uint256 supply, uint256 amount) public view returns (uint256) {\\n        uint256 sum1 = supply == 0 ? 0 : (supply)* (supply+1) * (2 * supply + 1) / 6;\\n        uint256 sum2 =  (supply + amount) * (supply + amount + 1) * (2 * (supply + amount) + 1) / 6;\\n        uint256 summation = sum2 - sum1;\\n        return summation * 1 ether / PRICE_DIVIDER;\\n    }\\n\\n    function getBuyPrice(address author, string calldata subject, uint256 amount) public view returns (uint256) {\\n        return getPrice(sharesSupply[author][subject], amount);\\n    }\\n\\n    function getSellPrice(address author, string calldata subject, uint256 amount) public view returns (uint256) {\\n        return getPrice(sharesSupply[author][subject] - amount, amount);\\n    }\\n\\n    function getBuyPriceAfterFee(address author, string calldata subject, uint256 amount) public view returns (uint256) {\\n        uint256 price = getBuyPrice(author, subject, amount);\\n        uint256 protocolFee = price * protocolFeePercent / PERCENT_BASE;\\n        uint256 subjectFee = price * subjectFeePercent / PERCENT_BASE;\\n        return price + protocolFee + subjectFee;\\n    }\\n\\n    function getSellPriceAfterFee(address author, string calldata subject, uint256 amount) public view returns (uint256) {\\n        uint256 price = getSellPrice(author, subject, amount);\\n        uint256 protocolFee = price * protocolFeePercent / PERCENT_BASE;\\n        uint256 subjectFee = price * subjectFeePercent / PERCENT_BASE;\\n        return price - protocolFee - subjectFee;\\n    }\\n\\n    function buyShares(address author, string calldata subject, address sender, uint256 amount) public payable nonReentrant {\\n         // Require the caller to be the parent protocol\\n        require(msg.sender == parentProtocolAddress, \\\"Caller is not the parent protocol\\\");\\n        require(tx.origin == sender, \\\"sender is not the original sender\\\");\\n\\n        uint256 supply = sharesSupply[author][subject];\\n        require(supply > 0 || author == sender, \\\"Only the shares' subject owner can buy the first share\\\");\\n        uint256 price = getPrice(supply, amount);\\n        uint256 protocolFee = price * protocolFeePercent / PERCENT_BASE;\\n        uint256 subjectFee = price * subjectFeePercent / PERCENT_BASE;\\n        require(msg.value >= price + protocolFee + subjectFee, \\\"Insufficient payment\\\");\\n        \\n        // Buy the shares for the content\\n        sharesBalance[author][subject][sender] = sharesBalance[author][subject][sender] + amount;\\n        sharesSupply[author][subject] = supply + amount;\\n        emit TradeContent(sender, author, subject, true, amount, price, protocolFee, subjectFee, supply + amount);\\n        (bool success1, ) = protocolFeeDestination.call{value: protocolFee}(\\\"\\\");\\n        (bool success2, ) = author.call{value: subjectFee}(\\\"\\\");\\n        // If the sender send any extra money, send it back\\n        if (msg.value > price + protocolFee + subjectFee) {\\n            (bool success3, ) = sender.call{value: msg.value - price - protocolFee - subjectFee}(\\\"\\\");\\n            require(success3, \\\"Unable to send funds\\\");\\n        }\\n        require(success1 && success2, \\\"Unable to send funds\\\");\\n    }\\n\\n    function sellShares(address author, string calldata subject, address sender, uint256 amount) public nonReentrant{\\n         // Require the caller to be the parent protocol and the original sender to be the sender\\n        require(msg.sender == parentProtocolAddress, \\\"Caller is not the parent protocol\\\");\\n        require(tx.origin == sender, \\\"sender is not the original sender\\\");\\n\\n        uint256 supply = sharesSupply[author][subject];\\n        require(supply >= amount, \\\"Cannot sell more than the shares supply\\\");\\n        require(author != sender || supply > amount || allowAuthorSellLastShare, \\\"Author cannot sell the last share\\\");\\n        uint256 price = getPrice(supply - amount, amount);\\n        uint256 protocolFee = price * protocolFeePercent / PERCENT_BASE;\\n        uint256 subjectFee = price * subjectFeePercent / PERCENT_BASE;\\n        require(sharesBalance[author][subject][sender] >= amount, \\\"Insufficient shares\\\");\\n\\n        // Sell the shares for the content\\n        sharesBalance[author][subject][sender] = sharesBalance[author][subject][sender] - amount;\\n        sharesSupply[author][subject] = supply - amount;\\n        emit TradeContent(sender, author, subject, false, amount, price, protocolFee, subjectFee, supply - amount);\\n        (bool success1, ) = sender.call{value: price - protocolFee - subjectFee}(\\\"\\\");\\n        (bool success2, ) = protocolFeeDestination.call{value: protocolFee}(\\\"\\\");\\n        (bool success3, ) = author.call{value: subjectFee}(\\\"\\\");\\n        require(success1 && success2 && success3, \\\"Unable to send funds\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/v2/crossspace_user_v2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../math.sol\\\";\\n\\ncontract CrossSpaceShareUserV2 is Ownable, ReentrancyGuard {\\n\\n    address public parentProtocolAddress;\\n    address public protocolFeeDestination;\\n    uint256 public protocolFeePercent = 500;\\n    uint256 public subjectFeePercent = 500;\\n    uint256 public PRICE_DIVIDER = 32000;\\n    bool public allowAuthorSellLastShare = false;\\n    uint256 public constant PERCENT_BASE = 10000;\\n    uint256 public constant MAX_FEE_PERCENT = 1000;\\n\\n    constructor(uint256 _priceDivider, bool _allowAuthorSellLastShare) {\\n        protocolFeeDestination = _msgSender();\\n        allowAuthorSellLastShare = _allowAuthorSellLastShare;\\n        PRICE_DIVIDER = _priceDivider;\\n    }\\n\\n    event TradeUser(address trader, address author, bool isBuy, uint256 shareAmountInWei, uint256 maticAmount, uint256 protocolMaticAmount, uint256 subjectMaticAmount, uint256 supplyInWei);\\n    event ParentProtocolAddressUpdated(address parentProtocolAddress);\\n    event ProtocolFeeDestinationUpdated(address protocolFeeDestination);\\n    event ProtocolFeePercentUpdated(uint256 protocolFeePercent);\\n    event SubjectFeePercentUpdated(uint256 subjectFeePercent);\\n\\n    // Author => (Holder => Balance)\\n    mapping(address => mapping(address => uint256)) public sharesBalanceInWei;\\n\\n    // Author => SupplyInWei\\n    mapping(address => uint256) public sharesSupplyInWei;\\n\\n    function setFeeDestination(address _feeDestination) public onlyOwner {\\n        protocolFeeDestination = _feeDestination;\\n        emit ProtocolFeeDestinationUpdated(_feeDestination);\\n    }\\n\\n    function setParentProtocolAddress(address _parentProtocolAddress) public onlyOwner {\\n        parentProtocolAddress = _parentProtocolAddress;\\n        emit ParentProtocolAddressUpdated(_parentProtocolAddress);\\n    }\\n\\n    function setProtocolFeePercent(uint256 _feePercent) public onlyOwner {\\n        // Requie the fee percent to be less than or equal to 10%\\n        require(_feePercent <= MAX_FEE_PERCENT, \\\"Fee percent is greater than 10%\\\");\\n        protocolFeePercent = _feePercent;\\n\\n        emit ProtocolFeePercentUpdated(_feePercent);\\n    }\\n\\n    function setSubjectFeePercent(uint256 _feePercent) public onlyOwner {\\n        // Requie the fee percent to be less than or equal to 10%\\n        require(_feePercent <= MAX_FEE_PERCENT, \\\"Fee percent is greater than 10%\\\");\\n        subjectFeePercent = _feePercent;\\n\\n        emit SubjectFeePercentUpdated(_feePercent);\\n    }\\n\\n    function getPrice(uint256 supplyInWei, uint256 amountInWei) public view returns (uint256) {\\n        uint256 price = (amountInWei * (amountInWei*amountInWei + 3*amountInWei* supplyInWei + 3*supplyInWei*supplyInWei));\\n        uint256 normalizedPrice = price / PRICE_DIVIDER / 3e36;\\n        return normalizedPrice;\\n    }\\n\\n    function getBuyPrice(address author, uint256 amountInWei) public view returns (uint256) {\\n        return getPrice(sharesSupplyInWei[author], amountInWei);\\n    }\\n\\n    function getSellPrice(address author, uint256 amountInWei) public view returns (uint256) {\\n        return getPrice(sharesSupplyInWei[author] - amountInWei, amountInWei);\\n    }\\n\\n    function getAmountInWeiByValue(uint256 supplyInWei, uint256 priceInWei) public view returns (uint256) {\\n        uint256 np =priceInWei* 3e36 * PRICE_DIVIDER;\\n        uint256 a = math.floorCbrt(np + supplyInWei * supplyInWei * supplyInWei) - supplyInWei;\\n\\n        return a;\\n    }\\n\\n     function getBuyPriceAfterFee(address author, uint256 amount) public view returns (uint256) {\\n        uint256 price = getBuyPrice(author, amount);\\n        uint256 protocolFee = price * protocolFeePercent / PERCENT_BASE;\\n        uint256 subjectFee = price * subjectFeePercent / PERCENT_BASE;\\n        return price + protocolFee + subjectFee;\\n    }\\n\\n    function getSellPriceAfterFee(address author, uint256 amount) public view returns (uint256) {\\n        uint256 price = getSellPrice(author, amount);\\n        uint256 protocolFee = price * protocolFeePercent / PERCENT_BASE;\\n        uint256 subjectFee = price * subjectFeePercent / PERCENT_BASE;\\n        return price - protocolFee - subjectFee;\\n    }\\n\\n    function getBuyAmountInWeiByValue(address author, uint256 priceInWei) public view returns (uint256) {\\n        return getAmountInWeiByValue(sharesSupplyInWei[author], priceInWei); \\n    }\\n\\n    function buyShares(address author, address sender, uint256 amountInWei) public payable nonReentrant {\\n        // Require the caller to be the parent protocol\\n        require(msg.sender == parentProtocolAddress, \\\"Caller is not the parent protocol\\\");\\n        require(tx.origin == sender, \\\"sender is not the original sender\\\");\\n\\n        uint256 supplyInWei = sharesSupplyInWei[author];\\n        require(supplyInWei > 0 || author == sender, \\\"Only the shares' subject owner can buy the first share\\\");\\n        uint256 price = getPrice(supplyInWei, amountInWei);\\n        uint256 protocolFee = price * protocolFeePercent / PERCENT_BASE;\\n        uint256 subjectFee = price * subjectFeePercent / PERCENT_BASE;\\n        require(msg.value >= price + protocolFee + subjectFee, \\\"Insufficient payment\\\");\\n        sharesBalanceInWei[author][sender] = sharesBalanceInWei[author][sender] + amountInWei;\\n        sharesSupplyInWei[author] = supplyInWei + amountInWei;\\n        emit TradeUser(sender, author, true, amountInWei, price, protocolFee, subjectFee, supplyInWei + amountInWei);\\n        (bool success1, ) = protocolFeeDestination.call{value: protocolFee}(\\\"\\\");\\n        (bool success2, ) = author.call{value: subjectFee}(\\\"\\\");\\n\\n        // Return the excess payment\\n        if (msg.value > price + protocolFee + subjectFee) {\\n            (bool success3, ) = sender.call{value: msg.value - price - protocolFee - subjectFee}(\\\"\\\");\\n            require(success3, \\\"Unable to send funds\\\");\\n        }\\n        require(success1 && success2, \\\"Unable to send funds\\\");\\n    }\\n\\n    function sellShares(address author, address sender, uint256 amountInWei) public nonReentrant {\\n         // Require the caller to be the parent protocol\\n        require(msg.sender == parentProtocolAddress, \\\"Caller is not the parent protocol\\\");\\n        require(tx.origin == sender, \\\"sender is not the original sender\\\");\\n\\n        uint256 supplyInWei = sharesSupplyInWei[author];\\n        require(supplyInWei >= amountInWei, \\\"Cannot sell exceeding shares supply\\\");\\n        require(author != sender || supplyInWei > amountInWei || allowAuthorSellLastShare, \\\"Author cannot sell the last share\\\");\\n        uint256 price = getPrice(supplyInWei - amountInWei, amountInWei);\\n        uint256 protocolFee = price * protocolFeePercent / PERCENT_BASE;\\n        uint256 subjectFee = price * subjectFeePercent / PERCENT_BASE;\\n        require(sharesBalanceInWei[author][sender] >= amountInWei, \\\"Insufficient shares\\\");\\n        sharesBalanceInWei[author][sender] = sharesBalanceInWei[author][sender] - amountInWei;\\n        sharesSupplyInWei[author] = supplyInWei - amountInWei;\\n        emit TradeUser(sender, author, false, amountInWei, price, protocolFee, subjectFee, supplyInWei - amountInWei);\\n        (bool success1, ) = sender.call{value: price - protocolFee - subjectFee}(\\\"\\\");\\n        (bool success2, ) = protocolFeeDestination.call{value: protocolFee}(\\\"\\\");\\n        (bool success3, ) = author.call{value: subjectFee}(\\\"\\\");\\n        require(success1 && success2 && success3, \\\"Unable to send funds\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/v2/crosssspace_trading_main_v2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../math.sol\\\";\\nimport \\\"./crossspace_content_v2.sol\\\";\\nimport \\\"./crossspace_user_v2.sol\\\";\\n\\ncontract CrossSpaceTradingMain is Ownable, ReentrancyGuard {\\n    address public contentContractAddress;\\n    address public userContractAddress;\\n    bool public isPaused;\\n\\n    // Author => Subject => (Holder => User Contract Balance)\\n    mapping(address => mapping(string => mapping(address => uint256))) public userContractBalance;\\n\\n    event TradingPaused(bool isPaused);\\n\\n    constructor(address _contentContractAddress, address _userContractAddress) {\\n        contentContractAddress = _contentContractAddress;\\n        userContractAddress = _userContractAddress;\\n        isPaused = true;\\n    }\\n\\n    function setPaused(bool _isPaused) public onlyOwner {\\n        isPaused = _isPaused;\\n        emit TradingPaused(_isPaused);\\n    }\\n\\n    function getTotalBuyPriceDetails(address author, string calldata subject, uint256 amount) public view returns (uint256[] memory) {\\n         // Assert that the contract addresses are not null\\n        require(contentContractAddress != address(0), \\\"Content contract address is null\\\");\\n        require(userContractAddress != address(0), \\\"User contract address is null\\\");\\n\\n        // Convert the contract address to the proper contract type\\n        CrossSpaceShareContentV2 contentContract = CrossSpaceShareContentV2(contentContractAddress);\\n        CrossSpaceShareUserV2 shareUserContract = CrossSpaceShareUserV2(userContractAddress);\\n\\n        // We will calculate the fees for both contract and add them to the total price\\n        uint256 contentTotalBeforeFee = contentContract.getBuyPrice(author, subject, amount);\\n        uint256 contentTotalAfterFee = contentContract.getBuyPriceAfterFee(author, subject, amount);\\n\\n         // We call the contract to get the amount of shares from the price and the total cost\\n        uint256 userShareAmountInWei = shareUserContract.getBuyAmountInWeiByValue(author, contentTotalBeforeFee); // We will use the same price to buy user share\\n        uint256 userShareFeeBeforeFee = shareUserContract.getBuyPrice(author, userShareAmountInWei);\\n        uint256 userShareFeeAfterFee = shareUserContract.getBuyPriceAfterFee(author, userShareAmountInWei);\\n\\n        uint256 grandTotal = contentTotalAfterFee + userShareFeeAfterFee;\\n\\n        uint256[] memory result = new uint256[](6);\\n        result[0] = contentTotalBeforeFee;\\n        result[1] = contentTotalAfterFee;\\n        result[2] = userShareAmountInWei;\\n        result[3] = userShareFeeBeforeFee;\\n        result[4] = userShareFeeAfterFee;\\n        result[5] = grandTotal;\\n        return result;\\n    }\\n\\n    function _getUserAmountToSell(address author, string calldata subject, address holder, uint256 totalAmount) private view returns (uint256) {\\n        // Assert that the contract addresses are not null\\n        require(contentContractAddress != address(0), \\\"Content contract address is null\\\");\\n        CrossSpaceShareContentV2 contentContract = CrossSpaceShareContentV2(contentContractAddress);\\n\\n        // Let's calculate the amount of user shares to sell for later\\n        uint256 userTotalShare = userContractBalance[author][subject][holder];\\n        uint256 contentTotalBalance = contentContract.sharesBalance(author,subject,holder);\\n        require(contentTotalBalance >= totalAmount, \\\"Insufficient shares\\\");\\n        uint256 userShareToSell = totalAmount * userTotalShare / contentTotalBalance;\\n\\n        return userShareToSell;\\n    }\\n\\n    function getTotalSellPriceDetails(address author, string calldata subject, address holder, uint256 amount) public view returns (uint256[] memory) {\\n        // Assert that the contract addresses are not null\\n        require(contentContractAddress != address(0), \\\"Content contract address is null\\\");\\n        require(userContractAddress != address(0), \\\"User contract address is null\\\");\\n\\n        // Convert the contract address to the proper contract type\\n        CrossSpaceShareContentV2 contentContract = CrossSpaceShareContentV2(contentContractAddress);\\n        CrossSpaceShareUserV2 shareUserContract = CrossSpaceShareUserV2(userContractAddress);\\n\\n         // Let's calculate the amount of user shares to sell for later\\n        uint256 userShareToSell = _getUserAmountToSell(author, subject, holder, amount);\\n\\n        // Let's calculate the fees for content\\n        uint256 contentTotalBeforeFee = contentContract.getSellPrice(author, subject, amount);\\n        uint256 contentTotalAfterFee = contentContract.getSellPriceAfterFee(author, subject, amount);\\n\\n        // Let's calculate the fees for user\\n        uint256 userShareFeeBeforeFee = shareUserContract.getSellPrice(author, userShareToSell);\\n        uint256 userShareFeeAfterFee = shareUserContract.getSellPriceAfterFee(author, userShareToSell);\\n\\n        uint256 grandTotal = contentTotalAfterFee + userShareFeeAfterFee;\\n\\n        uint256[] memory result = new uint256[](6);\\n        result[0] = contentTotalBeforeFee;\\n        result[1] = contentTotalAfterFee;\\n        result[2] = userShareToSell;\\n        result[3] = userShareFeeBeforeFee;\\n        result[4] = userShareFeeAfterFee;\\n        result[5] = grandTotal;\\n        return result;\\n    }\\n\\n     function buyShares(address author, string calldata subject, uint256 amount) public payable nonReentrant {\\n        // Require not paused\\n        require(!isPaused, \\\"Contract is paused\\\");\\n\\n        // Assert that the contract addresses are not null\\n        require(contentContractAddress != address(0), \\\"Content contract address is null\\\");\\n        require(userContractAddress != address(0), \\\"User contract address is null\\\");\\n\\n        // Convert the contract address to the proper contract type\\n        CrossSpaceShareContentV2 contentContract = CrossSpaceShareContentV2(contentContractAddress);\\n        CrossSpaceShareUserV2 shareUserContract = CrossSpaceShareUserV2(userContractAddress);\\n\\n        // We will calculate the fees for both contract and add them to the total price\\n        uint256 contentTotalBeforeFee = contentContract.getBuyPrice(author, subject, amount);\\n        uint256 contentTotalAfterFee = contentContract.getBuyPriceAfterFee(author, subject, amount);\\n\\n         // We call the contract to get the amount of shares from the price and the total cost\\n        uint256 userShareAmountInWei = shareUserContract.getBuyAmountInWeiByValue(author, contentTotalBeforeFee); // We will use the same price to buy user share\\n        uint256 userShareFeeAfterFee = shareUserContract.getBuyPriceAfterFee(author, userShareAmountInWei);\\n\\n        uint256 grandTotal = contentTotalAfterFee + userShareFeeAfterFee;\\n\\n        // Assert that the user sent enough funds\\n        require(msg.value >= grandTotal, \\\"Not enough funds\\\");\\n\\n        // Buy the shares for the user contract\\n        // Save the amount of shares in the mapping\\n        userContractBalance[author][subject][msg.sender] = userContractBalance[author][subject][msg.sender] + userShareAmountInWei;\\n\\n        // Buy the shares for the content contract\\n        contentContract.buyShares{value: contentTotalAfterFee}(author, subject, msg.sender, amount);\\n        // Transfer the funds to the user contract and call the buy shares function\\n        shareUserContract.buyShares{value: userShareFeeAfterFee}(author, msg.sender, userShareAmountInWei);\\n\\n        // Return the excess payment\\n        if (msg.value > grandTotal) {\\n            (bool success, ) = msg.sender.call{value: msg.value - grandTotal}(\\\"\\\");\\n            require(success, \\\"Unable to send funds\\\");\\n        }\\n     }\\n\\n     function sellShares(address author, string calldata subject, uint256 amount) public nonReentrant {\\n        // Require not paused\\n        require(!isPaused, \\\"Contract is paused\\\");\\n\\n        // Assert that the contract addresses are not null\\n        require(contentContractAddress != address(0), \\\"Content contract address is null\\\");\\n        require(userContractAddress != address(0), \\\"User contract address is null\\\");\\n\\n        // Convert the contract address to the proper contract type\\n        CrossSpaceShareContentV2 contentContract = CrossSpaceShareContentV2(contentContractAddress);\\n        CrossSpaceShareUserV2 shareUserContract = CrossSpaceShareUserV2(userContractAddress);\\n\\n         // Let's calculate the amount of user shares to sell for later\\n        uint256 userTotalShare = userContractBalance[author][subject][msg.sender];\\n        uint256 contentTotalBalance = contentContract.sharesBalance(author,subject,msg.sender);\\n        require(contentTotalBalance >= amount, \\\"Insufficient shares\\\");\\n        uint256 userShareToSell = amount * userTotalShare / contentTotalBalance;\\n        require(userShareToSell <= userTotalShare, \\\"Insufficient user shares\\\");\\n        userContractBalance[author][subject][msg.sender] = userContractBalance[author][subject][msg.sender] - userShareToSell;\\n\\n        // Sell\\n        contentContract.sellShares(author, subject, msg.sender, amount);\\n        shareUserContract.sellShares(author, msg.sender, userShareToSell);\\n     }\\n\\n     function getUserContractBalance(address author, string calldata subject, address holder) public view returns (uint256) {\\n         return userContractBalance[author][subject][holder];\\n     }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contentContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"TradingPaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"subject\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyShares\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contentContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"subject\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTotalBuyPriceDetails\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"subject\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTotalSellPriceDetails\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"subject\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getUserContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"subject\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CrossSpaceTradingMain", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000075ac7ada4d345952f6e759778be1cfebcb8a20ae000000000000000000000000d42d47815c862914a0b2d4b35b30fe535f3a66b5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}