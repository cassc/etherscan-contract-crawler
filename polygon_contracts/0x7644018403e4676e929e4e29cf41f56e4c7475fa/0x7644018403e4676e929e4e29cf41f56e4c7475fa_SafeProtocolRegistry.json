{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/safe-protocol/contracts/SafeProtocolRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.18;\\nimport {ISafeProtocolRegistry} from \\\"./interfaces/Registry.sol\\\";\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {Enum} from \\\"./common/Enum.sol\\\";\\nimport {ISafeProtocolFunctionHandler, ISafeProtocolHooks, ISafeProtocolPlugin} from \\\"./interfaces/Modules.sol\\\";\\nimport {MODULE_TYPE_PLUGIN, MODULE_TYPE_HOOKS, MODULE_TYPE_FUNCTION_HANDLER} from \\\"./common/Constants.sol\\\";\\n\\ncontract SafeProtocolRegistry is ISafeProtocolRegistry, Ownable2Step {\\n    mapping(address => ModuleInfo) public listedModules;\\n\\n    struct ModuleInfo {\\n        uint64 listedAt;\\n        uint64 flaggedAt;\\n        uint8 moduleTypes;\\n    }\\n\\n    error CannotFlagModule(address module);\\n    error CannotAddModule(address module, uint8 moduleTypes);\\n    error ModuleDoesNotSupportExpectedInterfaceId(address module, bytes4 expectedInterfaceId);\\n\\n    event ModuleAdded(address indexed module);\\n    event ModuleFlagged(address indexed module);\\n\\n    constructor(address initialOwner) {\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @notice This function returns information about a module\\n     * @param module Address of the module to be checked\\n     * @return listedAt Timestamp of listing the module. This value will be 0 if not listed.\\n     * @return flaggedAt Timestamp of falgging the module. This value will be 0 if not flagged.\\n     */\\n    function check(address module, bytes32 data) external view returns (uint64 listedAt, uint64 flaggedAt) {\\n        ModuleInfo memory moduleInfo = listedModules[module];\\n        listedAt = moduleInfo.listedAt;\\n        flaggedAt = moduleInfo.flaggedAt;\\n\\n        // If moduleType is not permitted, return 0 for listedAt and flaggedAt.\\n        if (moduleInfo.moduleTypes & uint8(uint256(data)) == 0) {\\n            listedAt = 0;\\n            flaggedAt = 0;\\n        }\\n    }\\n\\n    /**\\n     * @notice Allows only owner to add a module. A module can be any address including zero address for now.\\n     *         This function does not permit adding a module twice. This function validates if module supports expected interfaceId.\\n     * @param module Address of the module\\n     * @param moduleTypes uint8 indicating the types of module\\n     */\\n    function addModule(address module, uint8 moduleTypes) external virtual onlyOwner {\\n        _addModule(module, moduleTypes);\\n    }\\n\\n    function _addModule(address module, uint8 moduleTypes) internal {\\n        ModuleInfo memory moduleInfo = listedModules[module];\\n\\n        // Check if module is already listed or if moduleTypes is greater than 8.\\n        // Maximum allowed value of moduleTypes is 7. i.e. 2^0 (Plugin) + 2^1 (Function Handler) + 2^2 (Hooks)\\n        if (moduleInfo.listedAt != 0 || moduleTypes > 7) {\\n            revert CannotAddModule(module, moduleTypes);\\n        }\\n\\n        // Check if module supports expected interface\\n        if (\\n            moduleTypes & MODULE_TYPE_HOOKS == MODULE_TYPE_HOOKS && !IERC165(module).supportsInterface(type(ISafeProtocolHooks).interfaceId)\\n        ) {\\n            revert ModuleDoesNotSupportExpectedInterfaceId(module, type(ISafeProtocolHooks).interfaceId);\\n        }\\n\\n        if (\\n            moduleTypes & MODULE_TYPE_PLUGIN == MODULE_TYPE_PLUGIN &&\\n            !IERC165(module).supportsInterface(type(ISafeProtocolPlugin).interfaceId)\\n        ) {\\n            revert ModuleDoesNotSupportExpectedInterfaceId(module, type(ISafeProtocolPlugin).interfaceId);\\n        }\\n\\n        if (\\n            moduleTypes & MODULE_TYPE_FUNCTION_HANDLER == MODULE_TYPE_FUNCTION_HANDLER &&\\n            !IERC165(module).supportsInterface(type(ISafeProtocolFunctionHandler).interfaceId)\\n        ) {\\n            revert ModuleDoesNotSupportExpectedInterfaceId(module, type(ISafeProtocolFunctionHandler).interfaceId);\\n        }\\n\\n        listedModules[module] = ModuleInfo(uint64(block.timestamp), 0, moduleTypes);\\n        emit ModuleAdded(module);\\n    }\\n\\n    /**\\n     * @notice Allows only owner to flad a module. Only previously added module can be flagged.\\n     *         This function does not permit flagging a module twice.\\n     *         A module can be any address including zero address for now.\\n     * @param module Address of the module\\n     */\\n    function flagModule(address module) external onlyOwner {\\n        ModuleInfo memory moduleInfo = listedModules[module];\\n\\n        if (moduleInfo.listedAt == 0 || moduleInfo.flaggedAt != 0) {\\n            revert CannotFlagModule(module);\\n        }\\n\\n        listedModules[module] = ModuleInfo(moduleInfo.listedAt, uint64(block.timestamp), moduleInfo.moduleTypes);\\n        emit ModuleFlagged(module);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool) {\\n        return interfaceId == type(ISafeProtocolRegistry).interfaceId || interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/safe-protocol/contracts/interfaces/Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.18;\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface ISafeProtocolRegistry is IERC165 {\\n    /**\\n     * @notice This function allows external contracts to check if a module is listed and not flagged as faulty in the registry.\\n     * @param module Address of the module that should be checked\\n     * @param data bytes32 providing more information about the module. The type of this parameter is bytes32 to provide the flexibility to the developers to interpret the value in the registry. For example, it can be moduleType and registry would then check if given address can be used as that type of module.\\n     * @return listedAt MUST return the block number when the module was listed in the registry (or 0 if not listed)\\n     * @return flaggedAt MUST return the block number when the module was listed in the flagged as faulty (or 0 if not flagged)\\n     */\\n    function check(address module, bytes32 data) external view returns (uint64 listedAt, uint64 flaggedAt);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/safe-protocol/contracts/common/Enum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.18;\\n\\nabstract contract Enum {\\n    /**\\n     * @title Enum - Collection of enums used in Safe{Core} Account contracts.\\n     * @dev Source: https://github.com/safe-global/safe-contracts/blob/7d767973bd21e2d621a4895fdaf9524132efc2f9/contracts/common/Enum.sol#L8\\n     */\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/safe-protocol/contracts/interfaces/Modules.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.18;\\n\\nimport {SafeTransaction, SafeRootAccess} from \\\"../DataTypes.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title ISafeProtocolFunctionHandler - An interface that an Account function handler should implement to handle static calls.\\n * @notice In Safe{Core} Protocol, a function handler can be used to add additional functionality to an account.\\n *         User(s) should add SafeProtocolManager as a function handler (aka fallback handler in Safe v1.x) to the account\\n *         and enable the contract implementing ISafeProtocolFunctionHandler interface as a function handler in the\\n *         SafeProtocolManager for the specific function identifier.\\n */\\ninterface ISafeProtocolFunctionHandler is IERC165 {\\n    /**\\n     * @notice Handles calls to the account contract forwarded by the fallback function.\\n     * @param account Address of the account\\n     * @param sender Address of the sender\\n     * @param value Amount of ETH\\n     * @param data Arbitrary length bytes\\n     * @return result Arbitrary length bytes containing result of the operation\\n     */\\n    function handle(address account, address sender, uint256 value, bytes calldata data) external returns (bytes memory result);\\n\\n    /**\\n     * @notice A function that returns information about the type of metadata provider and its location.\\n     *         For more information on metadata provider, refer to https://github.com/safe-global/safe-core-protocol-specs/.\\n     * @return providerType uint256 Type of metadata provider\\n     * @return location bytes\\n     */\\n    function metadataProvider() external view returns (uint256 providerType, bytes memory location);\\n}\\n\\n/**\\n * @title ISafeProtocolStaticFunctionHandler - An interface that a Safe{Core} Protocol Function handler should implement in case when handling static calls\\n * @notice In Safe{Core} Protocol, a function handler can be used to add additional functionality to an account.\\n *         User(s) should add SafeProtocolManager as a function handler (aka fallback handler in Safe v1.x) to the account\\n *         and enable the contract implementing ISafeProtocolStaticFunctionHandler interface as a function handler in the\\n *         SafeProtocolManager for the specific function identifier.\\n */\\ninterface ISafeProtocolStaticFunctionHandler is IERC165 {\\n    /**\\n     * @notice Handles static calls to the account contract forwarded by the fallback function.\\n     * @param account Address of the account\\n     * @param sender Address of the sender\\n     * @param value Amount of ETH\\n     * @param data Arbitrary length bytes\\n     * @return result Arbitrary length bytes containing result of the operation\\n     */\\n    function handle(address account, address sender, uint256 value, bytes calldata data) external view returns (bytes memory result);\\n\\n    /**\\n     * @notice A function that returns information about the type of metadata provider and its location.\\n     *         For more information on metadata provider, refer to https://github.com/safe-global/safe-core-protocol-specs/.\\n     * @return providerType uint256 Type of metadata provider\\n     * @return location bytes\\n     */\\n    function metadataProvider() external view returns (uint256 providerType, bytes memory location);\\n}\\n\\n/**\\n * @title ISafeProtocolHooks - An interface that a contract should implement to be enabled as hooks.\\n * @notice In Safe{Core} Protocol, hooks can approve or deny transactions based on the logic it implements.\\n */\\ninterface ISafeProtocolHooks is IERC165 {\\n    /**\\n     * @notice A function that will be called before the execution of a transaction if the hooks are enabled\\n     * @dev Add custom logic in this function to validate the pre-state and contents of transaction for non-root access.\\n     * @param account Address of the account\\n     * @param tx A struct of type SafeTransaction that contains the details of the transaction.\\n     * @param executionType uint256\\n     * @param executionMeta Arbitrary length of bytes\\n     * @return preCheckData bytes\\n     */\\n    function preCheck(\\n        address account,\\n        SafeTransaction calldata tx,\\n        uint256 executionType,\\n        bytes calldata executionMeta\\n    ) external returns (bytes memory preCheckData);\\n\\n    /**\\n     * @notice A function that will be called before the execution of a transaction if the hooks are enabled and\\n     *         transaction requies root access.\\n     * @dev Add custom logic in this function to validate the pre-state and contents of transaction for root access.\\n     * @param account Address of the account\\n     * @param rootAccess DataTypes.SafeRootAccess\\n     * @param executionType uint256\\n     * @param executionMeta bytes\\n     * @return preCheckData bytes\\n     */\\n    function preCheckRootAccess(\\n        address account,\\n        SafeRootAccess calldata rootAccess,\\n        uint256 executionType,\\n        bytes calldata executionMeta\\n    ) external returns (bytes memory preCheckData);\\n\\n    /**\\n     * @notice A function that will be called after the execution of a transaction if the hooks are enabled. Hooks should revert if the post state of after the transaction is not as expected.\\n     * @dev Add custom logic in this function to validate the post-state after the transaction is executed.\\n     * @param account Address of the account\\n     * @param success bool\\n     * @param preCheckData Arbitrary length bytes that was returned by during pre-check of the transaction.\\n     */\\n    function postCheck(address account, bool success, bytes calldata preCheckData) external;\\n}\\n\\n/**\\n * @title ISafeProtocolPlugin - An interface that a Safe{Core} Protocol Plugin should implement\\n */\\ninterface ISafeProtocolPlugin is IERC165 {\\n    /**\\n     * @notice A funtion that returns name of the plugin\\n     * @return name string name of the plugin\\n     */\\n    function name() external view returns (string memory name);\\n\\n    /**\\n     * @notice A function that returns version of the plugin\\n     * @return version string version of the plugin\\n     */\\n    function version() external view returns (string memory version);\\n\\n    /**\\n     * @notice A function that returns information about the type of metadata provider and its location.\\n     *         For more information on metadata provider, refer to https://github.com/safe-global/safe-core-protocol-specs/.\\n     * @return providerType uint256 Type of metadata provider\\n     * @return location bytes\\n     */\\n    function metadataProvider() external view returns (uint256 providerType, bytes memory location);\\n\\n    /**\\n     * @notice A function that indicates permissions required by the.\\n     * @dev Permissions types and value: EXECUTE_CALL = 1, CALL_TO_SELF = 2, EXECUTE_DELEGATECALL = 4.\\n     *      These values can be sumed to indicate multiple permissions. e.g. EXECUTE_CALL + CALL_TO_SELF = 3\\n     * @return permissions Bit-based permissions required by the plugin.\\n     */\\n    function requiresPermissions() external view returns (uint8 permissions);\\n}\\n\"\r\n    },\r\n    \"lib/safe-protocol/contracts/common/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.18;\\n\\n// Plugin permissions\\nuint8 constant PLUGIN_PERMISSION_NONE = 0;\\nuint8 constant PLUGIN_PERMISSION_EXECUTE_CALL = 1;\\nuint8 constant PLUGIN_PERMISSION_CALL_TO_SELF = 2;\\nuint8 constant PLUGIN_PERMISSION_EXECUTE_DELEGATECALL = 4;\\n\\n// Module types\\nuint8 constant MODULE_TYPE_PLUGIN = 1;\\nuint8 constant MODULE_TYPE_FUNCTION_HANDLER = 2;\\nuint8 constant MODULE_TYPE_HOOKS = 4;\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/safe-protocol/contracts/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.18;\\n\\nstruct SafeProtocolAction {\\n    address payable to;\\n    uint256 value;\\n    bytes data;\\n}\\n\\nstruct SafeTransaction {\\n    SafeProtocolAction[] actions;\\n    uint256 nonce;\\n    bytes32 metadataHash;\\n}\\n\\nstruct SafeRootAccess {\\n    SafeProtocolAction action;\\n    uint256 nonce;\\n    bytes32 metadataHash;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@chainlink/=lib/chainlink/contracts/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"safe-protocol/=lib/safe-protocol/contracts/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"moduleTypes\",\"type\":\"uint8\"}],\"name\":\"CannotAddModule\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"CannotFlagModule\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"expectedInterfaceId\",\"type\":\"bytes4\"}],\"name\":\"ModuleDoesNotSupportExpectedInterfaceId\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ModuleFlagged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"moduleTypes\",\"type\":\"uint8\"}],\"name\":\"addModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"check\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"listedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"flaggedAt\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"flagModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"listedModules\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"listedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"flaggedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"moduleTypes\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SafeProtocolRegistry", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cb1c77846c34ea44f40b447fae0d2fdf2b4b5919", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}