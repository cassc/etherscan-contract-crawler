{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"../library/UserOperation.sol\\\";\\n\\ninterface IAccount {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp the operation that is about to be executed.\\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\\n     * @param aggregator the aggregator used to validate the signature. NULL for non-aggregated signature accounts.\\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     *      The excess is left as a deposit in the entrypoint, for future calls.\\n     *      can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\"\\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\\n     * @return deadline the last block timestamp this operation is valid, or zero if it is valid indefinitely.\\n     *      signature failure is returned as SIG_VALIDATION_FAILED value (1)\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        address aggregator,\\n        uint256 missingAccountFunds\\n    ) external returns (uint256 deadline);\\n\\n    function validateUserOpWithoutSig(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        address aggregator,\\n        uint256 missingAccountFunds\\n    ) external returns (uint256 deadline);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISignatureValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\n\\ncontract ISignatureValidatorConstants {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\\n}\\n\\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param _data Arbitrary length data signed on the behalf of address(this)\\n     * @param _signature Signature byte array associated with _data\\n     *\\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n     * MUST allow external calls\\n     */\\n    function isValidSignature(\\n        bytes memory _data,\\n        bytes memory _signature\\n    ) public view virtual returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\ninterface IStorage {\\n    struct bundlerInformation {\\n        address bundler;\\n        uint256 registeTime;\\n    }\\n    event UnrestrictedWalletSet(bool allowed);\\n    event UnrestrictedBundlerSet(bool allowed);\\n    event UnrestrictedModuleSet(bool allowed);\\n    event WalletFactoryWhitelistSet(address walletProxyFactory);\\n    event BundlerWhitelistSet(address indexed bundler, bool allowed);\\n    event ModuleWhitelistSet(address indexed module, bool allowed);\\n\\n    function officialBundlerWhiteList(\\n        address bundler\\n    ) external view returns (bool);\\n\\n    function moduleWhiteList(address module) external view returns (bool);\\n\\n    function setUnrestrictedWallet(bool allowed) external;\\n\\n    function setUnrestrictedBundler(bool allowed) external;\\n\\n    function setUnrestrictedModule(bool allowed) external;\\n\\n    function setBundlerOfficialWhitelist(\\n        address bundler,\\n        bool allowed\\n    ) external;\\n\\n    function setWalletProxyFactoryWhitelist(address walletFactory) external;\\n\\n    function setModuleWhitelist(address module, bool allowed) external;\\n\\n    function validateModuleWhitelist(address module) external;\\n\\n    function validateWalletWhitelist(address sender) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/library/UserOperation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request\\n * @param nonce unique value the sender uses to verify it is not a replay.\\n * @param initCode if set, the account contract will be created by this constructor\\n * @param callData the method call to execute on this account.\\n * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp\\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n * @param maxFeePerGas same as EIP-1559 gas parameter\\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter\\n * @param paymasterAndData if set, this field hold the paymaster address and \\\"paymaster-specific-data\\\". the paymaster will pay for the transaction instead of the sender\\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct UserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    uint256 callGasLimit;\\n    uint256 verificationGasLimit;\\n    uint256 preVerificationGas;\\n    uint256 maxFeePerGas;\\n    uint256 maxPriorityFeePerGas;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\\nlibrary UserOperationLib {\\n    function getSender(\\n        UserOperation calldata userOp\\n    ) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(\\n        UserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            uint256 maxFeePerGas = userOp.maxFeePerGas;\\n            uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    function pack(\\n        UserOperation calldata userOp\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return\\n            abi.encode(\\n                sender,\\n                nonce,\\n                hashInitCode,\\n                hashCallData,\\n                callGasLimit,\\n                verificationGasLimit,\\n                preVerificationGas,\\n                maxFeePerGas,\\n                maxPriorityFeePerGas,\\n                hashPaymasterAndData\\n            );\\n    }\\n\\n    function calldataKeccak(\\n        bytes calldata data\\n    ) internal pure returns (bytes32 ret) {\\n        assembly {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n    function hash(\\n        UserOperation calldata userOp\\n    ) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/base/Executor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\nimport \\\"../common/Enum.sol\\\";\\n\\n/// @title Executor - A contract that can execute transactions\\ncontract Executor {\\n    struct ExecuteParams {\\n        bool allowFailed;\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        bytes nestedCalls; // ExecuteParams encoded as bytes\\n    }\\n\\n    event HandleSuccessExternalCalls();\\n    event HandleFailedExternalCalls(bytes revertReason);\\n\\n    function execute(\\n        ExecuteParams memory params,\\n        Enum.Operation operation,\\n        uint256 txGas\\n    ) internal returns (bool success) {\\n        bytes memory result;\\n\\n        if (operation == Enum.Operation.DelegateCall) {\\n            // solhint-disable-next-line no-inline-assembly\\n            (success, result) = params.to.delegatecall{gas: txGas}(params.data);\\n        } else {\\n            // solhint-disable-next-line no-inline-assembly\\n            (success, result) = payable(params.to).call{\\n                gas: txGas,\\n                value: params.value\\n            }(params.data);\\n        }\\n\\n        if (!success) {\\n            if (!params.allowFailed) {\\n                assembly {\\n                    revert(add(result, 32), mload(result))\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/base/FallbackManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\n\\nimport \\\"../common/SelfAuthorized.sol\\\";\\n\\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\\ncontract FallbackManager is SelfAuthorized {\\n    event ChangedFallbackHandler(address handler);\\n\\n    // keccak256(\\\"fallback_manager.handler.address\\\")\\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT =\\n        0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\\n\\n    function getFallbackHandler()\\n        public\\n        view\\n        returns (address fallbackHandler)\\n    {\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let encoded := sload(slot)\\n            fallbackHandler := shr(96, encoded)\\n        }\\n    }\\n\\n    /// @dev Allows to add a contract to handle fallback calls.\\n    ///      Only fallback calls without value and with data will be forwarded.\\n    ///      This can only be done via a Safe transaction.\\n    /// @param handler contract to handle fallbacks calls.\\n    function setFallbackHandler(address handler) external authorized {\\n        setFallbackHandler(handler, false);\\n        emit ChangedFallbackHandler(handler);\\n    }\\n\\n    function setFallbackHandler(address handler, bool delegate) internal {\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let encoded := or(shl(96, handler), delegate)\\n            sstore(slot, encoded)\\n        }\\n    }\\n\\n    function initializeFallbackHandler(address handler) internal {\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let encoded := shl(96, handler)\\n            sstore(slot, encoded)\\n        }\\n    }\\n\\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\\n    fallback() external {\\n        assembly {\\n            // Load handler and delegate flag from storage\\n            let encoded := sload(FALLBACK_HANDLER_STORAGE_SLOT)\\n            let handler := shr(96, encoded)\\n            let delegate := and(encoded, 1)\\n\\n            // Copy calldata to memory\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // If delegate flag is set, delegate the call to the handler\\n            switch delegate\\n            case 0 {\\n                mstore(calldatasize(), shl(96, caller()))\\n                let success := call(\\n                    gas(),\\n                    handler,\\n                    0,\\n                    0,\\n                    add(calldatasize(), 20),\\n                    0,\\n                    0\\n                )\\n                returndatacopy(0, 0, returndatasize())\\n                if iszero(success) {\\n                    revert(0, returndatasize())\\n                }\\n                return(0, returndatasize())\\n            }\\n            case 1 {\\n                let result := delegatecall(\\n                    gas(),\\n                    handler,\\n                    0,\\n                    calldatasize(),\\n                    0,\\n                    0\\n                )\\n\\n                returndatacopy(0, 0, returndatasize())\\n\\n                switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/base/GuardManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\n\\nimport \\\"../common/Enum.sol\\\";\\nimport \\\"../common/SelfAuthorized.sol\\\";\\nimport \\\"./Executor.sol\\\";\\n\\ninterface Guard {\\n    function checkTransaction(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external;\\n\\n    function checkAfterExecution(bool success) external;\\n}\\n\\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\\ncontract GuardManager is SelfAuthorized, Executor {\\n    event ChangedGuard(address guard);\\n\\n    // keccak256(\\\"guard_manager.guard.address\\\")\\n    bytes32 internal constant GUARD_STORAGE_SLOT =\\n        0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;\\n\\n    function getGuard() public view returns (address guard) {\\n        bytes32 slot = GUARD_STORAGE_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            guard := sload(slot)\\n        }\\n    }\\n\\n    function setGuard(address guard) external authorized {\\n        bytes32 slot = GUARD_STORAGE_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, guard)\\n        }\\n        emit ChangedGuard(guard);\\n    }\\n\\n    // execute from this contract\\n    function execTransactionBatch(\\n        bytes memory executeParamBytes\\n    ) external authorized {\\n        executeWithGuardBatch(abi.decode(executeParamBytes, (ExecuteParams[])));\\n    }\\n\\n    function execTransactionRevertOnFail(\\n        bytes memory executeParamBytes\\n    ) external authorized {\\n        execTransactionBatchRevertOnFail(\\n            abi.decode(executeParamBytes, (ExecuteParams[]))\\n        );\\n    }\\n\\n    function executeWithGuard(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal {\\n        address guard = getGuard();\\n        if (guard != address(0)) {\\n            Guard(guard).checkTransaction(to, value, data, Enum.Operation.Call);\\n            Guard(guard).checkAfterExecution(\\n                execute(\\n                    ExecuteParams(false, to, value, data, \\\"\\\"),\\n                    Enum.Operation.Call,\\n                    gasleft()\\n                )\\n            );\\n        } else {\\n            execute(\\n                ExecuteParams(false, to, value, data, \\\"\\\"),\\n                Enum.Operation.Call,\\n                gasleft()\\n            );\\n        }\\n    }\\n\\n    function execTransactionBatchRevertOnFail(\\n        ExecuteParams[] memory _params\\n    ) internal {\\n        address guard = getGuard();\\n        uint256 length = _params.length;\\n\\n        if (guard == address(0)) {\\n            for (uint256 i = 0; i < length; ) {\\n                ExecuteParams memory param = _params[i];\\n                execute(param, Enum.Operation.Call, gasleft());\\n\\n                if (param.nestedCalls.length > 0) {\\n                    try\\n                        this.execTransactionRevertOnFail(param.nestedCalls)\\n                    {} catch (bytes memory returnData) {\\n                        revert(string(returnData));\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else {\\n            for (uint256 i = 0; i < length; ) {\\n                ExecuteParams memory param = _params[i];\\n\\n                Guard(guard).checkTransaction(\\n                    param.to,\\n                    param.value,\\n                    param.data,\\n                    Enum.Operation.Call\\n                );\\n\\n                Guard(guard).checkAfterExecution(\\n                    execute(param, Enum.Operation.Call, gasleft())\\n                );\\n\\n                if (param.nestedCalls.length > 0) {\\n                    try\\n                        this.execTransactionRevertOnFail(param.nestedCalls)\\n                    {} catch (bytes memory returnData) {\\n                        revert(string(returnData));\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    function executeWithGuardBatch(ExecuteParams[] memory _params) internal {\\n        address guard = getGuard();\\n        uint256 length = _params.length;\\n\\n        if (guard == address(0)) {\\n            for (uint256 i = 0; i < length; ) {\\n                ExecuteParams memory param = _params[i];\\n                bool success = execute(param, Enum.Operation.Call, gasleft());\\n                if (success) {\\n                    emit HandleSuccessExternalCalls();\\n                }\\n\\n                if (param.nestedCalls.length > 0) {\\n                    try this.execTransactionBatch(param.nestedCalls) {} catch (\\n                        bytes memory returnData\\n                    ) {\\n                        emit HandleFailedExternalCalls(returnData);\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else {\\n            for (uint256 i = 0; i < length; ) {\\n                ExecuteParams memory param = _params[i];\\n\\n                Guard(guard).checkTransaction(\\n                    param.to,\\n                    param.value,\\n                    param.data,\\n                    Enum.Operation.Call\\n                );\\n\\n                bool success = execute(param, Enum.Operation.Call, gasleft());\\n                if (success) {\\n                    emit HandleSuccessExternalCalls();\\n                }\\n\\n                Guard(guard).checkAfterExecution(success);\\n\\n                if (param.nestedCalls.length > 0) {\\n                    try this.execTransactionBatch(param.nestedCalls) {} catch (\\n                        bytes memory returnData\\n                    ) {\\n                        emit HandleFailedExternalCalls(returnData);\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/base/ModuleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\nimport \\\"../common/Enum.sol\\\";\\nimport \\\"../common/SelfAuthorized.sol\\\";\\nimport \\\"./Executor.sol\\\";\\n\\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\\ncontract ModuleManager is SelfAuthorized, Executor {\\n    event EnabledModule(address module);\\n    event DisabledModule(address module);\\n    event ExecutionFromModuleSuccess(address module);\\n    event ExecutionFromModuleFailure(address module);\\n\\n    address internal constant SENTINEL_MODULES = address(0x1);\\n    mapping(address => address) internal modules;\\n\\n    function initializeModules() internal {\\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\\n    }\\n\\n    function enableModule(address module) public authorized {\\n        // Module address cannot be null or sentinel.\\n        require(module != address(0) && module != SENTINEL_MODULES, \\\"GS101\\\");\\n        // Module cannot be added twice.\\n        require(modules[module] == address(0), \\\"GS102\\\");\\n\\n        modules[module] = modules[SENTINEL_MODULES];\\n        modules[SENTINEL_MODULES] = module;\\n        emit EnabledModule(module);\\n    }\\n\\n    /// @dev Allows to remove a module from the whitelist.\\n    ///      This can only be done via a Safe transaction.\\n    /// @notice Disables the module `module` for the Safe.\\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\\n    /// @param module Module to be removed.\\n    function disableModule(\\n        address prevModule,\\n        address module\\n    ) public authorized {\\n        // Validate module address and check that it corresponds to module index.\\n        require(module != address(0) && module != SENTINEL_MODULES, \\\"GS101\\\");\\n        require(modules[prevModule] == module, \\\"GS103\\\");\\n        modules[prevModule] = modules[module];\\n        modules[module] = address(0);\\n        emit DisabledModule(module);\\n    }\\n\\n    /// @dev Returns if an module is enabled\\n    /// @return True if the module is enabled\\n    function isModuleEnabled(address module) public view returns (bool) {\\n        return SENTINEL_MODULES != module && modules[module] != address(0);\\n    }\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation\\n    ) public virtual {\\n        // Only whitelisted modules are allowed.\\n        require(modules[msg.sender] != address(0), \\\"GS104\\\");\\n        // Execute transaction without further confirmations.\\n        if (\\n            execute(\\n                ExecuteParams(false, to, value, data, \\\"\\\"),\\n                operation,\\n                gasleft()\\n            )\\n        ) emit ExecutionFromModuleSuccess(msg.sender);\\n        else emit ExecutionFromModuleFailure(msg.sender);\\n    }\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModuleReturnData(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation\\n    ) public returns (bytes memory returnData) {\\n        execTransactionFromModule(to, value, data, operation);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Load free memory location\\n            let ptr := mload(0x40)\\n            // We allocate memory for the return data by setting the free memory location to\\n            // current free memory location + data size + 32 bytes for data size value\\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\\n            // Store the size\\n            mstore(ptr, returndatasize())\\n            // Store the data\\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\\n            // Point the return data to the correct memory location\\n            returnData := ptr\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/base/OwnerManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\n\\ncontract OwnerManager {\\n    event AAOwnerSet(address owner);\\n\\n    address internal owner;\\n\\n    uint256 public nonce;\\n\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"not call by owner\\\");\\n        _;\\n    }\\n\\n    function initializeOwners(address _owner) internal {\\n        owner = _owner;\\n\\n        emit AAOwnerSet(_owner);\\n    }\\n\\n    function isOwner(address _owner) public view returns (bool) {\\n        return owner == _owner;\\n    }\\n\\n    function getOwner() public view returns (address) {\\n        return owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/base/SignatureManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../../interfaces/ISignatureValidator.sol\\\";\\nimport \\\"../../interfaces/IAccount.sol\\\";\\nimport \\\"../common/Enum.sol\\\";\\nimport \\\"../common/SignatureDecoder.sol\\\";\\nimport \\\"./OwnerManager.sol\\\";\\n\\ncontract SignatureManager is\\n    IAccount,\\n    ISignatureValidatorConstants,\\n    Enum,\\n    OwnerManager,\\n    SignatureDecoder\\n{\\n    using UserOperationLib for UserOperation;\\n\\n    uint256 internal constant NONCE_VALIDATION_FAILED = 2;\\n\\n    bytes32 internal immutable HASH_NAME;\\n\\n    bytes32 internal immutable HASH_VERSION;\\n\\n    bytes32 internal immutable TYPE_HASH;\\n\\n    address internal immutable ADDRESS_THIS;\\n\\n    bytes32 internal immutable EIP712_ORDER_STRUCT_SCHEMA_HASH;\\n\\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\\n\\n    struct SignMessage {\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        address EntryPoint;\\n        uint256 sigTime;\\n    }\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    constructor(string memory name, string memory version) {\\n        HASH_NAME = keccak256(bytes(name));\\n        HASH_VERSION = keccak256(bytes(version));\\n        TYPE_HASH = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        ADDRESS_THIS = address(this);\\n\\n        EIP712_ORDER_STRUCT_SCHEMA_HASH = keccak256(\\n            abi.encodePacked(\\n                \\\"SignMessage(\\\",\\n                \\\"address sender,\\\",\\n                \\\"uint256 nonce,\\\",\\n                \\\"bytes initCode,\\\",\\n                \\\"bytes callData,\\\",\\n                \\\"uint256 callGasLimit,\\\",\\n                \\\"uint256 verificationGasLimit,\\\",\\n                \\\"uint256 preVerificationGas,\\\",\\n                \\\"uint256 maxFeePerGas,\\\",\\n                \\\"uint256 maxPriorityFeePerGas,\\\",\\n                \\\"bytes paymasterAndData,\\\",\\n                \\\"address EntryPoint,\\\",\\n                \\\"uint256 sigTime\\\",\\n                \\\")\\\"\\n            )\\n        );\\n    }\\n\\n    function getUOPHash(\\n        SignatureType sigType,\\n        address EntryPoint,\\n        UserOperation calldata userOp\\n    ) public view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    sigType == SignatureType.EIP712Type\\n                        ? EIP712_ORDER_STRUCT_SCHEMA_HASH\\n                        : bytes32(block.chainid),\\n                    userOp.getSender(),\\n                    userOp.nonce,\\n                    keccak256(userOp.initCode),\\n                    keccak256(userOp.callData),\\n                    userOp.callGasLimit,\\n                    userOp.verificationGasLimit,\\n                    userOp.preVerificationGas,\\n                    userOp.maxFeePerGas,\\n                    userOp.maxPriorityFeePerGas,\\n                    keccak256(userOp.paymasterAndData),\\n                    EntryPoint,\\n                    uint256(bytes32(userOp.signature[1:33]))\\n                )\\n            );\\n    }\\n\\n    function getUOPSignedHash(\\n        SignatureType sigType,\\n        address EntryPoint,\\n        UserOperation calldata userOp\\n    ) public view returns (bytes32) {\\n        return\\n            sigType == SignatureType.EIP712Type\\n                ? ECDSA.toTypedDataHash(\\n                    keccak256(\\n                        abi.encode(\\n                            TYPE_HASH,\\n                            HASH_NAME,\\n                            HASH_VERSION,\\n                            block.chainid,\\n                            ADDRESS_THIS\\n                        )\\n                    ),\\n                    keccak256(\\n                        abi.encode(\\n                            EIP712_ORDER_STRUCT_SCHEMA_HASH,\\n                            userOp.getSender(),\\n                            userOp.nonce,\\n                            keccak256(userOp.initCode),\\n                            keccak256(userOp.callData),\\n                            userOp.callGasLimit,\\n                            userOp.verificationGasLimit,\\n                            userOp.preVerificationGas,\\n                            userOp.maxFeePerGas,\\n                            userOp.maxPriorityFeePerGas,\\n                            keccak256(userOp.paymasterAndData),\\n                            EntryPoint,\\n                            uint256(bytes32(userOp.signature[1:33]))\\n                        )\\n                    )\\n                )\\n                : ECDSA.toEthSignedMessageHash(\\n                    keccak256(\\n                        abi.encode(\\n                            bytes32(block.chainid),\\n                            userOp.getSender(),\\n                            userOp.nonce,\\n                            keccak256(userOp.initCode),\\n                            keccak256(userOp.callData),\\n                            userOp.callGasLimit,\\n                            userOp.verificationGasLimit,\\n                            userOp.preVerificationGas,\\n                            userOp.maxFeePerGas,\\n                            userOp.maxPriorityFeePerGas,\\n                            keccak256(userOp.paymasterAndData),\\n                            EntryPoint,\\n                            uint256(bytes32(userOp.signature[1:33]))\\n                        )\\n                    )\\n                );\\n    }\\n\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32,\\n        address,\\n        uint256 missingAccountFunds\\n    ) public virtual returns (uint256) {\\n        if (missingAccountFunds != 0) {\\n            payable(msg.sender).call{\\n                value: missingAccountFunds,\\n                gas: type(uint256).max\\n            }(\\\"\\\");\\n        }\\n\\n        unchecked {\\n            if (userOp.nonce != nonce++) {\\n                return NONCE_VALIDATION_FAILED;\\n            }\\n        }\\n\\n        if (\\n            ECDSA.recover(\\n                getUOPSignedHash(\\n                    SignatureType(uint8(bytes1(userOp.signature[0:1]))),\\n                    msg.sender,\\n                    userOp\\n                ),\\n                userOp.signature[33:]\\n            ) != owner\\n        ) {\\n            return SIG_VALIDATION_FAILED;\\n        } else {\\n            return uint256(bytes32(userOp.signature[1:33]));\\n        }\\n    }\\n\\n    function validateUserOpWithoutSig(\\n        UserOperation calldata userOp,\\n        bytes32,\\n        address,\\n        uint256 missingAccountFunds\\n    ) public virtual returns (uint256) {\\n        if (missingAccountFunds != 0) {\\n            payable(msg.sender).call{\\n                value: missingAccountFunds,\\n                gas: type(uint256).max\\n            }(\\\"\\\");\\n        }\\n\\n        unchecked {\\n            if (userOp.nonce != nonce++) {\\n                return NONCE_VALIDATION_FAILED;\\n            }\\n        }\\n\\n        if (\\n            ECDSA.recover(\\n                getUOPSignedHash(\\n                    SignatureType(uint8(bytes1(userOp.signature[0:1]))),\\n                    msg.sender,\\n                    userOp\\n                ),\\n                userOp.signature[33:]\\n            ) != owner\\n        ) {\\n            return uint256(bytes32(userOp.signature[1:33]));\\n        } else {\\n            return uint256(bytes32(userOp.signature[1:33]));\\n        }\\n    }\\n\\n    function isValidSignature(\\n        bytes32 _hash,\\n        bytes calldata _signature\\n    ) external view returns (bytes4) {\\n        if (isOwner(ECDSA.recover(_hash, _signature))) {\\n            return 0x1626ba7e;\\n        } else {\\n            return 0xffffffff;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/common/Enum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/// @title Enum - Collection of enums\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n    enum SignatureType {\\n        EIP712Type,\\n        EIP191Type\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/common/EtherPaymentFallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract EtherPaymentFallback {\\n    event SafeReceived(address indexed sender, uint256 value);\\n\\n    /// @dev Fallback function accepts Ether transactions.\\n    receive() external payable {\\n        emit SafeReceived(msg.sender, msg.value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/common/SecuredTokenTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/// @title SecuredTokenTransfer - Secure token transfer\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract SecuredTokenTransfer {\\n    /// @dev Transfers a token and returns if it was a success\\n    /// @param token Token that should be transferred\\n    /// @param receiver Receiver to whom the token should be transferred\\n    /// @param amount The amount of tokens that should be transferred\\n    function transferToken(\\n        address token,\\n        address receiver,\\n        uint256 amount\\n    ) internal returns (bool transferred) {\\n        // 0xa9059cbb - keccack(\\\"transfer(address,uint256)\\\")\\n        bytes memory data = abi.encodeWithSelector(\\n            0xa9059cbb,\\n            receiver,\\n            amount\\n        );\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // We write the return value to scratch space.\\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\\n            let success := call(\\n                sub(gas(), 10000),\\n                token,\\n                0,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0x20\\n            )\\n            switch returndatasize()\\n            case 0 {\\n                transferred := success\\n            }\\n            case 0x20 {\\n                transferred := iszero(or(iszero(success), iszero(mload(0))))\\n            }\\n            default {\\n                transferred := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/common/SelfAuthorized.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\nimport \\\"../common/SelfAuthorized.sol\\\";\\n\\n/// @title SelfAuthorized - authorizes current contract to perform actions\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract SelfAuthorized {\\n    function requireSelfCall() private view {\\n        require(msg.sender == address(this), \\\"GS031\\\");\\n    }\\n\\n    modifier authorized() {\\n        // This is a function call as it minimized the bytecode size\\n        requireSelfCall();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/common/SignatureDecoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract SignatureDecoder {\\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\\n    /// @notice Make sure to peform a bounds check for @param pos, to avoid out of bounds access on @param signatures\\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\\n    /// @param signatures concatenated rsv signatures\\n    function signatureSplit(\\n        bytes memory signatures,\\n        uint256 pos\\n    ) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        // The signature format is a compact form of:\\n        //   {bytes32 r}{bytes32 s}{uint8 v}\\n        // Compact means, uint8 is not padded to 32 bytes.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let signaturePos := mul(0x41, pos)\\n            r := mload(add(signatures, add(signaturePos, 0x20)))\\n            s := mload(add(signatures, add(signaturePos, 0x40)))\\n            // Here we are loading the last 32 bytes, including 31 bytes\\n            // of 's'. There is no 'mload8' to do this.\\n            //\\n            // 'byte' is not working due to the Solidity parser, so lets\\n            // use the second best option, 'and'\\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/common/Singleton.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\nimport \\\"./SelfAuthorized.sol\\\";\\n\\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\\n///         This contract is tightly coupled to our proxy contract\\ncontract Singleton is SelfAuthorized {\\n    event ImplementUpdated(address indexed implement);\\n    address internal singleton;\\n\\n    function updateImplement(address implement) external authorized {\\n        singleton = implement;\\n        emit ImplementUpdated(implement);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wallet/SmartAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IStorage.sol\\\";\\nimport \\\"./base/SignatureManager.sol\\\";\\nimport \\\"./base/ModuleManager.sol\\\";\\nimport \\\"./base/OwnerManager.sol\\\";\\nimport \\\"./base/FallbackManager.sol\\\";\\nimport \\\"./base/GuardManager.sol\\\";\\nimport \\\"./common/EtherPaymentFallback.sol\\\";\\nimport \\\"./common/Singleton.sol\\\";\\nimport \\\"./common/SignatureDecoder.sol\\\";\\nimport \\\"./common/SecuredTokenTransfer.sol\\\";\\n\\ncontract SmartAccount is\\n    EtherPaymentFallback,\\n    Singleton,\\n    ModuleManager,\\n    OwnerManager,\\n    SignatureDecoder,\\n    SecuredTokenTransfer,\\n    FallbackManager,\\n    GuardManager,\\n    SignatureManager\\n{\\n    address public immutable EntryPoint;\\n    address public immutable FallbackHandler;\\n\\n    constructor(\\n        address _EntryPoint,\\n        address _FallbackHandler,\\n        string memory _name,\\n        string memory _version\\n    ) SignatureManager(_name, _version) {\\n        EntryPoint = _EntryPoint;\\n        FallbackHandler = _FallbackHandler;\\n    }\\n\\n    modifier onlyEntryPoint() {\\n        require(msg.sender == EntryPoint, \\\"Not from entrypoint\\\");\\n        _;\\n    }\\n\\n    function Initialize(address _owner) external {\\n        require(getOwner() == address(0), \\\"account: have set up\\\");\\n        initializeOwners(_owner);\\n        initializeFallbackHandler(FallbackHandler);\\n        initializeModules();\\n    }\\n\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        address aggregatorAddress,\\n        uint256 missingAccountFunds\\n    ) public override onlyEntryPoint returns (uint256 deadline) {\\n        deadline = super.validateUserOp(\\n            userOp,\\n            userOpHash,\\n            aggregatorAddress,\\n            missingAccountFunds\\n        );\\n    }\\n\\n    function validateUserOpWithoutSig(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        address aggregatorAddress,\\n        uint256 missingAccountFunds\\n    ) public override onlyEntryPoint returns (uint256 deadline) {\\n        deadline = super.validateUserOpWithoutSig(\\n            userOp,\\n            userOpHash,\\n            aggregatorAddress,\\n            missingAccountFunds\\n        );\\n    }\\n\\n    function execTransactionFromEntrypoint(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) public onlyEntryPoint {\\n        executeWithGuard(to, value, data);\\n    }\\n\\n    function execTransactionFromEntrypointBatch(\\n        ExecuteParams[] calldata _params\\n    ) external onlyEntryPoint {\\n        executeWithGuardBatch(_params);\\n    }\\n\\n    function execTransactionFromEntrypointBatchRevertOnFail(\\n        ExecuteParams[] calldata _params\\n    ) external onlyEntryPoint {\\n        execTransactionBatchRevertOnFail(_params);\\n    }\\n\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation\\n    ) public override {\\n        IStorage(EntryPoint).validateModuleWhitelist(msg.sender);\\n\\n        if (operation == Enum.Operation.Call) {\\n            ModuleManager.execTransactionFromModule(to, value, data, operation);\\n        } else {\\n            address originalFallbackHandler = getFallbackHandler();\\n\\n            setFallbackHandler(msg.sender, true);\\n            ModuleManager.execTransactionFromModule(to, value, data, operation);\\n            setFallbackHandler(originalFallbackHandler, false);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_EntryPoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_FallbackHandler\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_version\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AAOwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"ChangedFallbackHandler\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"ChangedGuard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"DisabledModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"EnabledModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ExecutionFromModuleFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ExecutionFromModuleSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"revertReason\",\"type\":\"bytes\"}],\"name\":\"HandleFailedExternalCalls\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HandleSuccessExternalCalls\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implement\",\"type\":\"address\"}],\"name\":\"ImplementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SafeReceived\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"EntryPoint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FallbackHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"Initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"disableModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"enableModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"executeParamBytes\",\"type\":\"bytes\"}],\"name\":\"execTransactionBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execTransactionFromEntrypoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"allowFailed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"nestedCalls\",\"type\":\"bytes\"}],\"internalType\":\"struct Executor.ExecuteParams[]\",\"name\":\"_params\",\"type\":\"tuple[]\"}],\"name\":\"execTransactionFromEntrypointBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"allowFailed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"nestedCalls\",\"type\":\"bytes\"}],\"internalType\":\"struct Executor.ExecuteParams[]\",\"name\":\"_params\",\"type\":\"tuple[]\"}],\"name\":\"execTransactionFromEntrypointBatchRevertOnFail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"execTransactionFromModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"execTransactionFromModuleReturnData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"executeParamBytes\",\"type\":\"bytes\"}],\"name\":\"execTransactionRevertOnFail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFallbackHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fallbackHandler\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGuard\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Enum.SignatureType\",\"name\":\"sigType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"EntryPoint\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"getUOPHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Enum.SignatureType\",\"name\":\"sigType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"EntryPoint\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"getUOPSignedHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"isModuleEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"setFallbackHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"setGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implement\",\"type\":\"address\"}],\"name\":\"updateImplement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"aggregatorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"missingAccountFunds\",\"type\":\"uint256\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"aggregatorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"missingAccountFunds\",\"type\":\"uint256\"}],\"name\":\"validateUserOpWithoutSig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SmartAccount", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dc5319815cdaac2d113f7f275bc893ed7d9ca469000000000000000000000000c9b02677ebfa3f4da43ebefc6fc38e11148b664d000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000253410000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005312e302e30000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}