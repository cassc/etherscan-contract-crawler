{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/external/IERC20Minimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\n/// @title Minimal ERC20 interface for lighter\\n/// @notice Contains a subset of the full ERC20 interface that is used in lighter\\ninterface IERC20Minimal {\\n    /// @notice Returns the balance of the account provided\\n    /// @param account The account to get the balance of\\n    /// @return balance The balance of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Transfers given amount of tokens from caller to the recipient\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return success Returns true for a successful transfer, false for unsuccessful\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers given amount of tokens from the sender to the recipient\\n    /// @param sender The sender of the transfer\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return success Returns true for a successful transfer, false for unsuccessful\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /// @return decimals Returns the decimals of the token\\n    function decimals() external returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport \\\"../libraries/LinkedList.sol\\\";\\nimport \\\"./external/IERC20Minimal.sol\\\";\\n\\n/// @title Order Book Interface\\n/// @notice Order book implements spot trading endpoints and storage for two assets which conform to the IERC20Minimal specification.\\ninterface IOrderBook {\\n    /// @notice Limit Order type.\\n    enum OrderType {\\n        LimitOrder, // Limit order\\n        PerformanceLimitOrder, // Limit order that uses claimable balances\\n        FoKOrder, // Fill or Kill limit order\\n        IoCOrder // Immediate or Cancel limit order\\n    }\\n\\n    /// @notice Struct to use for storing limit orders\\n    struct LimitOrder {\\n        uint32 perfMode_creatorId; // lowest bit for perfMode, remaining 31 bits for creatorId\\n        uint32 prev; // id of the previous order in the list\\n        uint32 next; // id of the next order in the list\\n        uint32 ownerId; // id of the owner of the order\\n        uint64 amount0Base; // amount0Base of the order\\n        uint64 priceBase; // priceBase of the order\\n    }\\n\\n    /// @notice Struct to use returning the paginated orders\\n    struct OrderQueryItem {\\n        bool isAsk; // true if the paginated orders are ask orders, false if bid orders\\n        uint32[] ids; // order ids of returned orders\\n        address[] owners; // owner addresses of returned orders\\n        uint256[] amount0s; // amount0s of returned orders (amount0Base * sizeTick)\\n        uint256[] prices; // prices of returned orders (priceBase * priceTick)\\n    }\\n\\n    /// @notice Emitted when a limit order gets created\\n    /// @param owner The address of the order owner\\n    /// @param id The id of the order\\n    /// @param amount0Base The amount of token0 in the limit order in terms of number of sizeTicks\\n    /// @param priceBase The price of the token0 in terms of price ticks\\n    /// @param isAsk Whether the order is an ask order\\n    /// @param orderType type of the order\\n    event CreateOrder(\\n        address indexed owner,\\n        uint32 indexed id,\\n        uint64 amount0Base,\\n        uint64 priceBase,\\n        bool isAsk,\\n        OrderType orderType\\n    );\\n\\n    /// @notice Emitted when a limit order gets canceled\\n    /// @param id The id of the canceled order\\n    event CancelLimitOrder(uint32 indexed id);\\n\\n    /// @notice Emitted when a taker initiates a swap (market order)\\n    /// @param sender The address that initiated the swap\\n    /// @param recipient The address that received the tokens from the swap\\n    /// @param isExactInput Whether the input amount is exact or output amount is exact\\n    /// @param isAsk Whether the order is an ask order\\n    /// @param swapAmount0 The amount of token0 that was swapped\\n    /// @param swapAmount1 The amount of token1 that was swapped\\n    event SwapExactAmount(\\n        address indexed sender,\\n        address indexed recipient,\\n        bool isExactInput,\\n        bool isAsk,\\n        uint256 swapAmount0,\\n        uint256 swapAmount1\\n    );\\n\\n    /// @notice Emitted when a maker gets filled by a taker\\n    /// @param askId The id of the ask order\\n    /// @param bidId The id of the bid order\\n    /// @param askOwner The address of the ask order owner\\n    /// @param bidOwner The address of the bid order owner\\n    /// @param amount0 The amount of token0 that was swapped\\n    /// @param amount1 The amount of token1 that was swapped\\n    event Swap(\\n        uint32 indexed askId,\\n        uint32 indexed bidId,\\n        address askOwner,\\n        address bidOwner,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted when flashLoan is called\\n    /// @param sender The address that initiated the flashLoan, and that received the callback\\n    /// @param recipient The address that received the tokens from flash loan\\n    /// @param amount0 The amount of token0 that was flash loaned\\n    /// @param amount1 The amount of token1 that was flash loaned\\n    event FlashLoan(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1);\\n\\n    /// @notice Emitted when user claimable balance is increased due to deposit or order operations\\n    event ClaimableBalanceIncrease(address indexed owner, uint256 amountDelta, bool isToken0);\\n\\n    /// @notice Emitted when user claimable balance is decreased due to withdraw or order operations\\n    event ClaimableBalanceDecrease(address indexed owner, uint256 amountDelta, bool isToken0);\\n\\n    /// @notice Creates a limit order.\\n    /// @param amount0Base The amount of token0 in the limit order in terms of number of sizeTicks.\\n    /// amount0 is calculated by multiplying amount0Base by sizeTick.\\n    /// @param priceBase The price of the token0 in terms of price ticks.\\n    /// amount1 is calculated by multiplying priceBase by sizeTick and priceMultiplier and dividing by priceDivider.\\n    /// @param isAsk Whether the order is an ask order\\n    /// @param owner The address which will receive the funds and that can\\n    /// cancel this order. When called by a router, it'll be populated\\n    /// with msg.sender. Smart wallets should use msg.sender directly.\\n    /// @param hintId Hint on where to insert the order in the order book.\\n    /// Can be calculated with suggestHintId function, is not used for FoK and IoC orders.\\n    /// @param orderType type of the order, if FoK or IoC remaining order will not be added for future matches.\\n    /// @param callbackData data to be passed to callback\\n    /// @return id The id of the order\\n    function createOrder(\\n        uint64 amount0Base,\\n        uint64 priceBase,\\n        bool isAsk,\\n        address owner,\\n        uint32 hintId,\\n        OrderType orderType,\\n        bytes memory callbackData\\n    ) external returns (uint32);\\n\\n    /// @notice Cancels an outstanding limit order. Refunds the remaining tokens in the order to the owner\\n    /// @param id The id of the order to cancel\\n    /// @param owner The address of the order sender\\n    /// @return isCanceled Whether the order was successfully canceled or not\\n    function cancelLimitOrder(uint32 id, address owner) external returns (bool);\\n\\n    /// @notice Swaps exact input or output amount of token0 or token1 for the other token\\n    /// @param isAsk Whether the order is an ask order, if true sender pays token0 and receives token1\\n    /// @param isExactInput Whether the input amount is exact or output amount is exact\\n    /// @param exactAmount exact token amount to swap (can be token0 or token1 based on isAsk and isExactInput)\\n    /// @param expectedAmount expected token amount to receive (can be token0 or token1 based on isAsk and isExactInput).\\n    /// if isExactInput is true, then expectedAmount is the minimum amount to receive.\\n    /// if isExactInput is false, then expectedAmount is the maximum amount to pay\\n    /// @param recipient The address which will receive the output\\n    /// @param callbackData data to be passed to callback\\n    function swapExactSingle(\\n        bool isAsk,\\n        bool isExactInput,\\n        uint256 exactAmount,\\n        uint256 expectedAmount,\\n        address recipient,\\n        bytes memory callbackData\\n    ) external returns (uint256, uint256);\\n\\n    /// @notice Flash loans token0 and token1 to the recipient, sender receives the callback\\n    /// @param recipient The address which will receive the token0 and token1\\n    /// @param amount0 The amount of token0 to flash loan\\n    /// @param amount1 The amount of token1 to flash loan\\n    /// @param callbackData data to be passed to callback\\n    function flashLoan(address recipient, uint256 amount0, uint256 amount1, bytes calldata callbackData) external;\\n\\n    /// @notice Deposits token0 or token1 from user to the order book and marks it as claimable\\n    /// to be used for performance limit orders for gas efficient limit order creations.\\n    /// @param amountToDeposit Amount to deposit\\n    /// @param isToken0 Whether the deposit is token0 or token1\\n    /// @param callbackData Byte data to send to callback\\n    function depositToken(uint256 amountToDeposit, bool isToken0, bytes memory callbackData) external;\\n\\n    /// @notice Withdraws deposited or swapped token0 or token1 to the owner.\\n    /// @param amountToClaim Amount to withdraw\\n    /// @param isToken0 Whether the claimable token is token0 or token1\\n    function claimToken(uint256 amountToClaim, bool isToken0) external;\\n\\n    /// @notice Finds the order id where the new order should be inserted to the right of\\n    /// Meant to be used off-chain to find the hintId for limit order creation functions\\n    /// @param priceBase basePrice derived from amount0Base and amount1Base\\n    /// @param isAsk Whether the new order is an ask order\\n    /// @return hintId The id of the order where the new order\\n    /// should be inserted to the right of\\n    function suggestHintId(uint64 priceBase, bool isAsk) external view returns (uint32);\\n\\n    /// @notice Returns the amount of token0 and token1 to traded between two limit orders\\n    /// @param takerOrderAmount0Base The amount0Base of the taker order\\n    /// @param takerOrderPriceBase The priceBase of the taker order\\n    /// @param makerOrderAmount0Base The amount0Base of the maker order\\n    /// @param makerOrderPriceBase The priceBase of the maker order\\n    /// @param isTakerAsk True if taker order is an ask\\n    /// @return amount0BaseReturn The amount0Base to be traded\\n    /// @return amount1BaseReturn The amount1Base to be traded\\n    function getLimitOrderSwapAmounts(\\n        uint64 takerOrderAmount0Base,\\n        uint64 takerOrderPriceBase,\\n        uint64 makerOrderAmount0Base,\\n        uint64 makerOrderPriceBase,\\n        bool isTakerAsk\\n    ) external pure returns (uint64, uint128);\\n\\n    /// @notice Returns the amount of token0 and token1 to traded between maker and swapper\\n    /// @param amount0 Exact token0 amount taker wants to trade\\n    /// @param isAsk True if swapper is an ask\\n    /// @param makerAmount0Base The amount0Base of the maker order\\n    /// @param makerPriceBase The priceBase of the maker order\\n    /// @return swapAmount0 The amount of token0 to be swapped\\n    /// @return swapAmount1 The amount of token1 to be swapped\\n    /// @return amount0BaseDelta Maker order baseAmount0 change\\n    /// @return fullTakerFill True if swapper can be fully filled by maker order\\n    function getSwapAmountsForToken0(\\n        uint256 amount0,\\n        bool isAsk,\\n        uint64 makerAmount0Base,\\n        uint64 makerPriceBase\\n    ) external view returns (uint256, uint256, uint64, bool);\\n\\n    /// @notice Returns the amount of token0 and token1 to traded between maker and swapper\\n    /// @param amount1 Exact token1 amount taker wants to trade\\n    /// @param isAsk True if swapper is an ask\\n    /// @param makerAmount0Base The amount0Base of the maker order\\n    /// @param makerPriceBase The priceBase of the maker order\\n    /// @return swapAmount0 The amount of token0 to be swapped\\n    /// @return swapAmount1 The amount of token1 to be swapped\\n    /// @return amount0BaseDelta Maker order baseAmount0 change\\n    /// @return fullTakerFill True if swapper can be fully filled by maker order\\n    function getSwapAmountsForToken1(\\n        uint256 amount1,\\n        bool isAsk,\\n        uint64 makerAmount0Base,\\n        uint64 makerPriceBase\\n    ) external view returns (uint256, uint256, uint64, bool);\\n\\n    /// @notice Returns price sorted limit orders with pagination\\n    /// @param startOrderId orderId from where the pagination should start (not inclusive)\\n    /// @dev caller can pass 0 to start from the top of the book\\n    /// @param isAsk Whether to return ask or bid orders\\n    /// @param limit Number number of orders to return in the page\\n    /// @return orderData The paginated order data\\n    function getPaginatedOrders(\\n        uint32 startOrderId,\\n        bool isAsk,\\n        uint32 limit\\n    ) external view returns (OrderQueryItem memory orderData);\\n\\n    /// @notice Returns the limit order of the given index\\n    /// @param isAsk Whether the order is an ask order\\n    /// @param id The id of the order\\n    /// @return order The limit order\\n    function getLimitOrder(bool isAsk, uint32 id) external view returns (LimitOrder memory);\\n\\n    /// @notice Returns whether an order is active or not\\n    /// @param id The id of the order\\n    /// @return isActive True if the order is active, false otherwise\\n    function isOrderActive(uint32 id) external view returns (bool);\\n\\n    /// @notice Returns whether an order is an ask order or not, fails if order is not active\\n    /// @param id The id of the order\\n    /// @return isAsk True if the order is an ask order, false otherwise\\n    function isAskOrder(uint32 id) external view returns (bool);\\n\\n    /// @notice Returns the constant for Log value of TickThreshold\\n    /// @return LOG10_TICK_THRESHOLD threshold for Log value of TickThreshold\\n    function LOG10_TICK_THRESHOLD() external view returns (uint8);\\n\\n    /// @notice Returns the constant for threshold value of orderId\\n    /// @return ORDER_ID_THRESHOLD threshold for threshold value of orderId\\n    function ORDER_ID_THRESHOLD() external view returns (uint32);\\n\\n    /// @notice Returns the constant for threshold value of creatorId\\n    /// @return CREATOR_ID_THRESHOLD threshold for threshold value of creatorId\\n    function CREATOR_ID_THRESHOLD() external view returns (uint32);\\n\\n    /// @notice The token0 (base token)\\n    /// @return token0 The token0 (base token) contract\\n    function token0() external view returns (IERC20Minimal);\\n\\n    /// @notice The token1 (quote token)\\n    /// @return token1 The token1 (quote token) contract\\n    function token1() external view returns (IERC20Minimal);\\n\\n    /// @notice Id of the order book\\n    /// @return orderBookId The unique identifier of an order book\\n    function orderBookId() external view returns (uint8);\\n\\n    /// @notice The sizeTick of the order book\\n    /// @return sizeTick The sizeTick of the order book\\n    function sizeTick() external view returns (uint128);\\n\\n    /// @notice The priceTick of the order book\\n    /// @return priceTick The priceTick of the order book\\n    function priceTick() external view returns (uint128);\\n\\n    /// @notice The priceMultiplier of the order book\\n    /// @return priceMultiplier The priceMultiplier of the order book\\n    function priceMultiplier() external view returns (uint128);\\n\\n    /// @notice The priceDivider of the order book\\n    /// @return priceDivider The priceMultiplier of the order book\\n    function priceDivider() external view returns (uint128);\\n\\n    /// @notice Returns the id of the next order Id to create\\n    /// @return orderIdCounter id of the next order\\n    function orderIdCounter() external view returns (uint32);\\n\\n    /// @notice minToken0BaseAmount minimum token0Base amount for limit order\\n    /// @return minToken0BaseAmount minToken0BaseAmount of the order book\\n    function minToken0BaseAmount() external view returns (uint64);\\n\\n    /// @notice minToken1BaseAmount minimum token1Base amount (token0Base * priceBase) for limit order\\n    /// @return minToken1BaseAmount minToken1BaseAmount of the order book\\n    function minToken1BaseAmount() external view returns (uint128);\\n\\n    /// @notice Claimable token0 amount for given address\\n    /// @return claimableToken0Balance Claimable token0 amount for given address\\n    function claimableToken0Balance(address owner) external view returns (uint256);\\n\\n    /// @notice Claimable token1 amount for given address\\n    /// @return claimableToken1Balance Claimable token1 amount for given address\\n    function claimableToken1Balance(address owner) external view returns (uint256);\\n\\n    /// @notice id of an order-owner\\n    /// @return addressToOwnerId id of an order-owner\\n    function addressToOwnerId(address owner) external view returns (uint32);\\n\\n    /// @notice address for given creatorId\\n    /// @return addressToCreatorId address for given creatorId\\n    function addressToCreatorId(address creatorAddress) external view returns (uint32);\\n\\n    /// @notice id of a creatorAddress\\n    /// @return creatorIdToAddress id of a creatorAddress\\n    function creatorIdToAddress(uint32 creatorId) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\n/// @title Errors\\n/// @notice Library containing errors that Lighter V2 Core functions may revert with\\nlibrary Errors {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      LIGHTER-V2-FACTORY\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when `msg.sender` is not the factory owner for setOwner or createOrderBook\\n    error LighterV2Factory_CallerNotOwner();\\n\\n    /// @notice Thrown when zero address is passed when setting the owner\\n    error LighterV2Factory_OwnerCannotBeZero();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      LIGHTER-V2-CREATE-ORDER-BOOK\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when token0 and token1 are identical or zero in order book creation\\n    error LighterV2CreateOrderBook_InvalidTokenPair();\\n\\n    /// @notice Thrown when an order book already exists with given token0 and token1 in order book creation\\n    error LighterV2CreateOrderBook_OrderBookAlreadyExists();\\n\\n    /// @notice Thrown when order book capacity is already reached in order book creation\\n    error LighterV2CreateOrderBook_OrderBookIdExceedsLimit();\\n\\n    /// @notice Thrown when invalid combination of logSizeTick and logPriceTick is given in order book creation\\n    error LighterV2CreateOrderBook_InvalidTickCombination();\\n\\n    /// @notice Thrown when invalid combination of minToken0BaseAmount and minToken1BaseAmount given in order book creation\\n    error LighterV2CreateOrderBook_InvalidMinAmount();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-V2-ORDER\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when invalid hintId is given in limit order creation\\n    error LighterV2Order_InvalidHintId();\\n\\n    /// @notice Thrown when given price is too small in order creation\\n    error LighterV2Order_PriceTooSmall();\\n\\n    /// @notice Thrown when given price is too big in order creation\\n    error LighterV2Order_PriceTooBig();\\n\\n    /// @notice Thrown when token0 or token1 amount is too small in limit order creation\\n    error LighterV2Order_AmountTooSmall();\\n\\n    /// @notice Thrown when order capacity is already reached in order creation\\n    error LighterV2Order_OrderIdExceedsLimit();\\n\\n    /// @notice Thrown when creator capacity is already reached in order creation\\n    error LighterV2Order_CreatorIdExceedsLimit();\\n\\n    /// @notice Thrown when tokens sent callback is insufficient in order creation or swap\\n    error LighterV2Order_InsufficentCallbackTransfer();\\n\\n    /// @notice Thrown when claimable balance is insufficient in order creation\\n    error LighterV2Order_InsufficientClaimableBalance();\\n\\n    /// @notice Thrown when FillOrKill order is not fully filled\\n    error LighterV2Order_FoKNotFilled();\\n\\n    /// @notice Thrown when contract balance decrease is larger than the transfered amount\\n    error LighterV2Base_ContractBalanceDoesNotMatchSentAmount();\\n\\n    /// @notice Thrown when caller is not the order creator or owner in order cancelation\\n    error LighterV2Owner_CallerCannotCancel();\\n\\n    /// @notice Thrown when caller tries to erase head or tail orders in order linked list\\n    error LighterV2Order_CannotEraseHeadOrTailOrders();\\n\\n    /// @notice Thrown when caller tries to cancel an order that is not active\\n    error LighterV2Order_CannotCancelInactiveOrders();\\n\\n    /// @notice Thrown when caller asks for order side for a inactive or non-existent order\\n    error LighterV2Order_OrderDoesNotExist();\\n\\n    /// @notice Thrown when caller tries to query an order book page starting from an inactive order\\n    error LighterV2Order_CannotQueryFromInactiveOrder();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-SWAP\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when order book does not have enough liquidity to fill the swap\\n    error LighterV2Swap_NotEnoughLiquidity();\\n\\n    /// @notice Thrown when swapper receives less than the minimum amount of tokens expected\\n    error LighterV2Swap_NotEnoughOutput();\\n\\n    /// @notice Thrown when swapper needs to pay more than the maximum amount of tokens they are willing to pay\\n    error LighterV2Swap_TooMuchRequested();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-V2-VAULT\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when caller tries to withdraw more than their balance or withdraw zero\\n    error LighterV2Vault_InvalidClaimAmount();\\n\\n    /// @notice Thrown when caller does not tranfer enough tokens to the vault when depositing\\n    error LighterV2Vault_InsufficentCallbackTransfer();\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-V2-FLASH-LOAN\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when caller does not tranfer enough tokens to repay for the flash loan\\n    error LighterV2FlashLoan_InsufficentCallbackTransfer();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-V2-TOKEN-TRANSFER\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when token transfer from order book fails\\n    error LighterV2TokenTransfer_Failed();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LinkedList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport \\\"./Errors.sol\\\";\\nimport \\\"../interfaces/IOrderBook.sol\\\";\\n\\n/// @title LinkedList\\n/// @notice Struct to use for storing sorted linked lists of ask and bid orders\\nstruct LinkedList {\\n    mapping(uint32 => IOrderBook.LimitOrder) asks;\\n    mapping(uint32 => IOrderBook.LimitOrder) bids;\\n}\\n\\n/// @title LinkedListLib\\n/// @notice Implements a sorted linked list of limit orders and provides necessary functions for order management\\n/// @dev Head is represented by order id 0, tail is represented by order id 1\\nlibrary LinkedListLib {\\n    /// @notice Inserts an order into the respective linked list and keeps sorted order\\n    /// @param orderId id of the order to insert\\n    /// @param isAsk true if the order is an ask order, false if the order is a bid order\\n    /// @param hintId hint id of the order where the new order should be inserted to the right of\\n    function insert(LinkedList storage self, uint32 orderId, bool isAsk, uint32 hintId) internal {\\n        mapping(uint32 => IOrderBook.LimitOrder) storage orders = isAsk ? self.asks : self.bids;\\n        IOrderBook.LimitOrder storage order = orders[orderId];\\n\\n        if (orders[hintId].next == 0) {\\n            revert Errors.LighterV2Order_InvalidHintId();\\n        }\\n\\n        while (orders[hintId].ownerId == 0) {\\n            hintId = orders[hintId].next;\\n        }\\n\\n        // After the search, hintId will be where the new order should be inserted to the right of\\n        IOrderBook.LimitOrder memory hintOrder = orders[hintId];\\n        while (hintId != 1) {\\n            IOrderBook.LimitOrder memory nextOrder = orders[hintOrder.next];\\n            if (isAsk ? (order.priceBase < nextOrder.priceBase) : (order.priceBase > nextOrder.priceBase)) break;\\n            hintId = hintOrder.next;\\n            hintOrder = nextOrder;\\n        }\\n        while (hintId != 0) {\\n            if (isAsk ? (order.priceBase >= hintOrder.priceBase) : (order.priceBase <= hintOrder.priceBase)) break;\\n            hintId = hintOrder.prev;\\n            hintOrder = orders[hintId];\\n        }\\n\\n        order.prev = hintId;\\n        order.next = orders[hintId].next;\\n        orders[order.prev].next = orderId;\\n        orders[order.next].prev = orderId;\\n    }\\n\\n    /// @notice Removes given order id from the respective linked list\\n    /// @dev Updates the respective linked list but does not delete the order, sets the ownerId to 0 instead\\n    /// @param orderId The order id to remove\\n    /// @param isAsk true if the order is an ask order, false if the order is a bid order\\n    function erase(LinkedList storage self, uint32 orderId, bool isAsk) internal {\\n        if (orderId <= 1) {\\n            revert Errors.LighterV2Order_CannotEraseHeadOrTailOrders();\\n        }\\n\\n        mapping(uint32 => IOrderBook.LimitOrder) storage orders = isAsk ? self.asks : self.bids;\\n\\n        if (orders[orderId].ownerId == 0) {\\n            revert Errors.LighterV2Order_CannotCancelInactiveOrders();\\n        }\\n        IOrderBook.LimitOrder storage order = orders[orderId];\\n        order.ownerId = 0;\\n\\n        uint32 prev = order.prev;\\n        uint32 next = order.next;\\n        orders[prev].next = next;\\n        orders[next].prev = prev;\\n    }\\n\\n    /// @notice Returns a struct that represents order page with given parameters\\n    /// @param startOrderId The order id to start the pagination from (not inclusive)\\n    /// @param isAsk true if the paginated orders are ask orders, false if bid orders\\n    /// @param limit The number of orders to return\\n    /// @param ownerIdToAddress Mapping from owner id to owner address\\n    /// @param sizeTick The size tick of the order book\\n    /// @param priceTick The price tick of the order book\\n    function getPaginatedOrders(\\n        LinkedList storage self,\\n        uint32 startOrderId,\\n        bool isAsk,\\n        uint32 limit,\\n        mapping(uint32 => address) storage ownerIdToAddress,\\n        uint128 sizeTick,\\n        uint128 priceTick\\n    ) public view returns (IOrderBook.OrderQueryItem memory paginatedOrders) {\\n        mapping(uint32 => IOrderBook.LimitOrder) storage orders = isAsk ? self.asks : self.bids;\\n\\n        if (orders[startOrderId].ownerId == 0) {\\n            revert Errors.LighterV2Order_CannotQueryFromInactiveOrder();\\n        }\\n        uint32 i = 0;\\n        paginatedOrders.ids = new uint32[](limit);\\n        paginatedOrders.owners = new address[](limit);\\n        paginatedOrders.amount0s = new uint256[](limit);\\n        paginatedOrders.prices = new uint256[](limit);\\n        for (uint32 pointer = orders[startOrderId].next; pointer != 1 && i < limit; pointer = orders[pointer].next) {\\n            IOrderBook.LimitOrder memory order = orders[pointer];\\n            paginatedOrders.ids[i] = pointer;\\n            paginatedOrders.owners[i] = ownerIdToAddress[order.ownerId];\\n            paginatedOrders.amount0s[i] = uint256(order.amount0Base) * sizeTick;\\n            paginatedOrders.prices[i] = order.priceBase * priceTick;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        paginatedOrders.isAsk = isAsk;\\n    }\\n\\n    /// @notice Finds the order id where the order with given price should be inserted to the right of\\n    /// @param priceBase The priceBase to suggest the hintId for\\n    /// @return hintId The order id where the order with given price should be inserted to the right of\\n    function suggestHintId(LinkedList storage self, uint64 priceBase, bool isAsk) public view returns (uint32) {\\n        mapping(uint32 => IOrderBook.LimitOrder) storage orders = isAsk ? self.asks : self.bids;\\n        uint32 hintOrderId = 0;\\n        IOrderBook.LimitOrder memory hintOrder = orders[hintOrderId];\\n        while (hintOrderId != 1) {\\n            IOrderBook.LimitOrder memory nextOrder = orders[hintOrder.next];\\n            if (isAsk ? (priceBase < nextOrder.priceBase) : (priceBase > nextOrder.priceBase)) break;\\n            hintOrderId = hintOrder.next;\\n            hintOrder = nextOrder;\\n        }\\n        return hintOrderId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 4150\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"LighterV2Order_CannotQueryFromInactiveOrder\",\"type\":\"error\"}]", "ContractName": "LinkedListLib", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "4150", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}