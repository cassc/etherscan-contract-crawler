{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.12;\r\n\r\nabstract contract Proxy {\r\n    function _delegate(address implementation) internal virtual {\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    function _implementation() internal view virtual returns (address);\r\n\r\n    function _fallback() internal virtual {\r\n        _beforeFallback();\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    fallback () external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    receive () external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    function _beforeFallback() internal virtual {\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract UpgradeableProxy is Proxy {\r\n    constructor(address _logic, bytes memory _data) public payable {\r\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(_logic);\r\n        if(_data.length > 0) {\r\n            Address.functionDelegateCall(_logic, _data);\r\n        }\r\n    }\r\n\r\n    event Upgraded(address indexed implementation);\r\n\r\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    function _implementation() internal view virtual override returns (address impl) {\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    function _upgradeTo(address newImplementation) internal virtual {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    function _setImplementation(address newImplementation) private {\r\n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\r\n\r\n        bytes32 slot = _IMPLEMENTATION_SLOT;\r\n\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n\r\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\r\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\r\n        _setAdmin(admin_);\r\n    }\r\n\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _admin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    function admin() external ifAdmin returns (address admin_) {\r\n        admin_ = _admin();\r\n    }\r\n\r\n    function implementation() external ifAdmin returns (address implementation_) {\r\n        implementation_ = _implementation();\r\n    }\r\n\r\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\r\n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");\r\n        emit AdminChanged(_admin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n        Address.functionDelegateCall(newImplementation, data);\r\n    }\r\n\r\n    function _admin() internal view virtual returns (address adm) {\r\n        bytes32 slot = _ADMIN_SLOT;\r\n        assembly {\r\n            adm := sload(slot)\r\n        }\r\n    }\r\n\r\n    function _setAdmin(address newAdmin) private {\r\n        bytes32 slot = _ADMIN_SLOT;\r\n\r\n        assembly {\r\n            sstore(slot, newAdmin)\r\n        }\r\n    }\r\n\r\n    function _beforeFallback() internal virtual override {\r\n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\r\n        super._beforeFallback();\r\n    }\r\n}\r\n\r\ncontract Minter is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) public TransparentUpgradeableProxy(_logic, admin_, _data){ }\r\n\r\n    function getAdmin() public view returns (address) {\r\n        return _admin();\r\n    }\r\n    \r\n    function getImplementation() public view returns (address) {\r\n        return _implementation();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Minter", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000e5438a397a3dbb7818b8e8f746de9b5daa4aa7c0000000000000000000000008d5dceab358979101dc96a62e08296269f6bd1bd00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x9815832e44126e4a145139bed909d6e8093880c0", "SwarmSource": "ipfs://7666a5bb63b432b4b44e38f1f2717043c30d6c6715537e38854f3aec5804e1cc"}