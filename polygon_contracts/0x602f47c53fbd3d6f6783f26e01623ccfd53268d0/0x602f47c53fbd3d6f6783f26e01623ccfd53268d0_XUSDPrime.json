{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"main-contract/main-contract/XUSDPrime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ASWF-Digital-Assets-1.1\\n/// @title XUSD\u2122 Prime 2.0.10 Smart Contract\\n/// @author This contract has been developed by Unified Global Intelligence Corporation\u2122 on behalf of XUSD Blockchain\u2122 Holdings, LLC ~ Dr. Brian K. Fontenot II ~ bf@ugic.co\\n/// @notice This contract represents the XUSD Prime\u2122 2.0 token with additional functionalities like pausing, minting, price checks, blacklisting, and much more.\\n///         The contract is designed to derive it's value from a physical asset pool that is managed by ICTS Trust ATOA\u2122 - A Sovereign International Trust \\n///         fully registered with the International Court of Justice at the Hague, Netherlands.\\n/// @dev Explain to a developer any extra details\\n/// @param Copyright \u00a9 2019-2023 \u2022 Unified Global Intelligence Corporation\u2122 \u2022 All right reserved.\\n/// @param Patent This contract has full patent protection in the United States of America as well as abroad. Please visit http://www.xusdcrypto.com for more information.\\n\\npragma solidity ^0.8.19;\\n\\n// \u2500\u2500\u2500 Related Library Imports \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\nimport { BlacklistLib } from \\\"./contracts/libraries/BlacklistLib.sol\\\";\\nimport { WhitelistLib } from \\\"./contracts/libraries/WhitelistLib.sol\\\";\\nimport { KnownExchangesLib } from \\\"./contracts/libraries/KnownExchangesLib.sol\\\";\\nimport { BMPViolatorsLib } from \\\"./contracts/libraries/BMPViolatorsLib.sol\\\";\\nimport { HPRPListLib } from \\\"./contracts/libraries/HPRPListLib.sol\\\";\\n// \u2500\u2500\u2500 Related Template Imports \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\nimport \\\"./contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./contracts/access/Ownable.sol\\\";\\nimport \\\"./contracts/security/Pausable.sol\\\";\\nimport \\\"./contracts/chainlink/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"./contracts/token-recover/TokenRecover.sol\\\";\\nimport \\\"./contracts/security/ReentrancyGuard.sol\\\";\\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\ncontract XUSDPrime is ERC20, Ownable, Pausable, TokenRecover, ReentrancyGuard {\\n    // \u2500\u2500\u2500 State Variables \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    uint256 private maxAddresses = 10;  // State variable to store the maximum number of addresses\\n    mapping(string => Asset) public assets; // This mapping tracks the assets\\n    mapping(address => bool) public assetHolders; // This mapping tracks asset holders    \\n    uint256 private _currentPoolValue; // Current value of the pool in dollars\\n    uint256 public baseMinimumPrice; // Base minimum price for token transfer checks\\n    mapping(address => bool) private _excludedFromPriceCheck; // Addresses excluded from price checks\\n    using BlacklistLib for BlacklistLib.List; // Blacklist Functionality - Mapping\\n    BlacklistLib.List private blacklist; // Blacklist Functionality - Mapping\\n    using WhitelistLib for WhitelistLib.List; // Whitelist Functionality - Usage\\n    WhitelistLib.List private whitelist; // Whitelist Functionality - Mapping\\n    bool public whitelistEnabled = false; // Whitelisting is set to false by default\\n    using KnownExchangesLib for KnownExchangesLib.List; //Known Exchange Functionality - Usage\\n    KnownExchangesLib.List private knownExchanges; // Known Exchange Functionality - Mapping\\n    using BMPViolatorsLib for BMPViolatorsLib.List; // BMP Violators List Functionality - Usage\\n    BMPViolatorsLib.List private bmpViolators; // BMP Violators List Functionality - Mapping\\n    uint256 private _violatorPenaltyPercentage; // BMP Violator Penalty in percentage (0 to 100)\\n    using HPRPListLib for HPRPListLib.List; //\\n    HPRPListLib.List private hprpList; // List to store registered HPRP addresses\\n    uint256 public feePercentage = 3; // Fee percentage levied on all transactions\\n    uint256 public hprpPool; // State variable to store accumulated fees for HPRP\\n    address public selectedWinnerAddress; // HPRP selected winner address\\n    LastHPRPReward public lastHPRPReward; // Store the details of the last HPRP reward\\n    uint256 public lastRewardBlockNumber; // Last Reward Block Detail State\\n    uint256 public lastRewardTime; // Last Reward Time Detail State\\n    uint256 public lastRewardAmount; // Last Reward Amount Detail State\\n    address public lastWinnerAddress; // Last Reward Winner Detail State\\n    mapping(address => uint256) public lastTransactionTime; // Mapping from user's address to the timestamp of the user's last transaction\\n    uint256 public constant TIME_LOCK_PERIOD = 60; // Define a time lock period (in seconds). Set to 1 minute\\n    bool public manualPoolValueEnabled = true; // Flag to enable manual pool value setting\\n    bool public chainlinkEnabled = false; // Flag to enable Chainlink for pool value\\n    AggregatorV3Interface internal priceFeed; // Chainlink price feed for external data\\n    uint256 public previousBaseMinimumPrice; // Previous values for base minimum price\\n    uint256 public previousPoolValue; // Previous values for pool value\\n    uint256 public previousMarketPrice; // Previous market price\\n    uint256 public currentMarketPrice; // Current market price\\n    SecurityAudit public latestSecurityAudit; // Latest security audit details\\n    bool private _locked = false; // State Variable for Reentrancy Guard system\\n\\n// \u2500\u2500\u2500 Physical Asset Struct And Mappings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    struct Asset {\\n        string assetType;\\n        uint256 assetValue;\\n        address assetHolderAddr;\\n        string UCCState;\\n        string UCCNumber;\\n        uint256 UCCDate;\\n        bool exists;\\n    }\\n// \u2500\u2500\u2500 Struct To Store Details Of The Latest Security Audit \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    struct SecurityAudit {\\n        bool status; // true for pass, false for fail\\n        uint256 blockNumber;\\n        uint256 timestamp;\\n    }\\n// \u2500\u2500\u2500 Struct To Store Details Of The Last Hprp Reward \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    struct LastHPRPReward {\\n        uint256 blockNumber;\\n        uint256 timestamp;\\n        string winnerName;\\n        address winnerAddress;\\n        uint256 rewardAmount;\\n    }\\n// \u2500\u2500\u2500 Text Strings For Various Event Emits \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    string public marketCloseText = \\\"This ENDS the Official Trading Day.\\\";\\n    string public marketOpenText = \\\"This BEGINS the Official Trading Day. BMP Updated.\\\";\\n    string public marketCloseAuditText = \\\"This ENDS the Official Trading Day. SEC Audit Point.\\\";\\n    string public marketOpenAuditText = \\\"This BEGINS the Official Trading Day. SEC Audit Done.\\\";\\n    string public priceBelowMinErrorMessage = \\\"Price below Base Minimum Price established by Asset Pool.\\\";\\n    string public whitelistAddedText = \\\"Address added to whitelist.\\\";\\n    string public whitelistRemovedText = \\\"Address removed from whitelist.\\\";\\n    string public HPRPwinnerName;\\n    string public violatorAddedText = \\\"Address added to BMP Violator list.\\\";\\n    string public penaltyChangedText = \\\"BMP Violator penalty changed.\\\";\\n    string public penaltyChargedText = \\\"Penalty charged Violator.\\\";\\n    string public blacklistErrorMessage = \\\"Blacklisted Address. Interaction not allowed.\\\";\\n    string public eTReventText = \\\"Emergency Token Recovery initiated.\\\";\\n    string public assetRegisteredText = \\\"New Asset added to active pool.\\\";\\n    string public assetRemovedText = \\\"Asset removed from active pool.\\\";\\n\\n// \u2500\u2500\u2500 Custom Error Statements \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    error AssetExists(string assetTransactionID);\\n    error AssetNotFound(string assetTransactionID);\\n    error ZeroAddressNotAllowed();\\n    error FunctionNotSupported();\\n    error ManualValueDisabled();\\n    error InvalidChainlink();\\n    error AddressAlreadySet();\\n    error ChainlinkAlreadyEnabled();\\n    error ManualValueAlreadyEnabled();\\n    error NoPoolMethodEnabled();\\n    error InvalidAddressCount();\\n    error NoAddressRegistered();\\n    error NoWinnerSelected();\\n    error InsufficientFunds(uint256 required, uint256 available);\\n    error InvalidPenaltyPercentage(uint256 providedPercentage);\\n    error NotWhitelisted(address from, address to);\\n    error TimeLockNotExpired(address sender);\\n    error AddressBlacklisted(address offender);\\n    error BMPViolatorDetected(address violator);\\n    error PriceBelowMinimum();\\n    error WhitelistDisabled();\\n    error InvalidMax(uint256 providedValue);\\n    error InvalidTokenAddress();\\n    error InvalidTokenAmount();\\n\\n// \u2500\u2500\u2500 Blockchain Event Calls \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    event AssetRegistered(string description, uint256 blockNum, uint256 blockTime, string assetTransactionID, string assetType, uint256 assetValue, string UCCState, string UCCNumber, uint256 UCCDate); // Called when a physical asset is registered to the active asset pool\\n    event AssetRemoved(string description, uint256 blockNum, uint256 blockTime, string assetTransactionID, string assetType, uint256 assetValue, string UCCState, string UCCNumber, uint256 UCCDate); // Called when a physical asset is removed from the active pool\\n    event PoolValueSet(uint256 newPoolValue); // Called when a new value is assigned to the pool\\n    event Burned(address indexed account, uint256 amount, string reason); // Called when we burn a transaction\\n    event XUSDPaused(); // Called when the contract is paused\\n    event XUSDUnpaused(); // Called when the contract is unpaused\\n    event ExchangeAdded(address indexed account); // Called when a KnownExchange is added\\n    event ExchangeRemoved(address indexed account); // Called when a KnownExchange is removed\\n    event ChainlinkUpdated(address newChainlinkAddress);  // Called when chainlink address is updated.\\n    event MarketClosure(uint256 time, string message); // Event handler for closing the market\\n    event MarketOpening(uint256 time, string message, uint256 previousBaseMinimumPrice, uint256 newBaseMinimumPrice, uint256 previousPoolValue, uint256 currentPoolValue, uint256 previousMarketPrice); // Event handler for opening the market\\n    event MarketClosedAudit(uint256 time, string message); // Market close with audit event\\n    event MarketOpenedAudit(uint256 time, string message, bool auditStatus, uint256 auditBlock, uint256 auditTimestamp, uint256 previousBaseMinimumPrice, uint256 newBaseMinimumPrice, uint256 previousPoolValue, uint256 currentPoolValue, uint256 previousMarketPrice); // Market Open with audit event\\n    event AuditRecorded(bool status, uint256 blockNumber, uint256 timestamp); // Secure audit Recorded event\\n    event WhitelistAdded(address indexed account, string message); // Called when an address is added to the whitelist\\n    event WhitelistRemoved(address indexed account, string message); // Called when an address is removed from the whitelist\\n    event HPRPWinnerSelected(address indexed winnerAddress, uint256 timestamp, uint256 blockNumber); // Called when HPRP winner is Selected\\n    event HPRPRewardIssued(uint256 blockNumber, uint256 timestamp, string winnerName, address winnerAddress, uint256 rewardAmount); // Called when a reward has been issued from the HPRP\\n    event AddressAddedToHPRPList(address indexed account); // Called when an address is added to HPRP list\\n    event AddressRemovedFromHPRPList(address indexed account); // Called when an address is removed from HPRP list\\n    event ViolatorAdded(address indexed violator, string message); // Called when a violator is added to the list of BMP violators\\n    event PenaltySet(uint256 newPenalty, string message); // Called when the BMP Violator penalty percentage is set\\n    event PenaltyCharged(address indexed violator, uint256 penaltyAmount, string message); // Called when a BMP Violator penalty is charged\\n    event BlacklistAdded(address indexed account); // Called when an address is added to the blacklist\\n    event BlacklistRemoved(address indexed account); // Called when an address is removed from the blacklist\\n    event TransferRefusedDueToPrice(address indexed from, address indexed to, uint256 amount, string reason); // Called when a transfer refused due to being below the BMP\\n    event EmergencyTokenRecovery(string eTReventText, address account, uint256 timestamp, uint256 blockNum, string reason); // This is called when we receive Emergency Token Recovery events\\n    \\n// \u2500\u2500\u2500 Function Modifiers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    modifier onlyWhenWhitelistEnabled() {\\n    if (!whitelistEnabled) {revert WhitelistDisabled();}\\n    _;\\n    }\\n\\n// \u2500\u2500\u2500 Constructor \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    constructor(\\n    string memory tokenName,\\n    string memory tokenSymbol,\\n    uint256 baseMinPriceUSD,\\n    uint256 initialSupply\\n    )\\nERC20(tokenName, tokenSymbol)\\n    {   \\n    manualPoolValueEnabled = true;\\n    WhitelistLib.initializeWithOwner(whitelist, owner()); // Add initialization of Whitelist and cache with owner\\n    BlacklistLib.initialize(blacklist); // Add initialization of Blicklist and cache\\n    BMPViolatorsLib.initialize(bmpViolators); // Add initialization of BMPViolatorsList and cache\\n    HPRPListLib.initialize(hprpList); // Add initialization of HPRPList and cache\\n    KnownExchangesLib.initialize(knownExchanges); // Add initialization of knownExchanges and cache\\n    baseMinimumPrice = baseMinPriceUSD;\\n    _mint(msg.sender, initialSupply * 10 ** decimals());\\n    }\\n\\n// \u2500\u2500\u2500 Available Functions \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n    // This function is executed on a call to the contract if none of the other functions match the given function signature, or if no data is supplied.\\n    fallback() external {revert FunctionNotSupported();} // React to unexpected calls. This function is non-payable, so it won't accept Ether.\\n    // Function to set the maximum number of addresses (only callable by the owner)\\n    function setMaxAddresses(uint256 _maxAddresses) external nonReentrant onlyOwner {\\n        if (_maxAddresses <= 0) {revert InvalidMax(_maxAddresses);}\\n        maxAddresses = _maxAddresses;\\n    }\\n    // Function to get the current maximum number of addresses\\n    function getMaxAddresses() external view returns (uint256) {\\n        return maxAddresses;\\n    }\\n    // Physical Asset Registration Function\\n    function addAsset(string memory assetTransactionID, address assetHolderAddr, uint256 assetValue, string memory _assetType, string memory _UCCState, string memory _UCCNumber, uint256 _UCCDate) external nonReentrant onlyOwner {\\n        if (assetHolderAddr == address(0)) {revert ZeroAddressNotAllowed();}\\n        if (assets[assetTransactionID].exists) {revert AssetExists(assetTransactionID);}\\n            assets[assetTransactionID] = Asset({assetType: _assetType, assetValue: assetValue, assetHolderAddr: assetHolderAddr, UCCState: _UCCState, UCCNumber: _UCCNumber, UCCDate: _UCCDate, exists: true});\\n            assetHolders[assetHolderAddr] = true;\\n        emit AssetRegistered(assetRegisteredText, block.number, block.timestamp, assetTransactionID, _assetType, assetValue, _UCCState, _UCCNumber, _UCCDate);\\n    }\\n    // Physical Asset Removal Function\\n    function removeAsset(string memory assetTransactionID) external nonReentrant onlyOwner {\\n        if (assets[assetTransactionID].assetHolderAddr == address(0)) {revert AssetNotFound(assetTransactionID);}\\n        // Directly reference the asset's properties from storage\\n        address holderAddr = assets[assetTransactionID].assetHolderAddr;\\n        string memory assetType = assets[assetTransactionID].assetType;\\n        uint256 assetValue = assets[assetTransactionID].assetValue;\\n        string memory UCCState = assets[assetTransactionID].UCCState;\\n        string memory UCCNumber = assets[assetTransactionID].UCCNumber;\\n        uint256 UCCDate = assets[assetTransactionID].UCCDate;\\n    assetHolders[holderAddr] = false;\\n    delete assets[assetTransactionID];\\n    emit AssetRemoved(assetRemovedText, block.number, block.timestamp, assetTransactionID, assetType, assetValue, UCCState, UCCNumber, UCCDate);\\n    }\\n    // Check if an address is an asset holder\\n    function isAssetHolder(mapping(address => bool) storage _assetHolders, address holder) internal view returns (bool) {\\n        return _assetHolders[holder];\\n    }\\n    // Set the current asset pool value\\n    function setCurrentPoolValue(uint256 newPoolValue) public onlyOwner whenPaused {\\n        if (!manualPoolValueEnabled) {revert ManualValueDisabled();}\\n        _currentPoolValue = newPoolValue;\\n        emit PoolValueSet(newPoolValue);\\n    }\\n    // Get the current asset pool value\\n    function getCurrentPoolValue() public view returns (uint256) {\\n        return _currentPoolValue;\\n    }\\n    // Set the base minimum price or BMP\\n    function setBMP(uint256 newBaseMinimumPrice) public onlyOwner whenPaused {\\n        baseMinimumPrice = newBaseMinimumPrice;\\n    }\\n    // Exclude an address from the base minimum price check\\n    function excludeFromPriceCheck(address account) public onlyOwner {\\n        _excludedFromPriceCheck[account] = true;\\n    }\\n    // Include an address in the base minimum price check\\n    function includeInPriceCheck(address account) public onlyOwner {\\n        _excludedFromPriceCheck[account] = false;\\n    }\\n    // Check if an address is excluded from the base minimum price check\\n    function isExcludedFromPriceCheck(address account) public view returns (bool) {\\n        return _excludedFromPriceCheck[account];\\n    }\\n    // Pause the contract\\n    function pause() public onlyOwner {\\n        _pause();\\n        emit XUSDPaused();\\n    }\\n    // Unpause the contract\\n    function unpause() public onlyOwner {\\n        _unpause();\\n        emit XUSDUnpaused();\\n    }\\n    // Get the Pause Status of the Contract\\n    function isPaused() public view returns (bool) {\\n        return paused();\\n    }\\n    // Mint new tokens\\n    function mint(address to, uint256 amount) public onlyOwner() {\\n        _mint(to, amount);\\n    }\\n    // Set or Update the Chainlink address for the current available pool value\\n    function UpdateChainlinkAddress(address newChainlinkAddress) public onlyOwner whenPaused {\\n        if (newChainlinkAddress == address(0)) {revert InvalidChainlink();}\\n        if (chainlinkEnabled && priceFeed == AggregatorV3Interface(newChainlinkAddress)) {revert AddressAlreadySet();}\\n        priceFeed = AggregatorV3Interface(newChainlinkAddress);\\n        emit ChainlinkUpdated(newChainlinkAddress);\\n    }\\n    // Get the current Chainlink Address\\n    function getChainlinkAddress() public view returns (address) {\\n        return address(priceFeed);\\n    }\\n    // Enable manual value input of the current available pool value\\n    function enableManualPoolValue() public onlyOwner whenPaused {\\n        if (chainlinkEnabled) {revert ChainlinkAlreadyEnabled();}\\n        manualPoolValueEnabled = true;\\n        chainlinkEnabled = false; // Ensure Chainlink is disabled when manual setting is enabled\\n    }\\n        function disableManualPoolValue() public onlyOwner whenPaused { // Disable manual pool value current available pool\\n        manualPoolValueEnabled = false;\\n    }\\n    function enableChainlink() public onlyOwner whenPaused { // Enable Chainlink address for the input of the current available pool value\\n        if (manualPoolValueEnabled) {revert ManualValueAlreadyEnabled();}\\n        chainlinkEnabled = true;\\n        manualPoolValueEnabled = false; // Ensure manual setting is disabled when Chainlink is enabled\\n    }\\n    // Disable Chainlink address for the input of the current available pool value\\n    function disableChainlink() public onlyOwner whenPaused {\\n        chainlinkEnabled = false;\\n    }\\n    // Get the latest current available pool value\\n    function getLatestPoolValue() public view returns (int) {\\n        if (!(manualPoolValueEnabled || chainlinkEnabled)) {revert NoPoolMethodEnabled();}\\n        if (chainlinkEnabled) {(,int price,,,) = priceFeed.latestRoundData();\\n        return price;} \\n        else {return int(_currentPoolValue);}\\n    } //@todo Halfway Point\\n    // Initialize the KE Cache\\n    function populateKnownExchanges(address[] memory addresses) external nonReentrant onlyOwner{\\n        KnownExchangesLib.initializeAfterDeployment(knownExchanges, addresses);\\n    }\\n    // Add a single known exchange address\\n    function addKnownExchange(address account) external nonReentrant onlyOwner {\\n        KnownExchangesLib.add(knownExchanges, account, owner());\\n        emit ExchangeAdded(account);\\n    }\\n    // Add multiple known exchanges\\n    function addMultipleKnownExchanges(address[] memory accounts) external nonReentrant onlyOwner{\\n        for(uint i = 0; i < accounts.length; i++) {\\n        KnownExchangesLib.add(knownExchanges, accounts[i]);\\n        emit ExchangeAdded(accounts[i]);\\n        }\\n    }\\n    // Remove a single known exchange address\\n    function removeKnownExchange(address account) external nonReentrant onlyOwner {\\n        KnownExchangesLib.remove(knownExchanges, account);\\n        emit ExchangeRemoved(account);\\n    }\\n    // Remove multiple known exchanges\\n    function removeMultipleKnownExchanges(address[] memory accounts) external nonReentrant onlyOwner {\\n        for(uint i = 0; i < accounts.length; i++) {\\n        KnownExchangesLib.remove(knownExchanges, accounts[i]);\\n        emit ExchangeRemoved(accounts[i]);\\n        }\\n    }\\n    // Check if an address is on the known exchange list\\n    function isKnownExchange(address account) public view returns (bool) {\\n        return KnownExchangesLib.contains(knownExchanges, account);\\n    }\\n    // Function to set the previous market price\\n    function setPreviousMarketPrice(uint256 price) external onlyOwner {\\n        previousMarketPrice = price;\\n    }\\n    // Function to set the current market price\\n    function setCurrentMarketPrice(uint256 price) external onlyOwner {\\n        currentMarketPrice = price;\\n    }\\n    // Record the security audit\\n    function recordSECAudit(bool auditStatus) public onlyOwner {\\n        latestSecurityAudit = SecurityAudit({\\n            status: auditStatus,\\n            blockNumber: block.number,\\n            timestamp: block.timestamp\\n        });\\n        emit AuditRecorded(auditStatus, block.number, block.timestamp);\\n    }\\n    // Function for the public to call the results of the latest security audit\\n    function getLatestSecurityAudit() public view returns (bool auditStatus, uint256 blockNum, uint256 time) {\\n        auditStatus = latestSecurityAudit.status;\\n        blockNum = latestSecurityAudit.blockNumber;\\n        time = latestSecurityAudit.timestamp;\\n        return (auditStatus, blockNum, time);\\n    }\\n    // Function to mark the market close and pause the contract\\n    function MarketClosed() public onlyOwner {\\n        _pause();\\n        previousBaseMinimumPrice = baseMinimumPrice;\\n        previousPoolValue = _currentPoolValue;\\n        emit MarketClosure(block.timestamp, marketCloseText);\\n        emit XUSDPaused();\\n    }\\n    // Function to update the marketCloseAuditText\\n    function setMarketCloseAuditText(string memory newText) public onlyOwner {\\n        marketCloseAuditText = newText;\\n    }\\n    // Function to mark the market close and pause the contract while performing a security audit\\n    function MarketCloseAudit() public onlyOwner {\\n        _pause();\\n        previousBaseMinimumPrice = baseMinimumPrice;\\n        previousPoolValue = _currentPoolValue;\\n        emit MarketClosedAudit(block.timestamp, marketCloseAuditText);\\n    }\\n    // Function to update the marketOpenAuditText\\n    function setMarketOpenAuditText(string memory newText) public onlyOwner {\\n        marketOpenAuditText = newText;\\n    }\\n    // Function to mark the market open and unpause the contract\\n    function MarketOpen() public onlyOwner {\\n        _unpause();\\n        emit MarketOpening(block.timestamp, marketOpenText, previousBaseMinimumPrice, baseMinimumPrice, previousPoolValue, _currentPoolValue, previousMarketPrice);\\n        emit XUSDUnpaused();\\n    }\\n    // Function to mark the market open and unpause the contract after a security audit was performed\\n    function MarketOpenAudit(bool auditStatus) public onlyOwner {\\n        recordSECAudit(auditStatus); //Using the auditStatus parameter\\n        _unpause();\\n        emit MarketOpenedAudit(block.timestamp, marketOpenAuditText, latestSecurityAudit.status, latestSecurityAudit.blockNumber, latestSecurityAudit.timestamp, previousBaseMinimumPrice, baseMinimumPrice, previousPoolValue, _currentPoolValue, previousMarketPrice);\\n    }\\n    // Function to update the market close text\\n    function setMarketCloseText(string memory newText) public onlyOwner {\\n        marketCloseText = newText;\\n    }\\n    // Function to update the market open text\\n    function setMarketOpenText(string memory newText) public onlyOwner {\\n        marketOpenText = newText;\\n    }\\n    // Initialize the WhitelistLib\\n    function populateWhitelist(address[] memory addrs) external {\\n    }\\n    // Check if an address is whitelisted\\n    function isWhitelisted(address account) public view returns (bool) {\\n    return WhitelistLib.contains(whitelist, account);\\n    }\\n    // Enable whitelist functionality\\n    function enableWhitelist() public onlyOwner {\\n        whitelistEnabled = true;\\n    }\\n    // Disable whitelist functionality\\n    function disableWhitelist() public onlyOwner {\\n        whitelistEnabled = false;\\n    }\\n    // Add address to the whitelist\\n    function addToWhitelist(address account) external nonReentrant onlyOwner onlyWhenWhitelistEnabled {\\n        WhitelistLib.add(whitelist, account);\\n        emit WhitelistAdded(account, whitelistAddedText);\\n    }\\n    // Add multiple addresses to the whitelist\\n    function addMultipleToWhitelist(address[] memory accounts) external nonReentrant onlyOwner onlyWhenWhitelistEnabled {\\n    for(uint i = 0; i < accounts.length; i++) {\\n        WhitelistLib.add(whitelist, accounts[i]);\\n        emit WhitelistAdded(accounts[i], whitelistAddedText);\\n        }\\n    }\\n    // Remove address from the whitelist\\n    function removeFromWhitelist(address account) external nonReentrant onlyOwner onlyWhenWhitelistEnabled {\\n        WhitelistLib.remove(whitelist, account);\\n        emit WhitelistRemoved(account, whitelistRemovedText);\\n    }\\n    // Remove multiple addresses from the whitelist\\n    function removeMultipleFromWhitelist(address[] memory accounts) external nonReentrant onlyOwner onlyWhenWhitelistEnabled {\\n    for(uint i = 0; i < accounts.length; i++) {\\n        WhitelistLib.remove(whitelist, accounts[i]);\\n        emit WhitelistRemoved(accounts[i], whitelistRemovedText);\\n        }\\n    }\\n    // Set the text for the WhitelistedAddressAdded event\\n    function setWhitelistedAddressAddedText(string memory newText) public onlyOwner {\\n        whitelistAddedText = newText;\\n    }\\n    // Set the text for the WhitelistedAddressRemoved event\\n    function setWhitelistedAddressRemovedText(string memory newText) public onlyOwner {\\n        whitelistRemovedText = newText;\\n    }\\n    // Initialize the WhitelistLib\\n    function populateHPRPList(address[] memory accounts) external {\\n        HPRPListLib.initializeAfterDeployment(hprpList, accounts);\\n    }\\n    // Function to add single addresses to the registeredHPRPList\\n    function addToHPRPList(address[] memory accounts) external nonReentrant onlyOwner {\\n    for(uint i = 0; i < accounts.length; i++) {\\n        HPRPListLib.add(hprpList, accounts[i]);\\n        emit AddressAddedToHPRPList(accounts[i]);\\n        }\\n    }\\n    // Function to remove single addresses from the registeredHPRPList\\n    function removeFromHPRPList(address[] memory accounts) external nonReentrant onlyOwner {\\n    for (uint256 i = 0; i < accounts.length; i++) {\\n        HPRPListLib.remove(hprpList, accounts[i]);\\n        emit AddressRemovedFromHPRPList(accounts[i]);\\n        }\\n    }\\n    // Function to randomly select an HPRP winner from the registeredHPRPList\\n    function selectHPRPWinner() external nonReentrant onlyOwner {\\n            address[] memory registeredAddresses = HPRPListLib.getAll(hprpList); // Get a list of all registered addresses\\n        if (registeredAddresses.length == 0) {revert NoAddressRegistered();}\\n            bytes32 hashOfLastBlock = blockhash(block.number - 1); // Generate a pseudo-random number using the current and previous block hashes\\n            bytes32 hashOfCurrentBlock = blockhash(block.number);\\n            uint256 randomIndex = uint256(keccak256(abi.encodePacked(hashOfLastBlock, hashOfCurrentBlock))) % registeredAddresses.length;\\n            address winner = registeredAddresses[randomIndex]; // Get the winner's address from the list\\n        if (winner == address(0)) {revert NoWinnerSelected();}\\n            selectedWinnerAddress = winner;\\n            emit HPRPWinnerSelected(winner, block.timestamp, block.number);\\n    }\\n    // Helper function to get all registered addresses\\n    function getRegisteredAddresses() internal view returns (address[] memory) {\\n        return HPRPListLib.getAll(hprpList);\\n    }\\n    // Function to set the name of the HPRP winner\\n    function setHPRPwinnerName(string memory winnerName) external nonReentrant onlyOwner {\\n        HPRPwinnerName = winnerName;\\n    }\\n    // Function to issue HPRP reward to selected winner\\n    function issueHPRPReward() external onlyOwner nonReentrant {\\n        if (selectedWinnerAddress == address(0)) {revert NoWinnerSelected();}\\n            uint256 rewardAmount = hprpPool; // Use the accumulated HPRP fees from hprpPool\\n        if (rewardAmount > address(this).balance) {revert InsufficientFunds(rewardAmount, address(this).balance);}\\n        _transfer(owner(), selectedWinnerAddress, rewardAmount); // Transfer the reward from the owner's address to the selected winner\\n        lastHPRPReward = LastHPRPReward({blockNumber: block.number, timestamp: block.timestamp, winnerName: HPRPwinnerName, winnerAddress: selectedWinnerAddress, rewardAmount: rewardAmount}); // Store the details of the last HPRP reward\\n        emit HPRPRewardIssued(block.number, block.timestamp, HPRPwinnerName, selectedWinnerAddress, rewardAmount); // Emit the HPRPRewardIssued event  \\n        selectedWinnerAddress = address(0); // Reset the selectedWinnerAddress and hprpPool for the next reward\\n        hprpPool = 0; // Reset the accumulated fees\\n    }\\n    // Function for the public to call the details of the last HPRP reward\\n    function getLastHPRPReward() external view returns (uint256 blockNumber, uint256 timestamp, string memory winnerName, address winnerAddress, uint256 rewardAmount) {\\n        return (lastHPRPReward.blockNumber, lastHPRPReward.timestamp, lastHPRPReward.winnerName, lastHPRPReward.winnerAddress, lastHPRPReward.rewardAmount);\\n    }\\n    // Initialize the BMP Violators List\\n    function populateBMPViolators(address[] memory accounts) external {\\n        BMPViolatorsLib.initializeAfterDeployment(bmpViolators, accounts);\\n    }\\n    // Function to set the BMP Violator Added Text Message\\n    function setViolatorAddedText(string memory newText) public onlyOwner {\\n        violatorAddedText = newText;\\n    }\\n    // Function to set the BMP Violator Penalty Changed Text Message\\n    function setPenaltyChangedText(string memory newText) public onlyOwner {\\n        penaltyChangedText = newText;\\n    }\\n    // Function to set the BMP Violator Charged Text Message\\n    function setPenaltyChargedText(string memory newText) public onlyOwner {\\n        penaltyChargedText = newText;\\n    }\\n    // Add a single BMP Violator from the list\\n    function addBMPViolator(address account) external nonReentrant onlyOwner {\\n        BMPViolatorsLib.add(bmpViolators, account);\\n        emit ViolatorAdded(account, violatorAddedText);\\n    }\\n    // Remove single BMP Violator from the list\\n    function removeBMPViolator(address account) external nonReentrant onlyOwner {\\n        BMPViolatorsLib.remove(bmpViolators, account);\\n    }\\n    // Add multiple BMP Violators\\n    function addMultipleBMPViolators(address[] memory accounts) external nonReentrant onlyOwner {\\n        for(uint i = 0; i < accounts.length; i++) {\\n        BMPViolatorsLib.add(bmpViolators, accounts[i]);\\n        emit ViolatorAdded(accounts[i], violatorAddedText); \\n        }\\n    }\\n    // Remove multiple BMP Violators\\n    function removeMultipleBMPViolators(address[] memory accounts) external nonReentrant onlyOwner {\\n        for(uint i = 0; i < accounts.length; i++) {\\n        BMPViolatorsLib.remove(bmpViolators, accounts[i]);\\n        }\\n    }\\n    // Check if an address is a BMP Violator\\n    function isBMPViolator(address account) public view returns (bool) {\\n        return BMPViolatorsLib.contains(bmpViolators, account);\\n    }\\n    // Function to set the BMP Violator Penalty Fee Percentage\\n    function setViolatorPenaltyPercentage(uint256 penaltyPercentage) external nonReentrant onlyOwner {\\n        if (penaltyPercentage > 100) {revert InvalidPenaltyPercentage(penaltyPercentage);}\\n            _violatorPenaltyPercentage = penaltyPercentage;\\n            emit PenaltySet(_violatorPenaltyPercentage, penaltyChangedText);\\n    }\\n    // Function to get the BMP Violator Penalty Fee Percentage\\n    function getViolatorPenalty() external view returns (uint256) {\\n        return _violatorPenaltyPercentage;\\n    }\\n    // Initialize the BlacklistLib\\n    function populateBlacklist(address[] memory addrs) external {\\n    }\\n    // Add address to the blacklist\\n    function addToBlacklist(address account) external nonReentrant onlyOwner {\\n        BlacklistLib.add(blacklist, account, owner());\\n            emit BlacklistAdded(account);\\n    }\\n    // Add multiple addresses to the blacklist\\n    function addMultipleToBlacklist(address[] memory accounts) external nonReentrant onlyOwner {\\n\\t    for(uint i = 0; i < accounts.length; i++) {\\n\\t    BlacklistLib.add(blacklist, accounts[i]);\\n\\t    emit BlacklistAdded(accounts[i]);  // Emitting the event for each address\\n\\t    }\\n    }\\n    // Remove single address from the blacklist\\n    function removeFromBlacklist(address account) external nonReentrant onlyOwner {\\n            emit BlacklistRemoved(account);\\n        BlacklistLib.remove(blacklist, account);\\n    }\\n    // Remove multiple addresses from the blacklist\\n    function removeMultipleFromBlacklist(address[] memory accounts) external nonReentrant onlyOwner {\\n        for(uint i = 0; i < accounts.length; i++) {\\n        BlacklistLib.remove(blacklist, accounts[i]);\\n        emit BlacklistRemoved(accounts[i]); // Emitting the event for each address\\n        }\\n    }\\n    //Check if Blacklisted\\n    function isBlacklisted(address account) public view returns (bool) {\\n        return BlacklistLib.contains(blacklist, account);\\n    }\\n    // Change the error message for blacklisted addresses\\n    function setBlacklistedAddressErrorMessage(string memory newErrorMessage) public onlyOwner {\\n        blacklistErrorMessage = newErrorMessage;\\n    }\\n    // Function to recover tokens lost to scammers or sending errors\\n    function emergencyTokenRecover(address tokenAddress, uint256 tokenAmount, string memory reason) public nonReentrant onlyOwner {\\n        if (tokenAddress == address(0)) {revert InvalidTokenAddress();} // Check for valid token address\\n        if (tokenAmount == 0) {revert InvalidTokenAmount();} // Check for valid token amount\\n        recoverERC20(tokenAddress, tokenAmount); // Call recoverERC20 from TokenRecover\\n        _burn(owner(), tokenAmount, reason); // Burn the recovered tokens\\n        _mint(owner(), tokenAmount); // Re-mint the burned tokens\\n            emit EmergencyTokenRecovery(eTReventText, msg.sender, block.timestamp, block.number, reason); // Emit the special event\\n    }\\n    // Perform the price check before a token transfer - The owner address overrides these checks\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override (ERC20) whenNotPaused nonReentrant {\\n    super._beforeTokenTransfer(from, to, amount);\\n\\n    // If 'from' or 'to' address is the owner, or 'from' or 'to' is excluded from the price check, skip all other checks\\n    if (from == owner() || to == owner() || _excludedFromPriceCheck[from] || _excludedFromPriceCheck[to]) {\\n        return;\\n    }\\n\\n    // Whitelist Check\\n    if (whitelistEnabled && (!WhitelistLib.contains(whitelist, from) || !WhitelistLib.contains(whitelist, to))) {\\n        revert NotWhitelisted(from, to);\\n    }\\n\\n    // Time-Lock of 1 minute enacted to deter from arbitrage.\\n    if (block.timestamp < lastTransactionTime[from] + TIME_LOCK_PERIOD) {\\n        revert TimeLockNotExpired(from);\\n    }\\n\\n    // Ensure neither 'from' nor 'to' is blacklisted\\n    if (BlacklistLib.contains(blacklist, from) || BlacklistLib.contains(blacklist, to)) {\\n        revert AddressBlacklisted(from);\\n    }\\n\\n    // Check if either 'from' or 'to' address is in the BMP Violators list and charge the penalty\\n    if (BMPViolatorsLib.contains(bmpViolators, from) || BMPViolatorsLib.contains(bmpViolators, to)) {\\n        uint256 penalty = (amount * _violatorPenaltyPercentage) / 100; // Calculate penalty based on percentage\\n        _transfer(from, owner(), penalty); // Deduct the penalty from the sender and send to the owner\\n        hprpPool += penalty; // Increase the HPRP pool by the penalty amount\\n        emit PenaltyCharged(from, penalty, penaltyChargedText);\\n    }\\n\\n    // If the current market price is below the base minimum price, refuse the transfer\\n    if (currentMarketPrice < baseMinimumPrice) {\\n        emit TransferRefusedDueToPrice(from, to, amount, priceBelowMinErrorMessage);\\n        revert PriceBelowMinimum();\\n    }\\n\\n    bool isFromAssetHolder = assetHolders[from]; // Check if 'from' address is an asset holder\\n\\n    // Deduct fee for HPRP\\n    if (!isFromAssetHolder && !KnownExchangesLib.contains(knownExchanges, from) && !KnownExchangesLib.contains(knownExchanges, to)) {\\n        uint256 fee = (amount * feePercentage) / 100; // Calculate fee\\n        hprpPool += fee; // Add fee to HPRP pool\\n        amount -= fee; // Deduct fee from the transferred amount\\n    }\\n}\\n    // Function to burn tokens from an address with a reason\\n    function burn(uint256 amount, string memory reason) public virtual onlyOwner {\\n        _burn(msg.sender, amount, reason);\\n    }\\n    // Private function to burn tokens and emit a custom Burned event\\n    function _burn(address account, uint256 amount, string memory reason) private {\\n        super._burn(account, amount);\\n        emit Burned(account, amount, reason);\\n    }\\n}\"\r\n    },\r\n    \"main-contract/main-contract/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"main-contract/main-contract/contracts/token-recover/TokenRecover.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\nimport \\\"../access/Ownable.sol\\\";\\n\\n/**\\n * @title TokenRecover\\n * @dev Allows owner to recover any ERC20 sent into the contract\\n */\\ncontract TokenRecover is Ownable {\\n    /**\\n     * @dev Remember that only owner can call so be careful when use on contracts generated from other contracts.\\n     * @param tokenAddress The token contract address\\n     * @param tokenAmount Number of tokens to be sent\\n     */\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) public virtual onlyOwner {\\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"main-contract/main-contract/contracts/chainlink/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\"\r\n    },\r\n    \"main-contract/main-contract/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"main-contract/main-contract/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"main-contract/main-contract/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"main-contract/main-contract/contracts/libraries/HPRPListLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ASWF-Digital-Assets-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary HPRPListLib {\\n    struct List {\\n        mapping(address => bool) exists;\\n        address[] entries;\\n    }\\n    function initialize(List storage list) internal {\\n    }\\n    function initializeAfterDeployment(List storage list, address[] memory addrs) internal {\\n        for(uint i = 0; i < addrs.length; i++) {\\n        list.exists[addrs[i]] = true; \\n        list.entries.push(addrs[i]);\\n        }\\n    }\\n// \u2500\u2500\u2500 Error Handling \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n     error AccountAlreadyExists();\\n     error AccountNotFound();\\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n     function add(List storage list, address account) internal {\\n        if (list.exists[account]) {revert AccountAlreadyExists();}\\n        list.exists[account] = true;\\n        list.entries.push(account);\\n    }\\n    function remove(List storage list, address account) internal {\\n        if (!list.exists[account]) {revert AccountNotFound();}\\n        list.exists[account] = false;\\n        for (uint256 i = 0; i < list.entries.length; i++) { // Find the index of the account and remove it\\n            if (list.entries[i] == account) {\\n                list.entries[i] = list.entries[list.entries.length - 1];\\n                list.entries.pop();\\n                break;\\n            }\\n        }\\n    }\\n    function contains(List storage list, address account) internal view returns (bool) {\\n        return list.exists[account];\\n    }\\n    function getAll(List storage list) internal view returns (address[] memory) {\\n        return list.entries;\\n    }\\n}\"\r\n    },\r\n    \"main-contract/main-contract/contracts/libraries/BMPViolatorsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ASWF-Digital-Assets-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary BMPViolatorsLib {\\n    struct List {\\n        mapping(address => bool) data;\\n    }\\n    function initialize(List storage list) internal {\\n    }\\n    function initializeAfterDeployment(List storage list, address[] memory addrs) internal {\\n        for(uint i = 0; i < addrs.length; i++) {\\n        list.data[addrs[i]] = true;\\n        }\\n    }\\n    // \u2500\u2500\u2500 Error Handling \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    error BVLZeroAddressNotAllowed();\\n\\n    // \u2500\u2500\u2500 Helper Function \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    function _validateAddress(address account) private pure {\\n        if (account == address(0)) {revert BVLZeroAddressNotAllowed();}\\n    }\\n\\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    function add(List storage list, address account) internal {\\n        _validateAddress(account);\\n        list.data[account] = true;\\n    }\\n\\n    function remove(List storage list, address account) internal {\\n        _validateAddress(account);\\n        list.data[account] = false;\\n    }\\n\\n    function contains(List storage list, address account) internal view returns (bool) {\\n        return list.data[account];\\n    }\\n}\"\r\n    },\r\n    \"main-contract/main-contract/contracts/libraries/KnownExchangesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ASWF-Digital-Assets-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary KnownExchangesLib {\\n    struct List {\\n        mapping(address => bool) data;\\n    }\\n    function initialize(List storage list) internal {\\n    }\\n    function initializeAfterDeployment(List storage list, address[] memory addrs) internal {\\n        for(uint i = 0; i < addrs.length; i++) {\\n        list.data[addrs[i]] = true;\\n        }\\n    }\\n    // \u2500\u2500\u2500 Error Handling \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    error KELZeroAddressNotAllowed();\\n    error KELOwnerAddressNotAllowed();\\n\\n    // \u2500\u2500\u2500 Helper Function \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    function _validateAddress(address account, address owner) private pure {\\n        if (account == address(0)) {revert KELZeroAddressNotAllowed();}\\n        if (account == owner) {revert KELOwnerAddressNotAllowed();}\\n    }\\n\\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    function add(List storage list, address account, address owner) internal {\\n        _validateAddress(account, owner);\\n        list.data[account] = true;\\n    }\\n\\n    function add(List storage list, address account) internal {\\n        _validateAddress(account, address(0)); // Passing zero address for owner as it's not used in this context\\n        list.data[account] = true;\\n    }\\n\\n    function remove(List storage list, address account) internal {\\n        _validateAddress(account, address(0)); // Passing zero address for owner as it's not used in this context\\n        list.data[account] = false;\\n    }\\n\\n    function contains(List storage list, address account) internal view returns (bool) {\\n        return list.data[account];\\n    }\\n}\"\r\n    },\r\n    \"main-contract/main-contract/contracts/libraries/WhitelistLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ASWF-Digital-Assets-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary WhitelistLib {\\n    struct List {\\n        mapping(address => bool) data;\\n    }\\n    function initialize(List storage list) internal {\\n    }\\n    function initializeAfterDeployment(List storage list, address[] memory addrs) internal {\\n        for(uint i = 0; i < addrs.length; i++) {\\n        list.data[addrs[i]] = true;\\n        }\\n    }\\n    // \u2500\u2500\u2500 Error Handling \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    error WLLZeroAddressNotAllowed();\\n\\n    // \u2500\u2500\u2500 Helper Function \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    function _validateAddress(address account) private pure {\\n        if (account == address(0)) {revert WLLZeroAddressNotAllowed();}\\n    }\\n\\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    function initializeWithOwner(List storage list, address owner) internal {\\n        _validateAddress(owner);\\n        list.data[owner] = true;\\n    }\\n\\n    function add(List storage list, address account) internal {\\n        _validateAddress(account);\\n        list.data[account] = true;\\n    }\\n\\n    function remove(List storage list, address account) internal {\\n        _validateAddress(account);\\n        list.data[account] = false;\\n    }\\n\\n    function contains(List storage list, address account) internal view returns (bool) {\\n        return list.data[account];\\n    }\\n}\"\r\n    },\r\n    \"main-contract/main-contract/contracts/libraries/BlacklistLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ASWF-Digital-Assets-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary BlacklistLib {\\n    struct List {\\n        mapping(address => bool) data;\\n    }\\n    function initialize(List storage list) internal {\\n    }\\n    function initializeAfterDeployment(List storage list, address[] memory addrs) internal {\\n        for(uint i = 0; i < addrs.length; i++) {\\n        list.data[addrs[i]] = true;\\n        }\\n    }\\n    // \u2500\u2500\u2500 Error Handling \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    error BLLZeroAddressNotAllowed();\\n    error BLLOwnerAddressNotAllowed();\\n\\n    // \u2500\u2500\u2500 Helper Function \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    function _validateAddress(address account, address owner) private pure {\\n        if (account == address(0)) {revert BLLZeroAddressNotAllowed();}\\n        if (account == owner) {revert BLLOwnerAddressNotAllowed();}\\n    }\\n\\n    // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n    function add(List storage list, address account, address owner) internal {\\n        _validateAddress(account, owner);\\n        list.data[account] = true;\\n    }\\n\\n    function add(List storage list, address account) internal {\\n        if (account == address(0)) {revert BLLZeroAddressNotAllowed();}\\n        list.data[account] = true;\\n    }\\n\\n    function remove(List storage list, address account) internal {\\n        list.data[account] = false;\\n    }\\n\\n    function contains(List storage list, address account) internal view returns (bool) {\\n        return list.data[account];\\n    }\\n}\"\r\n    },\r\n    \"main-contract/main-contract/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"main-contract/main-contract/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"main-contract/main-contract/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 40\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"baseMinPriceUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccountAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AccountNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AddressAlreadySet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offender\",\"type\":\"address\"}],\"name\":\"AddressBlacklisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"assetTransactionID\",\"type\":\"string\"}],\"name\":\"AssetExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"assetTransactionID\",\"type\":\"string\"}],\"name\":\"AssetNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BLLOwnerAddressNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BLLZeroAddressNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"violator\",\"type\":\"address\"}],\"name\":\"BMPViolatorDetected\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BVLZeroAddressNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ChainlinkAlreadyEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FunctionNotSupported\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"InsufficientFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddressCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidChainlink\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"providedValue\",\"type\":\"uint256\"}],\"name\":\"InvalidMax\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"providedPercentage\",\"type\":\"uint256\"}],\"name\":\"InvalidPenaltyPercentage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KELOwnerAddressNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KELZeroAddressNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ManualValueAlreadyEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ManualValueDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAddressRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPoolMethodEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoWinnerSelected\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"NotWhitelisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceBelowMinimum\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"TimeLockNotExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WLLZeroAddressNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WhitelistDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressAddedToHPRPList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressRemovedFromHPRPList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetTransactionID\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"UCCState\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"UCCNumber\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"UCCDate\",\"type\":\"uint256\"}],\"name\":\"AssetRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetTransactionID\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"assetType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"UCCState\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"UCCNumber\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"UCCDate\",\"type\":\"uint256\"}],\"name\":\"AssetRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AuditRecorded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BlacklistAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BlacklistRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newChainlinkAddress\",\"type\":\"address\"}],\"name\":\"ChainlinkUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"eTReventText\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"EmergencyTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExchangeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExchangeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"winnerName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winnerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"HPRPRewardIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winnerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"HPRPWinnerSelected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"MarketClosedAudit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"MarketClosure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"auditStatus\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auditBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auditTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBaseMinimumPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBaseMinimumPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPoolValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentPoolValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousMarketPrice\",\"type\":\"uint256\"}],\"name\":\"MarketOpenedAudit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBaseMinimumPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBaseMinimumPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPoolValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentPoolValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousMarketPrice\",\"type\":\"uint256\"}],\"name\":\"MarketOpening\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"violator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"PenaltyCharged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"PenaltySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPoolValue\",\"type\":\"uint256\"}],\"name\":\"PoolValueSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"TransferRefusedDueToPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"violator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"ViolatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"WhitelistAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"WhitelistRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"XUSDPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"XUSDUnpaused\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"HPRPwinnerName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketCloseAudit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketClosed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"auditStatus\",\"type\":\"bool\"}],\"name\":\"MarketOpenAudit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_LOCK_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newChainlinkAddress\",\"type\":\"address\"}],\"name\":\"UpdateChainlinkAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"assetTransactionID\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"assetHolderAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetValue\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_assetType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_UCCState\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_UCCNumber\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_UCCDate\",\"type\":\"uint256\"}],\"name\":\"addAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addBMPViolator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addKnownExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addMultipleBMPViolators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addMultipleKnownExchanges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addMultipleToBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addMultipleToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addToBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addToHPRPList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetHolders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetRegisteredText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetRemovedText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"assetType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"assetValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetHolderAddr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"UCCState\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"UCCNumber\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"UCCDate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseMinimumPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blacklistErrorMessage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlinkEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMarketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableChainlink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableManualPoolValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eTReventText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"emergencyTokenRecover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableChainlink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableManualPoolValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromPriceCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPoolValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastHPRPReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"winnerName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"winnerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPoolValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestSecurityAudit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"auditStatus\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxAddresses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getViolatorPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hprpPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInPriceCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBMPViolator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromPriceCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isKnownExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issueHPRPReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastHPRPReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"winnerName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"winnerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastTransactionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWinnerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestSecurityAudit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualPoolValueEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketCloseAuditText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketCloseText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketOpenAuditText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketOpenText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyChangedText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyChargedText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"populateBMPViolators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"populateBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"populateHPRPList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"populateKnownExchanges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"populateWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousBaseMinimumPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousMarketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousPoolValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceBelowMinErrorMessage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"auditStatus\",\"type\":\"bool\"}],\"name\":\"recordSECAudit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"assetTransactionID\",\"type\":\"string\"}],\"name\":\"removeAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeBMPViolator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeFromBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeFromHPRPList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeKnownExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeMultipleBMPViolators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeMultipleFromBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeMultipleFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeMultipleKnownExchanges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selectHPRPWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selectedWinnerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBaseMinimumPrice\",\"type\":\"uint256\"}],\"name\":\"setBMP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newErrorMessage\",\"type\":\"string\"}],\"name\":\"setBlacklistedAddressErrorMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setCurrentMarketPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPoolValue\",\"type\":\"uint256\"}],\"name\":\"setCurrentPoolValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"winnerName\",\"type\":\"string\"}],\"name\":\"setHPRPwinnerName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newText\",\"type\":\"string\"}],\"name\":\"setMarketCloseAuditText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newText\",\"type\":\"string\"}],\"name\":\"setMarketCloseText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newText\",\"type\":\"string\"}],\"name\":\"setMarketOpenAuditText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newText\",\"type\":\"string\"}],\"name\":\"setMarketOpenText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxAddresses\",\"type\":\"uint256\"}],\"name\":\"setMaxAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newText\",\"type\":\"string\"}],\"name\":\"setPenaltyChangedText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newText\",\"type\":\"string\"}],\"name\":\"setPenaltyChargedText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPreviousMarketPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newText\",\"type\":\"string\"}],\"name\":\"setViolatorAddedText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"penaltyPercentage\",\"type\":\"uint256\"}],\"name\":\"setViolatorPenaltyPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newText\",\"type\":\"string\"}],\"name\":\"setWhitelistedAddressAddedText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newText\",\"type\":\"string\"}],\"name\":\"setWhitelistedAddressRemovedText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"violatorAddedText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistAddedText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistRemovedText\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "XUSDPrime", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "40", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000114400000000000000000000000000000000000000000000000000000000004c4b40000000000000000000000000000000000000000000000000000000000000000e58555344205072696d6520322e3000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000065855534450320000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}