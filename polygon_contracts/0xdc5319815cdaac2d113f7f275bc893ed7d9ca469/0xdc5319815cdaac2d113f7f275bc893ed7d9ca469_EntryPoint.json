{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/@eth-infinitism-v0.4/EntryPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// Modified version of a Implementation of contracts for ERC-4337 account abstraction via alternative mempool.\\n// Original code: https://github.com/eth-infinitism/account-abstraction/tree/releases/v0.4\\n\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n\\nimport \\\"../interfaces/IAccount.sol\\\";\\nimport \\\"../interfaces/IPaymaster.sol\\\";\\n\\nimport \\\"../interfaces/IAggregatedAccount.sol\\\";\\nimport \\\"../interfaces/IEntryPoint.sol\\\";\\nimport \\\"./StakeManager.sol\\\";\\nimport \\\"./SenderCreator.sol\\\";\\n\\ncontract EntryPoint is IEntryPoint, StakeManager {\\n    using UserOperationLib for UserOperation;\\n\\n    SenderCreator internal immutable senderCreator = new SenderCreator();\\n\\n    // internal value used during simulation: need to query aggregator.\\n    address internal constant SIMULATE_FIND_AGGREGATOR = address(1);\\n\\n    /**\\n     * for simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value\\n     * in case of signature failure, instead of revert.\\n     */\\n    uint256 public constant SIG_VALIDATION_FAILED = 1;\\n\\n    uint256 public constant NONCE_VALIDATION_FAILED = 2;\\n\\n    /**\\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\\n     * @param beneficiary the address to receive the fees\\n     * @param amount amount to transfer.\\n     */\\n    function _compensate(address payable beneficiary, uint256 amount) internal {\\n        require(beneficiary != address(0), \\\"AA90 invalid beneficiary\\\");\\n        (bool success, ) = beneficiary.call{value: amount}(\\\"\\\");\\n        require(success, \\\"AA91 failed send to beneficiary\\\");\\n    }\\n\\n    /**\\n     * execute a user op\\n     * @param opIndex into into the opInfo array\\n     * @param userOp the userOp to execute\\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\\n     * @return collected the total amount this userOp paid.\\n     */\\n    function _executeUserOp(\\n        uint256 opIndex,\\n        UserOperation calldata userOp,\\n        UserOpInfo memory opInfo\\n    ) internal returns (uint256 collected) {\\n        uint256 preGas = gasleft();\\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\\n\\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (\\n            uint256 _actualGasCost\\n        ) {\\n            collected = _actualGasCost;\\n        } catch {\\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\\n            collected = _handlePostOp(\\n                opIndex,\\n                IPaymaster.PostOpMode.postOpReverted,\\n                opInfo,\\n                context,\\n                actualGas\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an \\\"actualAggregator\\\" when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(\\n        UserOperation[] calldata ops,\\n        address payable beneficiary\\n    ) public virtual {\\n        uint256 opslen = ops.length;\\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\\n\\n        unchecked {\\n            for (uint256 i = 0; i < opslen; i++) {\\n                UserOpInfo memory opInfo = opInfos[i];\\n                (\\n                    uint256 deadline,\\n                    uint256 paymasterDeadline,\\n\\n                ) = _validatePrepayment(i, ops[i], opInfo, address(0));\\n                _validateDeadline(i, opInfo, deadline, paymasterDeadline);\\n            }\\n\\n            uint256 collected = 0;\\n\\n            for (uint256 i = 0; i < opslen; i++) {\\n                collected += _executeUserOp(i, ops[i], opInfos[i]);\\n            }\\n\\n            _compensate(beneficiary, collected);\\n        } //unchecked\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) public virtual {\\n        uint256 opasLen = opsPerAggregator.length;\\n        uint256 totalOps = 0;\\n        for (uint256 i = 0; i < opasLen; i++) {\\n            totalOps += opsPerAggregator[i].userOps.length;\\n        }\\n\\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\\n\\n        uint256 opIndex = 0;\\n        for (uint256 a = 0; a < opasLen; a++) {\\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\\n            UserOperation[] calldata ops = opa.userOps;\\n            IAggregator aggregator = opa.aggregator;\\n            uint256 opslen = ops.length;\\n            for (uint256 i = 0; i < opslen; i++) {\\n                UserOpInfo memory opInfo = opInfos[opIndex];\\n                (\\n                    uint256 deadline,\\n                    uint256 paymasterDeadline,\\n\\n                ) = _validatePrepayment(\\n                        opIndex,\\n                        ops[i],\\n                        opInfo,\\n                        address(aggregator)\\n                    );\\n                _validateDeadline(i, opInfo, deadline, paymasterDeadline);\\n                opIndex++;\\n            }\\n\\n            if (address(aggregator) != address(0)) {\\n                // solhint-disable-next-line no-empty-blocks\\n                try aggregator.validateSignatures(ops, opa.signature) {} catch {\\n                    revert SignatureValidationFailed(address(aggregator));\\n                }\\n            }\\n        }\\n\\n        uint256 collected = 0;\\n        opIndex = 0;\\n        for (uint256 a = 0; a < opasLen; a++) {\\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\\n            emit SignatureAggregatorChanged(address(opa.aggregator));\\n            UserOperation[] calldata ops = opa.userOps;\\n            uint256 opslen = ops.length;\\n\\n            for (uint256 i = 0; i < opslen; i++) {\\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\\n                opIndex++;\\n            }\\n        }\\n        emit SignatureAggregatorChanged(address(0));\\n\\n        _compensate(beneficiary, collected);\\n    }\\n\\n    function simulateHandleOp(UserOperation calldata op) external override {\\n        UserOpInfo memory opInfo;\\n\\n        (uint256 deadline, uint256 paymasterDeadline, ) = _validatePrepayment(\\n            0,\\n            op,\\n            opInfo,\\n            SIMULATE_FIND_AGGREGATOR\\n        );\\n        //ignore signature check failure\\n        if (deadline == SIG_VALIDATION_FAILED) {\\n            deadline = 0;\\n        }\\n        if (paymasterDeadline == SIG_VALIDATION_FAILED) {\\n            paymasterDeadline = 0;\\n        }\\n        _validateDeadline(0, opInfo, deadline, paymasterDeadline);\\n        numberMarker();\\n        uint256 paid = _executeUserOp(0, op, opInfo);\\n        revert ExecutionResult(\\n            opInfo.preOpGas,\\n            paid,\\n            deadline,\\n            paymasterDeadline\\n        );\\n    }\\n\\n    //a memory copy of UserOp fields (except that dynamic byte arrays: callData, initCode and signature\\n    struct MemoryUserOp {\\n        address sender;\\n        uint256 nonce;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        address paymaster;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n    }\\n\\n    struct UserOpInfo {\\n        MemoryUserOp mUserOp;\\n        bytes32 userOpHash;\\n        uint256 prefund;\\n        uint256 contextOffset;\\n        uint256 preOpGas;\\n    }\\n\\n    /**\\n     * inner function to handle a UserOperation.\\n     * Must be declared \\\"external\\\" to open a call context, but it can only be called by handleOps.\\n     */\\n    function innerHandleOp(\\n        bytes calldata callData,\\n        UserOpInfo memory opInfo,\\n        bytes calldata context\\n    ) external returns (uint256 actualGasCost) {\\n        uint256 preGas = gasleft();\\n        require(msg.sender == address(this), \\\"AA92 internal call only\\\");\\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n\\n        IPaymaster.PostOpMode mode;\\n\\n        (bool success, bytes memory result) = address(mUserOp.sender).call{\\n            gas: mUserOp.callGasLimit\\n        }(callData);\\n        if (!success) {\\n            emit UserOperationRevertReason(\\n                opInfo.userOpHash,\\n                mUserOp.sender,\\n                mUserOp.nonce,\\n                result\\n            );\\n            mode = IPaymaster.PostOpMode.opReverted;\\n        } else {\\n            mode = IPaymaster.PostOpMode.opSucceeded;\\n        }\\n\\n        unchecked {\\n            //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\\n            return\\n                _handlePostOp(\\n                    0,\\n                    mode,\\n                    opInfo,\\n                    context,\\n                    preGas - gasleft() + opInfo.preOpGas\\n                );\\n        }\\n    }\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(\\n        UserOperation calldata userOp\\n    ) public view returns (bytes32) {\\n        return\\n            keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\\n    }\\n\\n    /**\\n     * copy general fields from userOp into the memory opInfo structure.\\n     */\\n    function _copyUserOpToMemory(\\n        UserOperation calldata userOp,\\n        MemoryUserOp memory mUserOp\\n    ) internal pure {\\n        mUserOp.sender = userOp.sender;\\n        mUserOp.nonce = userOp.nonce;\\n        mUserOp.callGasLimit = userOp.callGasLimit;\\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\\n        if (paymasterAndData.length > 0) {\\n            require(\\n                paymasterAndData.length >= 20,\\n                \\\"AA93 invalid paymasterAndData\\\"\\n            );\\n            mUserOp.paymaster = address(bytes20(paymasterAndData[:20]));\\n        } else {\\n            mUserOp.paymaster = address(0);\\n        }\\n    }\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external {\\n        UserOpInfo memory outOpInfo;\\n\\n        (\\n            uint256 deadline,\\n            uint256 paymasterDeadline,\\n            address aggregator\\n        ) = _validatePrepayment(0, userOp, outOpInfo, SIMULATE_FIND_AGGREGATOR);\\n        StakeInfo memory paymasterInfo = getStakeInfo(\\n            outOpInfo.mUserOp.paymaster\\n        );\\n        StakeInfo memory senderInfo = getStakeInfo(outOpInfo.mUserOp.sender);\\n        bytes calldata initCode = userOp.initCode;\\n        address factory = initCode.length >= 20\\n            ? address(bytes20(initCode[0:20]))\\n            : address(0);\\n        StakeInfo memory factoryInfo = getStakeInfo(factory);\\n\\n        ReturnInfo memory returnInfo = ReturnInfo(\\n            outOpInfo.preOpGas,\\n            outOpInfo.prefund,\\n            deadline,\\n            paymasterDeadline,\\n            getMemoryBytesFromOffset(outOpInfo.contextOffset)\\n        );\\n\\n        if (aggregator != address(0)) {\\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(\\n                aggregator,\\n                getStakeInfo(aggregator)\\n            );\\n            revert ValidationResultWithAggregation(\\n                returnInfo,\\n                senderInfo,\\n                factoryInfo,\\n                paymasterInfo,\\n                aggregatorInfo\\n            );\\n        }\\n        revert ValidationResult(\\n            returnInfo,\\n            senderInfo,\\n            factoryInfo,\\n            paymasterInfo\\n        );\\n    }\\n\\n    function _getRequiredPrefund(\\n        MemoryUserOp memory mUserOp\\n    ) internal view returns (uint256 requiredPrefund) {\\n        unchecked {\\n            //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\\n            // our security model might call postOp eventually twice\\n            uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\\n            uint256 requiredGas = mUserOp.callGasLimit +\\n                mUserOp.verificationGasLimit *\\n                mul +\\n                mUserOp.preVerificationGas;\\n\\n            // TODO: copy logic of gasPrice?\\n            requiredPrefund = requiredGas * getUserOpGasPrice(mUserOp);\\n        }\\n    }\\n\\n    // create the sender's contract if needed.\\n    function _createSenderIfNeeded(\\n        uint256 opIndex,\\n        UserOpInfo memory opInfo,\\n        bytes calldata initCode\\n    ) internal {\\n        if (initCode.length != 0) {\\n            address sender = opInfo.mUserOp.sender;\\n            if (sender.code.length != 0)\\n                revert FailedOp(\\n                    opIndex,\\n                    address(0),\\n                    \\\"AA10 sender already constructed\\\"\\n                );\\n            address sender1 = senderCreator.createSender{\\n                gas: opInfo.mUserOp.verificationGasLimit\\n            }(initCode);\\n            if (sender1 == address(0))\\n                revert FailedOp(\\n                    opIndex,\\n                    address(0),\\n                    \\\"AA13 initCode failed or OOG\\\"\\n                );\\n            if (sender1 != sender)\\n                revert FailedOp(\\n                    opIndex,\\n                    address(0),\\n                    \\\"AA14 initCode must return sender\\\"\\n                );\\n            if (sender1.code.length == 0)\\n                revert FailedOp(\\n                    opIndex,\\n                    address(0),\\n                    \\\"AA15 initCode must create sender\\\"\\n                );\\n            address factory = address(bytes20(initCode[0:20]));\\n            emit AccountDeployed(\\n                opInfo.userOpHash,\\n                sender,\\n                factory,\\n                opInfo.mUserOp.paymaster\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes calldata initCode) public {\\n        revert SenderAddressResult(senderCreator.createSender(initCode));\\n    }\\n\\n    /**\\n     * call account.validateUserOp.\\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\\n     * decrement account's deposit if needed\\n     */\\n    function _validateAccountPrepayment(\\n        uint256 opIndex,\\n        UserOperation calldata op,\\n        UserOpInfo memory opInfo,\\n        address aggregator,\\n        uint256 requiredPrefund\\n    )\\n        internal\\n        returns (\\n            uint256 gasUsedByValidateAccountPrepayment,\\n            address actualAggregator,\\n            uint256 deadline\\n        )\\n    {\\n        unchecked {\\n            uint256 preGas = gasleft();\\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n            address sender = mUserOp.sender;\\n            _createSenderIfNeeded(opIndex, opInfo, op.initCode);\\n            if (aggregator == SIMULATE_FIND_AGGREGATOR) {\\n                numberMarker();\\n\\n                if (sender.code.length == 0) {\\n                    // it would revert anyway. but give a meaningful message\\n                    revert FailedOp(0, address(0), \\\"AA20 account not deployed\\\");\\n                }\\n                if (\\n                    mUserOp.paymaster != address(0) &&\\n                    mUserOp.paymaster.code.length == 0\\n                ) {\\n                    // it would revert anyway. but give a meaningful message\\n                    revert FailedOp(\\n                        0,\\n                        address(0),\\n                        \\\"AA30 paymaster not deployed\\\"\\n                    );\\n                }\\n                // during simulation, we don't use given aggregator,\\n                // but query the account for its aggregator\\n                try IAggregatedAccount(sender).getAggregator() returns (\\n                    address userOpAggregator\\n                ) {\\n                    aggregator = actualAggregator = userOpAggregator;\\n                } catch {\\n                    aggregator = actualAggregator = address(0);\\n                }\\n            }\\n            uint256 missingAccountFunds = 0;\\n            address paymaster = mUserOp.paymaster;\\n            if (paymaster == address(0)) {\\n                uint256 bal = balanceOf(sender);\\n                missingAccountFunds = bal > requiredPrefund\\n                    ? 0\\n                    : requiredPrefund - bal;\\n            }\\n\\n            try\\n                IAccount(sender).validateUserOp{\\n                    gas: mUserOp.verificationGasLimit\\n                }(op, opInfo.userOpHash, aggregator, missingAccountFunds)\\n            returns (uint256 _deadline) {\\n                deadline = _deadline;\\n            } catch Error(string memory revertReason) {\\n                revert FailedOp(opIndex, address(0), revertReason);\\n            } catch {\\n                revert FailedOp(opIndex, address(0), \\\"AA23 reverted (or OOG)\\\");\\n            }\\n            if (paymaster == address(0)) {\\n                DepositInfo storage senderInfo = deposits[sender];\\n                uint256 deposit = senderInfo.deposit;\\n                if (requiredPrefund > deposit) {\\n                    revert FailedOp(\\n                        opIndex,\\n                        address(0),\\n                        \\\"AA21 didn't pay prefund\\\"\\n                    );\\n                }\\n                senderInfo.deposit = uint112(deposit - requiredPrefund);\\n            }\\n            gasUsedByValidateAccountPrepayment = preGas - gasleft();\\n        }\\n    }\\n\\n    /**\\n     * in case the request has a paymaster:\\n     * validate paymaster is staked and has enough deposit.\\n     * call paymaster.validatePaymasterUserOp.\\n     * revert with proper FailedOp in case paymaster reverts.\\n     * decrement paymaster's deposit\\n     */\\n    function _validatePaymasterPrepayment(\\n        uint256 opIndex,\\n        UserOperation calldata op,\\n        UserOpInfo memory opInfo,\\n        uint256 requiredPreFund,\\n        uint256 gasUsedByValidateAccountPrepayment\\n    ) internal returns (bytes memory context, uint256 deadline) {\\n        unchecked {\\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n            address paymaster = mUserOp.paymaster;\\n            uint256 verificationGasLimit = mUserOp.verificationGasLimit;\\n            if (verificationGasLimit <= gasUsedByValidateAccountPrepayment) {\\n                revert FailedOp(\\n                    opIndex,\\n                    paymaster,\\n                    \\\"AA41 too little verificationGas\\\"\\n                );\\n            }\\n\\n            uint256 gas = verificationGasLimit -\\n                gasUsedByValidateAccountPrepayment;\\n\\n            DepositInfo storage paymasterInfo = deposits[paymaster];\\n            uint256 deposit = paymasterInfo.deposit;\\n            if (deposit < requiredPreFund) {\\n                revert FailedOp(\\n                    opIndex,\\n                    paymaster,\\n                    \\\"AA31 paymaster deposit too low\\\"\\n                );\\n            }\\n            paymasterInfo.deposit = uint112(deposit - requiredPreFund);\\n            try\\n                IPaymaster(paymaster).validatePaymasterUserOp{gas: gas}(\\n                    op,\\n                    opInfo.userOpHash,\\n                    requiredPreFund\\n                )\\n            returns (bytes memory _context, uint256 _deadline) {\\n                context = _context;\\n                deadline = _deadline;\\n            } catch Error(string memory revertReason) {\\n                revert FailedOp(opIndex, paymaster, revertReason);\\n            } catch {\\n                revert FailedOp(opIndex, paymaster, \\\"AA33 reverted (or OOG)\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * revert if either account deadline or paymaster deadline is expired\\n     */\\n    function _validateDeadline(\\n        uint256 opIndex,\\n        UserOpInfo memory opInfo,\\n        uint256 deadline,\\n        uint256 paymasterDeadline\\n    ) internal view {\\n        //we want to treat \\\"zero\\\" as \\\"maxint\\\", so we subtract one, ignoring underflow\\n        unchecked {\\n            // solhint-disable-next-line not-rely-on-time\\n            if (deadline < block.timestamp) {\\n                if (deadline == SIG_VALIDATION_FAILED) {\\n                    revert FailedOp(\\n                        opIndex,\\n                        address(0),\\n                        \\\"AA24 signature error\\\"\\n                    );\\n                } else if (deadline == NONCE_VALIDATION_FAILED) {\\n                    revert FailedOp(opIndex, address(0), \\\"AA25 nonce error\\\");\\n                } else {\\n                    revert FailedOp(opIndex, address(0), \\\"AA22 expired\\\");\\n                }\\n            }\\n            // solhint-disable-next-line not-rely-on-time\\n            if (paymasterDeadline != 0 && paymasterDeadline < block.timestamp) {\\n                address paymaster = opInfo.mUserOp.paymaster;\\n                if (paymasterDeadline == SIG_VALIDATION_FAILED) {\\n                    revert FailedOp(opIndex, paymaster, \\\"AA34 signature error\\\");\\n                } else {\\n                    revert FailedOp(\\n                        opIndex,\\n                        paymaster,\\n                        \\\"AA32 paymaster expired\\\"\\n                    );\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * validate account and paymaster (if defined).\\n     * also make sure total validation doesn't exceed verificationGasLimit\\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\\n     * @param opIndex the index of this userOp into the \\\"opInfos\\\" array\\n     * @param userOp the userOp to validate\\n     */\\n    function _validatePrepayment(\\n        uint256 opIndex,\\n        UserOperation calldata userOp,\\n        UserOpInfo memory outOpInfo,\\n        address aggregator\\n    )\\n        internal\\n        returns (\\n            uint256 deadline,\\n            uint256 paymasterDeadline,\\n            address actualAggregator\\n        )\\n    {\\n        uint256 preGas = gasleft();\\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\\n        _copyUserOpToMemory(userOp, mUserOp);\\n        outOpInfo.userOpHash = getUserOpHash(userOp);\\n\\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\\n        // and multiplied without causing overflow\\n        uint256 maxGasValues = mUserOp.preVerificationGas |\\n            mUserOp.verificationGasLimit |\\n            mUserOp.callGasLimit |\\n            userOp.maxFeePerGas |\\n            userOp.maxPriorityFeePerGas;\\n        require(maxGasValues <= type(uint120).max, \\\"AA94 gas values overflow\\\");\\n\\n        uint256 gasUsedByValidateAccountPrepayment;\\n        uint256 requiredPreFund = _getRequiredPrefund(mUserOp);\\n\\n        (\\n            gasUsedByValidateAccountPrepayment,\\n            actualAggregator,\\n            deadline\\n        ) = _validateAccountPrepayment(\\n            opIndex,\\n            userOp,\\n            outOpInfo,\\n            aggregator,\\n            requiredPreFund\\n        );\\n        //a \\\"marker\\\" where account opcode validation is done and paymaster opcode validation is about to start\\n        // (used only by off-chain simulateValidation)\\n        numberMarker();\\n\\n        bytes memory context;\\n        if (mUserOp.paymaster != address(0)) {\\n            (context, paymasterDeadline) = _validatePaymasterPrepayment(\\n                opIndex,\\n                userOp,\\n                outOpInfo,\\n                requiredPreFund,\\n                gasUsedByValidateAccountPrepayment\\n            );\\n        }\\n\\n        unchecked {\\n            if (userOp.verificationGasLimit < preGas - gasleft()) {\\n                revert FailedOp(\\n                    opIndex,\\n                    mUserOp.paymaster,\\n                    \\\"AA40 over verificationGasLimit\\\"\\n                );\\n            }\\n\\n            outOpInfo.prefund = requiredPreFund;\\n            outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\\n            outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\\n        }\\n    }\\n\\n    /**\\n     * process post-operation.\\n     * called just after the callData is executed.\\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\\n     * the excess amount is refunded to the account (or paymaster - if it is was used in the request)\\n     * @param opIndex index in the batch\\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\\n     * @param opInfo userOp fields and info collected during validation\\n     * @param context the context returned in validatePaymasterUserOp\\n     * @param actualGas the gas used so far by this user operation\\n     */\\n    function _handlePostOp(\\n        uint256 opIndex,\\n        IPaymaster.PostOpMode mode,\\n        UserOpInfo memory opInfo,\\n        bytes memory context,\\n        uint256 actualGas\\n    ) internal returns (uint256 actualGasCost) {\\n        uint256 preGas = gasleft();\\n        unchecked {\\n            address refundAddress;\\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n            uint256 gasPrice = getUserOpGasPrice(mUserOp);\\n\\n            address paymaster = mUserOp.paymaster;\\n            if (paymaster == address(0)) {\\n                refundAddress = mUserOp.sender;\\n            } else {\\n                refundAddress = paymaster;\\n                if (context.length > 0) {\\n                    actualGasCost = actualGas * gasPrice;\\n                    if (mode != IPaymaster.PostOpMode.postOpReverted) {\\n                        IPaymaster(paymaster).postOp{\\n                            gas: mUserOp.verificationGasLimit\\n                        }(mode, context, actualGasCost);\\n                    } else {\\n                        // solhint-disable-next-line no-empty-blocks\\n                        try\\n                            IPaymaster(paymaster).postOp{\\n                                gas: mUserOp.verificationGasLimit\\n                            }(mode, context, actualGasCost)\\n                        {} catch Error(string memory reason) {\\n                            revert FailedOp(opIndex, paymaster, reason);\\n                        } catch {\\n                            revert FailedOp(\\n                                opIndex,\\n                                paymaster,\\n                                \\\"AA50 postOp revert\\\"\\n                            );\\n                        }\\n                    }\\n                }\\n            }\\n\\n            actualGas += preGas - gasleft();\\n            actualGasCost = actualGas * gasPrice;\\n            if (opInfo.prefund < actualGasCost) {\\n                revert FailedOp(\\n                    opIndex,\\n                    paymaster,\\n                    \\\"AA51 prefund below actualGasCost\\\"\\n                );\\n            }\\n\\n            {\\n                uint256 refund = opInfo.prefund - actualGasCost;\\n                if (paymaster == address(0)) {\\n                    refundDeposit(payable(refundAddress), refund);\\n                } else {\\n                    internalIncrementDeposit(refundAddress, refund);\\n                }\\n            }\\n\\n            emit UserOperationEvent(\\n                opInfo.userOpHash,\\n                mUserOp.sender,\\n                mUserOp.paymaster,\\n                mUserOp.nonce,\\n                mode == IPaymaster.PostOpMode.opSucceeded,\\n                actualGasCost,\\n                actualGas\\n            );\\n        } // unchecked\\n    }\\n\\n    /**\\n     * the gas price this UserOp agrees to pay.\\n     * relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n     */\\n    function getUserOpGasPrice(\\n        MemoryUserOp memory mUserOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            return\\n                mUserOp.maxFeePerGas == mUserOp.maxPriorityFeePerGas\\n                    ? mUserOp.maxFeePerGas\\n                    : min(\\n                        mUserOp.maxFeePerGas,\\n                        mUserOp.maxPriorityFeePerGas + block.basefee\\n                    );\\n        }\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function getOffsetOfMemoryBytes(\\n        bytes memory data\\n    ) internal pure returns (uint256 offset) {\\n        assembly {\\n            offset := data\\n        }\\n    }\\n\\n    function getMemoryBytesFromOffset(\\n        uint256 offset\\n    ) internal pure returns (bytes memory data) {\\n        assembly {\\n            data := offset\\n        }\\n    }\\n\\n    //place the NUMBER opcode in the code.\\n    // this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\\n    // account and paymaster.\\n    function numberMarker() internal view {\\n        assembly {\\n            mstore(0, number())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/@eth-infinitism-v0.4/SenderCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// Original code: https://github.com/eth-infinitism/account-abstraction/tree/releases/v0.4\\npragma solidity ^0.8.12;\\n\\n/**\\n * helper contract for EntryPoint, to call userOp.initCode from a \\\"neutral\\\" address,\\n * which is explicitly not the entryPoint itself.\\n */\\ncontract SenderCreator {\\n    /**\\n     * call the \\\"initCode\\\" factory to create and return the sender account address\\n     * @param initCode the initCode value from a UserOp. contains 20 bytes of factory address, followed by calldata\\n     * @return sender the returned address of the created account, or zero address on failure.\\n     */\\n    function createSender(\\n        bytes calldata initCode\\n    ) external returns (address sender) {\\n        address initAddress = address(bytes20(initCode[0:20]));\\n        bytes memory initCallData = initCode[20:];\\n        bool success;\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            success := call(\\n                gas(),\\n                initAddress,\\n                0,\\n                add(initCallData, 0x20),\\n                mload(initCallData),\\n                0,\\n                32\\n            )\\n            sender := mload(0)\\n        }\\n        if (!success) {\\n            sender = address(0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/@eth-infinitism-v0.4/StakeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// Modified version of a Implementation of contracts for ERC-4337 account abstraction via alternative mempool.\\n// Original code: https://github.com/eth-infinitism/account-abstraction/tree/releases/v0.4\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IStakeManager.sol\\\";\\n\\nabstract contract StakeManager is IStakeManager {\\n    /// maps paymaster to their deposits and stakes\\n    mapping(address => DepositInfo) public deposits;\\n\\n    function getDepositInfo(\\n        address account\\n    ) public view returns (DepositInfo memory info) {\\n        return deposits[account];\\n    }\\n\\n    // internal method to return just the stake info\\n    function getStakeInfo(\\n        address addr\\n    ) internal view returns (StakeInfo memory info) {\\n        DepositInfo storage depositInfo = deposits[addr];\\n        info.stake = depositInfo.stake;\\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\\n    }\\n\\n    /// return the deposit (for gas payment) of the account\\n    function balanceOf(address account) public view returns (uint256) {\\n        return deposits[account].deposit;\\n    }\\n\\n    receive() external payable {\\n        depositTo(msg.sender);\\n    }\\n\\n    function internalIncrementDeposit(\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        DepositInfo storage info = deposits[account];\\n        uint256 newAmount = info.deposit + amount;\\n        require(newAmount <= type(uint112).max, \\\"deposit overflow\\\");\\n        info.deposit = uint112(newAmount);\\n    }\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) public payable {\\n        internalIncrementDeposit(account, msg.value);\\n        DepositInfo storage info = deposits[account];\\n        emit Deposited(\\n            msg.sender,\\n            address(this),\\n            account,\\n            msg.value,\\n            info.deposit\\n        );\\n    }\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(\\n        address payable withdrawAddress,\\n        uint256 withdrawAmount\\n    ) external {\\n        DepositInfo storage info = deposits[msg.sender];\\n        require(withdrawAmount <= info.deposit, \\\"Withdraw amount too large\\\");\\n        info.deposit = uint112(info.deposit - withdrawAmount);\\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\\n        (bool success, ) = withdrawAddress.call{value: withdrawAmount}(\\\"\\\");\\n        require(success, \\\"failed to withdraw\\\");\\n    }\\n\\n    function refundDeposit(\\n        address payable refundAddress,\\n        uint256 refundAmount\\n    ) internal {\\n        (bool success, ) = refundAddress.call{value: refundAmount, gas: 4500}(\\n            \\\"\\\"\\n        );\\n\\n        if (success) {\\n            emit RefundDeposit(msg.sender, refundAddress, refundAmount);\\n        } else {\\n            internalIncrementDeposit(refundAddress, refundAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/EntryPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./EntryPointSimulations.sol\\\";\\n\\ncontract EntryPoint is EntryPointSimulations {\\n    constructor(address owner) EntryPointSimulations(owner) {}\\n}\\n\"\r\n    },\r\n    \"contracts/core/EntryPointLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IEntryPointLogic.sol\\\";\\nimport {EntryPoint as EntryPoint0_4} from \\\"../@eth-infinitism-v0.4/EntryPoint.sol\\\";\\nimport \\\"./Storage.sol\\\";\\n\\ncontract EntryPointLogic is IEntryPointLogic, EntryPoint0_4, Storage {\\n    constructor(address owner) {\\n        _transferOwnership(owner);\\n    }\\n\\n    function handleOps(\\n        UserOperation[] calldata ops,\\n        address payable beneficiary\\n    ) public override(EntryPoint0_4, IEntryPoint) {\\n        uint256 opslen = ops.length;\\n\\n        if (!officialBundlerWhiteList[msg.sender]) {\\n            require(\\n                unrestrictedBundler && msg.sender == tx.origin,\\n                \\\"called by illegal bundler\\\"\\n            );\\n            require(opslen == 1, \\\"only support one op\\\");\\n        }\\n\\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\\n        uint256 collected;\\n        unchecked {\\n            for (uint256 i = 0; i < opslen; ++i) {\\n                try this.handleOp(i, ops[i], opInfos[i], address(0)) returns (\\n                    uint256 gasUsed\\n                ) {\\n                    collected += gasUsed;\\n                } catch (bytes memory revertReason) {\\n                    emit HandleUserOpRevertReason(\\n                        ops[i].sender,\\n                        ops[i].nonce,\\n                        revertReason\\n                    );\\n                }\\n            }\\n            _compensate(beneficiary, collected);\\n        }\\n    }\\n\\n    function handleOps(UserOperation[] calldata ops) public override {\\n        handleOps(ops, payable(msg.sender));\\n    }\\n\\n    function handleOp(\\n        uint256 opIndex,\\n        UserOperation calldata userOp,\\n        UserOpInfo memory outOpInfo,\\n        address aggregator\\n    ) external returns (uint256) {\\n        require(msg.sender == address(this), \\\"can only call by handleOps\\\");\\n\\n        (uint256 deadline, uint256 paymasterDeadline, ) = _validatePrepayment(\\n            opIndex,\\n            userOp,\\n            outOpInfo,\\n            aggregator\\n        );\\n\\n        _validateDeadline(opIndex, outOpInfo, deadline, paymasterDeadline);\\n\\n        return _executeUserOp(opIndex, userOp, outOpInfo);\\n    }\\n\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata,\\n        address payable\\n    ) public pure override(EntryPoint0_4, IEntryPoint) {\\n        revert(\\\"Not support aggregator yet\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/EntryPointSimulations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IEntryPointSimulations.sol\\\";\\nimport \\\"../interfaces/IAccount.sol\\\";\\nimport \\\"./EntryPointLogic.sol\\\";\\nimport \\\"../library/UserOperation.sol\\\";\\n\\ncontract EntryPointSimulations is IEntryPointSimulations, EntryPointLogic {\\n    constructor(address owner) EntryPointLogic(owner) {}\\n\\n    function simulateValidationWithWalletWhitelistValidate(\\n        UserOperation calldata op\\n    ) external {\\n        UserOpInfo memory opInfo;\\n\\n        (uint256 deadline, uint256 paymasterDeadline, ) = _validatePrepayment(\\n            0,\\n            op,\\n            opInfo,\\n            SIMULATE_FIND_AGGREGATOR\\n        );\\n\\n        _validateDeadline(0, opInfo, deadline, paymasterDeadline);\\n\\n        validateWalletWhitelist(op.sender);\\n\\n        (\\n            uint256 actualGasCost,\\n            uint256 callGasEstimate,\\n            IPaymaster.PostOpMode mode,\\n            bytes memory excuteResult\\n        ) = _executeUserOpWithResult(0, op, opInfo);\\n\\n        uint256 gasPrice = getUserOpGasPrice(opInfo.mUserOp);\\n\\n        revert SimulateHandleOpResult(\\n            opInfo.preOpGas,\\n            mode,\\n            excuteResult,\\n            gasPrice > 0 ? actualGasCost / gasPrice : 0,\\n            callGasEstimate,\\n            gasPrice,\\n            deadline,\\n            paymasterDeadline\\n        );\\n    }\\n\\n    function simulateHandleOpWithoutSig(\\n        UserOperation calldata op\\n    ) external override {\\n        UserOpInfo memory opInfo;\\n\\n        (\\n            uint256 deadline,\\n            uint256 paymasterDeadline,\\n\\n        ) = _validatePrepaymentWithoutSig(0, op, opInfo, address(0));\\n\\n        _validateDeadline(0, opInfo, deadline, paymasterDeadline);\\n\\n        validateWalletWhitelist(op.sender);\\n\\n        (\\n            uint256 actualGasCost,\\n            uint256 callGasEstimate,\\n            IPaymaster.PostOpMode mode,\\n            bytes memory excuteResult\\n        ) = _executeUserOpWithResult(0, op, opInfo);\\n\\n        uint256 gasPrice = getUserOpGasPrice(opInfo.mUserOp);\\n\\n        revert SimulateHandleOpResult(\\n            opInfo.preOpGas,\\n            mode,\\n            excuteResult,\\n            gasPrice > 0 ? actualGasCost / gasPrice : 0,\\n            callGasEstimate,\\n            gasPrice,\\n            deadline,\\n            paymasterDeadline\\n        );\\n    }\\n\\n    function _validatePrepaymentWithoutSig(\\n        uint256 opIndex,\\n        UserOperation calldata userOp,\\n        UserOpInfo memory outOpInfo,\\n        address aggregator\\n    )\\n        internal\\n        returns (\\n            uint256 deadline,\\n            uint256 paymasterDeadline,\\n            address actualAggregator\\n        )\\n    {\\n        uint256 preGas = gasleft();\\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\\n        _copyUserOpToMemory(userOp, mUserOp);\\n        outOpInfo.userOpHash = getUserOpHash(userOp);\\n\\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\\n        // and multiplied without causing overflow\\n        uint256 maxGasValues = mUserOp.preVerificationGas |\\n            mUserOp.verificationGasLimit |\\n            mUserOp.callGasLimit |\\n            userOp.maxFeePerGas |\\n            userOp.maxPriorityFeePerGas;\\n        require(maxGasValues <= type(uint120).max, \\\"AA94 gas values overflow\\\");\\n\\n        uint256 gasUsedByValidateAccountPrepayment;\\n        uint256 requiredPreFund = _getRequiredPrefund(mUserOp);\\n        (\\n            gasUsedByValidateAccountPrepayment,\\n            actualAggregator,\\n            deadline\\n        ) = _validateAccountPrepaymentWithoutSig(\\n            opIndex,\\n            userOp,\\n            outOpInfo,\\n            aggregator,\\n            requiredPreFund\\n        );\\n        //a \\\"marker\\\" where account opcode validation is done and paymaster opcode validation is about to start\\n        // (used only by off-chain simulateValidation)\\n        numberMarker();\\n\\n        bytes memory context;\\n        if (mUserOp.paymaster != address(0)) {\\n            (\\n                context,\\n                paymasterDeadline\\n            ) = _validatePaymasterPrepaymentWithoutSig(\\n                opIndex,\\n                userOp,\\n                outOpInfo,\\n                requiredPreFund,\\n                gasUsedByValidateAccountPrepayment\\n            );\\n        }\\n        unchecked {\\n            uint256 gasUsed = preGas - gasleft();\\n\\n            if (userOp.verificationGasLimit < gasUsed) {\\n                revert FailedOp(\\n                    opIndex,\\n                    mUserOp.paymaster,\\n                    \\\"AA40 over verificationGasLimit\\\"\\n                );\\n            }\\n            outOpInfo.prefund = requiredPreFund;\\n            outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\\n            outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\\n        }\\n    }\\n\\n    function _validateAccountPrepaymentWithoutSig(\\n        uint256 opIndex,\\n        UserOperation calldata op,\\n        UserOpInfo memory opInfo,\\n        address aggregator,\\n        uint256 requiredPrefund\\n    )\\n        internal\\n        returns (\\n            uint256 gasUsedByValidateAccountPrepayment,\\n            address actualAggregator,\\n            uint256 deadline\\n        )\\n    {\\n        unchecked {\\n            uint256 preGas = gasleft();\\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n            address sender = mUserOp.sender;\\n            _createSenderIfNeeded(opIndex, opInfo, op.initCode);\\n\\n            if (sender.code.length == 0) {\\n                // it would revert anyway. but give a meaningful message\\n                revert FailedOp(0, address(0), \\\"AA20 account not deployed\\\");\\n            }\\n\\n            if (\\n                mUserOp.paymaster != address(0) &&\\n                mUserOp.paymaster.code.length == 0\\n            ) {\\n                // it would revert anyway. but give a meaningful message\\n                revert FailedOp(0, address(0), \\\"AA30 paymaster not deployed\\\");\\n            }\\n\\n            uint256 missingAccountFunds = 0;\\n            address paymaster = mUserOp.paymaster;\\n\\n            if (paymaster == address(0)) {\\n                uint256 bal = balanceOf(sender);\\n                missingAccountFunds = bal > requiredPrefund\\n                    ? 0\\n                    : requiredPrefund - bal;\\n            }\\n\\n            try\\n                IAccount(sender).validateUserOpWithoutSig{\\n                    gas: mUserOp.verificationGasLimit\\n                }(op, opInfo.userOpHash, aggregator, missingAccountFunds)\\n            returns (uint256 _deadline) {\\n                deadline = _deadline;\\n            } catch Error(string memory revertReason) {\\n                revert FailedOp(opIndex, address(0), revertReason);\\n            } catch {\\n                revert FailedOp(opIndex, address(0), \\\"AA23 reverted (or OOG)\\\");\\n            }\\n\\n            if (paymaster == address(0)) {\\n                DepositInfo storage senderInfo = deposits[sender];\\n                uint256 deposit = senderInfo.deposit;\\n                if (requiredPrefund > deposit) {\\n                    revert FailedOp(\\n                        opIndex,\\n                        address(0),\\n                        \\\"AA21 didn't pay prefund\\\"\\n                    );\\n                }\\n                senderInfo.deposit = uint112(deposit - requiredPrefund);\\n            }\\n            gasUsedByValidateAccountPrepayment = preGas - gasleft();\\n        }\\n    }\\n\\n    function _validatePaymasterPrepaymentWithoutSig(\\n        uint256 opIndex,\\n        UserOperation calldata op,\\n        UserOpInfo memory opInfo,\\n        uint256 requiredPreFund,\\n        uint256 gasUsedByValidateAccountPrepayment\\n    ) internal returns (bytes memory context, uint256 deadline) {\\n        unchecked {\\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n            uint256 verificationGasLimit = mUserOp.verificationGasLimit;\\n            require(\\n                verificationGasLimit > gasUsedByValidateAccountPrepayment,\\n                \\\"AA41 too little verificationGas\\\"\\n            );\\n            uint256 gas = verificationGasLimit -\\n                gasUsedByValidateAccountPrepayment;\\n\\n            address paymaster = mUserOp.paymaster;\\n            DepositInfo storage paymasterInfo = deposits[paymaster];\\n            uint256 deposit = paymasterInfo.deposit;\\n            if (deposit < requiredPreFund) {\\n                revert FailedOp(\\n                    opIndex,\\n                    paymaster,\\n                    \\\"AA31 paymaster deposit too low\\\"\\n                );\\n            }\\n            paymasterInfo.deposit = uint112(deposit - requiredPreFund);\\n\\n            try\\n                IPaymaster(paymaster).validatePaymasterUserOpWithoutSig{\\n                    gas: gas\\n                }(op, opInfo.userOpHash, requiredPreFund)\\n            returns (bytes memory _context, uint256 _deadline) {\\n                context = _context;\\n                deadline = _deadline;\\n            } catch Error(string memory revertReason) {\\n                revert FailedOp(opIndex, paymaster, revertReason);\\n            } catch {\\n                revert FailedOp(opIndex, paymaster, \\\"AA33 reverted (or OOG)\\\");\\n            }\\n        }\\n    }\\n\\n    function _executeUserOpWithResult(\\n        uint256 opIndex,\\n        UserOperation calldata userOp,\\n        UserOpInfo memory opInfo\\n    )\\n        internal\\n        returns (\\n            uint256 collected,\\n            uint256 callGasCost,\\n            IPaymaster.PostOpMode mode,\\n            bytes memory excuteResult\\n        )\\n    {\\n        uint256 preGas = gasleft();\\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\\n\\n        try\\n            this.innerHandleOpWithResult(userOp.callData, opInfo, context)\\n        returns (\\n            uint256 _actualGasCost,\\n            uint256 _callGasCost,\\n            IPaymaster.PostOpMode _mode,\\n            bytes memory _excuteResult\\n        ) {\\n            collected = _actualGasCost;\\n            callGasCost = _callGasCost;\\n            mode = _mode;\\n            excuteResult = _excuteResult;\\n        } catch {\\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\\n            collected = _handlePostOp(\\n                opIndex,\\n                IPaymaster.PostOpMode.postOpReverted,\\n                opInfo,\\n                context,\\n                actualGas\\n            );\\n            mode = IPaymaster.PostOpMode.postOpReverted;\\n        }\\n    }\\n\\n    function innerHandleOpWithResult(\\n        bytes calldata callData,\\n        UserOpInfo memory opInfo,\\n        bytes calldata context\\n    )\\n        external\\n        returns (\\n            uint256 actualGasCost,\\n            uint256 callGasCost,\\n            IPaymaster.PostOpMode postOpMode,\\n            bytes memory excuteResult\\n        )\\n    {\\n        uint256 preGas = gasleft();\\n        require(msg.sender == address(this), \\\"AA92 internal call only\\\");\\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n\\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\\n        if (callData.length > 0) {\\n            (bool success, bytes memory result) = address(mUserOp.sender).call{\\n                gas: mUserOp.callGasLimit\\n            }(callData);\\n            callGasCost = preGas - gasleft();\\n            if (!success) {\\n                if (result.length > 0) {\\n                    emit UserOperationRevertReason(\\n                        opInfo.userOpHash,\\n                        mUserOp.sender,\\n                        mUserOp.nonce,\\n                        result\\n                    );\\n                }\\n                mode = IPaymaster.PostOpMode.opReverted;\\n            }\\n\\n            excuteResult = result;\\n        }\\n\\n        unchecked {\\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\\n            //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\\n            actualGasCost = _handlePostOp(0, mode, opInfo, context, actualGas);\\n            postOpMode = mode;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IStorage.sol\\\";\\nimport \\\"../interfaces/ISmartAccountProxy.sol\\\";\\nimport \\\"../interfaces/ISmartAccountProxyFactory.sol\\\";\\n\\ncontract Storage is Ownable, IStorage {\\n    bool public unrestrictedWallet;\\n    bool public unrestrictedBundler;\\n    bool public unrestrictedModule;\\n\\n    address public walletProxyFactory;\\n\\n    mapping(address => bool) public officialBundlerWhiteList;\\n    mapping(address => bool) public moduleWhiteList;\\n\\n    function setUnrestrictedWallet(bool allowed) public onlyOwner {\\n        unrestrictedWallet = allowed;\\n        emit UnrestrictedWalletSet(allowed);\\n    }\\n\\n    function setUnrestrictedBundler(bool allowed) public onlyOwner {\\n        unrestrictedBundler = allowed;\\n        emit UnrestrictedBundlerSet(allowed);\\n    }\\n\\n    function setUnrestrictedModule(bool allowed) public onlyOwner {\\n        unrestrictedModule = allowed;\\n        emit UnrestrictedModuleSet(allowed);\\n    }\\n\\n    function setBundlerOfficialWhitelist(\\n        address bundler,\\n        bool allowed\\n    ) public onlyOwner {\\n        officialBundlerWhiteList[bundler] = allowed;\\n        emit BundlerWhitelistSet(bundler, allowed);\\n    }\\n\\n    function setWalletProxyFactoryWhitelist(\\n        address walletFactory\\n    ) public onlyOwner {\\n        require(walletProxyFactory == address(0), \\\"already set\\\");\\n        walletProxyFactory = walletFactory;\\n        emit WalletFactoryWhitelistSet(walletFactory);\\n    }\\n\\n    function setModuleWhitelist(address module, bool allowed) public onlyOwner {\\n        moduleWhiteList[module] = allowed;\\n        emit ModuleWhitelistSet(module, allowed);\\n    }\\n\\n    function validateModuleWhitelist(address module) public view {\\n        if (!moduleWhiteList[module]) {\\n            require(unrestrictedModule, \\\"not allowed module\\\");\\n        }\\n    }\\n\\n    function validateWalletWhitelist(address sender) public view {\\n        if (!unrestrictedWallet) {\\n            require(\\n                ISmartAccountProxyFactory(walletProxyFactory).walletWhiteList(\\n                    sender\\n                ),\\n                \\\"sender not created by whitelist factory\\\"\\n            );\\n\\n            require(\\n                ISmartAccountProxyFactory(walletProxyFactory).safeSingleton(\\n                    ISmartAccountProxy(sender).masterCopy()\\n                ),\\n                \\\"sender implement not in whitelist\\\"\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"../library/UserOperation.sol\\\";\\n\\ninterface IAccount {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp the operation that is about to be executed.\\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\\n     * @param aggregator the aggregator used to validate the signature. NULL for non-aggregated signature accounts.\\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     *      The excess is left as a deposit in the entrypoint, for future calls.\\n     *      can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\"\\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\\n     * @return deadline the last block timestamp this operation is valid, or zero if it is valid indefinitely.\\n     *      signature failure is returned as SIG_VALIDATION_FAILED value (1)\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        address aggregator,\\n        uint256 missingAccountFunds\\n    ) external returns (uint256 deadline);\\n\\n    function validateUserOpWithoutSig(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        address aggregator,\\n        uint256 missingAccountFunds\\n    ) external returns (uint256 deadline);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAggregatedAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"../library/UserOperation.sol\\\";\\nimport \\\"./IAccount.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\n\\n/**\\n * Aggregated account, that support IAggregator.\\n * - the validateUserOp will be called only after the aggregator validated this account (with all other accounts of this aggregator).\\n * - the validateUserOp MUST valiate the aggregator parameter, and MAY ignore the userOp.signature field.\\n */\\ninterface IAggregatedAccount is IAccount {\\n    /**\\n     * return the address of the signature aggregator the account supports.\\n     */\\n    function getAggregator() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"../library/UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n    /**\\n     * validate aggregated signature.\\n     * revert if the aggregated signature does not match the given list of operations.\\n     */\\n    function validateSignatures(\\n        UserOperation[] calldata userOps,\\n        bytes calldata signature\\n    ) external view;\\n\\n    /**\\n     * validate signature of a single userOp\\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n     * First it validates the signature over the userOp. then it return data to be used when creating the handleOps:\\n     * @param userOp the userOperation received from the user.\\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n     *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n     */\\n    function validateUserOpSignature(\\n        UserOperation calldata userOp\\n    ) external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation\\n     * @param userOps array of UserOperations to collect the signatures from.\\n     * @return aggregatesSignature the aggregated signature\\n     */\\n    function aggregateSignatures(\\n        UserOperation[] calldata userOps\\n    ) external view returns (bytes memory aggregatesSignature);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEntryPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// Modified version of a Implementation of contracts for ERC-4337 account abstraction via alternative mempool.\\n// Original code: https://github.com/eth-infinitism/account-abstraction/tree/releases/v0.4\\npragma solidity ^0.8.12;\\n\\nimport \\\"../library/UserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager {\\n    /***\\n     * An event emitted after each successful request\\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request\\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation\\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution)\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     */\\n    event UserOperationEvent(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address indexed paymaster,\\n        uint256 nonce,\\n        bool success,\\n        uint256 actualGasCost,\\n        uint256 actualGasUsed\\n    );\\n\\n    /**\\n     * account \\\"sender\\\" was deployed.\\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender the account that is deployed\\n     * @param factory the factory used to deploy this account (in the initCode)\\n     * @param paymaster the paymaster used by this UserOp\\n     */\\n    event AccountDeployed(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address factory,\\n        address paymaster\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param userOpHash the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * signature aggregator used by the following UserOperationEvents within this bundle.\\n     */\\n    event SignatureAggregatorChanged(address aggregator);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param paymaster - if paymaster.validatePaymasterUserOp fails, this will be the paymaster's address. if validateUserOp failed,\\n     *       this value will be zero (since it failed before accessing the paymaster)\\n     *  @param reason - revert reason\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of account/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, address paymaster, string reason);\\n\\n    /**\\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    //UserOps handled, per aggregator\\n    struct UserOpsPerAggregator {\\n        UserOperation[] userOps;\\n        // aggregator address\\n        IAggregator aggregator;\\n        // aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an \\\"actualAggregator\\\" when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(\\n        UserOperation[] calldata ops,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(\\n        UserOperation calldata userOp\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external;\\n\\n    /**\\n     * Successful result from simulateValidation.\\n     * @param returnInfo gas and deadlines returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factor (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     */\\n    error ValidationResult(\\n        ReturnInfo returnInfo,\\n        StakeInfo senderInfo,\\n        StakeInfo factoryInfo,\\n        StakeInfo paymasterInfo\\n    );\\n\\n    /**\\n     * Successful result from simulateValidation, if the account returns a signature aggregator\\n     * @param returnInfo gas and deadlines returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factor (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\\n     */\\n    error ValidationResultWithAggregation(\\n        ReturnInfo returnInfo,\\n        StakeInfo senderInfo,\\n        StakeInfo factoryInfo,\\n        StakeInfo paymasterInfo,\\n        AggregatorStakeInfo aggregatorInfo\\n    );\\n\\n    /**\\n     * gas and deadlines returned during simulation\\n     * @param preOpGas the gas used for validation (including preValidationGas)\\n     * @param prefund the required prefund for this operation\\n     * @param deadline validateUserOp's deadline (or SIG_VALIDATION_FAILED for signature failure)\\n     * @param paymasterDeadline validatePaymasterUserOp's deadline (or SIG_VALIDATION_FAILED for signature failure)\\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        uint256 deadline;\\n        uint256 paymasterDeadline;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * returned aggregated signature info.\\n     * the aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address actualAggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n    /**\\n     * return value of getSenderAddress\\n     */\\n    error SenderAddressResult(address sender);\\n\\n    /**\\n     * simulate full execution of a UserOperation (including both validation and target execution)\\n     * this method will always revert. it performs full validation of the UserOperation, but ignores\\n     * signature error.\\n     * Note that in order to collect the the success/failure of the target call, it must be executed\\n     * with trace enabled to track the emitted events.\\n     */\\n    function simulateHandleOp(UserOperation calldata op) external;\\n\\n    error ExecutionResult(\\n        uint256 preOpGas,\\n        uint256 paid,\\n        uint256 deadline,\\n        uint256 paymasterDeadline\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEntryPointLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./IEntryPoint.sol\\\";\\nimport \\\"./IPaymaster.sol\\\";\\n\\ninterface IEntryPointLogic is IEntryPoint {\\n    event HandleUserOpRevertReason(\\n        address sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    function handleOps(UserOperation[] calldata ops) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEntryPointSimulations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./IEntryPoint.sol\\\";\\nimport \\\"./IPaymaster.sol\\\";\\n\\ninterface IEntryPointSimulations {\\n    function simulateHandleOpWithoutSig(UserOperation calldata op) external;\\n\\n    error SimulateHandleOpResult(\\n        uint256 preOpGas,\\n        IPaymaster.PostOpMode,\\n        bytes result,\\n        uint256 paid,\\n        uint256 callGasCost,\\n        uint256 gasPrice,\\n        uint256 deadline,\\n        uint256 paymasterDeadline\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"../library/UserOperation.sol\\\";\\n\\n/**\\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\\n */\\ninterface IPaymaster {\\n    /**\\n     * payment validation: check if paymaster agree to pay.\\n     * Must verify sender is the entryPoint.\\n     * Revert to reject this request.\\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\\n     * @param userOp the user operation\\n     * @param userOpHash hash of the user's request data.\\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\\n     * @return context value to send to a postOp\\n     *  zero length to signify postOp is not required.\\n     * @return sigTimeRange signature and time-range of this operation, encoded the same as the return value of validateUserOperation\\n     *      <byte> sigFailure - (1) to mark signature failure (needed only if paymaster uses signature-based validation,)\\n     *      <4-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *      <4-byte> validAfter - first timestamp this operation is valid\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validatePaymasterUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 maxCost\\n    ) external returns (bytes memory context, uint256 sigTimeRange);\\n\\n    function validatePaymasterUserOpWithoutSig(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 maxCost\\n    ) external returns (bytes memory context, uint256 sigTimeRange);\\n\\n    /**\\n     * post-operation handler.\\n     * Must verify sender is the entryPoint\\n     * @param mode enum with the following options:\\n     *      opSucceeded - user operation succeeded.\\n     *      opReverted  - user op reverted. still has to pay for gas.\\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\\n     * @param context - the context value returned by validatePaymasterUserOp\\n     * @param actualGasCost - actual gas used so far (without this postOp call).\\n     */\\n    function postOp(\\n        PostOpMode mode,\\n        bytes calldata context,\\n        uint256 actualGasCost\\n    ) external;\\n\\n    enum PostOpMode {\\n        opSucceeded, // user op succeeded\\n        opReverted, // user op reverted. still has to pay for gas.\\n        postOpReverted //user op succeeded, but caused postOp to revert. Now its a 2nd call, after user's op was deliberately reverted.\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISmartAccountProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/**\\n * A wrapper factory contract to deploy SmartAccount as an Account-Abstraction wallet contract.\\n */\\ninterface ISmartAccountProxy {\\n    function masterCopy() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISmartAccountProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\ninterface ISmartAccountProxyFactory {\\n    function safeSingleton(address singleton) external view returns (bool);\\n\\n    function walletWhiteList(address wallet) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by a paymaster.\\n */\\ninterface IStakeManager {\\n    event Deposited(\\n        address from,\\n        address to,\\n        address account,\\n        uint256 increaseDeposit,\\n        uint256 totalDeposit\\n    );\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    event RefundDeposit(address from, address to, uint256 refundAmount);\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 withdrawTime\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit the account's deposit\\n     * @param staked true if this account is staked as a paymaster\\n     * @param stake actual amount of ether staked for this paymaster.\\n     * @param unstakeDelaySec minimum delay to withdraw the stake. must be above the global unstakeDelaySec\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 2^15 eth\\n     *    64 bit for full timestamp\\n     *    32 bit allow 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint64 withdrawTime;\\n    }\\n\\n    //API struct used by getStakeInfo and simulateValidation\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    function getDepositInfo(\\n        address account\\n    ) external view returns (DepositInfo memory info);\\n\\n    /// return the deposit (for gas payment) of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(\\n        address payable withdrawAddress,\\n        uint256 withdrawAmount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\ninterface IStorage {\\n    struct bundlerInformation {\\n        address bundler;\\n        uint256 registeTime;\\n    }\\n    event UnrestrictedWalletSet(bool allowed);\\n    event UnrestrictedBundlerSet(bool allowed);\\n    event UnrestrictedModuleSet(bool allowed);\\n    event WalletFactoryWhitelistSet(address walletProxyFactory);\\n    event BundlerWhitelistSet(address indexed bundler, bool allowed);\\n    event ModuleWhitelistSet(address indexed module, bool allowed);\\n\\n    function officialBundlerWhiteList(\\n        address bundler\\n    ) external view returns (bool);\\n\\n    function moduleWhiteList(address module) external view returns (bool);\\n\\n    function setUnrestrictedWallet(bool allowed) external;\\n\\n    function setUnrestrictedBundler(bool allowed) external;\\n\\n    function setUnrestrictedModule(bool allowed) external;\\n\\n    function setBundlerOfficialWhitelist(\\n        address bundler,\\n        bool allowed\\n    ) external;\\n\\n    function setWalletProxyFactoryWhitelist(address walletFactory) external;\\n\\n    function setModuleWhitelist(address module, bool allowed) external;\\n\\n    function validateModuleWhitelist(address module) external;\\n\\n    function validateWalletWhitelist(address sender) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/library/UserOperation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request\\n * @param nonce unique value the sender uses to verify it is not a replay.\\n * @param initCode if set, the account contract will be created by this constructor\\n * @param callData the method call to execute on this account.\\n * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp\\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n * @param maxFeePerGas same as EIP-1559 gas parameter\\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter\\n * @param paymasterAndData if set, this field hold the paymaster address and \\\"paymaster-specific-data\\\". the paymaster will pay for the transaction instead of the sender\\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct UserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    uint256 callGasLimit;\\n    uint256 verificationGasLimit;\\n    uint256 preVerificationGas;\\n    uint256 maxFeePerGas;\\n    uint256 maxPriorityFeePerGas;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\\nlibrary UserOperationLib {\\n    function getSender(\\n        UserOperation calldata userOp\\n    ) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(\\n        UserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            uint256 maxFeePerGas = userOp.maxFeePerGas;\\n            uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    function pack(\\n        UserOperation calldata userOp\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return\\n            abi.encode(\\n                sender,\\n                nonce,\\n                hashInitCode,\\n                hashCallData,\\n                callGasLimit,\\n                verificationGasLimit,\\n                preVerificationGas,\\n                maxFeePerGas,\\n                maxPriorityFeePerGas,\\n                hashPaymasterAndData\\n            );\\n    }\\n\\n    function calldataKeccak(\\n        bytes calldata data\\n    ) internal pure returns (bytes32 ret) {\\n        assembly {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n    function hash(\\n        UserOperation calldata userOp\\n    ) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"preOpGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymasterDeadline\",\"type\":\"uint256\"}],\"name\":\"ExecutionResult\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"opIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"FailedOp\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SenderAddressResult\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"SignatureValidationFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"preOpGas\",\"type\":\"uint256\"},{\"internalType\":\"enum IPaymaster.PostOpMode\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymasterDeadline\",\"type\":\"uint256\"}],\"name\":\"SimulateHandleOpResult\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"preOpGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prefund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymasterDeadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterContext\",\"type\":\"bytes\"}],\"internalType\":\"struct IEntryPoint.ReturnInfo\",\"name\":\"returnInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeDelaySec\",\"type\":\"uint256\"}],\"internalType\":\"struct IStakeManager.StakeInfo\",\"name\":\"senderInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeDelaySec\",\"type\":\"uint256\"}],\"internalType\":\"struct IStakeManager.StakeInfo\",\"name\":\"factoryInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeDelaySec\",\"type\":\"uint256\"}],\"internalType\":\"struct IStakeManager.StakeInfo\",\"name\":\"paymasterInfo\",\"type\":\"tuple\"}],\"name\":\"ValidationResult\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"preOpGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prefund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymasterDeadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterContext\",\"type\":\"bytes\"}],\"internalType\":\"struct IEntryPoint.ReturnInfo\",\"name\":\"returnInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeDelaySec\",\"type\":\"uint256\"}],\"internalType\":\"struct IStakeManager.StakeInfo\",\"name\":\"senderInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeDelaySec\",\"type\":\"uint256\"}],\"internalType\":\"struct IStakeManager.StakeInfo\",\"name\":\"factoryInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeDelaySec\",\"type\":\"uint256\"}],\"internalType\":\"struct IStakeManager.StakeInfo\",\"name\":\"paymasterInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"actualAggregator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeDelaySec\",\"type\":\"uint256\"}],\"internalType\":\"struct IStakeManager.StakeInfo\",\"name\":\"stakeInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct IEntryPoint.AggregatorStakeInfo\",\"name\":\"aggregatorInfo\",\"type\":\"tuple\"}],\"name\":\"ValidationResultWithAggregation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"}],\"name\":\"AccountDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bundler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"BundlerWhitelistSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increaseDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"revertReason\",\"type\":\"bytes\"}],\"name\":\"HandleUserOpRevertReason\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"ModuleWhitelistSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"}],\"name\":\"RefundDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"SignatureAggregatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"}],\"name\":\"StakeLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"}],\"name\":\"StakeUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"UnrestrictedBundlerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"UnrestrictedModuleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"UnrestrictedWalletSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualGasCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualGasUsed\",\"type\":\"uint256\"}],\"name\":\"UserOperationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"revertReason\",\"type\":\"bytes\"}],\"name\":\"UserOperationRevertReason\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"walletProxyFactory\",\"type\":\"address\"}],\"name\":\"WalletFactoryWhitelistSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NONCE_VALIDATION_FAILED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SIG_VALIDATION_FAILED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"depositTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"deposit\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"staked\",\"type\":\"bool\"},{\"internalType\":\"uint112\",\"name\":\"stake\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"unstakeDelaySec\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"withdrawTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getDepositInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint112\",\"name\":\"deposit\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"staked\",\"type\":\"bool\"},{\"internalType\":\"uint112\",\"name\":\"stake\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"unstakeDelaySec\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"withdrawTime\",\"type\":\"uint64\"}],\"internalType\":\"struct IStakeManager.DepositInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"getSenderAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"getUserOpHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation[]\",\"name\":\"userOps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IAggregator\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct IEntryPoint.UserOpsPerAggregator[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"handleAggregatedOps\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"opIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"}],\"internalType\":\"struct EntryPoint.MemoryUserOp\",\"name\":\"mUserOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"prefund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contextOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preOpGas\",\"type\":\"uint256\"}],\"internalType\":\"struct EntryPoint.UserOpInfo\",\"name\":\"outOpInfo\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"handleOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation[]\",\"name\":\"ops\",\"type\":\"tuple[]\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"handleOps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation[]\",\"name\":\"ops\",\"type\":\"tuple[]\"}],\"name\":\"handleOps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"}],\"internalType\":\"struct EntryPoint.MemoryUserOp\",\"name\":\"mUserOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"prefund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contextOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preOpGas\",\"type\":\"uint256\"}],\"internalType\":\"struct EntryPoint.UserOpInfo\",\"name\":\"opInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"innerHandleOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"actualGasCost\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"}],\"internalType\":\"struct EntryPoint.MemoryUserOp\",\"name\":\"mUserOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"prefund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contextOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preOpGas\",\"type\":\"uint256\"}],\"internalType\":\"struct EntryPoint.UserOpInfo\",\"name\":\"opInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"innerHandleOpWithResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"actualGasCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"callGasCost\",\"type\":\"uint256\"},{\"internalType\":\"enum IPaymaster.PostOpMode\",\"name\":\"postOpMode\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"excuteResult\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"moduleWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"officialBundlerWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bundler\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setBundlerOfficialWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setModuleWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setUnrestrictedBundler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setUnrestrictedModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setUnrestrictedWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"walletFactory\",\"type\":\"address\"}],\"name\":\"setWalletProxyFactoryWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"op\",\"type\":\"tuple\"}],\"name\":\"simulateHandleOp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"op\",\"type\":\"tuple\"}],\"name\":\"simulateHandleOpWithoutSig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"simulateValidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"op\",\"type\":\"tuple\"}],\"name\":\"simulateValidationWithWalletWhitelistValidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unrestrictedBundler\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unrestrictedModule\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unrestrictedWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"validateModuleWhitelist\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"validateWalletWhitelist\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletProxyFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EntryPoint", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000794b93902449c524c3158f9e101204ecb2057f2e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}