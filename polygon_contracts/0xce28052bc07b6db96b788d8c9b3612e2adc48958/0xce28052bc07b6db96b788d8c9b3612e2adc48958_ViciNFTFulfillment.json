{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ViciNFTFulfillment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"IAccessControl.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IERC721.sol\\\";\\nimport \\\"IERC1155.sol\\\";\\nimport \\\"IERC165.sol\\\";\\nimport \\\"ConduitInterface.sol\\\";\\nimport \\\"ConduitControllerInterface.sol\\\";\\nimport \\\"ConsiderationEventsAndErrors.sol\\\";\\nimport \\\"ConsiderationInterface.sol\\\";\\nimport \\\"SeaportEnums.sol\\\";\\nimport \\\"SeaportStructs.sol\\\";\\n\\nimport \\\"ViciAccess.sol\\\";\\nimport \\\"Wallet.sol\\\";\\nimport \\\"AddressUtils.sol\\\";\\n\\ncontract ViciNFTFulfillment is\\n    ViciAccess,\\n    Wallet,\\n    ConsiderationEventsAndErrors\\n{\\n    ConsiderationInterface public orderFiller;\\n    ConduitControllerInterface public conduitController;\\n    ConduitInterface public conduit;\\n    bytes32 public conduitKey;\\n\\n    bytes32 public constant DISPATCHER_ROLE = keccak256(\\\"DISPATCHER_ROLE\\\");\\n    bytes32 public constant WALLET_MANAGER = keccak256(\\\"WALLET_MANAGER\\\");\\n\\n    mapping(ItemType => ConduitItemType) offerTypeToConduitType;\\n\\n    /* ################################################################\\n     *                        Initialization\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev the initializer function\\n     * @param _accessServer The Access Server contract\\n     * @param _orderFiller The contract that fills the orders, either OpenSea's\\n     * contract or a custom order filler.\\n     * @param _conduitSuffix a value appended to this contract's address to\\n     *   generate the conduit key.\\n     */\\n    function initialize(\\n        IAccessServer _accessServer,\\n        ConsiderationInterface _orderFiller,\\n        bytes12 _conduitSuffix\\n    ) public virtual initializer {\\n        __FulfillmentCenter_init(_accessServer, _orderFiller, _conduitSuffix);\\n    }\\n\\n    function __FulfillmentCenter_init(\\n        IAccessServer _accessServer,\\n        ConsiderationInterface _orderFiller,\\n        bytes12 _conduitSuffix\\n    ) internal onlyInitializing {\\n        __ViciAccess_init(_accessServer);\\n        __FulfillmentCenter_init_unchained(_orderFiller, _conduitSuffix);\\n    }\\n\\n    function __FulfillmentCenter_init_unchained(\\n        ConsiderationInterface _orderFiller,\\n        bytes12 _conduitSuffix\\n    ) internal onlyInitializing {\\n        setOrderFiller(_orderFiller);\\n        initConduit(_conduitSuffix);\\n        updateChannel(address(this), true);\\n        updateChannel(address(orderFiller), true);\\n\\n        offerTypeToConduitType[ItemType.NATIVE] = ConduitItemType.NATIVE;\\n        offerTypeToConduitType[ItemType.ERC20] = ConduitItemType.ERC20;\\n        offerTypeToConduitType[ItemType.ERC721] = ConduitItemType.ERC721;\\n        offerTypeToConduitType[ItemType.ERC721_WITH_CRITERIA] = ConduitItemType\\n            .ERC721;\\n        offerTypeToConduitType[ItemType.ERC1155] = ConduitItemType.ERC1155;\\n        offerTypeToConduitType[ItemType.ERC1155_WITH_CRITERIA] = ConduitItemType\\n            .ERC1155;\\n    }\\n\\n    /**\\n     * @dev Sets the contract used to fill orders, and grabs a reference to\\n     * its conduit controller.\\n     *\\n     * @param _orderFiller The contract that fills the orders, either OpenSea's\\n     * contract or a custom order filler.\\n     *\\n     * Requirements\\n     * ----------\\n     * - Caller must be the contract owner or have the DISPATCHER role.\\n     */\\n    function setOrderFiller(\\n        ConsiderationInterface _orderFiller\\n    ) public onlyOwnerOrRole(DISPATCHER_ROLE) {\\n        orderFiller = _orderFiller;\\n\\n        (, , address conduitControllerAddr) = _orderFiller.information();\\n        conduitController = ConduitControllerInterface(conduitControllerAddr);\\n    }\\n\\n    /**\\n     * @dev Generates a conduit key and creates a conduit.\\n     *\\n     * @param _conduitSuffix a value appended to this contract's address to\\n     *   generate the conduit key.\\n     */\\n    function initConduit(\\n        bytes12 _conduitSuffix\\n    ) public virtual onlyOwnerOrRole(DISPATCHER_ROLE) {\\n        conduitKey =\\n            bytes32(bytes20(address(this))) |\\n            (bytes32(_conduitSuffix) >> 160);\\n        (address conduitAddress, bool exists) = conduitController.getConduit(\\n            conduitKey\\n        );\\n        if (!exists) {\\n            conduitAddress = conduitController.createConduit(\\n                conduitKey,\\n                address(this)\\n            );\\n        }\\n        conduit = ConduitInterface(conduitAddress);\\n    }\\n\\n    /**\\n     * @notice Open or close a channel on our conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     * @notice Do not open a channel for an account you do not trust, because\\n     *         those accounts can transfer any ERC20, ERC721, and ERC1155 tokens\\n     *         where the token holder has granted the conduit approval.\\n     *\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     *\\n     * Requirements\\n     * ----------\\n     * - Caller must be the contract owner or have the DISPATCHER role.\\n     */\\n    function updateChannel(\\n        address channel,\\n        bool isOpen\\n    ) public onlyOwnerOrRole(DISPATCHER_ROLE) {\\n        conduitController.updateChannel(address(conduit), channel, isOpen);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(Wallet, ViciAccess) returns (bool) {\\n        return\\n            Wallet.supportsInterface(interfaceId) ||\\n            ViciAccess.supportsInterface(interfaceId);\\n    }\\n\\n    /* ################################################################\\n     *                        Token Approvals\\n     * ##############################################################*/\\n\\n    /**\\n     * @notice Allows the conduit to fill orders using the specified\\n     * consideration token.\\n     * @param tokenAddress the consideration token\\n     * @param itemType What is this token?\\n     *\\n     * Requirements:\\n     * - caller MUST be the contract owner or have the WALLET_MANAGER role.\\n     */\\n    function approveConsiderationToken(\\n        address tokenAddress,\\n        ItemType itemType\\n    ) public virtual onlyOwnerOrRole(WALLET_MANAGER) {\\n        if (itemType == ItemType.ERC20) {\\n            IERC20(tokenAddress).approve(\\n                address(conduit),\\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE\\n            );\\n        } else if (\\n            itemType == ItemType.ERC721 ||\\n            itemType == ItemType.ERC721_WITH_CRITERIA\\n        ) {\\n            IERC721(tokenAddress).setApprovalForAll(address(conduit), true);\\n        } else if (\\n            itemType == ItemType.ERC1155 ||\\n            itemType == ItemType.ERC1155_WITH_CRITERIA\\n        ) {\\n            IERC1155(tokenAddress).setApprovalForAll(address(conduit), true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Disallows the conduit from filling orders using the specified\\n     * consideration token.\\n     * @param tokenAddress the consideration token\\n     * @param itemType What is this token?\\n     *\\n     * Requirements:\\n     * - caller MUST be the contract owner or have the WALLET_MANAGER role.\\n     */\\n    function unapproveConsiderationToken(\\n        address tokenAddress,\\n        ItemType itemType\\n    ) public virtual onlyOwnerOrRole(WALLET_MANAGER) {\\n        if (itemType == ItemType.ERC20) {\\n            IERC20(tokenAddress).approve(address(conduit), 0);\\n        } else if (\\n            itemType == ItemType.ERC721 ||\\n            itemType == ItemType.ERC721_WITH_CRITERIA\\n        ) {\\n            IERC721(tokenAddress).setApprovalForAll(address(conduit), false);\\n        } else if (\\n            itemType == ItemType.ERC1155 ||\\n            itemType == ItemType.ERC1155_WITH_CRITERIA\\n        ) {\\n            IERC1155(tokenAddress).setApprovalForAll(address(conduit), false);\\n        }\\n    }\\n\\n    /* ################################################################\\n     *                       Preflight Checks\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Verifies that the conduit has been approved by `participant` for\\n     * at least `amount` of `token`.  Also verfies `participant` has a\\n     * sufficient balance if `checkApprovalOnly` is false.\\n     */\\n    function preflightERC20Check(\\n        IERC20 token,\\n        uint256 amount,\\n        address participant,\\n        bool checkApprovalOnly\\n    ) public view virtual returns (bool) {\\n        require(participant != address(0), \\\"InvalidParticipant\\\");\\n        require(AddressUtils.isContract(address(token)), \\\"InvalidERC20Address\\\");\\n\\n        try token.allowance(participant, address(conduit)) returns (\\n            uint256 allowed\\n        ) {\\n            require(allowed >= amount, \\\"ERC20NotApproved\\\");\\n        } catch {\\n            revert(\\\"InvalidERC20Address\\\");\\n        }\\n\\n        uint256 erc20Balance = token.balanceOf(participant);\\n        require(\\n            checkApprovalOnly || erc20Balance >= amount,\\n            \\\"InsufficientERC20Balance\\\"\\n        );\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Verifies that the conduit has been approved by `participant` for\\n     * `token`.  Also verfies `participant` owns the tokenid if `\\n     * checkApprovalOnly` is false.\\n     */\\n    function preflightERC721Check(\\n        IERC721 token,\\n        uint256 tokenId,\\n        address participant,\\n        bool checkApprovalOnly\\n    ) public view virtual returns (bool) {\\n        require(participant != address(0), \\\"InvalidParticipant\\\");\\n        require(\\n            AddressUtils.isContract(address(token)),\\n            \\\"InvalidERC721Address\\\"\\n        );\\n\\n        // bytes memory data = abi.encodeWithSelector(IERC721.balanceOf.selector, participant);\\n        // AddressUtils.functionStaticCall(address(token), data, \\\"InvalidERC721Address\\\");\\n\\n        // reverts for ERC1155 but not ERC20\\n        try token.balanceOf(participant) returns (uint256) {} catch {\\n            revert(\\\"InvalidERC721Address\\\");\\n        }\\n\\n        // reverts for ERC20 but not ERC1155\\n        try token.isApprovedForAll(participant, address(conduit)) returns (\\n            bool approved\\n        ) {\\n            require(approved, \\\"ERC721NotApproved\\\");\\n        } catch {\\n            revert(\\\"InvalidERC721Address\\\");\\n        }\\n\\n        if (!checkApprovalOnly) {\\n            try token.ownerOf(tokenId) returns (address tokenOwner) {\\n                require(tokenOwner == participant, \\\"InsufficientERC721Balance\\\");\\n            } catch {\\n                revert(\\\"ERC721: Nonexistent Token\\\");\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Verifies that the conduit has been approved by `participant` for\\n     * at least `amount` of `token`.  Also verfies `participant` has a\\n     * sufficient balance if `checkApprovalOnly` is false.\\n     */\\n    function preflightERC1155Check(\\n        IERC1155 token,\\n        uint256 amount,\\n        uint256 tokenId,\\n        address participant,\\n        bool checkApprovalOnly\\n    ) public view virtual returns (bool) {\\n        require(participant != address(0), \\\"InvalidParticipant\\\");\\n        require(\\n            AddressUtils.isContract(address(token)),\\n            \\\"InvalidERC1155Address\\\"\\n        );\\n        uint256 erc1155Balance;\\n        try token.balanceOf(participant, tokenId) returns (uint256 balance) {\\n            erc1155Balance = balance;\\n        } catch {\\n            revert(\\\"InvalidERC1155Address\\\");\\n        }\\n\\n        require(\\n            token.isApprovedForAll(participant, address(conduit)),\\n            \\\"ERC1155NotApproved\\\"\\n        );\\n\\n        require(\\n            checkApprovalOnly || erc1155Balance >= amount,\\n            \\\"InsufficientERC1155Balance\\\"\\n        );\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Verifies that the conduit has been approved by `participant` for\\n     * at least `amount` of `token`.  Also verfies `participant` has a\\n     * sufficient balance if `checkApprovalOnly` is false.\\n     */\\n    function preflightItemCheck(\\n        ConduitItemType itemType,\\n        address token,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address participant,\\n        bool checkApprovalOnly\\n    ) public view virtual returns (bool) {\\n        if (itemType == ConduitItemType.ERC20) {\\n            preflightERC20Check(\\n                IERC20(token),\\n                amount,\\n                participant,\\n                checkApprovalOnly\\n            );\\n        } else if (itemType == ConduitItemType.ERC721) {\\n            preflightERC721Check(\\n                IERC721(token),\\n                tokenId,\\n                participant,\\n                checkApprovalOnly\\n            );\\n        } else if (itemType == ConduitItemType.ERC1155) {\\n            preflightERC1155Check(\\n                IERC1155(token),\\n                amount,\\n                tokenId,\\n                participant,\\n                checkApprovalOnly\\n            );\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Reverts with an error if the values describe a fillOrder\\n     * transaction that is expected to fail.\\n     *\\n     * @dev Verifies that\\n     * - this contract has approved all of the consideration tokens for any\\n     *   required amounts\\n     * - this contract has approved all of the offer tokens, so it can use\\n     *   the conduit to tranfer them\\n     * - this contract has sufficient balances to fulfill the transaction\\n     * - the offerer has approved all of the offer tokens for any required\\n     *   amounts\\n     * - if `premint` is false, the offerer has sufficient balances to fulfill\\n     *   the transaction\\n     * @dev Send `premint`=`false` if the offer tokens are expected to already\\n     * exist.\\n     * @dev Send `premint`=`true` if the offer tokens will be minted to the\\n     * offerer's wallet prior to calling fulfill.\\n     */\\n    function fulfillPreflightCheck(\\n        address offerer,\\n        ConsiderationItem[] calldata considerations,\\n        OfferItem[] calldata offers,\\n        bool premintCheck\\n    ) public view virtual returns (bool) {\\n        for (uint256 i = 0; i < considerations.length; i++) {\\n            ConsiderationItem memory item = considerations[i];\\n            // this contract needs to have granted permission to conduit\\n            // this contract needs to own the consideration items\\n            preflightItemCheck(\\n                offerTypeToConduitType[item.itemType],\\n                item.token,\\n                item.identifierOrCriteria,\\n                item.startAmount,\\n                address(this),\\n                false\\n            );\\n        }\\n        for (uint256 i = 0; i < offers.length; i++) {\\n            OfferItem memory item = offers[i];\\n            // offerer needs to have granted permission to conduit\\n            // if not premint check, offer must own offer items\\n            preflightItemCheck(\\n                offerTypeToConduitType[item.itemType],\\n                item.token,\\n                item.identifierOrCriteria,\\n                item.startAmount,\\n                offerer,\\n                premintCheck\\n            );\\n            // this contract needs to have granted permission to conduit\\n            preflightItemCheck(\\n                offerTypeToConduitType[item.itemType],\\n                item.token,\\n                item.identifierOrCriteria,\\n                item.startAmount,\\n                address(this),\\n                true\\n            );\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Reverts with an error if the values describe a transfer\\n     * transaction that is expected to fail.\\n     *\\n     * @dev Verifies that\\n     * - Each `transfers.from` has approved each transfer token for any\\n     *   required amounts\\n     * - Each `transfers.from` has sufficient balances\\n     */\\n    function transferPreflightCheck(\\n        ConduitTransfer[] calldata transfers\\n    ) public view virtual returns (bool) {\\n        for (uint256 i = 0; i < transfers.length; i++) {\\n            ConduitTransfer memory transfer = transfers[i];\\n            preflightItemCheck(\\n                transfer.itemType,\\n                transfer.token,\\n                transfer.identifier,\\n                transfer.amount,\\n                transfer.from,\\n                false\\n            );\\n        }\\n        return true;\\n    }\\n\\n    /* ################################################################\\n     *                       Order Processing\\n     * ##############################################################*/\\n\\n    function getCounter(address offerer) public view returns (uint256) {\\n        return orderFiller.getCounter(offerer);\\n    }\\n\\n    /**\\n     * @notice Fills the order, then transfers all of the offer items to\\n     * `customer`.\\n     *\\n     * @param sellOrder The order to fulfill.\\n     * @param customer The customer.\\n     *\\n     * Requirements\\n     * ----------\\n     * - caller MUST be the contract owner or have the WALLET_MANAGER role.\\n     * - This contract MUST have approved the conduit for all consideration\\n     *   tokens\\n     * - This contract MUST have approved the conduit for all offer tokens\\n     * - The offerer MUST have approved the conduit for all offer tokens\\n     * - This contract MUST have sufficient balances of all consideration\\n     *   tokens\\n     * - The offerer MUST have sufficient balances of all offer tokens\\n     */\\n    function fillAndTransfer(\\n        Order calldata sellOrder,\\n        address customer\\n    ) public payable virtual onlyOwnerOrRole(DISPATCHER_ROLE) {\\n        if (\\n            !orderFiller.fulfillOrder(\\n                sellOrder,\\n                sellOrder.parameters.conduitKey\\n            )\\n        ) {\\n            revert(string(abi.encodePacked(\\\"Order for \\\", customer, \\\" failed\\\")));\\n        }\\n\\n        ConduitTransfer[] memory transfers = offerToConduitTransfer(\\n            sellOrder.parameters.offer,\\n            address(this),\\n            customer\\n        );\\n\\n        conduit.execute(transfers);\\n    }\\n\\n    /**\\n     * @dev convenience function to convert OfferItem structs to\\n     * ConduitTransfer structs.\\n     */\\n    function offerToConduitTransfer(\\n        OfferItem[] calldata stuff,\\n        address fromAddress,\\n        address toAddress\\n    ) public pure virtual returns (ConduitTransfer[] memory transfers) {\\n        transfers = new ConduitTransfer[](stuff.length);\\n        for (uint256 i = 0; i < stuff.length; i++) {\\n            OfferItem memory offer = stuff[i];\\n            transfers[i] = ConduitTransfer(\\n                ConduitItemType(uint8(offer.itemType)),\\n                offer.token,\\n                fromAddress,\\n                toAddress,\\n                offer.identifierOrCriteria,\\n                offer.startAmount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Use the conduit to perform a batch of transfers.\\n     */\\n    function batchTransfer(\\n        ConduitTransfer[] calldata transfers\\n    ) public payable virtual onlyOwnerOrRole(DISPATCHER_ROLE) {\\n        conduit.execute(transfers);\\n    }\\n\\n    /* ################################################################\\n     *                       Withdrawals\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Withdraw native crypto.\\n     * @notice Emits Withdraw\\n     * @param toAddress Where to send the crypto\\n     * @param amount The amount to send\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner\\n     */\\n    function withdraw(\\n        address payable toAddress,\\n        uint256 amount\\n    ) public onlyOwner {\\n        super._withdraw(toAddress, amount);\\n    }\\n\\n    /**\\n     * @dev Withdraw ERC20 tokens.\\n     * @notice Emits WithdrawERC20\\n     * @param toAddress Where to send the ERC20 tokens\\n     * @param tokenContract The ERC20 token contract\\n     * @param amount The amount withdrawn\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner\\n     */\\n    function withdrawERC20(\\n        address payable toAddress,\\n        uint256 amount,\\n        IERC20 tokenContract\\n    ) public onlyOwner {\\n        super._withdrawERC20(toAddress, amount, tokenContract);\\n    }\\n\\n    /**\\n     * @dev Withdraw an NFT.\\n     * @notice Emits WithdrawERC721\\n     * @param toAddress Where to send the NFT\\n     * @param tokenContract The NFT contract\\n     * @param tokenId The id of the NFT\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner\\n     */\\n    function withdrawERC721(\\n        address payable toAddress,\\n        uint256 tokenId,\\n        IERC721 tokenContract\\n    ) public onlyOwner {\\n        super._withdrawERC721(toAddress, tokenId, tokenContract);\\n    }\\n\\n    /**\\n     * @dev Withdraw ERC777 tokens.\\n     * @notice Emits WithdrawERC777\\n     * @param toAddress Where to send the ERC777 tokens\\n     * @param tokenContract The ERC777 token contract\\n     * @param amount The amount withdrawn\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner\\n     */\\n    function withdrawERC777(\\n        address payable toAddress,\\n        uint256 amount,\\n        IERC777 tokenContract\\n    ) public onlyOwner {\\n        super._withdrawERC777(toAddress, amount, tokenContract);\\n    }\\n\\n    /**\\n     * @dev Withdraw semi-fungible tokens.\\n     * @notice Emits WithdrawERC1155\\n     * @param toAddress Where to send the semi-fungible tokens\\n     * @param tokenContract The semi-fungible token contract\\n     * @param tokenId The id of the semi-fungible tokens\\n     * @param amount The number of tokens withdrawn\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner\\n     */\\n    function withdrawERC1155(\\n        address payable toAddress,\\n        uint256 tokenId,\\n        uint256 amount,\\n        IERC1155 tokenContract\\n    ) public onlyOwner {\\n        super._withdrawERC1155(toAddress, tokenId, amount, tokenContract);\\n    }\\n}\\n\"\r\n    },\r\n    \"IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"ConduitInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"SeaportStructs.sol\\\";\\n\\n/**\\n * @title ConduitInterface\\n * @author 0age\\n * @notice ConduitInterface contains all external function interfaces, events,\\n *         and errors for conduit contracts.\\n */\\ninterface ConduitInterface {\\n    /**\\n     * @dev Revert with an error when attempting to execute transfers using a\\n     *      caller that does not have an open channel.\\n     */\\n    error ChannelClosed(address channel);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update a channel to the\\n     *      current status of that channel.\\n     */\\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\\n\\n    /**\\n     * @dev Revert with an error when attempting to execute a transfer for an\\n     *      item that does not have an ERC20/721/1155 item type.\\n     */\\n    error InvalidItemType();\\n\\n    /**\\n     * @dev Revert with an error when attempting to update the status of a\\n     *      channel from a caller that is not the conduit controller.\\n     */\\n    error InvalidController();\\n\\n    /**\\n     * @dev Emit an event whenever a channel is opened or closed.\\n     *\\n     * @param channel The channel that has been updated.\\n     * @param open    A boolean indicating whether the conduit is open or not.\\n     */\\n    event ChannelUpdated(address indexed channel, bool open);\\n\\n    /**\\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\\n     *         with an open channel can call this function.\\n     *\\n     * @param transfers The ERC20/721/1155 transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function execute(\\n        ConduitTransfer[] calldata transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\\n     *         open channel can call this function.\\n     *\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeBatch1155(\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\\n     *         a caller with an open channel can call this function.\\n     *\\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\\n     * @param batch1155Transfers The 1155 batch transfers to perform.\\n     *\\n     * @return magicValue A magic value indicating that the transfers were\\n     *                    performed successfully.\\n     */\\n    function executeWithBatch1155(\\n        ConduitTransfer[] calldata standardTransfers,\\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\\n    ) external returns (bytes4 magicValue);\\n\\n    /**\\n     * @notice Open or close a given channel. Only callable by the controller.\\n     *\\n     * @param channel The channel to open or close.\\n     * @param isOpen  The status of the channel (either open or closed).\\n     */\\n    function updateChannel(address channel, bool isOpen) external;\\n}\\n\"\r\n    },\r\n    \"SeaportStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"SeaportEnums.sol\\\";\\n\\n/**\\n * @dev An order contains eleven components: an offerer, a zone (or account that\\n *      can cancel the order or restrict who can fulfill the order depending on\\n *      the type), the order type (specifying partial fill support as well as\\n *      restricted order status), the start and end time, a hash that will be\\n *      provided to the zone when validating restricted orders, a salt, a key\\n *      corresponding to a given conduit, a counter, and an arbitrary number of\\n *      offer items that can be spent along with consideration items that must\\n *      be received by their respective recipient.\\n */\\nstruct OrderComponents {\\n    address offerer;\\n    address zone;\\n    OfferItem[] offer;\\n    ConsiderationItem[] consideration;\\n    OrderType orderType;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n    uint256 salt;\\n    bytes32 conduitKey;\\n    uint256 counter;\\n}\\n\\n/**\\n * @dev An offer item has five components: an item type (ETH or other native\\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\\n *      ERC1155), a token address, a dual-purpose \\\"identifierOrCriteria\\\"\\n *      component that will either represent a tokenId or a merkle root\\n *      depending on the item type, and a start and end amount that support\\n *      increasing or decreasing amounts over the duration of the respective\\n *      order.\\n */\\nstruct OfferItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n}\\n\\n/**\\n * @dev A consideration item has the same five components as an offer item and\\n *      an additional sixth component designating the required recipient of the\\n *      item.\\n */\\nstruct ConsiderationItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev A spent item is translated from a utilized offer item and has four\\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\\n *      ERC1155), a token address, a tokenId, and an amount.\\n */\\nstruct SpentItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A received item is translated from a utilized consideration item and has\\n *      the same four components as a spent item, as well as an additional fifth\\n *      component designating the required recipient of the item.\\n */\\nstruct ReceivedItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\\n *      matching, a group of six functions may be called that only requires a\\n *      subset of the usual order arguments. Note the use of a \\\"basicOrderType\\\"\\n *      enum; this represents both the usual order type as well as the \\\"route\\\"\\n *      of the basic order (a simple derivation function for the basic order\\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\\n */\\nstruct BasicOrderParameters {\\n    // calldata offset\\n    address considerationToken; // 0x24\\n    uint256 considerationIdentifier; // 0x44\\n    uint256 considerationAmount; // 0x64\\n    address payable offerer; // 0x84\\n    address zone; // 0xa4\\n    address offerToken; // 0xc4\\n    uint256 offerIdentifier; // 0xe4\\n    uint256 offerAmount; // 0x104\\n    BasicOrderType basicOrderType; // 0x124\\n    uint256 startTime; // 0x144\\n    uint256 endTime; // 0x164\\n    bytes32 zoneHash; // 0x184\\n    uint256 salt; // 0x1a4\\n    bytes32 offererConduitKey; // 0x1c4\\n    bytes32 fulfillerConduitKey; // 0x1e4\\n    uint256 totalOriginalAdditionalRecipients; // 0x204\\n    AdditionalRecipient[] additionalRecipients; // 0x224\\n    bytes signature; // 0x244\\n    // Total length, excluding dynamic array data: 0x264 (580)\\n}\\n\\n/**\\n * @dev Basic orders can supply any number of additional recipients, with the\\n *      implied assumption that they are supplied from the offered ETH (or other\\n *      native token) or ERC20 token for the order.\\n */\\nstruct AdditionalRecipient {\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev The full set of order components, with the exception of the counter,\\n *      must be supplied when fulfilling more sophisticated orders or groups of\\n *      orders. The total number of original consideration items must also be\\n *      supplied, as the caller may specify additional consideration items.\\n */\\nstruct OrderParameters {\\n    address offerer; // 0x00\\n    address zone; // 0x20\\n    OfferItem[] offer; // 0x40\\n    ConsiderationItem[] consideration; // 0x60\\n    OrderType orderType; // 0x80\\n    uint256 startTime; // 0xa0\\n    uint256 endTime; // 0xc0\\n    bytes32 zoneHash; // 0xe0\\n    uint256 salt; // 0x100\\n    bytes32 conduitKey; // 0x120\\n    uint256 totalOriginalConsiderationItems; // 0x140\\n    // offer.length                          // 0x160\\n}\\n\\n/**\\n * @dev Orders require a signature in addition to the other order parameters.\\n */\\nstruct Order {\\n    OrderParameters parameters;\\n    bytes signature;\\n}\\n\\n/**\\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\\n *      and a denominator (the total size of the order) in addition to the\\n *      signature and other order parameters. It also supports an optional field\\n *      for supplying extra data; this data will be provided to the zone if the\\n *      order type is restricted and the zone is not the caller, or will be\\n *      provided to the offerer as context for contract order types.\\n */\\nstruct AdvancedOrder {\\n    OrderParameters parameters;\\n    uint120 numerator;\\n    uint120 denominator;\\n    bytes signature;\\n    bytes extraData;\\n}\\n\\n/**\\n * @dev Orders can be validated (either explicitly via `validate`, or as a\\n *      consequence of a full or partial fill), specifically cancelled (they can\\n *      also be cancelled in bulk via incrementing a per-zone counter), and\\n *      partially or fully filled (with the fraction filled represented by a\\n *      numerator and denominator).\\n */\\nstruct OrderStatus {\\n    bool isValidated;\\n    bool isCancelled;\\n    uint120 numerator;\\n    uint120 denominator;\\n}\\n\\n/**\\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\\n *      alongside a merkle proof demonstrating the identifier meets the required\\n *      criteria.\\n */\\nstruct CriteriaResolver {\\n    uint256 orderIndex;\\n    Side side;\\n    uint256 index;\\n    uint256 identifier;\\n    bytes32[] criteriaProof;\\n}\\n\\n/**\\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\\n *      offer and consideration items, then generates a single execution\\n *      element. A given fulfillment can be applied to as many offer and\\n *      consideration items as desired, but must contain at least one offer and\\n *      at least one consideration that match. The fulfillment must also remain\\n *      consistent on all key parameters across all offer items (same offerer,\\n *      token, type, tokenId, and conduit preference) as well as across all\\n *      consideration items (token, type, tokenId, and recipient).\\n */\\nstruct Fulfillment {\\n    FulfillmentComponent[] offerComponents;\\n    FulfillmentComponent[] considerationComponents;\\n}\\n\\n/**\\n * @dev Each fulfillment component contains one index referencing a specific\\n *      order and another referencing a specific offer or consideration item.\\n */\\nstruct FulfillmentComponent {\\n    uint256 orderIndex;\\n    uint256 itemIndex;\\n}\\n\\n/**\\n * @dev An execution is triggered once all consideration items have been zeroed\\n *      out. It sends the item in question from the offerer to the item's\\n *      recipient, optionally sourcing approvals from either this contract\\n *      directly or from the offerer's chosen conduit if one is specified. An\\n *      execution is not provided as an argument, but rather is derived via\\n *      orders, criteria resolvers, and fulfillments (where the total number of\\n *      executions will be less than or equal to the total number of indicated\\n *      fulfillments) and returned as part of `matchOrders`.\\n */\\nstruct Execution {\\n    ReceivedItem item;\\n    address offerer;\\n    bytes32 conduitKey;\\n}\\n\\n/**\\n * @dev Restricted orders are validated post-execution by calling validateOrder\\n *      on the zone. This struct provides context about the order fulfillment\\n *      and any supplied extraData, as well as all order hashes fulfilled in a\\n *      call to a match or fulfillAvailable method.\\n */\\nstruct ZoneParameters {\\n    bytes32 orderHash;\\n    address fulfiller;\\n    address offerer;\\n    SpentItem[] offer;\\n    ReceivedItem[] consideration;\\n    bytes extraData;\\n    bytes32[] orderHashes;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n}\\n\\n/**\\n * @dev Zones and contract offerers can communicate which schemas they implement\\n *      along with any associated metadata related to each schema.\\n */\\nstruct Schema {\\n    uint256 id;\\n    bytes metadata;\\n}\\n\\n/**\\n * @dev A ConduitTransfer is a struct that contains the information needed for a\\n *      conduit to transfer an item from one address to another.\\n */\\nstruct ConduitTransfer {\\n    ConduitItemType itemType;\\n    address token;\\n    address from;\\n    address to;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A ConduitBatch1155Transfer is a struct that contains the information\\n *      needed for a conduit to transfer a batch of ERC-1155 tokens from one\\n *      address to another.\\n */\\nstruct ConduitBatch1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256[] ids;\\n    uint256[] amounts;\\n}\\n\"\r\n    },\r\n    \"SeaportEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nenum OrderType {\\n    // 0: no partial fills, anyone can execute\\n    FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    PARTIAL_RESTRICTED,\\n\\n    // 4: contract order type\\n    CONTRACT\\n}\\n\\nenum BasicOrderType {\\n    // 0: no partial fills, anyone can execute\\n    ETH_TO_ERC721_FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    ETH_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 4: no partial fills, anyone can execute\\n    ETH_TO_ERC1155_FULL_OPEN,\\n\\n    // 5: partial fills supported, anyone can execute\\n    ETH_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 6: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 7: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 8: no partial fills, anyone can execute\\n    ERC20_TO_ERC721_FULL_OPEN,\\n\\n    // 9: partial fills supported, anyone can execute\\n    ERC20_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 10: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 11: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 12: no partial fills, anyone can execute\\n    ERC20_TO_ERC1155_FULL_OPEN,\\n\\n    // 13: partial fills supported, anyone can execute\\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 14: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 15: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 16: no partial fills, anyone can execute\\n    ERC721_TO_ERC20_FULL_OPEN,\\n\\n    // 17: partial fills supported, anyone can execute\\n    ERC721_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 18: no partial fills, only offerer or zone can execute\\n    ERC721_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 19: partial fills supported, only offerer or zone can execute\\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\\n\\n    // 20: no partial fills, anyone can execute\\n    ERC1155_TO_ERC20_FULL_OPEN,\\n\\n    // 21: partial fills supported, anyone can execute\\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 22: no partial fills, only offerer or zone can execute\\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 23: partial fills supported, only offerer or zone can execute\\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\\n}\\n\\nenum BasicOrderRouteType {\\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\\n    ETH_TO_ERC721,\\n\\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\\n    ETH_TO_ERC1155,\\n\\n    // 2: provide ERC20 item to receive offered ERC721 item.\\n    ERC20_TO_ERC721,\\n\\n    // 3: provide ERC20 item to receive offered ERC1155 item.\\n    ERC20_TO_ERC1155,\\n\\n    // 4: provide ERC721 item to receive offered ERC20 item.\\n    ERC721_TO_ERC20,\\n\\n    // 5: provide ERC1155 item to receive offered ERC20 item.\\n    ERC1155_TO_ERC20\\n}\\n\\nenum ItemType {\\n    // 0: ETH on mainnet, MATIC on polygon, etc.\\n    NATIVE,\\n\\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\\n    ERC20,\\n\\n    // 2: ERC721 items\\n    ERC721,\\n\\n    // 3: ERC1155 items\\n    ERC1155,\\n\\n    // 4: ERC721 items where a number of tokenIds are supported\\n    ERC721_WITH_CRITERIA,\\n\\n    // 5: ERC1155 items where a number of ids are supported\\n    ERC1155_WITH_CRITERIA\\n}\\n\\nenum Side {\\n    // 0: Items that can be spent\\n    OFFER,\\n\\n    // 1: Items that must be received\\n    CONSIDERATION\\n}\\n\\nenum ConduitItemType {\\n    NATIVE, // unused\\n    ERC20,\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"ConduitControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title ConduitControllerInterface\\n * @author 0age\\n * @notice ConduitControllerInterface contains all external function interfaces,\\n *         structs, events, and errors for the conduit controller.\\n */\\ninterface ConduitControllerInterface {\\n    /**\\n     * @dev Track the conduit key, current owner, new potential owner, and open\\n     *      channels for each deployed conduit.\\n     */\\n    struct ConduitProperties {\\n        bytes32 key;\\n        address owner;\\n        address potentialOwner;\\n        address[] channels;\\n        mapping(address => uint256) channelIndexesPlusOne;\\n    }\\n\\n    /**\\n     * @dev Emit an event whenever a new conduit is created.\\n     *\\n     * @param conduit    The newly created conduit.\\n     * @param conduitKey The conduit key used to create the new conduit.\\n     */\\n    event NewConduit(address conduit, bytes32 conduitKey);\\n\\n    /**\\n     * @dev Emit an event whenever conduit ownership is transferred.\\n     *\\n     * @param conduit       The conduit for which ownership has been\\n     *                      transferred.\\n     * @param previousOwner The previous owner of the conduit.\\n     * @param newOwner      The new owner of the conduit.\\n     */\\n    event OwnershipTransferred(\\n        address indexed conduit,\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever a conduit owner registers a new potential\\n     *      owner for that conduit.\\n     *\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit using a\\n     *      conduit key where the first twenty bytes of the key do not match the\\n     *      address of the caller.\\n     */\\n    error InvalidCreator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit when no\\n     *      initial owner address is supplied.\\n     */\\n    error InvalidInitialOwner();\\n\\n    /**\\n     * @dev Revert with an error when attempting to set a new potential owner\\n     *      that is already set.\\n     */\\n    error NewPotentialOwnerAlreadySet(\\n        address conduit,\\n        address newPotentialOwner\\n    );\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel ownership transfer\\n     *      when no new potential owner is currently set.\\n     */\\n    error NoPotentialOwnerCurrentlySet(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to interact with a conduit that\\n     *      does not yet exist.\\n     */\\n    error NoConduit();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a conduit that\\n     *      already exists.\\n     */\\n    error ConduitAlreadyExists(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update channels or transfer\\n     *      ownership of a conduit when the caller is not the owner of the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to register a new potential\\n     *      owner and supplying the null address.\\n     */\\n    error NewPotentialOwnerIsZeroAddress(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to claim ownership of a conduit\\n     *      with a caller that is not the current potential owner for the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotNewPotentialOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to retrieve a channel using an\\n     *      index that is out of range.\\n     */\\n    error ChannelOutOfRange(address conduit);\\n\\n    /**\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\n     *         an initial owner for the deployed conduit. Note that the first\\n     *         twenty bytes of the supplied conduit key must match the caller\\n     *         and that a new conduit cannot be created if one has already been\\n     *         deployed using the same conduit key.\\n     *\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\n     *                     the first twenty bytes of the conduit key must match\\n     *                     the caller of this contract.\\n     * @param initialOwner The initial owner to set for the new conduit.\\n     *\\n     * @return conduit The address of the newly deployed conduit.\\n     */\\n    function createConduit(\\n        bytes32 conduitKey,\\n        address initialOwner\\n    ) external returns (address conduit);\\n\\n    /**\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     *         Extreme care must be taken when updating channels, as malicious\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\n     *         tokens where the token holder has granted the conduit approval.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to open or close the channel.\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     */\\n    function updateChannel(\\n        address conduit,\\n        address channel,\\n        bool isOpen\\n    ) external;\\n\\n    /**\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\n     *         owner for the given conduit. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to initiate ownership transfer.\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    function transferOwnership(\\n        address conduit,\\n        address newPotentialOwner\\n    ) external;\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to cancel ownership transfer.\\n     */\\n    function cancelOwnershipTransfer(address conduit) external;\\n\\n    /**\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     *\\n     * @param conduit The conduit for which to accept ownership.\\n     */\\n    function acceptOwnership(address conduit) external;\\n\\n    /**\\n     * @notice Retrieve the current owner of a deployed conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated owner.\\n     *\\n     * @return owner The owner of the supplied conduit.\\n     */\\n    function ownerOf(address conduit) external view returns (address owner);\\n\\n    /**\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\n     *         lookup.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated conduit\\n     *                key.\\n     *\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\n     */\\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\\n\\n    /**\\n     * @notice Derive the conduit associated with a given conduit key and\\n     *         determine whether that conduit exists (i.e. whether it has been\\n     *         deployed).\\n     *\\n     * @param conduitKey The conduit key used to derive the conduit.\\n     *\\n     * @return conduit The derived address of the conduit.\\n     * @return exists  A boolean indicating whether the derived conduit has been\\n     *                 deployed or not.\\n     */\\n    function getConduit(\\n        bytes32 conduitKey\\n    ) external view returns (address conduit, bool exists);\\n\\n    /**\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\n     *         current owner may set a new potential owner via\\n     *         `transferOwnership` and that owner may then accept ownership of\\n     *         the conduit in question via `acceptOwnership`.\\n     *\\n     * @param conduit The conduit for which to retrieve the potential owner.\\n     *\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\n     */\\n    function getPotentialOwner(\\n        address conduit\\n    ) external view returns (address potentialOwner);\\n\\n    /**\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\n     *         a conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the channel status.\\n     * @param channel The channel for which to retrieve the status.\\n     *\\n     * @return isOpen The status of the channel on the given conduit.\\n     */\\n    function getChannelStatus(\\n        address conduit,\\n        address channel\\n    ) external view returns (bool isOpen);\\n\\n    /**\\n     * @notice Retrieve the total number of open channels for a given conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the total channel count.\\n     *\\n     * @return totalChannels The total number of open channels for the conduit.\\n     */\\n    function getTotalChannels(\\n        address conduit\\n    ) external view returns (uint256 totalChannels);\\n\\n    /**\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\n     *         Note that the index of a channel can change as a result of other\\n     *         channels being closed on the conduit.\\n     *\\n     * @param conduit      The conduit for which to retrieve the open channel.\\n     * @param channelIndex The index of the channel in question.\\n     *\\n     * @return channel The open channel, if any, at the specified channel index.\\n     */\\n    function getChannel(\\n        address conduit,\\n        uint256 channelIndex\\n    ) external view returns (address channel);\\n\\n    /**\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\n     *         this function for a conduit with many channels will revert with\\n     *         an out-of-gas error.\\n     *\\n     * @param conduit The conduit for which to retrieve open channels.\\n     *\\n     * @return channels An array of open channels on the given conduit.\\n     */\\n    function getChannels(\\n        address conduit\\n    ) external view returns (address[] memory channels);\\n\\n    /**\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\n     */\\n    function getConduitCodeHashes()\\n        external\\n        view\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\\n}\\n\"\r\n    },\r\n    \"ConsiderationEventsAndErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"SeaportStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationEventsAndErrors\\n * @author 0age\\n * @notice ConsiderationEventsAndErrors contains all events and errors.\\n */\\ninterface ConsiderationEventsAndErrors {\\n    /**\\n     * @dev Emit an event whenever an order is successfully fulfilled.\\n     *\\n     * @param orderHash     The hash of the fulfilled order.\\n     * @param offerer       The offerer of the fulfilled order.\\n     * @param zone          The zone of the fulfilled order.\\n     * @param recipient     The recipient of each spent item on the fulfilled\\n     *                      order, or the null address if there is no specific\\n     *                      fulfiller (i.e. the order is part of a group of\\n     *                      orders). Defaults to the caller unless explicitly\\n     *                      specified otherwise by the fulfiller.\\n     * @param offer         The offer items spent as part of the order.\\n     * @param consideration The consideration items received as part of the\\n     *                      order along with the recipients of each item.\\n     */\\n    event OrderFulfilled(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone,\\n        address recipient,\\n        SpentItem[] offer,\\n        ReceivedItem[] consideration\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever an order is successfully cancelled.\\n     *\\n     * @param orderHash The hash of the cancelled order.\\n     * @param offerer   The offerer of the cancelled order.\\n     * @param zone      The zone of the cancelled order.\\n     */\\n    event OrderCancelled(\\n        bytes32 orderHash,\\n        address indexed offerer,\\n        address indexed zone\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever an order is explicitly validated. Note that\\n     *      this event will not be emitted on partial fills even though they do\\n     *      validate the order as part of partial fulfillment.\\n     *\\n     * @param orderHash        The hash of the validated order.\\n     * @param orderParameters  The parameters of the validated order.\\n     */\\n    event OrderValidated(bytes32 orderHash, OrderParameters orderParameters);\\n\\n    /**\\n     * @dev Emit an event whenever one or more orders are matched using either\\n     *      matchOrders or matchAdvancedOrders.\\n     *\\n     * @param orderHashes The order hashes of the matched orders.\\n     */\\n    event OrdersMatched(bytes32[] orderHashes);\\n\\n    /**\\n     * @dev Emit an event whenever a counter for a given offerer is incremented.\\n     *\\n     * @param newCounter The new counter for the offerer.\\n     * @param offerer    The offerer in question.\\n     */\\n    event CounterIncremented(uint256 newCounter, address indexed offerer);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that has\\n     *      already been fully filled.\\n     *\\n     * @param orderHash The order hash on which a fill was attempted.\\n     */\\n    error OrderAlreadyFilled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order outside the\\n     *      specified start time and end time.\\n     *\\n     * @param startTime The time at which the order becomes active.\\n     * @param endTime   The time at which the order becomes inactive.\\n     */\\n    error InvalidTime(uint256 startTime, uint256 endTime);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order referencing an\\n     *      invalid conduit (i.e. one that has not been deployed).\\n     */\\n    error InvalidConduit(bytes32 conduitKey, address conduit);\\n\\n    /**\\n     * @dev Revert with an error when an order is supplied for fulfillment with\\n     *      a consideration array that is shorter than the original array.\\n     */\\n    error MissingOriginalConsiderationItems();\\n\\n    /**\\n     * @dev Revert with an error when an order is validated and the length of\\n     *      the consideration array is not equal to the supplied total original\\n     *      consideration items value. This error is also thrown when contract\\n     *      orders supply a total original consideration items value that does\\n     *      not match the supplied consideration array length.\\n     */\\n    error ConsiderationLengthNotEqualToTotalOriginal();\\n\\n    /**\\n     * @dev Revert with an error when a call to a conduit fails with revert data\\n     *      that is too expensive to return.\\n     */\\n    error InvalidCallToConduit(address conduit);\\n\\n    /**\\n     * @dev Revert with an error if a consideration amount has not been fully\\n     *      zeroed out after applying all fulfillments.\\n     *\\n     * @param orderIndex         The index of the order with the consideration\\n     *                           item with a shortfall.\\n     * @param considerationIndex The index of the consideration item on the\\n     *                           order.\\n     * @param shortfallAmount    The unfulfilled consideration amount.\\n     */\\n    error ConsiderationNotMet(\\n        uint256 orderIndex,\\n        uint256 considerationIndex,\\n        uint256 shortfallAmount\\n    );\\n\\n    /**\\n     * @dev Revert with an error when insufficient native tokens are supplied as\\n     *      part of msg.value when fulfilling orders.\\n     */\\n    error InsufficientNativeTokensSupplied();\\n\\n    /**\\n     * @dev Revert with an error when a native token transfer reverts.\\n     */\\n    error NativeTokenTransferGenericFailure(address account, uint256 amount);\\n\\n    /**\\n     * @dev Revert with an error when a partial fill is attempted on an order\\n     *      that does not specify partial fill support in its order type.\\n     */\\n    error PartialFillsNotEnabledForOrder();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill an order that has been\\n     *      cancelled.\\n     *\\n     * @param orderHash The hash of the cancelled order.\\n     */\\n    error OrderIsCancelled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill a basic order that has\\n     *      been partially filled.\\n     *\\n     * @param orderHash The hash of the partially used order.\\n     */\\n    error OrderPartiallyFilled(bytes32 orderHash);\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel an order as a caller\\n     *      other than the indicated offerer or zone or when attempting to\\n     *      cancel a contract order.\\n     */\\n    error CannotCancelOrder();\\n\\n    /**\\n     * @dev Revert with an error when supplying a fraction with a value of zero\\n     *      for the numerator or denominator, or one where the numerator exceeds\\n     *      the denominator.\\n     */\\n    error BadFraction();\\n\\n    /**\\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\\n     *      non-payable basic order route or does not supply any callvalue to a\\n     *      payable basic order route.\\n     */\\n    error InvalidMsgValue(uint256 value);\\n\\n    /**\\n     * @dev Revert with an error when attempting to fill a basic order using\\n     *      calldata not produced by default ABI encoding.\\n     */\\n    error InvalidBasicOrderParameterEncoding();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill any number of\\n     *      available orders when none are fulfillable.\\n     */\\n    error NoSpecifiedOrdersAvailable();\\n\\n    /**\\n     * @dev Revert with an error when attempting to fulfill an order with an\\n     *      offer for a native token outside of matching orders.\\n     */\\n    error InvalidNativeOfferItem();\\n}\"\r\n    },\r\n    \"ConsiderationInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"SeaportStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationInterface\\n * @author 0age\\n * @custom:version 1.5\\n * @notice Consideration is a generalized native token/ERC20/ERC721/ERC1155\\n *         marketplace. It minimizes external calls to the greatest extent\\n *         possible and provides lightweight methods for common routes as well\\n *         as more flexible methods for composing advanced orders.\\n *\\n * @dev ConsiderationInterface contains all external function interfaces for\\n *      Consideration.\\n */\\ninterface ConsiderationInterface {\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder(\\n        BasicOrderParameters calldata parameters\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order               The order to fulfill. Note that both the\\n     *                            offerer and the fulfiller must first approve\\n     *                            this contract (or the corresponding conduit if\\n     *                            indicated) to transfer any relevant tokens on\\n     *                            their behalf and that contracts must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\n     *                            as consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillOrder(\\n        Order calldata order,\\n        bytes32 fulfillerConduitKey\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder       The order to fulfill along with the fraction\\n     *                            of the order to attempt to fill. Note that\\n     *                            both the offerer and the fulfiller must first\\n     *                            approve this contract (or their preferred\\n     *                            conduit if indicated by the order) to transfer\\n     *                            any relevant tokens on their behalf and that\\n     *                            contracts must implement `onERC1155Received`\\n     *                            to receive ERC1155 tokens as consideration.\\n     *                            Also note that all offer and consideration\\n     *                            components must have no remainder after\\n     *                            multiplication of the respective amount with\\n     *                            the supplied fraction for the partial fill to\\n     *                            be considered valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the merkle root held by the item\\n     *                            in question's criteria element. Note that an\\n     *                            empty criteria indicates that any\\n     *                            (transferable) token identifier on the token\\n     *                            in question is valid and that no associated\\n     *                            proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     * @param recipient           The intended recipient for all received items,\\n     *                            with `address(0)` indicating that the caller\\n     *                            should receive the items.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\n     *         of items for offer and consideration. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *         Note that this function does not support criteria-based orders or\\n     *         partial filling of orders (though filling the remainder of a\\n     *         partially-filled order is supported).\\n     *\\n     * @param orders                    The orders to fulfill. Note that both\\n     *                                  the offerer and the fulfiller must first\\n     *                                  approve this contract (or the\\n     *                                  corresponding conduit if indicated) to\\n     *                                  transfer any relevant tokens on their\\n     *                                  behalf and that contracts must implement\\n     *                                  `onERC1155Received` to receive ERC1155\\n     *                                  tokens as consideration.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableOrders(\\n        Order[] calldata orders,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their preferred conduit if\\n     *                                  indicated by the order) to transfer any\\n     *                                  relevant tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` to enable receipt of\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param recipient                 The intended recipient for all received\\n     *                                  items, with `address(0)` indicating that\\n     *                                  the caller should receive the items.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] calldata advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with a set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported). Any unspent\\n     *         offer item amounts or native tokens will be transferred to the\\n     *         caller.\\n     *\\n     * @param orders       The orders to match. Note that both the offerer and\\n     *                     fulfiller on each order must first approve this\\n     *                     contract (or their conduit if indicated by the order)\\n     *                     to transfer any relevant tokens on their behalf and\\n     *                     each consideration recipient must implement\\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\\n     * @param fulfillments An array of elements allocating offer components to\\n     *                     consideration components. Note that each\\n     *                     consideration component must be fully met for the\\n     *                     match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or\\n     *                    native tokens will not be reflected as part of this\\n     *                    array.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components. Any unspent offer item\\n     *         amounts will be transferred to the designated recipient (with the\\n     *         null address signifying to use the caller) and any unspent native\\n     *         tokens will be returned to the caller.\\n     *\\n     * @param orders            The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or a preferred conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order to receive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     * @param recipient         The intended recipient for all unspent offer\\n     *                          item amounts, or the caller if the null address\\n     *                          is supplied.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or native\\n     *                    tokens will not be reflected as part of this array.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments,\\n        address recipient\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     *         or the zone of a given order may cancel it. Callers should ensure\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\n     *         and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancel(\\n        OrderComponents[] calldata orders\\n    ) external returns (bool cancelled);\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\n     *         signatures as valid and allowing the fulfiller to skip signature\\n     *         verification on fulfillment. Note that validated orders may still\\n     *         be unfulfillable due to invalid item amounts or other factors;\\n     *         callers should determine whether validated orders are fulfillable\\n     *         by simulating the fulfillment call prior to execution. Also note\\n     *         that anyone can validate a signed order, but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders have\\n     *                   been successfully validated.\\n     */\\n    function validate(\\n        Order[] calldata orders\\n    ) external returns (bool validated);\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a counter. Note that only the offerer may\\n     *         increment the counter.\\n     *\\n     * @return newCounter The new counter.\\n     */\\n    function incrementCounter() external returns (uint256 newCounter);\\n\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration. Note that this function costs less gas than\\n     *         `fulfillBasicOrder` due to the zero bytes in the function\\n     *         selector (0x00000000) which also results in earlier function\\n     *         dispatch.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder_efficient_6GL6yc(\\n        BasicOrderParameters calldata parameters\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return orderHash The order hash.\\n     */\\n    function getOrderHash(\\n        OrderComponents calldata order\\n    ) external view returns (bytes32 orderHash);\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(\\n        bytes32 orderHash\\n    )\\n        external\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        );\\n\\n    /**\\n     * @notice Retrieve the current counter for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return counter The current counter.\\n     */\\n    function getCounter(\\n        address offerer\\n    ) external view returns (uint256 counter);\\n\\n    /**\\n     * @notice Retrieve configuration information for this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function information()\\n        external\\n        view\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        );\\n\\n    function getContractOffererNonce(\\n        address contractOfferer\\n    ) external view returns (uint256 nonce);\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return contractName The name of this contract.\\n     */\\n    function name() external view returns (string memory contractName);\\n}\\n\"\r\n    },\r\n    \"ViciAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"ERC165.sol\\\";\\n\\nimport \\\"Context.sol\\\";\\nimport \\\"AccessConstants.sol\\\";\\nimport \\\"IViciAccess.sol\\\";\\nimport {IAccessServer} from \\\"IAccessServer.sol\\\";\\n\\n/**\\n * @title ViciAccess\\n * @notice (c) 2023 ViciNFT https://vicinft.com/\\n * @author Josh Davis <josh.davis@vicinft.com>\\n *\\n * @dev This contract implements OpenZeppelin's IAccessControl and\\n * IAccessControlEnumerable interfaces as well as the behavior of their\\n * Ownable contract.\\n * @dev The differences are:\\n * - Use of an external AccessServer contract to track roles and ownership.\\n * - Support for OFAC sanctions compliance\\n * - Support for a negative BANNED role\\n * - A contract owner is automatically granted the DEFAULT ADMIN role.\\n * - Contract owner cannot renounce ownership, can only transfer it.\\n * - DEFAULT ADMIN role cannot be revoked from the Contract owner, nor can they\\n *   renouce that role.\\n * @dev see `AccessControl`, `AccessControlEnumerable`, and `Ownable` for\\n * additional documentation.\\n */\\nabstract contract ViciAccess is Context, IViciAccess, ERC165 {\\n    IAccessServer public accessServer;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = DEFAULT_ADMIN;\\n\\n    // Role for banned users.\\n    bytes32 public constant BANNED_ROLE_NAME = BANNED;\\n\\n    // Role for moderator.\\n    bytes32 public constant MODERATOR_ROLE_NAME = MODERATOR;\\n\\n    /* ################################################################\\n     * Initialization\\n     * ##############################################################*/\\n\\n    function __ViciAccess_init(\\n        IAccessServer _accessServer\\n    ) internal onlyInitializing {\\n        __ViciAccess_init_unchained(_accessServer);\\n    }\\n\\n    function __ViciAccess_init_unchained(\\n        IAccessServer _accessServer\\n    ) internal onlyInitializing {\\n        accessServer = _accessServer;\\n        accessServer.register(_msgSender());\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IAccessControl).interfaceId ||\\n            interfaceId == type(IAccessControlEnumerable).interfaceId ||\\n            ERC165.supportsInterface(interfaceId);\\n    }\\n\\n    /* ################################################################\\n     * Checking Roles\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev reverts if called by an account that is not the owner and doesn't\\n     *     have the required role.\\n     */\\n    modifier onlyOwnerOrRole(bytes32 role) {\\n        enforceOwnerOrRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        accessServer.enforceIsMyOwner(_msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev reverts if the caller is banned or on the OFAC sanctions list.\\n     */\\n    modifier noBannedAccounts() {\\n        enforceIsNotBanned(_msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev reverts if the account is banned or on the OFAC sanctions list.\\n     */\\n    modifier notBanned(address account) {\\n        enforceIsNotBanned(account);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Revert if the address is on the OFAC sanctions list\\n     */\\n    modifier notSanctioned(address account) {\\n        enforceIsNotSanctioned(account);\\n        _;\\n    }\\n\\n    /**\\n     * @dev reverts if the account is not the owner and doesn't have the required role.\\n     */\\n    function enforceOwnerOrRole(\\n        bytes32 role,\\n        address account\\n    ) public view virtual override {\\n        if (account != owner()) {\\n            _checkRole(role, account);\\n        }\\n    }\\n\\n    /**\\n     * @dev reverts if the account is banned or on the OFAC sanctions list.\\n     */\\n    function enforceIsNotBanned(address account) public view virtual override {\\n        accessServer.enforceIsNotBannedForMe(account);\\n    }\\n\\n    /**\\n     * @dev Revert if the address is on the OFAC sanctions list\\n     */\\n    function enforceIsNotSanctioned(\\n        address account\\n    ) public view virtual override {\\n        accessServer.enforceIsNotSanctioned(account);\\n    }\\n\\n    /**\\n     * @dev returns true if the account is banned.\\n     */\\n    function isBanned(\\n        address account\\n    ) public view virtual override returns (bool) {\\n        return accessServer.isBannedForMe(account);\\n    }\\n\\n    /**\\n     * @dev returns true if the account is on the OFAC sanctions list.\\n     */\\n    function isSanctioned(\\n        address account\\n    ) public view virtual override returns (bool) {\\n        return accessServer.isSanctioned(account);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(\\n        bytes32 role,\\n        address account\\n    ) public view virtual override returns (bool) {\\n        return accessServer.hasRoleForMe(role, account);\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (role != ANY_ROLE) {\\n            accessServer.checkRoleForMe(role, account);\\n        }\\n    }\\n\\n    /* ################################################################\\n     * Owner management\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual override returns (address) {\\n        return accessServer.getMyOwner();\\n    }\\n\\n    /**\\n     * Make another account the owner of this contract.\\n     * @param newOwner the new owner.\\n     *\\n     * Requirements:\\n     *\\n     * - Calling user MUST be owner.\\n     * - `newOwner` MUST NOT have the banned role.\\n     */\\n    function transferOwnership(address newOwner) public virtual {\\n        address oldOwner = owner();\\n        accessServer.setMyOwner(_msgSender(), newOwner);\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /* ################################################################\\n     * Role Administration\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(\\n        bytes32 role\\n    ) public view virtual override returns (bytes32) {\\n        return accessServer.getMyRoleAdmin(role);\\n    }\\n\\n    /**\\n     * @dev Sets the admin role that controls a role.\\n     *\\n     * Requirements:\\n     * - caller MUST be the owner or have the admin role.\\n     */\\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) public virtual {\\n        accessServer.setRoleAdmin(_msgSender(), role, adminRole);\\n    }\\n\\n    /* ################################################################\\n     * Enumerating role members\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(\\n        bytes32 role,\\n        uint256 index\\n    ) public view virtual override returns (address) {\\n        return accessServer.getMyRoleMember(role, index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(\\n        bytes32 role\\n    ) public view virtual override returns (uint256) {\\n        return accessServer.getMyRoleMemberCount(role);\\n    }\\n\\n    /* ################################################################\\n     * Granting / Revoking / Renouncing roles\\n     * ##############################################################*/\\n\\n    /**\\n     *  Requirements:\\n     *\\n     * - Calling user MUST have the admin role\\n     * - If `role` is banned, calling user MUST be the owner\\n     *   and `address` MUST NOT be the owner.\\n     * - If `role` is not banned, `account` MUST NOT be under sanctions.\\n     *\\n     * @inheritdoc IAccessControl\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override {\\n        if (!hasRole(role, account)) {\\n            accessServer.grantRole(_msgSender(), role, account);\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * Take the role away from the account. This will throw an exception\\n     * if you try to take the admin role (0x00) away from the owner.\\n     *\\n     * Requirements:\\n     *\\n     * - Calling user has admin role.\\n     * - If `role` is admin, `address` MUST NOT be owner.\\n     * - if `role` is banned, calling user MUST be owner.\\n     *\\n     * @inheritdoc IAccessControl\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override {\\n        if (hasRole(role, account)) {\\n            accessServer.revokeRole(_msgSender(), role, account);\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * Take a role away from yourself. This will throw an exception if you\\n     * are the contract owner and you are trying to renounce the admin role (0x00).\\n     *\\n     * Requirements:\\n     *\\n     * - if `role` is admin, calling user MUST NOT be owner.\\n     * - `account` is ignored.\\n     * - `role` MUST NOT be banned.\\n     *\\n     * @inheritdoc IAccessControl\\n     */\\n    function renounceRole(bytes32 role, address) public virtual override {\\n        renounceRole(role);\\n    }\\n\\n    /**\\n     * Take a role away from yourself. This will throw an exception if you\\n     * are the contract owner and you are trying to renounce the admin role (0x00).\\n     *\\n     * Requirements:\\n     *\\n     * - if `role` is admin, calling user MUST NOT be owner.\\n     * - `role` MUST NOT be banned.\\n     */\\n    function renounceRole(bytes32 role) public virtual {\\n        accessServer.renounceRole(_msgSender(), role);\\n        emit RoleRevoked(role, _msgSender(), _msgSender());\\n        // if (hasRole(role, _msgSender())) {\\n        // }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.17;\\nimport \\\"Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n *\\n * @dev This contract is a direct copy of OpenZeppelin's ContextUpgradeable, \\n * moved here, renamed, and modified to use our Initializable interface so we \\n * don't have to deal with incompatibilities between OZ'` contracts and \\n * contracts-upgradeable `\\n */\\nabstract contract Context is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"AddressUtils.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n *\\n * @dev This contract is a direct copy of OpenZeppelin's InitializableUpgradeable,\\n * moved here, renamed, and modified to use our AddressUtils library so we\\n * don't have to deal with incompatibilities between OZ'` contracts and\\n * contracts-upgradeable `\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) ||\\n                (!AddressUtils.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(\\n            !_initializing && _initialized < version,\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n *\\n * @dev This contract is a direct copy of OpenZeppelin's AddressUpgradeable, \\n * moved here and renamed so we don't have to deal with incompatibilities \\n * between OZ'` contracts and contracts-upgradeable `\\n */\\nlibrary AddressUtils {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"AccessConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nbytes32 constant DEFAULT_ADMIN = 0x00;\\nbytes32 constant BANNED = \\\"banned\\\";\\nbytes32 constant MODERATOR = \\\"moderator\\\";\\nbytes32 constant ANY_ROLE = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\nbytes32 constant BRIDGE_CONTRACT = keccak256(\\\"BRIDGE_CONTRACT\\\");\\nbytes32 constant BRIDGE_ROLE_MGR = keccak256(\\\"BRIDGE_ROLE_MGR\\\");\\n\"\r\n    },\r\n    \"IViciAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"IAccessControlEnumerable.sol\\\";\\n\\n/**\\n * @title ViciAccess Interface\\n * @notice (c) 2023 ViciNFT https://vicinft.com/\\n * @author Josh Davis <josh.davis@vicinft.com>\\n *\\n * @dev Interface for ViciAccess.\\n * @dev External contracts SHOULD refer to implementers via this interface.\\n */\\ninterface IViciAccess is IAccessControlEnumerable {\\n    /**\\n     * @dev emitted when the owner changes.\\n     */\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Revert if the address is on the OFAC sanctions list\\n     */\\n    function enforceIsNotSanctioned(address account) external view;\\n\\n    /**\\n     * @dev reverts if the account is banned or on the OFAC sanctions list.\\n     */\\n    function enforceIsNotBanned(address account) external view;\\n\\n    /**\\n     * @dev reverts if the account is not the owner and doesn't have the required role.\\n     */\\n    function enforceOwnerOrRole(bytes32 role, address account) external view;\\n\\n    /**\\n     * @dev returns true if the account is on the OFAC sanctions list.\\n     */\\n    function isSanctioned(address account) external view returns (bool);\\n\\n    /**\\n     * @dev returns true if the account is banned.\\n     */\\n    function isBanned(address account) external view returns (bool);\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() external view returns (address);\\n}\"\r\n    },\r\n    \"IAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerable is IAccessControl {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"IAccessServer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface ChainalysisSanctionsList {\\n    function isSanctioned(address addr) external view returns (bool);\\n}\\n\\n/**\\n * @title Access Server Interface\\n * @notice (c) 2023 ViciNFT https://vicinft.com/\\n * @author Josh Davis <josh.davis@vicinft.com>\\n *\\n * @dev Interface for the AccessServer.\\n * @dev AccessServer client contracts SHOULD refer to the server contract via\\n * this interface.\\n */\\ninterface IAccessServer {\\n    /**\\n     * @notice Emitted when a new administrator is added.\\n     */\\n    event AdminAddition(address indexed admin);\\n\\n    /**\\n     * @notice Emitted when an administrator is removed.\\n     */\\n    event AdminRemoval(address indexed admin);\\n\\n    /**\\n     * @notice Emitted when a resource is registered.\\n     */\\n    event ResourceRegistration(address indexed resource);\\n\\n    /**\\n     * @notice Emitted when `newAdminRole` is set globally as ``role``'s admin\\n     * role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {GlobalRoleAdminChanged} not being emitted signaling this.\\n     */\\n    event GlobalRoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n\\n    /**\\n     * @notice Emitted when `account` is granted `role` globally.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event GlobalRoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @notice Emitted when `account` is revoked `role` globally.\\n     * @notice `account` will still have `role` where it was granted\\n     * specifically for any resources\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event GlobalRoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /* ################################################################\\n     * Modifiers / Rule Enforcement\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Throws if the account is not the resource's owner.\\n     */\\n    function enforceIsOwner(address resource, address account) external view;\\n\\n    /**\\n     * @dev Throws if the account is not the calling resource's owner.\\n     */\\n    function enforceIsMyOwner(address account) external view;\\n\\n    /**\\n     * @dev Reverts if the account is not the resource owner or doesn't have\\n     * the moderator role for the resource.\\n     */\\n    function enforceIsModerator(address resource, address account)\\n        external\\n        view;\\n\\n    /**\\n     * @dev Reverts if the account is not the resource owner or doesn't have\\n     * the moderator role for the calling resource.\\n     */\\n    function enforceIsMyModerator(address account) external view;\\n\\n    /**\\n     * @dev Reverts if the account is under OFAC sanctions or is banned for the\\n     * resource\\n     */\\n    function enforceIsNotBanned(address resource, address account)\\n        external\\n        view;\\n\\n    /**\\n     * @dev Reverts if the account is under OFAC sanctions or is banned for the\\n     * calling resource\\n     */\\n    function enforceIsNotBannedForMe(address account) external view;\\n\\n    /**\\n     * @dev Reverts the account is on the OFAC sanctions list.\\n     */\\n    function enforceIsNotSanctioned(address account) external view;\\n\\n    /**\\n     * @dev Reverts if the account is not the resource owner or doesn't have\\n     * the required role for the resource.\\n     */\\n    function enforceOwnerOrRole(\\n        address resource,\\n        bytes32 role,\\n        address account\\n    ) external view;\\n\\n    /**\\n     * @dev Reverts if the account is not the resource owner or doesn't have\\n     * the required role for the calling resource.\\n     */\\n    function enforceOwnerOrRoleForMe(bytes32 role, address account)\\n        external\\n        view;\\n\\n    /* ################################################################\\n     * Administration\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Returns `true` if `admin` is an administrator of this AccessServer.\\n     */\\n    function isAdministrator(address admin) external view returns (bool);\\n\\n    /**\\n     * @dev Adds `admin` as an administrator of this AccessServer.\\n     */\\n    function addAdministrator(address admin) external;\\n\\n    /**\\n     * @dev Removes `admin` as an administrator of this AccessServer.\\n     */\\n    function removeAdministrator(address admin) external;\\n\\n    /**\\n     * @dev Returns the number of administrators of this AccessServer.\\n     * @dev Use with `getAdminAt()` to enumerate.\\n     */\\n    function getAdminCount() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the administrator at the index.\\n     * @dev Use with `getAdminCount()` to enumerate.\\n     */\\n    function getAdminAt(uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the list of administrators\\n     */\\n    function getAdmins() external view returns (address[] memory);\\n\\n    /**\\n     * @dev returns the Chainalysis sanctions oracle.\\n     */\\n    function sanctionsList() external view returns (ChainalysisSanctionsList);\\n\\n    /**\\n     * @dev Sets the Chainalysis sanctions oracle.\\n     * @dev setting this to the zero address disables sanctions compliance.\\n     * @dev Don't disable sanctions compliance unless there is some problem\\n     * with the sanctions oracle.\\n     */\\n    function setSanctionsList(ChainalysisSanctionsList _sanctionsList) external;\\n\\n    /**\\n     * @dev Returns `true` if `account` is under OFAC sanctions.\\n     * @dev Returns `false` if sanctions compliance is disabled.\\n     */\\n    function isSanctioned(address account) external view returns (bool);\\n\\n    /* ################################################################\\n     * Registration / Ownership\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Registers the calling resource and sets the resource owner.\\n     * @dev Grants the default administrator role for the resource to the\\n     * resource owner.\\n     *\\n     * Requirements:\\n     * - caller SHOULD be a contract\\n     * - caller MUST NOT be already registered\\n     * - `owner` MUST NOT be the zero address\\n     * - `owner` MUST NOT be globally banned\\n     * - `owner` MUST NOT be under OFAC sanctions\\n     */\\n    function register(address owner) external;\\n\\n    /**\\n     * @dev Returns `true` if `resource` is registered.\\n     */\\n    function isRegistered(address resource) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the owner of `resource`.\\n     */\\n    function getResourceOwner(address resource) external view returns (address);\\n\\n    /**\\n     * @dev Returns the owner of the calling resource.\\n     */\\n    function getMyOwner() external view returns (address);\\n\\n    /**\\n     * @dev Sets the owner for the calling resource.\\n     *\\n     * Requirements:\\n     * - caller MUST be a registered resource\\n     * - `operator` MUST be the current owner\\n     * - `newOwner` MUST NOT be the zero address\\n     * - `newOwner` MUST NOT be globally banned\\n     * - `newOwner` MUST NOT be banned by the calling resource\\n     * - `newOwner` MUST NOT be under OFAC sanctions\\n     * - `newOwner` MUST NOT be the current owner\\n     */\\n    function setMyOwner(address operator, address newOwner) external;\\n\\n    /* ################################################################\\n     * Role Administration\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Returns the admin role that controls `role` by default for all\\n     * resources. See {grantRole} and {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getGlobalRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role` for a resource.\\n     * See {grantRole} and {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdminForResource(address resource, bytes32 role)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role` for the calling resource.\\n     * See {grantRole} and {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getMyRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role on as default all\\n     * resources.\\n     *\\n     * Requirements:\\n     * - caller MUST be an an administrator of this AccessServer\\n     */\\n    function setGlobalRoleAdmin(bytes32 role, bytes32 adminRole) external;\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role on the calling resource.\\n     * @dev There is no set roleAdminForResource vs setRoleAdminForMe.\\n     * @dev Resources must manage their own role admins or use the global\\n     * defaults.\\n     *\\n     * Requirements:\\n     * - caller MUST be a registered resource\\n     */\\n    function setRoleAdmin(\\n        address operator,\\n        bytes32 role,\\n        bytes32 adminRole\\n    ) external;\\n\\n    /* ################################################################\\n     * Checking Role Membership\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role` as default for\\n     * all resources.\\n     */\\n    function hasGlobalRole(bytes32 role, address account)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role` globally or for\\n     * `resource`.\\n     */\\n    function hasRole(\\n        address resource,\\n        bytes32 role,\\n        address account\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role` for `resource`.\\n     */\\n    function hasLocalRole(\\n        address resource,\\n        bytes32 role,\\n        address account\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role` globally or for\\n     * the calling resource.\\n     */\\n    function hasRoleForMe(bytes32 role, address account)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if account` is banned globally or from `resource`.\\n     */\\n    function isBanned(address resource, address account)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if account` is banned globally or from the calling\\n     * resource.\\n     */\\n    function isBannedForMe(address account) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if `account` has not been granted `role` globally or for\\n     * `resource`.\\n     */\\n    function checkRole(\\n        address resource,\\n        bytes32 role,\\n        address account\\n    ) external view;\\n\\n    /**\\n     * @dev Reverts if `account` has not been granted `role` globally or for\\n     * the calling resource.\\n     */\\n    function checkRoleForMe(bytes32 role, address account) external view;\\n\\n    /* ################################################################\\n     * Granting Roles\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Grants `role` to `account` as default for all resources.\\n     * @dev Warning: This function can do silly things like applying a global\\n     * ban to a resource owner.\\n     *\\n     * Requirements:\\n     * - caller MUST be an an administrator of this AccessServer\\n     * - If `role` is not BANNED_ROLE_NAME, `account` MUST NOT be banned or\\n     *   under OFAC sanctions. Roles cannot be granted to such accounts.\\n     */\\n    function grantGlobalRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Grants `role` to `account` for the calling resource as `operator`.\\n     * @dev There is no set grantRoleForResource vs grantRoleForMe.\\n     * @dev Resources must manage their own roles or use the global defaults.\\n     *\\n     * Requirements:\\n     * - caller MUST be a registered resource\\n     * - `operator` SHOULD be the account that called `grantRole()` on the\\n     *    calling resource.\\n     * - `operator` MUST be the resource owner or have the role admin role\\n     *    for `role` on the calling resource.\\n     * - If `role` is BANNED_ROLE_NAME, `account` MUST NOT be the resource\\n     *   owner. You can't ban the owner.\\n     * - If `role` is not BANNED_ROLE_NAME, `account` MUST NOT be banned or\\n     *   under OFAC sanctions. Roles cannot be granted to such accounts.\\n     */\\n    function grantRole(\\n        address operator,\\n        bytes32 role,\\n        address account\\n    ) external;\\n\\n    /* ################################################################\\n     * Revoking / Renouncing Roles\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Revokes `role` as default for all resources from `account`.\\n     *\\n     * Requirements:\\n     * - caller MUST be an an administrator of this AccessServer\\n     */\\n    function revokeGlobalRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account` for the calling resource as\\n     * `operator`.\\n     *\\n     * Requirements:\\n     * - caller MUST be a registered resource\\n     * - `operator` SHOULD be the account that called `revokeRole()` on the\\n     *    calling resource.\\n     * - `operator` MUST be the resource owner or have the role admin role\\n     *    for `role` on the calling resource.\\n     * - if `role` is DEFAULT_ADMIN_ROLE, `account` MUST NOT be the calling\\n     *   resource's owner. The admin role cannot be revoked from the owner.\\n     */\\n    function revokeRole(\\n        address operator,\\n        bytes32 role,\\n        address account\\n    ) external;\\n\\n    /**\\n     * @dev Remove the default role for yourself. You will still have the role\\n     * for any resources where it was granted individually.\\n     *\\n     * Requirements:\\n     * - caller MUST have the role they are renouncing at the global level.\\n     * - `role` MUST NOT be BANNED_ROLE_NAME. You can't unban yourself.\\n     */\\n    function renounceRoleGlobally(bytes32 role) external;\\n\\n    /**\\n     * @dev Renounces `role` for the calling resource as `operator`.\\n     *\\n     * Requirements:\\n     * - caller MUST be a registered resource\\n     * - `operator` SHOULD be the account that called `renounceRole()` on the\\n     *    calling resource.\\n     * - `operator` MUST have the role they are renouncing on the calling\\n     *   resource.\\n     * - if `role` is DEFAULT_ADMIN_ROLE, `operator` MUST NOT be the calling\\n     *   resource's owner. The owner cannot renounce the admin role.\\n     * - `role` MUST NOT be BANNED_ROLE_NAME. You can't unban yourself.\\n     */\\n    function renounceRole(address operator, bytes32 role) external;\\n\\n    /* ################################################################\\n     * Enumerating Role Members\\n     * ##############################################################*/\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role` set at the global\\n     * level.\\n     * @dev Use with `getGlobalRoleMember()` to enumerate.\\n     */\\n    function getGlobalRoleMemberCount(bytes32 role) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role` set at the global\\n     * level.\\n     * @dev Use with `getGlobalRoleMemberCount()` to enumerate.\\n     *\\n     * Requirements:\\n     * `index` MUST be >= 0 and < `getGlobalRoleMemberCount(role)`\\n     */\\n    function getGlobalRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the list of accounts that have `role` set at the global\\n     * level.\\n     */\\n    function getGlobalRoleMembers(bytes32 role) external view returns (address[] memory);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role` set globally or for \\n     * `resource`.\\n     * @dev Use with `getRoleMember()` to enumerate.\\n     */\\n    function getRoleMemberCount(address resource, bytes32 role) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role` set globally or for \\n     * `resource`. \\n     * @dev If a role has global and local members, the global members \\n     * will be returned first.\\n     * @dev If a user has the role globally and locally, the same user will be \\n     * returned at two different indexes.\\n     * @dev If you only want locally assigned role members, start the index at\\n     * `getGlobalRoleMemberCount(role)`.\\n     * @dev Use with `getRoleMemberCount()` to enumerate.\\n     *\\n     * Requirements:\\n     * `index` MUST be >= 0 and < `getRoleMemberCount(role)`\\n     */\\n    function getRoleMember(\\n        address resource,\\n        bytes32 role,\\n        uint256 index\\n    ) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role` set globally or for \\n     * the calling resource.\\n     * @dev Use with `getMyRoleMember()` to enumerate.\\n     */\\n    function getMyRoleMemberCount(bytes32 role) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role` set globally or for \\n     * the calling resource.\\n     * @dev If a role has global and local members, the global members \\n     * will be returned first.\\n     * @dev If a user has the role globally and locally, the same user will be \\n     * returned at two different indexes.\\n     * @dev If you only want locally assigned role members, start the index at\\n     * `getGlobalRoleMemberCount(role)`.\\n     * @dev Use with `getMyRoleMemberCount()` to enumerate.\\n     *\\n     * Requirements:\\n     * `index` MUST be >= 0 and < `getMyRoleMemberCount(role)`\\n     */\\n    function getMyRoleMember(bytes32 role, uint256 index) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"Wallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IERC721.sol\\\";\\nimport \\\"IERC721Receiver.sol\\\";\\nimport \\\"IERC777.sol\\\";\\nimport \\\"IERC777Recipient.sol\\\";\\nimport \\\"IERC1155.sol\\\";\\nimport \\\"IERC1155Receiver.sol\\\";\\nimport \\\"ERC165.sol\\\";\\n\\n/**\\n * @title Wallet\\n * @notice (c) 2023 ViciNFT https://vicinft.com/\\n * @author Josh Davis <josh.davis@vicinft.com>\\n *\\n * @dev This is an abstract contract with basic wallet functionality. It can\\n *     send and receive native crypto, ERC20 tokens, ERC721 tokens, ERC777 \\n *     tokens, and ERC1155 tokens.\\n * @dev The withdraw events are always emitted when crypto or tokens are\\n *     withdrawn.\\n * @dev The deposit events are less reliable, and normally only work when the\\n *     safe transfer functions are used.\\n * @dev There is no DepositERC20 event defined, because the ERC20 standard \\n *     doesn't include a safe transfer function.\\n * @dev The withdraw functions are all marked as internal. Subclasses should\\n *     add public withdraw functions that delegate to these, preferably with \\n *     some kind of control over who is allowed to call them.\\n */\\nabstract contract Wallet is\\n    IERC721Receiver,\\n    IERC777Recipient,\\n    IERC1155Receiver,\\n    ERC165\\n{\\n    /**\\n     * @dev May be emitted when native crypto is deposited.\\n     * @param sender the source of the crypto\\n     * @param value the amount deposited\\n     */\\n    event Deposit(address indexed sender, uint256 value);\\n\\n    /**\\n     * @dev May be emitted when an NFT is deposited.\\n     * @param sender the source of the NFT\\n     * @param tokenContract the NFT contract\\n     * @param tokenId the id of the deposited token\\n     */\\n    event DepositERC721(\\n        address indexed sender,\\n        address indexed tokenContract,\\n        uint256 tokenId\\n    );\\n\\n    /**\\n     * @dev May be emitted when ERC777 tokens are deposited.\\n     * @param sender the source of the ERC777 tokens\\n     * @param tokenContract the ERC777 contract\\n     * @param amount the amount deposited\\n     */\\n    event DepositERC777(\\n        address indexed sender,\\n        address indexed tokenContract,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev May be emitted when semi-fungible tokens are deposited.\\n     * @param sender the source of the semi-fungible tokens\\n     * @param tokenContract the semi-fungible token contract\\n     * @param tokenId the id of the semi-fungible tokens\\n     * @param amount the number of tokens deposited\\n     */\\n    event DepositERC1155(\\n        address indexed sender,\\n        address indexed tokenContract,\\n        uint256 tokenId,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted when native crypto is withdrawn.\\n     * @param recipient the destination of the crypto\\n     * @param value the amount withdrawn\\n     */\\n    event Withdraw(address indexed recipient, uint256 value);\\n\\n    /**\\n     * @dev Emitted when ERC20 tokens are withdrawn.\\n     * @param recipient the destination of the ERC20 tokens\\n     * @param tokenContract the ERC20 contract\\n     * @param amount the amount withdrawn\\n     */\\n    event WithdrawERC20(\\n        address indexed recipient,\\n        address indexed tokenContract,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted when an NFT is withdrawn.\\n     * @param recipient the destination of the NFT\\n     * @param tokenContract the NFT contract\\n     * @param tokenId the id of the withdrawn token\\n     */\\n    event WithdrawERC721(\\n        address indexed recipient,\\n        address indexed tokenContract,\\n        uint256 tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when ERC777 tokens are withdrawn.\\n     * @param recipient the destination of the ERC777 tokens\\n     * @param tokenContract the ERC777 contract\\n     * @param amount the amount withdrawn\\n     */\\n    event WithdrawERC777(\\n        address indexed recipient,\\n        address indexed tokenContract,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted when semi-fungible tokens are withdrawn.\\n     * @param recipient the destination of the semi-fungible tokens\\n     * @param tokenContract the semi-fungible token contract\\n     * @param tokenId the id of the semi-fungible tokens\\n     * @param amount the number of tokens withdrawn\\n     */\\n    event WithdrawERC1155(\\n        address indexed recipient,\\n        address indexed tokenContract,\\n        uint256 tokenId,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC165, IERC165)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721Receiver).interfaceId ||\\n            interfaceId == type(IERC777Recipient).interfaceId ||\\n            interfaceId == type(IERC1155Receiver).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    receive() external payable {\\n        if (msg.value > 0) emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     */\\n    function onERC721Received(\\n        address,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata\\n    ) external override returns (bytes4) {\\n        emit DepositERC721(from, msg.sender, tokenId);\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * @dev See {IERC777Recipient-tokensReceived}.\\n     */\\n    function tokensReceived(\\n        address,\\n        address from,\\n        address,\\n        uint256 amount,\\n        bytes calldata,\\n        bytes calldata\\n    ) external override {\\n        emit DepositERC777(from, msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155Receiver-onERC1155Received}.\\n     */\\n    function onERC1155Received(\\n        address,\\n        address from,\\n        uint256 tokenId,\\n        uint256 value,\\n        bytes calldata\\n    ) external override returns (bytes4) {\\n        emit DepositERC1155(from, msg.sender, tokenId, value);\\n        return\\n            bytes4(\\n                keccak256(\\n                    \\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\\n     */\\n    function onERC1155BatchReceived(\\n        address,\\n        address from,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata values,\\n        bytes calldata\\n    ) external override returns (bytes4) {\\n        for (uint256 i = 0; i < values.length; i++) {\\n            emit DepositERC1155(from, msg.sender, tokenIds[i], values[i]);\\n        }\\n        return\\n            bytes4(\\n                keccak256(\\n                    \\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Withdraw native crypto.\\n     * @notice Emits Withdraw\\n     * @param toAddress Where to send the crypto\\n     * @param amount The amount to send\\n     */\\n    function _withdraw(address payable toAddress, uint256 amount)\\n        internal\\n        virtual\\n    {\\n        require(toAddress != address(0), \\\"ETH: transfer to the zero address\\\");\\n        toAddress.transfer(amount);\\n        emit Withdraw(toAddress, amount);\\n    }\\n\\n    /**\\n     * @dev Withdraw ERC20 tokens.\\n     * @notice Emits WithdrawERC20\\n     * @param toAddress Where to send the ERC20 tokens\\n     * @param tokenContract The ERC20 token contract\\n     * @param amount The amount withdrawn\\n     */\\n    function _withdrawERC20(\\n        address payable toAddress,\\n        uint256 amount,\\n        IERC20 tokenContract\\n    ) internal virtual {\\n        require(toAddress != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        tokenContract.transfer(toAddress, amount);\\n        emit WithdrawERC20(toAddress, address(tokenContract), amount);\\n    }\\n\\n    /**\\n     * @dev Withdraw an NFT.\\n     * @notice Emits WithdrawERC721\\n     * @param toAddress Where to send the NFT\\n     * @param tokenContract The NFT contract\\n     * @param tokenId The id of the NFT\\n     */\\n    function _withdrawERC721(\\n        address payable toAddress,\\n        uint256 tokenId,\\n        IERC721 tokenContract\\n    ) internal virtual {\\n        require(toAddress != address(0), \\\"ERC721: transfer to the zero address\\\");\\n        tokenContract.safeTransferFrom(address(this), toAddress, tokenId);\\n        emit WithdrawERC721(toAddress, address(tokenContract), tokenId);\\n    }\\n\\n    /**\\n     * @dev Withdraw ERC777 tokens.\\n     * @notice Emits WithdrawERC777\\n     * @param toAddress Where to send the ERC777 tokens\\n     * @param tokenContract The ERC777 token contract\\n     * @param amount The amount withdrawn\\n     */\\n    function _withdrawERC777(\\n        address payable toAddress,\\n        uint256 amount,\\n        IERC777 tokenContract\\n    ) internal virtual {\\n        require(toAddress != address(0), \\\"ERC777: transfer to the zero address\\\");\\n        tokenContract.operatorSend(address(this), toAddress, amount, \\\"\\\", \\\"\\\");\\n        emit WithdrawERC777(toAddress, address(tokenContract), amount);\\n    }\\n\\n    /**\\n     * @dev Withdraw semi-fungible tokens.\\n     * @notice Emits WithdrawERC1155\\n     * @param toAddress Where to send the semi-fungible tokens\\n     * @param tokenContract The semi-fungible token contract\\n     * @param tokenId The id of the semi-fungible tokens\\n     * @param amount The number of tokens withdrawn\\n     */\\n    function _withdrawERC1155(\\n        address payable toAddress,\\n        uint256 tokenId,\\n        uint256 amount,\\n        IERC1155 tokenContract\\n    ) internal virtual {\\n        require(toAddress != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        tokenContract.safeTransferFrom(\\n            address(this),\\n            toAddress,\\n            tokenId,\\n            amount,\\n            \\\"\\\"\\n        );\\n        emit WithdrawERC1155(\\n            toAddress,\\n            address(tokenContract),\\n            tokenId,\\n            amount\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"IERC777.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\\n     */\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\\n     */\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n}\\n\"\r\n    },\r\n    \"IERC777Recipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\\n *\\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\\n * contract implement this interface (contract holders can be their own\\n * implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777Recipient {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever tokens are being\\n     * moved or created into a registered account (`to`). The type of operation\\n     * is conveyed by `from` being the zero address or not.\\n     *\\n     * This call occurs _after_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"ViciNFTFulfillment.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"BadFraction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotCancelOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationLengthNotEqualToTotalOriginal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfallAmount\",\"type\":\"uint256\"}],\"name\":\"ConsiderationNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientNativeTokensSupplied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBasicOrderParameterEncoding\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidCallToConduit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidConduit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvalidMsgValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNativeOfferItem\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingOriginalConsiderationItems\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NativeTokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSpecifiedOrdersAvailable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderAlreadyFilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderIsCancelled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderPartiallyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartialFillsNotEnabledForOrder\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"CounterIncremented\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"DepositERC721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositERC777\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SpentItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct ReceivedItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"}],\"name\":\"OrderFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct OrderParameters\",\"name\":\"orderParameters\",\"type\":\"tuple\"}],\"name\":\"OrderValidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"orderHashes\",\"type\":\"bytes32[]\"}],\"name\":\"OrdersMatched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"WithdrawERC721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawERC777\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BANNED_ROLE_NAME\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DISPATCHER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MODERATOR_ROLE_NAME\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WALLET_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessServer\",\"outputs\":[{\"internalType\":\"contract IAccessServer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"}],\"name\":\"approveConsiderationToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ConduitItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ConduitTransfer[]\",\"name\":\"transfers\",\"type\":\"tuple[]\"}],\"name\":\"batchTransfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conduit\",\"outputs\":[{\"internalType\":\"contract ConduitInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conduitController\",\"outputs\":[{\"internalType\":\"contract ConduitControllerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conduitKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"enforceIsNotBanned\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"enforceIsNotSanctioned\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"enforceOwnerOrRole\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order\",\"name\":\"sellOrder\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"customer\",\"type\":\"address\"}],\"name\":\"fillAndTransfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"considerations\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offers\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"premintCheck\",\"type\":\"bool\"}],\"name\":\"fulfillPreflightCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"getCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes12\",\"name\":\"_conduitSuffix\",\"type\":\"bytes12\"}],\"name\":\"initConduit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAccessServer\",\"name\":\"_accessServer\",\"type\":\"address\"},{\"internalType\":\"contract ConsiderationInterface\",\"name\":\"_orderFiller\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"_conduitSuffix\",\"type\":\"bytes12\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBanned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSanctioned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"stuff\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"offerToConduitTransfer\",\"outputs\":[{\"components\":[{\"internalType\":\"enum ConduitItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ConduitTransfer[]\",\"name\":\"transfers\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderFiller\",\"outputs\":[{\"internalType\":\"contract ConsiderationInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"checkApprovalOnly\",\"type\":\"bool\"}],\"name\":\"preflightERC1155Check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"checkApprovalOnly\",\"type\":\"bool\"}],\"name\":\"preflightERC20Check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"checkApprovalOnly\",\"type\":\"bool\"}],\"name\":\"preflightERC721Check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ConduitItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"checkApprovalOnly\",\"type\":\"bool\"}],\"name\":\"preflightItemCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ConsiderationInterface\",\"name\":\"_orderFiller\",\"type\":\"address\"}],\"name\":\"setOrderFiller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"adminRole\",\"type\":\"bytes32\"}],\"name\":\"setRoleAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ConduitItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ConduitTransfer[]\",\"name\":\"transfers\",\"type\":\"tuple[]\"}],\"name\":\"transferPreflightCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"}],\"name\":\"unapproveConsiderationToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"updateChannel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC1155\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC777\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawERC777\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ViciNFTFulfillment", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}