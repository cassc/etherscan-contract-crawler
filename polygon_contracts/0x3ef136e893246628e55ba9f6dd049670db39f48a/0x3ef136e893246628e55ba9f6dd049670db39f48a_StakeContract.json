{"SourceCode": "{\"ERC1155Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ERC1155Receiver.sol\\\";\\r\\n\\r\\n/**\\r\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\r\\n *\\r\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\r\\n * stuck.\\r\\n *\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ncontract ERC1155Holder is ERC1155Receiver {\\r\\n    function onERC1155Received(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        uint256,\\r\\n        bytes memory\\r\\n    ) public virtual override returns (bytes4) {\\r\\n        return this.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    function onERC1155BatchReceived(\\r\\n        address,\\r\\n        address,\\r\\n        uint256[] memory,\\r\\n        uint256[] memory,\\r\\n        bytes memory\\r\\n    ) public virtual override returns (bytes4) {\\r\\n        return this.onERC1155BatchReceived.selector;\\r\\n    }\\r\\n}\\r\\n\"},\"ERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC1155Receiver.sol\\\";\\r\\nimport \\\"./ERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\r\\n    }\\r\\n}\\r\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\r\\n * for the additional interface id that will be supported. For example:\\r\\n *\\r\\n * ```solidity\\r\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\"},\"IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Receiver is IERC165 {\\r\\n    /**\\r\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\r\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer, this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n     * (i.e. 0xf23a6e61, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param id The ID of the token being transferred\\r\\n     * @param value The amount of tokens being transferred\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n\\r\\n    /**\\r\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\r\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\r\\n     * been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer(s), this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n     * (i.e. 0xbc197c81, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\r\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"Owner.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Owner\\r\\n * @dev Set \\u0026 change owner\\r\\n */\\r\\ncontract Owner {\\r\\n\\r\\n    address private owner;\\r\\n    \\r\\n    // event for EVM logging\\r\\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\\r\\n    \\r\\n    // modifier to check if caller is owner\\r\\n    modifier isOwner() {\\r\\n        // If the first argument of \\u0027require\\u0027 evaluates to \\u0027false\\u0027, execution terminates and all\\r\\n        // changes to the state and to Ether balances are reverted.\\r\\n        // This used to consume all gas in old EVM versions, but not anymore.\\r\\n        // It is often a good idea to use \\u0027require\\u0027 to check if functions are called correctly.\\r\\n        // As a second argument, you can also provide an explanation about what went wrong.\\r\\n        require(msg.sender == owner, \\\"Caller is not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Set contract deployer as owner\\r\\n     */\\r\\n    constructor() {\\r\\n        owner = msg.sender; // \\u0027msg.sender\\u0027 is sender of current call, contract deployer for a constructor\\r\\n        emit OwnerSet(address(0), owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Change owner\\r\\n     * @param newOwner address of new owner\\r\\n     */\\r\\n    function changeOwner(address newOwner) external isOwner { // ===\\r\\n        require(newOwner != address(0), \\\"ERC20: changeOwner newOwner the zero address\\\"); // ===\\r\\n        emit OwnerSet(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return owner address \\r\\n     * @return address of owner\\r\\n     */\\r\\n    function getOwner() public view returns (address) {\\r\\n        return owner;\\r\\n    }\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor () {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\"},\"Stake.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.6;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Owner.sol\\\";\\r\\nimport \\\"./ReentrancyGuard.sol\\\";\\r\\nimport \\\"./ERC1155Holder.sol\\\";\\r\\n\\r\\ninterface IERC1155{\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface Referrals{\\r\\n    function addReward1(address _referredAccount, uint256 _amount) external returns(uint256);\\r\\n    function addReward2(address _referredAccount, uint256 _amount) external returns(uint256);\\r\\n}\\r\\n\\r\\ncontract StakeContract is Owner, ReentrancyGuard, ERC1155Holder {\\r\\n\\r\\n    // nfts contract address \\r\\n    address public nfts;\\r\\n\\r\\n    // the token address to be used for pay rewards\\r\\n    address public rewardToken;\\r\\n\\r\\n    // referrals contract address \\r\\n    address public referrals;\\r\\n\\r\\n    // address with balance to be used to pay rewards\\r\\n    address public rewardWallet;\\r\\n\\r\\n    // minimum stake time in seconds\\r\\n    uint256 public MST;\\r\\n\\r\\n    // the Stake\\r\\n    struct Stake {\\r\\n        // stake Type\\r\\n        uint256 stakeTypeIndex;\\r\\n        // opening timestamp\\r\\n        uint256 startDate;\\r\\n        // amount staked\\r\\n    \\tuint256 amount;\\r\\n        // is active or not\\r\\n    \\tbool active;\\r\\n    }\\r\\n\\r\\n    // the StakeType\\r\\n    struct StakeType {\\r\\n        uint256 tokenId;\\r\\n        uint256 apy; // Annual Percentage Yield (1=1%)\\r\\n        uint256 LVLXUnitPrice;\\r\\n    \\tbool status; // true=actived, false=disabled\\r\\n    }\\r\\n\\r\\n    // stakes of address\\r\\n    mapping(address =\\u003e Stake[10]) public stakesOf;\\r\\n\\r\\n    // stake Type List\\r\\n    StakeType[20] public stakeTypeList;\\r\\n\\r\\n    event Set_TokenContracts(\\r\\n        address rewardToken,\\r\\n        address nfts,\\r\\n        address referrals\\r\\n    );\\r\\n\\r\\n    event Set_RewardWallet(\\r\\n        address rewardWallet\\r\\n    );\\r\\n\\r\\n    event Set_MST(\\r\\n        uint256 MST\\r\\n    );\\r\\n\\r\\n    event Set_StakeType(\\r\\n        uint256 index,\\r\\n        uint256 indexed tokenId,\\r\\n        uint256 apy,\\r\\n        uint256 LVLXUnitPrice,\\r\\n        bool status\\r\\n    );\\r\\n\\r\\n    event AddedStake(\\r\\n        uint256 stakeTypeIndex,\\r\\n        uint256 indexed tokenId,\\r\\n        uint256 startDate,\\r\\n        uint256 amount,\\r\\n        address indexed ownerStake\\r\\n    );\\r\\n\\r\\n    event WithdrawStake(\\r\\n        uint256 _withdrawType,\\r\\n        uint256 stakeTypeIndex,\\r\\n        uint256 indexed tokenId,\\r\\n        uint256 startDate,\\r\\n        uint256 withdrawDate,\\r\\n        uint256 interest,\\r\\n        uint256 amount,\\r\\n        address indexed ownerStake\\r\\n    );\\r\\n\\r\\n    constructor(address _rewardToken, address _nfts, address _referrals) {\\r\\n        setTokenContracts(_rewardToken, _nfts, _referrals);\\r\\n        setRewardWallet(getOwner());\\r\\n        setMST(2592000); // 30 days in seconds\\r\\n\\r\\n        uint256 mulByDec = 10**18;\\r\\n        setStakeType(0, 1, 84, 5000*mulByDec, true); // recreacion y turismo 7%/month = 84%/year\\r\\n        setStakeType(1, 2, 96, 10000*mulByDec, true); // transporte 8%/month = 96%/year\\r\\n        setStakeType(2, 3, 108, 20000*mulByDec, true); // hoteleria 9%/month = 108%/year\\r\\n    }\\r\\n\\r\\n    function setTokenContracts(address _rewardToken, address _nfts, address _referrals) public isOwner {\\r\\n        rewardToken = _rewardToken;\\r\\n        nfts = _nfts;\\r\\n        referrals = _referrals;\\r\\n        emit Set_TokenContracts(_rewardToken, _nfts, _referrals);\\r\\n    }\\r\\n\\r\\n    function setRewardWallet(address _newVal) public isOwner {\\r\\n        rewardWallet = _newVal;\\r\\n        emit Set_RewardWallet(_newVal);\\r\\n    }\\r\\n\\r\\n    function setMST(uint256 _newVal) public isOwner {\\r\\n        MST = _newVal;\\r\\n        emit Set_MST(_newVal);\\r\\n    }\\r\\n\\r\\n    function setStakeType(uint256 _index, uint256 _tokenId, uint256 _apy, uint256 _LVLXUnitPrice, bool _status) public isOwner {\\r\\n        require(_index \\u003e= 0 \\u0026\\u0026 _index \\u003c= 19, \\\"_index must be a number between 0 and 19\\\");\\r\\n        stakeTypeList[_index].tokenId = _tokenId;\\r\\n        stakeTypeList[_index].apy = _apy;\\r\\n        stakeTypeList[_index].LVLXUnitPrice = _LVLXUnitPrice;\\r\\n        stakeTypeList[_index].status = _status;\\r\\n        emit Set_StakeType(_index, _tokenId, _apy, _LVLXUnitPrice, _status);\\r\\n    }\\r\\n\\r\\n    function calculateInterest(uint256 _stakeTypeIndex, uint256 _stakeStartDate, uint256 _stakeAmount) public view returns (uint256) {\\r\\n        uint256 apy = stakeTypeList[_stakeTypeIndex].apy;\\r\\n        uint256 LVLXUnitPrice = stakeTypeList[_stakeTypeIndex].LVLXUnitPrice;\\r\\n\\r\\n        // APY per year = amount * APY / 100\\r\\n        uint256 interest_per_year = ((_stakeAmount*LVLXUnitPrice) * apy) / 100;\\r\\n\\r\\n        // number of seconds since opening date\\r\\n        uint256 num_seconds = block.timestamp - _stakeStartDate;\\r\\n\\r\\n        // calculate interest by a rule of three\\r\\n        //  seconds of the year: 31536000 = 365*24*60*60\\r\\n        //  interest_per_year   -   31536000\\r\\n        //  interest            -   num_seconds\\r\\n        //  interest = num_seconds * interest_per_year / 31536000\\r\\n        return (num_seconds * interest_per_year) / 31536000;\\r\\n    }\\r\\n\\r\\n    function getIndexToCreateStake(address _account) private view returns (uint256) {\\r\\n        uint256 index = 10;\\r\\n        for(uint256 i=0; i\\u003cstakesOf[_account].length; i++){\\r\\n            if(!stakesOf[_account][i].active){\\r\\n                index = i;\\r\\n            }\\r\\n        }\\r\\n        // if (index \\u003c 10)  = limit not reached\\r\\n        // if (index == 10) = limit reached\\r\\n        return index; \\r\\n    }\\r\\n\\r\\n    // anyone can create a stake\\r\\n    function createStake(uint256 _stakeTypeIndex, uint256 _amount) external {\\r\\n        require(stakeTypeList[_stakeTypeIndex].status, \\\"_stakeTypeIndex is not valid or is not active\\\");\\r\\n        uint256 index = getIndexToCreateStake(msg.sender);\\r\\n        require(index \\u003c 10, \\\"stakes limit reached\\\");\\r\\n        uint256 tokenId = stakeTypeList[_stakeTypeIndex].tokenId;\\r\\n        // store the tokens of the user in the contract\\r\\n        // requires approve\\r\\n        IERC1155(nfts).safeTransferFrom(msg.sender, address(this), tokenId, _amount, \\\"\\\");\\r\\n        // create the stake\\r\\n        stakesOf[msg.sender][index] = Stake(_stakeTypeIndex, block.timestamp, _amount, true);\\r\\n        emit AddedStake(_stakeTypeIndex, tokenId, block.timestamp, _amount, msg.sender);\\r\\n    }\\r\\n\\r\\n    function withdrawStake(uint256 _arrayIndex, uint256 _withdrawType) external nonReentrant { // _withdrawType (1=normal withdraw, 2=withdraw only rewards)\\r\\n        require(_withdrawType\\u003e=1 \\u0026\\u0026 _withdrawType\\u003c=2, \\\"invalid _withdrawType\\\");\\r\\n        // Stake should exists and opened\\r\\n        require(_arrayIndex \\u003c stakesOf[msg.sender].length, \\\"Stake does not exist\\\");\\r\\n        Stake memory stk = stakesOf[msg.sender][_arrayIndex];\\r\\n        require(stk.active, \\\"This stake is not active\\\");\\r\\n        require((block.timestamp - stk.startDate) \\u003e= MST, \\\"the minimum stake time has not been completed yet\\\");\\r\\n        uint256 tokenId = stakeTypeList[stk.stakeTypeIndex].tokenId;\\r\\n\\r\\n        // get the interest\\r\\n        uint256 interest = calculateInterest(stk.stakeTypeIndex, stk.startDate, stk.amount);\\r\\n        interest = interest - Referrals(referrals).addReward2(msg.sender, interest);\\r\\n\\r\\n        // transfer the interes from rewardWallet, it has to have enough funds approved\\r\\n        IERC20(rewardToken).transferFrom(rewardWallet, msg.sender, interest);\\r\\n\\r\\n        if(_withdrawType == 1){\\r\\n            // transfer the NFTs from the contract itself\\r\\n            IERC1155(nfts).safeTransferFrom(address(this), msg.sender, tokenId, stk.amount, \\\"\\\");\\r\\n            // stake closing\\r\\n            delete stakesOf[msg.sender][_arrayIndex];\\r\\n        }else{\\r\\n            // restart stake\\r\\n            stakesOf[msg.sender][_arrayIndex].startDate = block.timestamp;\\r\\n        }\\r\\n\\r\\n        emit WithdrawStake(_withdrawType, stk.stakeTypeIndex, tokenId, stk.startDate, block.timestamp, interest, stk.amount, msg.sender);\\r\\n    }\\r\\n\\r\\n    function getStakesOf(address _account) external view returns(uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory, bool[] memory){\\r\\n        uint256 stakesLength = stakesOf[_account].length;\\r\\n        uint256[] memory tokenIdList = new uint256[](stakesLength);\\r\\n        uint256[] memory startDateList = new uint256[](stakesLength);\\r\\n        uint256[] memory amountList = new uint256[](stakesLength);\\r\\n        uint256[] memory interestList = new uint256[](stakesLength);\\r\\n        bool[] memory activeList = new bool[](stakesLength);\\r\\n\\r\\n        for(uint256 i=0; i\\u003cstakesLength; i++){\\r\\n            Stake memory stk = stakesOf[_account][i];\\r\\n            tokenIdList[i] = stakeTypeList[stk.stakeTypeIndex].tokenId;\\r\\n            startDateList[i] = stk.startDate;\\r\\n            amountList[i] = stk.amount;\\r\\n            interestList[i] = calculateInterest(stk.stakeTypeIndex, stk.startDate, stk.amount);\\r\\n            activeList[i] = stk.active;\\r\\n        }\\r\\n\\r\\n        return (tokenIdList, startDateList, amountList, interestList, activeList);\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nfts\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrals\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeTypeIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerStake\",\"type\":\"address\"}],\"name\":\"AddedStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"MST\",\"type\":\"uint256\"}],\"name\":\"Set_MST\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardWallet\",\"type\":\"address\"}],\"name\":\"Set_RewardWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LVLXUnitPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Set_StakeType\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nfts\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrals\",\"type\":\"address\"}],\"name\":\"Set_TokenContracts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_withdrawType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeTypeIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerStake\",\"type\":\"address\"}],\"name\":\"WithdrawStake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeTypeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeStartDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"}],\"name\":\"calculateInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeTypeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"createStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getStakesOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nfts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newVal\",\"type\":\"uint256\"}],\"name\":\"setMST\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newVal\",\"type\":\"address\"}],\"name\":\"setRewardWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_LVLXUnitPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setStakeType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nfts\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrals\",\"type\":\"address\"}],\"name\":\"setTokenContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeTypeList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LVLXUnitPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeTypeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_arrayIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawType\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakeContract", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000034b12ca94903c67a057c5f9f0014ba6945b15b180000000000000000000000005099e14b1fdf0b3b66af86378e403cbd7190b06c000000000000000000000000f0a8888a3aa1ad7d6cdb6dbb27f2efafd4ae6b0b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d3609408a4075dac55dd2b2d1f3356bafa62f4187ff603b0956fda091799f56f"}