{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StealthKeyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\ncontract StealthKeyRegistry {\\n  // =========================================== Events ============================================\\n\\n  /// @dev Event emitted when a user updates their registered stealth keys\\n  event StealthKeyChanged(\\n    address indexed registrant,\\n    uint256 spendingPubKeyPrefix,\\n    uint256 spendingPubKey,\\n    uint256 viewingPubKeyPrefix,\\n    uint256 viewingPubKey\\n  );\\n\\n  // ======================================= State variables =======================================\\n\\n  /// @dev The payload typehash used for EIP-712 signatures in setStealthKeysOnBehalf\\n  bytes32 public constant STEALTHKEYS_TYPEHASH =\\n    keccak256(\\n      \\\"StealthKeys(uint256 spendingPubKeyPrefix,uint256 spendingPubKey,uint256 viewingPubKeyPrefix,uint256 viewingPubKey)\\\"\\n    );\\n\\n  /// @dev The domain separator used for EIP-712 sigatures in setStealthKeysOnBehalf\\n  bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n  /**\\n   * @dev Mapping used to store two secp256k1 curve public keys used for\\n   * receiving stealth payments. The mapping records two keys: a viewing\\n   * key and a spending key, which can be set and read via the `setStealthKeys`\\n   * and `stealthKey` methods respectively.\\n   *\\n   * The mapping associates the user's address to another mapping, which itself maps\\n   * the public key prefix to the actual key . This scheme is used to avoid using an\\n   * extra storage slot for the public key prefix. For a given address, the mapping\\n   * may contain a spending key at position 0 or 1, and a viewing key at position\\n   * 2 or 3. See the setter/getter methods for details of how these map to prefixes.\\n   *\\n   * For more on secp256k1 public keys and prefixes generally, see:\\n   * https://github.com/ethereumbook/ethereumbook/blob/develop/04keys-addresses.asciidoc#generating-a-public-key\\n   */\\n  mapping(address => mapping(uint256 => uint256)) keys;\\n\\n  /**\\n   * @dev We wait until deployment to codify the domain separator because we need the\\n   * chainId and the contract address\\n   */\\n  constructor() {\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n        keccak256(bytes(\\\"Umbra Stealth Key Registry\\\")),\\n        keccak256(bytes(\\\"1\\\")),\\n        block.chainid,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  // ======================================= Set Keys ===============================================\\n\\n  /**\\n   * @notice Sets stealth keys for the caller\\n   * @param _spendingPubKeyPrefix Prefix of the spending public key (2 or 3)\\n   * @param _spendingPubKey The public key for generating a stealth address\\n   * @param _viewingPubKeyPrefix Prefix of the viewing public key (2 or 3)\\n   * @param _viewingPubKey The public key to use for encryption\\n   */\\n  function setStealthKeys(\\n    uint256 _spendingPubKeyPrefix,\\n    uint256 _spendingPubKey,\\n    uint256 _viewingPubKeyPrefix,\\n    uint256 _viewingPubKey\\n  ) external {\\n    _setStealthKeys(msg.sender, _spendingPubKeyPrefix, _spendingPubKey, _viewingPubKeyPrefix, _viewingPubKey);\\n  }\\n\\n  /**\\n   * @notice Sets stealth keys for the registrant using an EIP-712 signature to\\n   * authenticate the update on their behalf.\\n   * @param _registrant The address for which stealth keys are being registered,\\n   * i.e. the address expected to be recovered from the provided signature\\n   * @param _spendingPubKeyPrefix Prefix of the spending public key (2 or 3)\\n   * @param _spendingPubKey The public key for generating a stealth address\\n   * @param _viewingPubKeyPrefix Prefix of the viewing public key (2 or 3)\\n   * @param _viewingPubKey The public key to use for encryption\\n   * @param _v ECDSA signature component: Parity of the `y` coordinate of point `R`\\n   * @param _r ECDSA signature component: x-coordinate of `R`\\n   * @param _s ECDSA signature component: `s` value of the signature\\n   */\\n  function setStealthKeysOnBehalf(\\n    address _registrant,\\n    uint256 _spendingPubKeyPrefix,\\n    uint256 _spendingPubKey,\\n    uint256 _viewingPubKeyPrefix,\\n    uint256 _viewingPubKey,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external {\\n    // create EIP-712 Digest\\n    bytes32 _digest =\\n      keccak256(\\n        abi.encodePacked(\\n          \\\"\\\\x19\\\\x01\\\",\\n          DOMAIN_SEPARATOR,\\n          keccak256(\\n            abi.encode(\\n              STEALTHKEYS_TYPEHASH,\\n              _spendingPubKeyPrefix,\\n              _spendingPubKey,\\n              _viewingPubKeyPrefix,\\n              _viewingPubKey\\n            )\\n          )\\n        )\\n      );\\n\\n    // recover the signing address and ensure it matches the registrant\\n    address _recovered = ecrecover(_digest, _v, _r, _s);\\n    require(_recovered == _registrant, \\\"StealthKeyRegistry: Invalid Signature\\\");\\n\\n    // now that we know the registrant has authorized it, update the stealth keys\\n    _setStealthKeys(_registrant, _spendingPubKeyPrefix, _spendingPubKey, _viewingPubKeyPrefix, _viewingPubKey);\\n  }\\n\\n  /**\\n   * @dev Internal method for setting stealth key that must be called after safety\\n   * check on registrant; see calling method for parameter details\\n   */\\n  function _setStealthKeys(\\n    address _registrant,\\n    uint256 _spendingPubKeyPrefix,\\n    uint256 _spendingPubKey,\\n    uint256 _viewingPubKeyPrefix,\\n    uint256 _viewingPubKey\\n  ) internal {\\n    require(\\n      (_spendingPubKeyPrefix == 2 || _spendingPubKeyPrefix == 3) &&\\n        (_viewingPubKeyPrefix == 2 || _viewingPubKeyPrefix == 3),\\n      \\\"StealthKeyRegistry: Invalid Prefix\\\"\\n    );\\n\\n    emit StealthKeyChanged(_registrant, _spendingPubKeyPrefix, _spendingPubKey, _viewingPubKeyPrefix, _viewingPubKey);\\n\\n    // Shift the spending key prefix down by 2, making it the appropriate index of 0 or 1\\n    _spendingPubKeyPrefix -= 2;\\n\\n    // Ensure the opposite prefix indices are empty\\n    delete keys[_registrant][1 - _spendingPubKeyPrefix];\\n    delete keys[_registrant][5 - _viewingPubKeyPrefix];\\n\\n    // Set the appropriate indices to the new key values\\n    keys[_registrant][_spendingPubKeyPrefix] = _spendingPubKey;\\n    keys[_registrant][_viewingPubKeyPrefix] = _viewingPubKey;\\n  }\\n\\n  // ======================================= Get Keys ===============================================\\n\\n  /**\\n   * @notice Returns the stealth key associated with an address.\\n   * @param _registrant The address whose keys to lookup.\\n   * @return spendingPubKeyPrefix Prefix of the spending public key (2 or 3)\\n   * @return spendingPubKey The public key for generating a stealth address\\n   * @return viewingPubKeyPrefix Prefix of the viewing public key (2 or 3)\\n   * @return viewingPubKey The public key to use for encryption\\n   */\\n  function stealthKeys(address _registrant)\\n    external\\n    view\\n    returns (\\n      uint256 spendingPubKeyPrefix,\\n      uint256 spendingPubKey,\\n      uint256 viewingPubKeyPrefix,\\n      uint256 viewingPubKey\\n    )\\n  {\\n    if (keys[_registrant][0] != 0) {\\n      spendingPubKeyPrefix = 2;\\n      spendingPubKey = keys[_registrant][0];\\n    } else {\\n      spendingPubKeyPrefix = 3;\\n      spendingPubKey = keys[_registrant][1];\\n    }\\n\\n    if (keys[_registrant][2] != 0) {\\n      viewingPubKeyPrefix = 2;\\n      viewingPubKey = keys[_registrant][2];\\n    } else {\\n      viewingPubKeyPrefix = 3;\\n      viewingPubKey = keys[_registrant][3];\\n    }\\n\\n    return (spendingPubKeyPrefix, spendingPubKey, viewingPubKeyPrefix, viewingPubKey);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"registrant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spendingPubKeyPrefix\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spendingPubKey\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"viewingPubKeyPrefix\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"viewingPubKey\",\"type\":\"uint256\"}],\"name\":\"StealthKeyChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STEALTHKEYS_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_spendingPubKeyPrefix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_spendingPubKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_viewingPubKeyPrefix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_viewingPubKey\",\"type\":\"uint256\"}],\"name\":\"setStealthKeys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registrant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_spendingPubKeyPrefix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_spendingPubKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_viewingPubKeyPrefix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_viewingPubKey\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"setStealthKeysOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registrant\",\"type\":\"address\"}],\"name\":\"stealthKeys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spendingPubKeyPrefix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spendingPubKey\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"viewingPubKeyPrefix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"viewingPubKey\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StealthKeyRegistry", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}