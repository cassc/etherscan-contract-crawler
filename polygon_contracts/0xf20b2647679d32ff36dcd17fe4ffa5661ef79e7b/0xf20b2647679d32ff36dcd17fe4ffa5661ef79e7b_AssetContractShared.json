{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/ronak/Developer/projects/tsgit/swappable-asset-contracts/contracts/AssetContractShared.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\nimport \\\"./AssetContract.sol\\\";\\nimport \\\"./TokenIdentifiers.sol\\\";\\n/**\\n * @title AssetContractShared\\n * Swappable shared asset contract - A contract for easily creating custom assets on Swappable\\n */\\ncontract AssetContractShared is AssetContract, ReentrancyGuard {\\n    mapping(address => bool) public sharedProxyAddresses;\\n    using SafeMath for uint256;\\n    using TokenIdentifiers for uint256;\\n\\n    event CreatorChanged(uint256 indexed _id, address indexed _creator);\\n\\n    mapping(uint256 => address) internal _creatorOverride;\\n\\n    /**\\n     * @dev Require msg.sender to be the creator of the token id\\n     */\\n    modifier creatorOnly(uint256 _id) {\\n        require(\\n            _isCreatorOrProxy(_id, _msgSender()),\\n            \\\"AssetContractShared#creatorOnly: ONLY_CREATOR_ALLOWED\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _proxyRegistryAddress,\\n        string memory _templateURI\\n    )\\n        public\\n        AssetContract(_name, _symbol, _proxyRegistryAddress, _templateURI)\\n    {}\\n\\n    /**\\n     * @dev Allows owner to change the proxy registry\\n     */\\n    function setProxyRegistryAddress(address _address) public onlyOwner {\\n        proxyRegistryAddress = _address;\\n    }\\n\\n    /**\\n     * @dev Allows owner to add a shared proxy address\\n     */\\n    function addSharedProxyAddress(address _address) public onlyOwner {\\n        sharedProxyAddresses[_address] = true;\\n    }\\n\\n    /**\\n     * @dev Allows owner to remove a shared proxy address\\n     */\\n    function removeSharedProxyAddress(address _address) public onlyOwner {\\n        delete sharedProxyAddresses[_address];\\n    }\\n\\n    function mint(\\n        address _to,\\n        uint256 _id,\\n        uint256 _quantity,\\n        bytes memory _data\\n    ) public nonReentrant() {\\n        _requireMintable(_msgSender(), _id, _quantity);\\n        _mint(_to, _id, _quantity, _data);\\n    }\\n\\n    function batchMint(\\n        address _to,\\n        uint256[] memory _ids,\\n        uint256[] memory _quantities,\\n        bytes memory _data\\n    ) public nonReentrant() {\\n        for (uint256 i = 0; i < _ids.length; i++) {\\n            _requireMintable(_msgSender(), _ids[i], _quantities[i]);\\n        }\\n        _batchMint(_to, _ids, _quantities, _data);\\n    }\\n\\n    /////////////////////////////////\\n    // CONVENIENCE CREATOR METHODS //\\n    /////////////////////////////////\\n\\n    /**\\n     * @dev Will update the URI for the token\\n     * @param _id The token ID to update. msg.sender must be its creator.\\n     * @param _uri New URI for the token.\\n     */\\n    function setURI(uint256 _id, string memory _uri) public creatorOnly(_id) {\\n        _setURI(_id, _uri);\\n    }\\n\\n    /**\\n     * @dev Change the creator address for given token\\n     * @param _to   Address of the new creator\\n     * @param _id  Token IDs to change creator of\\n     */\\n    function setCreator(uint256 _id, address _to) public creatorOnly(_id) {\\n        require(\\n            _to != address(0),\\n            \\\"AssetContractShared#setCreator: INVALID_ADDRESS.\\\"\\n        );\\n        _creatorOverride[_id] = _to;\\n        emit CreatorChanged(_id, _to);\\n    }\\n\\n    /**\\n     * @dev Get the creator for a token\\n     * @param _id   The token id to look up\\n     */\\n    function creator(uint256 _id) public view returns (address) {\\n        if (_creatorOverride[_id] != address(0)) {\\n            return _creatorOverride[_id];\\n        } else {\\n            return _id.tokenCreator();\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the maximum supply for a token\\n     * @param _id   The token id to look up\\n     */\\n    function maxSupply(uint256 _id) public pure returns (uint256) {\\n        return _id.tokenMaxSupply();\\n    }\\n\\n    // Override ERC1155Tradable for birth events\\n    function _origin(uint256 _id) internal view returns (address) {\\n        return _id.tokenCreator();\\n    }\\n\\n    function _requireMintable(\\n        address _address,\\n        uint256 _id,\\n        uint256 _amount\\n    ) internal view {\\n        require(\\n            _isCreatorOrProxy(_id, _address),\\n            \\\"AssetContractShared#_requireMintable: ONLY_CREATOR_ALLOWED\\\"\\n        );\\n        require(\\n            _remainingSupply(_id) >= _amount,\\n            \\\"AssetContractShared#_requireMintable: SUPPLY_EXCEEDED\\\"\\n        );\\n    }\\n\\n    function _remainingSupply(uint256 _id) internal view returns (uint256) {\\n        return maxSupply(_id).sub(totalSupply(_id));\\n    }\\n\\n    function _isCreatorOrProxy(uint256 _id, address _address)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        address creator_ = creator(_id);\\n        return creator_ == _address || _isProxyForUser(creator_, _address);\\n    }\\n\\n    // Overrides ERC1155Tradable to allow a shared proxy address\\n    function _isProxyForUser(address _user, address _address)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (sharedProxyAddresses[_address]) {\\n            return true;\\n        }\\n        return super._isProxyForUser(_user, _address);\\n    }\\n}\"\r\n    },\r\n    \"multi-token-standard/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n\\n/**\\n * @title ERC165\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\ninterface IERC165 {\\n\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @dev Interface identification is specified in ERC-165. This function\\n     * uses less than 30,000 gas\\n     * @param _interfaceId The interface identifier, as specified in ERC-165\\n     */\\n    function supportsInterface(bytes4 _interfaceId)\\n    external\\n    view\\n    returns (bool);\\n}\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"multi-token-standard/contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n   * @dev Multiplies two unsigned integers, reverts on overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath#mul: OVERFLOW\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, \\\"SafeMath#div: DIVISION_BY_ZERO\\\");\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, \\\"SafeMath#sub: UNDERFLOW\\\");\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Adds two unsigned integers, reverts on overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"SafeMath#add: OVERFLOW\\\");\\n\\n    return c; \\n  }\\n\\n  /**\\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n   * reverts when dividing by zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"SafeMath#mod: DIVISION_BY_ZERO\\\");\\n    return a % b;\\n  }\\n}\"\r\n    },\r\n    \"multi-token-standard/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n\\n  // Default hash for EOA accounts returned by extcodehash\\n  bytes32 constant internal ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n  /**\\n   * Returns whether the target address is a contract\\n   * @dev This function will return false if invoked during the constructor of a contract.\\n   * @param _address address of the account to check\\n   * @return Whether the target address is a contract\\n   */\\n  function isContract(address _address) internal view returns (bool) {\\n    bytes32 codehash;\\n\\n    // Currently there is no better way to check if there is a contract in an address\\n    // than to check the size of the code at that address or if it has a non-zero code hash or account hash\\n    assembly { codehash := extcodehash(_address) }\\n    return (codehash != 0x0 && codehash != ACCOUNT_HASH);\\n  }\\n}\"\r\n    },\r\n    \"multi-token-standard/contracts/tokens/ERC1155/ERC1155MintBurn.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\nimport \\\"./ERC1155.sol\\\";\\n\\n\\n/**\\n * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\\n *      a parent contract to be executed as they are `internal` functions\\n */\\ncontract ERC1155MintBurn is ERC1155 {\\n\\n  /****************************************|\\n  |            Minting Functions           |\\n  |_______________________________________*/\\n\\n  /**\\n   * @notice Mint _amount of tokens of a given id\\n   * @param _to      The address to mint tokens to\\n   * @param _id      Token id to mint\\n   * @param _amount  The amount to be minted\\n   * @param _data    Data to pass if receiver is contract\\n   */\\n  function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\\n    internal\\n  {\\n    // Add _amount\\n    balances[_to][_id] = balances[_to][_id].add(_amount);\\n\\n    // Emit event\\n    emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\\n\\n    // Calling onReceive method if recipient is contract\\n    _callonERC1155Received(address(0x0), _to, _id, _amount, gasleft(), _data);\\n  }\\n\\n  /**\\n   * @notice Mint tokens for each ids in _ids\\n   * @param _to       The address to mint tokens to\\n   * @param _ids      Array of ids to mint\\n   * @param _amounts  Array of amount of tokens to mint per id\\n   * @param _data    Data to pass if receiver is contract\\n   */\\n  function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\\n    internal\\n  {\\n    require(_ids.length == _amounts.length, \\\"ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH\\\");\\n\\n    // Number of mints to execute\\n    uint256 nMint = _ids.length;\\n\\n     // Executing all minting\\n    for (uint256 i = 0; i < nMint; i++) {\\n      // Update storage balance\\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\\n    }\\n\\n    // Emit batch mint event\\n    emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\\n\\n    // Calling onReceive method if recipient is contract\\n    _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, gasleft(), _data);\\n  }\\n\\n\\n  /****************************************|\\n  |            Burning Functions           |\\n  |_______________________________________*/\\n\\n  /**\\n   * @notice Burn _amount of tokens of a given token id\\n   * @param _from    The address to burn tokens from\\n   * @param _id      Token id to burn\\n   * @param _amount  The amount to be burned\\n   */\\n  function _burn(address _from, uint256 _id, uint256 _amount)\\n    internal\\n  {\\n    //Substract _amount\\n    balances[_from][_id] = balances[_from][_id].sub(_amount);\\n\\n    // Emit event\\n    emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\\n  }\\n\\n  /**\\n   * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\\n   * @param _from     The address to burn tokens from\\n   * @param _ids      Array of token ids to burn\\n   * @param _amounts  Array of the amount to be burned\\n   */\\n  function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\\n    internal\\n  {\\n    // Number of mints to execute\\n    uint256 nBurn = _ids.length;\\n    require(nBurn == _amounts.length, \\\"ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH\\\");\\n\\n    // Executing all minting\\n    for (uint256 i = 0; i < nBurn; i++) {\\n      // Update storage balance\\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\\n    }\\n\\n    // Emit batch mint event\\n    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\\n  }\\n}\\n\\n\"\r\n    },\r\n    \"multi-token-standard/contracts/tokens/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"../../interfaces/IERC165.sol\\\";\\nimport \\\"../../utils/SafeMath.sol\\\";\\nimport \\\"../../interfaces/IERC1155TokenReceiver.sol\\\";\\nimport \\\"../../interfaces/IERC1155.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n\\n/**\\n * @dev Implementation of Multi-Token Standard contract\\n */\\ncontract ERC1155 is IERC165, IERC1155 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  /***********************************|\\n  |        Variables and Events       |\\n  |__________________________________*/\\n\\n  // onReceive function signatures\\n  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\\n  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\\n\\n  // Objects balances\\n  mapping (address => mapping(uint256 => uint256)) internal balances;\\n\\n  // Operator Functions\\n  mapping (address => mapping(address => bool)) internal operators;\\n\\n\\n  /***********************************|\\n  |     Public Transfer Functions     |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   * @param _data    Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\\n    public\\n  {\\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \\\"ERC1155#safeTransferFrom: INVALID_OPERATOR\\\");\\n    require(_to != address(0),\\\"ERC1155#safeTransferFrom: INVALID_RECIPIENT\\\");\\n    // require(_amount <= balances[_from][_id]) is not necessary since checked with safemath operations\\n\\n    _safeTransferFrom(_from, _to, _id, _amount);\\n    _callonERC1155Received(_from, _to, _id, _amount, gasleft(), _data);\\n  }\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   * @param _data     Additional data with no specified format, sent in call to `_to`\\n   */\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\\n    public\\n  {\\n    // Requirements\\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \\\"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\\\");\\n    require(_to != address(0), \\\"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\\\");\\n\\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasleft(), _data);\\n  }\\n\\n\\n  /***********************************|\\n  |    Internal Transfer Functions    |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\\n   * @param _from    Source address\\n   * @param _to      Target address\\n   * @param _id      ID of the token type\\n   * @param _amount  Transfered amount\\n   */\\n  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\\n    internal\\n  {\\n    // Update balances\\n    balances[_from][_id] = balances[_from][_id].sub(_amount); // Subtract amount\\n    balances[_to][_id] = balances[_to][_id].add(_amount);     // Add amount\\n\\n    // Emit event\\n    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\\n  }\\n\\n  /**\\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\\n   */\\n  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, uint256 _gasLimit, bytes memory _data)\\n    internal\\n  {\\n    // Check if recipient is contract\\n    if (_to.isContract()) {\\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received.gas(_gasLimit)(msg.sender, _from, _id, _amount, _data);\\n      require(retval == ERC1155_RECEIVED_VALUE, \\\"ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE\\\");\\n    }\\n  }\\n\\n  /**\\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n   * @param _from     Source addresses\\n   * @param _to       Target addresses\\n   * @param _ids      IDs of each token type\\n   * @param _amounts  Transfer amounts per token type\\n   */\\n  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\\n    internal\\n  {\\n    require(_ids.length == _amounts.length, \\\"ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH\\\");\\n\\n    // Number of transfer to execute\\n    uint256 nTransfer = _ids.length;\\n\\n    // Executing all transfers\\n    for (uint256 i = 0; i < nTransfer; i++) {\\n      // Update storage balance of previous bin\\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\\n    }\\n\\n    // Emit event\\n    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\\n  }\\n\\n  /**\\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\\n   */\\n  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, uint256 _gasLimit, bytes memory _data)\\n    internal\\n  {\\n    // Pass data if recipient is contract\\n    if (_to.isContract()) {\\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived.gas(_gasLimit)(msg.sender, _from, _ids, _amounts, _data);\\n      require(retval == ERC1155_BATCH_RECEIVED_VALUE, \\\"ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE\\\");\\n    }\\n  }\\n\\n\\n  /***********************************|\\n  |         Operator Functions        |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved)\\n    external\\n  {\\n    // Update operator status\\n    operators[msg.sender][_operator] = _approved;\\n    emit ApprovalForAll(msg.sender, _operator, _approved);\\n  }\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator)\\n    public view returns (bool isOperator)\\n  {\\n    return operators[_owner][_operator];\\n  }\\n\\n\\n  /***********************************|\\n  |         Balance Functions         |\\n  |__________________________________*/\\n\\n  /**\\n   * @notice Get the balance of an account's Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return The _owner's balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id)\\n    public view returns (uint256)\\n  {\\n    return balances[_owner][_id];\\n  }\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\\n    public view returns (uint256[] memory)\\n  {\\n    require(_owners.length == _ids.length, \\\"ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH\\\");\\n\\n    // Variables\\n    uint256[] memory batchBalances = new uint256[](_owners.length);\\n\\n    // Iterate over each owner and token ID\\n    for (uint256 i = 0; i < _owners.length; i++) {\\n      batchBalances[i] = balances[_owners[i]][_ids[i]];\\n    }\\n\\n    return batchBalances;\\n  }\\n\\n\\n  /***********************************|\\n  |          ERC165 Functions         |\\n  |__________________________________*/\\n\\n  /**\\n   * INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256(\\\"supportsInterface(bytes4)\\\"));\\n   */\\n  bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\\n\\n  /**\\n   * INTERFACE_SIGNATURE_ERC1155 =\\n   * bytes4(keccak256(\\\"safeTransferFrom(address,address,uint256,uint256,bytes)\\\")) ^\\n   * bytes4(keccak256(\\\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\\\")) ^\\n   * bytes4(keccak256(\\\"balanceOf(address,uint256)\\\")) ^\\n   * bytes4(keccak256(\\\"balanceOfBatch(address[],uint256[])\\\")) ^\\n   * bytes4(keccak256(\\\"setApprovalForAll(address,bool)\\\")) ^\\n   * bytes4(keccak256(\\\"isApprovedForAll(address,address)\\\"));\\n   */\\n  bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param _interfaceID  The interface identifier, as specified in ERC-165\\n   * @return `true` if the contract implements `_interfaceID` and\\n   */\\n  function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\\n    if (_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\\n        _interfaceID == INTERFACE_SIGNATURE_ERC1155) {\\n      return true;\\n    }\\n    return false;\\n  }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"multi-token-standard/contracts/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n * @dev ERC-1155 interface for accepting safe transfers.\\n */\\ninterface IERC1155TokenReceiver {\\n\\n  /**\\n   * @notice Handle the receipt of a single ERC1155 token type\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value MUST result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _id        The id of the token being transferred\\n   * @param _amount    The amount of tokens being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n   */\\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\\n\\n  /**\\n   * @notice Handle the receipt of multiple ERC1155 token types\\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\\n   * This function MAY throw to revert and reject the transfer\\n   * Return of other amount than the magic value WILL result in the transaction being reverted\\n   * Note: The token contract address is always the message sender\\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\\n   * @param _from      The address which previously owned the token\\n   * @param _ids       An array containing ids of each token being transferred\\n   * @param _amounts   An array containing amounts of each token being transferred\\n   * @param _data      Additional data with no specified format\\n   * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n   */\\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\\n\\n  /**\\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\\n   *      This function MUST NOT consume more than 5,000 gas.\\n   * @return Whether ERC-165 or ERC1155TokenReceiver interfaces are supported.\\n   */\\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"multi-token-standard/contracts/interfaces/IERC1155.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n\\ninterface IERC1155 {\\n\\n  /****************************************|\\n  |                 Events                 |\\n  |_______________________________________*/\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n  /**\\n   * @dev MUST emit when the URI is updated for a token ID\\n   *   URIs are defined in RFC 3986\\n   *   The URI MUST point a JSON file that conforms to the \\\"ERC-1155 Metadata JSON Schema\\\"\\n   */\\n  event URI(string _amount, uint256 indexed _id);\\n\\n\\n  /****************************************|\\n  |                Functions               |\\n  |_______________________________________*/\\n\\n  /**\\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\\n    * @dev MUST emit TransferSingle event on success\\n    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n    * MUST throw if `_to` is the zero address\\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\n    * MUST throw on any other error\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n    * @param _from    Source address\\n    * @param _to      Target address\\n    * @param _id      ID of the token type\\n    * @param _amount  Transfered amount\\n    * @param _data    Additional data with no specified format, sent in call to `_to`\\n    */\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\\n\\n  /**\\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n    * @dev MUST emit TransferBatch event on success\\n    * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\\n    * MUST throw if `_to` is the zero address\\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\n    * MUST throw on any other error\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\n    * @param _from     Source addresses\\n    * @param _to       Target addresses\\n    * @param _ids      IDs of each token type\\n    * @param _amounts  Transfer amounts per token type\\n    * @param _data     Additional data with no specified format, sent in call to `_to`\\n  */\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\\n\\n  /**\\n   * @notice Get the balance of an account's Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return        The _owner's balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller's tokens\\n   * @dev MUST emit the ApprovalForAll event on success\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return           True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\n}\\n\"\r\n    },\r\n    \"/Users/ronak/Developer/projects/tsgit/swappable-asset-contracts/contracts/TokenIdentifiers.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"multi-token-standard/contracts/utils/SafeMath.sol\\\";\\n\\n/*\\n  DESIGN NOTES:\\n  Token ids are a concatenation of:\\n * creator: hex address of the creator of the token. 160 bits\\n * index: Index for this token (the regular ID), up to 2^56 - 1. 56 bits\\n * supply: Supply cap for this token, up to 2^40 - 1 (1 trillion).  40 bits\\n\\n*/\\n/**\\n * @title TokenIdentifiers\\n * support for authentication and metadata for token ids\\n */\\nlibrary TokenIdentifiers {\\n    using SafeMath for uint256;\\n\\n    uint8 constant ADDRESS_BITS = 160;\\n    uint8 constant INDEX_BITS = 56;\\n    uint8 constant SUPPLY_BITS = 40;\\n\\n    uint256 constant SUPPLY_MASK = (uint256(1) << SUPPLY_BITS) - 1;\\n    uint256 constant INDEX_MASK = ((uint256(1) << INDEX_BITS) - 1) ^\\n        SUPPLY_MASK;\\n\\n    function tokenMaxSupply(uint256 _id) internal pure returns (uint256) {\\n        return _id & SUPPLY_MASK;\\n    }\\n\\n    function tokenIndex(uint256 _id) internal pure returns (uint256) {\\n        return _id & INDEX_MASK;\\n    }\\n\\n    function tokenCreator(uint256 _id) internal pure returns (address) {\\n        return address(_id >> (INDEX_BITS + SUPPLY_BITS));\\n    }\\n}\"\r\n    },\r\n    \"/Users/ronak/Developer/projects/tsgit/swappable-asset-contracts/contracts/ERC1155Tradable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"multi-token-standard/contracts/tokens/ERC1155/ERC1155MintBurn.sol\\\";\\n\\ncontract OwnableDelegateProxy {}\\n\\ncontract ProxyRegistry {\\n    mapping(address => OwnableDelegateProxy) public proxies;\\n}\\n\\n/**\\n * @title ERC1155Tradable\\n * ERC1155Tradable - ERC1155 contract that whitelists an operator address, has create and mint functionality, and supports useful standards from OpenZeppelin,\\n  like exists(), name(), symbol(), and totalSupply()\\n */\\ncontract ERC1155Tradable is ERC1155MintBurn, Ownable {\\n    // Proxy registry address\\n    address public proxyRegistryAddress;\\n    // Contract name\\n    string public name;\\n    // Contract symbol\\n    string public symbol;\\n\\n    mapping(uint256 => uint256) private _supply;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _proxyRegistryAddress\\n    ) public {\\n        name = _name;\\n        symbol = _symbol;\\n        proxyRegistryAddress = _proxyRegistryAddress;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner or their proxy\\n     */\\n    modifier onlyOwner() {\\n        require(\\n            _isOwner(_msgSender()),\\n            \\\"ERC1155Tradable#onlyOwner: CALLER_IS_NOT_OWNER\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the total quantity for a token ID\\n     * @param _id uint256 ID of the token to query\\n     * @return amount of token in existence\\n     */\\n    function totalSupply(uint256 _id) public view returns (uint256) {\\n        return _supply[_id];\\n    }\\n\\n    /**\\n     * Override isApprovedForAll to whitelist user's Swappable proxy accounts to enable gas-free listings.\\n     */\\n    function isApprovedForAll(address _owner, address _operator)\\n        public\\n        view\\n        returns (bool isOperator)\\n    {\\n        // Whitelist Swappable proxy contracts for easy trading.\\n        if (_isProxyForUser(_owner, _operator)) {\\n            return true;\\n        }\\n\\n        return super.isApprovedForAll(_owner, _operator);\\n    }\\n\\n    /**\\n     * @dev Mints some amount of tokens to an address\\n     * @param _to          Address of the future owner of the token\\n     * @param _id          Token ID to mint\\n     * @param _quantity    Amount of tokens to mint\\n     * @param _data        Data to pass if receiver is contract\\n     */\\n    function mint(\\n        address _to,\\n        uint256 _id,\\n        uint256 _quantity,\\n        bytes memory _data\\n    ) public onlyOwner {\\n        _mint(_to, _id, _quantity, _data);\\n    }\\n\\n    /**\\n     * @dev Mint tokens for each id in _ids\\n     * @param _to          The address to mint tokens to\\n     * @param _ids         Array of ids to mint\\n     * @param _quantities  Array of amounts of tokens to mint per id\\n     * @param _data        Data to pass if receiver is contract\\n     */\\n    function batchMint(\\n        address _to,\\n        uint256[] memory _ids,\\n        uint256[] memory _quantities,\\n        bytes memory _data\\n    ) public onlyOwner {\\n        _batchMint(_to, _ids, _quantities, _data);\\n    }\\n\\n    /**\\n     * @dev Returns whether the specified token is minted\\n     * @param _id uint256 ID of the token to query the existence of\\n     * @return bool whether the token exists\\n     */\\n    function exists(uint256 _id) public view returns (bool) {\\n        return _supply[_id] > 0;\\n    }\\n\\n    function _isOwner(address _address) internal view returns (bool) {\\n        return owner() == _address || _isProxyForUser(owner(), _address);\\n    }\\n\\n    // Overrides ERC1155MintBurn to allow changing birth events to creator transfers,\\n    // and to set _supply\\n    function _mint(\\n        address _to,\\n        uint256 _id,\\n        uint256 _amount,\\n        bytes memory _data\\n    ) internal {\\n        // Add _amount\\n        balances[_to][_id] = balances[_to][_id].add(_amount);\\n        _supply[_id] = _supply[_id].add(_amount);\\n\\n        // Origin of token will be the _from parameter\\n        address origin = _origin(_id);\\n\\n        // Emit event\\n        emit TransferSingle(msg.sender, origin, _to, _id, _amount);\\n\\n        // Calling onReceive method if recipient is contract\\n        _callonERC1155Received(origin, _to, _id, _amount, gasleft(), _data);\\n    }\\n\\n    // Overrides ERC1155MintBurn to change the batch birth events to creator transfers, and to set _supply\\n    function _batchMint(\\n        address _to,\\n        uint256[] memory _ids,\\n        uint256[] memory _amounts,\\n        bytes memory _data\\n    ) internal {\\n        require(\\n            _ids.length == _amounts.length,\\n            \\\"ERC1155Tradable#batchMint: INVALID_ARRAYS_LENGTH\\\"\\n        );\\n\\n        // Number of mints to execute\\n        uint256 nMint = _ids.length;\\n\\n        // Origin of tokens will be the _from parameter\\n        address origin = _origin(_ids[0]);\\n\\n        // Executing all minting\\n        for (uint256 i = 0; i < nMint; i++) {\\n            // Update storage balance\\n            uint256 id = _ids[i];\\n            require(\\n                _origin(id) == origin,\\n                \\\"ERC1155Tradable#batchMint: MULTIPLE_ORIGINS_NOT_ALLOWED\\\"\\n            );\\n            balances[_to][id] = balances[_to][id].add(_amounts[i]);\\n            _supply[id] = _supply[id].add(_amounts[i]);\\n        }\\n\\n        // Emit batch mint event\\n        emit TransferBatch(msg.sender, origin, _to, _ids, _amounts);\\n\\n        // Calling onReceive method if recipient is contract\\n        _callonERC1155BatchReceived(\\n            origin,\\n            _to,\\n            _ids,\\n            _amounts,\\n            gasleft(),\\n            _data\\n        );\\n    }\\n\\n    // Override this to change birth events' _from address\\n    function _origin(\\n        uint256 /* _id */\\n    ) internal view returns (address) {\\n        return address(0);\\n    }\\n\\n    // PROXY HELPER METHODS\\n\\n    function _isProxyForUser(address _user, address _address)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _proxy(_user) == _address;\\n    }\\n\\n    function _proxy(address _address) internal view returns (address) {\\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\\n        return address(proxyRegistry.proxies(_address));\\n    }\\n}\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract ReentrancyGuard {\\n    bool private _notEntered;\\n\\n    constructor () internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/ronak/Developer/projects/tsgit/swappable-asset-contracts/contracts/AssetContract.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport \\\"./ERC1155Tradable.sol\\\";\\n\\n/**\\n * @title AssetContract\\n * AssetContract - A contract for easily creating non-fungible assets on Swappable.\\n */\\ncontract AssetContract is ERC1155Tradable {\\n    event URI(string _value, uint256 indexed _id);\\n\\n    uint256 constant TOKEN_SUPPLY_CAP = 1;\\n\\n    string public templateURI;\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) private _tokenURI;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _proxyRegistryAddress,\\n        string memory _templateURI\\n    ) public ERC1155Tradable(_name, _symbol, _proxyRegistryAddress) {\\n        if (bytes(_templateURI).length > 0) {\\n            setTemplateURI(_templateURI);\\n        }\\n    }\\n\\n    function swappableVersion() public pure returns (string memory) {\\n        return \\\"2.0.2\\\";\\n    }\\n\\n    /**\\n     * Compat for factory interfaces on Swappable\\n     * Indicates that this contract can return balances for\\n     * tokens that haven't been minted yet\\n     */\\n    function supportsFactoryInterface() public pure returns (bool) {\\n        return true;\\n    }\\n\\n    function setTemplateURI(string memory uri) public onlyOwner {\\n        templateURI = uri;\\n    }\\n\\n    function setURI(uint256 _id, string memory _uri) public onlyOwner {\\n        _setURI(_id, _uri);\\n    }\\n\\n    function uri(uint256 _id) public view returns (string memory) {\\n        string memory tokenUri = _tokenURI[_id];\\n        if (bytes(tokenUri).length != 0) {\\n            return tokenUri;\\n        }\\n        return templateURI;\\n    }\\n\\n    function balanceOf(address _owner, uint256 _id)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 balance = super.balanceOf(_owner, _id);\\n        return\\n            _isCreatorOrProxy(_id, _owner)\\n                ? balance.add(_remainingSupply(_id))\\n                : balance;\\n    }\\n\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _amount,\\n        bytes memory _data\\n    ) public {\\n        uint256 mintedBalance = super.balanceOf(_from, _id);\\n        if (mintedBalance < _amount) {\\n            // Only mint what _from doesn't already have\\n            mint(_to, _id, _amount.sub(mintedBalance), _data);\\n            if (mintedBalance > 0) {\\n                super.safeTransferFrom(_from, _to, _id, mintedBalance, _data);\\n            }\\n        } else {\\n            super.safeTransferFrom(_from, _to, _id, _amount, _data);\\n        }\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] memory _ids,\\n        uint256[] memory _amounts,\\n        bytes memory _data\\n    ) public {\\n        require(\\n            _ids.length == _amounts.length,\\n            \\\"AssetContractShared#safeBatchTransferFrom: INVALID_ARRAYS_LENGTH\\\"\\n        );\\n        for (uint256 i = 0; i < _ids.length; i++) {\\n            safeTransferFrom(_from, _to, _ids[i], _amounts[i], _data);\\n        }\\n    }\\n\\n    function mint(\\n        address _to,\\n        uint256 _id,\\n        uint256 _quantity,\\n        bytes memory _data\\n    ) public onlyOwner {\\n        require(\\n            _quantity <= _remainingSupply(_id),\\n            \\\"AssetContract#mint: QUANTITY_EXCEEDS_TOKEN_SUPPLY_CAP\\\"\\n        );\\n        _mint(_to, _id, _quantity, _data);\\n    }\\n\\n    function batchMint(\\n        address _to,\\n        uint256[] memory _ids,\\n        uint256[] memory _quantities,\\n        bytes memory _data\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i < _ids.length; i++) {\\n            require(\\n                _quantities[i] <= _remainingSupply(_ids[i]),\\n                \\\"AssetContract#batchMint: QUANTITY_EXCEEDS_TOKEN_SUPPLY_CAP\\\"\\n            );\\n        }\\n        _batchMint(_to, _ids, _quantities, _data);\\n    }\\n\\n    function _mint(\\n        address _to,\\n        uint256 _id,\\n        uint256 _quantity,\\n        bytes memory _data\\n    ) internal {\\n        super._mint(_to, _id, _quantity, _data);\\n        if (_data.length > 1) {\\n            _setURI(_id, string(_data));\\n        }\\n    }\\n\\n    function _isCreatorOrProxy(uint256, address _address)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _isOwner(_address);\\n    }\\n\\n    function _remainingSupply(uint256 _id) internal view returns (uint256) {\\n        return TOKEN_SUPPLY_CAP.sub(totalSupply(_id));\\n    }\\n\\n    // Override ERC1155Tradable for birth events\\n    function _origin(\\n        uint256 /* _id */\\n    ) internal view returns (address) {\\n        return owner();\\n    }\\n\\n    function _batchMint(\\n        address _to,\\n        uint256[] memory _ids,\\n        uint256[] memory _quantities,\\n        bytes memory _data\\n    ) internal {\\n        super._batchMint(_to, _ids, _quantities, _data);\\n        if (_data.length > 1) {\\n            for (uint256 i = 0; i < _ids.length; i++) {\\n                _setURI(_ids[i], string(_data));\\n            }\\n        }\\n    }\\n\\n    function _setURI(uint256 _id, string memory _uri) internal {\\n        _tokenURI[_id] = _uri;\\n        emit URI(_uri, _id);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_proxyRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_templateURI\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"CreatorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addSharedProxyAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_quantities\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"batchMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isOperator\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeSharedProxyAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"setCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setProxyRegistryAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setTemplateURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sharedProxyAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supportsFactoryInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swappableVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"templateURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AssetContractShared", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000405ef38d44acff35b293410fef9d8de1369bece400000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000015537761707061626c6520436f6c6c656374696f6e73000000000000000000000000000000000000000000000000000000000000000000000000000000000000095357415053544f52450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002968747470733a2f2f6170692e737761707061626c652e696f2f6170692f76312f6d657461646174612f0000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}