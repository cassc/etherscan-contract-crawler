{"SourceCode": "// SPDX-License-Identifier: LGPL-3.0-only\r\n\r\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/cryptography/ECDSA.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        } else if (error == RecoverError.InvalidSignatureV) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature` or error string. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address, RecoverError)\r\n    {\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n            return tryRecover(hash, r, vs);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n     *\r\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address, RecoverError) {\r\n        bytes32 s = vs &\r\n            bytes32(\r\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n            );\r\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (\r\n            uint256(s) >\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n        ) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return (address(0), RecoverError.InvalidSignatureV);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes memory s)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n\",\r\n                    Strings.toString(s.length),\r\n                    s\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\r\n            );\r\n    }\r\n}\r\n\r\n// File contracts/libraries/EIP712CrossChain.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\r\n *\r\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\r\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\r\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\r\n *\r\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\r\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\r\n * ({_hashTypedDataV4}).\r\n *\r\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\r\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\r\n *\r\n * _Available since v3.4._\r\n */\r\nabstract contract EIP712CrossChain {\r\n    /* solhint-disable var-name-mixedcase */\r\n    // Cache the domain separator as an immutable value.\r\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\r\n    address private immutable _CACHED_THIS;\r\n\r\n    bytes32 private immutable _HASHED_NAME;\r\n    bytes32 private immutable _HASHED_VERSION;\r\n    bytes32 private immutable _TYPE_HASH;\r\n\r\n    /* solhint-enable var-name-mixedcase */\r\n\r\n    /**\r\n     * @dev Initializes the domain separator and parameter caches.\r\n     *\r\n     * The meaning of `name` and `version` is specified in\r\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\r\n     *\r\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\r\n     * - `version`: the current major version of the signing domain.\r\n     *\r\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\r\n     * contract upgrade].\r\n     */\r\n    constructor(string memory name, string memory version) {\r\n        bytes32 hashedName = keccak256(bytes(name));\r\n        bytes32 hashedVersion = keccak256(bytes(version));\r\n        bytes32 typeHash = keccak256(\r\n            \"EIP712Domain(string name,string version,address verifyingContract)\"\r\n        );\r\n        _HASHED_NAME = hashedName;\r\n        _HASHED_VERSION = hashedVersion;\r\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\r\n            typeHash,\r\n            hashedName,\r\n            hashedVersion\r\n        );\r\n        _CACHED_THIS = address(this);\r\n        _TYPE_HASH = typeHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the domain separator.\r\n     */\r\n    function _domainSeparatorV4() internal view returns (bytes32) {\r\n        if (address(this) == _CACHED_THIS) {\r\n            return _CACHED_DOMAIN_SEPARATOR;\r\n        } else {\r\n            return\r\n                _buildDomainSeparator(\r\n                    _TYPE_HASH,\r\n                    _HASHED_NAME,\r\n                    _HASHED_VERSION\r\n                );\r\n        }\r\n    }\r\n\r\n    function _buildDomainSeparator(\r\n        bytes32 typeHash,\r\n        bytes32 nameHash,\r\n        bytes32 versionHash\r\n    ) private view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(typeHash, nameHash, versionHash, address(this))\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\r\n     * function returns the hash of the fully encoded EIP712 message for this domain.\r\n     *\r\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\r\n     *\r\n     * ```solidity\r\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\r\n     *     keccak256(\"Mail(address to,string contents)\"),\r\n     *     mailTo,\r\n     *     keccak256(bytes(mailContents))\r\n     * )));\r\n     * address signer = ECDSA.recover(digest, signature);\r\n     * ```\r\n     */\r\n    function _hashTypedDataV4(bytes32 structHash)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bytes32)\r\n    {\r\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/crosschain/Enum.sol\r\n\r\n/// @title Enum - Collection of enums\r\n/// @author Richard Meissner - <richard@gnosis.pm>\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/crosschain/UserOperation.sol\r\n\r\nstruct UserOperation {\r\n    uint256 toChainId;\r\n    address to;\r\n    uint256 value;\r\n    bytes data;\r\n    address gasToken;\r\n    uint256 gasTokenAmount;\r\n    uint256 saltNonce;\r\n    Enum.Operation operation;\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n}\r\n\r\n// File contracts/interfaces/crosschain/IModule.sol\r\n\r\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\r\n\r\ninterface IModule {\r\n    event OperationExecuted(\r\n        address indexed _avatar,\r\n        uint256 _avatarNonce,\r\n        address _executor,\r\n        bool _success\r\n    );\r\n\r\n    /// @dev Passes a transaction to be executed by the avatar.\r\n    /// @param srcAddress user's main account\r\n    /// @param uo UserOperation\r\n    /// @param uo._saltNonce id of user's avatar\r\n    function exec(address srcAddress, UserOperation calldata uo)\r\n        external\r\n        returns (bool success);\r\n\r\n    function nonces(address avatar) external view returns (uint256);\r\n\r\n    function getSafe(address _srcAddress, uint256 _saltNonce)\r\n        external\r\n        returns (address);\r\n\r\n    function computeSafeAddress(address _srcAddress, uint256 _saltNonce)\r\n        external\r\n        view\r\n        returns (address _safeAddr, bytes memory _initializer);\r\n}\r\n\r\n// File contracts/interfaces/crosschain/IAvatar.sol\r\n\r\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\r\n\r\ninterface IAvatar {\r\n    event EnabledModule(address module);\r\n    event DisabledModule(address module);\r\n    event ExecutionFromModuleSuccess(address indexed module);\r\n    event ExecutionFromModuleFailure(address indexed module);\r\n\r\n    /// @dev Enables a module on the avatar.\r\n    /// @notice Can only be called by the avatar.\r\n    /// @notice Modules should be stored as a linked list.\r\n    /// @notice Must emit EnabledModule(address module) if successful.\r\n    /// @param module Module to be enabled.\r\n    function enableModule(address module) external;\r\n\r\n    /// @dev Disables a module on the avatar.\r\n    /// @notice Can only be called by the avatar.\r\n    /// @notice Must emit DisabledModule(address module) if successful.\r\n    /// @param prevModule Address that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(address prevModule, address module) external;\r\n\r\n    /// @dev Allows a Module to execute a transaction.\r\n    /// @notice Can only be called by an enabled module.\r\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\r\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\r\n    function execTransactionFromModule(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success);\r\n\r\n    /// @dev Allows a Module to execute a transaction and return data\r\n    /// @notice Can only be called by an enabled module.\r\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\r\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\r\n    function execTransactionFromModuleReturnData(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation\r\n    ) external returns (bool success, bytes memory returnData);\r\n\r\n    /// @dev Returns if an module is enabled\r\n    /// @return True if the module is enabled\r\n    function isModuleEnabled(address module) external view returns (bool);\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @param start Start of the page.\r\n    /// @param pageSize Maximum number of modules that should be returned.\r\n    /// @return array Array of modules.\r\n    /// @return next Start of the next page.\r\n    function getModulesPaginated(address start, uint256 pageSize)\r\n        external\r\n        view\r\n        returns (address[] memory array, address next);\r\n}\r\n\r\n// File contracts/interfaces/crosschain/IGnosisSafe.sol\r\n\r\ninterface IGnosisSafe {\r\n    function isOwner(address owner) external view returns (bool);\r\n\r\n    function getThreshold() external view returns (uint256);\r\n\r\n    function setup(\r\n        address[] calldata _owners,\r\n        uint256 _threshold,\r\n        address to,\r\n        bytes calldata data,\r\n        address fallbackHandler,\r\n        address paymentToken,\r\n        uint256 payment,\r\n        address payable paymentReceiver\r\n    ) external;\r\n\r\n    function execTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        Enum.Operation operation,\r\n        uint256 safeTxGas,\r\n        uint256 baseGas,\r\n        uint256 gasPrice,\r\n        address gasToken,\r\n        address payable refundReceiver,\r\n        bytes memory signatures\r\n    ) external payable returns (bool);\r\n\r\n    function enableModule(address module) external;\r\n}\r\n\r\n// File contracts/interfaces/crosschain/IAvaultGuard.sol\r\n\r\ninterface IAvaultGuard {\r\n    event OperationBlocked(string _reason);\r\n\r\n    function checkTransaction(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        Enum.Operation operation,\r\n        address gasToken,\r\n        uint256 gasTokenAmount,\r\n        address executor,\r\n        address avatar\r\n    ) external view returns (bool);\r\n}\r\n\r\n// File contracts/interfaces/crosschain/IGnosisSafeProxyFactory.sol\r\n\r\ninterface IGnosisSafeProxyFactory {\r\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\r\n    /// @param _singleton Address of singleton contract.\r\n    /// @param initializer Payload for message call sent to new proxy contract.\r\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\r\n    function createProxyWithNonce(\r\n        address _singleton,\r\n        bytes memory initializer,\r\n        uint256 saltNonce\r\n    ) external returns (address proxy);\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Counters.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File contracts/crosschain/SigValidationModule.sol\r\n\r\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\r\n\r\ncontract SigValidationModule is Ownable, EIP712CrossChain, IModule {\r\n    using Counters for Counters.Counter;\r\n\r\n    mapping(address => Counters.Counter) private _nonces;\r\n    mapping(address => address) public userSafe; // cache use's safe address\r\n    IAvaultGuard public avaultGuard;\r\n    address payable public feeAccount =\r\n        payable(0x51dCfc9E04859A0B7647608fbd9Ab34fC8553189); //treasury account\r\n\r\n    // SAFEPROXY_CREATIONCODE: https://arbiscan.io/address/0xa6b71e26c5e0845f74c812102ca7114b6a896ab2#readContract#F1\r\n    // bytes public constant SAFEPROXY_CREATIONCODE = 0x60806040523480156100105760....70726f7669646564;\r\n    // keccak256(abi.encodePacked(SAFEPROXY_CREATIONCODE, abi.encode(SAFE_SINGLETON)))\r\n    bytes32 public immutable BYTECODE_HASH;\r\n    address public immutable SAFE_CALLBACK;\r\n    address public immutable SAFE_FACTORY;\r\n    address public immutable SAFE_SINGLETON;\r\n    address public immutable MODULE_ENABLER;\r\n    bytes public constant ENABLE_MODULE_ENCODED = hex\"24292962\"; //IGnosisSafe.enableModule.selector\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    // bytes32 private immutable SAFE_MODULE_TX_TYPEHASH =\r\n    //     keccak256(\"SafeModuleTx(uint256 toChainId,address to,uint256 value,bytes data,address gasToken,uint256 gasTokenAmount,uint8 operation,uint256 nonce,uint256 saltNonce)\");\r\n    bytes32 private constant SAFE_MODULE_TX_TYPEHASH =\r\n        0xb4a321956a4d1700990e384bf60825e82b1c6971d4296049b1ea99bd635dd752;\r\n\r\n    event AvaultGuardSet(address _avaultGuard);\r\n    event FeeAccountSet(address payable _feeAccount);\r\n\r\n    constructor(\r\n        bytes32 _BYTECODE_HASH,\r\n        address _SAFE_CALLBACK,\r\n        address _SAFE_FACTORY,\r\n        address _SAFE_SINGLETON,\r\n        address _MODULE_ENABLER\r\n    ) EIP712CrossChain(\"Avault\", \"1\") {\r\n        BYTECODE_HASH = _BYTECODE_HASH;\r\n        SAFE_CALLBACK = _SAFE_CALLBACK;\r\n        SAFE_FACTORY = _SAFE_FACTORY;\r\n        SAFE_SINGLETON = _SAFE_SINGLETON;\r\n        MODULE_ENABLER = _MODULE_ENABLER;\r\n    }\r\n\r\n    function setFeeAccount(address payable _feeAccount) external onlyOwner {\r\n        feeAccount = _feeAccount;\r\n        emit FeeAccountSet(_feeAccount);\r\n    }\r\n\r\n    function setAvaultGuard(IAvaultGuard _guard) external onlyOwner {\r\n        avaultGuard = _guard;\r\n        emit AvaultGuardSet(address(_guard));\r\n    }\r\n\r\n    /// @dev Passes a transaction to be executed by the avatar.\r\n    /// @param srcAddress user's main account\r\n    /// @param uo UserOperation\r\n    /// @param uo.saltNonce id of user's avatar\r\n    function exec(address srcAddress, UserOperation calldata uo)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        address avatar = getSafe(srcAddress, uo.saltNonce);\r\n\r\n        require(IGnosisSafe(avatar).isOwner(srcAddress), \"not owner\");\r\n        require(IGnosisSafe(avatar).getThreshold() == 1, \"not unique owner\");\r\n        require(getChainId() == uo.toChainId, \"incorrect chain\");\r\n\r\n        //check signature\r\n        uint256 _avatarNonce = _useNonce(avatar);\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(\r\n                SAFE_MODULE_TX_TYPEHASH,\r\n                uo.toChainId,\r\n                uo.to,\r\n                uo.value,\r\n                keccak256(uo.data),\r\n                uo.gasToken,\r\n                uo.gasTokenAmount,\r\n                uo.operation,\r\n                _avatarNonce,\r\n                uo.saltNonce\r\n            )\r\n        );\r\n        bytes32 hash = _hashTypedDataV4(structHash);\r\n        address signer = ECDSA.recover(hash, uo.v, uo.r, uo.s);\r\n        require(signer == srcAddress, \"invalid sig\");\r\n\r\n        /** filter the to address\r\n         *  1. prevent fishing risk, the to shouldn't transfer asset to others\r\n         *  2. gasToken should be valid\r\n         *  3. if gasTokenAmount == 0, the to and data must be constrained.\r\n         **/\r\n        if (address(avaultGuard) != address(0)) {\r\n            require(\r\n                avaultGuard.checkTransaction(\r\n                    uo.to,\r\n                    uo.value,\r\n                    uo.data,\r\n                    uo.operation,\r\n                    uo.gasToken,\r\n                    uo.gasTokenAmount,\r\n                    msg.sender,\r\n                    avatar\r\n                ),\r\n                \"Guard\"\r\n            );\r\n        }\r\n\r\n        //get fee\r\n        if (uo.gasTokenAmount > 0) {\r\n            if (uo.gasToken == address(0)) {\r\n                // native coin as gas fee (e.g. ETH, BNB)\r\n                require(\r\n                    avatar.balance >= uo.gasTokenAmount,\r\n                    \"insufficient balance in avatar\"\r\n                );\r\n                success = IAvatar(avatar).execTransactionFromModule(\r\n                    feeAccount,\r\n                    uo.gasTokenAmount,\r\n                    \"\",\r\n                    Enum.Operation.Call\r\n                );\r\n                require(success, \"native payment failed\"); //unable to send value, recipient may have reverted\r\n            } else {\r\n                // ERC20 or non-ERC20 token as gas fee (e.g. ETH, BNB)\r\n                (bool _success, bytes memory _returnData) = IAvatar(avatar)\r\n                    .execTransactionFromModuleReturnData(\r\n                        uo.gasToken,\r\n                        0,\r\n                        abi.encodeWithSelector(\r\n                            IERC20.transfer.selector,\r\n                            feeAccount,\r\n                            uo.gasTokenAmount\r\n                        ),\r\n                        Enum.Operation.Call\r\n                    );\r\n                if (_success) {\r\n                    if (_returnData.length == 0) {\r\n                        // only check isContract if the call was successful and the return data is empty\r\n                        // otherwise we already know that it was a contract\r\n                        require(\r\n                            uo.gasToken.code.length > 0,\r\n                            \"token is non-contract\"\r\n                        );\r\n                    } else {\r\n                        // Return data is optional\r\n                        require(\r\n                            abi.decode(_returnData, (bool)),\r\n                            \"token return false\"\r\n                        );\r\n                    }\r\n                } else {\r\n                    _revert(_returnData, \"token call failed\");\r\n                }\r\n            }\r\n        }\r\n\r\n        success = IAvatar(avatar).execTransactionFromModule(\r\n            uo.to,\r\n            uo.value,\r\n            uo.data,\r\n            uo.operation\r\n        );\r\n\r\n        emit OperationExecuted(avatar, _avatarNonce, msg.sender, success);\r\n        return success;\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage)\r\n        private\r\n        pure\r\n    {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-nonces}.\r\n     */\r\n    function nonces(address avatar) public view returns (uint256) {\r\n        return _nonces[avatar].current();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\r\n        return _domainSeparatorV4();\r\n    }\r\n\r\n    /**\r\n     * @dev \"Consume a nonce\": return the current value and increment.\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    function _useNonce(address _avatar) internal returns (uint256 current) {\r\n        Counters.Counter storage nonce = _nonces[_avatar];\r\n        current = nonce.current();\r\n        nonce.increment();\r\n    }\r\n\r\n    /// @dev Returns the chain id used by this contract.\r\n    function getChainId() public view returns (uint256) {\r\n        uint256 id;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    function getSafe(address _srcAddress, uint256 _saltNonce)\r\n        public\r\n        returns (address _safe)\r\n    {\r\n        _safe = userSafe[_srcAddress];\r\n        if (_safe == address(0)) {\r\n            //calculate safe address\r\n            bytes memory _initializer;\r\n            (_safe, _initializer) = computeSafeAddress(_srcAddress, _saltNonce);\r\n\r\n            uint256 _size;\r\n            assembly {\r\n                _size := extcodesize(_safe)\r\n            }\r\n            if (_size == 0) {\r\n                //the _safe hasn't created, create it\r\n                address _s = IGnosisSafeProxyFactory(SAFE_FACTORY)\r\n                    .createProxyWithNonce(\r\n                        SAFE_SINGLETON,\r\n                        _initializer,\r\n                        _saltNonce\r\n                    );\r\n                require(_safe == _s, \"create safe error\");\r\n            }\r\n            userSafe[_srcAddress] = _safe;\r\n        }\r\n    }\r\n\r\n    function computeSafeAddress(address _srcAddress, uint256 _saltNonce)\r\n        public\r\n        view\r\n        returns (address _safeAddr, bytes memory _initializer)\r\n    {\r\n        address[] memory _owners = new address[](1);\r\n        _owners[0] = _srcAddress;\r\n        _initializer = abi.encodeWithSelector(\r\n            IGnosisSafe.setup.selector,\r\n            _owners,\r\n            uint256(1),\r\n            MODULE_ENABLER,\r\n            ENABLE_MODULE_ENCODED,\r\n            SAFE_CALLBACK,\r\n            address(0),\r\n            0,\r\n            address(0)\r\n        );\r\n        bytes32 _salt = keccak256(\r\n            abi.encodePacked(keccak256(_initializer), _saltNonce)\r\n        );\r\n        _safeAddr = computeAddress(_salt, BYTECODE_HASH, SAFE_FACTORY);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\r\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\r\n     */\r\n    function computeAddress(\r\n        bytes32 salt,\r\n        bytes32 bytecodeHash,\r\n        address deployer\r\n    ) private pure returns (address addr) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40) // Get free memory pointer\r\n\r\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\r\n            // |-------------------|---------------------------------------------------------------------------|\r\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\r\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\r\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\r\n            // | 0xFF              |            FF                                                             |\r\n            // |-------------------|---------------------------------------------------------------------------|\r\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\r\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\r\n\r\n            mstore(add(ptr, 0x40), bytecodeHash)\r\n            mstore(add(ptr, 0x20), salt)\r\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\r\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\r\n            mstore8(start, 0xff)\r\n            addr := keccak256(start, 85)\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_BYTECODE_HASH\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_SAFE_CALLBACK\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_SAFE_FACTORY\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_SAFE_SINGLETON\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_MODULE_ENABLER\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_avaultGuard\",\"type\":\"address\"}],\"name\":\"AvaultGuardSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"_feeAccount\",\"type\":\"address\"}],\"name\":\"FeeAccountSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_avatar\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_avatarNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"name\":\"OperationExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BYTECODE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ENABLE_MODULE_ENCODED\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MODULE_ENABLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SAFE_CALLBACK\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SAFE_FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SAFE_SINGLETON\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avaultGuard\",\"outputs\":[{\"internalType\":\"contract IAvaultGuard\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_srcAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_saltNonce\",\"type\":\"uint256\"}],\"name\":\"computeSafeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_safeAddr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_initializer\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"srcAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saltNonce\",\"type\":\"uint256\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct UserOperation\",\"name\":\"uo\",\"type\":\"tuple\"}],\"name\":\"exec\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_srcAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_saltNonce\",\"type\":\"uint256\"}],\"name\":\"getSafe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_safe\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"avatar\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAvaultGuard\",\"name\":\"_guard\",\"type\":\"address\"}],\"name\":\"setAvaultGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeAccount\",\"type\":\"address\"}],\"name\":\"setFeeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userSafe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SigValidationModule", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "caf2dc2f91b804b2fcf1ed3a965a1ff4404b840b80c124277b00a43b4634b2ce000000000000000000000000f48f2b2d2a534e402487b3ee7c18c33aec0fe5e4000000000000000000000000a6b71e26c5e0845f74c812102ca7114b6a896ab20000000000000000000000003e5c63644e683549055b9be8653de26e0b4cd36e000000000000000000000000c5b8d0ec15984653a7554878ee9b4212ea059fd2", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2201e10a1abff525e162d283f3492fdd234b56ee4537aa22062e3fa412468a1a"}