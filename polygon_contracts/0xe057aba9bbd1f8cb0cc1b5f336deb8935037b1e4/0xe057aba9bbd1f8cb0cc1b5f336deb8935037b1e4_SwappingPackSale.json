{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/SwappingPackSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2023 Soccerverse Ltd\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\\\";\\n\\nimport \\\"./PackSale.sol\\\";\\nimport \\\"./SwapProvider.sol\\\";\\n\\n/**\\n * @dev An extension to the basic PackSale contract, which supports minting\\n * with auto-convert (swapping any input token to the payment token on-the-fly\\n * using a UniswapV2 router such as Quickswap).\\n */\\ncontract SwappingPackSale is PackSale\\n{\\n\\n  /** @dev WETH contract used for wrapping/unwrapping ETH with auto-convert.  */\\n  IWETH public immutable weth;\\n\\n  /**\\n   * @dev Magic constant for the \\\"token\\\" address passed when native ETH\\n   * should be used instead (and wrapped/unwrapped on the fly).\\n   */\\n  address public constant ETH_TOKEN\\n      = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  /** @dev The provider used for swapping into USDC.  */\\n  SwapProvider public immutable swapper;\\n\\n  /* ************************************************************************ */\\n\\n  constructor (IERC20 t, ClubMinter m, address fwd,\\n               IWETH w, SwapProvider s)\\n    PackSale (t, m, fwd)\\n  {\\n    weth = w;\\n    swapper = s;\\n    require (t == s.wchi (), \\\"SwapProvider does not output the right token\\\");\\n  }\\n\\n  receive () external payable\\n  {\\n    /* We accept payment of native ETH, so we can unwrap WETH on the fly.  */\\n    require (msg.sender == address (weth), \\\"payment is not ETH unwrapping\\\");\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Returns the current (exact) input amount required of a certain\\n   * token to buy a given number of packs.  This number should be increased\\n   * by some slippage tolerance by the frontend before calling into the\\n   * actual mint function.\\n   *\\n   * The swapData argument is the swap-specific extra data (e.g. path)\\n   * used by the SwapProvider.\\n   */\\n  function quoteMint (string calldata country, uint num,\\n                      IERC20 inputToken, bytes calldata swapData)\\n      public view returns (uint)\\n  {\\n    CountryConfig storage data = countries[country];\\n    /* Require that the country is configured properly.  */\\n    require (data.sharesPerClub > 0 && data.clubIds.length > 0,\\n             \\\"no clubs to give out for this country\\\");\\n\\n    uint totalRequired = num * data.packCost;\\n\\n    if (inputToken == token)\\n      return totalRequired;\\n\\n    return swapper.quoteExactOutput (inputToken, totalRequired, swapData);\\n  }\\n\\n  /**\\n   * @dev Mints share packs, paying for them in the given token (or native\\n   * ETH if inputToken is set as ETH_TOKEN).  The inputAmount of that token\\n   * is used as swap input, which must be enough to yield the required cost\\n   * in the payment token, and should be chosen based on quoteMint plus\\n   * some slippage tolerance.  The excess amount is returned.\\n   *\\n   * The swapData argument is the swap-specific extra data such as path\\n   * information for the SwapProvider used.\\n   */\\n  function mintWithSwap (string calldata country, uint num,\\n                         string calldata receiver,\\n                         IERC20 inputToken, uint inputAmount,\\n                         bytes calldata swapData)\\n      public payable whenNotPaused\\n  {\\n    uint totalRequired = num * countries[country].packCost;\\n\\n    if (inputToken == token)\\n      {\\n        /* The input token is already the one used for payment.  In this case,\\n           verify that the inputAmount is the expected one (just in case)\\n           and call the non-swapping mint.  */\\n        require (msg.value == 0, \\\"payment only allowed for native ETH input\\\");\\n        require (inputAmount == totalRequired,\\n                 \\\"wrong inputAmount supplied for non-swapping mint\\\");\\n        mint (country, num, receiver);\\n        return;\\n      }\\n\\n    address buyer = _msgSender ();\\n\\n    bool nativeETH = (address (inputToken) == ETH_TOKEN);\\n    if (nativeETH)\\n      {\\n        require (msg.value == inputAmount,\\n                 \\\"payment does not match input amount\\\");\\n        inputToken = IERC20 (address (weth));\\n        weth.deposit{value: inputAmount} ();\\n        require (weth.transfer (address (swapper), inputAmount),\\n                 \\\"failed to transfer WETH to swapper\\\");\\n      }\\n    else\\n      {\\n        require (msg.value == 0, \\\"payment only allowed for native ETH input\\\");\\n        require (inputToken.transferFrom (buyer, address (swapper),\\n                                          inputAmount),\\n                 \\\"transferring the input tokens failed\\\");\\n      }\\n\\n    swapper.swapExactOutput (inputToken, totalRequired, swapData);\\n    swapper.transferToken (token, totalRequired, owner ());    \\n    mintInternal (country, num, receiver, buyer);\\n\\n    /* What remains of the input token is returned to the original buyer.  */\\n    uint excess = inputToken.balanceOf (address (swapper));\\n    if (excess > 0)\\n      {\\n        if (nativeETH)\\n          {\\n            swapper.transferToken (inputToken, excess, address (this));\\n            weth.withdraw (excess);\\n            (bool success, bytes memory res)\\n                = buyer.call{value: excess} (\\\"\\\");\\n            require (success,\\n                     string (abi.encodePacked (\\n                        \\\"failed to pay unwrapped ETH back to buyer: \\\",\\n                        res)));\\n          }\\n        else\\n          swapper.transferToken (inputToken, excess, buyer);\\n      }\\n  }\\n\\n  /* ************************************************************************ */\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/SwapProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2023 Soccerverse Ltd\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev This is the interface of a provider for swapping between tokens,\\n * as used by Democrit's auto-convert feature.  It can be implemented based\\n * on an on-chain DEX such as Uniswap v2 or v3.\\n *\\n * All methods accept an implementation-specific \\\"data\\\" argument, which\\n * can contain other data required, such as swap paths.\\n *\\n * Token swaps are done from / to the contract's balance.  Democrit will\\n * directly move tokens from the user's wallet to this contract, and the\\n * contract has a method to withdraw tokens from its own balance onwards\\n * after the swap, which Democrit will use.\\n */\\nabstract contract SwapProvider\\n{\\n\\n  /** @dev The WCHI token used.  */\\n  IERC20 public immutable wchi;\\n\\n  constructor (IERC20 wc)\\n  {\\n    wchi = wc;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens owned by this contract.  This is a method\\n   * that Democrit will use to distribute the swap output.  It can be\\n   * called by anyone, as this contract is not expected to hold tokens\\n   * \\\"long term\\\".  Any balances it receives will be distributed by\\n   * Democrit right away in the same transaction.\\n   */\\n  function transferToken (IERC20 token, uint amount, address receiver) public\\n  {\\n    require (token.transfer (receiver, amount), \\\"token transfer failed\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the expected amount of input token required to get\\n   * the provided output amount in WCHI.\\n   */\\n  function quoteExactOutput (IERC20 inputToken, uint outputAmount,\\n                             bytes calldata data)\\n      public view virtual returns (uint);\\n\\n  /**\\n   * @dev Returns the expected amount of output token if the provided\\n   * input amount of WCHI is swapped.\\n   */\\n  function quoteExactInput (uint inputAmount, IERC20 outputToken,\\n                            bytes calldata data)\\n      public view virtual returns (uint);\\n\\n  /**\\n   * @dev Performs a swap of input tokens to exact output WCHI tokens.\\n   */\\n  function swapExactOutput (IERC20 inputToken, uint outputAmount,\\n                            bytes calldata data) public virtual;\\n\\n  /**\\n   * @dev Performs a swap of an exact input of WCHI to the desired output.\\n   */\\n  function swapExactInput (uint inputAmount, IERC20 outputToken,\\n                           bytes calldata data) public virtual;\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/PackSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2023 Soccerverse Ltd\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/metatx/ERC2771Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./ClubMinter.sol\\\";\\n\\n/**\\n * @dev This contract implements the on-chain sale of share packs in clubs.\\n * It has the configuration about which clubs are available, which countries\\n * they correspond to, and how much a pack of each country costs.  It takes\\n * payment (sent to the owner address) in an ERC20 token such as USDC,\\n * and requests the in-game minting of shares from a ClubMinter.\\n */\\ncontract PackSale is ERC2771Context, Ownable, Pausable\\n{\\n\\n  /**\\n   * @dev The ClubMinter contract used to mint shares.  The PackSale contract\\n   * must be an authorised minter on it.\\n   */\\n  ClubMinter public immutable minter;\\n\\n  /** @dev The token used for payments.  */\\n  IERC20 public immutable token;\\n\\n  /** @dev Configuration for one country.  */\\n  struct CountryConfig\\n  {\\n\\n    /**\\n     * @dev The cost of a pack of this country.  This is in base units\\n     * of the ERC20 payment token.\\n     */\\n    uint packCost;\\n\\n    /** @dev Number of shares of each club given with a pack.  */\\n    uint sharesPerClub;\\n\\n    /** @dev All club IDs that belong to this country.  */\\n    uint[] clubIds;\\n\\n  }\\n\\n  /** @dev Data stored for one club, which points to its country data.  */\\n  struct ClubPointer\\n  {\\n\\n    /** @dev The country this club is associated to.  */\\n    string country;\\n\\n    /** @dev The index in the country's clubIds array.  */\\n    uint index;\\n\\n  }\\n\\n  /** @dev The available and configured countries.  */\\n  mapping (string => CountryConfig) public countries;\\n\\n  /** @dev All clubs that are currently configured.  */\\n  mapping (uint => ClubPointer) public clubs;\\n\\n  /**\\n   * @dev Emitted when a new country is created with base config, or the\\n   * base config of a country updated.\\n   */\\n  event CountryConfigured (string indexed country, uint packCost,\\n                           uint sharesPerClub);\\n\\n  /** @dev Emitted when a club is added.  */\\n  event ClubAdded (uint indexed clubId, string country);\\n\\n  /** @dev Emitted when a club is removed.  */\\n  event ClubRemoved (uint indexed clubId);\\n\\n  /** @dev Emitted when one or more packs are bought.  */\\n  event PacksBought (address indexed buyer, string receiver,\\n                     string country, uint numPacks);\\n\\n  /* ************************************************************************ */\\n\\n  constructor (IERC20 t, ClubMinter m, address fwd)\\n    ERC2771Context(fwd)\\n  {\\n    token = t;\\n    minter = m;\\n  }\\n\\n  /* Explicitly specify that we want to use the ERC2771 variants for\\n     _msgSender and _msgData.  */\\n\\n  function _msgSender ()\\n      internal view override(Context, ERC2771Context) returns (address)\\n  {\\n    return ERC2771Context._msgSender ();\\n  }\\n\\n  function _msgData ()\\n      internal view override(Context, ERC2771Context) returns (bytes calldata)\\n  {\\n    return ERC2771Context._msgData ();\\n  }\\n\\n  function pause () public onlyOwner\\n  {\\n    _pause ();\\n  }\\n\\n  function unpause () public onlyOwner\\n  {\\n    _unpause ();\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Configures a country, adding it or updating the base config.\\n   */\\n  function configureCountry (string calldata country, uint pc, uint s)\\n      public onlyOwner\\n  {\\n    require (bytes (country).length > 0, \\\"empty country string\\\");\\n\\n    CountryConfig storage data = countries[country];\\n    data.packCost = pc;\\n    data.sharesPerClub = s;\\n    emit CountryConfigured (country, pc, s);\\n  }\\n\\n  /**\\n   * @dev Adds a club, assigning it to the given country.\\n   */\\n  function addClub (uint clubId, string calldata country) public onlyOwner\\n  {\\n    require (bytes (country).length > 0, \\\"empty country string\\\");\\n\\n    ClubPointer storage ptr = clubs[clubId];\\n    require (bytes (ptr.country).length == 0, \\\"club is already configured\\\");\\n    ptr.country = country;\\n\\n    CountryConfig storage data = countries[country];\\n    ptr.index = data.clubIds.length;\\n    data.clubIds.push (clubId);\\n    \\n    emit ClubAdded (clubId, country);\\n  }\\n\\n  /**\\n   * @dev Batch adds multiple clubs at once for a country.\\n   */\\n  function addClubs (uint[] calldata clubIds, string calldata country)\\n      public onlyOwner\\n  {\\n    for (uint i = 0; i < clubIds.length; ++i)\\n      addClub (clubIds[i], country);\\n  }\\n\\n  /**\\n   * @dev Removes a club from the config.\\n   */\\n  function removeClub (uint clubId) public onlyOwner\\n  {\\n    ClubPointer memory c = clubs[clubId];\\n\\n    CountryConfig storage data = countries[c.country];\\n    /* If the club does not exist, the country string will be empty, and\\n       thus it will lead to an entry with clubIds.length == 0.  */\\n    require (data.clubIds.length > c.index, \\\"the club does not exist\\\");\\n\\n    /* If the club is not currently at the end of the array, swap it there.  */\\n    if (c.index + 1 < data.clubIds.length)\\n      {\\n        uint endClubId = data.clubIds[data.clubIds.length - 1];\\n        clubs[endClubId].index = c.index;\\n        data.clubIds[c.index] = endClubId;\\n      }\\n\\n    /* Now just remove the last entry, and the club pointer data.  */\\n    data.clubIds.pop ();\\n    delete clubs[clubId];\\n\\n    emit ClubRemoved (clubId);\\n  }\\n\\n  /**\\n   * @dev Returns the clubs (IDs) associated to a given country.\\n   */\\n  function getClubsForCountry (string calldata country)\\n      public view returns (uint[] memory)\\n  {\\n    return countries[country].clubIds;\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Returns the maximum number of packs that can be minted for the\\n   * given country, taking available shares into account.\\n   */\\n  function getMaxPacks (string calldata country) public view returns (uint)\\n  {\\n    if (paused ())\\n      return 0;\\n\\n    CountryConfig storage data = countries[country];\\n\\n    uint sharesPerClub = data.sharesPerClub;\\n    if (sharesPerClub == 0)\\n      return 0;\\n\\n    uint numClubs = data.clubIds.length;\\n    if (numClubs == 0)\\n      return 0;\\n\\n    uint minLeft = minter.sharesAvailable (data.clubIds[0]);\\n    for (uint i = 1; i < numClubs; ++i)\\n      {\\n        uint cur = minter.sharesAvailable (data.clubIds[i]);\\n        if (cur < minLeft)\\n          minLeft = cur;\\n      }\\n\\n    return minLeft / sharesPerClub;\\n  }\\n\\n  /**\\n   * @dev Internal function for minting packs.  This is called from the public\\n   * mint(), but can also be used internally together with auto-convert\\n   * in a subcontract.  This function just mints the packs, and does not\\n   * take any payment.  So the publicly exposed callers need to make sure\\n   * to take payment accordingly.\\n   */\\n  function mintInternal (string calldata country, uint num,\\n                         string calldata receiver, address buyer)\\n      internal\\n  {\\n    CountryConfig storage data = countries[country];\\n    uint sharesPerClub = num * data.sharesPerClub;\\n\\n    /* This will also catch passing an invalid / uninitialised country.  */\\n    uint numClubs = data.clubIds.length;\\n    require (numClubs > 0 && sharesPerClub > 0,\\n             \\\"no clubs to give out for this country\\\");\\n\\n    for (uint i = 0; i < numClubs; ++i)\\n      minter.mint (data.clubIds[i], sharesPerClub, receiver);\\n\\n    emit PacksBought (buyer, receiver, country, num);\\n  }\\n\\n  /**\\n   * @dev Requests to mint one or more packs of a given country.  Payment\\n   * is taken from the _msgSender(), and the minted shares will be given\\n   * to the receiver account name.\\n   */\\n  function mint (string calldata country, uint num, string calldata receiver)\\n      public whenNotPaused\\n  {\\n    address buyer = _msgSender ();\\n    uint total = num * countries[country].packCost;\\n    if (total > 0)\\n      require (token.transferFrom (buyer, owner (), total),\\n               \\\"failed to transfer payment\\\");\\n\\n    mintInternal (country, num, receiver, buyer);\\n  }\\n\\n  /* ************************************************************************ */\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/ClubMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2023 Soccerverse Ltd\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport \\\"@xaya/democrit-evm/contracts/JsonUtils.sol\\\";\\nimport \\\"@xaya/eth-delegator-contract/contracts/XayaDelegation.sol\\\";\\n\\n/**\\n * @dev This contract is responsible for minting club shares (as packs are\\n * bought) using Soccerverse admin commands.  It has delegation access to\\n * g/smc accordingly, so it can send those moves.  It also keeps track of\\n * how many shares have been minted for each club so far, to ensure we do\\n * not attempt to mint over the supply cap.\\n *\\n * The actual selling of packs is handled by another contract, which uses\\n * this one to perform the mints themselves.  By this separation, we can\\n * in theory replace the sales contract if required, while keeping the\\n * state about which shares have been minted already intact in this one.\\n *\\n * Note that this contract does not know which IDs are actually valid clubs.\\n * It just keeps track of the number of shares minted for each ID, as\\n * instructed by the sales contract.\\n */\\ncontract ClubMinter is Ownable\\n{\\n\\n  string public constant gameId = \\\"smc\\\";\\n\\n  /** @dev Delegation contract used to send moves.  */\\n  XayaDelegation public immutable delegator;\\n\\n  /** @dev Maximum allowed supply for each share.  */\\n  uint public constant shareSupply = 10_000_000;\\n\\n  /**\\n   * @dev Whether or not the given address is allowed to request a mint.\\n   * This will be set (by the owner) to the active sales contract(s).\\n   */\\n  mapping (address => bool) public isMinter;\\n\\n  /** @dev Number of shares minted for each club ID.  */\\n  mapping (uint => uint) public sharesMinted;\\n\\n  /** @dev Emitted when the isMinter status of an address changes.  */\\n  event IsMinterChanged (address indexed addr, bool allowed);\\n\\n  /** @dev Emitted when new shares are minted.  */\\n  event Mint (uint indexed clubId, uint num, string receiver,\\n              uint totalMinted, uint remaining);\\n\\n  constructor (XayaDelegation d)\\n  {\\n    delegator = d;\\n\\n    /* In case we need to pay fees for the minting moves, approve WCHI.  */\\n    d.accounts ().wchiToken ().approve (address (d), type (uint256).max);\\n  }\\n\\n  /**\\n   * @dev Sets whether or not a given address is allowed to mint.\\n   */\\n  function setMinter (address addr, bool allowed) public onlyOwner\\n  {\\n    isMinter[addr] = allowed;\\n    emit IsMinterChanged (addr, allowed);\\n  }\\n\\n  /**\\n   * @dev Returns the remaining amount of shares that can be minted\\n   * for a given club.\\n   */\\n  function sharesAvailable (uint clubId) public view returns (uint)\\n  {\\n    return shareSupply - sharesMinted[clubId];\\n  }\\n\\n  /**\\n   * @dev Requests to mint some shares of a given club.\\n   */\\n  function mint (uint clubId, uint num, string calldata receiver) public\\n  {\\n    require (isMinter[msg.sender], \\\"message sender is not allowed to mint\\\");\\n\\n    uint minted = sharesMinted[clubId];\\n    minted += num;\\n    require (minted <= shareSupply, \\\"mint cap exceeded\\\");\\n\\n    string memory escapedReceiver = JsonUtils.escapeString (receiver);\\n    string memory mintCmd = string (abi.encodePacked (\\n      \\\"{\\\",\\n        \\\"\\\\\\\"s\\\\\\\":{\\\\\\\"club\\\\\\\":\\\", Strings.toString (clubId), \\\"},\\\",\\n        \\\"\\\\\\\"r\\\\\\\":\\\", escapedReceiver, \\\",\\\",\\n        \\\"\\\\\\\"n\\\\\\\":\\\", Strings.toString (num),\\n      \\\"}\\\"\\n    ));\\n    string[] memory path = new string[] (2);\\n    path[0] = \\\"cmd\\\";\\n    path[1] = \\\"mint\\\";\\n    delegator.sendHierarchicalMove (\\\"g\\\", gameId, path, mintCmd);\\n\\n    sharesMinted[clubId] = minted;\\n    emit Mint (clubId, num, receiver, minted, shareSupply - minted);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/eth-delegator-contract/contracts/XayaDelegation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2022 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"./JsonSubObject.sol\\\";\\nimport \\\"./NamePermissions.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/metatx/ERC2771Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@xaya/eth-account-registry/contracts/IXayaAccounts.sol\\\";\\n\\n/**\\n * @dev The main delegation contract.  It uses the permissions tree system\\n * implemented in the super contracts, and links it to the actual XayaAccounts\\n * contract for sending moves.  It also enables ERC2771 meta transactions.\\n */\\ncontract XayaDelegation is NamePermissions, ERC2771Context, IERC721Receiver\\n{\\n\\n  /* ************************************************************************ */\\n\\n  /** @dev The XayaAccounts contract used.  */\\n  IXayaAccounts public immutable accounts;\\n\\n  /** @dev The WCHI token used.  */\\n  IERC20 public immutable wchi;\\n\\n  /**\\n   * @dev Temporarily set to true while we expect to receive name NFTs\\n   * (e.g. while registering for a user).\\n   *\\n   * It allows to receive name ERC721 tokens when set.\\n   */\\n  bool private allowNameReceive;\\n\\n  /**\\n   * @dev Constructs the contract, fixing the XayaAccounts as well as forwarder\\n   * contracts.\\n   */\\n  constructor (IXayaAccounts acc, address fwd)\\n    ERC2771Context(fwd)\\n  {\\n    accounts = acc;\\n    wchi = accounts.wchiToken ();\\n    wchi.approve (address (accounts), type (uint256).max);\\n  }\\n\\n  /**\\n   * @dev We accept ERC-721 token transfers only when explicitly specified\\n   * that we expect one, and we only accept Xaya names at all.\\n   */\\n  function onERC721Received (address, address, uint256, bytes calldata)\\n      public view override returns (bytes4)\\n  {\\n    require (msg.sender == address (accounts),\\n             \\\"only Xaya names can be received\\\");\\n    require (allowNameReceive, \\\"tokens cannot be received at the moment\\\");\\n    return IERC721Receiver.onERC721Received.selector;\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Registers a name for a given owner.  This registers the name,\\n   * transfers it, and then sets operator permissions for the delegation\\n   * contract with the owner's prepared signature.  With this method, we\\n   * can enable gas-free name registration with this contract's support\\n   * for meta transactions.  Returns the new token's ID.\\n   *\\n   * The WCHI for the name registration is paid for by _msgSender.\\n   */\\n  function registerFor (string memory ns, string memory name,\\n                        address owner, bytes memory signature)\\n      public returns (uint256 tokenId)\\n  {\\n    uint256 fee = accounts.policy ().checkRegistration (ns, name);\\n    if (fee > 0)\\n      require (wchi.transferFrom (_msgSender (), address (this), fee),\\n               \\\"failed to obtain WCHI from sender\\\");\\n\\n    allowNameReceive = true;\\n    tokenId = accounts.register (ns, name);\\n    allowNameReceive = false;\\n    accounts.safeTransferFrom (address (this), owner, tokenId);\\n\\n    /* In theory, we could eliminate the \\\"owner\\\" argument and just recover\\n       it from the signature always.  But that runs the risk of sending names\\n       to an unspendable address if the user messes up the signature, so we\\n       are explicit here to ensure this can't happen as easily.  */\\n    address fromSig = accounts.permitOperator (address (this), signature);\\n    require (owner == fromSig, \\\"signature did not match owner\\\");\\n  }\\n\\n  /**\\n   * @dev Takes over a name:  This transfers the name to be owned by\\n   * the delegation contract (which is irreversible and corresponds to\\n   * a provable \\\"lock\\\" of the name).  This can only be done by the owner\\n   * of the name.  The previous owner will be granted top-level permissions,\\n   * based on which they can then selectively restrict their access if desired.\\n   */\\n  function takeOverName (string memory ns, string memory name)\\n      public\\n  {\\n    (uint256 tokenId, address owner) = idAndOwner (ns, name);\\n    require (_msgSender () == owner, \\\"only the owner can request a take over\\\");\\n\\n    allowNameReceive = true;\\n    accounts.safeTransferFrom (owner, address (this), tokenId);\\n    allowNameReceive = false;\\n\\n    string[] memory emptyPath;\\n    /* We need to do a real, external transaction here (rather than an\\n       internal call), so that the sender is actually the contract now,\\n       which is the owner and allowed to grant permissions.  */\\n    this.grant (tokenId, address (this), emptyPath,\\n                owner, type (uint256).max, false);\\n  }\\n\\n  /**\\n   * @dev Sends a move for the given name that contains some JSON data at\\n   * the given path.  Verifies that the _msgSender is allowed to send\\n   * a move for that name and path at the current time.  The nonce used is\\n   * returned (as from XayaAccounts.move).\\n   *\\n   * Any WCHI required for the move will be paid for by _msgSender.\\n   */\\n  function sendHierarchicalMove (string memory ns, string memory name,\\n                                 string[] memory path, string memory mv)\\n      public returns (uint256)\\n  {\\n    return sendHierarchicalMove (ns, name, path, mv, type (uint256).max,\\n                                 0, address (0));\\n  }\\n\\n  /**\\n   * @dev Sends a move for the given name as the other sendHierarchicalMove\\n   * method, but allows control over nonce and WCHI payments.\\n   */\\n  function sendHierarchicalMove (string memory ns, string memory name,\\n                                 string[] memory path, string memory mv,\\n                                 uint256 nonce,\\n                                 uint256 amount, address receiver)\\n      public returns (uint256)\\n  {\\n    require (hasAccess (ns, name, path, _msgSender (), block.timestamp),\\n             \\\"the message sender has no permission to send moves\\\");\\n\\n    string memory fullMove = JsonSubObject.atPath (path, mv);\\n    uint256 cost = accounts.policy ().checkMove (ns, fullMove) + amount;\\n    if (cost > 0)\\n      require (wchi.transferFrom (_msgSender (), address (this), cost),\\n               \\\"failed to obtain WCHI from sender\\\");\\n\\n    return accounts.move (ns, name, fullMove, nonce, amount, receiver);\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Computes the tokenId and looks up the current owner for a given name.\\n   */\\n  function idAndOwner (string memory ns, string memory name)\\n      private view returns (uint256 tokenId, address owner)\\n  {\\n    tokenId = accounts.tokenIdForName (ns, name);\\n    owner = accounts.ownerOf (tokenId);\\n  }\\n\\n  /* Expose the methods for managing permissions from NamePermissions on a\\n     per-name basis, with automatic lookup of the tokenId and current owner.\\n\\n     This is just for convenience.  All logic (and checks!) are done in the\\n     according methods in NamePermissions, and those could be called directly\\n     as well by anyone if needed.  */\\n\\n  function hasAccess (string memory ns, string memory name,\\n                      string[] memory path,\\n                      address operator, uint256 atTime)\\n      public view returns (bool)\\n  {\\n    (uint256 tokenId, address owner) = idAndOwner (ns, name);\\n    return hasAccess (tokenId, owner, path, operator, atTime);\\n  }\\n\\n  function grant (string memory ns, string memory name, string[] memory path,\\n                  address operator, uint256 expiration, bool fallbackOnly)\\n      public\\n  {\\n    (uint256 tokenId, address owner) = idAndOwner (ns, name);\\n    grant (tokenId, owner, path, operator, expiration, fallbackOnly);\\n  }\\n\\n  function revoke (string memory ns, string memory name, string[] memory path,\\n                   address operator, bool fallbackOnly)\\n      public\\n  {\\n    (uint256 tokenId, address owner) = idAndOwner (ns, name);\\n    revoke (tokenId, owner, path, operator, fallbackOnly);\\n  }\\n\\n  function resetTree (string memory ns, string memory name,\\n                      string[] memory path)\\n      public\\n  {\\n    (uint256 tokenId, address owner) = idAndOwner (ns, name);\\n    resetTree (tokenId, owner, path);\\n  }\\n\\n  function expireTree (string memory ns, string memory name,\\n                       string[] memory path)\\n      public\\n  {\\n    (uint256 tokenId, address owner) = idAndOwner (ns, name);\\n    expireTree (tokenId, owner, path);\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /* Explicitly specify that we want to use the ERC2771 variants for\\n     _msgSender and _msgData.  */\\n\\n  function _msgSender ()\\n      internal view override(Context, ERC2771Context) returns (address)\\n  {\\n    return ERC2771Context._msgSender ();\\n  }\\n\\n  function _msgData ()\\n      internal view override(Context, ERC2771Context) returns (bytes calldata)\\n  {\\n    return ERC2771Context._msgData ();\\n  }\\n\\n  /* ************************************************************************ */\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/eth-delegator-contract/contracts/NamePermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2022 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"./MovePermissions.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev A base smart contract that stores a tree of move permissions for\\n * each token ID of a Xaya name, and NFT owner.  It also implements basic\\n * methods to extract the data via public view methods if desired, and\\n * to modify (grant and revoke) permissions.  These methods will ensure\\n * proper authorisation checks, so that only users actually permitted\\n * to grant or revoke permissions can do so.\\n *\\n * This contract is still \\\"abstract\\\" in that it does not actually link\\n * to the XayaAccounts registry yet (and thus does not actually query\\n * or process who really owns a name at the moment), and it also does not\\n * yet implement actual move functions (just the permissions handling).\\n */\\ncontract NamePermissions is Context\\n{\\n\\n  using MovePermissions for MovePermissions.PermissionsNode;\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev The permissions tree associated to each particular name when\\n   * owned by a given account.\\n   */\\n  mapping (uint256 => mapping (address => MovePermissions.PermissionsNode))\\n      private permissions;\\n\\n  /** @dev Event fired when a permission is granted.  */\\n  event PermissionGranted (uint256 indexed tokenId, address indexed owner,\\n                           string[] path, address operator, uint256 expiration,\\n                           bool fallbackOnly);\\n\\n  /**\\n   * @dev Event fired when a particular permission is revoked.  Note that this\\n   * may or may not mean that some empty nodes in the permissions tree\\n   * have been pruned as well.\\n   */\\n  event PermissionRevoked (uint256 indexed tokenId, address indexed owner,\\n                           string[] path, address operator, bool fallbackOnly);\\n\\n  /**\\n   * @dev Event fired when an entire tree of permissions has been reset\\n   * to just a single permission (for the message sender).\\n   */\\n  event PermissionTreeReset (uint256 indexed tokenId, address indexed owner,\\n                             string[] path);\\n\\n  /**\\n   * @dev Event fired when permissions inside a subtree have been explicitly\\n   * expired.  Note that the individual permissions removed do not emit\\n   * any more events.\\n   */\\n  event PermissionTreeExpired (uint256 indexed tokenId, address indexed owner,\\n                               string[] path, uint256 atTime);\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Retrieves the permissions node at the given position.\\n   */\\n  function retrieve (uint256 tokenId, address owner, string[] memory path)\\n      private view returns (MovePermissions.PermissionsNode storage)\\n  {\\n    return permissions[tokenId][owner].retrieveNode (path);\\n  }\\n\\n  /**\\n   * @dev Retrieves the address permissions tied to a given place in the\\n   * permissions hierarchy, operator and fallback status.\\n   */\\n  function retrieve (uint256 tokenId, address owner, string[] memory path,\\n                     address operator, bool fallbackOnly)\\n      private view returns (MovePermissions.AddressPermissions storage)\\n  {\\n    MovePermissions.PermissionsNode storage node\\n        = retrieve (tokenId, owner, path);\\n    return (fallbackOnly ? node.fallbackAccess.forAddress[operator]\\n                         : node.fullAccess.forAddress[operator]);\\n  }\\n\\n  /**\\n   * @dev Returns true if there is a node with specific permissions\\n   * at the given hierarchy level (i.e. it exists).\\n   */\\n  function permissionExists (uint256 tokenId, address owner,\\n                             string[] memory path)\\n      public view returns (bool)\\n  {\\n    return retrieve (tokenId, owner, path).indexAndOne != 0;\\n  }\\n\\n  /**\\n   * @dev Returns true if a specific permission exists at the given\\n   * node and for the given operator and fallback type.\\n   */\\n  function permissionExists (uint256 tokenId, address owner,\\n                             string[] memory path, address operator,\\n                             bool fallbackOnly)\\n      public view returns (bool)\\n  {\\n    MovePermissions.AddressPermissions storage addrPerm\\n        = retrieve (tokenId, owner, path, operator, fallbackOnly);\\n    return addrPerm.indexAndOne != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the expiration timestamp for a given operator permission\\n   * inside the storage.\\n   */\\n  function getExpiration (uint256 tokenId, address owner, string[] memory path,\\n                          address operator, bool fallbackOnly)\\n      public view returns (uint256)\\n  {\\n    MovePermissions.AddressPermissions storage addrPerm\\n        = retrieve (tokenId, owner, path, operator, fallbackOnly);\\n    return addrPerm.expiration;\\n  }\\n\\n  /**\\n   * @dev Returns all defined keys (addresses with full access, addresses\\n   * with fallback access, and child paths) for the node at the given position\\n   * in the permissions.\\n   */\\n  function getDefinedKeys (uint256 tokenId, address owner, string[] memory path)\\n      public view returns (string[] memory children,\\n                           address[] memory fullAccess,\\n                           address[] memory fallbackAccess)\\n  {\\n    MovePermissions.PermissionsNode storage node\\n        = retrieve (tokenId, owner, path);\\n    children = node.keys;\\n    fullAccess = node.fullAccess.keys;\\n    fallbackAccess = node.fallbackAccess.keys;\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Checks if the given address has access permissions to the\\n   * given token and hierarchy level.  In addition to the actual rules\\n   * specified in the permissions themselves, the owner address always\\n   * has access.\\n   */\\n  function hasAccess (uint256 tokenId, address owner, string[] memory path,\\n                      address operator, uint256 atTime)\\n      public view returns (bool)\\n  {\\n    if (operator == owner)\\n      return true;\\n\\n    return permissions[tokenId][owner].check (path, operator, atTime);\\n  }\\n\\n  /**\\n   * @dev Tries to grant a particular permission, checking that the sender\\n   * of the message is actually allowed to do so.\\n   */\\n  function grant (uint256 tokenId, address owner, string[] memory path,\\n                  address operator, uint256 expiration, bool fallbackOnly)\\n      public\\n  {\\n    require (hasAccess (tokenId, owner, path, _msgSender (), expiration),\\n             \\\"the sender has no access\\\");\\n\\n    permissions[tokenId][owner].grant (path, operator,\\n                                       expiration, fallbackOnly);\\n    emit PermissionGranted (tokenId, owner, path, operator,\\n                            expiration, fallbackOnly);\\n  }\\n\\n  /**\\n   * @dev Checks if the root node for the given token and owner is empty\\n   * (i.e. potentially set but with nothing in it) and removes it if so.\\n   */\\n  function removeIfEmpty (uint256 tokenId, address owner) private\\n  {\\n    MovePermissions.PermissionsNode storage root = permissions[tokenId][owner];\\n    if (root.indexAndOne != 0 && root.isEmpty ())\\n      delete permissions[tokenId][owner];\\n  }\\n\\n  /**\\n   * @dev Revokes a particular approval, checking that the message\\n   * sender is actually allowed to do so.\\n   */\\n  function revoke (uint256 tokenId, address owner, string[] memory path,\\n                   address operator, bool fallbackOnly)\\n      public\\n  {\\n    address sender = _msgSender ();\\n    /* Any address can revoke its own access, and also any access on levels\\n       where it has unlimited (in time) permissions.  */\\n    require (sender == operator\\n                || hasAccess (tokenId, owner, path, sender, type (uint256).max),\\n             \\\"the sender has no access\\\");\\n\\n    permissions[tokenId][owner].revoke (path, operator, fallbackOnly);\\n    removeIfEmpty (tokenId, owner);\\n    emit PermissionRevoked (tokenId, owner, path, operator, fallbackOnly);\\n  }\\n\\n  /**\\n   * @dev Revokes all permissions in a given subtree, and replaces them with\\n   * just a single permission for the message sender.  This can be used\\n   * to reset an entire tree of permissions if desired, while making sure the\\n   * message sender retains permission (but they can explicitly revoke their\\n   * own as well afterwards).  Reverts if the message sender has no access\\n   * to the requested level.\\n   */\\n  function resetTree (uint256 tokenId, address owner, string[] memory path)\\n      public\\n  {\\n    address sender = _msgSender ();\\n    require (hasAccess (tokenId, owner, path, sender, type (uint256).max),\\n             \\\"the sender has no access\\\");\\n\\n    MovePermissions.PermissionsNode storage root = permissions[tokenId][owner];\\n    root.revokeTree (path);\\n\\n    /* If the message sender is not the owner, we add them back as only\\n       permission at that level now (and then the subtree is by definition\\n       not empty).  Otherwise, they have access in any case, and we might\\n       be able to prune an empty tree.  */\\n    if (sender != owner)\\n      root.grant (path, sender, type (uint256).max, false);\\n    else\\n      removeIfEmpty (tokenId, owner);\\n\\n    emit PermissionTreeReset (tokenId, owner, path);\\n  }\\n\\n  /**\\n   * @dev Removes all expired permissions in the given subtree.  This may\\n   * have an indirect effect on fallback permissions, but otherwise does not\\n   * alter permissions (since it only removes ones that are expired anyway at\\n   * the current time).  Everyone is allowed to call this if they are willing\\n   * to pay for the gas.\\n   */\\n  function expireTree (uint256 tokenId, address owner, string[] memory path)\\n      public\\n  {\\n    permissions[tokenId][owner].expireTree (path, block.timestamp);\\n    removeIfEmpty (tokenId, owner);\\n    emit PermissionTreeExpired (tokenId, owner, path, block.timestamp);\\n  }\\n\\n  /* ************************************************************************ */\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/eth-delegator-contract/contracts/MovePermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2022 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.13;\\n\\n/**\\n * @dev Solidity library that implements the core permissions logic for moves.\\n * Those permissions form hierarchical trees (with one tree for a particular\\n * account (token ID) and current owner).  The trees correspond to JSON \\\"paths\\\"\\n * to specify which bits of a full move someone has permission for (e.g.\\n * just the g->tn subobject to send Taurion moves, or even just a particular\\n * type of move for one game).\\n *\\n * Each node in the tree can specify:\\n *  - addresses that have permission for moves in that subtree,\\n *    potentially with an expiration time\\n *  - addresses that have \\\"fallback permission\\\" (with optional expiration),\\n *    which means that have access to any subtree (not at the current level\\n *    directly) that has no explicit node in the permissions tree\\n *  - child nodes that further refine permissions for JSON fields\\n *    below the current level\\n *\\n * This library implements the core logic for operating on these permission\\n * trees, without actually triggering delegated moves nor even storing the\\n * actual root trees themselves and tying them to accounts.  It just exposes\\n * internal methods for querying and updating the permission trees passed in\\n * as storage pointers.\\n */\\nlibrary MovePermissions\\n{\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Helper struct which represents the data stored for an address\\n   * with (fallback) permissions.\\n   */\\n  struct AddressPermissions\\n  {\\n\\n    /**\\n     * @dev The latest timestamp when permissions are granted, or uint256.max\\n     * if access is \\\"unlimited\\\".\\n     */\\n    uint256 expiration;\\n\\n    /**\\n     * @dev The one-based index (i.e. the actual index + 1) of the address in\\n     * the parent struct's array of addresses with explicit permissions.\\n     *\\n     * This has two uses:  First, it allows us to explicitly and effectively\\n     * delete an entry and update the list of defined addresses at the same\\n     * time (by swap-replacing the entry at the given index with the last one\\n     * and shrinking the array).  Second, if the value is non-zero, we know that\\n     * the entry actually exists and is explicitly set (vs. zero meaning it\\n     * is a missing map entry).\\n     */\\n    uint indexAndOne;\\n\\n  }\\n\\n  /**\\n   * @dev A mapping of addresses to explicit permissions (mainly expiration\\n   * timestamps) of them.  This also contains book-keeping data so that\\n   * we can iterate through all explicit addresses and remove them if\\n   * so desired (as well as remove individual ones).\\n   */\\n  struct PermissionsMap\\n  {\\n\\n    /** @dev Addresses and their associated permissions.  */\\n    mapping (address => AddressPermissions) forAddress;\\n\\n    /** @dev List of all addresses with set permissions.  */\\n    address[] keys;\\n\\n  }\\n\\n  /**\\n   * @dev All data stored for permissions at a particular node in the\\n   * tree for one account.  This also contains necessary book-keeping data\\n   * to iterate the entire tree and remove all entries in it if desired.\\n   */\\n  struct PermissionsNode\\n  {\\n\\n    /**\\n     * @dev The one-based index (i.e. actual index + 1) of this node\\n     * in the parent's \\\"keys\\\" array (similar to the field in\\n     * AddressPermissions).\\n     *\\n     * For the permissions at the tree's root, this value is just something\\n     * non-zero to indicate the entry actually exists.\\n     */\\n    uint indexAndOne;\\n\\n    /** @dev Addresses that have full access at and below the current level.  */\\n    PermissionsMap fullAccess;\\n\\n    /** @dev Addresses with fallback access only.  */\\n    PermissionsMap fallbackAccess;\\n\\n    /** @dev Child nodes with explicitly defined permissions.  */\\n    mapping (string => PermissionsNode) children;\\n\\n    /** @dev All keys for which child nodes are defined.  */\\n    string[] keys;\\n\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Checks if the given address should have move permissions in a\\n   * particular permissions tree (whose root node is passed) for a particular\\n   * JSON path and at a particular time.  Returns true if permissions should\\n   * be granted and false if not.\\n   */\\n  function check (PermissionsNode storage root, string[] memory path,\\n                  address operator, uint256 atTime)\\n      internal view returns (bool)\\n  {\\n    /* For simplicity, we check \\\"expiration >= atTime\\\" later on against\\n       the permissions entries.  If an entry does not exist at all, expiration\\n       will be returned as zero.  This could lead to unexpected behaviour\\n       if we allow atTime to be zero.  Since a zero atTime is not relevant\\n       in practice anyway (since that is long in the past), let's explicitly\\n       disallow this.  */\\n    require (atTime > 0, \\\"atTime must not be zero\\\");\\n\\n    PermissionsNode storage node = root;\\n    uint nextPath = 0;\\n\\n    while (true)\\n      {\\n        /* If there is an explicit and non-expired full-access entry\\n           at the current level, we're good.  */\\n        if (node.fullAccess.forAddress[operator].expiration >= atTime)\\n          return true;\\n\\n        /* We can't grant access directly at the current level.  So if the\\n           request is not for a deeper level, we reject it.  */\\n        assert (nextPath <= path.length);\\n        if (nextPath == path.length)\\n          return false;\\n\\n        /* See if there is an explicit node for the next path level.\\n           If there is, we continue with it.  */\\n        PermissionsNode storage child = node.children[path[nextPath]];\\n        if (child.indexAndOne > 0)\\n          {\\n            node = child;\\n            ++nextPath;\\n            continue;\\n          }\\n\\n        /* Finally, we apply access based on the fallback map.  */\\n        return node.fallbackAccess.forAddress[operator].expiration >= atTime;\\n      }\\n\\n    /* We can never reach here, but this silences the compiler warning\\n       about a missing return.  */\\n    assert (false);\\n    return false;\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Looks up and returns (as storage pointer) the ultimate\\n   * tree node with the permissions for the given level.  If it (or any\\n   * of its parents) does not exist yet and \\\"create\\\" is set, those will be\\n   * added.\\n   */\\n  function retrieveNode (PermissionsNode storage root, string[] memory path,\\n                         bool create)\\n      private returns (PermissionsNode storage)\\n  {\\n    /* If the root itself does not actually exist (is not initialised yet),\\n       we do so as well.  For the root, the only thing that matters is\\n       that indexAndOne is not zero.  We set it to max uint256 just to emphasise\\n       it is not an actual, valid index.  */\\n    if (root.indexAndOne == 0 && create)\\n      root.indexAndOne = type (uint256).max;\\n\\n    PermissionsNode storage node = root;\\n    for (uint i = 0; i < path.length; ++i)\\n      {\\n        PermissionsNode storage child = node.children[path[i]];\\n\\n        /* If the node does not exist yet, add it explicitly to the parent's\\n           keys array, and store its indexAndOne.  */\\n        if (child.indexAndOne == 0 && create)\\n          {\\n            node.keys.push (path[i]);\\n            child.indexAndOne = node.keys.length;\\n          }\\n\\n        node = child;\\n      }\\n\\n    return node;\\n  }\\n\\n  /**\\n   * @dev Looks up and returns (as storage pointer) the ultimate tree node\\n   * with the given level.  This method never auto-creates entries,\\n   * and is available to users of the library.  It is also \\\"view\\\".\\n   */\\n  function retrieveNode (PermissionsNode storage root, string[] memory path)\\n      internal view returns (PermissionsNode storage res)\\n  {\\n    res = root;\\n    for (uint i = 0; i < path.length; ++i)\\n      res = res.children[path[i]];\\n  }\\n\\n  /**\\n   * @dev Sets the expiration timestamp associated to an address in a\\n   * permissions map to the given value.  This function also takes care to\\n   * update the necessary book-keeping fields (i.e. keys) in case this\\n   * actually inserts a new element.  Note that this is meant for granting\\n   * permissions, and as such the new timestamp must be non-zero and also\\n   * not earlier than any existing timestamp.\\n   */\\n  function setExpiration (PermissionsMap storage map, address key,\\n                          uint256 expiration) private\\n  {\\n    require (expiration > 0, \\\"cannot grant permissions with zero expiration\\\");\\n\\n    AddressPermissions storage entry = map.forAddress[key];\\n    require (expiration >= entry.expiration,\\n             \\\"existing permission has longer validity than new grant\\\");\\n    entry.expiration = expiration;\\n\\n    if (entry.indexAndOne == 0)\\n      {\\n        map.keys.push (key);\\n        entry.indexAndOne = map.keys.length;\\n      }\\n  }\\n\\n  /**\\n   * @dev Unconditionally grants permissions in a given tree to a given\\n   * operator address, potentially in the fallback map.  The expiration time\\n   * must be non-zero and must not be earlier than any existing entry in the\\n   * given map.  No other checks are performed, so callers need to make sure\\n   * that it is actually permitted in the current context to grant the new\\n   * permission.\\n   */\\n  function grant (PermissionsNode storage root, string[] memory path,\\n                  address operator, uint256 expiration, bool fallbackOnly)\\n      internal\\n  {\\n    PermissionsNode storage node = retrieveNode (root, path, true);\\n    setExpiration (fallbackOnly ? node.fallbackAccess : node.fullAccess,\\n                   operator, expiration);\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Revokes permissions for an address in a PermissionsMap (i.e. removes\\n   * the corresponding entry, keeping \\\"keys\\\" up-to-date).\\n   */\\n  function removeEntry (PermissionsMap storage map, address key) private\\n  {\\n    uint oldIndex = map.forAddress[key].indexAndOne;\\n    if (oldIndex == 0)\\n      return;\\n\\n    delete map.forAddress[key];\\n\\n    /* Now we need to remove the entry from keys.  If it is the last one,\\n       we can just pop.  Otherwise we swap the last element into its position\\n       and pop then.  */\\n\\n    if (oldIndex < map.keys.length)\\n      {\\n        address last = map.keys[map.keys.length - 1];\\n        map.keys[oldIndex - 1] = last;\\n\\n        AddressPermissions storage lastEntry = map.forAddress[last];\\n        assert (lastEntry.indexAndOne > 0);\\n        lastEntry.indexAndOne = oldIndex;\\n      }\\n\\n    map.keys.pop ();\\n  }\\n\\n  /**\\n   * @dev Checks if a permissions node is empty, which means that it\\n   * has no children and no explicit permissions set.\\n   */\\n  function isEmpty (PermissionsNode storage node) internal view returns (bool)\\n  {\\n    return node.keys.length == 0\\n        && node.fullAccess.keys.length == 0\\n        && node.fallbackAccess.keys.length == 0;\\n  }\\n\\n  /**\\n   * @dev Removes the child node at the given key below parent if it\\n   * is empty.  This takes care to update all the book-keeping stuff, like\\n   * parent.keys and the other child indices.\\n   */\\n  function removeChildIfEmpty (PermissionsNode storage parent,\\n                               string memory key) private\\n  {\\n    PermissionsNode storage child = parent.children[key];\\n    if (!isEmpty (child))\\n      return;\\n\\n    uint oldIndex = child.indexAndOne;\\n    delete parent.children[key];\\n\\n    /* If the child didn't exist at all, nothing to do.  */\\n    if (oldIndex == 0)\\n      return;\\n\\n    /* Remove the child in parent.keys by swapping in the last element\\n       and popping at the tail.  */\\n    if (oldIndex < parent.keys.length)\\n      {\\n        string memory last = parent.keys[parent.keys.length - 1];\\n        parent.keys[oldIndex - 1] = last;\\n\\n        PermissionsNode storage lastNode = parent.children[last];\\n        assert (lastNode.indexAndOne > 0);\\n        lastNode.indexAndOne = oldIndex;\\n      }\\n\\n    parent.keys.pop ();\\n  }\\n\\n  /**\\n   * @dev Removes all \\\"empty\\\" tree nodes along the specified branch to clean\\n   * up storage.  If a node has no children and both permission maps are\\n   * empty (no keys with associations), then it will be removed.  This has\\n   * \\\"almost\\\" no effect on permissions, with the exception being that it may\\n   * grant back permissions to addresses with fallback access.\\n   *\\n   * This method is used recursively, and considers only the tail of the\\n   * path array starting at the given \\\"start\\\" index.\\n   */\\n  function removeEmptyNodes (PermissionsNode storage node,\\n                             string[] memory path, uint start) private\\n  {\\n    /* If the current node does not exist or is at the leaf level,\\n       there is nothing to do.  Deleting of empty nodes is done one\\n       level up (from the call on its parent node), so that the parent's\\n       book-keeping data can be updated as well.  */\\n    if (node.indexAndOne == 0 || start == path.length)\\n      return;\\n    assert (start < path.length);\\n\\n    /* Process the child node first, so descendant nodes further down\\n       are cleared now (if any).  */\\n    removeEmptyNodes (node.children[path[start]], path, start + 1);\\n\\n    /* If the child node is empty, remove it.  */\\n    removeChildIfEmpty (node, path[start]);\\n  }\\n\\n  /**\\n   * @dev Revokes a particular permission at the given tree level\\n   * and in the fallback or full-access map (based on the flag).\\n   *\\n   * This method does not perform any checks, so callers need to ensure\\n   * that it is actually ok to revoke that entry (e.g. the message sender\\n   * has the required authorisation).\\n   *\\n   * If this leads to completely \\\"empty\\\" tree nodes, they will be removed\\n   * and cleaned up as well.  Note that this may, in special situations, lead\\n   * to expanded permissions of an address with fallback access.\\n   */\\n  function revoke (PermissionsNode storage root, string[] memory path,\\n                   address operator, bool fallbackOnly) internal\\n  {\\n    PermissionsNode storage node = retrieveNode (root, path, false);\\n    removeEntry (fallbackOnly ? node.fallbackAccess : node.fullAccess,\\n                 operator);\\n\\n    removeEmptyNodes (root, path, 0);\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Clears an entire PermissionsMap completely.\\n   */\\n  function clear (PermissionsMap storage map) private\\n  {\\n    for (uint i = 0; i < map.keys.length; ++i)\\n      delete map.forAddress[map.keys[i]];\\n    delete map.keys;\\n  }\\n\\n  /**\\n   * @dev Revokes all permissions in the entire hierarchy starting at\\n   * the given node.  If deleteNode is set, then the node itself\\n   * will be removed (i.e. also the indexAndOne it has as marker).  If not,\\n   * then it will remain.\\n   */\\n  function revokeTree (PermissionsNode storage node, bool deleteNode) private\\n  {\\n    clear (node.fullAccess);\\n    clear (node.fallbackAccess);\\n\\n    for (uint i = 0; i < node.keys.length; ++i)\\n      revokeTree (node.children[node.keys[i]], true);\\n    delete node.keys;\\n\\n    if (deleteNode)\\n      delete node.indexAndOne;\\n  }\\n\\n  /**\\n   * @dev Revokes all permissions for a node at a given path.\\n   */\\n  function revokeTree (PermissionsNode storage root, string[] memory path)\\n      internal\\n  {\\n    revokeTree (retrieveNode (root, path, false), false);\\n  }\\n\\n  /* ************************************************************************ */\\n\\n  /**\\n   * @dev Removes all expired permissions inside a PermissionsMap.\\n   */\\n  function expire (PermissionsMap storage map, uint256 atTime) private\\n  {\\n    /* removeEntry only affects (potentially) the elements from the removed\\n       index onwards, since it either pops the last element if that is the\\n       current one, or swaps in the last element into the current position.\\n\\n       Thus if we iterate in reverse order, a single pass is enough even if\\n       we keep removing some of the elements while we do it.  */\\n\\n    for (int i = int (map.keys.length) - 1; i >= 0; --i)\\n      {\\n        address current = map.keys[uint (i)];\\n        if (map.forAddress[current].expiration < atTime)\\n          removeEntry (map, current);\\n      }\\n  }\\n\\n  /**\\n   * @dev Revokes all expired permissions in the given subtree (i.e. permissions\\n   * with a time earlier than the atTime timestamp).  Any child nodes that\\n   * become empty will be removed as well (but not the initial node with\\n   * which the method is called).\\n   */\\n  function expireTree (PermissionsNode storage node, uint256 atTime) private\\n  {\\n    expire (node.fullAccess, atTime);\\n    expire (node.fallbackAccess, atTime);\\n\\n    /* As with expire, we process the children in reverse order, so that\\n       we need only a single pass even if nodes are removed (swapped with\\n       the last one) during the process.  */\\n    for (int i = int (node.keys.length) - 1; i >= 0; --i)\\n      {\\n        string memory current = node.keys[uint (i)];\\n        expireTree (node.children[current], atTime);\\n        removeChildIfEmpty (node, current);\\n      }\\n  }\\n\\n  /**\\n   * @dev Revokes all permissions expired at the given timestamp (i.e. earlier\\n   * than atTime) in the subtree referenced.  Afterwards, all nodes that\\n   * have become empty will be cleaned out up to (not including) the root.\\n   */\\n  function expireTree (PermissionsNode storage root, string[] memory path,\\n                       uint256 atTime) internal\\n  {\\n    expireTree (retrieveNode (root, path, false), atTime);\\n\\n    /* Also remove parent nodes of the expired tree if they became empty\\n       (expireTree only removes empty nodes below the first node on which\\n       it gets called).  */\\n    removeEmptyNodes (root, path, 0);\\n  }\\n\\n  /* ************************************************************************ */\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/eth-delegator-contract/contracts/JsonSubObject.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2022 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.13;\\n\\n/**\\n * @dev A Solidity library that implements building of JSON moves\\n * where a user-supplied \\\"sub object\\\" is placed at some specified\\n * path (e.g. user-supplied move for a particular game ID in Xaya).\\n * This includes validation required to ensure that users cannot\\n * \\\"inject\\\" fake JSON strings to manipulate and break out of the\\n * specified path.\\n */\\nlibrary JsonSubObject\\n{\\n\\n  /**\\n   * @dev Checks if a string is a \\\"safe\\\" JSON object serialisation.  This means\\n   * that the string is either a valid and complete JSON object, or that it\\n   * will certainly produce invalid JSON if concatenated with other JSON\\n   * strings and placed at the position for some JSON value.\\n   * For simplicity, this method does not accept leading or trailing\\n   * whitespace around the outer-most {} of the object.\\n   *\\n   * This method is at the heart of the safe sub-object construction.\\n   * It ensures that the user-provided string cannot lead to an \\\"injection\\\"\\n   * of JSON syntax that breaks out of the intended path it is placed at,\\n   * either because it is a valid and proper JSON object, or because it will\\n   * at least produce invalid JSON in the end which leads to invalid moves.\\n   * By allowing the latter, we can simplify the processing necessary in\\n   * Solidity to a minimum.\\n   */\\n  function isSafe (string memory str) private pure returns (bool)\\n  {\\n    /* Essentially, what this method needs to detect and reject are\\n       strings like:\\n\\n         null},\\\"other game\\\":{...\\n\\n       If such a string would be put as sub-object into a particular place\\n       by adding something like\\n\\n         {\\\"g\\\":{\\\"some game\\\":\\n\\n       at the front and }} at the end, it could lead to attacks actually\\n       injecting move data for another game into what is, in the end,\\n       a fully valid JSON move.\\n\\n       The main thing we need to do for this is ensure that the outermost\\n       {} brackets of the JSON object are properly matched; the value should\\n       begin with { and end with }, and while processing the string, there\\n       should always be at least one level of {} brackets open.  Other brackets\\n       (i.e. []) are not relevant, because if they are mismatched, it will\\n       ensure the final JSON value is certainly invalid.\\n\\n       In addition to that, we need to track string literals well enough to\\n       ignore any brackets inside of them.  For this, we need to keep track\\n       of whether or not a string literal is open, and also properly handle\\n       \\\\\\\" (do not close it) and \\\\\\\\ (if followed by \\\", it closes the string).\\n\\n       Any other validation or processing is not necessary.  We also don't have\\n       to deal with UTF-8 characters in any case (those can be part of\\n       string literals), as those are cannot interfere with the basic\\n       control syntax in JSON (which is ASCII).  Any invalid UTF-8 will just\\n       result in invalid UTF-8 (and thus, and invalid value) in the end.  */\\n\\n    bytes memory data = bytes (str);\\n\\n    /* The very first character should be the opening {.  */\\n    if (data.length < 1 || data[0] != '{')\\n      return false;\\n\\n    int depth = 1;\\n    bool openString = false;\\n    bool afterBackslash = false;\\n\\n    for (uint i = 1; i < data.length; ++i)\\n      {\\n        /* While we have more to process, we should never leave the\\n           outermost layer of brackets.  This is checked when processing\\n           the closing bracket, but just double-check it here.  */\\n        assert (depth > 0);\\n\\n        /* Check if we are inside a string literal.  If we are, we need to\\n           look for its closing \\\", and handle backslash escapes.  */\\n        if (openString)\\n          {\\n            if (afterBackslash)\\n              {\\n                /* We don't have to care whatever comes after an escape.\\n                   The thing that matters is that it is not a closing \\\".  */\\n                afterBackslash = false;\\n                continue;\\n              }\\n\\n            if (data[i] == '\\\"')\\n              openString = false;\\n            else if (data[i] == '\\\\\\\\')\\n              afterBackslash = true;\\n\\n            continue;\\n          }\\n\\n        /* We are not inside a string literal, so track brackets and\\n           watch for opening of strings.  */\\n\\n        assert (!afterBackslash);\\n\\n        if (data[i] == '\\\"')\\n          openString = true;\\n        else if (data[i] == '{')\\n          ++depth;\\n        else if (data[i] == '}')\\n          {\\n            --depth;\\n            assert (depth >= 0);\\n            /* We should always have a depth larger than zero, except for\\n               the very last character which will be the final closing } that\\n               leads to depth zero.  */\\n            if (depth == 0 && i + 1 != data.length)\\n              return false;\\n          }\\n      }\\n\\n    /* At the end, all brackets should indeed be closed.  */\\n    return (depth == 0);\\n  }\\n\\n  /**\\n   * @dev Checks if a string is safe as \\\"string literal\\\".  This means that\\n   * if quotes are added around it but nothing else is done, it is sure to\\n   * be a valid string literal.\\n   */\\n  function isSafeKey (string memory str) private pure returns (bool)\\n  {\\n    /* This method is used to check that the keys in a path are safe,\\n       in a quick and simple way.  We simply check that the string does\\n       not contain any \\\\ or \\\" characters, which is enough to guarantee\\n       that enclosing in quotes will safely yield a valid string literal.\\n\\n       This prevents some strings from ever being possible to create,\\n       but since those are meant for object keys anyway, the main use will\\n       be stuff like all-lower-case ASCII names.  */\\n\\n    bytes memory data = bytes (str);\\n\\n    for (uint i = 0; i < data.length; ++i)\\n      if (data[i] == '\\\"' || data[i] == '\\\\\\\\')\\n        return false;\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Builds up a string representing a JSON object where the user-supplied\\n   * sub-object is present at the given \\\"path\\\" within the full object.\\n   * Elements of \\\"path\\\" are supposed to be simple field names that don't\\n   * need escaping inside a JSON string literal.\\n   *\\n   * If the user-supplied string is indeed a valid JSON object, then this\\n   * method returns valid JSON as well (for the full object).  If the\\n   * subobject string is not a valid JSON object, then this method may\\n   * either revert or return a string that is invalid JSON (but it is guaranteed\\n   * to not return successfully a string that is valid).\\n   */\\n  function atPath (string[] memory path, string memory subObject)\\n      internal pure returns (string memory res)\\n  {\\n    require (isSafe (subObject), \\\"possible JSON injection attempt\\\");\\n\\n    res = subObject;\\n    for (int i = int (path.length) - 1; i >= 0; --i)\\n      {\\n        string memory key = path[uint (i)];\\n        require (isSafeKey (key), \\\"invalid path key\\\");\\n        res = string (abi.encodePacked (\\\"{\\\\\\\"\\\", key, \\\"\\\\\\\":\\\", res, \\\"}\\\"));\\n      }\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/eth-account-registry/contracts/Utf8.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2021-2022 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev A Solidity library for validating UTF-8 from strings / bytes.\\n * This is based on the definition of UTF-8 in RFC 3629.\\n */\\nlibrary Utf8\\n{\\n\\n  /**\\n   * @dev Decodes the next codepoint from a byte array of UTF-8 encoded\\n   * data.  The input is expected in the byte(s) following the offset\\n   * into the array, and the return value is the decoded codepoint as well\\n   * as the offset of the following bytes (if any).  If the input bytes\\n   * are invalid, this method throws.\\n   */\\n  function decodeCodepoint (bytes memory data, uint offset)\\n      internal pure returns (uint32 cp, uint newOffset)\\n  {\\n    require (offset < data.length, \\\"no more input bytes available\\\");\\n\\n    uint8 cur = uint8 (data[offset]);\\n\\n    /* Special case for ASCII characters.  */\\n    if (cur < 0x80)\\n      return (cur, offset + 1);\\n\\n    if (cur < 0xC0)\\n      revert (\\\"mid-sequence character at start of sequence\\\");\\n\\n    /* Process the sequence-start character.  */\\n    uint8 numBytes;\\n    uint8 state;\\n    if (cur < 0xE0)\\n      {\\n        numBytes = 2;\\n        cp = uint32 (cur & 0x1F) << 6;\\n        state = 6;\\n      }\\n    else if (cur < 0xF0)\\n      {\\n        numBytes = 3;\\n        cp = uint32 (cur & 0x0F) << 12;\\n        state = 12;\\n      }\\n    else if (cur < 0xF8)\\n      {\\n        numBytes = 4;\\n        cp = uint32 (cur & 0x07) << 18;\\n        state = 18;\\n      }\\n    else\\n      revert (\\\"invalid sequence start byte\\\");\\n    newOffset = offset + 1;\\n\\n    /* Process the following bytes of this sequence.  */\\n    while (state > 0)\\n      {\\n        require (newOffset < data.length, \\\"eof in the middle of a sequence\\\");\\n\\n        cur = uint8 (data[newOffset]);\\n        newOffset += 1;\\n\\n        require (cur & 0xC0 == 0x80, \\\"expected sequence continuation\\\");\\n\\n        state -= 6;\\n        cp |= uint32 (cur & 0x3F) << state;\\n      }\\n\\n    /* Verify that the character we decoded matches the number of bytes\\n       we had, to prevent overlong sequences.  */\\n    if (numBytes == 2)\\n      require (cp >= 0x80 && cp < 0x800, \\\"overlong sequence\\\");\\n    else if (numBytes == 3)\\n      require (cp >= 0x800 && cp < 0x10000, \\\"overlong sequence\\\");\\n    else\\n      {\\n        assert (numBytes == 4);\\n        require (cp >= 0x10000 && cp < 0x110000, \\\"overlong sequence\\\");\\n      }\\n\\n    /* Prevent characters reserved for UTF-16 surrogate pairs.  */\\n    require (cp < 0xD800 || cp > 0xDFFF, \\\"surrogate-pair character decoded\\\");\\n  }\\n\\n  /**\\n   * @dev Validates that the given sequence of bytes is valid UTF-8\\n   * as per the definition in RFC 3629.  Throws if not.\\n   */\\n  function validate (bytes memory data) internal pure\\n  {\\n    uint offset = 0;\\n    while (offset < data.length)\\n      (, offset) = decodeCodepoint (data, offset);\\n    assert (offset == data.length);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/eth-account-registry/contracts/StringBuilder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2021 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Utility library for building up strings in Solidity bit-by-bit,\\n * without the need to re-allocate the string for each bit.\\n */\\nlibrary StringBuilder\\n{\\n\\n  /**\\n   * @dev A string being built.  This is just a bytes array of a given\\n   * allocated size, and the current length (which might be smaller than\\n   * the allocated size).\\n   */\\n  struct Type\\n  {\\n\\n    /**\\n     * @dev The allocated data array.  The size (stored in the first slot)\\n     * is set to the actual (current) length, rather than the allocated one.\\n     */\\n    bytes data;\\n\\n    /** @dev The maximum / allocated size of the data array.  */\\n    uint maxLen;\\n\\n  }\\n\\n  /**\\n   * @dev Constructs a new builder that is empty initially but has space\\n   * for the given number of bytes.\\n   */\\n  function create (uint maxLen) internal pure returns (Type memory res)\\n  {\\n    bytes memory data = new bytes (maxLen);\\n\\n    assembly {\\n      mstore (data, 0)\\n    }\\n\\n    res.data = data;\\n    res.maxLen = maxLen;\\n  }\\n\\n  /**\\n   * @dev Extracts the current data from a builder instance as string.\\n   */\\n  function extract (Type memory b) internal pure returns (string memory)\\n  {\\n    return string (b.data);\\n  }\\n\\n  /**\\n   * @dev Adds the given string to the content of the builder.  This must\\n   * not exceed the allocated maximum size.\\n   */\\n  function append (Type memory b, string memory str) internal pure\\n  {\\n    bytes memory buf = b.data;\\n    bytes memory added = bytes (str);\\n\\n    uint256 oldLen = buf.length;\\n    uint256 newLen = oldLen + added.length;\\n    require (newLen <= b.maxLen, \\\"StringBuilder maxLen exceeded\\\");\\n    assembly {\\n      mstore (buf, newLen)\\n    }\\n\\n    for (uint i = 0; i < added.length; ++i)\\n      buf[i + oldLen] = added[i];\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/eth-account-registry/contracts/IXayaPolicy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2021-2022 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface for a contract that defines the validation and fee\\n * policy for Xaya accounts, as well as the NFT metadata returned for\\n * a particular name.  This contract is the \\\"part\\\" of the Xaya account\\n * registry that can be configured by the owner.\\n *\\n * All fees are denominated in WCHI tokens, this is not configurable\\n * by the policy (but instead coded into the non-upgradable parts\\n * of the account registry).\\n */\\ninterface IXayaPolicy\\n{\\n\\n  /**\\n   * @dev Returns the address to which fees should be paid.\\n   */\\n  function feeReceiver () external returns (address);\\n\\n  /**\\n   * @dev Verifies if the given namespace/name combination is valid; if it\\n   * is not, the function throws.  If it is valid, the fee that should be\\n   * charged is returned.\\n   */\\n  function checkRegistration (string memory ns, string memory name)\\n      external returns (uint256);\\n\\n  /**\\n   * @dev Verifies if the given value is valid as a move for the given\\n   * namespace.  If it is not, the function throws.  If it is, the fee that\\n   * should be charged is returned.\\n   *\\n   * Note that the function does not know the exact name.  This ensures that\\n   * the policy cannot be abused to censor specific names (and the associated\\n   * game assets) after they have already been accepted for registration.\\n   */\\n  function checkMove (string memory ns, string memory mv)\\n      external returns (uint256);\\n\\n  /**\\n   * @dev Constructs the full metadata URI for a given name.\\n   */\\n  function tokenUriForName (string memory ns, string memory name)\\n      external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the contract-level metadata for OpenSea.\\n   */\\n  function contractUri () external view returns (string memory);\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/eth-account-registry/contracts/IXayaAccounts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2021-2022 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IXayaPolicy.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/**\\n * @dev Interface for the Xaya account registry contract.  This is the base\\n * component of Xaya on any EVM chain, which keeps tracks of user accounts\\n * and their moves.\\n */\\ninterface IXayaAccounts is IERC721\\n{\\n\\n  /**\\n   * @dev Returns the address of the WCHI token used for payments\\n   * of fees and in moves.\\n   */\\n  function wchiToken () external returns (IERC20);\\n\\n  /**\\n   * @dev Returns the address of the policy contract used.\\n   */\\n  function policy () external returns (IXayaPolicy);\\n\\n  /**\\n   * @dev Returns the next nonce that should be used for a move with\\n   * the given token ID.  Nonces start at zero and count up for every move\\n   * sent.\\n   */\\n  function nextNonce (uint256 tokenId) external returns (uint256);\\n\\n  /**\\n   * @dev Returns the unique token ID that corresponds to a given namespace\\n   * and name combination.  The token ID is determined deterministically from\\n   * namespace and name, so it does not matter if the account has been\\n   * registered already or not.\\n   */\\n  function tokenIdForName (string memory ns, string memory name)\\n      external pure returns (uint256);\\n\\n  /**\\n   * @dev Returns the namespace and name for a token ID, which must exist.\\n   */\\n  function tokenIdToName (uint256)\\n      external view returns (string memory, string memory);\\n\\n  /**\\n   * @dev Returns true if the given namespace/name combination exists.\\n   */\\n  function exists (string memory ns, string memory name)\\n      external view returns (bool);\\n\\n  /**\\n   * @dev Returns true if the given token ID exists.\\n   */\\n  function exists (uint256 tokenId) external view returns (bool);\\n\\n  /**\\n   * @dev Registers a new name.  The newly minted account NFT will be owned\\n   * by the caller.  Returns the token ID of the new account.\\n   */\\n  function register (string memory ns, string memory name)\\n      external returns (uint256);\\n\\n  /**\\n   * @dev Sends a move with a given name, optionally attaching a WCHI payment\\n   * to the given receiver.  For no payment, amount and receiver should be\\n   * set to zero.\\n   *\\n   * If a nonce other than uint256.max is passed, then the move is valid\\n   * only if it matches exactly the account's next nonce.  The nonce used\\n   * is returned.\\n   */\\n  function move (string memory ns, string memory name, string memory mv,\\n                 uint256 nonce, uint256 amount, address receiver)\\n      external returns (uint256);\\n\\n  /**\\n   * @dev Computes and returns the message to be signed for permitOperator.\\n   */\\n  function permitOperatorMessage (address operator)\\n      external view returns (bytes memory);\\n\\n  /**\\n   * @dev Gives approval as per setApprovalForAll to an operator via a signed\\n   * permit message.  The owner to whose names permission is given is recovered\\n   * from the signature and returned.\\n   */\\n  function permitOperator (address operator, bytes memory signature)\\n      external returns (address);\\n\\n  /**\\n   * @dev Emitted when a name is registered.\\n   */\\n  event Registration (string ns, string name, uint256 indexed tokenId,\\n                      address owner);\\n\\n  /**\\n   * @dev Emitted when a move is sent.  If no payment is attached,\\n   * then the amount and address are zero.\\n   */\\n  event Move (string ns, string name, string mv,\\n              uint256 indexed tokenId,\\n              uint256 nonce, address mover,\\n              uint256 amount, address receiver);\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/eth-account-registry/contracts/HexEscapes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2021 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./StringBuilder.sol\\\";\\n\\n/**\\n * @dev A Solidity library for escaping UTF-8 characters into\\n * hex sequences, e.g. for JSON string literals.\\n */\\nlibrary HexEscapes\\n{\\n\\n  /** @dev Hex characters used.  */\\n  bytes internal constant HEX = bytes (\\\"0123456789ABCDEF\\\");\\n\\n  /**\\n   * @dev Converts a single uint16 number into a \\\\uXXXX JSON escape\\n   * string.  This does not do any UTF-16 surrogate pair conversion.\\n   */\\n  function jsonUint16 (uint16 val) private pure returns (string memory)\\n  {\\n    bytes memory res = bytes (\\\"\\\\\\\\uXXXX\\\");\\n\\n    for (uint i = 0; i < 4; ++i)\\n      {\\n        res[5 - i] = HEX[val & 0xF];\\n        val >>= 4;\\n      }\\n\\n    return string (res);\\n  }\\n\\n  /**\\n   * @dev Converts a given Unicode codepoint into a corresponding\\n   * escape sequence inside a JSON literal.  This takes care of encoding\\n   * it into either one or two \\\\uXXXX sequences based on UTF-16.\\n   */\\n  function jsonCodepoint (uint32 val) internal pure returns (string memory)\\n  {\\n    if (val < 0xD800 || (val >= 0xE000 && val < 0x10000))\\n      return jsonUint16 (uint16 (val));\\n\\n    require (val >= 0x10000 && val < 0x110000, \\\"invalid codepoint\\\");\\n\\n    val -= 0x10000;\\n    return string (abi.encodePacked (\\n      jsonUint16 (0xD800 | uint16 (val >> 10)),\\n      jsonUint16 (0xDC00 | uint16 (val & 0x3FF))\\n    ));\\n  }\\n\\n  /**\\n   * @dev Converts a given Unicode codepoint into an XML escape sequence.\\n   */\\n  function xmlCodepoint (uint32 val) internal pure returns (string memory)\\n  {\\n    bytes memory res = bytes (\\\"&#x000000;\\\");\\n\\n    for (uint i = 0; val > 0; ++i)\\n      {\\n        require (i < 6, \\\"codepoint does not fit into 24 bits\\\");\\n\\n        res[8 - i] = HEX[val & 0xF];\\n        val >>= 4;\\n      }\\n\\n    return string (res);\\n  }\\n\\n  /**\\n   * @dev Converts a binary string into all-hex characters.\\n   */\\n  function hexlify (string memory str) internal pure returns (string memory)\\n  {\\n    bytes memory data = bytes (str);\\n    StringBuilder.Type memory builder = StringBuilder.create (2 * data.length);\\n\\n    for (uint i = 0; i < data.length; ++i)\\n      {\\n        bytes memory cur = bytes (\\\"xx\\\");\\n\\n        uint8 val = uint8 (data[i]);\\n        cur[1] = HEX[val & 0xF];\\n        val >>= 4;\\n        cur[0] = HEX[val & 0xF];\\n\\n        StringBuilder.append (builder, string (cur));\\n      }\\n\\n    return StringBuilder.extract (builder);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@xaya/democrit-evm/contracts/JsonUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2023 Autonomous Worlds Ltd\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@xaya/eth-account-registry/contracts/HexEscapes.sol\\\";\\nimport \\\"@xaya/eth-account-registry/contracts/Utf8.sol\\\";\\n\\n/**\\n * @dev A basic utility library for dealing with JSON (which we need for\\n * handling moves).  In particular, it supports escaping user-provided\\n * account names into JSON literals, so we can use them in moves to send\\n * assets to those accounts.\\n */\\nlibrary JsonUtils\\n{\\n\\n  /**\\n   * @dev Escapes a raw string into a JSON literal representing the same\\n   * string (including the surrounding quotes).  If the provided string is\\n   * invalid UTF-8, then this method will revert.\\n   */\\n  function escapeString (string memory input)\\n      internal pure returns (string memory)\\n  {\\n    bytes memory data = bytes (input);\\n\\n    /* ASCII characters get translated literally (i.e. just copied over).\\n       We escape \\\" and \\\\ by placing a backslash before them, and change\\n       control characters as well as non-ASCII Unicode codepoints to \\\\uXXXX.\\n       So worst case, if all are Unicode codepoints that need a\\n       UTF-16 surrogate pair, we 12x the length of the data, plus\\n       two quotes.  */\\n    bytes memory out = new bytes (2 + 12 * data.length);\\n\\n    uint len = 0;\\n    out[len++] = '\\\"';\\n\\n    /* Note that one could in theory ignore the UTF-8 parsing here, and just\\n       literally copy over bytes 0x80 and above.  This would also produce a\\n       valid JSON result (or invalid JSON if the input is invalid), but it\\n       fails the XayaPolicy move validation, which requires all non-ASCII\\n       characters to be escaped in moves.  */\\n\\n    uint offset = 0;\\n    while (offset < data.length)\\n      {\\n        uint32 cp;\\n        (cp, offset) = Utf8.decodeCodepoint (data, offset);\\n        if (cp == 0x22 || cp == 0x5C)\\n          {\\n            out[len++] = '\\\\\\\\';\\n            out[len++] = bytes1 (uint8 (cp));\\n          }\\n        else if (cp >= 0x20 && cp < 0x7F)\\n          out[len++] = bytes1 (uint8 (cp));\\n        else\\n          {\\n            bytes memory escape = bytes (HexEscapes.jsonCodepoint (cp));\\n            for (uint i = 0; i < escape.length; ++i)\\n              out[len++] = escape[i];\\n          }\\n      }\\n    assert (offset == data.length);\\n\\n    out[len++] = '\\\"';\\n\\n    assembly {\\n      mstore (out, len)\\n    }\\n\\n    return string (out);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/metatx/ERC2771Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\nabstract contract ERC2771Context is Context {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable _trustedForwarder;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address trustedForwarder) {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual override returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return super._msgSender();\\n        }\\n    }\\n\\n    function _msgData() internal view virtual override returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return super._msgData();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"contract ClubMinter\",\"name\":\"m\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fwd\",\"type\":\"address\"},{\"internalType\":\"contract IWETH\",\"name\":\"w\",\"type\":\"address\"},{\"internalType\":\"contract SwapProvider\",\"name\":\"s\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"clubId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"}],\"name\":\"ClubAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"clubId\",\"type\":\"uint256\"}],\"name\":\"ClubRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesPerClub\",\"type\":\"uint256\"}],\"name\":\"CountryConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"receiver\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numPacks\",\"type\":\"uint256\"}],\"name\":\"PacksBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"clubId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"}],\"name\":\"addClub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"clubIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"}],\"name\":\"addClubs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"clubs\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"pc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"configureCountry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"countries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"packCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesPerClub\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"}],\"name\":\"getClubsForCountry\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"}],\"name\":\"getMaxPacks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"receiver\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"receiver\",\"type\":\"string\"},{\"internalType\":\"contract IERC20\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"name\":\"mintWithSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"contract ClubMinter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"country\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"name\":\"quoteMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"clubId\",\"type\":\"uint256\"}],\"name\":\"removeClub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapper\",\"outputs\":[{\"internalType\":\"contract SwapProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SwappingPackSale", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "0000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000030ff48a6c041c428d4e683f713df73d7617da96400000000000000000000000069015912aa33720b842dcd6ac059ed623f28d9f70000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270000000000000000000000000852edaa496c8065dcc77470646a62740380279be", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}