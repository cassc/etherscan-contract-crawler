{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AddLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./owner/Operator.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Router.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\ncontract AddLiquidity is Operator {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public uniRouter = address(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin, to);\\n    }\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return _addLiquidityETH(token, amountTokenDesired, amountTokenMin, amountETHMin, to);\\n    }\\n\\n\\n\\n\\n\\n\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        _token.safeTransfer(_to, _amount);\\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n    function _addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to\\n    ) \\n    private\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        require(amountTokenDesired != 0 && msg.value != 0, \\\"amounts can't be 0\\\");\\n\\n        IERC20(token).transferFrom(msg.sender, address(this), amountTokenDesired);\\n        _approveTokenIfNeeded(token, uniRouter);\\n\\n        uint256 resultAmtToken;\\n        uint256 resultAmtEth;\\n        uint256 liquidity;\\n        (resultAmtToken, resultAmtEth, liquidity) = IUniswapV2Router(uniRouter).addLiquidityETH{value: msg.value}(\\n            token,\\n            amountTokenDesired,\\n            amountTokenMin,\\n            amountETHMin,\\n            to,\\n            block.timestamp\\n        );\\n\\n        if (amountTokenDesired.sub(resultAmtToken) > 0) {\\n            IERC20(token).transfer(to, amountTokenDesired.sub(resultAmtToken));\\n        }\\n        return (resultAmtToken, resultAmtEth, liquidity);\\n    }\\n\\n\\n\\n\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to\\n    )\\n        private\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        require(amountADesired != 0 && amountBDesired != 0, \\\"amounts can't be 0\\\");\\n\\n        IERC20(tokenA).transferFrom(msg.sender, address(this), amountADesired);\\n        IERC20(tokenB).transferFrom(msg.sender, address(this), amountBDesired);\\n        _approveTokenIfNeeded(tokenA, uniRouter);\\n        _approveTokenIfNeeded(tokenB, uniRouter);\\n\\n        uint256 resultAmtA;\\n        uint256 resultAmtB;\\n        uint256 liquidity;\\n        (resultAmtA, resultAmtB, liquidity) = IUniswapV2Router(uniRouter).addLiquidity(\\n            tokenA,\\n            tokenB,\\n            amountADesired,\\n            amountBDesired,\\n            amountAMin,\\n            amountBMin,\\n            to,\\n            block.timestamp\\n        );\\n\\n        if (amountADesired.sub(resultAmtA) > 0) {\\n            IERC20(tokenA).transfer(to, amountADesired.sub(resultAmtA));\\n        }\\n        if (amountBDesired.sub(resultAmtB) > 0) {\\n            IERC20(tokenB).transfer(to, amountBDesired.sub(resultAmtB));\\n        }\\n        return (resultAmtA, resultAmtB, liquidity);\\n    }\\n\\n    function _approveTokenIfNeeded(address _token, address _router) private {\\n        if (IERC20(_token).allowance(address(this), _router) == 0) {\\n            IERC20(_token).approve(_router, type(uint256).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/owner/Operator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Operator is Context, Ownable {\\n    address private _operator;\\n\\n    event OperatorTransferred(address indexed previousOperator, address indexed newOperator);\\n\\n    constructor() internal {\\n        _operator = _msgSender();\\n        emit OperatorTransferred(address(0), _operator);\\n    }\\n\\n    function operator() public view returns (address) {\\n        return _operator;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(_operator == msg.sender, \\\"operator: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    function isOperator() public view returns (bool) {\\n        return _msgSender() == _operator;\\n    }\\n\\n    function transferOperator(address newOperator_) public onlyOwner {\\n        _transferOperator(newOperator_);\\n    }\\n\\n    function _transferOperator(address newOperator_) internal {\\n        require(newOperator_ != address(0), \\\"operator: zero address given for new operator\\\");\\n        emit OperatorTransferred(address(0), newOperator_);\\n        _operator = newOperator_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IUniswapV2Router {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable\\n    returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Treasury/TreasuryPMATIC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../lib/Babylonian.sol\\\";\\nimport \\\"../owner/Operator.sol\\\";\\nimport \\\"../utils/ContractGuard.sol\\\";\\nimport \\\"../interfaces/IBasisAsset.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\nimport \\\"../interfaces/IBoardroom.sol\\\";\\nimport \\\"../interfaces/IRegulationStats.sol\\\";\\n\\n/*\\n\\n$$$$$$$\\\\   $$$$$$\\\\  $$\\\\      $$\\\\ $$$$$$$\\\\                                                            \\n$$  __$$\\\\ $$  __$$\\\\ $$$\\\\    $$$ |$$  __$$\\\\                                                           \\n$$ |  $$ |$$ /  $$ |$$$$\\\\  $$$$ |$$ |  $$ |    $$$$$$\\\\$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\  $$\\\\   $$\\\\ \\n$$$$$$$\\\\ |$$ |  $$ |$$\\\\$$\\\\$$ $$ |$$$$$$$\\\\ |    $$  _$$  _$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$ |  $$ |\\n$$  __$$\\\\ $$ |  $$ |$$ \\\\$$$  $$ |$$  __$$\\\\     $$ / $$ / $$ |$$ /  $$ |$$ |  $$ |$$$$$$$$ |$$ |  $$ |\\n$$ |  $$ |$$ |  $$ |$$ |\\\\$  /$$ |$$ |  $$ |    $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\\n$$$$$$$  | $$$$$$  |$$ | \\\\_/ $$ |$$$$$$$  |$$\\\\ $$ | $$ | $$ |\\\\$$$$$$  |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |\\n\\\\_______/  \\\\______/ \\\\__|     \\\\__|\\\\_______/ \\\\__|\\\\__| \\\\__| \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______| \\\\____$$ |\\n                                                                                           $$\\\\   $$ |\\n                                                                                           \\\\$$$$$$  |\\n    http://bomb.money                                                                      \\\\______/ \\n*/\\ncontract TreasuryPMATIC is ContractGuard, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    /* ========= CONSTANT VARIABLES ======== */\\n\\n    uint256 public constant PERIOD = 8 hours;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // governance\\n    address public operator;\\n\\n    // flags\\n    bool public initialized = false;\\n\\n    // epoch\\n    uint256 public startTime;\\n    uint256 public epoch = 0;\\n    uint256 public epochSupplyContractionLeft = 0;\\n\\n    // exclusions from total supply\\n    address[] public excludedFromTotalSupply = [\\n        address(0xf8F65bFD45996b2e7b43adDd2243C83db2D6c24f) // TokenGenesisPool\\n    ];\\n\\n    // core components\\n    address public token;\\n    address public bond;\\n    address public share;\\n\\n    address public boardroom;\\n    address public tokenOracle;\\n\\n    uint256 public boardroomWithdrawFee;\\n    uint256 public boardroomStakeFee;\\n    // price\\n    uint256 public tokenPriceOne;\\n    uint256 public tokenPriceCeiling;\\n\\n    uint256 public seigniorageSaved;\\n\\n    uint256[] public supplyTiers;\\n    uint256[] public maxExpansionTiers;\\n\\n    uint256 public maxSupplyExpansionPercent;\\n    uint256 public bondDepletionFloorPercent;\\n    uint256 public seigniorageExpansionFloorPercent;\\n    uint256 public maxSupplyContractionPercent;\\n    uint256 public maxDebtRatioPercent;\\n\\n    // 28 first epochs (1 week) with 4.5% expansion regardless of BOMB price\\n    uint256 public bootstrapEpochs;\\n    uint256 public bootstrapSupplyExpansionPercent;\\n\\n    /* =================== Added variables =================== */\\n    uint256 public previousEpochTokenPrice;\\n    uint256 public maxDiscountRate; // when purchasing bond\\n    uint256 public maxPremiumRate; // when redeeming bond\\n    uint256 public discountPercent;\\n    uint256 public premiumThreshold;\\n    uint256 public premiumPercent;\\n    uint256 public mintingFactorForPayingDebt; // print extra BOMB during debt phase\\n\\n    // 45% for Stakers in boardroom (THIS)\\n    // 45% for DAO fund\\n    // 2% for DEV fund\\n    // 8% for INSURANCE fund\\n    address public daoFund;\\n    uint256 public daoFundSharedPercent;\\n\\n    address public devFund;\\n    uint256 public devFundSharedPercent;\\n\\n    address public insuranceFund;\\n    uint256 public insuranceFundSharedPercent;\\n\\n    address public regulationStats;\\n\\n    /* =================== Events =================== */\\n\\n    event Initialized(address indexed executor, uint256 at);\\n    event BurnedBonds(address indexed from, uint256 bondAmount);\\n    event RedeemedBonds(address indexed from, uint256 tokenAmount, uint256 bondAmount);\\n    event BoughtBonds(address indexed from, uint256 tokenAmount, uint256 bondAmount);\\n    event TreasuryFunded(uint256 timestamp, uint256 seigniorage);\\n    event BoardroomFunded(uint256 timestamp, uint256 seigniorage);\\n    event DaoFundFunded(uint256 timestamp, uint256 seigniorage);\\n    event DevFundFunded(uint256 timestamp, uint256 seigniorage);\\n    event InsuranceFundFunded(uint256 timestamp, uint256 seigniorage);\\n    event Seigniorage(uint256 epoch, uint256 twap, uint256 expansion);\\n\\n    /* =================== Modifier =================== */\\n\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"Treasury: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    modifier checkCondition() {\\n        require(now >= startTime, \\\"Treasury: not started yet\\\");\\n\\n        _;\\n    }\\n\\n    modifier checkEpoch() {\\n        require(now >= nextEpochPoint(), \\\"Treasury: not opened yet\\\");\\n\\n        _;\\n\\n        epoch = epoch.add(1);\\n        epochSupplyContractionLeft = (getTokenPrice() > tokenPriceCeiling) ? 0 : getTokenCirculatingSupply().mul(maxSupplyContractionPercent).div(10000);\\n    }\\n\\n    modifier checkOperator() {\\n        require(\\n            IBasisAsset(token).operator() == address(this) &&\\n                IBasisAsset(bond).operator() == address(this) &&\\n                //   IBasisAsset(share).operator() == address(this) &&\\n                Operator(boardroom).operator() == address(this),\\n            \\\"Treasury: need more permission\\\"\\n        );\\n\\n        _;\\n    }\\n\\n    modifier notInitialized() {\\n        require(!initialized, \\\"Treasury: already initialized\\\");\\n\\n        _;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function isInitialized() public view returns (bool) {\\n        return initialized;\\n    }\\n\\n    // epoch\\n    function nextEpochPoint() public view returns (uint256) {\\n        return startTime.add(epoch.mul(PERIOD));\\n    }\\n\\n    // oracle\\n    function getTokenPrice() public view returns (uint256 tokenPrice) {\\n        try IOracle(tokenOracle).consult(token, 1e18) returns (uint144 price) {\\n            return uint256(price);\\n        } catch {\\n            revert(\\\"Treasury: failed to consult BOMB price from the oracle\\\");\\n        }\\n    }\\n\\n    function getTokenUpdatedPrice() public view returns (uint256 _tokenPrice) {\\n        try IOracle(tokenOracle).twap(token, 1e18) returns (uint144 price) {\\n            return uint256(price);\\n        } catch {\\n            revert(\\\"Treasury: failed to consult BOMB price from the oracle\\\");\\n        }\\n    }\\n\\n    // budget\\n    function getReserve() public view returns (uint256) {\\n        return seigniorageSaved;\\n    }\\n\\n    function getBurnableTokenLeft() public view returns (uint256 _burnableTokenLeft) {\\n        uint256 _tokenPrice = getTokenPrice();\\n        if (_tokenPrice <= tokenPriceOne) {\\n            uint256 _tokenSupply = getTokenCirculatingSupply();\\n            uint256 _bondMaxSupply = _tokenSupply.mul(maxDebtRatioPercent).div(10000);\\n            uint256 _bondSupply = IERC20(bond).totalSupply();\\n            if (_bondMaxSupply > _bondSupply) {\\n                uint256 _maxMintableBond = _bondMaxSupply.sub(_bondSupply);\\n                uint256 _maxBurnableToken = _maxMintableBond.mul(_tokenPrice).div(1e18);\\n                _burnableTokenLeft = Math.min(epochSupplyContractionLeft, _maxBurnableToken);\\n            }\\n        }\\n    }\\n\\n    function getRedeemableBonds() public view returns (uint256 _redeemableBonds) {\\n        uint256 _tokenPrice = getTokenPrice();\\n        if (_tokenPrice > tokenPriceCeiling) {\\n            uint256 _totalToken = IERC20(token).balanceOf(address(this));\\n            uint256 _rate = getBondPremiumRate();\\n            if (_rate > 0) {\\n                _redeemableBonds = _totalToken.mul(1e18).div(_rate);\\n            }\\n        }\\n    }\\n\\n    function getBondDiscountRate() public view returns (uint256 _rate) {\\n        uint256 _tokenPrice = getTokenPrice();\\n        if (_tokenPrice <= tokenPriceOne) {\\n            if (discountPercent == 0) {\\n                // no discount\\n                _rate = tokenPriceOne;\\n            } else {\\n                uint256 _bondAmount = tokenPriceOne.mul(1e18).div(_tokenPrice); // to burn 1 BOMB\\n                uint256 _discountAmount = _bondAmount.sub(tokenPriceOne).mul(discountPercent).div(10000);\\n                _rate = tokenPriceOne.add(_discountAmount);\\n                if (maxDiscountRate > 0 && _rate > maxDiscountRate) {\\n                    _rate = maxDiscountRate;\\n                }\\n            }\\n        }\\n    }\\n\\n    function getBondPremiumRate() public view returns (uint256 _rate) {\\n        uint256 _tokenPrice = getTokenPrice();\\n        if (_tokenPrice > tokenPriceCeiling) {\\n            uint256 _tokenPricePremiumThreshold = tokenPriceOne.mul(premiumThreshold).div(100);\\n            if (_tokenPrice >= _tokenPricePremiumThreshold) {\\n                //Price > 1.10\\n                uint256 _premiumAmount = _tokenPrice.sub(tokenPriceOne).mul(premiumPercent).div(10000);\\n                _rate = tokenPriceOne.add(_premiumAmount);\\n                if (maxPremiumRate > 0 && _rate > maxPremiumRate) {\\n                    _rate = maxPremiumRate;\\n                }\\n            } else {\\n                // no premium bonus\\n                _rate = tokenPriceOne;\\n            }\\n        }\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function initialize(\\n        address _token,\\n        address _bond,\\n        address _share,\\n        address _tokenOracle,\\n        address _boardroom,\\n        uint256 _startTime\\n    ) public notInitialized {\\n        token = _token;\\n        bond = _bond;\\n        share = _share;\\n        tokenOracle = _tokenOracle;\\n        boardroom = _boardroom;\\n        startTime = _startTime;\\n\\n        tokenPriceOne = 10**18; // This is to allow a PEG of 10,000 BOMB per BTC\\n        tokenPriceCeiling = tokenPriceOne.mul(1001).div(1000);\\n\\n        // Dynamic max expansion percent\\n        supplyTiers = [0 ether, 100000 ether, 250000 ether, 500000 ether, 1000000 ether, 5000000 ether];\\n        maxExpansionTiers = [150, 150, 150, 150, 150, 150];\\n\\n        maxSupplyExpansionPercent = 350; // Upto 4.5% supply for expansion\\n\\n        bondDepletionFloorPercent = 10000; // 100% of Bond supply for depletion floor\\n        seigniorageExpansionFloorPercent = 3500; // At least 35% of expansion reserved for boardroom\\n        maxSupplyContractionPercent = 300; // Upto 3.0% supply for contraction (to burn BOMB and mint tBOND)\\n        maxDebtRatioPercent = 3500; // Upto 35% supply of tBOND to purchase\\n\\n        premiumThreshold = 105;\\n        premiumPercent = 7000;\\n\\n        // First 21 epochs with 3.5% expansion\\n        bootstrapEpochs = 21;\\n        bootstrapSupplyExpansionPercent = 350;\\n\\n        // set seigniorageSaved to it's balance\\n        seigniorageSaved = IERC20(token).balanceOf(address(this));\\n\\n        initialized = true;\\n        operator = msg.sender;\\n        emit Initialized(msg.sender, block.number);\\n    }\\n\\n    function setOperator(address _operator) external onlyOperator {\\n        operator = _operator;\\n    }\\n\\n    function setBoardroom(address _boardroom) external onlyOperator {\\n        boardroom = _boardroom;\\n    }\\n\\n    function setRegulationStats(address _regulationStats) external onlyOperator {\\n        regulationStats = _regulationStats;\\n    }\\n\\n    function setBoardroomWithdrawFee(uint256 _boardroomWithdrawFee) external onlyOperator {\\n        require(_boardroomWithdrawFee <= 20, \\\"Max withdraw fee is 20%\\\");\\n        boardroomWithdrawFee = _boardroomWithdrawFee;\\n        IBoardroom(boardroom).setWithdrawFee(boardroomWithdrawFee);\\n    }\\n\\n    function setBoardroomStakeFee(uint256 _boardroomStakeFee) external onlyOperator {\\n        require(_boardroomStakeFee <= 5, \\\"Max stake fee is 5%\\\");\\n        boardroomStakeFee = _boardroomStakeFee;\\n        IBoardroom(boardroom).setStakeFee(boardroomStakeFee);\\n    }\\n\\n    function setTokenOracle(address _tokenOracle) external onlyOperator {\\n        tokenOracle = _tokenOracle;\\n    }\\n\\n    function setTokenPriceCeiling(uint256 _tokenPriceCeiling) external onlyOperator {\\n        require(_tokenPriceCeiling >= tokenPriceOne && _tokenPriceCeiling <= tokenPriceOne.mul(120).div(100), \\\"out of range\\\"); // [$1.0, $1.2]\\n        tokenPriceCeiling = _tokenPriceCeiling;\\n    }\\n\\n    function setMaxSupplyExpansionPercents(uint256 _maxSupplyExpansionPercent) external onlyOperator {\\n        require(_maxSupplyExpansionPercent >= 10 && _maxSupplyExpansionPercent <= 1000, \\\"_maxSupplyExpansionPercent: out of range\\\"); // [0.1%, 10%]\\n        maxSupplyExpansionPercent = _maxSupplyExpansionPercent;\\n    }\\n\\n    function setSupplyTiersEntry(uint8 _index, uint256 _value) external onlyOperator returns (bool) {\\n        require(_index >= 0, \\\"Index has to be higher than 0\\\");\\n        require(_index < 9, \\\"Index has to be lower than count of tiers\\\");\\n        if (_index > 0) {\\n            require(_value > supplyTiers[_index - 1]);\\n        }\\n        if (_index < 8) {\\n            require(_value < supplyTiers[_index + 1]);\\n        }\\n        supplyTiers[_index] = _value;\\n        return true;\\n    }\\n\\n    function setMaxExpansionTiersEntry(uint8 _index, uint256 _value) external onlyOperator returns (bool) {\\n        require(_index >= 0, \\\"Index has to be higher than 0\\\");\\n        require(_index < 9, \\\"Index has to be lower than count of tiers\\\");\\n        require(_value >= 10 && _value <= 1000, \\\"_value: out of range\\\"); // [0.1%, 10%]\\n        maxExpansionTiers[_index] = _value;\\n        return true;\\n    }\\n\\n    function setBondDepletionFloorPercent(uint256 _bondDepletionFloorPercent) external onlyOperator {\\n        require(_bondDepletionFloorPercent >= 500 && _bondDepletionFloorPercent <= 10000, \\\"out of range\\\"); // [5%, 100%]\\n        bondDepletionFloorPercent = _bondDepletionFloorPercent;\\n    }\\n\\n    function setMaxSupplyContractionPercent(uint256 _maxSupplyContractionPercent) external onlyOperator {\\n        require(_maxSupplyContractionPercent >= 100 && _maxSupplyContractionPercent <= 1500, \\\"out of range\\\"); // [0.1%, 15%]\\n        maxSupplyContractionPercent = _maxSupplyContractionPercent;\\n    }\\n\\n    function setMaxDebtRatioPercent(uint256 _maxDebtRatioPercent) external onlyOperator {\\n        require(_maxDebtRatioPercent >= 1000 && _maxDebtRatioPercent <= 10000, \\\"out of range\\\"); // [10%, 100%]\\n        maxDebtRatioPercent = _maxDebtRatioPercent;\\n    }\\n\\n    function setBootstrap(uint256 _bootstrapEpochs, uint256 _bootstrapSupplyExpansionPercent) external onlyOperator {\\n        require(_bootstrapEpochs <= 120, \\\"_bootstrapEpochs: out of range\\\"); // <= 1 month\\n        require(_bootstrapSupplyExpansionPercent >= 100 && _bootstrapSupplyExpansionPercent <= 1000, \\\"_bootstrapSupplyExpansionPercent: out of range\\\"); // [1%, 10%]\\n        bootstrapEpochs = _bootstrapEpochs;\\n        bootstrapSupplyExpansionPercent = _bootstrapSupplyExpansionPercent;\\n    }\\n\\n    function setExtraFunds(\\n        address _daoFund,\\n        uint256 _daoFundSharedPercent,\\n        address _devFund,\\n        uint256 _devFundSharedPercent,\\n        address _insuranceFund,\\n        uint256 _insuranceFundSharedPercent\\n    ) external onlyOperator {\\n        require(_daoFund != address(0), \\\"zero\\\");\\n        require(_daoFundSharedPercent <= 5000, \\\"out of range\\\"); // <= 50%\\n        require(_devFund != address(0), \\\"zero\\\");\\n        require(_devFundSharedPercent <= 1000, \\\"out of range\\\"); // <= 10%\\n        require(_insuranceFund != address(0), \\\"zero\\\");\\n        require(_insuranceFundSharedPercent <= 1000, \\\"out of range\\\"); // <= 10%\\n\\n        daoFund = _daoFund;\\n        daoFundSharedPercent = _daoFundSharedPercent;\\n\\n        devFund = _devFund;\\n        devFundSharedPercent = _devFundSharedPercent;\\n\\n        insuranceFund = _insuranceFund;\\n        insuranceFundSharedPercent = _insuranceFundSharedPercent;\\n    }\\n\\n    function setMaxDiscountRate(uint256 _maxDiscountRate) external onlyOperator {\\n        maxDiscountRate = _maxDiscountRate;\\n    }\\n\\n    function setMaxPremiumRate(uint256 _maxPremiumRate) external onlyOperator {\\n        maxPremiumRate = _maxPremiumRate;\\n    }\\n\\n    function setDiscountPercent(uint256 _discountPercent) external onlyOperator {\\n        require(_discountPercent <= 20000, \\\"_discountPercent is over 200%\\\");\\n        discountPercent = _discountPercent;\\n    }\\n\\n    function setPremiumThreshold(uint256 _premiumThreshold) external onlyOperator {\\n        require(_premiumThreshold <= 150, \\\"_premiumThreshold is higher than 1.5\\\");\\n        premiumThreshold = _premiumThreshold;\\n    }\\n\\n    function setPremiumPercent(uint256 _premiumPercent) external onlyOperator {\\n        require(_premiumPercent <= 20000, \\\"_premiumPercent is over 200%\\\");\\n        premiumPercent = _premiumPercent;\\n    }\\n\\n    function setMintingFactorForPayingDebt(uint256 _mintingFactorForPayingDebt) external onlyOperator {\\n        require(_mintingFactorForPayingDebt >= 10000 && _mintingFactorForPayingDebt <= 20000, \\\"_mintingFactorForPayingDebt: out of range\\\"); // [100%, 200%]\\n        mintingFactorForPayingDebt = _mintingFactorForPayingDebt;\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    function _updateTokenPrice() internal {\\n        try IOracle(tokenOracle).update() {} catch {}\\n    }\\n\\n    function getTokenCirculatingSupply() public view returns (uint256) {\\n        IERC20 tokenErc20 = IERC20(token);\\n        uint256 totalSupply = tokenErc20.totalSupply();\\n        uint256 balanceExcluded = 0;\\n        for (uint8 entryId = 0; entryId < excludedFromTotalSupply.length; ++entryId) {\\n            balanceExcluded = balanceExcluded.add(tokenErc20.balanceOf(excludedFromTotalSupply[entryId]));\\n        }\\n        return totalSupply.sub(balanceExcluded);\\n    }\\n\\n    function buyBonds(uint256 _tokenAmount, uint256 targetPrice) external onlyOneBlock checkCondition checkOperator {\\n        require(_tokenAmount > 0, \\\"Treasury: cannot purchase bonds with zero amount\\\");\\n\\n        uint256 tokenPrice = getTokenPrice();\\n        require(tokenPrice == targetPrice, \\\"Treasury: BOMB price moved\\\");\\n        require(\\n            tokenPrice < tokenPriceOne, // price < $1\\n            \\\"Treasury: tokenPrice not eligible for bond purchase\\\"\\n        );\\n\\n        require(_tokenAmount <= epochSupplyContractionLeft, \\\"Treasury: not enough bond left to purchase\\\");\\n\\n        uint256 _rate = getBondDiscountRate();\\n        require(_rate > 0, \\\"Treasury: invalid bond rate\\\");\\n\\n        uint256 _bondAmount = _tokenAmount.mul(_rate).div(1e18);\\n        uint256 tokenSupply = getTokenCirculatingSupply();\\n        uint256 newBondSupply = IERC20(bond).totalSupply().add(_bondAmount);\\n        require(newBondSupply <= tokenSupply.mul(maxDebtRatioPercent).div(10000), \\\"over max debt ratio\\\");\\n\\n        IBasisAsset(token).burnFrom(msg.sender, _tokenAmount);\\n        IBasisAsset(bond).mint(msg.sender, _bondAmount);\\n\\n        epochSupplyContractionLeft = epochSupplyContractionLeft.sub(_tokenAmount);\\n        _updateTokenPrice();\\n        if (regulationStats != address(0)) IRegulationStats(regulationStats).addBonded(epoch, _bondAmount);\\n\\n        emit BoughtBonds(msg.sender, _tokenAmount, _bondAmount);\\n    }\\n\\n    function redeemBonds(uint256 _bondAmount, uint256 targetPrice) external onlyOneBlock checkCondition checkOperator {\\n        require(_bondAmount > 0, \\\"Treasury: cannot redeem bonds with zero amount\\\");\\n\\n        uint256 tokenPrice = getTokenPrice();\\n        require(tokenPrice == targetPrice, \\\"Treasury: BOMB price moved\\\");\\n        require(\\n            tokenPrice > tokenPriceCeiling, // price > $1.01\\n            \\\"Treasury: tokenPrice not eligible for bond purchase\\\"\\n        );\\n\\n        uint256 _rate = getBondPremiumRate();\\n        require(_rate > 0, \\\"Treasury: invalid bond rate\\\");\\n\\n        uint256 _tokenAmount = _bondAmount.mul(_rate).div(1e18);\\n        require(IERC20(token).balanceOf(address(this)) >= _tokenAmount, \\\"Treasury: treasury has no more budget\\\");\\n\\n        seigniorageSaved = seigniorageSaved.sub(Math.min(seigniorageSaved, _tokenAmount));\\n\\n        IBasisAsset(bond).burnFrom(msg.sender, _bondAmount);\\n        IERC20(token).safeTransfer(msg.sender, _tokenAmount);\\n\\n        _updateTokenPrice();\\n        if (regulationStats != address(0)) IRegulationStats(regulationStats).addRedeemed(epoch, _tokenAmount);\\n\\n        emit RedeemedBonds(msg.sender, _tokenAmount, _bondAmount);\\n    }\\n\\n    function _sendToBoardroom(uint256 _amount) internal {\\n        IBasisAsset(token).mint(address(this), _amount);\\n\\n        uint256 _daoFundSharedAmount = 0;\\n        if (daoFundSharedPercent > 0) {\\n            _daoFundSharedAmount = _amount.mul(daoFundSharedPercent).div(10000);\\n            IERC20(token).transfer(daoFund, _daoFundSharedAmount);\\n            emit DaoFundFunded(now, _daoFundSharedAmount);\\n        }\\n\\n        uint256 _devFundSharedAmount = 0;\\n        if (devFundSharedPercent > 0) {\\n            _devFundSharedAmount = _amount.mul(devFundSharedPercent).div(10000);\\n            IERC20(token).transfer(devFund, _devFundSharedAmount);\\n            emit DevFundFunded(now, _devFundSharedAmount);\\n        }\\n\\n        uint256 _insuranceFundSharedAmount = 0;\\n        if (insuranceFundSharedPercent > 0) {\\n            _insuranceFundSharedAmount = _amount.mul(insuranceFundSharedPercent).div(10000);\\n            IERC20(token).transfer(insuranceFund, _insuranceFundSharedAmount);\\n            emit InsuranceFundFunded(now, _insuranceFundSharedAmount);\\n        }\\n\\n        _amount = _amount.sub(_daoFundSharedAmount).sub(_devFundSharedAmount).sub(_insuranceFundSharedAmount);\\n\\n        IERC20(token).safeApprove(boardroom, 0);\\n        IERC20(token).safeApprove(boardroom, _amount);\\n        IBoardroom(boardroom).allocateSeigniorage(_amount);\\n        if (regulationStats != address(0))\\n            IRegulationStats(regulationStats).addEpochInfo(\\n                epoch.add(1),\\n                previousEpochTokenPrice,\\n                _amount,\\n                _amount,\\n                _daoFundSharedAmount,\\n                _devFundSharedAmount,\\n                _insuranceFundSharedAmount\\n            );\\n        emit BoardroomFunded(now, _amount);\\n    }\\n\\n    function _calculateMaxSupplyExpansionPercent(uint256 _tokenSupply) internal returns (uint256) {\\n        for (uint8 tierId = 8; tierId >= 0; --tierId) {\\n            if (_tokenSupply >= supplyTiers[tierId]) {\\n                maxSupplyExpansionPercent = maxExpansionTiers[tierId];\\n                break;\\n            }\\n        }\\n        return maxSupplyExpansionPercent;\\n    }\\n\\n    function allocateSeigniorage() external onlyOneBlock checkCondition checkEpoch checkOperator {\\n        _updateTokenPrice();\\n        previousEpochTokenPrice = getTokenPrice();\\n        uint256 tokenSupply = getTokenCirculatingSupply().sub(seigniorageSaved);\\n        if (epoch < bootstrapEpochs) {\\n            // 28 first epochs with 4.5% expansion\\n            _sendToBoardroom(tokenSupply.mul(bootstrapSupplyExpansionPercent).div(10000));\\n            emit Seigniorage(epoch, previousEpochTokenPrice, tokenSupply.mul(bootstrapSupplyExpansionPercent).div(10000));\\n        } else {\\n            if (previousEpochTokenPrice > tokenPriceCeiling) {\\n                // Expansion ($BOMB Price > 1 $ETH): there is some seigniorage to be allocated\\n                uint256 bondSupply = IERC20(bond).totalSupply();\\n                uint256 _percentage = previousEpochTokenPrice.sub(tokenPriceOne);\\n                uint256 _savedForBond;\\n                uint256 _savedForBoardroom;\\n                uint256 _mse = _calculateMaxSupplyExpansionPercent(tokenSupply).mul(1e14);\\n                if (_percentage > _mse) {\\n                    _percentage = _mse;\\n                }\\n                if (seigniorageSaved >= bondSupply.mul(bondDepletionFloorPercent).div(10000)) {\\n                    // saved enough to pay debt, mint as usual rate\\n                    _savedForBoardroom = tokenSupply.mul(_percentage).div(1e18);\\n                } else {\\n                    // have not saved enough to pay debt, mint more\\n                    uint256 _seigniorage = tokenSupply.mul(_percentage).div(1e18);\\n                    _savedForBoardroom = _seigniorage.mul(seigniorageExpansionFloorPercent).div(10000);\\n                    _savedForBond = _seigniorage.sub(_savedForBoardroom);\\n                    if (mintingFactorForPayingDebt > 0) {\\n                        _savedForBond = _savedForBond.mul(mintingFactorForPayingDebt).div(10000);\\n                    }\\n                }\\n                if (_savedForBoardroom > 0) {\\n                    _sendToBoardroom(_savedForBoardroom);\\n                }\\n                if (_savedForBond > 0) {\\n                    seigniorageSaved = seigniorageSaved.add(_savedForBond);\\n                    IBasisAsset(token).mint(address(this), _savedForBond);\\n                    emit TreasuryFunded(now, _savedForBond);\\n                }\\n            }\\n        }\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        // do not allow to drain core tokens\\n        require(address(_token) != address(token), \\\"token\\\");\\n        require(address(_token) != address(bond), \\\"bond\\\");\\n        require(address(_token) != address(share), \\\"share\\\");\\n        _token.safeTransfer(_to, _amount);\\n    }\\n\\n    function boardroomSetOperator(address _operator) external onlyOperator {\\n        IBoardroom(boardroom).setOperator(_operator);\\n    }\\n\\n    function boardroomSetLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external onlyOperator {\\n        IBoardroom(boardroom).setLockUp(_withdrawLockupEpochs, _rewardLockupEpochs);\\n    }\\n\\n    function boardroomSetReserveFund(address _reserveFund) external onlyOperator {\\n        IBoardroom(boardroom).setReserveFund(_reserveFund);\\n    }\\n\\n    function boardroomAllocateSeigniorage(uint256 amount) external onlyOperator {\\n        IBoardroom(boardroom).allocateSeigniorage(amount);\\n    }\\n\\n    function boardroomSetWithdrawFeeMultiplier(uint256 _amount) external onlyOperator {\\n        IBoardroom(boardroom).setWithdrawFeeMultiplier(_amount);\\n    }\\n\\n    function boardroomGovernanceRecoverUnsupported(\\n        address _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        IBoardroom(boardroom).governanceRecoverUnsupported(_token, _amount, _to);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nlibrary Babylonian {\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n        // else z = 0\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ContractGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ncontract ContractGuard {\\n    mapping(uint256 => mapping(address => bool)) private _status;\\n\\n    function checkSameOriginReentranted() internal view returns (bool) {\\n        return _status[block.number][tx.origin];\\n    }\\n\\n    function checkSameSenderReentranted() internal view returns (bool) {\\n        return _status[block.number][msg.sender];\\n    }\\n\\n    modifier onlyOneBlock() {\\n        require(!checkSameOriginReentranted(), \\\"ContractGuard: one block, one function\\\");\\n        require(!checkSameSenderReentranted(), \\\"ContractGuard: one block, one function\\\");\\n\\n        _;\\n\\n        _status[block.number][tx.origin] = true;\\n        _status[block.number][msg.sender] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBasisAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IBasisAsset {\\n    function mint(address recipient, uint256 amount) external returns (bool);\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address from, uint256 amount) external;\\n\\n    function isOperator() external returns (bool);\\n\\n    function operator() external view returns (address);\\n\\n    function transferOperator(address newOperator_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IOracle {\\n    function update() external;\\n\\n    function consult(address _token, uint256 _amountIn) external view returns (uint144 amountOut);\\n\\n    function twap(address _token, uint256 _amountIn) external view returns (uint144 _amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBoardroom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IBoardroom {\\n    function balanceOf(address _member) external view returns (uint256);\\n\\n    function earned(address _member) external view returns (uint256);\\n\\n    function canWithdraw(address _member) external view returns (bool);\\n\\n    function canClaimReward(address _member) external view returns (bool);\\n\\n    function epoch() external view returns (uint256);\\n\\n    function nextEpochPoint() external view returns (uint256);\\n\\n    function getTokenPrice() external view returns (uint256);\\n\\n    function setOperator(address _operator) external;\\n\\n    function setReserveFund(address _reserveFund) external;\\n\\n    function setStakeFee(uint256 _stakeFee) external;\\n\\n    function setWithdrawFee(uint256 _withdrawFee) external;\\n\\n    function setWithdrawFeeMultiplier(uint256 _withdrawFee) external;\\n\\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external;\\n\\n    function stake(uint256 _amount) external;\\n\\n    function withdraw(uint256 _amount) external;\\n\\n    function exit() external;\\n\\n    function claimReward() external;\\n\\n    function allocateSeigniorage(uint256 _amount) external;\\n\\n    function governanceRecoverUnsupported(\\n        address _token,\\n        uint256 _amount,\\n        address _to\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRegulationStats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IRegulationStats {\\n    function addEpochInfo(\\n        uint256 epochNumber,\\n        uint256 twap,\\n        uint256 expanded,\\n        uint256 boardroomFunding,\\n        uint256 daoFunding,\\n        uint256 marketingFunding,\\n        uint256 insuranceFunding\\n    ) external;\\n\\n    function addBonded(uint256 epochNumber, uint256 added) external;\\n\\n    function addRedeemed(uint256 epochNumber, uint256 added) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./lib/Babylonian.sol\\\";\\nimport \\\"./owner/Operator.sol\\\";\\nimport \\\"./utils/ContractGuard.sol\\\";\\nimport \\\"./interfaces/IBasisAsset.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\nimport \\\"./interfaces/IBoardroom.sol\\\";\\nimport \\\"./interfaces/IRegulationStats.sol\\\";\\n\\n/*\\n\\n$$$$$$$\\\\   $$$$$$\\\\  $$\\\\      $$\\\\ $$$$$$$\\\\                                                            \\n$$  __$$\\\\ $$  __$$\\\\ $$$\\\\    $$$ |$$  __$$\\\\                                                           \\n$$ |  $$ |$$ /  $$ |$$$$\\\\  $$$$ |$$ |  $$ |    $$$$$$\\\\$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\  $$\\\\   $$\\\\ \\n$$$$$$$\\\\ |$$ |  $$ |$$\\\\$$\\\\$$ $$ |$$$$$$$\\\\ |    $$  _$$  _$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$ |  $$ |\\n$$  __$$\\\\ $$ |  $$ |$$ \\\\$$$  $$ |$$  __$$\\\\     $$ / $$ / $$ |$$ /  $$ |$$ |  $$ |$$$$$$$$ |$$ |  $$ |\\n$$ |  $$ |$$ |  $$ |$$ |\\\\$  /$$ |$$ |  $$ |    $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\\n$$$$$$$  | $$$$$$  |$$ | \\\\_/ $$ |$$$$$$$  |$$\\\\ $$ | $$ | $$ |\\\\$$$$$$  |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |\\n\\\\_______/  \\\\______/ \\\\__|     \\\\__|\\\\_______/ \\\\__|\\\\__| \\\\__| \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______| \\\\____$$ |\\n                                                                                           $$\\\\   $$ |\\n                                                                                           \\\\$$$$$$  |\\n    http://bomb.money                                                                      \\\\______/ \\n*/\\ncontract Treasury is ContractGuard, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    /* ========= CONSTANT VARIABLES ======== */\\n\\n    uint256 public constant PERIOD = 8 hours;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // governance\\n    address public operator;\\n\\n    // flags\\n    bool public initialized = false;\\n\\n    // epoch\\n    uint256 public startTime;\\n    uint256 public epoch = 0;\\n    uint256 public epochSupplyContractionLeft = 0;\\n\\n    // exclusions from total supply\\n    address[] public excludedFromTotalSupply = [\\n        address(0xbc0BC07A7e05b9a11A8e504FC29eb49D08445475), // TokenGenesisPool\\n        address(0x6E6BB04f91C928FBdC7f036462B0474107d86ef1) // new TokenRewardPool\\n    ];\\n\\n    // core components\\n    address public token;\\n    address public bond;\\n    address public share;\\n\\n    address public boardroom;\\n    address public tokenOracle;\\n\\n    uint256 public boardroomWithdrawFee;\\n    uint256 public boardroomStakeFee;\\n    // price\\n    uint256 public tokenPriceOne;\\n    uint256 public tokenPriceCeiling;\\n\\n    uint256 public seigniorageSaved;\\n\\n    uint256[] public supplyTiers;\\n    uint256[] public maxExpansionTiers;\\n\\n    uint256 public maxSupplyExpansionPercent;\\n    uint256 public bondDepletionFloorPercent;\\n    uint256 public seigniorageExpansionFloorPercent;\\n    uint256 public maxSupplyContractionPercent;\\n    uint256 public maxDebtRatioPercent;\\n\\n    // 28 first epochs (1 week) with 4.5% expansion regardless of BOMB price\\n    uint256 public bootstrapEpochs;\\n    uint256 public bootstrapSupplyExpansionPercent;\\n\\n    /* =================== Added variables =================== */\\n    uint256 public previousEpochTokenPrice;\\n    uint256 public maxDiscountRate; // when purchasing bond\\n    uint256 public maxPremiumRate; // when redeeming bond\\n    uint256 public discountPercent;\\n    uint256 public premiumThreshold;\\n    uint256 public premiumPercent;\\n    uint256 public mintingFactorForPayingDebt; // print extra BOMB during debt phase\\n\\n    // 45% for Stakers in boardroom (THIS)\\n    // 45% for DAO fund\\n    // 2% for DEV fund\\n    // 8% for INSURANCE fund\\n    address public daoFund;\\n    uint256 public daoFundSharedPercent;\\n\\n    address public devFund;\\n    uint256 public devFundSharedPercent;\\n\\n    address public insuranceFund;\\n    uint256 public insuranceFundSharedPercent;\\n\\n    address public regulationStats;\\n\\n    /* =================== Events =================== */\\n\\n    event Initialized(address indexed executor, uint256 at);\\n    event BurnedBonds(address indexed from, uint256 bondAmount);\\n    event RedeemedBonds(address indexed from, uint256 tokenAmount, uint256 bondAmount);\\n    event BoughtBonds(address indexed from, uint256 tokenAmount, uint256 bondAmount);\\n    event TreasuryFunded(uint256 timestamp, uint256 seigniorage);\\n    event BoardroomFunded(uint256 timestamp, uint256 seigniorage);\\n    event DaoFundFunded(uint256 timestamp, uint256 seigniorage);\\n    event DevFundFunded(uint256 timestamp, uint256 seigniorage);\\n    event InsuranceFundFunded(uint256 timestamp, uint256 seigniorage);\\n    event Seigniorage(uint256 epoch, uint256 twap, uint256 expansion);\\n\\n    /* =================== Modifier =================== */\\n\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"Treasury: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    modifier checkCondition() {\\n        require(now >= startTime, \\\"Treasury: not started yet\\\");\\n\\n        _;\\n    }\\n\\n    modifier checkEpoch() {\\n        require(now >= nextEpochPoint(), \\\"Treasury: not opened yet\\\");\\n\\n        _;\\n\\n        epoch = epoch.add(1);\\n        epochSupplyContractionLeft = (getTokenPrice() > tokenPriceCeiling) ? 0 : getTokenCirculatingSupply().mul(maxSupplyContractionPercent).div(10000);\\n    }\\n\\n    modifier checkOperator() {\\n        require(\\n            IBasisAsset(token).operator() == address(this) &&\\n                IBasisAsset(bond).operator() == address(this) &&\\n                //   IBasisAsset(share).operator() == address(this) &&\\n                Operator(boardroom).operator() == address(this),\\n            \\\"Treasury: need more permission\\\"\\n        );\\n\\n        _;\\n    }\\n\\n    modifier notInitialized() {\\n        require(!initialized, \\\"Treasury: already initialized\\\");\\n\\n        _;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function isInitialized() public view returns (bool) {\\n        return initialized;\\n    }\\n\\n    // epoch\\n    function nextEpochPoint() public view returns (uint256) {\\n        return startTime.add(epoch.mul(PERIOD));\\n    }\\n\\n    // oracle\\n    function getTokenPrice() public view returns (uint256 tokenPrice) {\\n        try IOracle(tokenOracle).consult(token, 1e18) returns (uint144 price) {\\n            return uint256(price);\\n        } catch {\\n            revert(\\\"Treasury: failed to consult BOMB price from the oracle\\\");\\n        }\\n    }\\n\\n    function getTokenUpdatedPrice() public view returns (uint256 _tokenPrice) {\\n        try IOracle(tokenOracle).twap(token, 1e18) returns (uint144 price) {\\n            return uint256(price);\\n        } catch {\\n            revert(\\\"Treasury: failed to consult BOMB price from the oracle\\\");\\n        }\\n    }\\n\\n    // budget\\n    function getReserve() public view returns (uint256) {\\n        return seigniorageSaved;\\n    }\\n\\n    function getBurnableTokenLeft() public view returns (uint256 _burnableTokenLeft) {\\n        uint256 _tokenPrice = getTokenPrice();\\n        if (_tokenPrice <= tokenPriceOne) {\\n            uint256 _tokenSupply = getTokenCirculatingSupply();\\n            uint256 _bondMaxSupply = _tokenSupply.mul(maxDebtRatioPercent).div(10000);\\n            uint256 _bondSupply = IERC20(bond).totalSupply();\\n            if (_bondMaxSupply > _bondSupply) {\\n                uint256 _maxMintableBond = _bondMaxSupply.sub(_bondSupply);\\n                uint256 _maxBurnableToken = _maxMintableBond.mul(_tokenPrice).div(1e18);\\n                _burnableTokenLeft = Math.min(epochSupplyContractionLeft, _maxBurnableToken);\\n            }\\n        }\\n    }\\n\\n    function getRedeemableBonds() public view returns (uint256 _redeemableBonds) {\\n        uint256 _tokenPrice = getTokenPrice();\\n        if (_tokenPrice > tokenPriceCeiling) {\\n            uint256 _totalToken = IERC20(token).balanceOf(address(this));\\n            uint256 _rate = getBondPremiumRate();\\n            if (_rate > 0) {\\n                _redeemableBonds = _totalToken.mul(1e18).div(_rate);\\n            }\\n        }\\n    }\\n\\n    function getBondDiscountRate() public view returns (uint256 _rate) {\\n        uint256 _tokenPrice = getTokenPrice();\\n        if (_tokenPrice <= tokenPriceOne) {\\n            if (discountPercent == 0) {\\n                // no discount\\n                _rate = tokenPriceOne;\\n            } else {\\n                uint256 _bondAmount = tokenPriceOne.mul(1e18).div(_tokenPrice); // to burn 1 BOMB\\n                uint256 _discountAmount = _bondAmount.sub(tokenPriceOne).mul(discountPercent).div(10000);\\n                _rate = tokenPriceOne.add(_discountAmount);\\n                if (maxDiscountRate > 0 && _rate > maxDiscountRate) {\\n                    _rate = maxDiscountRate;\\n                }\\n            }\\n        }\\n    }\\n\\n    function getBondPremiumRate() public view returns (uint256 _rate) {\\n        uint256 _tokenPrice = getTokenPrice();\\n        if (_tokenPrice > tokenPriceCeiling) {\\n            uint256 _tokenPricePremiumThreshold = tokenPriceOne.mul(premiumThreshold).div(100);\\n            if (_tokenPrice >= _tokenPricePremiumThreshold) {\\n                //Price > 1.10\\n                uint256 _premiumAmount = _tokenPrice.sub(tokenPriceOne).mul(premiumPercent).div(10000);\\n                _rate = tokenPriceOne.add(_premiumAmount);\\n                if (maxPremiumRate > 0 && _rate > maxPremiumRate) {\\n                    _rate = maxPremiumRate;\\n                }\\n            } else {\\n                // no premium bonus\\n                _rate = tokenPriceOne;\\n            }\\n        }\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function initialize(\\n        address _token,\\n        address _bond,\\n        address _share,\\n        address _tokenOracle,\\n        address _boardroom,\\n        uint256 _startTime\\n    ) public notInitialized {\\n        token = _token;\\n        bond = _bond;\\n        share = _share;\\n        tokenOracle = _tokenOracle;\\n        boardroom = _boardroom;\\n        startTime = _startTime;\\n\\n        tokenPriceOne = 10**18; // This is to allow a PEG of 10,000 BOMB per BTC\\n        tokenPriceCeiling = tokenPriceOne.mul(1001).div(1000);\\n\\n        // Dynamic max expansion percent\\n        supplyTiers = [0 ether, 100000 ether, 250000 ether, 500000 ether, 1000000 ether, 5000000 ether];\\n        maxExpansionTiers = [150, 150, 150, 150, 150, 150];\\n\\n        maxSupplyExpansionPercent = 350; // Upto 4.5% supply for expansion\\n\\n        bondDepletionFloorPercent = 10000; // 100% of Bond supply for depletion floor\\n        seigniorageExpansionFloorPercent = 3500; // At least 35% of expansion reserved for boardroom\\n        maxSupplyContractionPercent = 300; // Upto 3.0% supply for contraction (to burn BOMB and mint tBOND)\\n        maxDebtRatioPercent = 3500; // Upto 35% supply of tBOND to purchase\\n\\n        premiumThreshold = 105;\\n        premiumPercent = 7000;\\n\\n        // First 21 epochs with 3.5% expansion\\n        bootstrapEpochs = 21;\\n        bootstrapSupplyExpansionPercent = 350;\\n\\n        // set seigniorageSaved to it's balance\\n        seigniorageSaved = IERC20(token).balanceOf(address(this));\\n\\n        initialized = true;\\n        operator = msg.sender;\\n        emit Initialized(msg.sender, block.number);\\n    }\\n\\n    function setOperator(address _operator) external onlyOperator {\\n        operator = _operator;\\n    }\\n\\n    function setBoardroom(address _boardroom) external onlyOperator {\\n        boardroom = _boardroom;\\n    }\\n\\n    function setRegulationStats(address _regulationStats) external onlyOperator {\\n        regulationStats = _regulationStats;\\n    }\\n\\n    function setBoardroomWithdrawFee(uint256 _boardroomWithdrawFee) external onlyOperator {\\n        require(_boardroomWithdrawFee <= 20, \\\"Max withdraw fee is 20%\\\");\\n        boardroomWithdrawFee = _boardroomWithdrawFee;\\n        IBoardroom(boardroom).setWithdrawFee(boardroomWithdrawFee);\\n    }\\n\\n    function setBoardroomStakeFee(uint256 _boardroomStakeFee) external onlyOperator {\\n        require(_boardroomStakeFee <= 5, \\\"Max stake fee is 5%\\\");\\n        boardroomStakeFee = _boardroomStakeFee;\\n        IBoardroom(boardroom).setStakeFee(boardroomStakeFee);\\n    }\\n\\n    function setTokenOracle(address _tokenOracle) external onlyOperator {\\n        tokenOracle = _tokenOracle;\\n    }\\n\\n    function setTokenPriceCeiling(uint256 _tokenPriceCeiling) external onlyOperator {\\n        require(_tokenPriceCeiling >= tokenPriceOne && _tokenPriceCeiling <= tokenPriceOne.mul(120).div(100), \\\"out of range\\\"); // [$1.0, $1.2]\\n        tokenPriceCeiling = _tokenPriceCeiling;\\n    }\\n\\n    function setMaxSupplyExpansionPercents(uint256 _maxSupplyExpansionPercent) external onlyOperator {\\n        require(_maxSupplyExpansionPercent >= 10 && _maxSupplyExpansionPercent <= 1000, \\\"_maxSupplyExpansionPercent: out of range\\\"); // [0.1%, 10%]\\n        maxSupplyExpansionPercent = _maxSupplyExpansionPercent;\\n    }\\n\\n    function setSupplyTiersEntry(uint8 _index, uint256 _value) external onlyOperator returns (bool) {\\n        require(_index >= 0, \\\"Index has to be higher than 0\\\");\\n        require(_index < 9, \\\"Index has to be lower than count of tiers\\\");\\n        if (_index > 0) {\\n            require(_value > supplyTiers[_index - 1]);\\n        }\\n        if (_index < 8) {\\n            require(_value < supplyTiers[_index + 1]);\\n        }\\n        supplyTiers[_index] = _value;\\n        return true;\\n    }\\n\\n    function setMaxExpansionTiersEntry(uint8 _index, uint256 _value) external onlyOperator returns (bool) {\\n        require(_index >= 0, \\\"Index has to be higher than 0\\\");\\n        require(_index < 9, \\\"Index has to be lower than count of tiers\\\");\\n        require(_value >= 10 && _value <= 1000, \\\"_value: out of range\\\"); // [0.1%, 10%]\\n        maxExpansionTiers[_index] = _value;\\n        return true;\\n    }\\n\\n    function setBondDepletionFloorPercent(uint256 _bondDepletionFloorPercent) external onlyOperator {\\n        require(_bondDepletionFloorPercent >= 500 && _bondDepletionFloorPercent <= 10000, \\\"out of range\\\"); // [5%, 100%]\\n        bondDepletionFloorPercent = _bondDepletionFloorPercent;\\n    }\\n\\n    function setMaxSupplyContractionPercent(uint256 _maxSupplyContractionPercent) external onlyOperator {\\n        require(_maxSupplyContractionPercent >= 100 && _maxSupplyContractionPercent <= 1500, \\\"out of range\\\"); // [0.1%, 15%]\\n        maxSupplyContractionPercent = _maxSupplyContractionPercent;\\n    }\\n\\n    function setMaxDebtRatioPercent(uint256 _maxDebtRatioPercent) external onlyOperator {\\n        require(_maxDebtRatioPercent >= 1000 && _maxDebtRatioPercent <= 10000, \\\"out of range\\\"); // [10%, 100%]\\n        maxDebtRatioPercent = _maxDebtRatioPercent;\\n    }\\n\\n    function setBootstrap(uint256 _bootstrapEpochs, uint256 _bootstrapSupplyExpansionPercent) external onlyOperator {\\n        require(_bootstrapEpochs <= 120, \\\"_bootstrapEpochs: out of range\\\"); // <= 1 month\\n        require(_bootstrapSupplyExpansionPercent >= 100 && _bootstrapSupplyExpansionPercent <= 1000, \\\"_bootstrapSupplyExpansionPercent: out of range\\\"); // [1%, 10%]\\n        bootstrapEpochs = _bootstrapEpochs;\\n        bootstrapSupplyExpansionPercent = _bootstrapSupplyExpansionPercent;\\n    }\\n\\n    function setExtraFunds(\\n        address _daoFund,\\n        uint256 _daoFundSharedPercent,\\n        address _devFund,\\n        uint256 _devFundSharedPercent,\\n        address _insuranceFund,\\n        uint256 _insuranceFundSharedPercent\\n    ) external onlyOperator {\\n        require(_daoFund != address(0), \\\"zero\\\");\\n        require(_daoFundSharedPercent <= 5000, \\\"out of range\\\"); // <= 50%\\n        require(_devFund != address(0), \\\"zero\\\");\\n        require(_devFundSharedPercent <= 1000, \\\"out of range\\\"); // <= 10%\\n        require(_insuranceFund != address(0), \\\"zero\\\");\\n        require(_insuranceFundSharedPercent <= 1000, \\\"out of range\\\"); // <= 10%\\n\\n        daoFund = _daoFund;\\n        daoFundSharedPercent = _daoFundSharedPercent;\\n\\n        devFund = _devFund;\\n        devFundSharedPercent = _devFundSharedPercent;\\n\\n        insuranceFund = _insuranceFund;\\n        insuranceFundSharedPercent = _insuranceFundSharedPercent;\\n    }\\n\\n    function setMaxDiscountRate(uint256 _maxDiscountRate) external onlyOperator {\\n        maxDiscountRate = _maxDiscountRate;\\n    }\\n\\n    function setMaxPremiumRate(uint256 _maxPremiumRate) external onlyOperator {\\n        maxPremiumRate = _maxPremiumRate;\\n    }\\n\\n    function setDiscountPercent(uint256 _discountPercent) external onlyOperator {\\n        require(_discountPercent <= 20000, \\\"_discountPercent is over 200%\\\");\\n        discountPercent = _discountPercent;\\n    }\\n\\n    function setPremiumThreshold(uint256 _premiumThreshold) external onlyOperator {\\n        require(_premiumThreshold <= 150, \\\"_premiumThreshold is higher than 1.5\\\");\\n        premiumThreshold = _premiumThreshold;\\n    }\\n\\n    function setPremiumPercent(uint256 _premiumPercent) external onlyOperator {\\n        require(_premiumPercent <= 20000, \\\"_premiumPercent is over 200%\\\");\\n        premiumPercent = _premiumPercent;\\n    }\\n\\n    function setMintingFactorForPayingDebt(uint256 _mintingFactorForPayingDebt) external onlyOperator {\\n        require(_mintingFactorForPayingDebt >= 10000 && _mintingFactorForPayingDebt <= 20000, \\\"_mintingFactorForPayingDebt: out of range\\\"); // [100%, 200%]\\n        mintingFactorForPayingDebt = _mintingFactorForPayingDebt;\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    function _updateTokenPrice() internal {\\n        try IOracle(tokenOracle).update() {} catch {}\\n    }\\n\\n    function getTokenCirculatingSupply() public view returns (uint256) {\\n        IERC20 tokenErc20 = IERC20(token);\\n        uint256 totalSupply = tokenErc20.totalSupply();\\n        uint256 balanceExcluded = 0;\\n        for (uint8 entryId = 0; entryId < excludedFromTotalSupply.length; ++entryId) {\\n            balanceExcluded = balanceExcluded.add(tokenErc20.balanceOf(excludedFromTotalSupply[entryId]));\\n        }\\n        return totalSupply.sub(balanceExcluded);\\n    }\\n\\n    function buyBonds(uint256 _tokenAmount, uint256 targetPrice) external onlyOneBlock checkCondition checkOperator {\\n        require(_tokenAmount > 0, \\\"Treasury: cannot purchase bonds with zero amount\\\");\\n\\n        uint256 tokenPrice = getTokenPrice();\\n        require(tokenPrice == targetPrice, \\\"Treasury: BOMB price moved\\\");\\n        require(\\n            tokenPrice < tokenPriceOne, // price < $1\\n            \\\"Treasury: tokenPrice not eligible for bond purchase\\\"\\n        );\\n\\n        require(_tokenAmount <= epochSupplyContractionLeft, \\\"Treasury: not enough bond left to purchase\\\");\\n\\n        uint256 _rate = getBondDiscountRate();\\n        require(_rate > 0, \\\"Treasury: invalid bond rate\\\");\\n\\n        uint256 _bondAmount = _tokenAmount.mul(_rate).div(1e18);\\n        uint256 tokenSupply = getTokenCirculatingSupply();\\n        uint256 newBondSupply = IERC20(bond).totalSupply().add(_bondAmount);\\n        require(newBondSupply <= tokenSupply.mul(maxDebtRatioPercent).div(10000), \\\"over max debt ratio\\\");\\n\\n        IBasisAsset(token).burnFrom(msg.sender, _tokenAmount);\\n        IBasisAsset(bond).mint(msg.sender, _bondAmount);\\n\\n        epochSupplyContractionLeft = epochSupplyContractionLeft.sub(_tokenAmount);\\n        _updateTokenPrice();\\n        if (regulationStats != address(0)) IRegulationStats(regulationStats).addBonded(epoch, _bondAmount);\\n\\n        emit BoughtBonds(msg.sender, _tokenAmount, _bondAmount);\\n    }\\n\\n    function redeemBonds(uint256 _bondAmount, uint256 targetPrice) external onlyOneBlock checkCondition checkOperator {\\n        require(_bondAmount > 0, \\\"Treasury: cannot redeem bonds with zero amount\\\");\\n\\n        uint256 tokenPrice = getTokenPrice();\\n        require(tokenPrice == targetPrice, \\\"Treasury: BOMB price moved\\\");\\n        require(\\n            tokenPrice > tokenPriceCeiling, // price > $1.01\\n            \\\"Treasury: tokenPrice not eligible for bond purchase\\\"\\n        );\\n\\n        uint256 _rate = getBondPremiumRate();\\n        require(_rate > 0, \\\"Treasury: invalid bond rate\\\");\\n\\n        uint256 _tokenAmount = _bondAmount.mul(_rate).div(1e18);\\n        require(IERC20(token).balanceOf(address(this)) >= _tokenAmount, \\\"Treasury: treasury has no more budget\\\");\\n\\n        seigniorageSaved = seigniorageSaved.sub(Math.min(seigniorageSaved, _tokenAmount));\\n\\n        IBasisAsset(bond).burnFrom(msg.sender, _bondAmount);\\n        IERC20(token).safeTransfer(msg.sender, _tokenAmount);\\n\\n        _updateTokenPrice();\\n        if (regulationStats != address(0)) IRegulationStats(regulationStats).addRedeemed(epoch, _tokenAmount);\\n\\n        emit RedeemedBonds(msg.sender, _tokenAmount, _bondAmount);\\n    }\\n\\n    function _sendToBoardroom(uint256 _amount) internal {\\n        IBasisAsset(token).mint(address(this), _amount);\\n\\n        uint256 _daoFundSharedAmount = 0;\\n        if (daoFundSharedPercent > 0) {\\n            _daoFundSharedAmount = _amount.mul(daoFundSharedPercent).div(10000);\\n            IERC20(token).transfer(daoFund, _daoFundSharedAmount);\\n            emit DaoFundFunded(now, _daoFundSharedAmount);\\n        }\\n\\n        uint256 _devFundSharedAmount = 0;\\n        if (devFundSharedPercent > 0) {\\n            _devFundSharedAmount = _amount.mul(devFundSharedPercent).div(10000);\\n            IERC20(token).transfer(devFund, _devFundSharedAmount);\\n            emit DevFundFunded(now, _devFundSharedAmount);\\n        }\\n\\n        uint256 _insuranceFundSharedAmount = 0;\\n        if (insuranceFundSharedPercent > 0) {\\n            _insuranceFundSharedAmount = _amount.mul(insuranceFundSharedPercent).div(10000);\\n            IERC20(token).transfer(insuranceFund, _insuranceFundSharedAmount);\\n            emit InsuranceFundFunded(now, _insuranceFundSharedAmount);\\n        }\\n\\n        _amount = _amount.sub(_daoFundSharedAmount).sub(_devFundSharedAmount).sub(_insuranceFundSharedAmount);\\n\\n        IERC20(token).safeApprove(boardroom, 0);\\n        IERC20(token).safeApprove(boardroom, _amount);\\n        IBoardroom(boardroom).allocateSeigniorage(_amount);\\n        if (regulationStats != address(0))\\n            IRegulationStats(regulationStats).addEpochInfo(\\n                epoch.add(1),\\n                previousEpochTokenPrice,\\n                _amount,\\n                _amount,\\n                _daoFundSharedAmount,\\n                _devFundSharedAmount,\\n                _insuranceFundSharedAmount\\n            );\\n        emit BoardroomFunded(now, _amount);\\n    }\\n\\n    function _calculateMaxSupplyExpansionPercent(uint256 _tokenSupply) internal returns (uint256) {\\n        for (uint8 tierId = 8; tierId >= 0; --tierId) {\\n            if (_tokenSupply >= supplyTiers[tierId]) {\\n                maxSupplyExpansionPercent = maxExpansionTiers[tierId];\\n                break;\\n            }\\n        }\\n        return maxSupplyExpansionPercent;\\n    }\\n\\n    function allocateSeigniorage() external onlyOneBlock checkCondition checkEpoch checkOperator {\\n        _updateTokenPrice();\\n        previousEpochTokenPrice = getTokenPrice();\\n        uint256 tokenSupply = getTokenCirculatingSupply().sub(seigniorageSaved);\\n        if (epoch < bootstrapEpochs) {\\n            // 28 first epochs with 4.5% expansion\\n            _sendToBoardroom(tokenSupply.mul(bootstrapSupplyExpansionPercent).div(10000));\\n            emit Seigniorage(epoch, previousEpochTokenPrice, tokenSupply.mul(bootstrapSupplyExpansionPercent).div(10000));\\n        } else {\\n            if (previousEpochTokenPrice > tokenPriceCeiling) {\\n                // Expansion ($BOMB Price > 1 $ETH): there is some seigniorage to be allocated\\n                uint256 bondSupply = IERC20(bond).totalSupply();\\n                uint256 _percentage = previousEpochTokenPrice.sub(tokenPriceOne);\\n                uint256 _savedForBond;\\n                uint256 _savedForBoardroom;\\n                uint256 _mse = _calculateMaxSupplyExpansionPercent(tokenSupply).mul(1e14);\\n                if (_percentage > _mse) {\\n                    _percentage = _mse;\\n                }\\n                if (seigniorageSaved >= bondSupply.mul(bondDepletionFloorPercent).div(10000)) {\\n                    // saved enough to pay debt, mint as usual rate\\n                    _savedForBoardroom = tokenSupply.mul(_percentage).div(1e18);\\n                } else {\\n                    // have not saved enough to pay debt, mint more\\n                    uint256 _seigniorage = tokenSupply.mul(_percentage).div(1e18);\\n                    _savedForBoardroom = _seigniorage.mul(seigniorageExpansionFloorPercent).div(10000);\\n                    _savedForBond = _seigniorage.sub(_savedForBoardroom);\\n                    if (mintingFactorForPayingDebt > 0) {\\n                        _savedForBond = _savedForBond.mul(mintingFactorForPayingDebt).div(10000);\\n                    }\\n                }\\n                if (_savedForBoardroom > 0) {\\n                    _sendToBoardroom(_savedForBoardroom);\\n                }\\n                if (_savedForBond > 0) {\\n                    seigniorageSaved = seigniorageSaved.add(_savedForBond);\\n                    IBasisAsset(token).mint(address(this), _savedForBond);\\n                    emit TreasuryFunded(now, _savedForBond);\\n                }\\n            }\\n        }\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        // do not allow to drain core tokens\\n        require(address(_token) != address(token), \\\"token\\\");\\n        require(address(_token) != address(bond), \\\"bond\\\");\\n        require(address(_token) != address(share), \\\"share\\\");\\n        _token.safeTransfer(_to, _amount);\\n    }\\n\\n    function boardroomSetOperator(address _operator) external onlyOperator {\\n        IBoardroom(boardroom).setOperator(_operator);\\n    }\\n\\n    function boardroomSetLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external onlyOperator {\\n        IBoardroom(boardroom).setLockUp(_withdrawLockupEpochs, _rewardLockupEpochs);\\n    }\\n\\n    function boardroomSetReserveFund(address _reserveFund) external onlyOperator {\\n        IBoardroom(boardroom).setReserveFund(_reserveFund);\\n    }\\n\\n    function boardroomAllocateSeigniorage(uint256 amount) external onlyOperator {\\n        IBoardroom(boardroom).allocateSeigniorage(amount);\\n    }\\n\\n    function boardroomSetWithdrawFeeMultiplier(uint256 _amount) external onlyOperator {\\n        IBoardroom(boardroom).setWithdrawFeeMultiplier(_amount);\\n    }\\n\\n    function boardroomGovernanceRecoverUnsupported(\\n        address _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        IBoardroom(boardroom).governanceRecoverUnsupported(_token, _amount, _to);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Tokens/PMATICToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../lib/SafeMath8.sol\\\";\\nimport \\\"../owner/Operator.sol\\\";\\nimport \\\"../interfaces/IOracle.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\n\\ninterface ILiquidityFund {\\n    function addLiquidity(uint256 _amount) external;\\n}\\n\\npragma solidity 0.6.12;\\n\\ncontract PMATICToken is ERC20Burnable, Operator {\\n    using SafeMath8 for uint8;\\n    using SafeMath for uint256;\\n\\n    // Initial distribution for the first 24h genesis pools\\n    uint256 public constant INITIAL_GENESIS_POOL_DISTRIBUTION = 100000 ether;\\n\\n    // Have the rewards been distributed to the pools\\n    bool public rewardPoolDistributed = false;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    bool public addLiquidityEnabled = false;\\n\\n    address public oracle;\\n\\n    uint256 public burnRate;\\n    uint256 public taxRate; // buy back Peg Token and add liquidity\\n    address public taxFund; // fund buy back Peg Token\\n\\n    uint256 private _totalBurned;\\n    uint256 private _totalTaxAdded;\\n    mapping(address => bool) private _isExcludedFromFee;\\n    mapping(address => bool) private _isExcludedToFee;\\n\\n    /* =================== Added variables (need to keep orders for proxy to work) =================== */\\n    /*...\\n\\n    /* ========== EVENTS ========== */\\n\\n    event TaxAdded(address indexed account, address taxFund, uint256 amount);\\n\\n    /* ========== Modifiers =============== */\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    /**\\n     * @notice Constructs the CZpegs-Peg Token ERC-20 contract.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address _taxFund\\n    ) public ERC20(name_, symbol_) {\\n        _setupDecimals(decimals_);\\n        taxFund = _taxFund;\\n        burnRate = 0;\\n        taxRate = 0;\\n        _mint(msg.sender, 100 ether);\\n    }\\n\\n    function setOracle(address _oracle) external onlyOwner {\\n        oracle = _oracle;\\n    }\\n\\n    function toggleAddLiquidityEnabled() external onlyOwner {\\n        addLiquidityEnabled = !addLiquidityEnabled;\\n    }\\n\\n    function setBurnRate(uint256 _burnRate) external onlyOwner {\\n        require(_burnRate <= 1500, \\\"too high\\\"); // <= 15%\\n        burnRate = _burnRate;\\n    }\\n\\n    function setTaxRate(uint256 _taxRate) external onlyOwner {\\n        require(_taxRate <= 1500, \\\"too high\\\"); // <= 15%\\n        taxRate = _taxRate;\\n    }\\n\\n    function setTaxFund(address _taxFund) external onlyOwner {\\n        require(_taxFund != address(0), \\\"zero\\\");\\n        taxFund = _taxFund;\\n    }\\n\\n    function setExcludeFromFee(address _account, bool _status) external onlyOwner {\\n        _isExcludedFromFee[_account] = _status;\\n    }\\n\\n    function setExcludeToFee(address _account, bool _status) external onlyOwner {\\n        _isExcludedToFee[_account] = _status;\\n    }\\n\\n    function setExcludeBothDirectionsFee(address _account, bool _status) external onlyOwner {\\n        _isExcludedFromFee[_account] = _status;\\n        _isExcludedToFee[_account] = _status;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function totalBurned() external view returns (uint256) {\\n        return _totalBurned;\\n    }\\n\\n    function totalTaxAdded() external view returns (uint256) {\\n        return _totalTaxAdded;\\n    }\\n\\n    function getTokenPrice() public view returns (uint256) {\\n        address _oracle = oracle;\\n        return (_oracle == address(0)) ? 1e18 : uint256(IOracle(_oracle).consult(address(this), 1e18));\\n    }\\n\\n    function getTokenUpdatedPrice() public view returns (uint256) {\\n        address _oracle = oracle;\\n        return (_oracle == address(0)) ? 1e18 : uint256(IOracle(_oracle).twap(address(this), 1e18));\\n    }\\n\\n    function isExcludedFromFee(address _account) external view returns (bool) {\\n        return _isExcludedFromFee[_account];\\n    }\\n\\n    function isExcludedToFee(address _account) external view returns (bool) {\\n        return _isExcludedToFee[_account];\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Operator mints basis CZpegs-Peg Token to a recipient\\n     * @param recipient_ The address of recipient\\n     * @param amount_ The amount of basis CZpegs-Peg Token to mint to\\n     * @return whether the process has been done\\n     */\\n    function mint(address recipient_, uint256 amount_) public onlyOperator returns (bool) {\\n        uint256 balanceBefore = balanceOf(recipient_);\\n        _mint(recipient_, amount_);\\n        uint256 balanceAfter = balanceOf(recipient_);\\n\\n        return balanceAfter > balanceBefore;\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function burnFrom(address account, uint256 amount) public override onlyOperator {\\n        super.burnFrom(account, amount);\\n    }\\n\\n    /* ========== OVERRIDE STANDARD FUNCTIONS ========== */\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `_account` cannot be the zero address.\\n     * - `_account` must have at least `_amount` tokens.\\n     */\\n    function _burn(address _account, uint256 _amount) internal override {\\n        super._burn(_account, _amount);\\n        _totalBurned = _totalBurned.add(_amount);\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal override {\\n        require(sender != address(0), \\\"CZpegs: transfer to the zero address\\\");\\n        require(recipient != address(0), \\\"CZpegs: transfer to the zero address\\\");\\n\\n        uint256 _amount = amount;\\n\\n        _beforeTokenTransfer(sender, recipient, _amount);\\n\\n        if (!_isExcludedFromFee[sender] && !_isExcludedToFee[recipient]) {\\n            uint256 _tokenPrice = getTokenUpdatedPrice();\\n            if (_tokenPrice < 1e18) {\\n                {\\n                    uint256 _taxRate = taxRate;\\n                    if (_taxRate > 0) {\\n                        uint256 _taxAmount = amount.mul(_taxRate).div(10000);\\n                        address _taxFund = taxFund;\\n                        super._transfer(sender, _taxFund, _taxAmount);\\n                        _amount = _amount.sub(_taxAmount);\\n                        _totalTaxAdded = _totalTaxAdded.add(_taxAmount);\\n                        if (addLiquidityEnabled) {\\n                            ILiquidityFund(_taxFund).addLiquidity(_taxAmount);\\n                        }\\n                        emit TaxAdded(sender, _taxFund, _taxAmount);\\n                    }\\n                }\\n                {\\n                    uint256 _burnRate = burnRate;\\n                    if (_burnRate > 0) {\\n                        uint256 _burnAmount = amount.mul(_burnRate).div(10000);\\n                        _burn(sender, _burnAmount);\\n                        _amount = _amount.sub(_burnAmount);\\n                    }\\n                }\\n            }\\n        }\\n\\n        super._transfer(sender, recipient, _amount);\\n    }\\n\\n    /**\\n     * @notice distribute to reward pool (only once)\\n     */\\n    function distributeReward(address _genesisPool) external onlyOperator {\\n        require(!rewardPoolDistributed, \\\"only can distribute once\\\");\\n        require(_genesisPool != address(0), \\\"!_genesisPool\\\");\\n        rewardPoolDistributed = true;\\n        _mint(_genesisPool, INITIAL_GENESIS_POOL_DISTRIBUTION);\\n    }\\n\\n    /* ========== EMERGENCY ========== */\\n\\n    function governanceRecoverUnsupported(IERC20 _token) external onlyOwner {\\n        _token.transfer(owner(), _token.balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SafeMath8.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath8 {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\\n        uint8 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint8 a, uint8 b, string memory errorMessage) internal pure returns (uint8) {\\n        require(b <= a, errorMessage);\\n        uint8 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint8 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint8 a, uint8 b, string memory errorMessage) internal pure returns (uint8) {\\n        require(b > 0, errorMessage);\\n        uint8 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint8 a, uint8 b) internal pure returns (uint8) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint8 a, uint8 b, string memory errorMessage) internal pure returns (uint8) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/Tokens/BondPMATIC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"../owner/Operator.sol\\\";\\n\\n/*\\n\\n$$$$$$$\\\\   $$$$$$\\\\  $$\\\\      $$\\\\ $$$$$$$\\\\                                                            \\n$$  __$$\\\\ $$  __$$\\\\ $$$\\\\    $$$ |$$  __$$\\\\                                                           \\n$$ |  $$ |$$ /  $$ |$$$$\\\\  $$$$ |$$ |  $$ |    $$$$$$\\\\$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\  $$\\\\   $$\\\\ \\n$$$$$$$\\\\ |$$ |  $$ |$$\\\\$$\\\\$$ $$ |$$$$$$$\\\\ |    $$  _$$  _$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$ |  $$ |\\n$$  __$$\\\\ $$ |  $$ |$$ \\\\$$$  $$ |$$  __$$\\\\     $$ / $$ / $$ |$$ /  $$ |$$ |  $$ |$$$$$$$$ |$$ |  $$ |\\n$$ |  $$ |$$ |  $$ |$$ |\\\\$  /$$ |$$ |  $$ |    $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\\n$$$$$$$  | $$$$$$  |$$ | \\\\_/ $$ |$$$$$$$  |$$\\\\ $$ | $$ | $$ |\\\\$$$$$$  |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |\\n\\\\_______/  \\\\______/ \\\\__|     \\\\__|\\\\_______/ \\\\__|\\\\__| \\\\__| \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______| \\\\____$$ |\\n                                                                                           $$\\\\   $$ |\\n                                                                                           \\\\$$$$$$  |\\n    http://bomb.money                                                                      \\\\______/ \\n*/\\ncontract BondPMATIC is ERC20Burnable, Operator {\\n    /**\\n     * @notice Constructs the BOMB Bond ERC-20 contract.\\n     */\\n    constructor(string memory name_, string memory symbol_) public ERC20(name_, symbol_) {}\\n\\n    /**\\n     * @notice Operator mints basis bonds to a recipient\\n     * @param recipient_ The address of recipient\\n     * @param amount_ The amount of basis bonds to mint to\\n     * @return whether the process has been done\\n     */\\n    function mint(address recipient_, uint256 amount_) public onlyOperator returns (bool) {\\n        uint256 balanceBefore = balanceOf(recipient_);\\n        _mint(recipient_, amount_);\\n        uint256 balanceAfter = balanceOf(recipient_);\\n\\n        return balanceAfter > balanceBefore;\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function burnFrom(address account, uint256 amount) public override onlyOperator {\\n        super.burnFrom(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\n\\nimport \\\"./lib/SafeMath8.sol\\\";\\nimport \\\"./owner/Operator.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\n\\n/*\\n\\n$$$$$$$\\\\   $$$$$$\\\\  $$\\\\      $$\\\\ $$$$$$$\\\\                                                            \\n$$  __$$\\\\ $$  __$$\\\\ $$$\\\\    $$$ |$$  __$$\\\\                                                           \\n$$ |  $$ |$$ /  $$ |$$$$\\\\  $$$$ |$$ |  $$ |    $$$$$$\\\\$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\  $$\\\\   $$\\\\ \\n$$$$$$$\\\\ |$$ |  $$ |$$\\\\$$\\\\$$ $$ |$$$$$$$\\\\ |    $$  _$$  _$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$ |  $$ |\\n$$  __$$\\\\ $$ |  $$ |$$ \\\\$$$  $$ |$$  __$$\\\\     $$ / $$ / $$ |$$ /  $$ |$$ |  $$ |$$$$$$$$ |$$ |  $$ |\\n$$ |  $$ |$$ |  $$ |$$ |\\\\$  /$$ |$$ |  $$ |    $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\\n$$$$$$$  | $$$$$$  |$$ | \\\\_/ $$ |$$$$$$$  |$$\\\\ $$ | $$ | $$ |\\\\$$$$$$  |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |\\n\\\\_______/  \\\\______/ \\\\__|     \\\\__|\\\\_______/ \\\\__|\\\\__| \\\\__| \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______| \\\\____$$ |\\n                                                                                           $$\\\\   $$ |\\n                                                                                           \\\\$$$$$$  |\\n    http://bomb.money                                                                      \\\\______/ \\n*/\\ncontract Token is ERC20Burnable, Operator {\\n    using SafeMath8 for uint8;\\n    using SafeMath for uint256;\\n\\n    // Initial distribution for the first 24h genesis pools\\n    uint256 public constant INITIAL_GENESIS_POOL_DISTRIBUTION = 56000 ether;\\n    // Initial distribution for the day 2-5 SBOMB-BTCB LP -> BOMB pool\\n    uint256 public constant INITIAL_BOMB_POOL_DISTRIBUTION = 140000 ether;\\n    // Distribution for airdrops wallet\\n    uint256 public constant INITIAL_AIRDROP_WALLET_DISTRIBUTION = 300000 ether;\\n\\n    // Have the rewards been distributed to the pools\\n    bool public rewardPoolDistributed = false;\\n\\n    /* ================= Taxation =============== */\\n    // Address of the Oracle\\n    address public tokenOracle;\\n    // Address of the Tax Office\\n    address public taxOffice;\\n\\n    // Current tax rate\\n    uint256 public taxRate;\\n    // Price threshold below which taxes will get burned\\n    uint256 public burnThreshold = 1.10e18;\\n    // Address of the tax collector wallet\\n    address public taxCollectorAddress;\\n\\n    // Should the taxes be calculated using the tax tiers\\n    bool public autoCalculateTax;\\n\\n    // Tax Tiers\\n    uint256[] public taxTiersTwaps = [0, 5e17, 6e17, 7e17, 8e17, 9e17, 9.5e17, 1e18, 1.05e18, 1.10e18, 1.20e18, 1.30e18, 1.40e18, 1.50e18];\\n    uint256[] public taxTiersRates = [2000, 1900, 1800, 1700, 1600, 1500, 1500, 1500, 1500, 1400, 900, 400, 200, 100];\\n\\n    // Sender addresses excluded from Tax\\n    mapping(address => bool) public excludedAddresses;\\n\\n    event TaxOfficeTransferred(address oldAddress, address newAddress);\\n\\n    modifier onlyTaxOffice() {\\n        require(taxOffice == msg.sender, \\\"Caller is not the tax office\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperatorOrTaxOffice() {\\n        require(isOperator() || taxOffice == msg.sender, \\\"Caller is not the operator or the tax office\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Constructs the BOMB ERC-20 contract.\\n     */\\n    constructor(uint256 _taxRate, address _taxCollectorAddress) public ERC20(\\\"stoken.com\\\", \\\"SBOMB\\\") {\\n        // Mints 1 BOMB to contract creator for initial pool setup\\n        require(_taxRate < 10000, \\\"tax equal or bigger to 100%\\\");\\n        require(_taxCollectorAddress != address(0), \\\"tax collector address must be non-zero address\\\");\\n\\n        excludeAddress(address(this));\\n\\n        _mint(msg.sender, 4000 ether);\\n        taxRate = _taxRate;\\n        taxCollectorAddress = _taxCollectorAddress;\\n    }\\n\\n    /* ============= Taxation ============= */\\n\\n    function getTaxTiersTwapsCount() public view returns (uint256 count) {\\n        return taxTiersTwaps.length;\\n    }\\n\\n    function getTaxTiersRatesCount() public view returns (uint256 count) {\\n        return taxTiersRates.length;\\n    }\\n\\n    function isAddressExcluded(address _address) public view returns (bool) {\\n        return excludedAddresses[_address];\\n    }\\n\\n    function setTaxTiersTwap(uint8 _index, uint256 _value) public onlyTaxOffice returns (bool) {\\n        require(_index >= 0, \\\"Index has to be higher than 0\\\");\\n        require(_index < getTaxTiersTwapsCount(), \\\"Index has to lower than count of tax tiers\\\");\\n        if (_index > 0) {\\n            require(_value > taxTiersTwaps[_index - 1]);\\n        }\\n        if (_index < getTaxTiersTwapsCount().sub(1)) {\\n            require(_value < taxTiersTwaps[_index + 1]);\\n        }\\n        taxTiersTwaps[_index] = _value;\\n        return true;\\n    }\\n\\n    function setTaxTiersRate(uint8 _index, uint256 _value) public onlyTaxOffice returns (bool) {\\n        require(_index >= 0, \\\"Index has to be higher than 0\\\");\\n        require(_index < getTaxTiersRatesCount(), \\\"Index has to lower than count of tax tiers\\\");\\n        taxTiersRates[_index] = _value;\\n        return true;\\n    }\\n\\n    function setBurnThreshold(uint256 _burnThreshold) public onlyTaxOffice returns (bool) {\\n        burnThreshold = _burnThreshold;\\n    }\\n\\n    function _getTokenPrice() internal view returns (uint256 _tokenPrice) {\\n        try IOracle(tokenOracle).consult(address(this), 1e18) returns (uint144 _price) {\\n            return uint256(_price);\\n        } catch {\\n            revert(\\\"Token: failed to fetch BOMB price from Oracle\\\");\\n        }\\n    }\\n\\n    function _updateTaxRate(uint256 _tokenPrice) internal returns (uint256) {\\n        if (autoCalculateTax) {\\n            for (uint8 tierId = uint8(getTaxTiersTwapsCount()).sub(1); tierId >= 0; --tierId) {\\n                if (_tokenPrice >= taxTiersTwaps[tierId]) {\\n                    require(taxTiersRates[tierId] < 10000, \\\"tax equal or bigger to 100%\\\");\\n                    taxRate = taxTiersRates[tierId];\\n                    return taxTiersRates[tierId];\\n                }\\n            }\\n        }\\n    }\\n\\n    function enableAutoCalculateTax() public onlyTaxOffice {\\n        autoCalculateTax = true;\\n    }\\n\\n    function disableAutoCalculateTax() public onlyTaxOffice {\\n        autoCalculateTax = false;\\n    }\\n\\n    function setTokenOracle(address _tokenOracle) public onlyOperatorOrTaxOffice {\\n        require(_tokenOracle != address(0), \\\"oracle address cannot be 0 address\\\");\\n        tokenOracle = _tokenOracle;\\n    }\\n\\n    function setTaxOffice(address _taxOffice) public onlyOperatorOrTaxOffice {\\n        require(_taxOffice != address(0), \\\"tax office address cannot be 0 address\\\");\\n        emit TaxOfficeTransferred(taxOffice, _taxOffice);\\n        taxOffice = _taxOffice;\\n    }\\n\\n    function setTaxCollectorAddress(address _taxCollectorAddress) public onlyTaxOffice {\\n        require(_taxCollectorAddress != address(0), \\\"tax collector address must be non-zero address\\\");\\n        taxCollectorAddress = _taxCollectorAddress;\\n    }\\n\\n    function setTaxRate(uint256 _taxRate) public onlyTaxOffice {\\n        require(!autoCalculateTax, \\\"auto calculate tax cannot be enabled\\\");\\n        require(_taxRate < 10000, \\\"tax equal or bigger to 100%\\\");\\n        taxRate = _taxRate;\\n    }\\n\\n    function excludeAddress(address _address) public onlyOperatorOrTaxOffice returns (bool) {\\n        require(!excludedAddresses[_address], \\\"address can't be excluded\\\");\\n        excludedAddresses[_address] = true;\\n        return true;\\n    }\\n\\n    function includeAddress(address _address) public onlyOperatorOrTaxOffice returns (bool) {\\n        require(excludedAddresses[_address], \\\"address can't be included\\\");\\n        excludedAddresses[_address] = false;\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Operator mints BOMB to a recipient\\n     * @param recipient_ The address of recipient\\n     * @param amount_ The amount of BOMB to mint to\\n     * @return whether the process has been done\\n     */\\n    function mint(address recipient_, uint256 amount_) public onlyOperator returns (bool) {\\n        uint256 balanceBefore = balanceOf(recipient_);\\n        _mint(recipient_, amount_);\\n        uint256 balanceAfter = balanceOf(recipient_);\\n\\n        return balanceAfter > balanceBefore;\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function burnFrom(address account, uint256 amount) public override onlyOperator {\\n        super.burnFrom(account, amount);\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        uint256 currentTaxRate = 0;\\n        bool burnTax = false;\\n\\n        if (autoCalculateTax) {\\n            uint256 currentTokenPrice = _getTokenPrice();\\n            currentTaxRate = _updateTaxRate(currentTokenPrice);\\n            if (currentTokenPrice < burnThreshold) {\\n                burnTax = true;\\n            }\\n        }\\n\\n        if (currentTaxRate == 0 || excludedAddresses[sender]) {\\n            _transfer(sender, recipient, amount);\\n        } else {\\n            _transferWithTax(sender, recipient, amount, burnTax);\\n        }\\n\\n        _approve(sender, _msgSender(), allowance(sender, _msgSender()).sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function _transferWithTax(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool burnTax\\n    ) internal returns (bool) {\\n        uint256 taxAmount = amount.mul(taxRate).div(10000);\\n        uint256 amountAfterTax = amount.sub(taxAmount);\\n\\n        if (burnTax) {\\n            // Burn tax\\n            super.burnFrom(sender, taxAmount);\\n        } else {\\n            // Transfer tax to tax collector\\n            _transfer(sender, taxCollectorAddress, taxAmount);\\n        }\\n\\n        // Transfer amount after tax to recipient\\n        _transfer(sender, recipient, amountAfterTax);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice distribute to reward pool (only once)\\n     */\\n    function distributeReward(\\n        address _genesisPool,\\n        address _tokenPool,\\n        address _airdropWallet\\n    ) external onlyOperator {\\n        require(!rewardPoolDistributed, \\\"only can distribute once\\\");\\n        require(_genesisPool != address(0), \\\"!_genesisPool\\\");\\n        require(_tokenPool != address(0), \\\"!_tokenPool\\\");\\n        require(_airdropWallet != address(0), \\\"!_airdropWallet\\\");\\n        rewardPoolDistributed = true;\\n        _mint(_genesisPool, INITIAL_GENESIS_POOL_DISTRIBUTION);\\n        _mint(_tokenPool, INITIAL_BOMB_POOL_DISTRIBUTION);\\n        _mint(_airdropWallet, INITIAL_AIRDROP_WALLET_DISTRIBUTION);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        _token.transfer(_to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Share.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"./owner/Operator.sol\\\";\\n\\n/*\\n\\n$$$$$$$\\\\   $$$$$$\\\\  $$\\\\      $$\\\\ $$$$$$$\\\\                                                            \\n$$  __$$\\\\ $$  __$$\\\\ $$$\\\\    $$$ |$$  __$$\\\\                                                           \\n$$ |  $$ |$$ /  $$ |$$$$\\\\  $$$$ |$$ |  $$ |    $$$$$$\\\\$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\  $$\\\\   $$\\\\ \\n$$$$$$$\\\\ |$$ |  $$ |$$\\\\$$\\\\$$ $$ |$$$$$$$\\\\ |    $$  _$$  _$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$ |  $$ |\\n$$  __$$\\\\ $$ |  $$ |$$ \\\\$$$  $$ |$$  __$$\\\\     $$ / $$ / $$ |$$ /  $$ |$$ |  $$ |$$$$$$$$ |$$ |  $$ |\\n$$ |  $$ |$$ |  $$ |$$ |\\\\$  /$$ |$$ |  $$ |    $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\\n$$$$$$$  | $$$$$$  |$$ | \\\\_/ $$ |$$$$$$$  |$$\\\\ $$ | $$ | $$ |\\\\$$$$$$  |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |\\n\\\\_______/  \\\\______/ \\\\__|     \\\\__|\\\\_______/ \\\\__|\\\\__| \\\\__| \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______| \\\\____$$ |\\n                                                                                           $$\\\\   $$ |\\n                                                                                           \\\\$$$$$$  |\\n    http://bomb.money                                                                      \\\\______/ \\n*/\\ncontract Share is ERC20Burnable, Operator {\\n    using SafeMath for uint256;\\n\\n    // TOTAL MAX SUPPLY = 73,000 Share\\n    uint256 public constant FARMING_POOL_REWARD_ALLOCATION = 61350 ether;\\n\\n    uint256 public constant COMMUNITY_FUND_POOL_ALLOCATION = 7999 ether;\\n    uint256 public constant DEV_FUND_POOL_ALLOCATION = 3650 ether;\\n\\n    uint256 public constant VESTING_DURATION = 730 days;\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    uint256 public communityFundRewardRate;\\n    uint256 public devFundRewardRate;\\n\\n    address public communityFund;\\n    address public devFund;\\n\\n    uint256 public communityFundLastClaimed;\\n    uint256 public devFundLastClaimed;\\n\\n    bool public rewardPoolDistributed = false;\\n\\n    constructor(\\n        uint256 _startTime,\\n        address _communityFund,\\n        address _devFund\\n    ) public ERC20(\\\"PolyPegs Share\\\", \\\"PSHARE\\\") {\\n        _mint(msg.sender, 1 ether); // mint 100 Share for initial pools deployment\\n\\n        startTime = _startTime;\\n        endTime = startTime + VESTING_DURATION;\\n\\n        communityFundLastClaimed = startTime;\\n        devFundLastClaimed = startTime;\\n\\n        communityFundRewardRate = COMMUNITY_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n        devFundRewardRate = DEV_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n\\n        require(_devFund != address(0), \\\"Address cannot be 0\\\");\\n        devFund = _devFund;\\n\\n        require(_communityFund != address(0), \\\"Address cannot be 0\\\");\\n        communityFund = _communityFund;\\n    }\\n\\n    function setTreasuryFund(address _communityFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        communityFund = _communityFund;\\n    }\\n\\n    function setDevFund(address _devFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        require(_devFund != address(0), \\\"zero\\\");\\n        devFund = _devFund;\\n    }\\n\\n    function unclaimedTreasuryFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (communityFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(communityFundLastClaimed).mul(communityFundRewardRate);\\n    }\\n\\n    function unclaimedDevFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (devFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(devFundLastClaimed).mul(devFundRewardRate);\\n    }\\n\\n    /**\\n     * @dev Claim pending rewards to community and dev fund\\n     */\\n    function claimRewards() external {\\n        uint256 _pending = unclaimedTreasuryFund();\\n        if (_pending > 0 && communityFund != address(0)) {\\n            _mint(communityFund, _pending);\\n            communityFundLastClaimed = block.timestamp;\\n        }\\n        _pending = unclaimedDevFund();\\n        if (_pending > 0 && devFund != address(0)) {\\n            _mint(devFund, _pending);\\n            devFundLastClaimed = block.timestamp;\\n        }\\n    }\\n\\n    /**\\n     * @notice distribute to reward pool (only once)\\n     */\\n    function distributeReward(address _farmingIncentiveFund) external onlyOperator {\\n        require(!rewardPoolDistributed, \\\"only can distribute once\\\");\\n        require(_farmingIncentiveFund != address(0), \\\"!_farmingIncentiveFund\\\");\\n        rewardPoolDistributed = true;\\n        _mint(_farmingIncentiveFund, FARMING_POOL_REWARD_ALLOCATION);\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        _token.transfer(_to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Timelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/*\\n * Copyright 2020 Compound Labs, Inc.\\n *\\n * Redistribution and use in source and binary forms, with or without\\n * modification, are permitted provided that the following conditions are met:\\n *\\n * 1. Redistributions of source code must retain the above copyright notice,\\n * this list of conditions and the following disclaimer.\\n *\\n * 2. Redistributions in binary form must reproduce the above copyright notice,\\n * this list of conditions and the following disclaimer in the documentation\\n * and/or other materials provided with the distribution.\\n *\\n * 3. Neither the name of the copyright holder nor the names of its contributors\\n * may be used to endorse or promote products derived from this software without\\n * specific prior written permission.\\n *\\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\"\\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n */\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract Timelock {\\n    using SafeMath for uint256;\\n\\n    event NewAdmin(address indexed newAdmin);\\n    event NewPendingAdmin(address indexed newPendingAdmin);\\n    event NewDelay(uint256 indexed newDelay);\\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\\n\\n    uint256 public constant GRACE_PERIOD = 14 days;\\n    uint256 public constant MINIMUM_DELAY = 1 days;\\n    uint256 public constant MAXIMUM_DELAY = 30 days;\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    uint256 public delay;\\n\\n    mapping(bytes32 => bool) public queuedTransactions;\\n\\n    constructor(address admin_, uint256 delay_) public {\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::constructor: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n\\n        admin = admin_;\\n        delay = delay_;\\n    }\\n\\n    receive() external payable {}\\n\\n    function setDelay(uint256 delay_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\n        require(delay_ >= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\n        require(delay_ <= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n        delay = delay_;\\n\\n        emit NewDelay(delay);\\n    }\\n\\n    function acceptAdmin() public {\\n        require(msg.sender == pendingAdmin, \\\"Timelock::acceptAdmin: Call must come from pendingAdmin.\\\");\\n        admin = msg.sender;\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(admin);\\n    }\\n\\n    function setPendingAdmin(address pendingAdmin_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setPendingAdmin: Call must come from Timelock.\\\");\\n        pendingAdmin = pendingAdmin_;\\n\\n        emit NewPendingAdmin(pendingAdmin);\\n    }\\n\\n    function queueTransaction(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 eta\\n    ) public returns (bytes32) {\\n        require(msg.sender == admin, \\\"Timelock::queueTransaction: Call must come from admin.\\\");\\n        require(eta >= getBlockTimestamp().add(delay), \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = true;\\n\\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\\n        return txHash;\\n    }\\n\\n    function cancelTransaction(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 eta\\n    ) public {\\n        require(msg.sender == admin, \\\"Timelock::cancelTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = false;\\n\\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\\n    }\\n\\n    function executeTransaction(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 eta\\n    ) public payable returns (bytes memory) {\\n        require(msg.sender == admin, \\\"Timelock::executeTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        require(queuedTransactions[txHash], \\\"Timelock::executeTransaction: Transaction hasn't been queued.\\\");\\n        require(getBlockTimestamp() >= eta, \\\"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\\\");\\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \\\"Timelock::executeTransaction: Transaction is stale.\\\");\\n\\n        queuedTransactions[txHash] = false;\\n\\n        bytes memory callData;\\n\\n        if (bytes(signature).length == 0) {\\n            callData = data;\\n        } else {\\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n        }\\n\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\\n        require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\n\\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\n\\n        return returnData;\\n    }\\n\\n    function getBlockTimestamp() internal view returns (uint256) {\\n        // solium-disable-next-line security/no-block-members\\n        return block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Stats/StatsEMP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../interfaces/IRegulationStats.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\n\\ncontract StatsEMP is OwnableUpgradeSafe, IRegulationStats {\\n    using SafeMath for uint256;\\n\\n    struct Epoch {\\n        uint256 twap;\\n        uint256 expanded;\\n        uint256 bonded;\\n        uint256 redeemed;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // governance\\n    address public treasury;\\n\\n    // flags\\n    bool private initialized = false;\\n\\n    mapping(uint256 => Epoch) public epochInfo;\\n\\n    uint256 public totalBoardroomFunding;\\n    uint256 public totalDaoFunding;\\n    uint256 public totalDevFunding;\\n    uint256 public totalInsuranceFunding;\\n\\n    /* =================== Added variables (need to keep orders for proxy to work) =================== */\\n    // ...\\n\\n    /* =================== Events =================== */\\n\\n    /* =================== Modifier =================== */\\n\\n    modifier onlyTreasuryOrOwner() {\\n        require(treasury == msg.sender || owner() == msg.sender, \\\"!owner && !treasury\\\");\\n        _;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function getCurrentEpoch() public view returns (uint256) {\\n        return ITreasury(treasury).epoch();\\n    }\\n\\n    function getNextEpochPoint() public view returns (uint256) {\\n        return ITreasury(treasury).nextEpochPoint();\\n    }\\n\\n    function getEpochInfo(uint256 _start, uint256 _numEpochs) public view returns (uint256[] memory results) {\\n        results = new uint256[](_numEpochs * 4);\\n        uint256 _rindex = 0;\\n        for (uint256 i = 0; i < _numEpochs; i++) {\\n            Epoch memory _epochInfo = epochInfo[_start + i];\\n            results[_rindex++] = _epochInfo.twap;\\n            results[_rindex++] = _epochInfo.expanded;\\n            results[_rindex++] = _epochInfo.bonded;\\n            results[_rindex++] = _epochInfo.redeemed;\\n        }\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function initialize(address _treasury) external initializer {\\n        OwnableUpgradeSafe.__Ownable_init();\\n\\n        treasury = _treasury;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyOwner {\\n        treasury = _treasury;\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    function addEpochInfo(uint256 epochNumber, uint256 twap, uint256 expanded,\\n        uint256 boardroomFunding, uint256 daoFunding, uint256 devFunding, uint256 insuranceFunding) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.twap = twap;\\n        _epochInfo.expanded = expanded;\\n        totalBoardroomFunding = totalBoardroomFunding.add(boardroomFunding);\\n        totalDaoFunding = totalDaoFunding.add(daoFunding);\\n        totalDevFunding = totalDevFunding.add(devFunding);\\n        totalInsuranceFunding = totalInsuranceFunding.add(insuranceFunding);\\n    }\\n\\n    function addBonded(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.bonded = _epochInfo.bonded.add(added);\\n    }\\n\\n    function addRedeemed(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.redeemed = _epochInfo.redeemed.add(added);\\n    }\\n\\n    /* ========== EMERGENCY ========== */\\n\\n    function governanceRecoverUnsupported(IERC20 _token) external onlyOwner {\\n        _token.transfer(owner(), _token.balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n\\n\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n\\n    }\\n\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface ITreasury {\\n    function epoch() external view returns (uint256);\\n\\n    function nextEpochPoint() external view returns (uint256);\\n\\n    function getTokenPrice() external view returns (uint256);\\n\\n    function tokenPriceOne() external view returns (uint256);\\n\\n    function buyBonds(uint256 amount, uint256 targetPrice) external;\\n\\n    function redeemBonds(uint256 amount, uint256 targetPrice) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\nimport \\\"../Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract ContextUpgradeSafe is Initializable {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n\\n\\n    }\\n\\n\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.24 <0.7.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/Stats/StatsBUSD.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../interfaces/IRegulationStats.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\n\\ncontract StatsBUSD is OwnableUpgradeSafe, IRegulationStats {\\n    using SafeMath for uint256;\\n\\n    struct Epoch {\\n        uint256 twap;\\n        uint256 expanded;\\n        uint256 bonded;\\n        uint256 redeemed;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // governance\\n    address public treasury;\\n\\n    // flags\\n    bool private initialized = false;\\n\\n    mapping(uint256 => Epoch) public epochInfo;\\n\\n    uint256 public totalBoardroomFunding;\\n    uint256 public totalDaoFunding;\\n    uint256 public totalDevFunding;\\n    uint256 public totalInsuranceFunding;\\n\\n    /* =================== Added variables (need to keep orders for proxy to work) =================== */\\n    // ...\\n\\n    /* =================== Events =================== */\\n\\n    /* =================== Modifier =================== */\\n\\n    modifier onlyTreasuryOrOwner() {\\n        require(treasury == msg.sender || owner() == msg.sender, \\\"!owner && !treasury\\\");\\n        _;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function getCurrentEpoch() public view returns (uint256) {\\n        return ITreasury(treasury).epoch();\\n    }\\n\\n    function getNextEpochPoint() public view returns (uint256) {\\n        return ITreasury(treasury).nextEpochPoint();\\n    }\\n\\n    function getEpochInfo(uint256 _start, uint256 _numEpochs) public view returns (uint256[] memory results) {\\n        results = new uint256[](_numEpochs * 4);\\n        uint256 _rindex = 0;\\n        for (uint256 i = 0; i < _numEpochs; i++) {\\n            Epoch memory _epochInfo = epochInfo[_start + i];\\n            results[_rindex++] = _epochInfo.twap;\\n            results[_rindex++] = _epochInfo.expanded;\\n            results[_rindex++] = _epochInfo.bonded;\\n            results[_rindex++] = _epochInfo.redeemed;\\n        }\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function initialize(address _treasury) external initializer {\\n        OwnableUpgradeSafe.__Ownable_init();\\n\\n        treasury = _treasury;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyOwner {\\n        treasury = _treasury;\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    function addEpochInfo(uint256 epochNumber, uint256 twap, uint256 expanded,\\n        uint256 boardroomFunding, uint256 daoFunding, uint256 devFunding, uint256 insuranceFunding) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.twap = twap;\\n        _epochInfo.expanded = expanded;\\n        totalBoardroomFunding = totalBoardroomFunding.add(boardroomFunding);\\n        totalDaoFunding = totalDaoFunding.add(daoFunding);\\n        totalDevFunding = totalDevFunding.add(devFunding);\\n        totalInsuranceFunding = totalInsuranceFunding.add(insuranceFunding);\\n    }\\n\\n    function addBonded(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.bonded = _epochInfo.bonded.add(added);\\n    }\\n\\n    function addRedeemed(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.redeemed = _epochInfo.redeemed.add(added);\\n    }\\n\\n    /* ========== EMERGENCY ========== */\\n\\n    function governanceRecoverUnsupported(IERC20 _token) external onlyOwner {\\n        _token.transfer(owner(), _token.balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Stats/StatsBOMB.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../interfaces/IRegulationStats.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\n\\ncontract StatsBOMB is OwnableUpgradeSafe, IRegulationStats {\\n    using SafeMath for uint256;\\n\\n    struct Epoch {\\n        uint256 twap;\\n        uint256 expanded;\\n        uint256 bonded;\\n        uint256 redeemed;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // governance\\n    address public treasury;\\n\\n    // flags\\n    bool private initialized = false;\\n\\n    mapping(uint256 => Epoch) public epochInfo;\\n\\n    uint256 public totalBoardroomFunding;\\n    uint256 public totalDaoFunding;\\n    uint256 public totalDevFunding;\\n    uint256 public totalInsuranceFunding;\\n\\n    /* =================== Added variables (need to keep orders for proxy to work) =================== */\\n    // ...\\n\\n    /* =================== Events =================== */\\n\\n    /* =================== Modifier =================== */\\n\\n    modifier onlyTreasuryOrOwner() {\\n        require(treasury == msg.sender || owner() == msg.sender, \\\"!owner && !treasury\\\");\\n        _;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function getCurrentEpoch() public view returns (uint256) {\\n        return ITreasury(treasury).epoch();\\n    }\\n\\n    function getNextEpochPoint() public view returns (uint256) {\\n        return ITreasury(treasury).nextEpochPoint();\\n    }\\n\\n    function getEpochInfo(uint256 _start, uint256 _numEpochs) public view returns (uint256[] memory results) {\\n        results = new uint256[](_numEpochs * 4);\\n        uint256 _rindex = 0;\\n        for (uint256 i = 0; i < _numEpochs; i++) {\\n            Epoch memory _epochInfo = epochInfo[_start + i];\\n            results[_rindex++] = _epochInfo.twap;\\n            results[_rindex++] = _epochInfo.expanded;\\n            results[_rindex++] = _epochInfo.bonded;\\n            results[_rindex++] = _epochInfo.redeemed;\\n        }\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function initialize(address _treasury) external initializer {\\n        OwnableUpgradeSafe.__Ownable_init();\\n\\n        treasury = _treasury;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyOwner {\\n        treasury = _treasury;\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    function addEpochInfo(uint256 epochNumber, uint256 twap, uint256 expanded,\\n        uint256 boardroomFunding, uint256 daoFunding, uint256 devFunding, uint256 insuranceFunding) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.twap = twap;\\n        _epochInfo.expanded = expanded;\\n        totalBoardroomFunding = totalBoardroomFunding.add(boardroomFunding);\\n        totalDaoFunding = totalDaoFunding.add(daoFunding);\\n        totalDevFunding = totalDevFunding.add(devFunding);\\n        totalInsuranceFunding = totalInsuranceFunding.add(insuranceFunding);\\n    }\\n\\n    function addBonded(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.bonded = _epochInfo.bonded.add(added);\\n    }\\n\\n    function addRedeemed(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.redeemed = _epochInfo.redeemed.add(added);\\n    }\\n\\n    /* ========== EMERGENCY ========== */\\n\\n    function governanceRecoverUnsupported(IERC20 _token) external onlyOwner {\\n        _token.transfer(owner(), _token.balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Stats/StatsBNB.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../interfaces/IRegulationStats.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\n\\ncontract StatsBNB is OwnableUpgradeSafe, IRegulationStats {\\n    using SafeMath for uint256;\\n\\n    struct Epoch {\\n        uint256 twap;\\n        uint256 expanded;\\n        uint256 bonded;\\n        uint256 redeemed;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // governance\\n    address public treasury;\\n\\n    // flags\\n    bool private initialized = false;\\n\\n    mapping(uint256 => Epoch) public epochInfo;\\n\\n    uint256 public totalBoardroomFunding;\\n    uint256 public totalDaoFunding;\\n    uint256 public totalDevFunding;\\n    uint256 public totalInsuranceFunding;\\n\\n    /* =================== Added variables (need to keep orders for proxy to work) =================== */\\n    // ...\\n\\n    /* =================== Events =================== */\\n\\n    /* =================== Modifier =================== */\\n\\n    modifier onlyTreasuryOrOwner() {\\n        require(treasury == msg.sender || owner() == msg.sender, \\\"!owner && !treasury\\\");\\n        _;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function getCurrentEpoch() public view returns (uint256) {\\n        return ITreasury(treasury).epoch();\\n    }\\n\\n    function getNextEpochPoint() public view returns (uint256) {\\n        return ITreasury(treasury).nextEpochPoint();\\n    }\\n\\n    function getEpochInfo(uint256 _start, uint256 _numEpochs) public view returns (uint256[] memory results) {\\n        results = new uint256[](_numEpochs * 4);\\n        uint256 _rindex = 0;\\n        for (uint256 i = 0; i < _numEpochs; i++) {\\n            Epoch memory _epochInfo = epochInfo[_start + i];\\n            results[_rindex++] = _epochInfo.twap;\\n            results[_rindex++] = _epochInfo.expanded;\\n            results[_rindex++] = _epochInfo.bonded;\\n            results[_rindex++] = _epochInfo.redeemed;\\n        }\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function initialize(address _treasury) external initializer {\\n        OwnableUpgradeSafe.__Ownable_init();\\n\\n        treasury = _treasury;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyOwner {\\n        treasury = _treasury;\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    function addEpochInfo(uint256 epochNumber, uint256 twap, uint256 expanded,\\n        uint256 boardroomFunding, uint256 daoFunding, uint256 devFunding, uint256 insuranceFunding) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.twap = twap;\\n        _epochInfo.expanded = expanded;\\n        totalBoardroomFunding = totalBoardroomFunding.add(boardroomFunding);\\n        totalDaoFunding = totalDaoFunding.add(daoFunding);\\n        totalDevFunding = totalDevFunding.add(devFunding);\\n        totalInsuranceFunding = totalInsuranceFunding.add(insuranceFunding);\\n    }\\n\\n    function addBonded(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.bonded = _epochInfo.bonded.add(added);\\n    }\\n\\n    function addRedeemed(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.redeemed = _epochInfo.redeemed.add(added);\\n    }\\n\\n    /* ========== EMERGENCY ========== */\\n\\n    function governanceRecoverUnsupported(IERC20 _token) external onlyOwner {\\n        _token.transfer(owner(), _token.balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SimpleERCFund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"./owner/Operator.sol\\\";\\nimport \\\"./interfaces/ISimpleERCFund.sol\\\";\\n\\ncontract SimpleERCFund is ISimpleERCFund, Operator {\\n    using SafeERC20 for IERC20;\\n\\n    function deposit(\\n        address token,\\n        uint256 amount,\\n        string memory reason\\n    ) public override {\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n        emit Deposit(msg.sender, now, reason);\\n    }\\n\\n    function withdraw(\\n        address token,\\n        uint256 amount,\\n        address to,\\n        string memory reason\\n    ) public override onlyOperator {\\n        IERC20(token).safeTransfer(to, amount);\\n        emit Withdrawal(msg.sender, to, now, reason);\\n    }\\n\\n    event Deposit(address indexed from, uint256 indexed at, string reason);\\n    event Withdrawal(address indexed from, address indexed to, uint256 indexed at, string reason);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISimpleERCFund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface ISimpleERCFund {\\n    function deposit(\\n        address token,\\n        uint256 amount,\\n        string memory reason\\n    ) external;\\n\\n    function withdraw(\\n        address token,\\n        uint256 amount,\\n        address to,\\n        string memory reason\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/RegulationStats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./interfaces/IRegulationStats.sol\\\";\\nimport \\\"./interfaces/ITreasury.sol\\\";\\n\\ncontract RegulationStats is OwnableUpgradeSafe, IRegulationStats {\\n    using SafeMath for uint256;\\n\\n    struct Epoch {\\n        uint256 twap;\\n        uint256 expanded;\\n        uint256 bonded;\\n        uint256 redeemed;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // governance\\n    address public treasury;\\n\\n    // flags\\n    bool private initialized = false;\\n\\n    mapping(uint256 => Epoch) public epochInfo;\\n\\n    uint256 public totalBoardroomFunding;\\n    uint256 public totalDaoFunding;\\n    uint256 public totalDevFunding;\\n    uint256 public totalInsuranceFunding;\\n\\n    /* =================== Added variables (need to keep orders for proxy to work) =================== */\\n    // ...\\n\\n    /* =================== Events =================== */\\n\\n    /* =================== Modifier =================== */\\n\\n    modifier onlyTreasuryOrOwner() {\\n        require(treasury == msg.sender || owner() == msg.sender, \\\"!owner && !treasury\\\");\\n        _;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function getCurrentEpoch() public view returns (uint256) {\\n        return ITreasury(treasury).epoch();\\n    }\\n\\n    function getNextEpochPoint() public view returns (uint256) {\\n        return ITreasury(treasury).nextEpochPoint();\\n    }\\n\\n    function getEpochInfo(uint256 _start, uint256 _numEpochs) public view returns (uint256[] memory results) {\\n        results = new uint256[](_numEpochs * 4);\\n        uint256 _rindex = 0;\\n        for (uint256 i = 0; i < _numEpochs; i++) {\\n            Epoch memory _epochInfo = epochInfo[_start + i];\\n            results[_rindex++] = _epochInfo.twap;\\n            results[_rindex++] = _epochInfo.expanded;\\n            results[_rindex++] = _epochInfo.bonded;\\n            results[_rindex++] = _epochInfo.redeemed;\\n        }\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function initialize(address _treasury) external initializer {\\n        OwnableUpgradeSafe.__Ownable_init();\\n\\n        treasury = _treasury;\\n    }\\n\\n    function setTreasury(address _treasury) external onlyOwner {\\n        treasury = _treasury;\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    function addEpochInfo(uint256 epochNumber, uint256 twap, uint256 expanded,\\n        uint256 boardroomFunding, uint256 daoFunding, uint256 devFunding, uint256 insuranceFunding) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.twap = twap;\\n        _epochInfo.expanded = expanded;\\n        totalBoardroomFunding = totalBoardroomFunding.add(boardroomFunding);\\n        totalDaoFunding = totalDaoFunding.add(daoFunding);\\n        totalDevFunding = totalDevFunding.add(devFunding);\\n        totalInsuranceFunding = totalInsuranceFunding.add(insuranceFunding);\\n    }\\n\\n    function addBonded(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.bonded = _epochInfo.bonded.add(added);\\n    }\\n\\n    function addRedeemed(uint256 epochNumber, uint256 added) external override onlyTreasuryOrOwner {\\n        Epoch storage _epochInfo = epochInfo[epochNumber];\\n        _epochInfo.redeemed = _epochInfo.redeemed.add(added);\\n    }\\n\\n    /* ========== EMERGENCY ========== */\\n\\n    function governanceRecoverUnsupported(IERC20 _token) external onlyOwner {\\n        _token.transfer(owner(), _token.balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWrappedEth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWrappedEth is IERC20 {\\n    function deposit() external payable returns (uint256);\\n\\n    function withdraw(uint256 amount) external returns (uint256);\\n\\n}\\n\\n\"\r\n    },\r\n    \"contracts/distribution/ShareFarmRewardPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n// Note that this pool has no minter key of tSHARE (rewards).\\n// Instead, the governance will call tSHARE distributeReward method and send reward to this pool at the beginning.\\ncontract ShareFarmRewardPool {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // governance\\n    address public operator;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount; // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 token; // Address of LP token contract.\\n        uint256 allocPoint; // How many allocation points assigned to this pool. tSHAREs to distribute per block.\\n        uint256 lastRewardTime; // Last time that tSHAREs distribution occurs.\\n        uint256 accSharePerShare; // Accumulated tSHAREs per share, times 1e18. See below.\\n        bool isStarted; // if lastRewardTime has passed\\n    }\\n\\n    IERC20 public share;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n\\n    // Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n\\n    // The time when tSHARE mining starts.\\n    uint256 public poolStartTime;\\n\\n    // The time when tSHARE mining ends.\\n    uint256 public poolEndTime;\\n\\n    uint256 public sharePerSecond = 0.000972698 ether; // 73000 share / (730 days * 24h * 60min * 60s)\\n    uint256 public runningTime = 730 days; // 730 days\\n    uint256 public constant TOTAL_REWARDS = 61350 ether;\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 amount);\\n\\n    constructor(address _share, uint256 _poolStartTime) public {\\n        require(block.timestamp < _poolStartTime, \\\"late\\\");\\n        if (_share != address(0)) share = IERC20(_share);\\n        poolStartTime = _poolStartTime;\\n        poolEndTime = poolStartTime + runningTime;\\n        operator = msg.sender;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"SShareRewardPool: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    function checkPoolDuplicate(IERC20 _token) internal view {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            require(poolInfo[pid].token != _token, \\\"SShareRewardPool: existing pool?\\\");\\n        }\\n    }\\n\\n    // Add a new lp to the pool. Can only be called by the owner.\\n    function add(\\n        uint256 _allocPoint,\\n        IERC20 _token,\\n        bool _withUpdate,\\n        uint256 _lastRewardTime\\n    ) public onlyOperator {\\n        checkPoolDuplicate(_token);\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        if (block.timestamp < poolStartTime) {\\n            // chef is sleeping\\n            if (_lastRewardTime == 0) {\\n                _lastRewardTime = poolStartTime;\\n            } else {\\n                if (_lastRewardTime < poolStartTime) {\\n                    _lastRewardTime = poolStartTime;\\n                }\\n            }\\n        } else {\\n            // chef is cooking\\n            if (_lastRewardTime == 0 || _lastRewardTime < block.timestamp) {\\n                _lastRewardTime = block.timestamp;\\n            }\\n        }\\n        bool _isStarted = (_lastRewardTime <= poolStartTime) || (_lastRewardTime <= block.timestamp);\\n        poolInfo.push(PoolInfo({token: _token, allocPoint: _allocPoint, lastRewardTime: _lastRewardTime, accSharePerShare: 0, isStarted: _isStarted}));\\n        if (_isStarted) {\\n            totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n        }\\n    }\\n\\n    // Update the given pool's tSHARE allocation point. Can only be called by the owner.\\n    function set(uint256 _pid, uint256 _allocPoint) public onlyOperator {\\n        massUpdatePools();\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (pool.isStarted) {\\n            totalAllocPoint = totalAllocPoint.sub(pool.allocPoint).add(_allocPoint);\\n        }\\n        pool.allocPoint = _allocPoint;\\n    }\\n\\n    // Return accumulate rewards over the given _from to _to block.\\n    function getGeneratedReward(uint256 _fromTime, uint256 _toTime) public view returns (uint256) {\\n        if (_fromTime >= _toTime) return 0;\\n        if (_toTime >= poolEndTime) {\\n            if (_fromTime >= poolEndTime) return 0;\\n            if (_fromTime <= poolStartTime) return poolEndTime.sub(poolStartTime).mul(sharePerSecond);\\n            return poolEndTime.sub(_fromTime).mul(sharePerSecond);\\n        } else {\\n            if (_toTime <= poolStartTime) return 0;\\n            if (_fromTime <= poolStartTime) return _toTime.sub(poolStartTime).mul(sharePerSecond);\\n            return _toTime.sub(_fromTime).mul(sharePerSecond);\\n        }\\n    }\\n\\n    // View function to see pending tSHAREs on frontend.\\n    function pendingShare(uint256 _pid, address _user) external view returns (uint256) {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accSharePerShare = pool.accSharePerShare;\\n        uint256 tokenSupply = pool.token.balanceOf(address(this));\\n        if (block.timestamp > pool.lastRewardTime && tokenSupply != 0) {\\n            uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\\n            uint256 _shareReward = _generatedReward.mul(pool.allocPoint).div(totalAllocPoint);\\n            accSharePerShare = accSharePerShare.add(_shareReward.mul(1e18).div(tokenSupply));\\n        }\\n        return user.amount.mul(accSharePerShare).div(1e18).sub(user.rewardDebt);\\n    }\\n\\n    // Update reward variables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function updatePool(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.timestamp <= pool.lastRewardTime) {\\n            return;\\n        }\\n        uint256 tokenSupply = pool.token.balanceOf(address(this));\\n        if (tokenSupply == 0) {\\n            pool.lastRewardTime = block.timestamp;\\n            return;\\n        }\\n        if (!pool.isStarted) {\\n            pool.isStarted = true;\\n            totalAllocPoint = totalAllocPoint.add(pool.allocPoint);\\n        }\\n        if (totalAllocPoint > 0) {\\n            uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\\n            uint256 _shareReward = _generatedReward.mul(pool.allocPoint).div(totalAllocPoint);\\n            pool.accSharePerShare = pool.accSharePerShare.add(_shareReward.mul(1e18).div(tokenSupply));\\n        }\\n        pool.lastRewardTime = block.timestamp;\\n    }\\n\\n    // Deposit LP tokens.\\n    function deposit(uint256 _pid, uint256 _amount) public {\\n        address _sender = msg.sender;\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_sender];\\n        updatePool(_pid);\\n        if (user.amount > 0) {\\n            uint256 _pending = user.amount.mul(pool.accSharePerShare).div(1e18).sub(user.rewardDebt);\\n            if (_pending > 0) {\\n                safeShareTransfer(_sender, _pending);\\n                emit RewardPaid(_sender, _pending);\\n            }\\n        }\\n        if (_amount > 0) {\\n            pool.token.safeTransferFrom(_sender, address(this), _amount);\\n            user.amount = user.amount.add(_amount);\\n        }\\n        user.rewardDebt = user.amount.mul(pool.accSharePerShare).div(1e18);\\n        emit Deposit(_sender, _pid, _amount);\\n    }\\n\\n    // Withdraw LP tokens.\\n    function withdraw(uint256 _pid, uint256 _amount) public {\\n        address _sender = msg.sender;\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        updatePool(_pid);\\n        uint256 _pending = user.amount.mul(pool.accSharePerShare).div(1e18).sub(user.rewardDebt);\\n        if (_pending > 0) {\\n            safeShareTransfer(_sender, _pending);\\n            emit RewardPaid(_sender, _pending);\\n        }\\n        if (_amount > 0) {\\n            user.amount = user.amount.sub(_amount);\\n            pool.token.safeTransfer(_sender, _amount);\\n        }\\n        user.rewardDebt = user.amount.mul(pool.accSharePerShare).div(1e18);\\n        emit Withdraw(_sender, _pid, _amount);\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        uint256 _amount = user.amount;\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n        pool.token.safeTransfer(msg.sender, _amount);\\n        emit EmergencyWithdraw(msg.sender, _pid, _amount);\\n    }\\n\\n    // Safe share transfer function, just in case if rounding error causes pool to not have enough tSHAREs.\\n    function safeShareTransfer(address _to, uint256 _amount) internal {\\n        uint256 _shareBal = share.balanceOf(address(this));\\n        if (_shareBal > 0) {\\n            if (_amount > _shareBal) {\\n                share.safeTransfer(_to, _shareBal);\\n            } else {\\n                share.safeTransfer(_to, _amount);\\n            }\\n        }\\n    }\\n\\n    function setOperator(address _operator) external onlyOperator {\\n        operator = _operator;\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 amount,\\n        address to\\n    ) external onlyOperator {\\n        if (block.timestamp < poolEndTime + 90 days) {\\n            // do not allow to drain core token (tSHARE or lps) if less than 90 days after pool ends\\n            require(_token != share, \\\"share\\\");\\n            uint256 length = poolInfo.length;\\n            for (uint256 pid = 0; pid < length; ++pid) {\\n                PoolInfo storage pool = poolInfo[pid];\\n                require(_token != pool.token, \\\"pool.token\\\");\\n            }\\n        }\\n        _token.safeTransfer(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/distribution/GenesisMATICRewardPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n// Note that this pool has no minter key of BOMB (rewards).\\n// Instead, the governance will call BOMB distributeReward method and send reward to this pool at the beginning.\\ncontract GenesisMATICRewardPool {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // governance\\n    address public operator;\\n    address public reserveFund;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount; // How many tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 token; // Address of LP token contract.\\n        uint256 allocPoint; // How many allocation points assigned to this pool. BOMB to distribute.\\n        uint256 lastRewardTime; // Last time that BOMB distribution occurs.\\n        uint256 accTokenPerShare; // Accumulated BOMB per share, times 1e18. See below.\\n        bool isStarted; // if lastRewardBlock has passed\\n        //  uint16 depositFeeBP; // Deposit fee in basis points\\n    }\\n\\n    IERC20 public token;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n\\n    // Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n\\n    // The time when BOMB mining starts.\\n    uint256 public poolStartTime;\\n\\n    // The time when BOMB mining ends.\\n    uint256 public poolEndTime;\\n\\n    // TESTNET\\n    // uint256 public tokenPerSecond = 3.0555555 ether; // 11000 BOMB / (1h * 60min * 60s)\\n    // uint256 public runningTime = 24 hours; // 1 hours\\n    // uint256 public constant TOTAL_REWARDS = 11000 ether;\\n    // END TESTNET\\n\\n    // MAINNET\\n    uint256 public tokenPerSecond = 1.157407407 ether; //\\n    uint256 public runningTime = 1 days; // 1 days\\n    uint256 public constant TOTAL_REWARDS = 100000 ether;\\n    // END MAINNET\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 amount);\\n\\n    constructor(address _token, uint256 _poolStartTime) public {\\n        require(block.timestamp < _poolStartTime, \\\"late\\\");\\n        if (_token != address(0)) token = IERC20(_token);\\n        poolStartTime = _poolStartTime;\\n        poolEndTime = poolStartTime + runningTime;\\n        operator = msg.sender;\\n        reserveFund = msg.sender;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"TokenGenesisPool: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    function checkPoolDuplicate(IERC20 _token) internal view {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            require(poolInfo[pid].token != _token, \\\"TokenGenesisPool: existing pool?\\\");\\n        }\\n    }\\n\\n    // Add a new token to the pool. Can only be called by the owner.\\n    function add(\\n        uint256 _allocPoint,\\n        IERC20 _token,\\n        bool _withUpdate,\\n        uint256 _lastRewardTime\\n    ) public onlyOperator {\\n        checkPoolDuplicate(_token);\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        if (block.timestamp < poolStartTime) {\\n            // chef is sleeping\\n            if (_lastRewardTime == 0) {\\n                _lastRewardTime = poolStartTime;\\n            } else {\\n                if (_lastRewardTime < poolStartTime) {\\n                    _lastRewardTime = poolStartTime;\\n                }\\n            }\\n        } else {\\n            // chef is cooking\\n            if (_lastRewardTime == 0 || _lastRewardTime < block.timestamp) {\\n                _lastRewardTime = block.timestamp;\\n            }\\n        }\\n        bool _isStarted = (_lastRewardTime <= poolStartTime) || (_lastRewardTime <= block.timestamp);\\n        poolInfo.push(PoolInfo({token: _token, allocPoint: _allocPoint, lastRewardTime: _lastRewardTime, accTokenPerShare: 0, isStarted: _isStarted}));\\n        if (_isStarted) {\\n            totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n        }\\n    }\\n\\n    // Update the given pool's BOMB allocation point. Can only be called by the owner.\\n    function set(uint256 _pid, uint256 _allocPoint) public onlyOperator {\\n        massUpdatePools();\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (pool.isStarted) {\\n            totalAllocPoint = totalAllocPoint.sub(pool.allocPoint).add(_allocPoint);\\n        }\\n        pool.allocPoint = _allocPoint;\\n    }\\n\\n    // Return accumulate rewards over the given _from to _to block.\\n    function getGeneratedReward(uint256 _fromTime, uint256 _toTime) public view returns (uint256) {\\n        if (_fromTime >= _toTime) return 0;\\n        if (_toTime >= poolEndTime) {\\n            if (_fromTime >= poolEndTime) return 0;\\n            if (_fromTime <= poolStartTime) return poolEndTime.sub(poolStartTime).mul(tokenPerSecond);\\n            return poolEndTime.sub(_fromTime).mul(tokenPerSecond);\\n        } else {\\n            if (_toTime <= poolStartTime) return 0;\\n            if (_fromTime <= poolStartTime) return _toTime.sub(poolStartTime).mul(tokenPerSecond);\\n            return _toTime.sub(_fromTime).mul(tokenPerSecond);\\n        }\\n    }\\n\\n    // View function to see pending BOMB on frontend.\\n    function pendingReward(uint256 _pid, address _user) external view returns (uint256) {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accTokenPerShare = pool.accTokenPerShare;\\n        uint256 tokenSupply = pool.token.balanceOf(address(this));\\n        if (block.timestamp > pool.lastRewardTime && tokenSupply != 0) {\\n            uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\\n            uint256 _tokenReward = _generatedReward.mul(pool.allocPoint).div(totalAllocPoint);\\n            accTokenPerShare = accTokenPerShare.add(_tokenReward.mul(1e18).div(tokenSupply));\\n        }\\n        return user.amount.mul(accTokenPerShare).div(1e18).sub(user.rewardDebt);\\n    }\\n\\n    // Update reward variables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    function setReserveFund(address _reserveFund) external onlyOperator {\\n        reserveFund = _reserveFund;\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function updatePool(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.timestamp <= pool.lastRewardTime) {\\n            return;\\n        }\\n        uint256 tokenSupply = pool.token.balanceOf(address(this));\\n        if (tokenSupply == 0) {\\n            pool.lastRewardTime = block.timestamp;\\n            return;\\n        }\\n        if (!pool.isStarted) {\\n            pool.isStarted = true;\\n            totalAllocPoint = totalAllocPoint.add(pool.allocPoint);\\n        }\\n        if (totalAllocPoint > 0) {\\n            uint256 _generatedReward = getGeneratedReward(pool.lastRewardTime, block.timestamp);\\n            uint256 _tokenReward = _generatedReward.mul(pool.allocPoint).div(totalAllocPoint);\\n            pool.accTokenPerShare = pool.accTokenPerShare.add(_tokenReward.mul(1e18).div(tokenSupply));\\n        }\\n        pool.lastRewardTime = block.timestamp;\\n    }\\n\\n    // Deposit LP tokens.\\n    function deposit(uint256 _pid, uint256 _amount) public {\\n        address _sender = msg.sender;\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_sender];\\n        updatePool(_pid);\\n        if (user.amount > 0) {\\n            uint256 _pending = user.amount.mul(pool.accTokenPerShare).div(1e18).sub(user.rewardDebt);\\n            if (_pending > 0) {\\n                safeTokenTransfer(_sender, _pending);\\n                emit RewardPaid(_sender, _pending);\\n            }\\n        }\\n        if (_amount > 0) {\\n            IERC20 _depositToken = pool.token;\\n            uint256 _before = _depositToken.balanceOf(address(this));\\n            _depositToken.safeTransferFrom(msg.sender, address(this), _amount);\\n            uint256 _after = _depositToken.balanceOf(address(this));\\n            _amount = _after - _before;\\n            uint256 _depositFee = _amount.mul(300).div(10000);\\n            pool.token.safeTransfer(reserveFund, _depositFee);\\n            user.amount = user.amount.add(_amount).sub(_depositFee);\\n        }\\n        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e18);\\n        emit Deposit(_sender, _pid, _amount);\\n    }\\n\\n    // Withdraw LP tokens.\\n    function withdraw(uint256 _pid, uint256 _amount) public {\\n        address _sender = msg.sender;\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        updatePool(_pid);\\n        uint256 _pending = user.amount.mul(pool.accTokenPerShare).div(1e18).sub(user.rewardDebt);\\n        if (_pending > 0) {\\n            safeTokenTransfer(_sender, _pending);\\n            emit RewardPaid(_sender, _pending);\\n        }\\n        if (_amount > 0) {\\n            user.amount = user.amount.sub(_amount);\\n            pool.token.safeTransfer(_sender, _amount);\\n        }\\n        user.rewardDebt = user.amount.mul(pool.accTokenPerShare).div(1e18);\\n        emit Withdraw(_sender, _pid, _amount);\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        uint256 _amount = user.amount;\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n        pool.token.safeTransfer(msg.sender, _amount);\\n        emit EmergencyWithdraw(msg.sender, _pid, _amount);\\n    }\\n\\n    // Safe BOMB transfer function, just in case if rounding error causes pool to not have enough BOMBs.\\n    function safeTokenTransfer(address _to, uint256 _amount) internal {\\n        uint256 _tokenBalance = token.balanceOf(address(this));\\n        if (_tokenBalance > 0) {\\n            if (_amount > _tokenBalance) {\\n                token.safeTransfer(_to, _tokenBalance);\\n            } else {\\n                token.safeTransfer(_to, _amount);\\n            }\\n        }\\n    }\\n\\n    function setOperator(address _operator) external onlyOperator {\\n        operator = _operator;\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 amount,\\n        address to\\n    ) external onlyOperator {\\n        if (block.timestamp < poolEndTime + 90 days) {\\n            // do not allow to drain core token (BOMB or lps) if less than 90 days after pool ends\\n            require(_token != token, \\\"token\\\");\\n            uint256 length = poolInfo.length;\\n            for (uint256 pid = 0; pid < length; ++pid) {\\n                PoolInfo storage pool = poolInfo[pid];\\n                require(_token != pool.token, \\\"pool.token\\\");\\n            }\\n        }\\n        _token.safeTransfer(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Boardroom/BoardroomPMATIC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../utils/ContractGuard.sol\\\";\\nimport \\\"../interfaces/IBasisAsset.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\n\\n/*\\n\\n$$$$$$$\\\\   $$$$$$\\\\  $$\\\\      $$\\\\ $$$$$$$\\\\                                                            \\n$$  __$$\\\\ $$  __$$\\\\ $$$\\\\    $$$ |$$  __$$\\\\                                                           \\n$$ |  $$ |$$ /  $$ |$$$$\\\\  $$$$ |$$ |  $$ |    $$$$$$\\\\$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\  $$\\\\   $$\\\\ \\n$$$$$$$\\\\ |$$ |  $$ |$$\\\\$$\\\\$$ $$ |$$$$$$$\\\\ |    $$  _$$  _$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$ |  $$ |\\n$$  __$$\\\\ $$ |  $$ |$$ \\\\$$$  $$ |$$  __$$\\\\     $$ / $$ / $$ |$$ /  $$ |$$ |  $$ |$$$$$$$$ |$$ |  $$ |\\n$$ |  $$ |$$ |  $$ |$$ |\\\\$  /$$ |$$ |  $$ |    $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\\n$$$$$$$  | $$$$$$  |$$ | \\\\_/ $$ |$$$$$$$  |$$\\\\ $$ | $$ | $$ |\\\\$$$$$$  |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |\\n\\\\_______/  \\\\______/ \\\\__|     \\\\__|\\\\_______/ \\\\__|\\\\__| \\\\__| \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______| \\\\____$$ |\\n                                                                                           $$\\\\   $$ |\\n                                                                                           \\\\$$$$$$  |\\n    http://bomb.money                                                                      \\\\______/ \\n*/\\ncontract BoardroomPMATIC is ContractGuard {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    /* ========== DATA STRUCTURES ========== */\\n\\n    struct Memberseat {\\n        uint256 lastSnapshotIndex;\\n        uint256 rewardEarned;\\n        uint256 epochTimerStart;\\n    }\\n\\n    struct BoardroomSnapshot {\\n        uint256 time;\\n        uint256 rewardReceived;\\n        uint256 rewardPerShare;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IERC20 public share;\\n\\n    uint256 private _totalSupply;\\n    mapping(address => uint256) private _balances;\\n\\n    // governance\\n    address public operator;\\n\\n    // flags\\n    bool public initialized = false;\\n\\n    IERC20 public token;\\n    ITreasury public treasury;\\n\\n    mapping(address => Memberseat) public members;\\n    BoardroomSnapshot[] public boardroomHistory;\\n\\n    uint256 public withdrawLockupEpochs;\\n    uint256 public rewardLockupEpochs;\\n\\n    address public reserveFund;\\n    uint256 public withdrawFee;\\n    uint256 public stakeFee;\\n    uint256 public withdrawFeeMultiplier; // 100 means no multiplier\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Initialized(address indexed executor, uint256 at);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n    event RewardAdded(address indexed user, uint256 reward);\\n\\n    /* ========== Modifiers =============== */\\n\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"Boardroom: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    modifier memberExists() {\\n        require(balanceOf(msg.sender) > 0, \\\"Boardroom: The member does not exist\\\");\\n        _;\\n    }\\n\\n    modifier updateReward(address member) {\\n        if (member != address(0)) {\\n            Memberseat memory seat = members[member];\\n            seat.rewardEarned = earned(member);\\n            seat.lastSnapshotIndex = latestSnapshotIndex();\\n            members[member] = seat;\\n        }\\n        _;\\n    }\\n\\n    modifier notInitialized() {\\n        require(!initialized, \\\"Boardroom: already initialized\\\");\\n        _;\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function initialize(\\n        IERC20 _token,\\n        IERC20 _share,\\n        ITreasury _treasury\\n    ) public notInitialized {\\n        token = _token;\\n        share = _share;\\n        treasury = _treasury;\\n\\n        stakeFee = 2;\\n        withdrawFee = 2;\\n        withdrawFeeMultiplier = 100;\\n\\n        BoardroomSnapshot memory genesisSnapshot = BoardroomSnapshot({time: block.number, rewardReceived: 0, rewardPerShare: 0});\\n        boardroomHistory.push(genesisSnapshot);\\n\\n        withdrawLockupEpochs = 2; // Lock for 6 epochs (36h) before release withdraw\\n        rewardLockupEpochs = 1; // Lock for 3 epochs (18h) before release claimReward\\n\\n        initialized = true;\\n        operator = msg.sender;\\n        emit Initialized(msg.sender, block.number);\\n    }\\n\\n    function setOperator(address _operator) external onlyOperator {\\n        operator = _operator;\\n    }\\n\\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external onlyOperator {\\n        require(_withdrawLockupEpochs >= _rewardLockupEpochs && _withdrawLockupEpochs <= 42, \\\"_withdrawLockupEpochs: out of range\\\"); // <= 2 week\\n        withdrawLockupEpochs = _withdrawLockupEpochs;\\n        rewardLockupEpochs = _rewardLockupEpochs;\\n    }\\n\\n    function setReserveFund(address _reserveFund) external onlyOperator {\\n        require(_reserveFund != address(0), \\\"reserveFund address cannot be 0 address\\\");\\n        reserveFund = _reserveFund;\\n    }\\n\\n    function setStakeFee(uint256 _stakeFee) external onlyOperator {\\n        require(_stakeFee <= 5, \\\"Max stake fee is 5%\\\");\\n        stakeFee = _stakeFee;\\n    }\\n\\n    function setWithdrawFee(uint256 _withdrawFee) external onlyOperator {\\n        require(_withdrawFee <= 20, \\\"Max withdraw fee is 20%\\\");\\n        withdrawFee = _withdrawFee;\\n    }\\n\\n    function setWithdrawFeeMultiplier(uint256 _withdrawFeeMultiplier) external onlyOperator {\\n        require(_withdrawFeeMultiplier >= 100 && _withdrawFeeMultiplier <= 1000, \\\"withdraw fee multiplier must be 1x to 10x\\\");\\n        withdrawFeeMultiplier = _withdrawFeeMultiplier;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    // =========== Snapshot getters\\n    function latestSnapshotIndex() public view returns (uint256) {\\n        return boardroomHistory.length.sub(1);\\n    }\\n\\n    function getLatestSnapshot() internal view returns (BoardroomSnapshot memory) {\\n        return boardroomHistory[latestSnapshotIndex()];\\n    }\\n\\n    function getLastSnapshotIndexOf(address member) public view returns (uint256) {\\n        return members[member].lastSnapshotIndex;\\n    }\\n\\n    function getLastSnapshotOf(address member) internal view returns (BoardroomSnapshot memory) {\\n        return boardroomHistory[getLastSnapshotIndexOf(member)];\\n    }\\n\\n    function canWithdraw(address member) external view returns (bool) {\\n        return members[member].epochTimerStart.add(withdrawLockupEpochs) <= treasury.epoch();\\n    }\\n\\n    function canClaimReward(address member) external view returns (bool) {\\n        return members[member].epochTimerStart.add(rewardLockupEpochs) <= treasury.epoch();\\n    }\\n\\n    function epoch() external view returns (uint256) {\\n        return treasury.epoch();\\n    }\\n\\n    function nextEpochPoint() external view returns (uint256) {\\n        return treasury.nextEpochPoint();\\n    }\\n\\n    function getTokenPrice() external view returns (uint256) {\\n        return treasury.getTokenPrice();\\n    }\\n\\n    // =========== Member getters\\n\\n    function rewardPerShare() public view returns (uint256) {\\n        return getLatestSnapshot().rewardPerShare;\\n    }\\n\\n    function earned(address member) public view returns (uint256) {\\n        uint256 latestRPS = getLatestSnapshot().rewardPerShare;\\n        uint256 storedRPS = getLastSnapshotOf(member).rewardPerShare;\\n\\n        return balanceOf(member).mul(latestRPS.sub(storedRPS)).div(1e18).add(members[member].rewardEarned);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function stake(uint256 amount) public onlyOneBlock updateReward(msg.sender) {\\n        require(amount > 0, \\\"Boardroom: Cannot stake 0\\\");\\n        share.safeTransferFrom(msg.sender, address(this), amount);\\n        if (stakeFee > 0) {\\n            uint256 feeAmount = amount.mul(stakeFee).div(100);\\n            share.safeTransfer(reserveFund, feeAmount);\\n            amount = amount.sub(feeAmount);\\n        }\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        members[msg.sender].epochTimerStart = treasury.epoch(); // reset timer\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    function withdraw(uint256 amount) public onlyOneBlock memberExists updateReward(msg.sender) {\\n        require(amount > 0, \\\"Boardroom: Cannot withdraw 0\\\");\\n        require(members[msg.sender].epochTimerStart.add(withdrawLockupEpochs) <= treasury.epoch(), \\\"Boardroom: still in withdraw lockup\\\");\\n        claimReward();\\n        uint256 memberShare = _balances[msg.sender];\\n        require(memberShare >= amount, \\\"Boardroom: withdraw request greater than staked amount\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = memberShare.sub(amount);\\n        if (withdrawFee > 0) {\\n            uint256 currentPrice = treasury.getTokenPrice();\\n            uint256 targetPrice = treasury.tokenPriceOne();\\n            if (currentPrice < targetPrice) {\\n                withdrawFee = withdrawFee.mul(withdrawFeeMultiplier).div(100);\\n            }\\n            uint256 feeAmount = amount.mul(withdrawFee).div(100);\\n            share.safeTransfer(reserveFund, feeAmount);\\n            amount = amount.sub(feeAmount);\\n        }\\n        share.safeTransfer(msg.sender, amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function exit() external {\\n        withdraw(balanceOf(msg.sender));\\n    }\\n\\n    function claimReward() public updateReward(msg.sender) {\\n        uint256 reward = members[msg.sender].rewardEarned;\\n        if (reward > 0) {\\n            require(members[msg.sender].epochTimerStart.add(rewardLockupEpochs) <= treasury.epoch(), \\\"Boardroom: still in reward lockup\\\");\\n            members[msg.sender].epochTimerStart = treasury.epoch(); // reset timer\\n            members[msg.sender].rewardEarned = 0;\\n            token.safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    function allocateSeigniorage(uint256 amount) external onlyOneBlock onlyOperator {\\n        require(amount > 0, \\\"Boardroom: Cannot allocate 0\\\");\\n        require(totalSupply() > 0, \\\"Boardroom: Cannot allocate when totalSupply is 0\\\");\\n\\n        // Create & add new snapshot\\n        uint256 prevRPS = getLatestSnapshot().rewardPerShare;\\n        uint256 nextRPS = prevRPS.add(amount.mul(1e18).div(totalSupply()));\\n\\n        BoardroomSnapshot memory newSnapshot = BoardroomSnapshot({time: block.number, rewardReceived: amount, rewardPerShare: nextRPS});\\n        boardroomHistory.push(newSnapshot);\\n\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\n        emit RewardAdded(msg.sender, amount);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        // do not allow to drain core tokens\\n        require(address(_token) != address(token), \\\"token\\\");\\n        require(address(_token) != address(share), \\\"share\\\");\\n        _token.safeTransfer(_to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Boardroom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"./utils/ContractGuard.sol\\\";\\nimport \\\"./interfaces/IBasisAsset.sol\\\";\\nimport \\\"./interfaces/ITreasury.sol\\\";\\n\\n\\n/*\\n\\n$$$$$$$\\\\   $$$$$$\\\\  $$\\\\      $$\\\\ $$$$$$$\\\\                                                            \\n$$  __$$\\\\ $$  __$$\\\\ $$$\\\\    $$$ |$$  __$$\\\\                                                           \\n$$ |  $$ |$$ /  $$ |$$$$\\\\  $$$$ |$$ |  $$ |    $$$$$$\\\\$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\  $$\\\\   $$\\\\ \\n$$$$$$$\\\\ |$$ |  $$ |$$\\\\$$\\\\$$ $$ |$$$$$$$\\\\ |    $$  _$$  _$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$ |  $$ |\\n$$  __$$\\\\ $$ |  $$ |$$ \\\\$$$  $$ |$$  __$$\\\\     $$ / $$ / $$ |$$ /  $$ |$$ |  $$ |$$$$$$$$ |$$ |  $$ |\\n$$ |  $$ |$$ |  $$ |$$ |\\\\$  /$$ |$$ |  $$ |    $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\\n$$$$$$$  | $$$$$$  |$$ | \\\\_/ $$ |$$$$$$$  |$$\\\\ $$ | $$ | $$ |\\\\$$$$$$  |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |\\n\\\\_______/  \\\\______/ \\\\__|     \\\\__|\\\\_______/ \\\\__|\\\\__| \\\\__| \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______| \\\\____$$ |\\n                                                                                           $$\\\\   $$ |\\n                                                                                           \\\\$$$$$$  |\\n    http://bomb.money                                                                      \\\\______/ \\n*/\\ncontract Boardroom is ContractGuard {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using SafeMath for uint256;\\n\\n    /* ========== DATA STRUCTURES ========== */\\n\\n    struct Memberseat {\\n        uint256 lastSnapshotIndex;\\n        uint256 rewardEarned;\\n        uint256 epochTimerStart;\\n    }\\n\\n    struct BoardroomSnapshot {\\n        uint256 time;\\n        uint256 rewardReceived;\\n        uint256 rewardPerShare;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IERC20 public share;\\n\\n    uint256 private _totalSupply;\\n    mapping(address => uint256) private _balances;\\n\\n    // governance\\n    address public operator;\\n\\n    // flags\\n    bool public initialized = false;\\n\\n    IERC20 public token;\\n    ITreasury public treasury;\\n\\n    mapping(address => Memberseat) public members;\\n    BoardroomSnapshot[] public boardroomHistory;\\n\\n    uint256 public withdrawLockupEpochs;\\n    uint256 public rewardLockupEpochs;\\n\\n    address public reserveFund;\\n    uint256 public withdrawFee;\\n    uint256 public stakeFee;\\n    uint256 public withdrawFeeMultiplier; // 100 means no multiplier\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Initialized(address indexed executor, uint256 at);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n    event RewardAdded(address indexed user, uint256 reward);\\n\\n    /* ========== Modifiers =============== */\\n\\n    modifier onlyOperator() {\\n        require(operator == msg.sender, \\\"Boardroom: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    modifier memberExists() {\\n        require(balanceOf(msg.sender) > 0, \\\"Boardroom: The member does not exist\\\");\\n        _;\\n    }\\n\\n    modifier updateReward(address member) {\\n        if (member != address(0)) {\\n            Memberseat memory seat = members[member];\\n            seat.rewardEarned = earned(member);\\n            seat.lastSnapshotIndex = latestSnapshotIndex();\\n            members[member] = seat;\\n        }\\n        _;\\n    }\\n\\n    modifier notInitialized() {\\n        require(!initialized, \\\"Boardroom: already initialized\\\");\\n        _;\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function initialize(\\n        IERC20 _token,\\n        IERC20 _share,\\n        ITreasury _treasury\\n    ) public notInitialized {\\n        token = _token;\\n        share = _share;\\n        treasury = _treasury;\\n\\n        stakeFee = 2;\\n        withdrawFee = 2;\\n        withdrawFeeMultiplier = 200;\\n\\n        BoardroomSnapshot memory genesisSnapshot = BoardroomSnapshot({time: block.number, rewardReceived: 0, rewardPerShare: 0});\\n        boardroomHistory.push(genesisSnapshot);\\n\\n        withdrawLockupEpochs = 2; // Lock for 6 epochs (36h) before release withdraw\\n        rewardLockupEpochs = 1; // Lock for 3 epochs (18h) before release claimReward\\n\\n        initialized = true;\\n        operator = msg.sender;\\n        emit Initialized(msg.sender, block.number);\\n    }\\n\\n    function setOperator(address _operator) external onlyOperator {\\n        operator = _operator;\\n    }\\n\\n    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external onlyOperator {\\n        require(_withdrawLockupEpochs >= _rewardLockupEpochs && _withdrawLockupEpochs <= 42, \\\"_withdrawLockupEpochs: out of range\\\"); // <= 2 week\\n        withdrawLockupEpochs = _withdrawLockupEpochs;\\n        rewardLockupEpochs = _rewardLockupEpochs;\\n    }\\n\\n    function setReserveFund(address _reserveFund) external onlyOperator {\\n        require(_reserveFund != address(0), \\\"reserveFund address cannot be 0 address\\\");\\n        reserveFund = _reserveFund;\\n    }\\n\\n    function setStakeFee(uint256 _stakeFee) external onlyOperator {\\n        require(_stakeFee <= 5, \\\"Max stake fee is 5%\\\");\\n        stakeFee = _stakeFee;\\n    }\\n\\n    function setWithdrawFee(uint256 _withdrawFee) external onlyOperator {\\n        require(_withdrawFee <= 20, \\\"Max withdraw fee is 20%\\\");\\n        withdrawFee = _withdrawFee;\\n    }\\n\\n    function setWithdrawFeeMultiplier(uint256 _withdrawFeeMultiplier) external onlyOperator {\\n        require(_withdrawFeeMultiplier >= 100 && _withdrawFeeMultiplier <= 1000, \\\"withdraw fee multiplier must be 1x to 10x\\\");\\n        withdrawFeeMultiplier = _withdrawFeeMultiplier;\\n    }\\n\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    // =========== Snapshot getters\\n    function latestSnapshotIndex() public view returns (uint256) {\\n        return boardroomHistory.length.sub(1);\\n    }\\n\\n    function getLatestSnapshot() internal view returns (BoardroomSnapshot memory) {\\n        return boardroomHistory[latestSnapshotIndex()];\\n    }\\n\\n    function getLastSnapshotIndexOf(address member) public view returns (uint256) {\\n        return members[member].lastSnapshotIndex;\\n    }\\n\\n    function getLastSnapshotOf(address member) internal view returns (BoardroomSnapshot memory) {\\n        return boardroomHistory[getLastSnapshotIndexOf(member)];\\n    }\\n\\n    function canWithdraw(address member) external view returns (bool) {\\n        return members[member].epochTimerStart.add(withdrawLockupEpochs) <= treasury.epoch();\\n    }\\n\\n    function canClaimReward(address member) external view returns (bool) {\\n        return members[member].epochTimerStart.add(rewardLockupEpochs) <= treasury.epoch();\\n    }\\n\\n    function epoch() external view returns (uint256) {\\n        return treasury.epoch();\\n    }\\n\\n    function nextEpochPoint() external view returns (uint256) {\\n        return treasury.nextEpochPoint();\\n    }\\n\\n    function getTokenPrice() external view returns (uint256) {\\n        return treasury.getTokenPrice();\\n    }\\n\\n    // =========== Member getters\\n\\n    function rewardPerShare() public view returns (uint256) {\\n        return getLatestSnapshot().rewardPerShare;\\n    }\\n\\n    function earned(address member) public view returns (uint256) {\\n        uint256 latestRPS = getLatestSnapshot().rewardPerShare;\\n        uint256 storedRPS = getLastSnapshotOf(member).rewardPerShare;\\n\\n        return balanceOf(member).mul(latestRPS.sub(storedRPS)).div(1e18).add(members[member].rewardEarned);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n\\n    function stake(uint256 amount) public onlyOneBlock updateReward(msg.sender) {\\n        require(amount > 0, \\\"Boardroom: Cannot stake 0\\\");\\n        share.safeTransferFrom(msg.sender, address(this), amount);\\n        if (stakeFee > 0) {\\n            uint256 feeAmount = amount.mul(stakeFee).div(100);\\n            share.safeTransfer(reserveFund, feeAmount);\\n            amount = amount.sub(feeAmount);\\n        }\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        members[msg.sender].epochTimerStart = treasury.epoch(); // reset timer\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n\\n    function withdraw(uint256 amount) public onlyOneBlock memberExists updateReward(msg.sender) {\\n        require(amount > 0, \\\"Boardroom: Cannot withdraw 0\\\");\\n        require(members[msg.sender].epochTimerStart.add(withdrawLockupEpochs) <= treasury.epoch(), \\\"Boardroom: still in withdraw lockup\\\");\\n        claimReward();\\n        uint256 memberShare = _balances[msg.sender];\\n        require(memberShare >= amount, \\\"Boardroom: withdraw request greater than staked amount\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = memberShare.sub(amount);\\n        if (withdrawFee > 0) {\\n            uint256 currentPrice = treasury.getTokenPrice();\\n            uint256 targetPrice = treasury.tokenPriceOne();\\n            if (currentPrice < targetPrice) {\\n                withdrawFee = withdrawFee.mul(withdrawFeeMultiplier).div(100);\\n            }\\n            uint256 feeAmount = amount.mul(withdrawFee).div(100);\\n            share.safeTransfer(reserveFund, feeAmount);\\n            amount = amount.sub(feeAmount);\\n        }\\n        share.safeTransfer(msg.sender, amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n\\n    function exit() external {\\n        withdraw(balanceOf(msg.sender));\\n    }\\n\\n    function claimReward() public updateReward(msg.sender) {\\n        uint256 reward = members[msg.sender].rewardEarned;\\n        if (reward > 0) {\\n            require(members[msg.sender].epochTimerStart.add(rewardLockupEpochs) <= treasury.epoch(), \\\"Boardroom: still in reward lockup\\\");\\n            members[msg.sender].epochTimerStart = treasury.epoch(); // reset timer\\n            members[msg.sender].rewardEarned = 0;\\n            token.safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    function allocateSeigniorage(uint256 amount) external onlyOneBlock onlyOperator {\\n        require(amount > 0, \\\"Boardroom: Cannot allocate 0\\\");\\n        require(totalSupply() > 0, \\\"Boardroom: Cannot allocate when totalSupply is 0\\\");\\n\\n        // Create & add new snapshot\\n        uint256 prevRPS = getLatestSnapshot().rewardPerShare;\\n        uint256 nextRPS = prevRPS.add(amount.mul(1e18).div(totalSupply()));\\n\\n        BoardroomSnapshot memory newSnapshot = BoardroomSnapshot({time: block.number, rewardReceived: amount, rewardPerShare: nextRPS});\\n        boardroomHistory.push(newSnapshot);\\n\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\n        emit RewardAdded(msg.sender, amount);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        // do not allow to drain core tokens\\n        require(address(_token) != address(token), \\\"token\\\");\\n        require(address(_token) != address(share), \\\"share\\\");\\n        _token.safeTransfer(_to, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Oracles/OraclePMATIC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../lib/Babylonian.sol\\\";\\nimport \\\"../lib/FixedPoint.sol\\\";\\nimport \\\"../lib/UniswapV2OracleLibrary.sol\\\";\\nimport \\\"../utils/Epoch.sol\\\";\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\n\\n/*\\n\\n$$$$$$$\\\\   $$$$$$\\\\  $$\\\\      $$\\\\ $$$$$$$\\\\                                                            \\n$$  __$$\\\\ $$  __$$\\\\ $$$\\\\    $$$ |$$  __$$\\\\                                                           \\n$$ |  $$ |$$ /  $$ |$$$$\\\\  $$$$ |$$ |  $$ |    $$$$$$\\\\$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\  $$\\\\   $$\\\\ \\n$$$$$$$\\\\ |$$ |  $$ |$$\\\\$$\\\\$$ $$ |$$$$$$$\\\\ |    $$  _$$  _$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$ |  $$ |\\n$$  __$$\\\\ $$ |  $$ |$$ \\\\$$$  $$ |$$  __$$\\\\     $$ / $$ / $$ |$$ /  $$ |$$ |  $$ |$$$$$$$$ |$$ |  $$ |\\n$$ |  $$ |$$ |  $$ |$$ |\\\\$  /$$ |$$ |  $$ |    $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\\n$$$$$$$  | $$$$$$  |$$ | \\\\_/ $$ |$$$$$$$  |$$\\\\ $$ | $$ | $$ |\\\\$$$$$$  |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |\\n\\\\_______/  \\\\______/ \\\\__|     \\\\__|\\\\_______/ \\\\__|\\\\__| \\\\__| \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______| \\\\____$$ |\\n                                                                                           $$\\\\   $$ |\\n                                                                                           \\\\$$$$$$  |\\n    http://bomb.money                                                                      \\\\______/ \\n*/\\n// fixed window oracle that recomputes the average price for the entire period once every period\\n// note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\\ncontract OraclePMATIC is Epoch {\\n    using FixedPoint for *;\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // uniswap\\n    address public token0;\\n    address public token1;\\n    IUniswapV2Pair public pair;\\n\\n    // oracle\\n    uint32 public blockTimestampLast;\\n    uint256 public price0CumulativeLast;\\n    uint256 public price1CumulativeLast;\\n    FixedPoint.uq112x112 public price0Average;\\n    FixedPoint.uq112x112 public price1Average;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        IUniswapV2Pair _pair,\\n        uint256 _period,\\n        uint256 _startTime\\n    ) public Epoch(_period, _startTime, 0) {\\n        pair = _pair;\\n        token0 = pair.token0();\\n        token1 = pair.token1();\\n        price0CumulativeLast = pair.price0CumulativeLast(); // fetch the current accumulated price value (1 / 0)\\n        price1CumulativeLast = pair.price1CumulativeLast(); // fetch the current accumulated price value (0 / 1)\\n        uint112 reserve0;\\n        uint112 reserve1;\\n        (reserve0, reserve1, blockTimestampLast) = pair.getReserves();\\n        require(reserve0 != 0 && reserve1 != 0, \\\"Oracle: NO_RESERVES\\\"); // ensure that there's liquidity in the pair\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    /** @dev Updates 1-day EMA price from Uniswap.  */\\n    function update() external checkEpoch {\\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n\\n        if (timeElapsed == 0) {\\n            // prevent divided by zero\\n            return;\\n        }\\n\\n        // overflow is desired, casting never truncates\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\n        price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\\n        price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\\n\\n        price0CumulativeLast = price0Cumulative;\\n        price1CumulativeLast = price1Cumulative;\\n        blockTimestampLast = blockTimestamp;\\n\\n        emit Updated(price0Cumulative, price1Cumulative);\\n    }\\n\\n    // note this will always return 0 before update has been called successfully for the first time.\\n    function consult(address _token, uint256 _amountIn) external view returns (uint144 amountOut) {\\n        if (_token == token0) {\\n            amountOut = price0Average.mul(_amountIn).decode144();\\n        } else {\\n            require(_token == token1, \\\"Oracle: INVALID_TOKEN\\\");\\n            amountOut = price1Average.mul(_amountIn).decode144();\\n        }\\n    }\\n\\n    function twap(address _token, uint256 _amountIn) external view returns (uint144 _amountOut) {\\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (_token == token0) {\\n            _amountOut = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed)).mul(_amountIn).decode144();\\n        } else if (_token == token1) {\\n            _amountOut = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed)).mul(_amountIn).decode144();\\n        }\\n    }\\n\\n    event Updated(uint256 price0CumulativeLast, uint256 price1CumulativeLast);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./Babylonian.sol\\\";\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\\n    uint256 private constant Q224 = Q112 << RESOLUTION;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\\n        uint256 z;\\n        require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n\\n    // take the reciprocal of a UQ112x112\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        require(self._x != 0, \\\"FixedPoint: ZERO_RECIPROCAL\\\");\\n        return uq112x112(uint224(Q224 / self._x));\\n    }\\n\\n    // square root of a UQ112x112\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./FixedPoint.sol\\\";\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2**32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(address pair)\\n        internal\\n        view\\n        returns (\\n            uint256 price0Cumulative,\\n            uint256 price1Cumulative,\\n            uint32 blockTimestamp\\n        )\\n    {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint256(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Epoch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\n\\nimport '../owner/Operator.sol';\\n\\ncontract Epoch is Operator {\\n    using SafeMath for uint256;\\n\\n    uint256 private period;\\n    uint256 private startTime;\\n    uint256 private lastEpochTime;\\n    uint256 private epoch;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        uint256 _period,\\n        uint256 _startTime,\\n        uint256 _startEpoch\\n    ) public {\\n        period = _period;\\n        startTime = _startTime;\\n        epoch = _startEpoch;\\n        lastEpochTime = startTime.sub(period);\\n    }\\n\\n    /* ========== Modifier ========== */\\n\\n    modifier checkStartTime {\\n        require(now >= startTime, 'Epoch: not started yet');\\n\\n        _;\\n    }\\n\\n    modifier checkEpoch {\\n        uint256 _nextEpochPoint = nextEpochPoint();\\n        if (now < _nextEpochPoint) {\\n            require(msg.sender == operator(), 'Epoch: only operator allowed for pre-epoch');\\n            _;\\n        } else {\\n            _;\\n\\n            for (;;) {\\n                lastEpochTime = _nextEpochPoint;\\n                ++epoch;\\n                _nextEpochPoint = nextEpochPoint();\\n                if (now < _nextEpochPoint) break;\\n            }\\n        }\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n    function getCurrentEpoch() public view returns (uint256) {\\n        return epoch;\\n    }\\n\\n    function getPeriod() public view returns (uint256) {\\n        return period;\\n    }\\n\\n    function getStartTime() public view returns (uint256) {\\n        return startTime;\\n    }\\n\\n    function getLastEpochTime() public view returns (uint256) {\\n        return lastEpochTime;\\n    }\\n\\n    function nextEpochPoint() public view returns (uint256) {\\n        return lastEpochTime.add(period);\\n    }\\n\\n    /* ========== GOVERNANCE ========== */\\n\\n    function setPeriod(uint256 _period) external onlyOperator {\\n        require(_period >= 1 hours && _period <= 48 hours, '_period: out of range');\\n        period = _period;\\n    }\\n\\n    function setEpoch(uint256 _epoch) external onlyOperator {\\n        epoch = _epoch;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"./lib/Babylonian.sol\\\";\\nimport \\\"./lib/FixedPoint.sol\\\";\\nimport \\\"./lib/UniswapV2OracleLibrary.sol\\\";\\nimport \\\"./utils/Epoch.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\n\\n/*\\n\\n$$$$$$$\\\\   $$$$$$\\\\  $$\\\\      $$\\\\ $$$$$$$\\\\                                                            \\n$$  __$$\\\\ $$  __$$\\\\ $$$\\\\    $$$ |$$  __$$\\\\                                                           \\n$$ |  $$ |$$ /  $$ |$$$$\\\\  $$$$ |$$ |  $$ |    $$$$$$\\\\$$$$\\\\   $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\  $$\\\\   $$\\\\ \\n$$$$$$$\\\\ |$$ |  $$ |$$\\\\$$\\\\$$ $$ |$$$$$$$\\\\ |    $$  _$$  _$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$ |  $$ |\\n$$  __$$\\\\ $$ |  $$ |$$ \\\\$$$  $$ |$$  __$$\\\\     $$ / $$ / $$ |$$ /  $$ |$$ |  $$ |$$$$$$$$ |$$ |  $$ |\\n$$ |  $$ |$$ |  $$ |$$ |\\\\$  /$$ |$$ |  $$ |    $$ | $$ | $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\\n$$$$$$$  | $$$$$$  |$$ | \\\\_/ $$ |$$$$$$$  |$$\\\\ $$ | $$ | $$ |\\\\$$$$$$  |$$ |  $$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |\\n\\\\_______/  \\\\______/ \\\\__|     \\\\__|\\\\_______/ \\\\__|\\\\__| \\\\__| \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______| \\\\____$$ |\\n                                                                                           $$\\\\   $$ |\\n                                                                                           \\\\$$$$$$  |\\n    http://bomb.money                                                                      \\\\______/ \\n*/\\n// fixed window oracle that recomputes the average price for the entire period once every period\\n// note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\\ncontract Oracle is Epoch {\\n    using FixedPoint for *;\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    // uniswap\\n    address public token0;\\n    address public token1;\\n    IUniswapV2Pair public pair;\\n\\n    // oracle\\n    uint32 public blockTimestampLast;\\n    uint256 public price0CumulativeLast;\\n    uint256 public price1CumulativeLast;\\n    FixedPoint.uq112x112 public price0Average;\\n    FixedPoint.uq112x112 public price1Average;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        IUniswapV2Pair _pair,\\n        uint256 _period,\\n        uint256 _startTime\\n    ) public Epoch(_period, _startTime, 0) {\\n        pair = _pair;\\n        token0 = pair.token0();\\n        token1 = pair.token1();\\n        price0CumulativeLast = pair.price0CumulativeLast(); // fetch the current accumulated price value (1 / 0)\\n        price1CumulativeLast = pair.price1CumulativeLast(); // fetch the current accumulated price value (0 / 1)\\n        uint112 reserve0;\\n        uint112 reserve1;\\n        (reserve0, reserve1, blockTimestampLast) = pair.getReserves();\\n        require(reserve0 != 0 && reserve1 != 0, \\\"Oracle: NO_RESERVES\\\"); // ensure that there's liquidity in the pair\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    /** @dev Updates 1-day EMA price from Uniswap.  */\\n    function update() external checkEpoch {\\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n\\n        if (timeElapsed == 0) {\\n            // prevent divided by zero\\n            return;\\n        }\\n\\n        // overflow is desired, casting never truncates\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\n        price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\\n        price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\\n\\n        price0CumulativeLast = price0Cumulative;\\n        price1CumulativeLast = price1Cumulative;\\n        blockTimestampLast = blockTimestamp;\\n\\n        emit Updated(price0Cumulative, price1Cumulative);\\n    }\\n\\n    // note this will always return 0 before update has been called successfully for the first time.\\n    function consult(address _token, uint256 _amountIn) external view returns (uint144 amountOut) {\\n        if (_token == token0) {\\n            amountOut = price0Average.mul(_amountIn).decode144();\\n        } else {\\n            require(_token == token1, \\\"Oracle: INVALID_TOKEN\\\");\\n            amountOut = price1Average.mul(_amountIn).decode144();\\n        }\\n    }\\n\\n    function twap(address _token, uint256 _amountIn) external view returns (uint144 _amountOut) {\\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (_token == token0) {\\n            _amountOut = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed)).mul(_amountIn).decode144();\\n        } else if (_token == token1) {\\n            _amountOut = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed)).mul(_amountIn).decode144();\\n        }\\n    }\\n\\n    event Updated(uint256 price0CumulativeLast, uint256 price1CumulativeLast);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint256;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex\\\"ff\\\",\\n                        factory,\\n                        keccak256(abi.encodePacked(token0, token1)),\\n                        hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\" // init code hash\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) internal pure returns (uint256 amountB) {\\n        require(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\n        require(reserveA > 0 && reserveB > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountOut) {\\n        require(amountIn > 0, \\\"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        require(reserveIn > 0 && reserveOut > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n        uint256 amountInWithFee = amountIn.mul(997);\\n        uint256 numerator = amountInWithFee.mul(reserveOut);\\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountIn) {\\n        require(amountOut > 0, \\\"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n        require(reserveIn > 0 && reserveOut > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        address factory,\\n        uint256 amountIn,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint256 i; i < path.length - 1; i++) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        address factory,\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i > 0; i--) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DummyToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"./owner/Operator.sol\\\";\\n\\ncontract DummyToken is ERC20Burnable, Operator {\\n\\n    constructor() public ERC20(\\\"DummyToken\\\", \\\"DUMMY\\\") {}\\n\\n    function mint(address recipient_, uint256 amount_) public onlyOperator returns (bool) {\\n        uint256 balanceBefore = balanceOf(recipient_);\\n        _mint(recipient_, amount_);\\n        super.burnFrom(recipient_, amount_);\\n        uint256 balanceAfter = balanceOf(recipient_);\\n\\n        return balanceAfter > balanceBefore;\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function burnFrom(address account, uint256 amount) public override onlyOperator {\\n        super.burnFrom(account, amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"\": {\r\n        \"__CACHE_BREAKER__\": \"0x00000000d41867734bbee4c6863d9255b2b06ac1\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_share\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolStartTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TOTAL_REWARDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_lastRewardTime\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toTime\",\"type\":\"uint256\"}],\"name\":\"getGeneratedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"governanceRecoverUnsupported\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accSharePerShare\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStarted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"runningTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"share\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sharePerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ShareFarmRewardPool", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000004b79c851ed1a36549c6151189c79ec0eabca7450000000000000000000000000000000000000000000000000000000063580800", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}