{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LzMailer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IZKBridgeEntrypoint.sol\\\";\\nimport \\\"./interfaces/ILayerZeroEndpoint.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title Mailer\\n/// @notice An example contract for sending messages to other chains, using the ZKBridgeEntrypoint.\\ncontract LzMailer is Ownable {\\n    /// @notice The ZKBridgeEntrypoint contract, which sends messages to other chains.\\n    IZKBridgeEntrypoint public zkBridgeEntrypoint;\\n\\n    ILayerZeroEndpoint public immutable lzEndpoint;\\n\\n    bool public zkBridgePaused = false;\\n    bool public layerZeroPaused = false;\\n\\n    uint256 public maxLength = 200;\\n\\n    /// @notice Fee for each chain.\\n    mapping(uint16 => uint256) public fees;\\n\\n    event MessageSend(\\n        uint64 indexed sequence,\\n        uint32 indexed dstChainId,\\n        address indexed dstAddress,\\n        address sender,\\n        address recipient,\\n        string message\\n    );\\n\\n    event LzMessageSend(\\n        uint64 indexed sequence,\\n        uint32 indexed dstChainId,\\n        address indexed dstAddress,\\n        address sender,\\n        address recipient,\\n        string message\\n    );\\n    event NewFee(uint16 chainId, uint256 fee);\\n    /// @notice Event emitted when an action is paused/unpaused\\n    event PauseSendAction(\\n        address account,\\n        bool zkBridgePaused,\\n        bool layerZeroPaused\\n    );\\n\\n    constructor(address _zkBridgeEntrypoint, address _lzEndpoint) {\\n        zkBridgeEntrypoint = IZKBridgeEntrypoint(_zkBridgeEntrypoint);\\n        lzEndpoint = ILayerZeroEndpoint(_lzEndpoint);\\n    }\\n\\n    /// @notice Sends a message to a destination MessageBridge.\\n    /// @param dstChainId The chain ID where the destination MessageBridge.\\n    /// @param dstAddress The address of the destination MessageBridge.\\n    /// @param recipient Recipient of the target chain message.\\n    /// @param message The message to send.\\n    function sendMessage(\\n        uint16 dstChainId,\\n        address dstAddress,\\n        uint16 lzChainId,\\n        address lzDstAddress,\\n        uint256 nativeFee,\\n        address recipient,\\n        string memory message\\n    ) external payable {\\n        if (layerZeroPaused && zkBridgePaused) {\\n            revert(\\\"Nothing to do\\\");\\n        }\\n\\n        uint256 zkFee = fees[dstChainId];\\n        if (zkBridgePaused) {\\n            zkFee = 0;\\n        }\\n\\n        if (layerZeroPaused) {\\n            require(nativeFee == 0, \\\"Invalid native fee\\\");\\n        }\\n        require(msg.value >= nativeFee + zkFee, \\\"Insufficient Fee\\\");\\n        require(\\n            bytes(message).length <= maxLength,\\n            \\\"Maximum message length exceeded.\\\"\\n        );\\n\\n        if (!zkBridgePaused) {\\n            _sendMessage(dstChainId, dstAddress, recipient, message);\\n        }\\n\\n        if (!layerZeroPaused) {\\n            _sendToLayerZero(\\n                lzChainId,\\n                lzDstAddress,\\n                recipient,\\n                nativeFee,\\n                message\\n            );\\n        }\\n    }\\n\\n    function zkSendMessage(\\n        uint16 dstChainId,\\n        address dstAddress,\\n        address recipient,\\n        string memory message\\n    ) external payable {\\n        if (zkBridgePaused) {\\n            revert(\\\"Paused\\\");\\n        }\\n        require(msg.value >= fees[dstChainId], \\\"Insufficient Fee\\\");\\n        require(\\n            bytes(message).length <= maxLength,\\n            \\\"Maximum message length exceeded.\\\"\\n        );\\n\\n        _sendMessage(dstChainId, dstAddress, recipient, message);\\n    }\\n\\n    function lzSendMessage(\\n        uint16 lzChainId,\\n        address lzDstAddress,\\n        address recipient,\\n        string memory message\\n    ) external payable {\\n        if (layerZeroPaused) {\\n            revert(\\\"Paused\\\");\\n        }\\n        require(\\n            bytes(message).length <= maxLength,\\n            \\\"Maximum message length exceeded.\\\"\\n        );\\n\\n        _sendToLayerZero(\\n            lzChainId,\\n            lzDstAddress,\\n            recipient,\\n            msg.value,\\n            message\\n        );\\n    }\\n\\n    function _sendMessage(\\n        uint16 dstChainId,\\n        address dstAddress,\\n        address recipient,\\n        string memory message\\n    ) private {\\n        bytes memory payload = abi.encode(msg.sender, recipient, message);\\n        uint64 _sequence = zkBridgeEntrypoint.send(\\n            dstChainId,\\n            dstAddress,\\n            payload\\n        );\\n        emit MessageSend(\\n            _sequence,\\n            dstChainId,\\n            dstAddress,\\n            msg.sender,\\n            recipient,\\n            message\\n        );\\n    }\\n\\n    function _sendToLayerZero(\\n        uint16 _dstChainId,\\n        address _dstAddress,\\n        address _recipient,\\n        uint256 _nativeFee,\\n        string memory _message\\n    ) private {\\n        bytes memory payload = abi.encode(msg.sender, _recipient, _message);\\n        bytes memory path = abi.encodePacked(_dstAddress, address(this));\\n\\n        lzEndpoint.send{value: _nativeFee}(\\n            _dstChainId,\\n            path,\\n            payload,\\n            payable(msg.sender),\\n            msg.sender,\\n            bytes(\\\"\\\")\\n        );\\n\\n        uint64 _sequence = lzEndpoint.outboundNonce(_dstChainId, address(this));\\n\\n        emit LzMessageSend(\\n            _sequence,\\n            _dstChainId,\\n            _dstAddress,\\n            msg.sender,\\n            _recipient,\\n            _message\\n        );\\n    }\\n\\n    /// @notice Allows owner to set a new msg length.\\n    /// @param _maxLength new msg length.\\n    function setMsgLength(uint256 _maxLength) external onlyOwner {\\n        maxLength = _maxLength;\\n    }\\n\\n    /// @notice Allows owner to claim all fees sent to this contract.\\n    /// @notice Allows owner to set a new fee.\\n    /// @param _dstChainId The chain ID where the destination MessageBridge.\\n    /// @param _fee The new fee to use.\\n    function setFee(uint16 _dstChainId, uint256 _fee) external onlyOwner {\\n        require(fees[_dstChainId] != _fee, \\\"Fee has already been set.\\\");\\n        fees[_dstChainId] = _fee;\\n        emit NewFee(_dstChainId, _fee);\\n    }\\n\\n    /**\\n     * @notice Pauses different actions\\n     * @dev Changes the owner address.\\n     * @param zkBridgePaused_ Boolean for zkBridge send\\n     * @param layerZeroPaused_ Boolean for layer zero send\\n     */\\n    function pause(\\n        bool zkBridgePaused_,\\n        bool layerZeroPaused_\\n    ) external onlyOwner {\\n        zkBridgePaused = zkBridgePaused_;\\n        layerZeroPaused = layerZeroPaused_;\\n        emit PauseSendAction(msg.sender, zkBridgePaused, layerZeroPaused);\\n    }\\n\\n    /// @notice Allows owner to claim all fees sent to this contract.\\n    function claimFees() external onlyOwner {\\n        payable(owner()).transfer(address(this).balance);\\n    }\\n\\n    function estimateLzFee(\\n        uint16 _dstChainId,\\n        address _recipient,\\n        string memory _message\\n    ) public view returns (uint256 nativeFee) {\\n        if (layerZeroPaused) {\\n            return 0;\\n        }\\n\\n        bytes memory payload = abi.encode(msg.sender, _recipient, _message);\\n        (nativeFee, ) = lzEndpoint.estimateFees(\\n            _dstChainId,\\n            address(this),\\n            payload,\\n            false,\\n            bytes(\\\"\\\")\\n        );\\n    }\\n\\n    /**\\n     * @notice set the configuration of the LayerZero messaging library of the specified version\\n     * @param _version - messaging library version\\n     * @param _dstChainId - the chainId for the pending config change\\n     * @param _configType - type of configuration. every messaging library has its own convention.\\n     * @param _config - configuration in the bytes. can encode arbitrary content.\\n     */\\n    function setConfig(\\n        uint16 _version,\\n        uint16 _dstChainId,\\n        uint _configType,\\n        bytes calldata _config\\n    ) external onlyOwner {\\n        lzEndpoint.setConfig(_version, _dstChainId, _configType, _config);\\n    }\\n\\n    function setSendVersion(uint16 _version) external onlyOwner {\\n        lzEndpoint.setSendVersion(_version);\\n    }\\n\\n    function setReceiveVersion(uint16 _version) external onlyOwner {\\n        lzEndpoint.setReceiveVersion(_version);\\n    }\\n\\n    function forceResumeReceive(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress\\n    ) external onlyOwner {\\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\\n    }\\n\\n    /// @notice get the send() LayerZero messaging library version\\n    function getSendVersion() external view returns (uint16) {\\n        return lzEndpoint.getSendVersion(address(this));\\n    }\\n\\n    /**\\n     * @notice get the configuration of the LayerZero messaging library of the specified version\\n     * @param _version - messaging library version\\n     * @param _dstChainId - the chainId for the pending config change\\n     * @param _configType - type of configuration. every messaging library has its own convention.\\n     */\\n    function getConfig(\\n        uint16 _version,\\n        uint16 _dstChainId,\\n        uint _configType\\n    ) external view returns (bytes memory) {\\n        return\\n            lzEndpoint.getConfig(\\n                _version,\\n                _dstChainId,\\n                address(this),\\n                _configType\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param _payload - a custom bytes payload to send to the destination contract\\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n    function send(\\n        uint16 _dstChainId,\\n        bytes calldata _destination,\\n        bytes calldata _payload,\\n        address payable _refundAddress,\\n        address _zroPaymentAddress,\\n        bytes calldata _adapterParams\\n    ) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source contract (as bytes) at the source chain\\n    // @param _dstAddress - the address on destination chain\\n    // @param _nonce - the unbound message ordering nonce\\n    // @param _gasLimit - the gas limit for external contract execution\\n    // @param _payload - verified payload to send to the destination contract\\n    function receivePayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        address _dstAddress,\\n        uint64 _nonce,\\n        uint _gasLimit,\\n        bytes calldata _payload\\n    ) external;\\n\\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function getInboundNonce(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress\\n    ) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param _srcAddress - the source chain contract address\\n    function getOutboundNonce(\\n        uint16 _dstChainId,\\n        address _srcAddress\\n    ) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param _dstChainId - the destination chain identifier\\n    // @param _userApplication - the user app address on this EVM chain\\n    // @param _payload - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(\\n        uint16 _dstChainId,\\n        address _userApplication,\\n        bytes calldata _payload,\\n        bool _payInZRO,\\n        bytes calldata _adapterParam\\n    ) external view returns (uint nativeFee, uint zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    // @param _payload - the payload to be retried\\n    function retryPayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress,\\n        bytes calldata _payload\\n    ) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param _srcChainId - the source chain identifier\\n    // @param _srcAddress - the source chain contract address\\n    function hasStoredPayload(\\n        uint16 _srcChainId,\\n        bytes calldata _srcAddress\\n    ) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getSendLibraryAddress(\\n        address _userApplication\\n    ) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param _userApplication - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(\\n        address _userApplication\\n    ) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _userApplication - the contract address of the user application\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    function getConfig(\\n        uint16 _version,\\n        uint16 _chainId,\\n        address _userApplication,\\n        uint _configType\\n    ) external view returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getSendVersion(\\n        address _userApplication\\n    ) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param _userApplication - the contract address of the user application\\n    function getReceiveVersion(\\n        address _userApplication\\n    ) external view returns (uint16);\\n\\n    function defaultSendLibrary() external view returns (address);\\n\\n    function outboundNonce(\\n        uint16 _chainId,\\n        address _userApplication\\n    ) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IZKBridgeEntrypoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IZKBridgeEntrypoint {\\n    /// @notice send a ZKBridge message to the specified address at a ZKBridge endpoint.\\n    /// @param dstChainId - the destination chain identifier\\n    /// @param dstAddress - the address on destination chain\\n    /// @param payload - a custom bytes payload to send to the destination contract\\n    function send(\\n        uint16 dstChainId,\\n        address dstAddress,\\n        bytes memory payload\\n    ) external payable returns (uint64 sequence);\\n\\n    /// @return Current chain id.\\n    function chainId() external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_zkBridgeEntrypoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lzEndpoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"LzMessageSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"MessageSend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"NewFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"zkBridgePaused\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"layerZeroPaused\",\"type\":\"bool\"}],\"name\":\"PauseSendAction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"estimateLzFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSendVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerZeroPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lzEndpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"lzChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"lzDstAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"lzSendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"zkBridgePaused_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"layerZeroPaused_\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"lzChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"lzDstAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxLength\",\"type\":\"uint256\"}],\"name\":\"setMsgLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setReceiveVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkBridgeEntrypoint\",\"outputs\":[{\"internalType\":\"contract IZKBridgeEntrypoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkBridgePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"zkSendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "LzMailer", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a25be50be65070c2ad96d5ed639061de31c45e120000000000000000000000003c2269811836af69497e5f486a85d7316753cf62", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}