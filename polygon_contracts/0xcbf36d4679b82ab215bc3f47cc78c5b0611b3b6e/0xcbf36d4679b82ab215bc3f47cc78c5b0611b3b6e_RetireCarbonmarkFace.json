{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/infinity/facets/Retire/RetireCarbonmarkFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.16;\\n\\nimport {LibRetire, C, LibApprove} from \\\"../../libraries/LibRetire.sol\\\";\\nimport {ICarbonmark} from \\\"../../interfaces/ICarbonmark.sol\\\";\\nimport \\\"../../ReentrancyGuard.sol\\\";\\n\\ncontract RetireCarbonmarkFacet is ReentrancyGuard {\\n    event CarbonRetired(\\n        LibRetire.CarbonBridge carbonBridge,\\n        address indexed retiringAddress,\\n        string retiringEntityString,\\n        address indexed beneficiaryAddress,\\n        string beneficiaryString,\\n        string retirementMessage,\\n        address indexed carbonPool,\\n        address poolToken,\\n        uint256 retiredAmount\\n    );\\n\\n    /* ========== Retire directly from a Carbonmark listing ========== */\\n\\n    /**\\n     * @notice                     Retires an exact amount of carbon using default redemption\\n     * @param maxAmountIn          Maximum amount of USDC tokens to spend for this retirement\\n     * @param retireAmount         The amount of carbon to retire\\n     * @param retiringEntityString String description of the retiring entity\\n     * @param beneficiaryAddress   0x address for the beneficiary\\n     * @param beneficiaryString    String description of the beneficiary\\n     * @param retirementMessage    String message for this specific retirement\\n     * @param fromMode             From Mode for transfering tokens\\n     * @return retirementIndex     The latest retirement index for the beneficiary address\\n     */\\n    function retireCarbonmarkListing(\\n        ICarbonmark.CreditListing memory listing,\\n        uint256 maxAmountIn,\\n        uint256 retireAmount,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        LibTransfer.From fromMode\\n    ) external payable nonReentrant returns (uint256 retirementIndex) {\\n        require(retireAmount > 0, \\\"Cannot retire zero tonnes\\\");\\n\\n        LibTransfer.receiveToken(IERC20(C.usdc()), maxAmountIn, msg.sender, fromMode);\\n\\n        LibApprove.approveToken(IERC20(C.usdc()), C.carbonmark(), maxAmountIn);\\n\\n        ICarbonmark(C.carbonmark()).fillListing(\\n            listing.id, listing.account, listing.token, listing.unitPrice, retireAmount, maxAmountIn\\n        );\\n\\n        LibRetire.retireReceivedCreditToken(\\n            listing.token,\\n            retireAmount,\\n            msg.sender,\\n            retiringEntityString,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage\\n        );\\n\\n        return LibRetire.getTotalRetirements(beneficiaryAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/LibRetire.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @author Cujo\\n * @title LibRetire\\n */\\n\\nimport \\\"../C.sol\\\";\\nimport \\\"./LibAppStorage.sol\\\";\\nimport {LibMeta} from \\\"./LibMeta.sol\\\";\\nimport \\\"./Bridges/LibToucanCarbon.sol\\\";\\nimport \\\"./Bridges/LibMossCarbon.sol\\\";\\nimport \\\"./Bridges/LibC3Carbon.sol\\\";\\nimport \\\"./Token/LibTransfer.sol\\\";\\nimport \\\"./TokenSwap/LibSwap.sol\\\";\\nimport \\\"../interfaces/IKlimaInfinity.sol\\\";\\nimport \\\"../interfaces/IKlimaCarbonRetirements.sol\\\";\\n\\nlibrary LibRetire {\\n    using LibTransfer for IERC20;\\n    using LibBalance for address payable;\\n    using LibApprove for IERC20;\\n\\n    enum CarbonBridge {\\n        TOUCAN,\\n        MOSS,\\n        C3\\n    }\\n\\n    /* ========== Default Redemption Retirements ========== */\\n\\n    /**\\n     * @notice                     Retire received carbon based on the bridge of the provided pool tokens using default redemption\\n     * @param poolToken            Pool token used to retire\\n     * @param amount               The amount of carbon to retire\\n     * @param retiringEntityString String description of the retiring entity\\n     * @param beneficiaryAddress   0x address for the beneficiary\\n     * @param beneficiaryString    String description of the beneficiary\\n     * @param retirementMessage    String message for this specific retirement\\n     */\\n    function retireReceivedCarbon(\\n        address poolToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        if (s.poolBridge[poolToken] == CarbonBridge.TOUCAN) {\\n            LibToucanCarbon.redeemAutoAndRetire(\\n                poolToken,\\n                amount,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        } else if (s.poolBridge[poolToken] == CarbonBridge.MOSS) {\\n            LibMossCarbon.offsetCarbon(\\n                poolToken,\\n                amount,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        } else if (s.poolBridge[poolToken] == CarbonBridge.C3) {\\n            LibC3Carbon.freeRedeemAndRetire(\\n                poolToken,\\n                amount,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        }\\n    }\\n\\n    /* ========== Specific Redemption Retirements ========== */\\n\\n    /**\\n     * @notice                     Retire received carbon based on the bridge of the provided pool tokens using specific redemption\\n     * @param poolToken            Pool token used to retire\\n     * @param projectToken         Project token being retired\\n     * @param amount               The amount of carbon to retire\\n     * @param retiringEntityString String description of the retiring entity\\n     * @param beneficiaryAddress   0x address for the beneficiary\\n     * @param beneficiaryString    String description of the beneficiary\\n     * @param retirementMessage    String message for this specific retirement\\n     */\\n    function retireReceivedExactCarbonSpecific(\\n        address poolToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal returns (uint redeemedAmount) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(\\n            s.poolBridge[poolToken] == CarbonBridge.TOUCAN || s.poolBridge[poolToken] == CarbonBridge.C3,\\n            \\\"Specific redeem not supported.\\\"\\n        );\\n\\n        redeemedAmount = amount;\\n\\n        if (s.poolBridge[poolToken] == CarbonBridge.TOUCAN) {\\n            redeemedAmount += LibToucanCarbon.getSpecificRedeemFee(poolToken, amount);\\n            LibToucanCarbon.redeemSpecificAndRetire(\\n                poolToken,\\n                projectToken,\\n                redeemedAmount,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        } else if (s.poolBridge[poolToken] == CarbonBridge.C3) {\\n            redeemedAmount += LibC3Carbon.getExactCarbonSpecificRedeemFee(poolToken, amount);\\n\\n            LibC3Carbon.redeemSpecificAndRetire(\\n                poolToken,\\n                projectToken,\\n                amount,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        }\\n    }\\n\\n    /* ========== Credit Token Direct Retirements ========== */\\n\\n    /**\\n     * @notice                     Retire received carbon based on the bridge of the provided pool tokens using default redemption\\n     * @param creditToken          Pool token used to retire\\n     * @param amount               The amount of carbon to retire\\n     * @param retiringEntityString String description of the retiring entity\\n     * @param beneficiaryAddress   0x address for the beneficiary\\n     * @param beneficiaryString    String description of the beneficiary\\n     * @param retirementMessage    String message for this specific retirement\\n     */\\n    function retireReceivedCreditToken(\\n        address creditToken,\\n        uint256 amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal {\\n        if (LibToucanCarbon.isValid(creditToken)) {\\n            LibToucanCarbon.retireTCO2(\\n                address(0), // Direct retirement, no pool token\\n                creditToken,\\n                amount,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        } else if (LibC3Carbon.isValid(creditToken)) {\\n            LibC3Carbon.retireC3T(\\n                address(0), // Direct retirement, no pool token\\n                creditToken,\\n                amount,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice                     Additional function to handle the differences in wanting to fully retire x pool tokens specifically\\n     * @param poolToken            Pool token used to retire\\n     * @param projectToken         Project token being retired\\n     * @param amount               The amount of carbon to retire\\n     * @param retiringEntityString String description of the retiring entity\\n     * @param beneficiaryAddress   0x address for the beneficiary\\n     * @param beneficiaryString    String description of the beneficiary\\n     * @param retirementMessage    String message for this specific retirement\\n     * @return redeemedAmount      Number of pool tokens redeemed\\n     */\\n    function retireReceivedCarbonSpecificFromSource(\\n        address poolToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal returns (uint redeemedAmount) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        require(\\n            s.poolBridge[poolToken] == CarbonBridge.TOUCAN || s.poolBridge[poolToken] == CarbonBridge.C3,\\n            \\\"Specific redeem not supported.\\\"\\n        );\\n\\n        redeemedAmount = amount;\\n\\n        if (s.poolBridge[poolToken] == CarbonBridge.TOUCAN) {\\n            LibToucanCarbon.redeemSpecificAndRetire(\\n                poolToken,\\n                projectToken,\\n                amount,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        } else if (s.poolBridge[poolToken] == CarbonBridge.C3) {\\n            redeemedAmount += LibC3Carbon.getExactCarbonSpecificRedeemFee(poolToken, amount);\\n            LibC3Carbon.redeemSpecificAndRetire(\\n                poolToken,\\n                projectToken,\\n                amount,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        }\\n    }\\n\\n    /* ========== Helper Functions ========== */\\n\\n    /* ========== Common Functions ========== */\\n\\n    /**\\n     * @notice                  Returns the total carbon needed fee included\\n     * @param retireAmount      Pool token used to retire\\n     * @return totalCarbon      Total pool token needed\\n     */\\n    function getTotalCarbon(uint retireAmount) internal view returns (uint totalCarbon) {\\n        return retireAmount + getFee(retireAmount);\\n    }\\n\\n    /**\\n     * @notice                  Returns the total carbon needed fee included\\n     * @param poolToken         Pool token used to retire\\n     * @param retireAmount      Amount of carbon wanting to retire\\n     * @return totalCarbon      Total pool token needed\\n     */\\n    function getTotalCarbonSpecific(address poolToken, uint retireAmount) internal view returns (uint totalCarbon) {\\n        // This is for exact carbon retirements\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        totalCarbon = getTotalCarbon(retireAmount);\\n\\n        if (s.poolBridge[poolToken] == CarbonBridge.TOUCAN) {\\n            totalCarbon += LibToucanCarbon.getSpecificRedeemFee(poolToken, retireAmount);\\n        } else if (s.poolBridge[poolToken] == CarbonBridge.C3) {\\n            totalCarbon += LibC3Carbon.getExactCarbonSpecificRedeemFee(poolToken, retireAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice                  Returns the total fee needed to retire x number of tokens\\n     * @param carbonAmount      Amount being retired\\n     * @return fee              Total fee charged\\n     */\\n    function getFee(uint carbonAmount) internal view returns (uint fee) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        fee = (carbonAmount * s.fee) / 100_000;\\n    }\\n\\n    /**\\n     * @notice                      Saves the details of the retirement over to KlimaCarbonRetirements and project details within AppStorage\\n     * @param poolToken             Pool token used to retire\\n     * @param projectToken          Pool token used to retire\\n     * @param amount                Amount of carbon wanting to retire\\n     * @param beneficiaryAddress    0x address for the beneficiary\\n     * @param beneficiaryString     String description of the beneficiary\\n     * @param retirementMessage     String message for this specific retirement\\n     */\\n    function saveRetirementDetails(\\n        address poolToken,\\n        address projectToken,\\n        uint amount,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        (uint currentRetirementIndex,,) =\\n            IKlimaCarbonRetirements(C.klimaCarbonRetirements()).getRetirementTotals(beneficiaryAddress);\\n\\n        // Save the base details of the retirement\\n        IKlimaCarbonRetirements(C.klimaCarbonRetirements()).carbonRetired(\\n            beneficiaryAddress, poolToken, amount, beneficiaryString, retirementMessage\\n        );\\n\\n        // Save the details of the retirement\\n        s.a[beneficiaryAddress].retirements[currentRetirementIndex].projectTokenAddress = projectToken;\\n        s.a[beneficiaryAddress].totalProjectRetired[projectToken] += amount;\\n    }\\n\\n    /* ========== Account Getters ========== */\\n\\n    function getTotalRetirements(address account) internal view returns (uint totalRetirements) {\\n        (totalRetirements,,) = IKlimaCarbonRetirements(C.klimaCarbonRetirements()).getRetirementTotals(account);\\n    }\\n\\n    function getTotalCarbonRetired(address account) internal view returns (uint totalCarbonRetired) {\\n        (, totalCarbonRetired,) = IKlimaCarbonRetirements(C.klimaCarbonRetirements()).getRetirementTotals(account);\\n    }\\n\\n    function getTotalPoolRetired(address account, address poolToken) internal view returns (uint totalPoolRetired) {\\n        return IKlimaCarbonRetirements(C.klimaCarbonRetirements()).getRetirementPoolInfo(account, poolToken);\\n    }\\n\\n    function getTotalProjectRetired(address account, address projectToken) internal view returns (uint) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.a[account].totalProjectRetired[projectToken];\\n    }\\n\\n    function getTotalRewardsClaimed(address account) internal view returns (uint totalClaimed) {\\n        (,, totalClaimed) = IKlimaCarbonRetirements(C.klimaCarbonRetirements()).getRetirementTotals(account);\\n    }\\n\\n    function getRetirementDetails(address account, uint retirementIndex)\\n        internal\\n        view\\n        returns (\\n            address poolTokenAddress,\\n            address projectTokenAddress,\\n            address beneficiaryAddress,\\n            string memory beneficiary,\\n            string memory retirementMessage,\\n            uint amount\\n        )\\n    {\\n        (poolTokenAddress, amount, beneficiary, retirementMessage) =\\n            IKlimaCarbonRetirements(C.klimaCarbonRetirements()).getRetirementIndexInfo(account, retirementIndex);\\n        beneficiaryAddress = account;\\n\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        projectTokenAddress = s.a[account].retirements[retirementIndex].projectTokenAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/ICarbonmark.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.16;\\n\\ninterface ICarbonmark {\\n    /**\\n     * @notice Struct containing all of the detail information needed to fill a listing\\n     * @param account Ethereum address of the account who owns the listing\\n     * @param token Ethereum address of the token being listing\\n     * @param originalAmount Original amount of the listing\\n     * @param remainingAmount Remaining amount that can be filled on this listing\\n     * @param unitPrice The unit price in USDC of the listing\\n     * @param minFillAmount The minimum amount needed to purchase in order to fill the listing\\n     * @param deadline The block timestamp at which this listing expires\\n     */\\n    struct CreditListing {\\n        bytes32 id;\\n        address account;\\n        address token;\\n        uint256 remainingAmount;\\n        uint256 unitPrice;\\n    }\\n\\n    /**\\n     * @notice This function creates a new listing and returns the resulting listing ID\\n     * @param token The token being listed\\n     * @param amount The amount to be listed\\n     * @param unitPrice The unit price in USDC to list. Should be provided in full form so a price of 2.5 USDC = input\\n     * of 2500000\\n     * @param minFillAmount The minimum number of tons needed to be purchased to fill this listing\\n     * @param deadline The block timestamp at which this listing will expire\\n     * @return id The ID of the listing that was created\\n     */\\n    function createListing(address token, uint256 amount, uint256 unitPrice, uint256 minFillAmount, uint256 deadline)\\n        external\\n        returns (bytes32 id);\\n\\n    /**\\n     * @notice This function fills an existing listing\\n     * @param id The listing ID to update\\n     * @param listingAccount The account that created the listing you are filling\\n     * @param listingToken The token you are swapping for\\n     * @param listingUnitPrice The unit price per token to fill the listing\\n     * @param amount Amount of the listing to fill\\n     * @param maxCost Maximum cost in USDC for filling this listing\\n     */\\n    function fillListing(\\n        bytes32 id,\\n        address listingAccount,\\n        address listingToken,\\n        uint256 listingUnitPrice,\\n        uint256 amount,\\n        uint256 maxCost\\n    ) external;\\n\\n    function getListingOwner(bytes32 id) external view returns (address);\\n\\n    function getUnitPrice(bytes32 id) external view returns (uint256);\\n\\n    function getRemainingAmount(bytes32 id) external view returns (uint256);\\n\\n    function getListingDeadline(bytes32 id) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/infinity/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"./AppStorage.sol\\\";\\n\\n/**\\n * @author Beanstalk Farms\\n * @title Variation of Oepn Zeppelins reentrant guard to include Silo Update\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts%2Fsecurity%2FReentrancyGuard.sol\\n *\\n */\\nabstract contract ReentrancyGuard {\\n    uint private constant _NOT_ENTERED = 1;\\n    uint private constant _ENTERED = 2;\\n\\n    AppStorage internal s;\\n\\n    modifier nonReentrant() {\\n        require(s.reentrantStatus != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        s.reentrantStatus = _ENTERED;\\n        _;\\n        s.reentrantStatus = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/C.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @author Cujo\\n * @title C holds the constants for Klima Infinity\\n */\\n\\nlibrary C {\\n    // Chain\\n    uint256 private constant CHAIN_ID = 137; // Polygon\\n\\n    // Klima Protocol Contracts\\n    address private constant KLIMA = 0x4e78011Ce80ee02d2c3e649Fb657E45898257815;\\n    address private constant SKLIMA = 0xb0C22d8D350C67420f06F48936654f567C73E8C8;\\n    address private constant WSKLIMA = 0x6f370dba99E32A3cAD959b341120DB3C9E280bA6;\\n    address private constant STAKING = 0x25d28a24Ceb6F81015bB0b2007D795ACAc411b4d;\\n    address private constant STAKING_HELPER = 0x4D70a031Fc76DA6a9bC0C922101A05FA95c3A227;\\n    address private constant TREASURY = 0x7Dd4f0B986F032A44F913BF92c9e8b7c17D77aD7;\\n\\n    // Standard Swap ERC20s\\n    address private constant USDC = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\\n\\n    // DEX Router Addresses\\n    address private constant SUSHI_POLYGON = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;\\n    address private constant QUICKSWAP_POLYGON = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;\\n    address private constant SUSHI_BENTO = 0x0319000133d3AdA02600f0875d2cf03D442C3367;\\n    address private constant SUSHI_TRIDENT_POLYGON = 0xc5017BE80b4446988e8686168396289a9A62668E;\\n\\n    // Marketplace contracts\\n    address private constant CARBONMARK = 0x7B51dBc2A8fD98Fe0924416E628D5755f57eB821;\\n\\n    /* Carbon Pools */\\n    // Toucan\\n    address private constant BCT = 0x2F800Db0fdb5223b3C3f354886d907A671414A7F;\\n    address private constant NCT = 0xD838290e877E0188a4A44700463419ED96c16107;\\n\\n    // Moss\\n    address private constant MCO2 = 0xAa7DbD1598251f856C12f63557A4C4397c253Cea;\\n\\n    // C3\\n    address private constant UBO = 0x2B3eCb0991AF0498ECE9135bcD04013d7993110c;\\n    address private constant NBO = 0x6BCa3B77C1909Ce1a4Ba1A20d1103bDe8d222E48;\\n\\n    // Other important addresses\\n    address private constant TOUCAN_RETIRE_CERT = 0x5e377f16E4ec6001652befD737341a28889Af002;\\n    address private constant MOSS_CARBON_CHAIN = 0xeDAEFCf60e12Bd331c092341D5b3d8901C1c05A8;\\n    address private constant KLIMA_CARBON_RETIREMENTS = 0xac298CD34559B9AcfaedeA8344a977eceff1C0Fd;\\n    address private constant KLIMA_RETIREMENT_BOND = 0xa595f0d598DaF144e5a7ca91E6D9A5bAA09dDeD0;\\n    address constant TOUCAN_REGISTRY = 0x263fA1c180889b3a3f46330F32a4a23287E99FC9;\\n    address constant C3_PROJECT_FACTORY = 0xa4c951B30952f5E2feFC8a92F4d3c7551925A63B;\\n\\n    function toucanCert() internal pure returns (address) {\\n        return TOUCAN_RETIRE_CERT;\\n    }\\n\\n    function mossCarbonChain() internal pure returns (address) {\\n        return MOSS_CARBON_CHAIN;\\n    }\\n\\n    function staking() internal pure returns (address) {\\n        return STAKING;\\n    }\\n\\n    function stakingHelper() internal pure returns (address) {\\n        return STAKING_HELPER;\\n    }\\n\\n    function treasury() internal pure returns (address) {\\n        return TREASURY;\\n    }\\n\\n    function klima() internal pure returns (address) {\\n        return KLIMA;\\n    }\\n\\n    function sKlima() internal pure returns (address) {\\n        return SKLIMA;\\n    }\\n\\n    function wsKlima() internal pure returns (address) {\\n        return WSKLIMA;\\n    }\\n\\n    function usdc() internal pure returns (address) {\\n        return USDC;\\n    }\\n\\n    function bct() internal pure returns (address) {\\n        return BCT;\\n    }\\n\\n    function nct() internal pure returns (address) {\\n        return NCT;\\n    }\\n\\n    function mco2() internal pure returns (address) {\\n        return MCO2;\\n    }\\n\\n    function ubo() internal pure returns (address) {\\n        return UBO;\\n    }\\n\\n    function nbo() internal pure returns (address) {\\n        return NBO;\\n    }\\n\\n    function sushiRouter() internal pure returns (address) {\\n        return SUSHI_POLYGON;\\n    }\\n\\n    function quickswapRouter() internal pure returns (address) {\\n        return QUICKSWAP_POLYGON;\\n    }\\n\\n    function sushiTridentRouter() internal pure returns (address) {\\n        return SUSHI_TRIDENT_POLYGON;\\n    }\\n\\n    function sushiBento() internal pure returns (address) {\\n        return SUSHI_BENTO;\\n    }\\n\\n    function klimaCarbonRetirements() internal pure returns (address) {\\n        return KLIMA_CARBON_RETIREMENTS;\\n    }\\n\\n    function klimaRetirementBond() internal pure returns (address) {\\n        return KLIMA_RETIREMENT_BOND;\\n    }\\n\\n    function toucanRegistry() internal pure returns (address) {\\n        return TOUCAN_REGISTRY;\\n    }\\n\\n    function c3ProjectFactory() internal pure returns (address) {\\n        return C3_PROJECT_FACTORY;\\n    }\\n\\n    function carbonmark() internal pure returns (address) {\\n        return CARBONMARK;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/LibAppStorage.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT*/\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"../AppStorage.sol\\\";\\n\\n/**\\n * @author Publius\\n * @title App Storage Library allows libaries to access Klima Infinity's state.\\n *\\n */\\nlibrary LibAppStorage {\\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\\n        assembly {\\n            ds.slot := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/LibMeta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nlibrary LibMeta {\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\\\"));\\n\\n    function domainSeparator(string memory name, string memory version)\\n        internal\\n        view\\n        returns (bytes32 domainSeparator_)\\n    {\\n        domainSeparator_ = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), getChainID(), address(this)\\n            )\\n        );\\n    }\\n\\n    function getChainID() internal view returns (uint id) {\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    function msgSender() internal view returns (address sender_) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n            }\\n        } else {\\n            sender_ = msg.sender;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/Bridges/LibToucanCarbon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"../../C.sol\\\";\\nimport \\\"oz/token/ERC721/IERC721.sol\\\";\\nimport \\\"../../interfaces/IToucan.sol\\\";\\nimport \\\"../LibAppStorage.sol\\\";\\nimport \\\"../LibRetire.sol\\\";\\nimport \\\"../Token/LibTransfer.sol\\\";\\nimport \\\"../LibMeta.sol\\\";\\n\\n/**\\n * @author Cujo\\n * @title LibToucanCarbon\\n * Handles interactions with Toucan Protocol carbon\\n */\\n\\nlibrary LibToucanCarbon {\\n    event CarbonRetired(\\n        LibRetire.CarbonBridge carbonBridge,\\n        address indexed retiringAddress,\\n        string retiringEntityString,\\n        address indexed beneficiaryAddress,\\n        string beneficiaryString,\\n        string retirementMessage,\\n        address indexed carbonPool,\\n        address carbonToken,\\n        uint retiredAmount\\n    );\\n\\n    /**\\n     * @notice                      Redeems Toucan pool tokens using default redemtion and retires the TCO2\\n     * @param poolToken             Pool token to use for this retirement\\n     * @param amount                Amount of the project token to retire\\n     * @param retiringAddress       Address initiating this retirement\\n     * @param retiringEntityString  String description of the retiring entity\\n     * @param beneficiaryAddress    0x address for the beneficiary\\n     * @param beneficiaryString     String description of the beneficiary\\n     * @param retirementMessage     String message for this specific retirement\\n     */\\n    function redeemAutoAndRetire(\\n        address poolToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal {\\n        // Redeem pool tokens\\n        (address[] memory listTCO2, uint[] memory amounts) = IToucanPool(poolToken).redeemAuto2(amount);\\n\\n        // Retire TCO2\\n        for (uint i = 0; i < listTCO2.length; i++) {\\n            if (amounts[i] == 0) continue;\\n\\n            retireTCO2(\\n                poolToken,\\n                listTCO2[i],\\n                amounts[i],\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice                      Redeems Toucan pool tokens using specific redemtion and retires the TCO2\\n     * @param poolToken             Pool token to use for this retirement\\n     * @param projectToken          Project token to use for this retirement\\n     * @param amount                Amount of the project token to retire\\n     * @param retiringAddress       Address initiating this retirement\\n     * @param retiringEntityString  String description of the retiring entity\\n     * @param beneficiaryAddress    0x address for the beneficiary\\n     * @param beneficiaryString     String description of the beneficiary\\n     * @param retirementMessage     String message for this specific retirement\\n     * @return retiredAmount        The amount of TCO2 retired\\n     */\\n    function redeemSpecificAndRetire(\\n        address poolToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal returns (uint retiredAmount) {\\n        // Redeem pool tokens\\n        // Put redemption address into arrays for calling the redeem.\\n        address[] memory projectTokens = new address[](1);\\n        projectTokens[0] = projectToken;\\n\\n        uint[] memory amounts = new uint256[](1);\\n        amounts[0] = amount;\\n\\n        // Fetch balances, redeem, and update for net amount of TCO2 received from redemption.\\n        uint beforeBalance = IERC20(projectToken).balanceOf(address(this));\\n        IToucanPool(poolToken).redeemMany(projectTokens, amounts);\\n        amount = IERC20(projectToken).balanceOf(address(this)) - beforeBalance;\\n\\n        // Retire TCO2\\n        retireTCO2(\\n            poolToken,\\n            projectToken,\\n            amount,\\n            retiringAddress,\\n            retiringEntityString,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage\\n        );\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice                      Redeems Toucan TCO2s\\n     * @param poolToken             Pool token to use for this retirement\\n     * @param projectToken          Project token to use for this retirement\\n     * @param amount                Amount of the project token to retire\\n     * @param retiringAddress       Address initiating this retirement\\n     * @param retiringEntityString  String description of the retiring entity\\n     * @param beneficiaryAddress    0x address for the beneficiary\\n     * @param beneficiaryString     String description of the beneficiary\\n     * @param retirementMessage     String message for this specific retirement\\n     */\\n    function retireTCO2(\\n        address poolToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal {\\n        IToucanCarbonOffsets(projectToken).retireAndMintCertificate(\\n            retiringEntityString,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage,\\n            amount\\n        );\\n\\n        LibRetire.saveRetirementDetails(\\n            poolToken,\\n            projectToken,\\n            amount,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage\\n        );\\n\\n        emit CarbonRetired(\\n            LibRetire.CarbonBridge.TOUCAN,\\n            retiringAddress,\\n            retiringEntityString,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage,\\n            poolToken,\\n            projectToken,\\n            amount\\n        );\\n\\n        sendRetireCert(beneficiaryAddress);\\n    }\\n\\n    /**\\n     * @notice                      Send the ERC-721 retirement certificate received to a beneficiary\\n     * @param _beneficiary          Beneficiary to send the certificate to\\n     */\\n    function sendRetireCert(address _beneficiary) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        // Transfer the latest ERC721 retirement token to the beneficiary\\n        IERC721(C.toucanCert()).safeTransferFrom(address(this), _beneficiary, s.lastERC721Received);\\n    }\\n\\n    /**\\n     * @notice                      Calculates the additional pool tokens needed to specifically redeem x TCO2s\\n     * @param poolToken             Pool token to redeem\\n     * @param amount                Amount of TCO2 needed\\n     * @return poolFeeAmount        Number of additional pool tokens needed\\n     */\\n    function getSpecificRedeemFee(address poolToken, uint amount) internal view returns (uint poolFeeAmount) {\\n        bool feeExempt;\\n\\n        try IToucanPool(poolToken).redeemFeeExemptedAddresses(address(this)) returns (bool result) {\\n            feeExempt = result;\\n        } catch {\\n            feeExempt = false;\\n        }\\n\\n        if (feeExempt) {\\n            poolFeeAmount = 0;\\n        } else {\\n            uint feeRedeemBp = IToucanPool(poolToken).feeRedeemPercentageInBase();\\n            uint feeRedeemDivider = IToucanPool(poolToken).feeRedeemDivider();\\n            poolFeeAmount = ((amount * feeRedeemDivider) / (feeRedeemDivider - feeRedeemBp)) - amount;\\n        }\\n    }\\n\\n    /**\\n     * @notice                      Returns the number of TCO2s retired when selectively redeeming x pool tokens\\n     * @param poolToken             Pool token to redeem\\n     * @param amount                Amount of pool tokens redeemed\\n     * @return retireAmount        Number TCO2s that can be retired.\\n     */\\n    function getSpecificRetireAmount(address poolToken, uint amount) internal view returns (uint retireAmount) {\\n        bool feeExempt;\\n\\n        try IToucanPool(poolToken).redeemFeeExemptedAddresses(address(this)) returns (bool result) {\\n            feeExempt = result;\\n        } catch {\\n            feeExempt = false;\\n        }\\n\\n        if (feeExempt) {\\n            retireAmount = amount;\\n        } else {\\n            uint feeRedeemBp = IToucanPool(poolToken).feeRedeemPercentageInBase();\\n            uint feeRedeemDivider = IToucanPool(poolToken).feeRedeemDivider();\\n            retireAmount = (amount * (feeRedeemDivider - feeRedeemBp)) / feeRedeemDivider;\\n        }\\n    }\\n\\n    /**\\n     * @notice                      Simple wrapper to use redeem Toucan pools using the default list\\n     * @param poolToken             Pool token to redeem\\n     * @param amount                Amount of tokens being redeemed\\n     * @param toMode                Where to send TCO2 tokens\\n     * @return projectTokens        TCO2 token addresses redeemed\\n     * @return amounts              TCO2 token amounts redeemed\\n     */\\n    function redeemPoolAuto(\\n        address poolToken,\\n        uint amount,\\n        LibTransfer.To toMode\\n    ) internal returns (address[] memory projectTokens, uint[] memory amounts) {\\n        (projectTokens, amounts) = IToucanPool(poolToken).redeemAuto2(amount);\\n        for (uint i; i < projectTokens.length; i++) {\\n            LibTransfer.sendToken(IERC20(projectTokens[i]), amounts[i], msg.sender, toMode);\\n        }\\n    }\\n\\n    /**\\n     * @notice                      Simple wrapper to use redeem Toucan pools using the specific list\\n     * @param poolToken             Pool token to redeem\\n     * @param projectTokens         Project tokens to redeem\\n     * @param amounts               Token amounts to redeem\\n     * @param toMode                Where to send TCO2 tokens\\n     * @return redeemedAmounts      TCO2 token amounts redeemed\\n     */\\n    function redeemPoolSpecific(\\n        address poolToken,\\n        address[] memory projectTokens,\\n        uint[] memory amounts,\\n        LibTransfer.To toMode\\n    ) internal returns (uint[] memory) {\\n        uint[] memory beforeBalances = new uint256[](projectTokens.length);\\n        uint[] memory redeemedAmounts = new uint256[](projectTokens.length);\\n\\n        IToucanPool(poolToken).redeemMany(projectTokens, amounts);\\n\\n        for (uint i; i < projectTokens.length; i++) {\\n            redeemedAmounts[i] = IERC20(projectTokens[i]).balanceOf(address(this)) - beforeBalances[i];\\n            LibTransfer.sendToken(IERC20(projectTokens[i]), redeemedAmounts[i], msg.sender, toMode);\\n        }\\n        return redeemedAmounts;\\n    }\\n\\n    function isValid(address token) internal returns (bool) {\\n        return IToucanContractRegistry(C.toucanRegistry()).isValidERC20(token);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/Bridges/LibMossCarbon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"../../C.sol\\\";\\nimport \\\"../LibRetire.sol\\\";\\nimport \\\"../Token/LibApprove.sol\\\";\\nimport \\\"../../interfaces/ICarbonChain.sol\\\";\\n\\n/**\\n * @author Cujo\\n * @title LibMossCarbon\\n */\\n\\nlibrary LibMossCarbon {\\n    using LibApprove for IERC20;\\n\\n    event CarbonRetired(\\n        LibRetire.CarbonBridge carbonBridge,\\n        address indexed retiringAddress,\\n        string retiringEntityString,\\n        address indexed beneficiaryAddress,\\n        string beneficiaryString,\\n        string retirementMessage,\\n        address indexed carbonPool,\\n        address carbonToken,\\n        uint retiredAmount\\n    );\\n\\n    /**\\n     * @notice                      Retires Moss MCO2 tokens on Polygon\\n     * @param poolToken             Pool token to use for this retirement\\n     * @param amount                Amounts of the project tokens to retire\\n     * @param retiringAddress      Address initiating this retirement\\n     * @param retiringEntityString String description of the retiring entity\\n     * @param beneficiaryAddress   0x address for the beneficiary\\n     * @param beneficiaryString    String description of the beneficiary\\n     * @param retirementMessage    String message for this specific retirement\\n     */\\n    function offsetCarbon(\\n        address poolToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal {\\n        // Retire MCO2\\n        LibApprove.approveToken(IERC20(poolToken), C.mossCarbonChain(), amount);\\n        ICarbonChain(C.mossCarbonChain()).offsetCarbon(amount, retirementMessage, beneficiaryString);\\n\\n        LibRetire.saveRetirementDetails(\\n            poolToken,\\n            address(0), // MCO2 does not have an underlying project token.\\n            amount,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage\\n        );\\n\\n        emit CarbonRetired(\\n            LibRetire.CarbonBridge.MOSS,\\n            retiringAddress,\\n            retiringEntityString,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage,\\n            poolToken,\\n            address(0), // MCO2 does not have an underlying project token.\\n            amount\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/Bridges/LibC3Carbon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"../LibRetire.sol\\\";\\nimport \\\"../Token/LibTransfer.sol\\\";\\nimport \\\"../../interfaces/IC3.sol\\\";\\nimport \\\"../../C.sol\\\";\\n\\nimport \\\"lib/forge-std/src/console.sol\\\";\\n\\n/**\\n * @author Cujo\\n * @title LibC3Carbon\\n */\\n\\nlibrary LibC3Carbon {\\n    event CarbonRetired(\\n        LibRetire.CarbonBridge carbonBridge,\\n        address indexed retiringAddress,\\n        string retiringEntityString,\\n        address indexed beneficiaryAddress,\\n        string beneficiaryString,\\n        string retirementMessage,\\n        address indexed carbonPool,\\n        address carbonToken,\\n        uint retiredAmount\\n    );\\n\\n    /**\\n     * @notice                     Calls freeRedeem on a C3 pool and retires the underlying C3T\\n     * @param poolToken            Pool token to use for this retirement\\n     * @param amount               Amount of tokens to redeem and retire\\n     * @param retiringAddress      Address initiating this retirement\\n     * @param retiringEntityString String description of the retiring entity\\n     * @param beneficiaryAddress   0x address for the beneficiary\\n     * @param beneficiaryString    String description of the beneficiary\\n     * @param retirementMessage    String message for this specific retirement\\n     */\\n    function freeRedeemAndRetire(\\n        address poolToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal {\\n        address[] memory projectTokens = IC3Pool(poolToken).getFreeRedeemAddresses();\\n\\n        // Redeem pool tokens\\n        IC3Pool(poolToken).freeRedeem(amount);\\n\\n        // Retire C3T\\n        for (uint i = 0; i < projectTokens.length && amount > 0; i++) {\\n            uint balance = IERC20(projectTokens[i]).balanceOf(address(this));\\n            // Skip over any C3Ts returned that were not actually redeemed.\\n            if (balance == 0) continue;\\n\\n            retireC3T(\\n                poolToken,\\n                projectTokens[i],\\n                balance,\\n                retiringAddress,\\n                retiringEntityString,\\n                beneficiaryAddress,\\n                beneficiaryString,\\n                retirementMessage\\n            );\\n\\n            amount -= balance;\\n        }\\n\\n        require(amount == 0, \\\"Didn't retire all tons\\\");\\n    }\\n\\n    /**\\n     * @notice                     Calls taxedRedeem on a C3 pool and retires the underlying C3T\\n     * @param poolToken            Pool token to use for this retirement\\n     * @param projectToken         Project token being redeemed\\n     * @param amount               Amount of tokens to redeem and retire\\n     * @param retiringAddress      Address initiating this retirement\\n     * @param retiringEntityString String description of the retiring entity\\n     * @param beneficiaryAddress   0x address for the beneficiary\\n     * @param beneficiaryString    String description of the beneficiary\\n     * @param retirementMessage    String message for this specific retirement\\n     */\\n    function redeemSpecificAndRetire(\\n        address poolToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal {\\n        // Redeem pool tokens\\n        // C3 fee is additive, not subtractive\\n\\n        // Put redemption address into arrays for calling the redeem.\\n\\n        address[] memory projectTokens = new address[](1);\\n        projectTokens[0] = projectToken;\\n\\n        uint[] memory amounts = new uint256[](1);\\n        amounts[0] = amount;\\n\\n        IC3Pool(poolToken).taxedRedeem(projectTokens, amounts);\\n\\n        // Retire C3T\\n        retireC3T(\\n            poolToken,\\n            projectToken,\\n            amount,\\n            retiringAddress,\\n            retiringEntityString,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage\\n        );\\n    }\\n\\n    /**\\n     * @notice                     Retire a C3T token\\n     * @param poolToken            Pool token to use for this retirement\\n     * @param projectToken         Project token being redeemed\\n     * @param amount               Amount of tokens to redeem and retire\\n     * @param retiringAddress      Address initiating this retirement\\n     * @param retiringEntityString String description of the retiring entity\\n     * @param beneficiaryAddress   0x address for the beneficiary\\n     * @param beneficiaryString    String description of the beneficiary\\n     * @param retirementMessage    String message for this specific retirement\\n     */\\n    function retireC3T(\\n        address poolToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage\\n    ) internal {\\n        IC3ProjectToken(projectToken).offsetFor(amount, beneficiaryAddress, beneficiaryString, retirementMessage);\\n\\n        LibRetire.saveRetirementDetails(\\n            poolToken,\\n            projectToken,\\n            amount,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage\\n        );\\n\\n        emit CarbonRetired(\\n            LibRetire.CarbonBridge.C3,\\n            retiringAddress,\\n            retiringEntityString,\\n            beneficiaryAddress,\\n            beneficiaryString,\\n            retirementMessage,\\n            poolToken,\\n            projectToken,\\n            amount\\n        );\\n    }\\n\\n    /**\\n     * @notice                     Return the additional fee needed to redeem specific number of project tokens.\\n     * @param poolToken            Pool token to use for this retirement\\n     * @param amount               Amount of tokens to redeem and retire\\n     * @return poolFeeAmount       Additional C3 pool tokens needed for the redemption\\n     */\\n    function getExactCarbonSpecificRedeemFee(\\n        address poolToken,\\n        uint amount\\n    ) internal view returns (uint poolFeeAmount) {\\n        uint feeRedeem = IC3Pool(poolToken).feeRedeem();\\n        uint feeDivider = 10_000; // This is hardcoded in current C3 contract.\\n\\n        poolFeeAmount = (amount * feeRedeem) / feeDivider;\\n    }\\n\\n    /**\\n     * @notice                     Return the amount that can be specifically redeemed from a C3 given x number of tokens.\\n     * @param poolToken            Pool token to use for this retirement\\n     * @param amount               Amount of tokens to redeem and retire\\n     * @return retireAmount        Amount of C3T that can be specifically redeemed from a given pool amount\\n     */\\n    function getExactSourceSpecificRetireAmount(\\n        address poolToken,\\n        uint amount\\n    ) internal view returns (uint retireAmount) {\\n        // Backing into a redemption amount from a total pool token amount\\n        uint feeRedeem = IC3Pool(poolToken).feeRedeem();\\n        uint feeDivider = 10_000; // This is hardcoded in current C3 contract.\\n\\n        retireAmount = (amount * feeDivider) / (feeDivider + feeRedeem);\\n    }\\n\\n    /**\\n     * @notice                     Receives and redeems a number of pool tokens and sends the C3T to a destination..\\n     * @param poolToken            Pool token to use for this retirement\\n     * @param amount               Amount of tokens to redeem and retire\\n     * @param toMode               Where to send redeemed tokens to\\n     * @return allProjectTokens    Default redeem C3T list from the pool\\n     * @return amounts             Amount of C3T that was redeemed from the pool\\n     */\\n    function redeemPoolAuto(\\n        address poolToken,\\n        uint amount,\\n        LibTransfer.To toMode\\n    ) internal returns (address[] memory allProjectTokens, uint[] memory amounts) {\\n        allProjectTokens = IC3Pool(poolToken).getFreeRedeemAddresses();\\n        amounts = new uint256[](allProjectTokens.length);\\n\\n        // Redeem pool tokens\\n        IC3Pool(poolToken).freeRedeem(amount);\\n\\n        for (uint i = 0; i < allProjectTokens.length && amount > 0; i++) {\\n            uint balance = IERC20(allProjectTokens[i]).balanceOf(address(this));\\n            // Skip over any C3Ts returned that were not actually redeemed.\\n            if (balance == 0) continue;\\n\\n            amounts[i] = balance;\\n\\n            LibTransfer.sendToken(IERC20(allProjectTokens[i]), balance, msg.sender, toMode);\\n            amount -= balance;\\n        }\\n\\n        require(amount == 0, \\\"Didn't redeem all tons\\\");\\n    }\\n\\n    /**\\n     * @notice                      Receives and redeems a number of pool tokens and sends the C3T to a destination.\\n     * @param poolToken             Pool token to use for this retirement\\n     * @param projectTokens         Project tokens to redeem\\n     * @param amounts               Amounts of the project tokens to redeem\\n     * @param toMode                Where to send redeemed tokens to\\n     * @return redeemedAmounts      Amounts of the project tokens redeemed\\n     */\\n    function redeemPoolSpecific(\\n        address poolToken,\\n        address[] memory projectTokens,\\n        uint[] memory amounts,\\n        LibTransfer.To toMode\\n    ) internal returns (uint[] memory) {\\n        uint[] memory beforeBalances = new uint256[](projectTokens.length);\\n        uint[] memory redeemedAmounts = new uint256[](projectTokens.length);\\n        for (uint i; i < projectTokens.length; i++) {\\n            beforeBalances[i] = IERC20(projectTokens[i]).balanceOf(address(this));\\n        }\\n\\n        IC3Pool(poolToken).taxedRedeem(projectTokens, amounts);\\n\\n        for (uint i; i < projectTokens.length; i++) {\\n            redeemedAmounts[i] = IERC20(projectTokens[i]).balanceOf(address(this)) - beforeBalances[i];\\n            LibTransfer.sendToken(IERC20(projectTokens[i]), redeemedAmounts[i], msg.sender, toMode);\\n        }\\n        return redeemedAmounts;\\n    }\\n\\n    function isValid(address token) internal returns (bool) {\\n        return IC3ProjectFactory(C.c3ProjectFactory()).isTokenExists(token);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/Token/LibTransfer.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT*/\\n\\n/**\\n * @author publius\\n * @title LibTransfer handles the recieving and sending of Tokens to/from internal Balances.\\n *\\n */\\npragma solidity ^0.8.16;\\n\\nimport \\\"oz/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./LibBalance.sol\\\";\\n\\nlibrary LibTransfer {\\n    using SafeERC20 for IERC20;\\n\\n    enum From {\\n        EXTERNAL,\\n        INTERNAL,\\n        EXTERNAL_INTERNAL,\\n        INTERNAL_TOLERANT\\n    }\\n    enum To {\\n        EXTERNAL,\\n        INTERNAL\\n    }\\n\\n    function transferToken(IERC20 token, address recipient, uint amount, From fromMode, To toMode)\\n        internal\\n        returns (uint transferredAmount)\\n    {\\n        if (fromMode == From.EXTERNAL && toMode == To.EXTERNAL) {\\n            uint beforeBalance = token.balanceOf(recipient);\\n            token.safeTransferFrom(msg.sender, recipient, amount);\\n            return token.balanceOf(recipient) - beforeBalance;\\n        }\\n        amount = receiveToken(token, amount, msg.sender, fromMode);\\n        sendToken(token, amount, recipient, toMode);\\n        return amount;\\n    }\\n\\n    function receiveToken(IERC20 token, uint amount, address sender, From mode)\\n        internal\\n        returns (uint receivedAmount)\\n    {\\n        if (amount == 0) return 0;\\n        if (mode != From.EXTERNAL) {\\n            receivedAmount = LibBalance.decreaseInternalBalance(sender, token, amount, mode != From.INTERNAL);\\n            if (amount == receivedAmount || mode == From.INTERNAL_TOLERANT) return receivedAmount;\\n        }\\n        uint beforeBalance = token.balanceOf(address(this));\\n        token.safeTransferFrom(sender, address(this), amount - receivedAmount);\\n        return receivedAmount + (token.balanceOf(address(this)) - beforeBalance);\\n    }\\n\\n    function sendToken(IERC20 token, uint amount, address recipient, To mode) internal {\\n        if (amount == 0) return;\\n        if (mode == To.INTERNAL) LibBalance.increaseInternalBalance(recipient, token, amount);\\n        else token.safeTransfer(recipient, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/TokenSwap/LibSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @author Cujo\\n * @title LibSwap\\n */\\n\\nimport \\\"../../C.sol\\\";\\nimport \\\"../LibAppStorage.sol\\\";\\nimport \\\"../LibKlima.sol\\\";\\nimport \\\"../Token/LibTransfer.sol\\\";\\nimport \\\"./LibUniswapV2Swap.sol\\\";\\nimport \\\"./LibTridentSwap.sol\\\";\\nimport \\\"./LibTreasurySwap.sol\\\";\\n\\nlibrary LibSwap {\\n    using LibTransfer for IERC20;\\n\\n    /* ========== Swap to Exact Carbon Default Functions ========== */\\n\\n    /**\\n     * @notice                      Swaps to an exact number of carbon tokens\\n     * @param sourceToken           Source token provided to swap\\n     * @param carbonToken           Pool token needed\\n     * @param sourceAmount          Max amount of the source token\\n     * @param carbonAmount          Needed amount of tokens out\\n     * @return carbonReceived       Pool tokens actually received\\n     */\\n    function swapToExactCarbonDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint sourceAmount,\\n        uint carbonAmount\\n    ) internal returns (uint carbonReceived) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // If providing a staked version of Klima, update sourceToken to use Klima default path.\\n        if (sourceToken == C.sKlima() || sourceToken == C.wsKlima()) sourceToken = C.klima();\\n\\n        // If source token is not defined in the default, swap to USDC on Sushiswap.\\n        // This is wrapped in its own statement to allow for the fewest number of swaps\\n        if (s.swap[carbonToken][sourceToken].swapDexes.length == 0) {\\n            address[] memory firstPath = new address[](s.swap[carbonToken][C.usdc()].swapPaths[0].length + 1);\\n            firstPath[0] = sourceToken;\\n            for (uint8 i = 0; i < s.swap[carbonToken][C.usdc()].swapPaths[0].length; ++i) {\\n                firstPath[i + 1] = s.swap[carbonToken][C.usdc()].swapPaths[0][i];\\n            }\\n\\n            // Now that we have added to the initial USDC path, set the sourceToken to USDC and proceed as normal.\\n            sourceToken = C.usdc();\\n\\n            // Single DEX swap\\n            if (s.swap[carbonToken][sourceToken].swapDexes.length == 1) {\\n                return\\n                    _performToExactSwap(\\n                        s.swap[carbonToken][sourceToken].swapDexes[0],\\n                        s.swap[carbonToken][sourceToken].ammRouters[0],\\n                        firstPath,\\n                        sourceAmount,\\n                        carbonAmount\\n                    );\\n            }\\n\\n            // Multiple DEX swap\\n            uint256[] memory amountsIn = getMultipleSourceAmount(sourceToken, carbonToken, carbonAmount);\\n            carbonReceived = sourceAmount;\\n            for (uint256 i = 0; i < s.swap[carbonToken][sourceToken].swapDexes.length; ++i) {\\n                carbonReceived = _performToExactSwap(\\n                    s.swap[carbonToken][sourceToken].swapDexes[i],\\n                    s.swap[carbonToken][sourceToken].ammRouters[i],\\n                    i == 0 ? firstPath : s.swap[carbonToken][sourceToken].swapPaths[uint8(i)],\\n                    carbonReceived,\\n                    i + 1 == s.swap[carbonToken][sourceToken].swapDexes.length ? carbonAmount : amountsIn[i + 1]\\n                );\\n            }\\n            return carbonReceived;\\n        }\\n\\n        // Single DEX swap\\n        if (s.swap[carbonToken][sourceToken].swapDexes.length == 1) {\\n            return\\n                _performToExactSwap(\\n                    s.swap[carbonToken][sourceToken].swapDexes[0],\\n                    s.swap[carbonToken][sourceToken].ammRouters[0],\\n                    s.swap[carbonToken][sourceToken].swapPaths[0],\\n                    sourceAmount,\\n                    carbonAmount\\n                );\\n        }\\n\\n        // Multiple DEX swap\\n        uint256[] memory amountsIn = getMultipleSourceAmount(sourceToken, carbonToken, carbonAmount);\\n        carbonReceived = sourceAmount;\\n        for (uint256 i = 0; i < s.swap[carbonToken][sourceToken].swapDexes.length; ++i) {\\n            carbonReceived = _performToExactSwap(\\n                s.swap[carbonToken][sourceToken].swapDexes[i],\\n                s.swap[carbonToken][sourceToken].ammRouters[i],\\n                s.swap[carbonToken][sourceToken].swapPaths[uint8(i)],\\n                carbonReceived,\\n                i + 1 == s.swap[carbonToken][sourceToken].swapDexes.length ? carbonAmount : amountsIn[i + 1]\\n            );\\n        }\\n        return carbonReceived;\\n    }\\n\\n    /* ========== Swap to Exact Source Default Functions ========== */\\n\\n    /**\\n     * @notice                      Swaps to an exact number of source tokens\\n     * @param sourceToken           Source token provided to swap\\n     * @param carbonToken           Pool token needed\\n     * @param amount                Amount of the source token to swap\\n     * @return carbonReceived       Pool tokens actually received\\n     */\\n    function swapExactSourceToCarbonDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount\\n    ) internal returns (uint carbonReceived) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        // If providing a staked version of Klima, update sourceToken to use Klima default path.\\n        if (sourceToken == C.sKlima() || sourceToken == C.wsKlima()) sourceToken = C.klima();\\n\\n        // If source token is not defined in the default, swap to USDC on Sushiswap.\\n        // Then use the USDC default path.\\n        if (s.swap[carbonToken][sourceToken].swapDexes.length == 0) {\\n            address[] memory path = new address[](2);\\n            path[0] = sourceToken;\\n            path[1] = C.usdc();\\n\\n            amount = _performExactSourceSwap(\\n                s.swap[carbonToken][C.usdc()].swapDexes[0],\\n                s.swap[carbonToken][C.usdc()].ammRouters[0],\\n                path,\\n                amount\\n            );\\n            // Now that we have USDC, set the sourceToken to USDC and proceed as normal.\\n            sourceToken = C.usdc();\\n        }\\n\\n        // Single DEX swap\\n        if (s.swap[carbonToken][sourceToken].swapDexes.length == 1) {\\n            return\\n                _performExactSourceSwap(\\n                    s.swap[carbonToken][sourceToken].swapDexes[0],\\n                    s.swap[carbonToken][sourceToken].ammRouters[0],\\n                    s.swap[carbonToken][sourceToken].swapPaths[0],\\n                    amount\\n                );\\n        }\\n\\n        // Multiple DEX swap\\n        uint256 currentOutput;\\n        for (uint256 i = 0; i < s.swap[carbonToken][sourceToken].swapDexes.length; ++i) {\\n            currentOutput = _performExactSourceSwap(\\n                s.swap[carbonToken][sourceToken].swapDexes[i],\\n                s.swap[carbonToken][sourceToken].ammRouters[i],\\n                s.swap[carbonToken][sourceToken].swapPaths[uint8(i)],\\n                i == 0 ? amount : currentOutput\\n            );\\n        }\\n        return currentOutput;\\n    }\\n\\n    /**\\n     * @notice                  Return any dust/slippaged amounts still held by the contract\\n     * @param sourceToken       Source token provided to swap\\n     * @param poolToken         Pool token used\\n     */\\n    function returnTradeDust(address sourceToken, address poolToken) internal {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        address dustToken = sourceToken;\\n        if (sourceToken == C.wsKlima() || sourceToken == C.sKlima()) dustToken = C.klima();\\n        else if (s.swap[poolToken][sourceToken].swapDexes.length == 0) {\\n            dustToken = C.usdc();\\n            sourceToken = C.usdc();\\n        }\\n\\n        uint256 dustBalance = IERC20(dustToken).balanceOf(address(this));\\n\\n        if (dustBalance != 0) {\\n            if (sourceToken == C.wsKlima()) dustBalance = LibKlima.wrapKlima(dustBalance);\\n            if (sourceToken == C.sKlima()) LibKlima.stakeKlima(dustBalance);\\n\\n            LibTransfer.sendToken(IERC20(sourceToken), dustBalance, msg.sender, LibTransfer.To.EXTERNAL);\\n        }\\n    }\\n\\n    /* ========== Smaller Specific Swap Functions ========== */\\n\\n    /**\\n     * @notice                  Swaps a given amount of USDC for KLIMA using Sushiswap\\n     * @param sourceAmount      Amount of USDC to swap\\n     * @param klimaAmount       Amount of KLIMA to swap for\\n     * @return klimaReceived    Amount of KLIMA received\\n     */\\n    function swapToKlimaFromUsdc(uint256 sourceAmount, uint256 klimaAmount) internal returns (uint256 klimaReceived) {\\n        address[] memory path = new address[](2);\\n        path[0] = C.usdc();\\n        path[1] = C.klima();\\n\\n        return _performToExactSwap(0, C.sushiRouter(), path, sourceAmount, klimaAmount);\\n    }\\n\\n    /**\\n     * @notice                  Swaps from arbitrary token routed through USDC for KLIMA\\n     * @param sourceToken       Source token provided to swap\\n     * @param sourceAmount      Amount of source token to swap\\n     * @param klimaAmount       Amount of KLIMA to swap for\\n     * @return klimaReceived    Amount of KLIMA received\\n     */\\n    function swapToKlimaFromOther(address sourceToken, uint256 sourceAmount, uint256 klimaAmount)\\n        internal\\n        returns (uint256 klimaReceived)\\n    {\\n        address[] memory path = new address[](3);\\n        path[0] = sourceToken;\\n        path[1] = C.usdc();\\n        path[2] = C.klima();\\n        return _performToExactSwap(0, C.sushiRouter(), path, sourceAmount, klimaAmount);\\n    }\\n\\n    /**\\n     * @notice                  Performs a swap with Retirement Bonds for carbon to retire.\\n     * @param sourceToken       Source token provided to swap\\n     * @param carbonToken       Carbon token to receive\\n     * @param sourceAmount      Amount of source token to swap\\n     * @param carbonAmount      Amount of carbon token needed\\n     * @return carbonRecieved   Amount of carbon token received from the swap\\n     */\\n    function swapWithRetirementBonds(\\n        address sourceToken,\\n        address carbonToken,\\n        uint256 sourceAmount,\\n        uint256 carbonAmount\\n    ) internal returns (uint256 carbonRecieved) {\\n        // Any form of KLIMA should be unwrapped/unstaked before this is called.\\n        if (sourceToken == C.klima() || sourceToken == C.sKlima() || sourceToken == C.wsKlima()) {\\n            LibTreasurySwap.swapToExact(carbonToken, sourceAmount, carbonAmount);\\n            return carbonAmount;\\n        }\\n\\n        // The only other source tokens at this point should be USDC or non-KLIMA and non-Pool tokens\\n\\n        if (sourceToken == C.usdc()) {\\n            sourceAmount = swapToKlimaFromUsdc(sourceAmount, LibTreasurySwap.getAmountIn(carbonToken, carbonAmount));\\n        } else {\\n            sourceAmount =\\n                swapToKlimaFromOther(sourceToken, sourceAmount, LibTreasurySwap.getAmountIn(carbonToken, carbonAmount));\\n        }\\n\\n        LibTreasurySwap.swapToExact(carbonToken, sourceAmount, carbonAmount);\\n        return carbonAmount;\\n    }\\n\\n    /* ========== Source Amount View Functions ========== */\\n\\n    /**\\n     * @notice                  Get the source amount needed when swapping within a single DEX\\n     * @param sourceToken       Source token provided to swap\\n     * @param carbonToken       Pool token used\\n     * @param amount            Amount of carbon tokens needed\\n     * @return sourceNeeded     Total source tokens needed for output amount\\n     */\\n    function getSourceAmount(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount\\n    ) internal view returns (uint sourceNeeded) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint8 wrapped;\\n        if (sourceToken == C.wsKlima()) wrapped = 1;\\n        if (sourceToken == C.sKlima() || sourceToken == C.wsKlima()) sourceToken = C.klima();\\n\\n        if (s.swap[carbonToken][sourceToken].swapDexes.length == 1) {\\n            if (wrapped == 0) {\\n                return\\n                    _getAmountIn(\\n                        s.swap[carbonToken][sourceToken].swapDexes[0],\\n                        s.swap[carbonToken][sourceToken].ammRouters[0],\\n                        s.swap[carbonToken][sourceToken].swapPaths[0],\\n                        amount\\n                    );\\n            }\\n\\n            return\\n                LibKlima.toWrappedAmount(\\n                    _getAmountIn(\\n                        s.swap[carbonToken][sourceToken].swapDexes[0],\\n                        s.swap[carbonToken][sourceToken].ammRouters[0],\\n                        s.swap[carbonToken][sourceToken].swapPaths[0],\\n                        amount\\n                    )\\n                );\\n        } else if (s.swap[carbonToken][sourceToken].swapDexes.length > 1) {\\n            uint256[] memory amountsIn = getMultipleSourceAmount(sourceToken, carbonToken, amount);\\n            if (wrapped == 0) return amountsIn[0];\\n            return LibKlima.toWrappedAmount(amountsIn[0]);\\n        } else {\\n            uint256 usdcAmount = getSourceAmount(C.usdc(), carbonToken, amount);\\n            address[] memory usdcPath = new address[](2);\\n            usdcPath[0] = sourceToken;\\n            usdcPath[1] = C.usdc();\\n            // Swap to USDC on Sushiswap\\n            return _getAmountIn(0, C.sushiRouter(), usdcPath, usdcAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice                  Get the source amount needed when swapping between multiple DEXs\\n     * @param sourceToken       Source token provided to swap\\n     * @param carbonToken       Pool token used\\n     * @param amount            Amount of carbon tokens needed\\n     * @return sourcesNeeded    Total source tokens needed for output amount\\n     */\\n    function getMultipleSourceAmount(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount\\n    ) internal view returns (uint[] memory) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        uint256[] memory sourcesNeeded = new uint256[](s.swap[carbonToken][sourceToken].swapDexes.length);\\n        uint256 currentAmount = amount;\\n        for (uint256 i = 0; i < s.swap[carbonToken][sourceToken].swapDexes.length; ++i) {\\n            // Work backwards from the path definitions to get total source amount\\n            uint8 index = uint8(s.swap[carbonToken][sourceToken].swapDexes.length - 1 - i);\\n\\n            sourcesNeeded[s.swap[carbonToken][sourceToken].swapDexes.length - 1 - i] = _getAmountIn(\\n                s.swap[carbonToken][sourceToken].swapDexes[index],\\n                s.swap[carbonToken][sourceToken].ammRouters[index],\\n                s.swap[carbonToken][sourceToken].swapPaths[index],\\n                currentAmount\\n            );\\n\\n            currentAmount = sourcesNeeded[s.swap[carbonToken][sourceToken].swapDexes.length - 1 - i];\\n        }\\n\\n        return sourcesNeeded;\\n    }\\n\\n    /**\\n     * @notice                  Fetches the amount of KLIMA needed for a retirement bond, then calculates the source\\n     *                          amount needed if a DEX swap is required.\\n     * @param sourceToken       Source token provided to swap\\n     * @param carbonToken       Pool token used\\n     * @param amount            Amount of carbon tokens needed\\n     * @return sourceNeeded     Total source tokens needed for output amount\\n     */\\n     function getSourceAmountFromRetirementBond(\\n        address sourceToken,\\n        address carbonToken,\\n        uint256 amount\\n    ) internal view returns (uint256 sourceNeeded) {\\n        // Return the direct quote in KLIMA first\\n        if (sourceToken == C.klima() || sourceToken == C.sKlima())\\n            return LibTreasurySwap.getAmountIn(carbonToken,amount);\\n\\n        // Wrap the amount if using wsKLIMA\\n        if (sourceToken == C.wsKlima())\\n            return LibKlima.toWrappedAmount(LibTreasurySwap.getAmountIn(carbonToken,amount));\\n\\n        // Direct swap from USDC to KLIMA on Sushi\\n        if (sourceToken == C.usdc()) {\\n            uint256 klimaAmount = LibTreasurySwap.getAmountIn(carbonToken,amount);\\n            \\n            address[] memory path = new address[](2);\\n            path[0] = C.usdc();\\n            path[1] = C.klima();\\n            \\n            return LibUniswapV2Swap.getAmountIn(C.sushiRouter(), path, klimaAmount);\\n        }\\n\\n        // At this point we only have non USDC and not KLIMA tokens. Route through a source <> USDC pool on Sushi\\n        uint256 klimaAmount = LibTreasurySwap.getAmountIn(carbonToken,amount);\\n        \\n        address[] memory path = new address[](3);\\n        path[0] = sourceToken;\\n        path[1] = C.usdc();\\n        path[2] = C.klima();\\n            \\n        return LibUniswapV2Swap.getAmountIn(C.sushiRouter(), path, klimaAmount);\\n    }\\n\\n    /* ========== Output Amount View Functions ========== */\\n\\n    /**\\n     * @notice                  Get the source amount needed when swapping between multiple DEXs\\n     * @param sourceToken       Source token provided to swap\\n     * @param carbonToken       Pool token used\\n     * @param amount            Amount of carbon tokens needed\\n     * @return amountOut        Amount of carbonTokens recieved for the input amount\\n     */\\n    function getDefaultAmountOut(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount\\n    ) internal view returns (uint amountOut) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n\\n        amountOut = amount;\\n\\n        if (sourceToken == C.wsKlima()) amountOut = LibKlima.toUnwrappedAmount(amount);\\n        if (sourceToken == C.sKlima() || sourceToken == C.wsKlima()) sourceToken = C.klima();\\n\\n        for (uint8 i = 0; i < s.swap[carbonToken][sourceToken].swapDexes.length; ++i) {\\n            amountOut = _getAmountOut(\\n                s.swap[carbonToken][sourceToken].swapDexes[i],\\n                s.swap[carbonToken][sourceToken].ammRouters[i],\\n                s.swap[carbonToken][sourceToken].swapPaths[i],\\n                amountOut\\n            );\\n        }\\n    }\\n\\n    /* ========== Private Functions ========== */\\n\\n    /**\\n     * @notice              Perform a toExact swap depending on the dex provided\\n     * @param dex           Identifier for which DEX to use\\n     * @param router        Router for the swap\\n     * @param path          Trade path to use\\n     * @param maxAmountIn   Max amount of source tokens to swap\\n     * @param amount        Total pool tokens needed\\n     * @return amountOut    Total pool tokens swapped\\n     */\\n    function _performToExactSwap(\\n        uint8 dex,\\n        address router,\\n        address[] memory path,\\n        uint maxAmountIn,\\n        uint amount\\n    ) private returns (uint amountOut) {\\n        // UniswapV2 is DEX ID 0\\n        if (dex == 0) {\\n            amountOut = LibUniswapV2Swap.swapTokensForExactTokens(router, path, maxAmountIn, amount);\\n        }\\n        if (dex == 1) {\\n            amountOut = LibTridentSwap.swapExactTokensForTokens(\\n                router,\\n                LibTridentSwap.getTridentPool(path[0], path[1]),\\n                path[0],\\n                LibTridentSwap.getAmountIn(LibTridentSwap.getTridentPool(path[0], path[1]), path[0], path[1], amount),\\n                amount\\n            );\\n        }\\n\\n        return amountOut;\\n    }\\n\\n    /**\\n     * @notice              Perform a swap using all source tokens\\n     * @param dex           Identifier for which DEX to use\\n     * @param router        Router for the swap\\n     * @param path          Trade path to use\\n     * @param amount        Amount of tokens to swap\\n     * @return amountOut    Total pool tokens swapped\\n     */\\n    function _performExactSourceSwap(\\n        uint8 dex,\\n        address router,\\n        address[] memory path,\\n        uint amount\\n    ) private returns (uint amountOut) {\\n        // UniswapV2 is DEX ID 0\\n        if (dex == 0) {\\n            amountOut = LibUniswapV2Swap.swapExactTokensForTokens(router, path, amount);\\n        } else if (dex == 1) {\\n            amountOut = LibTridentSwap.swapExactTokensForTokens(\\n                router,\\n                LibTridentSwap.getTridentPool(path[0], path[1]),\\n                path[0],\\n                amount,\\n                1\\n            );\\n        }\\n\\n        return amountOut;\\n    }\\n\\n    /**\\n     * @notice              Return the amountIn needed for an exact swap\\n     * @param dex           Identifier for which DEX to use\\n     * @param router        Router for the swap\\n     * @param path          Trade path to use\\n     * @param amount        Total pool tokens needed\\n     * @return amountIn     Total pool tokens swapped\\n     */\\n    function _getAmountIn(\\n        uint8 dex,\\n        address router,\\n        address[] memory path,\\n        uint amount\\n    ) private view returns (uint amountIn) {\\n        if (dex == 0) {\\n            amountIn = LibUniswapV2Swap.getAmountIn(router, path, amount);\\n        } else if (dex == 1) {\\n            amountIn = LibTridentSwap.getAmountIn(\\n                LibTridentSwap.getTridentPool(path[0], path[1]),\\n                path[0],\\n                path[1],\\n                amount\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice              Return the amountIn needed for an exact swap\\n     * @param dex           Identifier for which DEX to use\\n     * @param router        Router for the swap\\n     * @param path          Trade path to use\\n     * @param amount        Total source tokens spent\\n     * @return amountOut    Total pool tokens swapped\\n     */\\n    function _getAmountOut(\\n        uint8 dex,\\n        address router,\\n        address[] memory path,\\n        uint amount\\n    ) private view returns (uint amountOut) {\\n        if (dex == 0) {\\n            amountOut = LibUniswapV2Swap.getAmountOut(router, path, amount);\\n        } else if (dex == 1) {\\n            amountOut = LibTridentSwap.getAmountOut(\\n                LibTridentSwap.getTridentPool(path[0], path[1]),\\n                path[0],\\n                path[1],\\n                amount\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/IKlimaInfinity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.16;\\n\\ninterface IKlimaInfinity {\\n    function toucan_retireExactCarbonPoolDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function toucan_retireExactCarbonPoolWithEntityDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function toucan_retireExactSourcePoolDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function toucan_retireExactSourcePoolWithEntityDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function toucan_retireExactCarbonPoolSpecific(\\n        address sourceToken,\\n        address carbonToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function toucan_retireExactCarbonPoolWithEntitySpecific(\\n        address sourceToken,\\n        address poolToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function toucan_retireExactSourcePoolWithEntitySpecific(\\n        address sourceToken,\\n        address poolToken,\\n        address projectToken,\\n        uint sourceAmount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function toucan_retireExactSourcePoolSpecific(\\n        address sourceToken,\\n        address poolToken,\\n        address projectToken,\\n        uint sourceAmount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function moss_retireExactCarbonPoolDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function moss_retireExactCarbonPoolWithEntityDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function moss_retireExactSourcePoolDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint sourceAmount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function moss_retireExactSourcePoolWithEntityDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint sourceAmount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function c3_retireExactCarbonPoolDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function c3_retireExactCarbonPoolWithEntityDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function c3_retireExactSourcePoolDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint sourceAmount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function c3_retireExactSourcePoolWithEntityDefault(\\n        address sourceToken,\\n        address carbonToken,\\n        uint sourceAmount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function c3_retireExactCarbonPoolSpecific(\\n        address sourceToken,\\n        address carbonToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function c3_retireExactCarbonPoolWithEntitySpecific(\\n        address sourceToken,\\n        address poolToken,\\n        address projectToken,\\n        uint amount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function c3_retireExactSourcePoolWithEntitySpecific(\\n        address sourceToken,\\n        address poolToken,\\n        address projectToken,\\n        uint sourceAmount,\\n        address retiringAddress,\\n        string memory retiringEntityString,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n\\n    function c3_retireExactSourcePoolSpecific(\\n        address sourceToken,\\n        address poolToken,\\n        address projectToken,\\n        uint sourceAmount,\\n        address retiringAddress,\\n        address beneficiaryAddress,\\n        string memory beneficiaryString,\\n        string memory retirementMessage,\\n        uint8 fromMode\\n    ) external returns (uint retirementIndex);\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/IKlimaCarbonRetirements.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IKlimaCarbonRetirements {\\n    function carbonRetired(\\n        address _retiree,\\n        address _pool,\\n        uint _amount,\\n        string calldata _beneficiaryString,\\n        string calldata _retirementMessage\\n    ) external;\\n\\n    function getUnclaimedTotal(address _minter) external view returns (uint);\\n\\n    function offsetClaimed(address _minter, uint _amount) external returns (bool);\\n\\n    function getRetirementIndexInfo(address _retiree, uint _index)\\n        external\\n        view\\n        returns (address, uint, string memory, string memory);\\n\\n    function getRetirementPoolInfo(address _retiree, address _pool) external view returns (uint);\\n\\n    function getRetirementTotals(address _retiree) external view returns (uint, uint, uint);\\n}\\n\"\r\n    },\r\n    \"src/infinity/AppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"oz/token/ERC20/IERC20.sol\\\";\\nimport \\\"./libraries/LibRetire.sol\\\";\\n\\n/**\\n * @author Cujo\\n * @title App Storage defines the state object for Klima Infinity\\n */\\n\\ncontract Account {\\n    struct Retirement {\\n        address poolTokenAddress; // Pool token used\\n        address projectTokenAddress; // Fractionalized ERC-20 address for project/vintage\\n        address beneficiaryAddress; // Address of the beneficiary\\n        string beneficiary; // Retirement beneficiary\\n        string retirementMessage; // Specific message going along with this retirement\\n        uint amount; // Amount of carbon retired\\n        uint pledgeID; // The ID of the pledge this retirement is associated with.\\n    }\\n\\n    struct State {\\n        mapping(uint => Retirement) retirements;\\n        mapping(address => uint) totalPoolRetired;\\n        mapping(address => uint) totalProjectRetired;\\n        uint totalRetirements;\\n        uint totalCarbonRetired;\\n        uint totalRewardsClaimed;\\n    }\\n}\\n\\ncontract Storage {\\n    struct CarbonBridge {\\n        string name;\\n        address defaultRouter;\\n        uint8 routerType;\\n    }\\n\\n    struct DefaultSwap {\\n        uint8[] swapDexes;\\n        address[] ammRouters;\\n        mapping(uint8 => address[]) swapPaths;\\n    }\\n}\\n\\nstruct AppStorage {\\n    mapping(uint => Storage.CarbonBridge) bridges; // Details for current carbon bridges\\n    mapping(address => bool) isPoolToken;\\n    mapping(address => LibRetire.CarbonBridge) poolBridge; // Mapping of pool token address to the carbon bridge\\n    mapping(address => mapping(address => Storage.DefaultSwap)) swap; // Mapping of pool token to default swap behavior.\\n    mapping(address => Account.State) a; // Mapping of a user address to account state.\\n    uint lastERC721Received; // Last ERC721 Toucan Retirement Certificate received.\\n    uint fee; // Aggregator fee charged on all retirements to 3 decimals. 1000 = 1%\\n    uint reentrantStatus; // An intra-transaction state variable to protect against reentrance.\\n    // Internal Balances\\n    mapping(address => mapping(IERC20 => uint)) internalTokenBalance; // A mapping from Klimate address to Token address to Internal Balance. It stores the amount of the Token that the Klimate has stored as an Internal Balance in Klima Infinity.\\n    // Meta tx items\\n    mapping(address => uint) metaNonces;\\n    bytes32 domainSeparator;\\n    // Swap routing\\n    mapping(address => mapping(address => address)) tridentPool; // Trident pool to use for getting swap info\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/IToucan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface IToucanPool {\\n    function redeemAuto2(uint amount) external returns (address[] memory tco2s, uint[] memory amounts);\\n\\n    function redeemMany(address[] calldata erc20s, uint[] calldata amounts) external;\\n\\n    function feeRedeemPercentageInBase() external pure returns (uint);\\n\\n    function feeRedeemDivider() external pure returns (uint);\\n\\n    function redeemFeeExemptedAddresses(address) external view returns (bool);\\n\\n    function getScoredTCO2s() external view returns (address[] memory);\\n}\\n\\ninterface IToucanCarbonOffsets {\\n    function retire(uint amount) external;\\n\\n    function retireAndMintCertificate(\\n        string calldata retiringEntityString,\\n        address beneficiary,\\n        string calldata beneficiaryString,\\n        string calldata retirementMessage,\\n        uint amount\\n    ) external;\\n\\n    function mintCertificateLegacy(\\n        string calldata retiringEntityString,\\n        address beneficiary,\\n        string calldata beneficiaryString,\\n        string calldata retirementMessage,\\n        uint amount\\n    ) external;\\n}\\n\\ninterface IToucanContractRegistry {\\n    function isValidERC20(address erc20) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/Token/LibApprove.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT*/\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"oz/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @author publius\\n * @title LibApproval handles approval other ERC-20 tokens.\\n *\\n */\\n\\nlibrary LibApprove {\\n    using SafeERC20 for IERC20;\\n\\n    function approveToken(IERC20 token, address spender, uint amount) internal {\\n        if (token.allowance(address(this), spender) == type(uint).max) return;\\n        token.safeIncreaseAllowance(spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/ICarbonChain.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.4;\\n\\ninterface ICarbonChain {\\n    function offsetCarbon(uint _carbonTon, string calldata _transactionInfo, string calldata _onBehalfOf) external;\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/IC3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IC3Pool {\\n    function freeRedeem(uint amount) external;\\n\\n    function taxedRedeem(address[] memory erc20Addresses, uint[] memory amount) external;\\n\\n    function getFreeRedeemAddresses() external view returns (address[] memory);\\n\\n    function getERC20Tokens() external view returns (address[] memory);\\n\\n    function feeRedeem() external view returns (uint);\\n}\\n\\ninterface IC3ProjectToken {\\n    function offsetFor(uint256 amount, address beneficiary, string memory transferee, string memory reason) external;\\n}\\n\\ninterface IC3ProjectFactory {\\n    function isTokenExists(address _address) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/Token/LibBalance.sol\": {\r\n      \"content\": \"/*\\n SPDX-License-Identifier: MIT*/\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"oz/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"oz/utils/math/Math.sol\\\";\\nimport {SafeCast} from \\\"oz/utils/math/SafeCast.sol\\\";\\nimport \\\"../LibAppStorage.sol\\\";\\n\\n/**\\n * @author LeoFib, Publius\\n * @title LibInternalBalance Library handles internal read/write functions for Internal User Balances.\\n * Largely inspired by Balancer's Vault\\n *\\n */\\n\\nlibrary LibBalance {\\n    using SafeERC20 for IERC20;\\n    using SafeCast for uint;\\n\\n    /**\\n     * @dev Emitted when a account's Internal Balance changes, through interacting using Internal Balance.\\n     *\\n     */\\n    event InternalBalanceChanged(address indexed account, IERC20 indexed token, int delta);\\n\\n    function getBalance(address account, IERC20 token) internal view returns (uint combined_balance) {\\n        combined_balance = token.balanceOf(account) + getInternalBalance(account, token);\\n        return combined_balance;\\n    }\\n\\n    /**\\n     * @dev Increases `account`'s Internal Balance for `token` by `amount`.\\n     */\\n    function increaseInternalBalance(address account, IERC20 token, uint amount) internal {\\n        uint currentBalance = getInternalBalance(account, token);\\n        uint newBalance = currentBalance + amount;\\n        setInternalBalance(account, token, newBalance, amount.toInt256());\\n    }\\n\\n    /**\\n     * @dev Decreases `account`'s Internal Balance for `token` by `amount`. If `allowPartial` is true, this function\\n     * doesn't revert if `account` doesn't have enough balance, and sets it to zero and returns the deducted amount\\n     * instead.\\n     */\\n    function decreaseInternalBalance(address account, IERC20 token, uint amount, bool allowPartial)\\n        internal\\n        returns (uint deducted)\\n    {\\n        uint currentBalance = getInternalBalance(account, token);\\n        require(allowPartial || (currentBalance >= amount), \\\"Balance: Insufficient internal balance\\\");\\n\\n        deducted = Math.min(currentBalance, amount);\\n        // By construction, `deducted` is lower or equal to `currentBalance`, so we don't need to use checked\\n        // arithmetic.\\n        uint newBalance = currentBalance - deducted;\\n        setInternalBalance(account, token, newBalance, -(deducted.toInt256()));\\n    }\\n\\n    /**\\n     * @dev Sets `account`'s Internal Balance for `token` to `newBalance`.\\n     *\\n     * Emits an `InternalBalanceChanged` event. This event includes `delta`, which is the amount the balance increased\\n     * (if positive) or decreased (if negative). To avoid reading the current balance in order to compute the delta,\\n     * this function relies on the caller providing it directly.\\n     */\\n    function setInternalBalance(address account, IERC20 token, uint newBalance, int delta) private {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        s.internalTokenBalance[account][token] = newBalance;\\n        emit InternalBalanceChanged(account, token, delta);\\n    }\\n\\n    /**\\n     * @dev Returns `account`'s Internal Balance for `token`.\\n     */\\n    function getInternalBalance(address account, IERC20 token) internal view returns (uint) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return s.internalTokenBalance[account][token];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/LibKlima.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @author Cujo\\n * @title LibKlima\\n */\\n\\nimport \\\"../C.sol\\\";\\nimport \\\"./LibAppStorage.sol\\\";\\nimport \\\"../interfaces/IKlima.sol\\\";\\nimport \\\"./Token/LibApprove.sol\\\";\\n\\nlibrary LibKlima {\\n    /**\\n     * @notice                  Returns wsKLIMA amount for provided sKLIMA amount\\n     * @param amount            sKLIMA provided\\n     * @return wrappedAmount    wsKLIMA amount\\n     */\\n    function toWrappedAmount(uint amount) internal view returns (uint wrappedAmount) {\\n        // @dev Account for rounding differences in wsKLIMA contract.\\n        return IwsKLIMA(C.wsKlima()).sKLIMATowKLIMA(amount) + 5;\\n    }\\n\\n    /**\\n     * @notice                  Returns sKLIMA amount for provided wsKLIMA amount\\n     * @param amount            wsKLIMA provided\\n     * @return unwrappedAmount    sKLIMA amount\\n     */\\n    function toUnwrappedAmount(uint amount) internal view returns (uint unwrappedAmount) {\\n        // @dev Account for rounding differences in wsKLIMA contract.\\n        return IwsKLIMA(C.wsKlima()).wKLIMATosKLIMA(amount);\\n    }\\n\\n    /**\\n     * @notice                  Unwraps and unstakes provided wsKLIMA amount\\n     * @param amount            wsKLIMA provided\\n     * @return unwrappedAmount    Final KLIMA amount\\n     */\\n    function unwrapKlima(uint amount) internal returns (uint unwrappedAmount) {\\n        unwrappedAmount = IwsKLIMA(C.wsKlima()).unwrap(amount);\\n        unstakeKlima(unwrappedAmount);\\n    }\\n\\n    /**\\n     * @notice                  Unstakes provided sKLIMA amount\\n     * @param amount            sKLIMA provided\\n     */\\n    function unstakeKlima(uint amount) internal {\\n        IStaking(C.staking()).unstake(amount, false);\\n    }\\n\\n    /**\\n     * @notice                  Stakes and wraps provided KLIMA amount\\n     * @param amount            KLIMA provided\\n     * @return wrappedAmount    Final wsKLIMA amount\\n     */\\n    function wrapKlima(uint amount) internal returns (uint wrappedAmount) {\\n        stakeKlima(amount);\\n        wrappedAmount = IwsKLIMA(C.wsKlima()).wrap(amount);\\n    }\\n\\n    /**\\n     * @notice                  Stakes provided KLIMA amount\\n     * @param amount            KLIMA provided\\n     */\\n    function stakeKlima(uint amount) internal {\\n        IStakingHelper(C.stakingHelper()).stake(amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/TokenSwap/LibUniswapV2Swap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @author Cujo\\n * @title LibUniswapV2Swap\\n */\\n\\nimport \\\"../../interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"../Token/LibApprove.sol\\\";\\n\\nlibrary LibUniswapV2Swap {\\n    function swapTokensForExactTokens(\\n        address router,\\n        address[] memory path,\\n        uint amountIn,\\n        uint amountOut\\n    ) internal returns (uint) {\\n        LibApprove.approveToken(IERC20(path[0]), router, amountIn);\\n\\n        uint[] memory amountsOut = IUniswapV2Router02(router).swapTokensForExactTokens(\\n            amountOut,\\n            amountIn,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        return amountsOut[path.length - 1];\\n    }\\n\\n    function swapExactTokensForTokens(address router, address[] memory path, uint amount) internal returns (uint) {\\n        uint[] memory amountsOut = IUniswapV2Router02(router).getAmountsOut(amount, path);\\n\\n        LibApprove.approveToken(IERC20(path[0]), router, amount);\\n\\n        amountsOut = IUniswapV2Router02(router).swapExactTokensForTokens(\\n            amount,\\n            amountsOut[path.length - 1],\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        return amountsOut[path.length - 1];\\n    }\\n\\n    function getAmountIn(address router, address[] memory path, uint amount) internal view returns (uint) {\\n        uint[] memory amountsIn = IUniswapV2Router02(router).getAmountsIn(amount, path);\\n        return amountsIn[0];\\n    }\\n\\n    function getAmountOut(address router, address[] memory path, uint amount) internal view returns (uint) {\\n        uint[] memory amountsOut = IUniswapV2Router02(router).getAmountsOut(amount, path);\\n        return amountsOut[amountsOut.length - 1];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/TokenSwap/LibTridentSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @author Cujo\\n * @title LibTridentSwap\\n */\\n\\nimport \\\"../../interfaces/ITrident.sol\\\";\\nimport \\\"../Token/LibApprove.sol\\\";\\nimport \\\"../LibAppStorage.sol\\\";\\nimport \\\"../../C.sol\\\";\\n\\nlibrary LibTridentSwap {\\n    function swapExactTokensForTokens(\\n        address router,\\n        address pool,\\n        address tokenIn,\\n        uint amountIn,\\n        uint minAmountOut\\n    ) internal returns (uint amountOut) {\\n        ITridentRouter.ExactInputSingleParams memory swapParams;\\n        swapParams.amountIn = amountIn;\\n        swapParams.amountOutMinimum = minAmountOut;\\n        swapParams.pool = pool;\\n        swapParams.tokenIn = tokenIn;\\n        swapParams.data = abi.encode(tokenIn, address(this), true);\\n        amountOut = ITridentRouter(router).exactInputSingleWithNativeToken(swapParams);\\n    }\\n\\n    function getAmountIn(\\n        address pool,\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountOut\\n    ) internal view returns (uint amountIn) {\\n        uint shareAmount = ITridentPool(pool).getAmountIn(abi.encode(tokenOut, amountOut));\\n        amountIn = IBentoBoxMinimal(C.sushiBento()).toAmount(IERC20(tokenIn), shareAmount, true);\\n    }\\n\\n    function getAmountOut(\\n        address pool,\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn\\n    ) internal view returns (uint amountOut) {\\n        uint shareAmount = ITridentPool(pool).getAmountOut(abi.encode(tokenIn, amountIn));\\n        amountOut = IBentoBoxMinimal(C.sushiBento()).toAmount(IERC20(tokenOut), shareAmount, true);\\n    }\\n\\n    function getTridentPool(address tokenOne, address tokenTwo) internal view returns (address tridentPool) {\\n        AppStorage storage s = LibAppStorage.diamondStorage();\\n        return\\n            s.tridentPool[tokenOne][tokenTwo] == address(0)\\n                ? s.tridentPool[tokenTwo][tokenOne]\\n                : s.tridentPool[tokenOne][tokenTwo];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/libraries/TokenSwap/LibTreasurySwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/**\\n * @author Cujo\\n * @title LibTreasurySwap\\n */\\n\\nimport {IKlimaRetirementBond} from \\\"../../interfaces/IKlima.sol\\\";\\nimport \\\"../Token/LibApprove.sol\\\";\\nimport \\\"../../C.sol\\\";\\n\\nlibrary LibTreasurySwap {\\n    function getAmountIn(address tokenIn, uint amountOut) internal view returns (uint amountIn) {\\n        return IKlimaRetirementBond(C.klimaRetirementBond()).getKlimaAmount(amountOut, tokenIn);\\n    }\\n\\n    function swapToExact(address carbonToken, uint amountIn, uint amountOut) internal {\\n        LibApprove.approveToken(IERC20(C.klima()), C.klimaRetirementBond(), amountIn);\\n\\n        IKlimaRetirementBond(C.klimaRetirementBond()).swapToExact(carbonToken, amountOut);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/IKlima.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\ninterface IStaking {\\n    function unstake(uint _amount, bool _trigger) external;\\n}\\n\\ninterface IStakingHelper {\\n    function stake(uint _amount) external;\\n}\\n\\ninterface IwsKLIMA {\\n    function wrap(uint _amount) external returns (uint);\\n\\n    function unwrap(uint _amount) external returns (uint);\\n\\n    function wKLIMATosKLIMA(uint _amount) external view returns (uint);\\n\\n    function sKLIMATowKLIMA(uint _amount) external view returns (uint);\\n}\\n\\ninterface IKlimaRetirementBond {\\n    function swapToExact(address poolToken, uint256 amount) external;\\n\\n    function getKlimaAmount(uint256 poolAmount, address poolToken) external view returns (uint256 klimaNeeded);\\n\\n    function owner() external returns (address);\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/ITrident.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"oz/token/ERC20/IERC20.sol\\\";\\n\\ninterface IBentoBoxMinimal {\\n    /// @dev Approves users' BentoBox assets to a \\\"master\\\" contract.\\n    function setMasterContractApproval(\\n        address user,\\n        address masterContract,\\n        bool approved,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function toAmount(IERC20 token, uint share, bool roundUp) external view returns (uint amount);\\n}\\n\\n/// @notice Trident pool router interface.\\ninterface ITridentRouter {\\n    struct ExactInputSingleParams {\\n        uint amountIn;\\n        uint amountOutMinimum;\\n        address pool;\\n        address tokenIn;\\n        bytes data;\\n    }\\n\\n    function exactInputSingleWithNativeToken(ExactInputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint amountOut);\\n}\\n\\n/// @notice Trident pool interface.\\ninterface ITridentPool {\\n    /// @notice Simulates a trade and returns the expected output.\\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\\n    /// @param data ABI-encoded params that the pool requires.\\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\\n    function getAmountOut(bytes calldata data) external view returns (uint finalAmountOut);\\n\\n    /// @notice Simulates a trade and returns the expected output.\\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\\n    /// @param data ABI-encoded params that the pool requires.\\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\\n    function getAmountIn(bytes calldata data) external view returns (uint finalAmountIn);\\n}\\n\"\r\n    },\r\n    \"src/infinity/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"oz/=lib/openzeppelin-contracts/contracts/\",\r\n      \"oz-4-5-0/=lib/openzeppelin-contracts-4-5-0/contracts/\",\r\n      \"ozu/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"ozu-4-5-1/=lib/openzeppelin-contracts-upgradeable-4-5-1/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-4-5-0/=lib/openzeppelin-contracts-4-5-0/\",\r\n      \"openzeppelin-contracts-upgradeable-4-5-1/=lib/openzeppelin-contracts-upgradeable-4-5-1/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solidity-stringutils/=lib/solidity-stringutils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum LibRetire.CarbonBridge\",\"name\":\"carbonBridge\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"retiringAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"retiringEntityString\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiaryAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"beneficiaryString\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"retirementMessage\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"carbonPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"retiredAmount\",\"type\":\"uint256\"}],\"name\":\"CarbonRetired\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"remainingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct ICarbonmark.CreditListing\",\"name\":\"listing\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"retireAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"retiringEntityString\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"beneficiaryAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"beneficiaryString\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"retirementMessage\",\"type\":\"string\"},{\"internalType\":\"enum LibTransfer.From\",\"name\":\"fromMode\",\"type\":\"uint8\"}],\"name\":\"retireCarbonmarkListing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"retirementIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "RetireCarbonmarkFacet", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}