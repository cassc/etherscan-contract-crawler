{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"MX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\n\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n\\r\\n\\r\\ncontract MxMillionPowerLottery {\\r\\n\\r\\n    uint256 public ticketPrice = 100 * 10**18; // 100 tokens (wei value)\\r\\n\\r\\n    uint256 public maxTickets = 100; // maximum tickets per lottery\\r\\n\\r\\n    uint256 public ticketCommission = 50 * 10**18; // 50 tokens (wei value) commission per ticket\\r\\n\\r\\n    uint256 public duration = 1440 minutes; // The duration set for the lottery\\r\\n\\r\\n    uint256 public expiration; // Timeout in case the lottery was not carried out.\\r\\n\\r\\n    address public lotteryOperator; // the creator of the lottery\\r\\n\\r\\n    uint256 public operatorTotalCommission = 0; // the total commission balance\\r\\n\\r\\n    address public lastWinner; // the last winner of the lottery\\r\\n\\r\\n    uint256 public lastWinnerAmount; // the last winner amount of the lottery\\r\\n\\r\\n\\r\\n\\r\\n    mapping(address => uint256) public winnings; // maps the winners to their winnings\\r\\n\\r\\n    address[] public tickets; // array of purchased Tickets\\r\\n\\r\\n\\r\\n\\r\\n    IERC20 public token; // the ERC20 token used for buying tickets\\r\\n\\r\\n\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n\\r\\n        require(msg.sender == lotteryOperator, \\\"Caller is not the owner\\\");\\r\\n\\r\\n        _;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    constructor(address _tokenAddress) {\\r\\n\\r\\n        lotteryOperator = msg.sender;\\r\\n\\r\\n        expiration = block.timestamp + duration;\\r\\n\\r\\n        token = IERC20(_tokenAddress);\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function getTickets() public view returns (address[] memory) {\\r\\n\\r\\n        return tickets;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function getWinningsForAddress(address addr) public view returns (uint256) {\\r\\n\\r\\n        return winnings[addr];\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function BuyTickets(uint256 numOfTicketsToBuy) public {\\r\\n\\r\\n        require(numOfTicketsToBuy > 0, \\\"Number of tickets to buy must be greater than zero\\\");\\r\\n\\r\\n\\r\\n\\r\\n        uint256 totalPrice = ticketPrice * numOfTicketsToBuy;\\r\\n\\r\\n\\r\\n\\r\\n        require(token.allowance(msg.sender, address(this)) >= totalPrice, \\\"Insufficient token allowance\\\");\\r\\n\\r\\n        require(numOfTicketsToBuy <= RemainingTickets(), \\\"Not enough tickets available.\\\");\\r\\n\\r\\n\\r\\n\\r\\n        for (uint256 i = 0; i < numOfTicketsToBuy; i++) {\\r\\n\\r\\n            tickets.push(msg.sender);\\r\\n\\r\\n        }\\r\\n\\r\\n\\r\\n\\r\\n        token.transferFrom(msg.sender, address(this), totalPrice);\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function DrawWinnerTicket() public onlyOwner {\\r\\n\\r\\n        require(tickets.length > 0, \\\"No tickets were purchased\\\");\\r\\n\\r\\n\\r\\n\\r\\n        bytes32 blockHash = blockhash(block.number - tickets.length);\\r\\n\\r\\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(block.timestamp, blockHash)));\\r\\n\\r\\n        uint256 winningTicket = randomNumber % tickets.length;\\r\\n\\r\\n\\r\\n\\r\\n        address winner = tickets[winningTicket];\\r\\n\\r\\n        lastWinner = winner;\\r\\n\\r\\n        winnings[winner] += (tickets.length * (ticketPrice - ticketCommission));\\r\\n\\r\\n        lastWinnerAmount = winnings[winner];\\r\\n\\r\\n        operatorTotalCommission += (tickets.length * ticketCommission);\\r\\n\\r\\n        delete tickets;\\r\\n\\r\\n        expiration = block.timestamp + duration;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function restartDraw() public onlyOwner {\\r\\n\\r\\n        require(tickets.length == 0, \\\"Cannot restart draw as draw is in play\\\");\\r\\n\\r\\n\\r\\n\\r\\n        delete tickets;\\r\\n\\r\\n        expiration = block.timestamp + duration;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function checkWinningsAmount() public view returns (uint256) {\\r\\n\\r\\n        address payable winner = payable(msg.sender);\\r\\n\\r\\n\\r\\n\\r\\n        uint256 reward2Transfer = winnings[winner];\\r\\n\\r\\n\\r\\n\\r\\n        return reward2Transfer;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function WithdrawWinnings(address tokenAddress) public {\\r\\n\\r\\n        address payable winner = payable(msg.sender);\\r\\n\\r\\n\\r\\n\\r\\n        uint256 reward2Transfer = winnings[winner];\\r\\n\\r\\n        require(reward2Transfer > 0, \\\"No winnings to withdraw\\\");\\r\\n\\r\\n\\r\\n\\r\\n        winnings[winner] = 0;\\r\\n\\r\\n\\r\\n\\r\\n        if (tokenAddress == address(0)) {\\r\\n\\r\\n            // Withdraw Ether\\r\\n\\r\\n            (bool success, ) = winner.call{ value: reward2Transfer }(\\\"\\\");\\r\\n\\r\\n            require(success, \\\"Failed to withdraw winnings in Ether\\\");\\r\\n\\r\\n        } else {\\r\\n\\r\\n            // Withdraw Tokens\\r\\n\\r\\n            IERC20 tokenToWithdraw = IERC20(tokenAddress);\\r\\n\\r\\n            require(tokenToWithdraw.transfer(winner, reward2Transfer), \\\"Token transfer failed\\\");\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function RefundAll() public {\\r\\n\\r\\n        require(block.timestamp >= expiration, \\\"The lottery has not expired yet\\\");\\r\\n\\r\\n\\r\\n\\r\\n        for (uint256 i = 0; i < tickets.length; i++) {\\r\\n\\r\\n            address payable to = payable(tickets[i]);\\r\\n\\r\\n            tickets[i] = address(0);\\r\\n\\r\\n            (bool success, ) = to.call{ value: ticketPrice }(\\\"\\\");\\r\\n\\r\\n            require(success, \\\"Failed to refund ticket\\\");\\r\\n\\r\\n        }\\r\\n\\r\\n        delete tickets;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function WithdrawCommission(address tokenAddress) public onlyOwner {\\r\\n\\r\\n        address payable operator = payable(msg.sender);\\r\\n\\r\\n\\r\\n\\r\\n        uint256 commission2Transfer = operatorTotalCommission;\\r\\n\\r\\n        operatorTotalCommission = 0;\\r\\n\\r\\n\\r\\n\\r\\n        if (tokenAddress == address(0)) {\\r\\n\\r\\n            // Withdraw Ether\\r\\n\\r\\n            (bool success, ) = operator.call{ value: commission2Transfer }(\\\"\\\");\\r\\n\\r\\n            require(success, \\\"Failed to withdraw commission in Ether\\\");\\r\\n\\r\\n        } else {\\r\\n\\r\\n            // Withdraw Tokens\\r\\n\\r\\n            IERC20 commissionToken = IERC20(tokenAddress);\\r\\n\\r\\n            require(commissionToken.transfer(operator, commission2Transfer), \\\"Token transfer failed\\\");\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function IsWinner() public view returns (bool) {\\r\\n\\r\\n        return winnings[msg.sender] > 0;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function CurrentWinningReward() public view returns (uint256) {\\r\\n\\r\\n        return tickets.length * ticketPrice;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function RemainingTickets() public view returns (uint256) {\\r\\n\\r\\n        return maxTickets - tickets.length;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function setDuration(uint256 newDuration) public onlyOwner {\\r\\n\\r\\n        require(newDuration > 0, \\\"Duration must be greater than zero\\\");\\r\\n\\r\\n        expiration = block.timestamp + newDuration;\\r\\n\\r\\n        duration = newDuration;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function setLotteryOperator(address newOperator) public onlyOwner {\\r\\n\\r\\n        require(newOperator != address(0), \\\"New operator address cannot be zero address\\\");\\r\\n\\r\\n        lotteryOperator = newOperator;\\r\\n\\r\\n    }\\r\\n\\r\\n\\tfunction setTicketPrice(uint256 newPrice) public onlyOwner {\\r\\n\\r\\n\\t\\trequire(newPrice > 0, \\\"Ticket price must be greater than zero\\\");\\r\\n\\r\\n\\t\\tticketPrice = newPrice;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\r\\n\\tfunction setTicketCommission(uint256 newCommission) public onlyOwner {\\r\\n\\r\\n\\t\\trequire(newCommission >= 0, \\\"Commission cannot be negative\\\");\\r\\n\\r\\n\\t\\tticketCommission = newCommission;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\tfunction setMaxTickets(uint256 newMaxTickets) public onlyOwner {\\r\\n\\r\\n\\t\\trequire(newMaxTickets > 0, \\\"Max tickets must be greater than zero\\\");\\r\\n\\r\\n\\t\\tmaxTickets = newMaxTickets;\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numOfTicketsToBuy\",\"type\":\"uint256\"}],\"name\":\"BuyTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentWinningReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DrawWinnerTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IsWinner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RefundAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RemainingTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"WithdrawCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"WithdrawWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkWinningsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTickets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getWinningsForAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWinnerAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorTotalCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restartDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"setDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setLotteryOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxTickets\",\"type\":\"uint256\"}],\"name\":\"setMaxTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCommission\",\"type\":\"uint256\"}],\"name\":\"setTicketCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setTicketPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tickets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"winnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MxMillionPowerLottery", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000a834ed56a63d1801c365f0ceacc4060283ebb5f5", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}