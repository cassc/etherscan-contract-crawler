{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Hats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// Copyright (C) 2023 Haberdasher Labs\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.13;\\n\\nimport { ERC1155 } from \\\"lib/ERC1155/ERC1155.sol\\\";\\n// import { console2 } from \\\"forge-std/Test.sol\\\"; //remove after testing\\nimport \\\"./Interfaces/IHats.sol\\\";\\nimport \\\"./HatsIdUtilities.sol\\\";\\nimport \\\"./Interfaces/IHatsToggle.sol\\\";\\nimport \\\"./Interfaces/IHatsEligibility.sol\\\";\\nimport \\\"solbase/utils/Base64.sol\\\";\\nimport \\\"solbase/utils/LibString.sol\\\";\\nimport \\\"solady/utils/Multicallable.sol\\\";\\n\\n/// @title Hats Protocol v1\\n/// @notice Hats are DAO-native, revocable, and programmable roles that are represented as non-transferable ERC-1155-similar tokens for composability\\n/// @dev This is a multi-tenant contract that can manage all hats for a given chain. While it fully implements the ERC1155 interface, it does not fully comply with the ERC1155 standard.\\n/// @author Haberdasher Labs\\ncontract Hats is IHats, ERC1155, Multicallable, HatsIdUtilities {\\n    /// @notice This contract's version is labeled v1. Previous versions labeled similarly as v1 and v1.0 are deprecated,\\n    ///         and should be treated as beta deployments.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              HATS DATA MODELS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice A Hat object containing the hat's properties\\n    /// @dev The members are packed to minimize storage costs\\n    /// @custom:member eligibility Module that rules on wearer eligibiliy and standing\\n    /// @custom:member maxSupply The max number of hats with this id that can exist\\n    /// @custom:member supply The number of this hat that currently exist\\n    /// @custom:member lastHatId Indexes how many different child hats an admin has\\n    /// @custom:member toggle Module that sets the hat's status\\n    /**\\n     * @custom:member config Holds status and other settings, with this bitwise schema:\\n     *\\n     *  0th bit  | `active` status; can be altered by toggle\\n     *  1        | `mutable` setting\\n     *  2 - 95   | unassigned\\n     */\\n    /// @custom:member details Holds arbitrary metadata about the hat\\n    /// @custom:member imageURI A uri pointing to an image for the hat\\n    struct Hat {\\n        // 1st storage slot\\n        address eligibility; // \u2500\u2510 20\\n        uint32 maxSupply; //     \u2502 4\\n        uint32 supply; //        \u2502 4\\n        uint16 lastHatId; //    \u2500\u2518 2\\n        // 2nd slot\\n        address toggle; //      \u2500\u2510 20\\n        uint96 config; //       \u2500\u2518 12\\n        // 3rd+ slot (optional)\\n        string details;\\n        string imageURI;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              HATS STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The name of the contract, typically including the version\\n    string public name;\\n\\n    /// @notice The first 4 bytes of the id of the last tophat created.\\n    uint32 public lastTopHatId; // first tophat id starts at 1\\n\\n    /// @notice The fallback image URI for hat tokens with no `imageURI` specified in their branch\\n    string public baseImageURI;\\n\\n    /// @dev Internal mapping of hats to hat ids. See HatsIdUtilities.sol for more info on how hat ids work\\n    mapping(uint256 => Hat) internal _hats; // key: hatId => value: Hat struct\\n\\n    /// @notice Mapping of wearers in bad standing for certain hats\\n    /// @dev Used by external contracts to trigger penalties for wearers in bad standing\\n    ///      hatId => wearer => !standing\\n    mapping(uint256 => mapping(address => bool)) public badStandings;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice All arguments are immutable; they can only be set once during construction\\n    /// @param _name The name of this contract, typically including the version\\n    /// @param _baseImageURI The fallback image URI\\n    constructor(string memory _name, string memory _baseImageURI) {\\n        name = _name;\\n        baseImageURI = _baseImageURI;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              HATS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Creates and mints a Hat that is its own admin, i.e. a \\\"topHat\\\"\\n    /// @dev A topHat has no eligibility and no toggle\\n    /// @param _target The address to which the newly created topHat is minted\\n    /// @param _details A description of the Hat [optional]. Should not be larger than 7000 bytes\\n    ///                 (enforced in changeHatDetails)\\n    /// @param _imageURI The image uri for this top hat and the fallback for its\\n    ///                  downstream hats [optional]. Should not be large than 7000 bytes\\n    ///                  (enforced in changeHatImageURI)\\n    /// @return topHatId The id of the newly created topHat\\n    function mintTopHat(address _target, string calldata _details, string calldata _imageURI)\\n        public\\n        returns (uint256 topHatId)\\n    {\\n        // create hat\\n\\n        topHatId = uint256(++lastTopHatId) << 224;\\n\\n        _createHat(\\n            topHatId,\\n            _details, // details\\n            1, // maxSupply = 1\\n            address(0), // there is no eligibility\\n            address(0), // it has no toggle\\n            false, // its immutable\\n            _imageURI\\n        );\\n\\n        _mintHat(_target, topHatId);\\n    }\\n\\n    /// @notice Creates a new hat. The msg.sender must wear the `_admin` hat.\\n    /// @dev Initializes a new Hat struct, but does not mint any tokens.\\n    /// @param _details A description of the Hat. Should not be larger than 7000 bytes (enforced in changeHatDetails)\\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\\n    /// @param _admin The id of the Hat that will control who wears the newly created hat\\n    /// @param _eligibility The address that can report on the Hat wearer's status\\n    /// @param _toggle The address that can deactivate the Hat\\n    /// @param _mutable Whether the hat's properties are changeable after creation\\n    /// @param _imageURI The image uri for this hat and the fallback for its\\n    ///                  downstream hats [optional]. Should not be larger than 7000 bytes (enforced in changeHatImageURI)\\n    /// @return newHatId The id of the newly created Hat\\n    function createHat(\\n        uint256 _admin,\\n        string calldata _details,\\n        uint32 _maxSupply,\\n        address _eligibility,\\n        address _toggle,\\n        bool _mutable,\\n        string calldata _imageURI\\n    ) public returns (uint256 newHatId) {\\n        if (uint16(_admin) > 0) {\\n            revert MaxLevelsReached();\\n        }\\n\\n        if (_eligibility == address(0)) revert ZeroAddress();\\n        if (_toggle == address(0)) revert ZeroAddress();\\n        // check that the admin id is valid, ie does not contain empty levels between filled levels\\n        if (!isValidHatId(_admin)) revert InvalidHatId();\\n        // construct the next hat id\\n        newHatId = getNextId(_admin);\\n        // to create a hat, you must be wearing one of its admin hats\\n        _checkAdmin(newHatId);\\n        // create the new hat\\n        _createHat(newHatId, _details, _maxSupply, _eligibility, _toggle, _mutable, _imageURI);\\n        // increment _admin.lastHatId\\n        // use the overflow check to constrain to correct number of hats per level\\n        ++_hats[_admin].lastHatId;\\n    }\\n\\n    /// @notice Creates new hats in batch. The msg.sender must be an admin of each hat.\\n    /// @dev This is a convenience function that loops through the arrays and calls `createHat`.\\n    /// @param _admins Array of ids of admins for each hat to create\\n    /// @param _details Array of details for each hat to create\\n    /// @param _maxSupplies Array of supply caps for each hat to create\\n    /// @param _eligibilityModules Array of eligibility module addresses for each hat to\\n    /// create\\n    /// @param _toggleModules Array of toggle module addresses for each hat to create\\n    /// @param _mutables Array of mutable flags for each hat to create\\n    /// @param _imageURIs Array of imageURIs for each hat to create\\n    /// @return success True if all createHat calls succeeded\\n    function batchCreateHats(\\n        uint256[] calldata _admins,\\n        string[] calldata _details,\\n        uint32[] calldata _maxSupplies,\\n        address[] memory _eligibilityModules,\\n        address[] memory _toggleModules,\\n        bool[] calldata _mutables,\\n        string[] calldata _imageURIs\\n    ) public returns (bool success) {\\n        // check if array lengths are the same\\n        uint256 length = _admins.length; // save an MLOAD\\n\\n        {\\n            bool sameLengths = (\\n                length == _details.length // details\\n                    && length == _maxSupplies.length // supplies\\n                    && length == _eligibilityModules.length // eligibility\\n                    && length == _toggleModules.length // toggle\\n                    && length == _mutables.length // mutable\\n                    && length == _imageURIs.length\\n            ); // imageURI\\n            if (!sameLengths) revert BatchArrayLengthMismatch();\\n        }\\n\\n        // loop through and create each hat\\n        for (uint256 i = 0; i < length;) {\\n            createHat(\\n                _admins[i],\\n                _details[i],\\n                _maxSupplies[i],\\n                _eligibilityModules[i],\\n                _toggleModules[i],\\n                _mutables[i],\\n                _imageURIs[i]\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        success = true;\\n    }\\n\\n    /// @notice Gets the id of the next child hat of the hat `_admin`\\n    /// @dev Does not incrememnt lastHatId\\n    /// @param _admin The id of the hat to serve as the admin for the next child hat\\n    /// @return nextId The new hat id\\n    function getNextId(uint256 _admin) public view returns (uint256 nextId) {\\n        uint16 nextHatId = _hats[_admin].lastHatId + 1;\\n        nextId = buildHatId(_admin, nextHatId);\\n    }\\n\\n    /// @notice Mints an ERC1155-similar token of the Hat to an eligible recipient, who then \\\"wears\\\" the hat\\n    /// @dev The msg.sender must wear an admin Hat of `_hatId`, and the recipient must be eligible to wear `_hatId`\\n    /// @param _hatId The id of the Hat to mint\\n    /// @param _wearer The address to which the Hat is minted\\n    /// @return success Whether the mint succeeded\\n    function mintHat(uint256 _hatId, address _wearer) public returns (bool success) {\\n        Hat storage hat = _hats[_hatId];\\n        if (hat.maxSupply == 0) revert HatDoesNotExist(_hatId);\\n        // only eligible wearers can receive minted hats\\n        if (!isEligible(_wearer, _hatId)) revert NotEligible();\\n        // only active hats can be minted\\n        if (!_isActive(hat, _hatId)) revert HatNotActive();\\n        // only the wearer of one of a hat's admins can mint it\\n        _checkAdmin(_hatId);\\n        // hat supply cannot exceed maxSupply\\n        if (hat.supply >= hat.maxSupply) revert AllHatsWorn(_hatId);\\n        // wearers cannot wear the same hat more than once\\n        if (_staticBalanceOf(_wearer, _hatId) > 0) revert AlreadyWearingHat(_wearer, _hatId);\\n        // if we've made it through all the checks, mint the hat\\n        _mintHat(_wearer, _hatId);\\n\\n        success = true;\\n    }\\n\\n    /// @notice Mints new hats in batch. The msg.sender must be an admin of each hat.\\n    /// @dev This is a convenience function that loops through the arrays and calls `mintHat`.\\n    /// @param _hatIds Array of ids of hats to mint\\n    /// @param _wearers Array of addresses to which the hats will be minted\\n    /// @return success True if all mintHat calls succeeded\\n    function batchMintHats(uint256[] calldata _hatIds, address[] calldata _wearers) public returns (bool success) {\\n        uint256 length = _hatIds.length;\\n        if (length != _wearers.length) revert BatchArrayLengthMismatch();\\n\\n        for (uint256 i = 0; i < length;) {\\n            mintHat(_hatIds[i], _wearers[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        success = true;\\n    }\\n\\n    /// @notice Toggles a Hat's status from active to deactive, or vice versa\\n    /// @dev The msg.sender must be set as the hat's toggle\\n    /// @param _hatId The id of the Hat for which to adjust status\\n    /// @param _newStatus The new status to set\\n    /// @return toggled Whether the status was toggled\\n    function setHatStatus(uint256 _hatId, bool _newStatus) external returns (bool toggled) {\\n        Hat storage hat = _hats[_hatId];\\n\\n        if (msg.sender != hat.toggle) {\\n            revert NotHatsToggle();\\n        }\\n\\n        toggled = _processHatStatus(_hatId, _newStatus);\\n    }\\n\\n    /// @notice Checks a hat's toggle module and processes the returned status\\n    /// @dev May change the hat's status in storage\\n    /// @param _hatId The id of the Hat whose toggle we are checking\\n    /// @return toggled Whether there was a new status\\n    function checkHatStatus(uint256 _hatId) public returns (bool toggled) {\\n        Hat storage hat = _hats[_hatId];\\n\\n        // attempt to retrieve the hat's status from the toggle module\\n        (bool success, bool newStatus) = _pullHatStatus(hat, _hatId);\\n\\n        // if unsuccessful (ie toggle was humanistic), process the new status\\n        if (!success) revert NotHatsToggle();\\n\\n        // if successful (ie toggle was mechanistic), process the new status\\n        toggled = _processHatStatus(_hatId, newStatus);\\n    }\\n\\n    function _pullHatStatus(Hat storage _hat, uint256 _hatId) internal view returns (bool success, bool newStatus) {\\n        bytes memory data = abi.encodeWithSignature(\\\"getHatStatus(uint256)\\\", _hatId);\\n        bytes memory returndata;\\n        (success, returndata) = _hat.toggle.staticcall(data);\\n\\n        /* \\n        * if function call succeeds with data of length == 32, then we know the contract exists \\n        * and has the getHatStatus function.\\n        * But \u2014 since function selectors don't include return types \u2014 we still can't assume that the return data is a boolean, \\n        * so we treat it as a uint so it will always safely decode without throwing.\\n        */\\n        if (success && returndata.length == 32) {\\n            // check the returndata manually\\n            uint256 uintReturndata = abi.decode(returndata, (uint256));\\n            // false condition\\n            if (uintReturndata == 0) {\\n                newStatus = false;\\n                // true condition\\n            } else if (uintReturndata == 1) {\\n                newStatus = true;\\n            }\\n            // invalid condition\\n            else {\\n                success = false;\\n            }\\n        } else {\\n            success = false;\\n        }\\n    }\\n\\n    /// @notice Report from a hat's eligibility on the status of one of its wearers and, if `false`, revoke their hat\\n    /// @dev Burns the wearer's hat, if revoked\\n    /// @param _hatId The id of the hat\\n    /// @param _wearer The address of the hat wearer whose status is being reported\\n    /// @param _eligible Whether the wearer is eligible for the hat (will be revoked if\\n    /// false)\\n    /// @param _standing False if the wearer is no longer in good standing (and potentially should be penalized)\\n    /// @return updated Whether the report succeeded\\n    function setHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)\\n        external\\n        returns (bool updated)\\n    {\\n        Hat storage hat = _hats[_hatId];\\n\\n        if (msg.sender != hat.eligibility) {\\n            revert NotHatsEligibility();\\n        }\\n\\n        updated = _processHatWearerStatus(_hatId, _wearer, _eligible, _standing);\\n    }\\n\\n    /// @notice Check a hat's eligibility for a report on the status of one of the hat's wearers and, if `false`, revoke their hat\\n    /// @dev Burns the wearer's hat, if revoked\\n    /// @param _hatId The id of the hat\\n    /// @param _wearer The address of the Hat wearer whose status report is being requested\\n    /// @return updated Whether the wearer's status was altered\\n    function checkHatWearerStatus(uint256 _hatId, address _wearer) public returns (bool updated) {\\n        bool eligible;\\n        bool standing;\\n\\n        (bool success, bytes memory returndata) = _hats[_hatId].eligibility.staticcall(\\n            abi.encodeWithSignature(\\\"getWearerStatus(address,uint256)\\\", _wearer, _hatId)\\n        );\\n\\n        /* \\n        * if function call succeeds with data of length == 64, then we know the contract exists \\n        * and has the getWearerStatus function (which returns two words).\\n        * But \u2014 since function selectors don't include return types \u2014 we still can't assume that the return data is two booleans, \\n        * so we treat it as a uint so it will always safely decode without throwing.\\n        */\\n        if (success && returndata.length == 64) {\\n            // check the returndata manually\\n            (uint256 firstWord, uint256 secondWord) = abi.decode(returndata, (uint256, uint256));\\n            // returndata is valid\\n            if (firstWord < 2 && secondWord < 2) {\\n                standing = (secondWord == 1) ? true : false;\\n                // never eligible if in bad standing\\n                eligible = (standing && firstWord == 1) ? true : false;\\n            }\\n            // returndata is invalid\\n            else {\\n                revert NotHatsEligibility();\\n            }\\n        } else {\\n            revert NotHatsEligibility();\\n        }\\n\\n        updated = _processHatWearerStatus(_hatId, _wearer, eligible, standing);\\n    }\\n\\n    /// @notice Stop wearing a hat, aka \\\"renounce\\\" it\\n    /// @dev Burns the msg.sender's hat\\n    /// @param _hatId The id of the Hat being renounced\\n    function renounceHat(uint256 _hatId) external {\\n        if (_staticBalanceOf(msg.sender, _hatId) < 1) {\\n            revert NotHatWearer();\\n        }\\n        // remove the hat\\n        _burnHat(msg.sender, _hatId);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              HATS INTERNAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Internal call for creating a new hat\\n    /// @dev Initializes a new Hat in storage, but does not mint any tokens\\n    /// @param _id ID of the hat to be stored\\n    /// @param _details A description of the hat\\n    /// @param _maxSupply The total instances of the Hat that can be worn at once\\n    /// @param _eligibility The address that can report on the Hat wearer's status\\n    /// @param _toggle The address that can deactivate the hat [optional]\\n    /// @param _mutable Whether the hat's properties are changeable after creation\\n    /// @param _imageURI The image uri for this top hat and the fallback for its\\n    ///                  downstream hats [optional]\\n    function _createHat(\\n        uint256 _id,\\n        string calldata _details,\\n        uint32 _maxSupply,\\n        address _eligibility,\\n        address _toggle,\\n        bool _mutable,\\n        string calldata _imageURI\\n    ) internal {\\n        /* \\n          We write directly to storage instead of first building the Hat struct in memory.\\n          This allows us to cheaply use the existing lastHatId value in case it was incremented by creating a hat while skipping admin levels.\\n          (Resetting it to 0 would be bad since this hat's child hat(s) would overwrite the previously created hat(s) at that level.)\\n        */\\n        Hat storage hat = _hats[_id];\\n        hat.details = _details;\\n        hat.maxSupply = _maxSupply;\\n        hat.eligibility = _eligibility;\\n        hat.toggle = _toggle;\\n        hat.imageURI = _imageURI;\\n        // config is a concatenation of the status and mutability properties\\n        hat.config = _mutable ? uint96(3 << 94) : uint96(1 << 95);\\n\\n        emit HatCreated(_id, _details, _maxSupply, _eligibility, _toggle, _mutable, _imageURI);\\n    }\\n\\n    /// @notice Internal function to process hat status\\n    /// @dev Updates a hat's status if different from current\\n    /// @param _hatId The id of the Hat in quest\\n    /// @param _newStatus The status to potentially change to\\n    /// @return updated - Whether the status was updated\\n    function _processHatStatus(uint256 _hatId, bool _newStatus) internal returns (bool updated) {\\n        // optimize later\\n        Hat storage hat = _hats[_hatId];\\n\\n        if (_newStatus != _getHatStatus(hat)) {\\n            _setHatStatus(hat, _newStatus);\\n            emit HatStatusChanged(_hatId, _newStatus);\\n            updated = true;\\n        }\\n    }\\n\\n    /// @notice Internal call to process wearer status from the eligibility module\\n    /// @dev Burns the wearer's Hat token if _eligible is false, and updates badStandings\\n    /// state if necessary\\n    /// @param _hatId The id of the Hat to revoke\\n    /// @param _wearer The address of the wearer in question\\n    /// @param _eligible Whether _wearer is eligible for the Hat (if false, this function\\n    /// will revoke their Hat)\\n    /// @param _standing Whether _wearer is in good standing (to be recorded in storage)\\n    /// @return updated Whether the wearer standing was updated\\n    function _processHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)\\n        internal\\n        returns (bool updated)\\n    {\\n        // revoke/burn the hat if _wearer has a positive balance\\n        if (_staticBalanceOf(_wearer, _hatId) > 0) {\\n            // always ineligible if in bad standing\\n            if (!_eligible || !_standing) {\\n                _burnHat(_wearer, _hatId);\\n            }\\n        }\\n\\n        // record standing for use by other contracts\\n        // note: here, standing and badStandings are opposite\\n        // i.e. if standing (true = good standing)\\n        // then badStandings[_hatId][wearer] will be false\\n        // if they are different, then something has changed, and we need to update\\n        // badStandings marker\\n        if (_standing == badStandings[_hatId][_wearer]) {\\n            badStandings[_hatId][_wearer] = !_standing;\\n            updated = true;\\n\\n            emit WearerStandingChanged(_hatId, _wearer, _standing);\\n        }\\n    }\\n\\n    /// @notice Internal function to set a hat's status in storage\\n    /// @dev Flips the 0th bit of _hat.config via bitwise operation\\n    /// @param _hat The hat object\\n    /// @param _status The status to set for the hat\\n    function _setHatStatus(Hat storage _hat, bool _status) internal {\\n        if (_status) {\\n            _hat.config |= uint96(1 << 95);\\n        } else {\\n            _hat.config &= ~uint96(1 << 95);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to retrieve an account's internal \\\"static\\\" balance directly from internal storage,\\n     * @dev This function bypasses the dynamic `_isActive` and `_isEligible` checks\\n     * @param _account The account to check\\n     * @param _hatId The hat to check\\n     * @return staticBalance The account's static of the hat, from internal storage\\n     */\\n    function _staticBalanceOf(address _account, uint256 _hatId) internal view returns (uint256 staticBalance) {\\n        staticBalance = _balanceOf[_account][_hatId];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              HATS ADMIN FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Checks whether msg.sender is an admin of a hat, and reverts if not\\n    function _checkAdmin(uint256 _hatId) internal view {\\n        if (!isAdminOfHat(msg.sender, _hatId)) {\\n            revert NotAdmin(msg.sender, _hatId);\\n        }\\n    }\\n\\n    /// @notice checks whether the msg.sender is either an admin or wearer or a hat, and reverts the appropriate error if not\\n    function _checkAdminOrWearer(uint256 _hatId) internal view {\\n        if (!isAdminOfHat(msg.sender, _hatId) && !isWearerOfHat(msg.sender, _hatId)) {\\n            revert NotAdminOrWearer();\\n        }\\n    }\\n\\n    /// @notice Transfers a hat from one wearer to another eligible wearer\\n    /// @dev The hat must be mutable, and the transfer must be initiated by an admin\\n    /// @param _hatId The hat in question\\n    /// @param _from The current wearer\\n    /// @param _to The new wearer\\n    function transferHat(uint256 _hatId, address _from, address _to) public {\\n        _checkAdmin(_hatId);\\n        // cannot transfer immutable hats, except for tophats, which can always transfer themselves\\n        if (!isTopHat(_hatId)) {\\n            if (!_isMutable(_hats[_hatId])) revert Immutable();\\n        }\\n        // Checks storage instead of `isWearerOfHat` since admins may want to transfer revoked Hats to new wearers\\n        if (_staticBalanceOf(_from, _hatId) < 1) revert NotHatWearer();\\n        // Check if recipient is already wearing hat; also checks storage to maintain balance == 1 invariant\\n        if (_staticBalanceOf(_to, _hatId) > 0) revert AlreadyWearingHat(_to, _hatId);\\n        // only eligible wearers can receive transferred hats\\n        if (!isEligible(_to, _hatId)) revert NotEligible();\\n        // only active hats can be transferred\\n        if (!_isActive(_hats[_hatId], _hatId)) revert HatNotActive();\\n        // we've made it passed all the checks, so adjust balances to execute the transfer\\n        _balanceOf[_from][_hatId] = 0;\\n        _balanceOf[_to][_hatId] = 1;\\n        // emit the ERC1155 standard transfer event\\n        emit TransferSingle(msg.sender, _from, _to, _hatId, 1);\\n    }\\n\\n    /// @notice Set a mutable hat to immutable\\n    /// @dev Sets the second bit of hat.config to 0\\n    /// @param _hatId The id of the Hat to make immutable\\n    function makeHatImmutable(uint256 _hatId) external {\\n        _checkAdmin(_hatId);\\n\\n        Hat storage hat = _hats[_hatId];\\n\\n        if (!_isMutable(hat)) {\\n            revert Immutable();\\n        }\\n\\n        hat.config &= ~uint96(1 << 94);\\n\\n        emit HatMutabilityChanged(_hatId);\\n    }\\n\\n    /// @notice Change a hat's details\\n    /// @dev Hat must be mutable, except for tophats.\\n    /// @param _hatId The id of the Hat to change\\n    /// @param _newDetails The new details. Must not be larger than 7000 bytes.\\n    function changeHatDetails(uint256 _hatId, string calldata _newDetails) external {\\n        if (bytes(_newDetails).length > 7000) revert StringTooLong();\\n\\n        _checkAdmin(_hatId);\\n\\n        Hat storage hat = _hats[_hatId];\\n\\n        // a tophat can change its own details, but otherwise only mutable hat details can be changed\\n        if (!isTopHat(_hatId)) {\\n            if (!_isMutable(hat)) revert Immutable();\\n        }\\n\\n        hat.details = _newDetails;\\n\\n        emit HatDetailsChanged(_hatId, _newDetails);\\n    }\\n\\n    /// @notice Change a hat's details\\n    /// @dev Hat must be mutable\\n    /// @param _hatId The id of the Hat to change\\n    /// @param _newEligibility The new eligibility module\\n    function changeHatEligibility(uint256 _hatId, address _newEligibility) external {\\n        if (_newEligibility == address(0)) revert ZeroAddress();\\n\\n        _checkAdmin(_hatId);\\n        Hat storage hat = _hats[_hatId];\\n\\n        if (!_isMutable(hat)) {\\n            revert Immutable();\\n        }\\n\\n        hat.eligibility = _newEligibility;\\n\\n        emit HatEligibilityChanged(_hatId, _newEligibility);\\n    }\\n\\n    /// @notice Change a hat's details\\n    /// @dev Hat must be mutable\\n    /// @param _hatId The id of the Hat to change\\n    /// @param _newToggle The new toggle module\\n    function changeHatToggle(uint256 _hatId, address _newToggle) external {\\n        if (_newToggle == address(0)) revert ZeroAddress();\\n\\n        _checkAdmin(_hatId);\\n        Hat storage hat = _hats[_hatId];\\n\\n        if (!_isMutable(hat)) {\\n            revert Immutable();\\n        }\\n\\n        // record hat status from old toggle before changing; ensures smooth transition to new toggle,\\n        // especially in case of switching from mechanistic to humanistic toggle\\n        // a) attempt to retrieve hat status from old toggle\\n        (bool success, bool newStatus) = _pullHatStatus(hat, _hatId);\\n        // b) if succeeded, (ie if old toggle was mechanistic), store the retrieved status\\n        if (success) _processHatStatus(_hatId, newStatus);\\n\\n        // set the new toggle\\n        hat.toggle = _newToggle;\\n\\n        emit HatToggleChanged(_hatId, _newToggle);\\n    }\\n\\n    /// @notice Change a hat's details\\n    /// @dev Hat must be mutable, except for tophats\\n    /// @param _hatId The id of the Hat to change\\n    /// @param _newImageURI The new imageURI. Must not be larger than 7000 bytes.\\n    function changeHatImageURI(uint256 _hatId, string calldata _newImageURI) external {\\n        if (bytes(_newImageURI).length > 7000) revert StringTooLong();\\n\\n        _checkAdmin(_hatId);\\n        Hat storage hat = _hats[_hatId];\\n\\n        // a tophat can change its own imageURI, but otherwise only mutable hat imageURIs can be changed\\n        if (!isTopHat(_hatId)) {\\n            if (!_isMutable(hat)) revert Immutable();\\n        }\\n\\n        hat.imageURI = _newImageURI;\\n\\n        emit HatImageURIChanged(_hatId, _newImageURI);\\n    }\\n\\n    /// @notice Change a hat's details\\n    /// @dev Hat must be mutable; new max supply cannot be less than current supply\\n    /// @param _hatId The id of the Hat to change\\n    /// @param _newMaxSupply The new max supply\\n    function changeHatMaxSupply(uint256 _hatId, uint32 _newMaxSupply) external {\\n        _checkAdmin(_hatId);\\n        Hat storage hat = _hats[_hatId];\\n\\n        if (!_isMutable(hat)) {\\n            revert Immutable();\\n        }\\n\\n        if (_newMaxSupply < hat.supply) {\\n            revert NewMaxSupplyTooLow();\\n        }\\n\\n        if (_newMaxSupply != hat.maxSupply) {\\n            hat.maxSupply = _newMaxSupply;\\n            emit HatMaxSupplyChanged(_hatId, _newMaxSupply);\\n        }\\n    }\\n\\n    /// @notice Submits a request to link a Hat Tree under a parent tree. Requests can be\\n    /// submitted by either...\\n    ///     a) the wearer of a topHat, previous to any linkage, or\\n    ///     b) the admin(s) of an already-linked topHat (aka tree root), where such a\\n    ///        request is to move the tree root to another admin within the same parent\\n    ///        tree\\n    /// @dev A topHat can have at most 1 request at a time. Submitting a new request will\\n    ///      replace the existing request.\\n    /// @param _topHatDomain The domain of the topHat to link\\n    /// @param _requestedAdminHat The hat that will administer the linked tree\\n    function requestLinkTopHatToTree(uint32 _topHatDomain, uint256 _requestedAdminHat) external {\\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\\n\\n        // The wearer of an unlinked tophat is also the admin of same; once a tophat is linked, its wearer is no longer its admin\\n        _checkAdmin(fullTopHatId);\\n\\n        linkedTreeRequests[_topHatDomain] = _requestedAdminHat;\\n        emit TopHatLinkRequested(_topHatDomain, _requestedAdminHat);\\n    }\\n\\n    /// @notice Approve a request to link a Tree under a parent tree, with options to add eligibility or toggle modules and change its metadata\\n    /// @dev Requests can only be approved by wearer or an admin of the `_newAdminHat`, and there\\n    ///      can only be one link per tree root at a given time.\\n    /// @param _topHatDomain The 32 bit domain of the topHat to link\\n    /// @param _newAdminHat The hat that will administer the linked tree\\n    /// @param _eligibility Optional new eligibility module for the linked topHat\\n    /// @param _toggle Optional new toggle module for the linked topHat\\n    /// @param _details Optional new details for the linked topHat\\n    /// @param _imageURI Optional new imageURI for the linked topHat\\n    function approveLinkTopHatToTree(\\n        uint32 _topHatDomain,\\n        uint256 _newAdminHat,\\n        address _eligibility,\\n        address _toggle,\\n        string calldata _details,\\n        string calldata _imageURI\\n    ) external {\\n        // for everything but the last hat level, check the admin of `_newAdminHat`'s theoretical child hat, since either wearer or admin of `_newAdminHat` can approve\\n        if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\\n            _checkAdmin(buildHatId(_newAdminHat, 1));\\n        } else {\\n            // the above buildHatId trick doesn't work for the last hat level, so we need to explicitly check both admin and wearer in this case\\n            _checkAdminOrWearer(_newAdminHat);\\n        }\\n\\n        // Linkages must be initiated by a request\\n        if (_newAdminHat != linkedTreeRequests[_topHatDomain]) revert LinkageNotRequested();\\n\\n        // remove the request -- ensures all linkages are initialized by unique requests,\\n        // except for relinks (see `relinkTopHatWithinTree`)\\n        delete linkedTreeRequests[_topHatDomain];\\n\\n        // execute the link. Replaces existing link, if any.\\n        _linkTopHatToTree(_topHatDomain, _newAdminHat, _eligibility, _toggle, _details, _imageURI);\\n    }\\n\\n    /**\\n     * @notice Unlink a Tree from the parent tree\\n     * @dev This can only be called by an admin of the tree root. Fails if the topHat to unlink has no non-zero wearer, which can occur if...\\n     *     - It's wearer is in badStanding\\n     *     - It has been revoked from its wearer (and possibly burned)\u02d8\\n     *     - It is not active (ie toggled off)\\n     * @param _topHatDomain The 32 bit domain of the topHat to unlink\\n     * @param _wearer The current wearer of the topHat to unlink\\n     */\\n    function unlinkTopHatFromTree(uint32 _topHatDomain, address _wearer) external {\\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\\n        _checkAdmin(fullTopHatId);\\n\\n        // prevent unlinking if the topHat has no non-zero wearer\\n        // since we cannot search the entire address space for a wearer, we require the caller to provide the wearer\\n        if (_wearer == address(0) || !isWearerOfHat(_wearer, fullTopHatId)) revert HatsErrors.InvalidUnlink();\\n\\n        // execute the unlink\\n        delete linkedTreeAdmins[_topHatDomain];\\n        // remove the request \u2014 ensures all linkages are initialized by unique requests\\n        delete linkedTreeRequests[_topHatDomain];\\n\\n        // reset eligibility and storage to defaults for unlinked top hats\\n        Hat storage hat = _hats[fullTopHatId];\\n        delete hat.eligibility;\\n        delete hat.toggle;\\n\\n        emit TopHatLinked(_topHatDomain, 0);\\n    }\\n\\n    /// @notice Move a tree root to a different position within the same parent tree,\\n    ///         without a request. Valid destinations include within the same local tree as the origin,\\n    ///         or to the local tree of the tippyTopHat. TippyTopHat wearers can bypass this restriction\\n    ///         to relink to anywhere in its full tree.\\n    /// @dev Caller must be both an admin tree root and admin or wearer of `_newAdminHat`.\\n    /// @param _topHatDomain The 32 bit domain of the topHat to relink\\n    /// @param _newAdminHat The new admin for the linked tree\\n    /// @param _eligibility Optional new eligibility module for the linked topHat\\n    /// @param _toggle Optional new toggle module for the linked topHat\\n    /// @param _details Optional new details for the linked topHat\\n    /// @param _imageURI Optional new imageURI for the linked topHat\\n    function relinkTopHatWithinTree(\\n        uint32 _topHatDomain,\\n        uint256 _newAdminHat,\\n        address _eligibility,\\n        address _toggle,\\n        string calldata _details,\\n        string calldata _imageURI\\n    ) external {\\n        uint256 fullTopHatId = uint256(_topHatDomain) << 224; // (256 - TOPHAT_ADDRESS_SPACE);\\n\\n        // msg.sender being capable of both requesting and approving allows us to skip the request step\\n        _checkAdmin(fullTopHatId); // \\\"requester\\\" must be admin\\n\\n        // \\\"approver\\\" can be wearer or admin\\n        if (getHatLevel(_newAdminHat) < MAX_LEVELS) {\\n            _checkAdmin(buildHatId(_newAdminHat, 1));\\n        } else {\\n            // the above buildHatId trick doesn't work for the last hat level, so we need to explicitly check both admin and wearer in this case\\n            _checkAdminOrWearer(_newAdminHat);\\n        }\\n\\n        // execute the new link, replacing the old link\\n        _linkTopHatToTree(_topHatDomain, _newAdminHat, _eligibility, _toggle, _details, _imageURI);\\n    }\\n\\n    /// @notice Internal function to link a Tree under a parent Tree, with protection against circular linkages and relinking to a separate Tree,\\n    ///         with options to add eligibility or toggle modules and change its metadata\\n    /// @dev Linking `_topHatDomain` replaces any existing links\\n    /// @param _topHatDomain The 32 bit domain of the topHat to link\\n    /// @param _newAdminHat The new admin for the linked tree\\n    /// @param _eligibility Optional new eligibility module for the linked topHat\\n    /// @param _toggle Optional new toggle module for the linked topHat\\n    /// @param _details Optional new details for the linked topHat\\n    /// @param _imageURI Optional new imageURI for the linked topHat\\n    function _linkTopHatToTree(\\n        uint32 _topHatDomain,\\n        uint256 _newAdminHat,\\n        address _eligibility,\\n        address _toggle,\\n        string calldata _details,\\n        string calldata _imageURI\\n    ) internal {\\n        if (!noCircularLinkage(_topHatDomain, _newAdminHat)) revert CircularLinkage();\\n        {\\n            uint256 linkedAdmin = linkedTreeAdmins[_topHatDomain];\\n\\n            // disallow relinking to separate tree\\n            if (linkedAdmin > 0) {\\n                uint256 tippyTopHat = uint256(getTippyTopHatDomain(_topHatDomain)) << 224;\\n                if (!isWearerOfHat(msg.sender, tippyTopHat)) {\\n                    uint256 destLocalTopHat = uint256(_newAdminHat >> 224 << 224); // (256 - TOPHAT_ADDRESS_SPACE);\\n                    // for non-tippyTopHat wearers: destination local tophat must be either...\\n                    // a) the same as origin local tophat, or\\n                    // b) within the tippy top hat's local tree\\n                    uint256 originLocalTopHat = linkedAdmin >> 224 << 224; // (256 - TOPHAT_ADDRESS_SPACE);\\n                    if (destLocalTopHat != originLocalTopHat && destLocalTopHat != tippyTopHat) {\\n                        revert CrossTreeLinkage();\\n                    }\\n                    // for tippyTopHat weerers: destination must be within the same super tree\\n                } else if (!sameTippyTopHatDomain(_topHatDomain, _newAdminHat)) {\\n                    revert CrossTreeLinkage();\\n                }\\n            }\\n        }\\n\\n        // update and log the linked topHat's modules and metadata, if any changes\\n        uint256 topHatId = uint256(_topHatDomain) << 224;\\n        Hat storage hat = _hats[topHatId];\\n\\n        if (_eligibility != address(0)) {\\n            hat.eligibility = _eligibility;\\n            emit HatEligibilityChanged(topHatId, _eligibility);\\n        }\\n        if (_toggle != address(0)) {\\n            hat.toggle = _toggle;\\n            emit HatToggleChanged(topHatId, _toggle);\\n        }\\n\\n        uint256 length = bytes(_details).length;\\n        if (length > 0) {\\n            if (length > 7000) revert StringTooLong();\\n            hat.details = _details;\\n            emit HatDetailsChanged(topHatId, _details);\\n        }\\n\\n        length = bytes(_imageURI).length;\\n        if (length > 0) {\\n            if (length > 7000) revert StringTooLong();\\n            hat.imageURI = _imageURI;\\n            emit HatImageURIChanged(topHatId, _imageURI);\\n        }\\n\\n        // store the new linked admin\\n        linkedTreeAdmins[_topHatDomain] = _newAdminHat;\\n        emit TopHatLinked(_topHatDomain, _newAdminHat);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              HATS VIEW FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice View the properties of a given Hat\\n    /// @param _hatId The id of the Hat\\n    /// @return details The details of the Hat\\n    /// @return maxSupply The max supply of tokens for this Hat\\n    /// @return supply The number of current wearers of this Hat\\n    /// @return eligibility The eligibility address for this Hat\\n    /// @return toggle The toggle address for this Hat\\n    /// @return imageURI The image URI used for this Hat\\n    /// @return lastHatId The most recently created Hat with this Hat as admin; also the count of Hats with this Hat as admin\\n    /// @return mutable_ Whether this hat's properties can be changed\\n    /// @return active Whether the Hat is current active, as read from `_isActive`\\n    function viewHat(uint256 _hatId)\\n        public\\n        view\\n        returns (\\n            string memory details,\\n            uint32 maxSupply,\\n            uint32 supply,\\n            address eligibility,\\n            address toggle,\\n            string memory imageURI,\\n            uint16 lastHatId,\\n            bool mutable_,\\n            bool active\\n        )\\n    {\\n        Hat storage hat = _hats[_hatId];\\n        details = hat.details;\\n        maxSupply = hat.maxSupply;\\n        supply = hat.supply;\\n        eligibility = hat.eligibility;\\n        toggle = hat.toggle;\\n        imageURI = getImageURIForHat(_hatId);\\n        lastHatId = hat.lastHatId;\\n        mutable_ = _isMutable(hat);\\n        active = _isActive(hat, _hatId);\\n    }\\n\\n    /// @notice Checks whether a given address wears a given Hat\\n    /// @dev Convenience function that wraps `balanceOf`\\n    /// @param _user The address in question\\n    /// @param _hatId The id of the Hat that the `_user` might wear\\n    /// @return isWearer Whether the `_user` wears the Hat.\\n    function isWearerOfHat(address _user, uint256 _hatId) public view returns (bool isWearer) {\\n        isWearer = (balanceOf(_user, _hatId) > 0);\\n    }\\n\\n    /// @notice Checks whether a given address serves as the admin of a given Hat\\n    /// @dev Recursively checks if `_user` wears the admin Hat of the Hat in question. This is recursive since there may be a string of Hats as admins of Hats.\\n    /// @param _user The address in question\\n    /// @param _hatId The id of the Hat for which the `_user` might be the admin\\n    /// @return isAdmin Whether the `_user` has admin rights for the Hat\\n    function isAdminOfHat(address _user, uint256 _hatId) public view returns (bool isAdmin) {\\n        uint256 linkedTreeAdmin;\\n        uint32 adminLocalHatLevel;\\n        if (isLocalTopHat(_hatId)) {\\n            linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\\n            if (linkedTreeAdmin == 0) {\\n                // tree is not linked\\n                return isAdmin = isWearerOfHat(_user, _hatId);\\n            } else {\\n                // tree is linked\\n                if (isWearerOfHat(_user, linkedTreeAdmin)) {\\n                    return isAdmin = true;\\n                } // user wears the treeAdmin\\n                else {\\n                    adminLocalHatLevel = getLocalHatLevel(linkedTreeAdmin);\\n                    _hatId = linkedTreeAdmin;\\n                }\\n            }\\n        } else {\\n            // if we get here, _hatId is not a tophat of any kind\\n            // get the local tree level of _hatId's admin\\n            adminLocalHatLevel = getLocalHatLevel(_hatId) - 1;\\n        }\\n\\n        // search up _hatId's local address space for an admin hat that the _user wears\\n        while (adminLocalHatLevel > 0) {\\n            if (isWearerOfHat(_user, getAdminAtLocalLevel(_hatId, adminLocalHatLevel))) {\\n                return isAdmin = true;\\n            }\\n            // should not underflow given stopping condition > 0\\n            unchecked {\\n                --adminLocalHatLevel;\\n            }\\n        }\\n\\n        // if we get here, we've reached the top of _hatId's local tree, ie the local tophat\\n        // check if the user wears the local tophat\\n        if (isWearerOfHat(_user, getAdminAtLocalLevel(_hatId, 0))) return isAdmin = true;\\n\\n        // if not, we check if it's linked to another tree\\n        linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\\n        if (linkedTreeAdmin == 0) {\\n            // tree is not linked\\n            // we've already learned that user doesn't wear the local tophat, so there's nothing else to check; we return false\\n            return isAdmin = false;\\n        } else {\\n            // tree is linked\\n            // check if user is wearer of linkedTreeAdmin\\n            if (isWearerOfHat(_user, linkedTreeAdmin)) return true;\\n            // if not, recurse to traverse the parent tree for a hat that the user wears\\n            isAdmin = isAdminOfHat(_user, linkedTreeAdmin);\\n        }\\n    }\\n\\n    /// @notice Checks the active status of a hat\\n    /// @dev For internal use instead of `isActive` when passing Hat as param is preferable\\n    /// @param _hat The Hat struct\\n    /// @param _hatId The id of the hat\\n    /// @return active The active status of the hat\\n    function _isActive(Hat storage _hat, uint256 _hatId) internal view returns (bool active) {\\n        (bool success, bytes memory returndata) =\\n            _hat.toggle.staticcall(abi.encodeWithSignature(\\\"getHatStatus(uint256)\\\", _hatId));\\n\\n        /*\\n        * if function call succeeds with data of length == 32, then we know the contract exists\\n        * and has the getHatStatus function.\\n        * But \u2014 since function selectors don't include return types \u2014 we still can't assume that the return data is a boolean,\\n        * so we treat it as a uint so it will always safely decode without throwing.\\n        */\\n        if (success && returndata.length == 32) {\\n            // check the returndata manually\\n            uint256 uintReturndata = uint256(bytes32(returndata));\\n            // false condition\\n            if (uintReturndata == 0) {\\n                active = false;\\n                // true condition\\n            } else if (uintReturndata == 1) {\\n                active = true;\\n            }\\n            // invalid condition\\n            else {\\n                active = _getHatStatus(_hat);\\n            }\\n        } else {\\n            active = _getHatStatus(_hat);\\n        }\\n    }\\n\\n    /// @notice Checks the active status of a hat\\n    /// @param _hatId The id of the hat\\n    /// @return active Whether the hat is active\\n    function isActive(uint256 _hatId) external view returns (bool active) {\\n        active = _isActive(_hats[_hatId], _hatId);\\n    }\\n\\n    /// @notice Internal function to retrieve a hat's status from storage\\n    /// @dev reads the 0th bit of the hat's config\\n    /// @param _hat The hat object\\n    /// @return status Whether the hat is active\\n    function _getHatStatus(Hat storage _hat) internal view returns (bool status) {\\n        status = (_hat.config >> 95 != 0);\\n    }\\n\\n    /// @notice Internal function to retrieve a hat's mutability setting\\n    /// @dev reads the 1st bit of the hat's config\\n    /// @param _hat The hat object\\n    /// @return _mutable Whether the hat is mutable\\n    function _isMutable(Hat storage _hat) internal view returns (bool _mutable) {\\n        _mutable = (_hat.config & uint96(1 << 94) != 0);\\n    }\\n\\n    /// @notice Checks whether a wearer of a Hat is in good standing\\n    /// @param _wearer The address of the Hat wearer\\n    /// @param _hatId The id of the Hat\\n    /// @return standing Whether the wearer is in good standing\\n    function isInGoodStanding(address _wearer, uint256 _hatId) public view returns (bool standing) {\\n        (bool success, bytes memory returndata) = _hats[_hatId].eligibility.staticcall(\\n            abi.encodeWithSignature(\\\"getWearerStatus(address,uint256)\\\", _wearer, _hatId)\\n        );\\n\\n        /* \\n        * if function call succeeds with data of length == 64, then we know the contract exists \\n        * and has the getWearerStatus function (which returns two words).\\n        * But \u2014 since function selectors don't include return types \u2014 we still can't assume that the return data is two booleans, \\n        * so we treat it as a uint so it will always safely decode without throwing.\\n        */\\n        if (success && returndata.length == 64) {\\n            // check the returndata manually\\n            (uint256 firstWord, uint256 secondWord) = abi.decode(returndata, (uint256, uint256));\\n            // returndata is valid\\n            if (firstWord < 2 && secondWord < 2) {\\n                standing = (secondWord == 1) ? true : false;\\n                // returndata is invalid\\n            } else {\\n                standing = !badStandings[_hatId][_wearer];\\n            }\\n        } else {\\n            standing = !badStandings[_hatId][_wearer];\\n        }\\n    }\\n\\n    /// @notice Internal call to check whether an address is eligible for a given Hat\\n    /// @dev Tries an external call to the Hat's eligibility module, defaulting to existing badStandings state if the call fails (ie if the eligibility module address does not conform to the IHatsEligibility interface)\\n    /// @param _wearer The address of the Hat wearer\\n    /// @param _hat The Hat object\\n    /// @param _hatId The id of the Hat\\n    /// @return eligible Whether the wearer is eligible for the Hat\\n    function _isEligible(address _wearer, Hat storage _hat, uint256 _hatId) internal view returns (bool eligible) {\\n        (bool success, bytes memory returndata) =\\n            _hat.eligibility.staticcall(abi.encodeWithSignature(\\\"getWearerStatus(address,uint256)\\\", _wearer, _hatId));\\n\\n        /* \\n        * if function call succeeds with data of length == 64, then we know the contract exists \\n        * and has the getWearerStatus function (which returns two words).\\n        * But \u2014 since function selectors don't include return types \u2014 we still can't assume that the return data is two booleans, \\n        * so we treat it as a uint so it will always safely decode without throwing.\\n        */\\n        if (success && returndata.length == 64) {\\n            bool standing;\\n            // check the returndata manually\\n            (uint256 firstWord, uint256 secondWord) = abi.decode(returndata, (uint256, uint256));\\n            // returndata is valid\\n            if (firstWord < 2 && secondWord < 2) {\\n                standing = (secondWord == 1) ? true : false;\\n                // never eligible if in bad standing\\n                eligible = (standing && firstWord == 1) ? true : false;\\n            }\\n            // returndata is invalid\\n            else {\\n                eligible = !badStandings[_hatId][_wearer];\\n            }\\n        } else {\\n            eligible = !badStandings[_hatId][_wearer];\\n        }\\n    }\\n\\n    /// @notice Checks whether an address is eligible for a given Hat\\n    /// @dev Public function for use when passing a Hat object is not possible or preferable\\n    /// @param _hatId The id of the Hat\\n    /// @param _wearer The address to check\\n    /// @return eligible Whether the wearer is eligible for the Hat\\n    function isEligible(address _wearer, uint256 _hatId) public view returns (bool eligible) {\\n        eligible = _isEligible(_wearer, _hats[_hatId], _hatId);\\n    }\\n\\n    /// @notice Gets the current supply of a Hat\\n    /// @dev Only tracks explicit burns and mints, not dynamic revocations\\n    /// @param _hatId The id of the Hat\\n    /// @return supply The current supply of the Hat\\n    function hatSupply(uint256 _hatId) external view returns (uint32 supply) {\\n        supply = _hats[_hatId].supply;\\n    }\\n\\n    /// @notice Gets the eligibility module for a hat\\n    /// @param _hatId The hat whose eligibility module we're looking for\\n    /// @return eligibility The eligibility module for this hat\\n    function getHatEligibilityModule(uint256 _hatId) external view returns (address eligibility) {\\n        eligibility = _hats[_hatId].eligibility;\\n    }\\n\\n    /// @notice Gets the toggle module for a hat\\n    /// @param _hatId The hat whose toggle module we're looking for\\n    /// @return toggle The toggle module for this hat\\n    function getHatToggleModule(uint256 _hatId) external view returns (address toggle) {\\n        toggle = _hats[_hatId].toggle;\\n    }\\n\\n    /// @notice Gets the max supply for a hat\\n    /// @param _hatId The hat whose max supply we're looking for\\n    /// @return maxSupply The maximum possible quantity of this hat that could be minted\\n    function getHatMaxSupply(uint256 _hatId) external view returns (uint32 maxSupply) {\\n        maxSupply = _hats[_hatId].maxSupply;\\n    }\\n\\n    /// @notice Gets the imageURI for a given hat\\n    /// @dev If this hat does not have an imageURI set, recursively get the imageURI from\\n    ///      its admin\\n    /// @param _hatId The hat whose imageURI we're looking for\\n    /// @return _uri The imageURI of this hat or, if empty, its admin\\n    function getImageURIForHat(uint256 _hatId) public view returns (string memory _uri) {\\n        // check _hatId first to potentially avoid the `getHatLevel` call\\n        Hat storage hat = _hats[_hatId];\\n\\n        string memory imageURI = hat.imageURI; // save 1 SLOAD\\n\\n        // if _hatId has an imageURI, we return it\\n        if (bytes(imageURI).length > 0) {\\n            return imageURI;\\n        }\\n\\n        // otherwise, we check its branch of admins\\n        uint256 level = getHatLevel(_hatId);\\n\\n        // but first we check if _hatId is a tophat, in which case we fall back to the global image uri\\n        if (level == 0) return baseImageURI;\\n\\n        // otherwise, we check each of its admins for a valid imageURI\\n        uint256 id;\\n\\n        // already checked at `level` above, so we start the loop at `level - 1`\\n        for (uint256 i = level - 1; i > 0;) {\\n            id = getAdminAtLevel(_hatId, uint32(i));\\n            hat = _hats[id];\\n            imageURI = hat.imageURI;\\n\\n            if (bytes(imageURI).length > 0) {\\n                return imageURI;\\n            }\\n            // should not underflow given stopping condition is > 0\\n            unchecked {\\n                --i;\\n            }\\n        }\\n\\n        id = getAdminAtLevel(_hatId, 0);\\n        hat = _hats[id];\\n        imageURI = hat.imageURI;\\n\\n        if (bytes(imageURI).length > 0) {\\n            return imageURI;\\n        }\\n\\n        // if none of _hatId's admins has an imageURI of its own, we again fall back to the global image uri\\n        _uri = baseImageURI;\\n    }\\n\\n    /// @notice Constructs the URI for a Hat, using data from the Hat struct\\n    /// @param _hatId The id of the Hat\\n    /// @return _uri An ERC1155-compatible JSON string\\n    function _constructURI(uint256 _hatId) internal view returns (string memory _uri) {\\n        Hat storage hat = _hats[_hatId];\\n\\n        uint256 hatAdmin;\\n\\n        if (isTopHat(_hatId)) {\\n            hatAdmin = _hatId;\\n        } else {\\n            hatAdmin = getAdminAtLevel(_hatId, getHatLevel(_hatId) - 1);\\n        }\\n\\n        // split into two objects to avoid stack too deep error\\n        string memory idProperties = string.concat(\\n            '\\\"domain\\\": \\\"',\\n            LibString.toString(getTopHatDomain(_hatId)),\\n            '\\\", \\\"id\\\": \\\"',\\n            LibString.toString(_hatId),\\n            '\\\", \\\"pretty id\\\": \\\"',\\n            LibString.toHexString(_hatId, 32),\\n            '\\\",'\\n        );\\n\\n        string memory otherProperties = string.concat(\\n            '\\\"status\\\": \\\"',\\n            (_isActive(hat, _hatId) ? \\\"active\\\" : \\\"inactive\\\"),\\n            '\\\", \\\"current supply\\\": \\\"',\\n            LibString.toString(hat.supply),\\n            '\\\", \\\"supply cap\\\": \\\"',\\n            LibString.toString(hat.maxSupply),\\n            '\\\", \\\"admin (id)\\\": \\\"',\\n            LibString.toString(hatAdmin),\\n            '\\\", \\\"admin (pretty id)\\\": \\\"',\\n            LibString.toHexString(hatAdmin, 32),\\n            '\\\", \\\"eligibility module\\\": \\\"',\\n            LibString.toHexString(hat.eligibility),\\n            '\\\", \\\"toggle module\\\": \\\"',\\n            LibString.toHexString(hat.toggle),\\n            '\\\", \\\"mutable\\\": \\\"',\\n            _isMutable(hat) ? \\\"true\\\" : \\\"false\\\",\\n            '\\\"'\\n        );\\n\\n        _uri = string(\\n            abi.encodePacked(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\n                    bytes(\\n                        string.concat(\\n                            '{\\\"name\\\": \\\"',\\n                            \\\"Hat\\\",\\n                            '\\\", \\\"description\\\": \\\"',\\n                            hat.details,\\n                            '\\\", \\\"image\\\": \\\"',\\n                            getImageURIForHat(_hatId),\\n                            '\\\",',\\n                            '\\\"properties\\\": ',\\n                            \\\"{\\\",\\n                            idProperties,\\n                            otherProperties,\\n                            \\\"}\\\",\\n                            \\\"}\\\"\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 OVERRIDES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Gets the Hat token balance of a user for a given Hat\\n    /// @dev Balance is dynamic based on the hat's status and wearer's eligibility, so off-chain balance data indexed from events may not be in sync\\n    /// @param _wearer The address whose balance is being checked\\n    /// @param _hatId The id of the Hat\\n    /// @return balance The `wearer`'s balance of the Hat tokens. Can never be > 1.\\n    function balanceOf(address _wearer, uint256 _hatId)\\n        public\\n        view\\n        override(ERC1155, IHats)\\n        returns (uint256 balance)\\n    {\\n        Hat storage hat = _hats[_hatId];\\n\\n        balance = 0;\\n\\n        if (_isActive(hat, _hatId) && _isEligible(_wearer, hat, _hatId)) {\\n            balance = super.balanceOf(_wearer, _hatId);\\n        }\\n    }\\n\\n    /// @notice Internal call to mint a Hat token to a wearer\\n    /// @dev Unsafe if called when `_wearer` has a non-zero balance of `_hatId`\\n    /// @param _wearer The wearer of the Hat and the recipient of the newly minted token\\n    /// @param _hatId The id of the Hat to mint\\n    function _mintHat(address _wearer, uint256 _hatId) internal {\\n        unchecked {\\n            // should not overflow since `mintHat` enforces max balance of 1\\n            _balanceOf[_wearer][_hatId] = 1;\\n\\n            // increment Hat supply counter\\n            // should not overflow given AllHatsWorn check in `mintHat`\\n            ++_hats[_hatId].supply;\\n        }\\n\\n        emit TransferSingle(msg.sender, address(0), _wearer, _hatId, 1);\\n    }\\n\\n    /// @notice Internal call to burn a wearer's Hat token\\n    /// @dev Unsafe if called when `_wearer` doesn't have a zero balance of `_hatId`\\n    /// @param _wearer The wearer from which to burn the Hat token\\n    /// @param _hatId The id of the Hat to burn\\n    function _burnHat(address _wearer, uint256 _hatId) internal {\\n        // neither should underflow since `_burnHat` is never called on non-positive balance\\n        unchecked {\\n            _balanceOf[_wearer][_hatId] = 0;\\n\\n            // decrement Hat supply counter\\n            --_hats[_hatId].supply;\\n        }\\n\\n        emit TransferSingle(msg.sender, _wearer, address(0), _hatId, 1);\\n    }\\n\\n    /// @notice Approvals are not necessary for Hats since transfers are not handled by the wearer\\n    /// @dev Admins should use `transferHat()` to transfer\\n    function setApprovalForAll(address, bool) public pure override {\\n        revert();\\n    }\\n\\n    /// @notice Safe transfers are not necessary for Hats since transfers are not handled by the wearer\\n    /// @dev Admins should use `transferHat()` to transfer\\n    function safeTransferFrom(address, address, uint256, uint256, bytes calldata) public pure override {\\n        revert();\\n    }\\n\\n    /// @notice Safe transfers are not necessary for Hats since transfers are not handled by the wearer\\n    function safeBatchTransferFrom(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\\n        public\\n        pure\\n        override\\n    {\\n        revert();\\n    }\\n\\n    /**\\n     * @notice ERC165 interface detection\\n     *  @dev While Hats Protocol conforms to the ERC1155 *interface*, it does not fully conform to the ERC1155 *specification*\\n     *  since it does not implement the ERC1155Receiver functionality.\\n     *  For this reason, this function overrides the ERC1155 implementation to return false for ERC1155.\\n     *  @param interfaceId The interface identifier, as specified in ERC-165\\n     *  @return bool True if the contract implements `interfaceId` and false otherwise\\n     */\\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\\n            // interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            || interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /// @notice Batch retrieval for wearer balances\\n    /// @dev Given the higher gas overhead of Hats balanceOf checks, large batches may be high cost or run into gas limits\\n    /// @param _wearers Array of addresses to check balances for\\n    /// @param _hatIds Array of Hat ids to check, using the same index as _wearers\\n    function balanceOfBatch(address[] calldata _wearers, uint256[] calldata _hatIds)\\n        public\\n        view\\n        override(ERC1155, IHats)\\n        returns (uint256[] memory balances)\\n    {\\n        if (_wearers.length != _hatIds.length) revert BatchArrayLengthMismatch();\\n\\n        balances = new uint256[](_wearers.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i; i < _wearers.length; ++i) {\\n                balances[i] = balanceOf(_wearers[i], _hatIds[i]);\\n            }\\n        }\\n    }\\n\\n    /// @notice View the uri for a Hat\\n    /// @param id The id of the Hat\\n    /// @return _uri An 1155-compatible JSON object\\n    function uri(uint256 id) public view override(ERC1155, IHats) returns (string memory _uri) {\\n        _uri = _constructURI(id);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) internal _balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        _balanceOf[from][id] -= amount;\\n        _balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            _balanceOf[from][id] -= amount;\\n            _balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 balance) {\\n        balance = _balanceOf[owner][id];\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = _balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        _balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            _balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            _balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        _balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Interfaces/IHats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// Copyright (C) 2023 Haberdasher Labs\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.13;\\n\\nimport \\\"./IHatsIdUtilities.sol\\\";\\nimport \\\"./HatsErrors.sol\\\";\\nimport \\\"./HatsEvents.sol\\\";\\n\\ninterface IHats is IHatsIdUtilities, HatsErrors, HatsEvents {\\n    function mintTopHat(address _target, string memory _details, string memory _imageURI)\\n        external\\n        returns (uint256 topHatId);\\n\\n    function createHat(\\n        uint256 _admin,\\n        string calldata _details,\\n        uint32 _maxSupply,\\n        address _eligibility,\\n        address _toggle,\\n        bool _mutable,\\n        string calldata _imageURI\\n    ) external returns (uint256 newHatId);\\n\\n    function batchCreateHats(\\n        uint256[] calldata _admins,\\n        string[] calldata _details,\\n        uint32[] calldata _maxSupplies,\\n        address[] memory _eligibilityModules,\\n        address[] memory _toggleModules,\\n        bool[] calldata _mutables,\\n        string[] calldata _imageURIs\\n    ) external returns (bool success);\\n\\n    function getNextId(uint256 _admin) external view returns (uint256 nextId);\\n\\n    function mintHat(uint256 _hatId, address _wearer) external returns (bool success);\\n\\n    function batchMintHats(uint256[] calldata _hatIds, address[] calldata _wearers) external returns (bool success);\\n\\n    function setHatStatus(uint256 _hatId, bool _newStatus) external returns (bool toggled);\\n\\n    function checkHatStatus(uint256 _hatId) external returns (bool toggled);\\n\\n    function setHatWearerStatus(uint256 _hatId, address _wearer, bool _eligible, bool _standing)\\n        external\\n        returns (bool updated);\\n\\n    function checkHatWearerStatus(uint256 _hatId, address _wearer) external returns (bool updated);\\n\\n    function renounceHat(uint256 _hatId) external;\\n\\n    function transferHat(uint256 _hatId, address _from, address _to) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              HATS ADMIN FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function makeHatImmutable(uint256 _hatId) external;\\n\\n    function changeHatDetails(uint256 _hatId, string memory _newDetails) external;\\n\\n    function changeHatEligibility(uint256 _hatId, address _newEligibility) external;\\n\\n    function changeHatToggle(uint256 _hatId, address _newToggle) external;\\n\\n    function changeHatImageURI(uint256 _hatId, string memory _newImageURI) external;\\n\\n    function changeHatMaxSupply(uint256 _hatId, uint32 _newMaxSupply) external;\\n\\n    function requestLinkTopHatToTree(uint32 _topHatId, uint256 _newAdminHat) external;\\n\\n    function approveLinkTopHatToTree(\\n        uint32 _topHatId,\\n        uint256 _newAdminHat,\\n        address _eligibility,\\n        address _toggle,\\n        string calldata _details,\\n        string calldata _imageURI\\n    ) external;\\n\\n    function unlinkTopHatFromTree(uint32 _topHatId, address _wearer) external;\\n\\n    function relinkTopHatWithinTree(\\n        uint32 _topHatDomain,\\n        uint256 _newAdminHat,\\n        address _eligibility,\\n        address _toggle,\\n        string calldata _details,\\n        string calldata _imageURI\\n    ) external;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              VIEW FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function viewHat(uint256 _hatId)\\n        external\\n        view\\n        returns (\\n            string memory details,\\n            uint32 maxSupply,\\n            uint32 supply,\\n            address eligibility,\\n            address toggle,\\n            string memory imageURI,\\n            uint16 lastHatId,\\n            bool mutable_,\\n            bool active\\n        );\\n\\n    function isWearerOfHat(address _user, uint256 _hatId) external view returns (bool isWearer);\\n\\n    function isAdminOfHat(address _user, uint256 _hatId) external view returns (bool isAdmin);\\n\\n    function isInGoodStanding(address _wearer, uint256 _hatId) external view returns (bool standing);\\n\\n    function isEligible(address _wearer, uint256 _hatId) external view returns (bool eligible);\\n\\n    function getHatEligibilityModule(uint256 _hatId) external view returns (address eligibility);\\n\\n    function getHatToggleModule(uint256 _hatId) external view returns (address toggle);\\n\\n    function getHatMaxSupply(uint256 _hatId) external view returns (uint32 maxSupply);\\n\\n    function hatSupply(uint256 _hatId) external view returns (uint32 supply);\\n\\n    function getImageURIForHat(uint256 _hatId) external view returns (string memory _uri);\\n\\n    function balanceOf(address wearer, uint256 hatId) external view returns (uint256 balance);\\n\\n    function balanceOfBatch(address[] calldata _wearers, uint256[] calldata _hatIds)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function uri(uint256 id) external view returns (string memory _uri);\\n}\\n\"\r\n    },\r\n    \"src/HatsIdUtilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// Copyright (C) 2023 Haberdasher Labs\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.13;\\n\\nimport \\\"./Interfaces/IHatsIdUtilities.sol\\\";\\n// import { console2 } from \\\"forge-std/Test.sol\\\"; //remove after testing\\n\\n/// @notice see HatsErrors.sol for description\\nerror MaxLevelsReached();\\n\\n/// @title Hats Id Utilities\\n/// @dev Functions for working with Hat Ids from Hats Protocol. Factored out of Hats.sol\\n/// for easier use by other contracts.\\n/// @author Haberdasher Labs\\ncontract HatsIdUtilities is IHatsIdUtilities {\\n    /// @notice Mapping of tophats requesting to link to admin hats in other trees\\n    /// @dev Linkage only occurs if request is approved by the new admin\\n    mapping(uint32 => uint256) public linkedTreeRequests; // topHatDomain => requested new admin\\n\\n    /// @notice Mapping of approved & linked tophats to admin hats in other trees, used for grafting one hats tree onto another\\n    /// @dev Trees can only be linked to another tree via their tophat\\n    mapping(uint32 => uint256) public linkedTreeAdmins; // topHatDomain => hatId\\n\\n    /**\\n     * Hat Ids serve as addresses. A given Hat's Id represents its location in its\\n     * hat tree: its level, its admin, its admin's admin (etc, all the way up to the\\n     * tophat).\\n     *\\n     * The top level consists of 4 bytes and references all tophats.\\n     *\\n     * Each level below consists of 16 bits, and contains up to 65,536 child hats.\\n     *\\n     * A uint256 contains 4 bytes of space for tophat addresses, giving room for ((256 -\\n     * 32) / 16) = 14 levels of delegation, with the admin at each level having space for\\n     * 65,536 different child hats.\\n     *\\n     * A hat tree consists of a single tophat and has a max depth of 14 levels.\\n     */\\n\\n    /// @dev Number of bits of address space for tophat ids, ie the tophat domain\\n    uint256 internal constant TOPHAT_ADDRESS_SPACE = 32;\\n\\n    /// @dev Number of bits of address space for each level below the tophat\\n    uint256 internal constant LOWER_LEVEL_ADDRESS_SPACE = 16;\\n\\n    /// @dev Maximum number of levels below the tophat, ie max tree depth\\n    ///      (256 - TOPHAT_ADDRESS_SPACE) / LOWER_LEVEL_ADDRESS_SPACE;\\n    uint256 internal constant MAX_LEVELS = 14;\\n\\n    /// @notice Constructs a valid hat id for a new hat underneath a given admin\\n    /// @dev Reverts if the admin has already reached `MAX_LEVELS`\\n    /// @param _admin the id of the admin for the new hat\\n    /// @param _newHat the uint16 id of the new hat\\n    /// @return id The constructed hat id\\n    function buildHatId(uint256 _admin, uint16 _newHat) public pure returns (uint256 id) {\\n        uint256 mask;\\n        for (uint256 i = 0; i < MAX_LEVELS;) {\\n            unchecked {\\n                mask = uint256(\\n                    type(uint256).max\\n                    // should not overflow given known constants\\n                    >> (TOPHAT_ADDRESS_SPACE + (LOWER_LEVEL_ADDRESS_SPACE * i))\\n                );\\n            }\\n            if (_admin & mask == 0) {\\n                unchecked {\\n                    id = _admin\\n                        | (\\n                            uint256(_newHat)\\n                            // should not overflow given known constants\\n                            << (LOWER_LEVEL_ADDRESS_SPACE * (MAX_LEVELS - 1 - i))\\n                        );\\n                }\\n                return id;\\n            }\\n\\n            // should not overflow based on < MAX_LEVELS stopping condition\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // if _admin is already at MAX_LEVELS, child hats are not possible, so we revert\\n        revert MaxLevelsReached();\\n    }\\n\\n    /// @notice Identifies the level a given hat in its hat tree\\n    /// @param _hatId the id of the hat in question\\n    /// @return level (0 to type(uint32).max)\\n    function getHatLevel(uint256 _hatId) public view returns (uint32 level) {\\n        // uint256 mask;\\n        // uint256 i;\\n        level = getLocalHatLevel(_hatId);\\n\\n        uint256 treeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\\n\\n        if (treeAdmin != 0) {\\n            level = 1 + level + getHatLevel(treeAdmin);\\n        }\\n    }\\n\\n    /// @notice Identifies the level a given hat in its local hat tree\\n    /// @dev Similar to getHatLevel, but does not account for linked trees\\n    /// @param _hatId the id of the hat in question\\n    /// @return level The local level, from 0 to 14\\n    function getLocalHatLevel(uint256 _hatId) public pure returns (uint32 level) {\\n        if (_hatId & uint256(type(uint224).max) == 0) return 0;\\n        if (_hatId & uint256(type(uint208).max) == 0) return 1;\\n        if (_hatId & uint256(type(uint192).max) == 0) return 2;\\n        if (_hatId & uint256(type(uint176).max) == 0) return 3;\\n        if (_hatId & uint256(type(uint160).max) == 0) return 4;\\n        if (_hatId & uint256(type(uint144).max) == 0) return 5;\\n        if (_hatId & uint256(type(uint128).max) == 0) return 6;\\n        if (_hatId & uint256(type(uint112).max) == 0) return 7;\\n        if (_hatId & uint256(type(uint96).max) == 0) return 8;\\n        if (_hatId & uint256(type(uint80).max) == 0) return 9;\\n        if (_hatId & uint256(type(uint64).max) == 0) return 10;\\n        if (_hatId & uint256(type(uint48).max) == 0) return 11;\\n        if (_hatId & uint256(type(uint32).max) == 0) return 12;\\n        if (_hatId & uint256(type(uint16).max) == 0) return 13;\\n        return 14;\\n    }\\n\\n    /// @notice Checks whether a hat is a topHat\\n    /// @param _hatId The hat in question\\n    /// @return _isTopHat Whether the hat is a topHat\\n    function isTopHat(uint256 _hatId) public view returns (bool _isTopHat) {\\n        _isTopHat = isLocalTopHat(_hatId) && linkedTreeAdmins[getTopHatDomain(_hatId)] == 0;\\n    }\\n\\n    /// @notice Checks whether a hat is a topHat in its local hat tree\\n    /// @dev Similar to isTopHat, but does not account for linked trees\\n    /// @param _hatId The hat in question\\n    /// @return _isLocalTopHat Whether the hat is a topHat for its local tree\\n    function isLocalTopHat(uint256 _hatId) public pure returns (bool _isLocalTopHat) {\\n        _isLocalTopHat = _hatId > 0 && uint224(_hatId) == 0;\\n    }\\n\\n    function isValidHatId(uint256 _hatId) public pure returns (bool validHatId) {\\n        // valid top hats are valid hats\\n        if (isLocalTopHat(_hatId)) return true;\\n\\n        uint32 level = getLocalHatLevel(_hatId);\\n        uint256 admin;\\n        // for each subsequent level up the tree, check if the level is 0 and return false if so\\n        for (uint256 i = level - 1; i > 0;) {\\n            // truncate to find the (truncated) admin at this level\\n            // we don't need to check _hatId's own level since getLocalHatLevel already ensures that its non-empty\\n            admin = _hatId >> (LOWER_LEVEL_ADDRESS_SPACE * (MAX_LEVELS - i));\\n            // if the lowest level of the truncated admin is empty, the hat id is invalid\\n            if (uint16(admin) == 0) return false;\\n\\n            unchecked {\\n                --i;\\n            }\\n        }\\n        // if there are no empty levels, return true\\n        return true;\\n    }\\n\\n    /// @notice Gets the hat id of the admin at a given level of a given hat\\n    /// @dev This function traverses trees by following the linkedTreeAdmin\\n    ///       pointer to a hat located in a different tree\\n    /// @param _hatId the id of the hat in question\\n    /// @param _level the admin level of interest\\n    /// @return admin The hat id of the resulting admin\\n    function getAdminAtLevel(uint256 _hatId, uint32 _level) public view returns (uint256 admin) {\\n        uint256 linkedTreeAdmin = linkedTreeAdmins[getTopHatDomain(_hatId)];\\n        if (linkedTreeAdmin == 0) return admin = getAdminAtLocalLevel(_hatId, _level);\\n\\n        uint32 localTopHatLevel = getHatLevel(getAdminAtLocalLevel(_hatId, 0));\\n\\n        if (localTopHatLevel <= _level) return admin = getAdminAtLocalLevel(_hatId, _level - localTopHatLevel);\\n\\n        return admin = getAdminAtLevel(linkedTreeAdmin, _level);\\n    }\\n\\n    /// @notice Gets the hat id of the admin at a given level of a given hat\\n    ///         local to the tree containing the hat.\\n    /// @param _hatId the id of the hat in question\\n    /// @param _level the admin level of interest\\n    /// @return admin The hat id of the resulting admin\\n    function getAdminAtLocalLevel(uint256 _hatId, uint32 _level) public pure returns (uint256 admin) {\\n        uint256 mask = type(uint256).max << (LOWER_LEVEL_ADDRESS_SPACE * (MAX_LEVELS - _level));\\n\\n        admin = _hatId & mask;\\n    }\\n\\n    /// @notice Gets the tophat domain of a given hat\\n    /// @dev A domain is the identifier for a given hat tree, stored in the first 4 bytes of a hat's id\\n    /// @param _hatId the id of the hat in question\\n    /// @return domain The domain of the hat's tophat\\n    function getTopHatDomain(uint256 _hatId) public pure returns (uint32 domain) {\\n        domain = uint32(_hatId >> (LOWER_LEVEL_ADDRESS_SPACE * MAX_LEVELS));\\n    }\\n\\n    /// @notice Gets the domain of the highest parent tophat \u2014 the \\\"tippy tophat\\\"\\n    /// @param _topHatDomain the 32 bit domain of a (likely linked) tophat\\n    /// @return domain The tippy tophat domain\\n    function getTippyTopHatDomain(uint32 _topHatDomain) public view returns (uint32 domain) {\\n        uint256 linkedAdmin = linkedTreeAdmins[_topHatDomain];\\n        if (linkedAdmin == 0) return domain = _topHatDomain;\\n        return domain = getTippyTopHatDomain(getTopHatDomain(linkedAdmin));\\n    }\\n\\n    /// @notice Checks For any circular linkage of trees\\n    /// @param _topHatDomain the 32 bit domain of the tree to be linked\\n    /// @param _linkedAdmin the hatId of the potential tree admin\\n    /// @return notCircular circular link has not been found\\n    function noCircularLinkage(uint32 _topHatDomain, uint256 _linkedAdmin) public view returns (bool notCircular) {\\n        if (_linkedAdmin == 0) return true;\\n        uint32 adminDomain = getTopHatDomain(_linkedAdmin);\\n        if (_topHatDomain == adminDomain) return false;\\n        uint256 parentAdmin = linkedTreeAdmins[adminDomain];\\n        return noCircularLinkage(_topHatDomain, parentAdmin);\\n    }\\n\\n    /// @notice Checks that a tophat domain and its potential linked admin are from the same tree, ie have the same tippy tophat domain\\n    /// @param _topHatDomain The 32 bit domain of the tophat to be linked\\n    /// @param _newAdminHat The new admin for the linked tree\\n    /// @return sameDomain Whether the _topHatDomain and the domain of its potential linked _newAdminHat domains are the same\\n    function sameTippyTopHatDomain(uint32 _topHatDomain, uint256 _newAdminHat) public view returns (bool sameDomain) {\\n        // get highest parent domains for current and new tree root admins\\n        uint32 currentTippyTophatDomain = getTippyTopHatDomain(_topHatDomain);\\n        uint32 newAdminDomain = getTopHatDomain(_newAdminHat);\\n        uint32 newHTippyTophatDomain = getTippyTopHatDomain(newAdminDomain);\\n\\n        // check that both domains are equal\\n        sameDomain = (currentTippyTophatDomain == newHTippyTophatDomain);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Interfaces/IHatsToggle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// Copyright (C) 2023 Haberdasher Labs\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.13;\\n\\ninterface IHatsToggle {\\n    function getHatStatus(uint256 _hatId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/Interfaces/IHatsEligibility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// Copyright (C) 2023 Haberdasher Labs\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.13;\\n\\ninterface IHatsEligibility {\\n    /// @notice Returns the status of a wearer for a given hat\\n    /// @dev If standing is false, eligibility MUST also be false\\n    /// @param _wearer The address of the current or prospective Hat wearer\\n    /// @param _hatId The id of the hat in question\\n    /// @return eligible Whether the _wearer is eligible to wear the hat\\n    /// @return standing Whether the _wearer is in goog standing\\n    function getWearerStatus(address _wearer, uint256 _hatId) external view returns (bool eligible, bool standing);\\n}\\n\"\r\n    },\r\n    \"lib/solbase/src/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode and decode strings in Base64.\\n/// @author SolDAO (https://github.com/Sol-DAO/solbase/blob/main/src/utils/Base64.sol)\\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(bytes memory data, bool fileSafe, bool noPadding) internal pure returns (string memory result) {\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(0x3f, sub(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0230)))\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                // Run over the input, 3 bytes at a time.\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\\n                    \\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    // prettier-ignore\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n\\n                let r := mod(dataLength, 3)\\n\\n                switch noPadding\\n                case 0 {\\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n                    // Write the length of the string.\\n                    mstore(result, encodedLength)\\n                }\\n                default {\\n                    // Write the length of the string.\\n                    mstore(result, sub(encodedLength, add(iszero(iszero(r)), eq(r, 1))))\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(end, 31), not(31)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe) internal pure returns (string memory result) {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Decodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let end := add(data, dataLength)\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                switch and(dataLength, 3)\\n                case 0 {\\n                    // If padded.\\n                    decodedLength := sub(\\n                        decodedLength,\\n                        add(eq(and(mload(end), 0xFF), 0x3d), eq(and(mload(end), 0xFFFF), 0x3d3d))\\n                    )\\n                }\\n                default {\\n                    // If non-padded.\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\n                }\\n\\n                result := mload(0x40)\\n\\n                // Write the length of the string.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n\\n                    ptr := add(ptr, 3)\\n                    \\n                    // prettier-ignore\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 32 + 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\\n\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solbase/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author SolDAO (https://github.com/Sol-DAO/solbase/blob/main/src/utils/LibString.sol)\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constants\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = uint256(int256(-1));\\n\\n    /// -----------------------------------------------------------------------\\n    /// Decimal Operations\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Hexadecimal Operations\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for {} 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                length := sub(length, 1)\\n                // prettier-ignore\\n                if iszero(length) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := add(sub(end, str), 2)\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 0x20)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            let m := add(start, 0xa0)\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := add(sub(end, str), 2)\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 0x20)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the length, 0x02 bytes for the prefix,\\n            // and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x02 + 0x28) is 0x60.\\n            str := add(start, 0x60)\\n\\n            // Allocate the memory.\\n            mstore(0x40, str)\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let length := 20\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                length := sub(length, 1)\\n                // prettier-ignore\\n                if iszero(length) { break }\\n            }\\n\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 32)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, 42)\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Other String Operations\\n    /// -----------------------------------------------------------------------\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurances of `search` replaced with `replacement`.\\n    function replace(\\n        string memory subject,\\n        string memory search,\\n        string memory replacement\\n    ) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) {\\n                    h := keccak256(search, searchLength)\\n                }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of \\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                // prettier-ignore\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        // prettier-ignore\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            // prettier-ignore\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            // prettier-ignore\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            // prettier-ignore\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            // Zeroize the slot after the string.\\n            let last := add(add(result, 0x20), k)\\n            mstore(last, 0)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n            // Store the length of the result.\\n            mstore(result, k)\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from) internal pure returns (uint256 result) {\\n        assembly {\\n            // prettier-ignore\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    // `result = min(from, subjectLength)`.\\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)    \\n                \\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(add(search, 0x20))\\n\\n                // prettier-ignore\\n                if iszero(lt(subject, subjectSearchEnd)) { break }\\n\\n                if iszero(lt(searchLength, 32)) {\\n                    // prettier-ignore\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        // prettier-ignore\\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\\n                    }\\n                    break\\n                }\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(\\n        string memory subject,\\n        string memory search,\\n        uint256 from\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            // prettier-ignore\\n            for {} 1 {} {\\n                let searchLength := mload(search)\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) {\\n                    from := fromMax\\n                }\\n                if iszero(mload(search)) {\\n                    result := from\\n                    break\\n                }\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\\n\\n                subject := add(add(subject, 0x20), from)\\n                // prettier-ignore\\n                if iszero(gt(subject, subjectSearchEnd)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                // prettier-ignore\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(subjectSearchEnd, 1))\\n                        break\\n                    }\\n                    subject := sub(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search) internal pure returns (bool result) {\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(keccak256(add(subject, 0x20), searchLength), keccak256(add(search, 0x20), searchLength))\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search) internal pure returns (bool result) {\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    // prettier-ignore\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        // prettier-ignore\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    // prettier-ignore\\n                    if iszero(times) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(output, 0)\\n                // Store the length.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) {\\n                end := subjectLength\\n            }\\n            if iszero(gt(subjectLength, start)) {\\n                start := subjectLength\\n            }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                // Copy the `subject` one word at a time, backwards.\\n                // prettier-ignore\\n                for { let o := and(add(resultLength, 31), not(31)) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := sub(o, 0x20)\\n                    // prettier-ignore\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start) internal pure returns (string memory result) {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search) internal pure returns (uint256[] memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) {\\n                    h := keccak256(search, searchLength)\\n                }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of \\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                // prettier-ignore\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            // prettier-ignore\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter) internal pure returns (string[] memory result) {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        assembly {\\n            if mload(indices) {\\n                let indexPtr := add(indices, 0x20)\\n                let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n                mstore(sub(indicesEnd, 0x20), mload(subject))\\n                mstore(indices, add(mload(indices), 1))\\n                let prevIndex := 0\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let index := mload(indexPtr)\\n                    mstore(indexPtr, 0x60)                        \\n                    if iszero(eq(index, prevIndex)) {\\n                        let element := mload(0x40)\\n                        let elementLength := sub(index, prevIndex)\\n                        mstore(element, elementLength)\\n                        // Copy the `subject` one word at a time, backwards.\\n                        // prettier-ignore\\n                        for { let o := and(add(elementLength, 31), not(31)) } 1 {} {\\n                            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                            o := sub(o, 0x20)\\n                            // prettier-ignore\\n                            if iszero(o) { break }\\n                        }\\n                        // Zeroize the slot after the string.\\n                        mstore(add(add(element, 0x20), elementLength), 0)\\n                        // Allocate memory for the length and the bytes,\\n                        // rounded up to a multiple of 32.\\n                        mstore(0x40, add(element, and(add(elementLength, 63), not(31))))\\n                        // Store the `element` into the array.\\n                        mstore(indexPtr, element)                        \\n                    }\\n                    prevIndex := add(index, mload(delimiter))\\n                    indexPtr := add(indexPtr, 0x20)\\n                    // prettier-ignore\\n                    if iszero(lt(indexPtr, indicesEnd)) { break }\\n                }\\n                result := indices\\n                if iszero(mload(delimiter)) {\\n                    result := add(indices, 0x20)\\n                    mstore(result, sub(mload(indices), 2))\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b) internal pure returns (string memory result) {\\n        assembly {\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            // prettier-ignore\\n            for { let o := and(add(mload(a), 32), not(31)) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := sub(o, 0x20)\\n                // prettier-ignore\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, mload(a))\\n            // Copy `b` one word at a time, backwards.\\n            // prettier-ignore\\n            for { let o := and(add(bLength, 32), not(31)) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := sub(o, 0x20)\\n                // prettier-ignore\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result := mul(\\n                // Load the length and the bytes.\\n                mload(add(a, 0x1f)),\\n                // `length != 0 && length < 32`. Abuses underflow.\\n                // Assumes that the length is valid and within the block gas limit.\\n                lt(sub(mload(a), 1), 0x1f)\\n            )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result := mul(\\n                // Load the length and the bytes of `a` and `b`.\\n                or(shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))), mload(sub(add(b, 0x1e), aLength))),\\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                // Assumes that the lengths are valid and within the block gas limit.\\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n            )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\\n    function unpackTwo(bytes32 packed) internal pure returns (string memory resultA, string memory resultB) {\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(add(a, 0x20), mload(a)), 0)\\n            // Store the return offset.\\n            // Assumes that the string does not start from the scratch space.\\n            mstore(sub(a, 0x20), 0x20)\\n            // End the transaction, returning the string.\\n            return(sub(a, 0x20), add(mload(a), 0x40))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/Multicallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Contract that enables a single call to call multiple methods on itself.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Multicallable.sol)\\nabstract contract Multicallable {\\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\\n    /// If any of the `DELEGATECALL`s reverts, the entire context is reverted,\\n    /// and the error is bubbled up.\\n    ///\\n    /// This function is deliberately made non-payable to guard against double-spending.\\n    /// (See: https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong)\\n    ///\\n    /// For efficiency, this function will directly return the results, terminating the context.\\n    /// If called internally, it must be called at the end of a function\\n    /// that returns `(bytes[] memory)`.\\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory) {\\n        assembly {\\n            mstore(0x00, 0x20)\\n            mstore(0x20, data.length) // Store `data.length` into `results`.\\n            // Early return if no data.\\n            if iszero(data.length) { return(0x00, 0x40) }\\n\\n            let results := 0x40\\n            // `shl` 5 is equivalent to multiplying by 0x20.\\n            let end := shl(5, data.length)\\n            // Copy the offsets from calldata into memory.\\n            calldatacopy(0x40, data.offset, end)\\n            // Offset into `results`.\\n            let resultsOffset := end\\n            // Pointer to the end of `results`.\\n            end := add(results, end)\\n\\n            for {} 1 {} {\\n                // The offset of the current bytes in the calldata.\\n                let o := add(data.offset, mload(results))\\n                let memPtr := add(resultsOffset, 0x40)\\n                // Copy the current bytes from calldata to the memory.\\n                calldatacopy(\\n                    memPtr,\\n                    add(o, 0x20), // The offset of the current bytes' bytes.\\n                    calldataload(o) // The length of the current bytes.\\n                )\\n                if iszero(delegatecall(gas(), address(), memPtr, calldataload(o), 0x00, 0x00)) {\\n                    // Bubble up the revert if the delegatecall reverts.\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n                // Append the current `resultsOffset` into `results`.\\n                mstore(results, resultsOffset)\\n                results := add(results, 0x20)\\n                // Append the `returndatasize()`, and the return data.\\n                mstore(memPtr, returndatasize())\\n                returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\\n                // Advance the `resultsOffset` by `returndatasize() + 0x20`,\\n                // rounded up to the next multiple of 32.\\n                resultsOffset :=\\n                    and(add(add(resultsOffset, returndatasize()), 0x3f), 0xffffffffffffffe0)\\n                if iszero(lt(results, end)) { break }\\n            }\\n            return(0x00, add(resultsOffset, 0x40))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Interfaces/IHatsIdUtilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// Copyright (C) 2023 Haberdasher Labs\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.13;\\n\\ninterface IHatsIdUtilities {\\n    function buildHatId(uint256 _admin, uint16 _newHat) external pure returns (uint256 id);\\n\\n    function getHatLevel(uint256 _hatId) external view returns (uint32 level);\\n\\n    function getLocalHatLevel(uint256 _hatId) external pure returns (uint32 level);\\n\\n    function isTopHat(uint256 _hatId) external view returns (bool _topHat);\\n\\n    function isLocalTopHat(uint256 _hatId) external pure returns (bool _localTopHat);\\n\\n    function isValidHatId(uint256 _hatId) external view returns (bool validHatId);\\n\\n    function getAdminAtLevel(uint256 _hatId, uint32 _level) external view returns (uint256 admin);\\n\\n    function getAdminAtLocalLevel(uint256 _hatId, uint32 _level) external pure returns (uint256 admin);\\n\\n    function getTopHatDomain(uint256 _hatId) external view returns (uint32 domain);\\n\\n    function getTippyTopHatDomain(uint32 _topHatDomain) external view returns (uint32 domain);\\n\\n    function noCircularLinkage(uint32 _topHatDomain, uint256 _linkedAdmin) external view returns (bool notCircular);\\n\\n    function sameTippyTopHatDomain(uint32 _topHatDomain, uint256 _newAdminHat)\\n        external\\n        view\\n        returns (bool sameDomain);\\n}\\n\"\r\n    },\r\n    \"src/Interfaces/HatsErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// Copyright (C) 2023 Haberdasher Labs\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.13;\\n\\ninterface HatsErrors {\\n    /// @notice Emitted when `user` is attempting to perform an action on `hatId` but is not wearing one of `hatId`'s admin hats\\n    /// @dev Can be equivalent to `NotHatWearer(buildHatId(hatId))`, such as when emitted by `approveLinkTopHatToTree` or `relinkTopHatToTree`\\n    error NotAdmin(address user, uint256 hatId);\\n\\n    /// @notice Emitted when attempting to perform an action as or for an account that is not a wearer of a given hat\\n    error NotHatWearer();\\n\\n    /// @notice Emitted when attempting to perform an action that requires being either an admin or wearer of a given hat\\n    error NotAdminOrWearer();\\n\\n    /// @notice Emitted when attempting to mint `hatId` but `hatId`'s maxSupply has been reached\\n    error AllHatsWorn(uint256 hatId);\\n\\n    /// @notice Emitted when attempting to create a hat with a level 14 hat as its admin\\n    error MaxLevelsReached();\\n\\n    /// @notice Emitted when an attempted hat id has empty intermediate level(s)\\n    error InvalidHatId();\\n\\n    /// @notice Emitted when attempting to mint `hatId` to a `wearer` who is already wearing the hat\\n    error AlreadyWearingHat(address wearer, uint256 hatId);\\n\\n    /// @notice Emitted when attempting to mint a non-existant hat\\n    error HatDoesNotExist(uint256 hatId);\\n\\n    /// @notice Emmitted when attempting to mint or transfer a hat that is not active\\n    error HatNotActive();\\n\\n    /// @notice Emitted when attempting to mint or transfer a hat to an ineligible wearer\\n    error NotEligible();\\n\\n    /// @notice Emitted when attempting to check or set a hat's status from an account that is not that hat's toggle module\\n    error NotHatsToggle();\\n\\n    /// @notice Emitted when attempting to check or set a hat wearer's status from an account that is not that hat's eligibility module\\n    error NotHatsEligibility();\\n\\n    /// @notice Emitted when array arguments to a batch function have mismatching lengths\\n    error BatchArrayLengthMismatch();\\n\\n    /// @notice Emitted when attempting to mutate or transfer an immutable hat\\n    error Immutable();\\n\\n    /// @notice Emitted when attempting to change a hat's maxSupply to a value lower than its current supply\\n    error NewMaxSupplyTooLow();\\n\\n    /// @notice Emitted when attempting to link a tophat to a new admin for which the tophat serves as an admin\\n    error CircularLinkage();\\n\\n    /// @notice Emitted when attempting to link or relink a tophat to a separate tree\\n    error CrossTreeLinkage();\\n\\n    /// @notice Emitted when attempting to link a tophat without a request\\n    error LinkageNotRequested();\\n\\n    /// @notice Emitted when attempting to unlink a tophat that does not have a wearer\\n    /// @dev This ensures that unlinking never results in a bricked tophat\\n    error InvalidUnlink();\\n\\n    /// @notice Emmited when attempting to change a hat's eligibility or toggle module to the zero address\\n    error ZeroAddress();\\n\\n    /// @notice Emmitted when attempting to change a hat's details or imageURI to a string with over 7000 bytes (~characters)\\n    /// @dev This protects against a DOS attack where an admin iteratively extend's a hat's details or imageURI\\n    ///      to be so long that reading it exceeds the block gas limit, breaking `uri()` and `viewHat()`\\n    error StringTooLong();\\n}\\n\"\r\n    },\r\n    \"src/Interfaces/HatsEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// Copyright (C) 2023 Haberdasher Labs\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.13;\\n\\ninterface HatsEvents {\\n    /// @notice Emitted when a new hat is created\\n    /// @param id The id for the new hat\\n    /// @param details A description of the Hat\\n    /// @param maxSupply The total instances of the Hat that can be worn at once\\n    /// @param eligibility The address that can report on the Hat wearer's status\\n    /// @param toggle The address that can deactivate the Hat\\n    /// @param mutable_ Whether the hat's properties are changeable after creation\\n    /// @param imageURI The image uri for this hat and the fallback for its\\n    event HatCreated(\\n        uint256 id,\\n        string details,\\n        uint32 maxSupply,\\n        address eligibility,\\n        address toggle,\\n        bool mutable_,\\n        string imageURI\\n    );\\n\\n    /// @notice Emitted when a hat wearer's standing is updated\\n    /// @dev Eligibility is excluded since the source of truth for eligibility is the eligibility module and may change without a transaction\\n    /// @param hatId The id of the wearer's hat\\n    /// @param wearer The wearer's address\\n    /// @param wearerStanding Whether the wearer is in good standing for the hat\\n    event WearerStandingChanged(uint256 hatId, address wearer, bool wearerStanding);\\n\\n    /// @notice Emitted when a hat's status is updated\\n    /// @param hatId The id of the hat\\n    /// @param newStatus Whether the hat is active\\n    event HatStatusChanged(uint256 hatId, bool newStatus);\\n\\n    /// @notice Emitted when a hat's details are updated\\n    /// @param hatId The id of the hat\\n    /// @param newDetails The updated details\\n    event HatDetailsChanged(uint256 hatId, string newDetails);\\n\\n    /// @notice Emitted when a hat's eligibility module is updated\\n    /// @param hatId The id of the hat\\n    /// @param newEligibility The updated eligibiliy module\\n    event HatEligibilityChanged(uint256 hatId, address newEligibility);\\n\\n    /// @notice Emitted when a hat's toggle module is updated\\n    /// @param hatId The id of the hat\\n    /// @param newToggle The updated toggle module\\n    event HatToggleChanged(uint256 hatId, address newToggle);\\n\\n    /// @notice Emitted when a hat's mutability is updated\\n    /// @param hatId The id of the hat\\n    event HatMutabilityChanged(uint256 hatId);\\n\\n    /// @notice Emitted when a hat's maximum supply is updated\\n    /// @param hatId The id of the hat\\n    /// @param newMaxSupply The updated max supply\\n    event HatMaxSupplyChanged(uint256 hatId, uint32 newMaxSupply);\\n\\n    /// @notice Emitted when a hat's image URI is updated\\n    /// @param hatId The id of the hat\\n    /// @param newImageURI The updated image URI\\n    event HatImageURIChanged(uint256 hatId, string newImageURI);\\n\\n    /// @notice Emitted when a tophat linkage is requested by its admin\\n    /// @param domain The domain of the tree tophat to link\\n    /// @param newAdmin The tophat's would-be admin in the parent tree\\n    event TopHatLinkRequested(uint32 domain, uint256 newAdmin);\\n\\n    /// @notice Emitted when a tophat is linked to a another tree\\n    /// @param domain The domain of the newly-linked tophat\\n    /// @param newAdmin The tophat's new admin in the parent tree\\n    event TopHatLinked(uint32 domain, uint256 newAdmin);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ERC1155/=lib/ERC1155/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solbase/=lib/solbase/src/\",\r\n      \"utils/=lib/utils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_baseImageURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"}],\"name\":\"AllHatsWorn\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wearer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"}],\"name\":\"AlreadyWearingHat\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BatchArrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CircularLinkage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CrossTreeLinkage\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"}],\"name\":\"HatDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HatNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Immutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHatId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUnlink\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkageNotRequested\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxLevelsReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxLevelsReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewMaxSupplyTooLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"}],\"name\":\"NotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAdminOrWearer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEligible\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotHatWearer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotHatsEligibility\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotHatsToggle\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"maxSupply\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"eligibility\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toggle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"mutable_\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"imageURI\",\"type\":\"string\"}],\"name\":\"HatCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newDetails\",\"type\":\"string\"}],\"name\":\"HatDetailsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newEligibility\",\"type\":\"address\"}],\"name\":\"HatEligibilityChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newImageURI\",\"type\":\"string\"}],\"name\":\"HatImageURIChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newMaxSupply\",\"type\":\"uint32\"}],\"name\":\"HatMaxSupplyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"}],\"name\":\"HatMutabilityChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"HatStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newToggle\",\"type\":\"address\"}],\"name\":\"HatToggleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdmin\",\"type\":\"uint256\"}],\"name\":\"TopHatLinkRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdmin\",\"type\":\"uint256\"}],\"name\":\"TopHatLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wearer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wearerStanding\",\"type\":\"bool\"}],\"name\":\"WearerStandingChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_topHatDomain\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_newAdminHat\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_eligibility\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toggle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_details\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_imageURI\",\"type\":\"string\"}],\"name\":\"approveLinkTopHatToTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"badStandings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wearer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_wearers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_hatIds\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseImageURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_admins\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"_details\",\"type\":\"string[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_maxSupplies\",\"type\":\"uint32[]\"},{\"internalType\":\"address[]\",\"name\":\"_eligibilityModules\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_toggleModules\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_mutables\",\"type\":\"bool[]\"},{\"internalType\":\"string[]\",\"name\":\"_imageURIs\",\"type\":\"string[]\"}],\"name\":\"batchCreateHats\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_hatIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_wearers\",\"type\":\"address[]\"}],\"name\":\"batchMintHats\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_admin\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_newHat\",\"type\":\"uint16\"}],\"name\":\"buildHatId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_newDetails\",\"type\":\"string\"}],\"name\":\"changeHatDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_newEligibility\",\"type\":\"address\"}],\"name\":\"changeHatEligibility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_newImageURI\",\"type\":\"string\"}],\"name\":\"changeHatImageURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_newMaxSupply\",\"type\":\"uint32\"}],\"name\":\"changeHatMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_newToggle\",\"type\":\"address\"}],\"name\":\"changeHatToggle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"checkHatStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"toggled\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wearer\",\"type\":\"address\"}],\"name\":\"checkHatWearerStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"updated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_admin\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_details\",\"type\":\"string\"},{\"internalType\":\"uint32\",\"name\":\"_maxSupply\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_eligibility\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toggle\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_mutable\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"_imageURI\",\"type\":\"string\"}],\"name\":\"createHat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newHatId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_level\",\"type\":\"uint32\"}],\"name\":\"getAdminAtLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"admin\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_level\",\"type\":\"uint32\"}],\"name\":\"getAdminAtLocalLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"admin\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"getHatEligibilityModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"eligibility\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"getHatLevel\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"getHatMaxSupply\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"maxSupply\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"getHatToggleModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"toggle\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"getImageURIForHat\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"getLocalHatLevel\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"level\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_admin\",\"type\":\"uint256\"}],\"name\":\"getNextId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_topHatDomain\",\"type\":\"uint32\"}],\"name\":\"getTippyTopHatDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"getTopHatDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"hatSupply\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"supply\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"isAdminOfHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isAdmin\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wearer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"isEligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"eligible\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wearer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"isInGoodStanding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"standing\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"isLocalTopHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isLocalTopHat\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"isTopHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isTopHat\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"isValidHatId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"validHatId\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"isWearerOfHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isWearer\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTopHatId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"linkedTreeAdmins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"linkedTreeRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"makeHatImmutable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wearer\",\"type\":\"address\"}],\"name\":\"mintHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_details\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_imageURI\",\"type\":\"string\"}],\"name\":\"mintTopHat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"topHatId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_topHatDomain\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_linkedAdmin\",\"type\":\"uint256\"}],\"name\":\"noCircularLinkage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"notCircular\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_topHatDomain\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_newAdminHat\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_eligibility\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toggle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_details\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_imageURI\",\"type\":\"string\"}],\"name\":\"relinkTopHatWithinTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"renounceHat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_topHatDomain\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_requestedAdminHat\",\"type\":\"uint256\"}],\"name\":\"requestLinkTopHatToTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_topHatDomain\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_newAdminHat\",\"type\":\"uint256\"}],\"name\":\"sameTippyTopHatDomain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"sameDomain\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_newStatus\",\"type\":\"bool\"}],\"name\":\"setHatStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"toggled\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wearer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_eligible\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_standing\",\"type\":\"bool\"}],\"name\":\"setHatWearerStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"updated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferHat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_topHatDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_wearer\",\"type\":\"address\"}],\"name\":\"unlinkTopHatFromTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hatId\",\"type\":\"uint256\"}],\"name\":\"viewHat\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"},{\"internalType\":\"uint32\",\"name\":\"maxSupply\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"supply\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"eligibility\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toggle\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"imageURI\",\"type\":\"string\"},{\"internalType\":\"uint16\",\"name\":\"lastHatId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"mutable_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Hats", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000010486174732050726f746f636f6c207631000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000042697066733a2f2f6261666b726569666c657a706b336b6a7a367a737632337062766f777461746e6435686d71666b64726f333378356d6832617a6c686e6533616834000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}