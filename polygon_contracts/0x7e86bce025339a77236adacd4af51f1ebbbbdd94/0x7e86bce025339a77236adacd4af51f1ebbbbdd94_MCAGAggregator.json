{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts-verify/interfaces/MCAGAggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\ninterface MCAGAggregatorInterface {\\n    event AccessControllerSet(address accesController);\\n    event AnswerTransmitted(address indexed transmitter, uint80 roundId, int256 answer);\\n    event MaxAnswerSet(int256 oldMaxAnswer, int256 newMaxAnswer);\\n    event VolatilityThresholdSet(uint256 oldVolatilityThreshold, uint256 newVolatilityThreshold);\\n    event TermSet(uint256 term);\\n\\n    function transmit(int256 answer) external;\\n\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function maxAnswer() external view returns (int256);\\n\\n    function getVolatilityThreshold() external view returns (uint256);\\n\\n    function version() external view returns (uint8);\\n\\n    function getTerm() external view returns (uint256);\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\"\r\n    },\r\n    \"contracts-verify/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary Errors {\\n    error CANNOT_SET_TO_ADDRESS_ZERO();\\n    error ERC721_APPROVAL_TO_CURRENT_OWNER();\\n    error ERC721_APPROVE_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED_FOR_ALL();\\n    error ERC721_INVALID_TOKEN_ID();\\n    error ERC721_CALLER_IS_NOT_TOKEN_OWNER();\\n    error ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE(address account, bytes32 role);\\n    error BLACKLIST_CALLER_IS_NOT_BLACKLISTER();\\n    error BLACKLIST_ACCOUNT_IS_NOT_BLACKLISTED(address account);\\n    error BLACKLIST_ACCOUNT_IS_BLACKLISTED(address account);\\n    error TRANSMITTED_ANSWER_TOO_HIGH(int256 answer, int256 maxAnswer);\\n    error TRANSMITTED_ANSWER_TOO_LOW(int256 answer, int256 minAnswer);\\n    error TOKEN_IS_NOT_TRANSFERABLE();\\n    error KYC_DATA_OWNER_MISMATCH(address to, address owner);\\n    error RATE_TOO_VOLATILE(uint256 absoluteRateChange, uint256 volatilityThreshold);\\n    error INVALID_VOLATILITY_THRESHOLD();\\n    error TERMS_AND_CONDITIONS_URL_DOES_NOT_EXIST(uint256 tncId);\\n    error TERM_TOO_LOW(uint256 term, uint256 minTerm);\\n    error RISK_CATEGORY_MISMATCH(bytes4 currency, bytes32 name, uint64 term, bytes32 riskCategory);\\n    error MATURITY_LESS_THAN_ISSUANCE(uint64 maturity, uint64 issuance);\\n    error INVALID_RISK_CATEGORY();\\n    error EMPTY_CUSIP_AND_ISIN();\\n    error INVALID_MAX_COUPON();\\n    error INVALID_COUPON(uint256 coupon, uint256 minCoupon, uint256 maxCoupon);\\n    error ANSWER_VARIATION_TOO_HIGH();\\n    error CANNOT_SET_NEGATIVE_MAX_ANSWER();\\n    error MAX_ANSWER_TOO_LOW(int256 maxAnswer, int256 minAnswer);\\n}\\n\"\r\n    },\r\n    \"contracts-verify/libraries/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary Roles {\\n    bytes32 public constant MCAG_MINT_ROLE = keccak256(\\\"MCAG_MINT_ROLE\\\");\\n    bytes32 public constant MCAG_BURN_ROLE = keccak256(\\\"MCAG_BURN_ROLE\\\");\\n    bytes32 public constant MCAG_BLACKLIST_ROLE = keccak256(\\\"MCAG_BLACKLIST_ROLE\\\");\\n    bytes32 public constant MCAG_PAUSE_ROLE = keccak256(\\\"MCAG_PAUSE_ROLE\\\");\\n    bytes32 public constant MCAG_UNPAUSE_ROLE = keccak256(\\\"MCAG_UNPAUSE_ROLE\\\");\\n    bytes32 public constant MCAG_TRANSMITTER_ROLE = keccak256(\\\"MCAG_TRANSMITTER_ROLE\\\");\\n    bytes32 public constant MCAG_MANAGER_ROLE = keccak256(\\\"MCAG_MANAGER_ROLE\\\");\\n    bytes32 public constant MCAG_SET_URI_ROLE = keccak256(\\\"MCAG_SET_URI_ROLE\\\");\\n    bytes32 public constant MCAG_SET_TNC_ROLE = keccak256(\\\"MCAG_SET_TNC_ROLE\\\");\\n    bytes32 public constant MCAG_SET_MAX_COUPON_ROLE = keccak256(\\\"MCAG_SET_MAX_COUPON_ROLE\\\");\\n}\\n\"\r\n    },\r\n    \"contracts-verify/libraries/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @notice Provides functions to perform calculations with Wad and Ray units\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\\n * with 27 digits of precision)\\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\\n *\\n */\\nlibrary WadRayMath {\\n    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant HALF_WAD = 0.5e18;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant HALF_RAY = 0.5e27;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a*b, in wad\\n     *\\n     */\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\\n        assembly {\\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) { revert(0, 0) }\\n\\n            c := div(add(mul(a, b), HALF_WAD), WAD)\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @param b Wad\\n     * @return c = a/b, in wad\\n     *\\n     */\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\\n        assembly {\\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) { revert(0, 0) }\\n\\n            c := div(add(mul(a, WAD), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raymul b\\n     *\\n     */\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\\n        assembly {\\n            if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) { revert(0, 0) }\\n\\n            c := div(add(mul(a, b), HALF_RAY), RAY)\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides two ray, rounding half up to the nearest ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @param b Ray\\n     * @return c = a raydiv b\\n     *\\n     */\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\\n        assembly {\\n            if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) { revert(0, 0) }\\n\\n            c := div(add(mul(a, RAY), div(b, 2)), b)\\n        }\\n    }\\n\\n    /**\\n     * @dev Casts ray down to wad\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Ray\\n     * @return b = a converted to wad, rounded half up to the nearest wad\\n     *\\n     */\\n    function rayToWad(uint256 a) internal pure returns (uint256 b) {\\n        assembly {\\n            b := div(a, WAD_RAY_RATIO)\\n            let remainder := mod(a, WAD_RAY_RATIO)\\n            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) { b := add(b, 1) }\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts wad up to ray\\n     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\\n     * @param a Wad\\n     * @return b = a converted in ray\\n     *\\n     */\\n    function wadToRay(uint256 a) internal pure returns (uint256 b) {\\n        // to avoid overflow, b/WAD_RAY_RATIO == a\\n        assembly {\\n            b := mul(a, WAD_RAY_RATIO)\\n\\n            if iszero(eq(div(b, WAD_RAY_RATIO), a)) { revert(0, 0) }\\n        }\\n    }\\n\\n    /**\\n     * @dev calculates base^exp. The code uses the ModExp precompile\\n     * @return z base^exp, in ray\\n     *\\n     */\\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rayMul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rayMul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-verify/MCAGAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport {Errors} from \\\"./libraries/Errors.sol\\\";\\nimport {IAccessControl} from \\\"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\\\";\\nimport {MCAGAggregatorInterface} from \\\"./interfaces/MCAGAggregatorInterface.sol\\\";\\nimport {Roles} from \\\"./libraries/Roles.sol\\\";\\nimport {WadRayMath} from \\\"./libraries/WadRayMath.sol\\\";\\n\\n/**\\n * @title MCAG Aggregator\\n * @author MIMO Labs\\n * @notice MCAGAggregator contracts serve as an oracle for the MCAGRateFeed\\n */\\ncontract MCAGAggregator is MCAGAggregatorInterface {\\n    using WadRayMath for uint256;\\n\\n    int256 public constant MIN_MAX_ANSWER = 0;\\n    uint256 public constant MIN_TERM = 4 weeks;\\n\\n    uint8 private constant _VERSION = 1;\\n    uint8 private constant _DECIMALS = 27;\\n\\n    uint256 private immutable _term;\\n\\n    IAccessControl public immutable accessController;\\n\\n    uint80 private _roundId;\\n    string private _description;\\n    int256 private _answer;\\n    int256 private _maxAnswer;\\n    uint256 private _volatilityThreshold;\\n    uint256 private _updatedAt;\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the caller has a specific role\\n     * @param role The role required to call the function\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        if (!accessController.hasRole(role, msg.sender)) {\\n            revert Errors.ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE(msg.sender, role);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @param description_ Description of the oracle - for example \\\"10 YEAR US TREASURY\\\".\\n     * @param maxAnswer_ Maximum sensible answer the contract should accept during transmission\\n     * @param _accessController MCAG AccessController\\n     * @param answer Initial answer\\n     * @param volatilityThreshold Maximum absolute value change of the answer between two consecutive rounds.\\n     * @param term Term of the risk category in seconds.\\n     */\\n    constructor(\\n        string memory description_,\\n        int256 maxAnswer_,\\n        IAccessControl _accessController,\\n        int256 answer,\\n        uint256 volatilityThreshold,\\n        uint256 term\\n    ) {\\n        if (address(_accessController) == address(0)) {\\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\\n        }\\n        if (volatilityThreshold <= 0) {\\n            revert Errors.INVALID_VOLATILITY_THRESHOLD();\\n        }\\n        if (answer > maxAnswer_) {\\n            revert Errors.TRANSMITTED_ANSWER_TOO_HIGH(answer, maxAnswer_);\\n        }\\n        if (term < MIN_TERM) {\\n            revert Errors.TERM_TOO_LOW(term, MIN_TERM);\\n        }\\n        if (maxAnswer_ < 0) {\\n            revert Errors.MAX_ANSWER_TOO_LOW(maxAnswer_, MIN_MAX_ANSWER);\\n        }\\n\\n        _description = description_;\\n        _answer = answer;\\n        _maxAnswer = maxAnswer_;\\n        _volatilityThreshold = volatilityThreshold;\\n        _updatedAt = block.timestamp;\\n        _term = term;\\n        accessController = _accessController;\\n\\n        emit AccessControllerSet(address(_accessController));\\n        emit AnswerTransmitted(msg.sender, 0, answer);\\n        emit MaxAnswerSet(0, maxAnswer_);\\n        emit VolatilityThresholdSet(0, volatilityThreshold);\\n        emit TermSet(term);\\n    }\\n\\n    /**\\n     * @notice Transmits a new price to the aggreator and updates the answer, round id and updated at.\\n     * @dev Can only be called by a registered transmitter.\\n     * @param answer New central bank rate as a per second cumualtive rate in 27 decimals.\\n     * For example a 5% annual linear rate would be converted to a per second cumulative rate as follow :\\n     * (1 + 5%)^(1 / 31536000) * 1e27 = 100000000578137865680459171\\n     */\\n    function transmit(int256 answer) external onlyRole(Roles.MCAG_TRANSMITTER_ROLE) {\\n        if (answer > _maxAnswer) {\\n            revert Errors.TRANSMITTED_ANSWER_TOO_HIGH(answer, _maxAnswer);\\n        }\\n        if (answer < 0) {\\n            revert Errors.TRANSMITTED_ANSWER_TOO_LOW(answer, 0);\\n        }\\n\\n        int256 answer_ = _answer;\\n        uint256 oldAnswer = uint256(answer_);\\n        uint256 newAnswer = uint256(answer);\\n\\n        uint256 oldTotalLinearRate = oldAnswer.rayPow(_term);\\n        uint256 newTotalLinearRate = newAnswer.rayPow(_term);\\n\\n        uint256 absoluteRateChange;\\n\\n        if (newTotalLinearRate > oldTotalLinearRate) {\\n            absoluteRateChange = newTotalLinearRate - oldTotalLinearRate;\\n        } else {\\n            absoluteRateChange = oldTotalLinearRate - newTotalLinearRate;\\n        }\\n\\n        if (absoluteRateChange > _volatilityThreshold) {\\n            revert Errors.RATE_TOO_VOLATILE(absoluteRateChange, _volatilityThreshold);\\n        }\\n\\n        ++_roundId;\\n        _updatedAt = block.timestamp;\\n        _answer = answer;\\n\\n        emit AnswerTransmitted(msg.sender, _roundId, answer);\\n    }\\n\\n    /**\\n     * @notice Sets a new max answer.\\n     * @dev Can only be called by MCAG Manager.\\n     * @param newMaxAnswer New maximum sensible answer the contract should accept in RAY.\\n     */\\n    function setMaxAnswer(int256 newMaxAnswer) external onlyRole(Roles.MCAG_MANAGER_ROLE) {\\n        if (newMaxAnswer < 0) {\\n            revert Errors.MAX_ANSWER_TOO_LOW(newMaxAnswer, MIN_MAX_ANSWER);\\n        }\\n        emit MaxAnswerSet(_maxAnswer, newMaxAnswer);\\n        _maxAnswer = newMaxAnswer;\\n    }\\n\\n    /**\\n     * @notice Sets a new volatility threshold.\\n     * @dev Can only be called by MCAG Manager.\\n     * @param newVolatilityThreshold New maximum absolute value change of the answer between two consecutive rounds.\\n     */\\n    function setVolatilityThreshold(uint256 newVolatilityThreshold) external onlyRole(Roles.MCAG_MANAGER_ROLE) {\\n        if (newVolatilityThreshold == 0) {\\n            revert Errors.INVALID_VOLATILITY_THRESHOLD();\\n        }\\n        emit VolatilityThresholdSet(_volatilityThreshold, newVolatilityThreshold);\\n        _volatilityThreshold = newVolatilityThreshold;\\n    }\\n\\n    /**\\n     * @notice Returns round data per the Chainlink format.\\n     * @return roundId Latest _roundId.\\n     * @return answer Latest answer transmitted.\\n     * @return startedAt Unused variable here only to follow Chainlink format.\\n     * @return updatedAt Timestamp of the last transmitted answer.\\n     * @return answeredInRound Latest _roundId.\\n     */\\n    function latestRoundData()\\n        external\\n        view\\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\\n    {\\n        roundId = _roundId;\\n        answer = _answer;\\n        startedAt = _updatedAt;\\n        updatedAt = _updatedAt;\\n        answeredInRound = _roundId;\\n    }\\n\\n    /**\\n     * @return Description of the oracle - for example \\\"10 YEAR US TREASURY\\\".\\n     */\\n    function description() external view returns (string memory) {\\n        return _description;\\n    }\\n\\n    /**\\n     * @return Maximum sensible answer the contract should accept.\\n     */\\n    function maxAnswer() external view returns (int256) {\\n        return _maxAnswer;\\n    }\\n\\n    /**\\n     * @return Maximum absolute value change of the answer between two consecutive rounds.\\n     */\\n    function getVolatilityThreshold() external view returns (uint256) {\\n        return _volatilityThreshold;\\n    }\\n\\n    /**\\n     * @return The term of oracle asset in seconds. For example 364 days for 52 week t-bills.\\n     */\\n    function getTerm() external view returns (uint256) {\\n        return _term;\\n    }\\n\\n    /**\\n     * @return Number of decimals used to get its user representation.\\n     */\\n    function decimals() external pure returns (uint8) {\\n        return _DECIMALS;\\n    }\\n\\n    /**\\n     * @return Contract version.\\n     */\\n    function version() external pure returns (uint8) {\\n        return _VERSION;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"description_\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"maxAnswer_\",\"type\":\"int256\"},{\"internalType\":\"contract IAccessControl\",\"name\":\"_accessController\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"volatilityThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CANNOT_SET_TO_ADDRESS_ZERO\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_VOLATILITY_THRESHOLD\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"maxAnswer\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"minAnswer\",\"type\":\"int256\"}],\"name\":\"MAX_ANSWER_TOO_LOW\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"absoluteRateChange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatilityThreshold\",\"type\":\"uint256\"}],\"name\":\"RATE_TOO_VOLATILE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTerm\",\"type\":\"uint256\"}],\"name\":\"TERM_TOO_LOW\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"maxAnswer\",\"type\":\"int256\"}],\"name\":\"TRANSMITTED_ANSWER_TOO_HIGH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"minAnswer\",\"type\":\"int256\"}],\"name\":\"TRANSMITTED_ANSWER_TOO_LOW\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"accesController\",\"type\":\"address\"}],\"name\":\"AccessControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"}],\"name\":\"AnswerTransmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"oldMaxAnswer\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"newMaxAnswer\",\"type\":\"int256\"}],\"name\":\"MaxAnswerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"TermSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVolatilityThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVolatilityThreshold\",\"type\":\"uint256\"}],\"name\":\"VolatilityThresholdSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_MAX_ANSWER\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_TERM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessController\",\"outputs\":[{\"internalType\":\"contract IAccessControl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTerm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVolatilityThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"newMaxAnswer\",\"type\":\"int256\"}],\"name\":\"setMaxAnswer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVolatilityThreshold\",\"type\":\"uint256\"}],\"name\":\"setVolatilityThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"}],\"name\":\"transmit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "MCAGAggregator", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000033b2e3d15dbb2e60397ea70000000000000000000000000c7b973a97f171e964eb3a0949caafbfd1ed77c0d0000000000000000000000000000000000000000033b2e3cae978f21f1e0e54b00000000000000000000000000000000000000000018d0bf423c03d8de0000000000000000000000000000000000000000000000000000000000000001d6a780000000000000000000000000000000000000000000000000000000000000001b33353744204652205442494c4c2041646a757374656420526174650000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}