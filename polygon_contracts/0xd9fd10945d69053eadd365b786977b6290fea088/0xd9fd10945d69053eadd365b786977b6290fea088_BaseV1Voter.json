{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BaseV1-voter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport './libraries/Math.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IVotingEscrow.sol';\\nimport './interfaces/IBaseV1Factory.sol';\\nimport './interfaces/IBaseV1Core.sol';\\nimport './interfaces/IBaseV1GaugeFactory.sol';\\nimport './interfaces/IBaseV1BribeFactory.sol';\\nimport './interfaces/IGauge.sol';\\nimport './interfaces/IBribe.sol';\\nimport './interfaces/IMinter.sol';\\n\\ncontract BaseV1Voter {\\n\\n    address public immutable _ve; // the ve token that governs these contracts\\n    address public immutable factory; // the BaseV1Factory\\n    address internal immutable base;\\n    address public gaugeFactory;\\n    address public immutable bribeFactory;\\n    uint internal constant DURATION = 7 days; // rewards are released over 7 days\\n    address public minter;\\n    address public admin;\\n    bool public permissionMode;\\n\\n    uint public totalWeight; // total voting weight\\n\\n    address[] public allGauges; // all gauges viable for incentives\\n    mapping(address => address) public gauges; // pair => maturity => gauge\\n    mapping(address => address) public poolForGauge; // gauge => pool\\n    mapping(address => address) public bribes; // gauge => bribe\\n    mapping(address => uint256) public weights; // gauge => weight\\n    mapping(uint => mapping(address => uint256)) public votes; // nft => gauge => votes\\n    mapping(uint => address[]) public gaugeVote; // nft => gauge\\n    mapping(uint => uint) public usedWeights;  // nft => total voting weight of user\\n    mapping(address => bool) public isGauge;\\n    mapping(address => bool) public isLive; // gauge => status (live or not)\\n\\n    mapping(address => bool) public isWhitelisted;\\n    mapping(address => mapping(address => bool)) public isReward;\\n    mapping(address => mapping(address => bool)) public isBribe;\\n\\n\\n    mapping(address => uint) public claimable;\\n    uint internal index;\\n    mapping(address => uint) internal supplyIndex;\\n\\n    event GaugeCreated(address indexed gauge, address creator, address indexed bribe, address indexed pair);\\n    event Voted(address indexed voter, uint tokenId, uint256 weight);\\n    event Abstained(uint tokenId, uint256 weight);\\n    event Deposit(address indexed lp, address indexed gauge, uint tokenId, uint amount);\\n    event Withdraw(address indexed lp, address indexed gauge, uint tokenId, uint amount);\\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\\n    event Whitelisted(address indexed whitelister, address indexed token);\\n    event Delisted(address indexed delister, address indexed token);\\n    event GaugeKilled(address indexed gauge);\\n    event GaugeRevived(address indexed gauge);\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Voter: only admin\\\");\\n        _;\\n    }\\n    \\n    modifier checkPermissionMode() {\\n        if(permissionMode) {\\n            require(msg.sender == admin, \\\"Permission Mode Is Active\\\");\\n        }\\n        _;\\n    }\\n\\n    constructor(address __ve, address _factory, address  _gauges, address _bribes) {\\n        require(\\n            __ve != address(0) &&\\n            _factory != address(0) &&\\n            _gauges != address(0) &&\\n            _bribes != address(0),\\n            \\\"Voter: zero address provided in constructor\\\"\\n        );\\n        _ve = __ve;\\n        factory = _factory;\\n        base = IVotingEscrow(__ve).token();\\n        gaugeFactory = _gauges;\\n        bribeFactory = _bribes;\\n        minter = msg.sender;\\n        admin = msg.sender;\\n        permissionMode = false;\\n    }\\n\\n    // simple re-entrancy check\\n    uint internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    function initialize(address[] memory _tokens, address _minter) external {\\n        require(msg.sender == minter);\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            _whitelist(_tokens[i]);\\n        }\\n        \\n        minter = _minter;\\n    }\\n\\n    function setAdmin(address _admin) external onlyAdmin {\\n        require(_admin != address(0), \\\"zero address\\\");\\n        admin = _admin;\\n    }\\n    \\n    function enablePermissionMode() external onlyAdmin {\\n        require(!permissionMode, \\\"Permission Mode Enabled\\\");\\n        permissionMode = true;\\n    }\\n\\n    function disablePermissionMode() external onlyAdmin {\\n        require(permissionMode, \\\"Permission Mode Disabled\\\");\\n        permissionMode = false;\\n    }\\n\\n    function setReward(address _gauge, address _token, bool _status) external onlyAdmin {\\n        isReward[_gauge][_token] = _status;\\n    }\\n\\n    function setBribe(address _bribe, address _token, bool _status) external onlyAdmin {\\n        isBribe[_bribe][_token] = _status;\\n    }\\n\\n    function killGauge(address _gauge) external onlyAdmin {\\n        require(isLive[_gauge], \\\"gauge is not live\\\");\\n        distribute(_gauge);\\n        isLive[_gauge] = false;\\n        claimable[_gauge] = 0;\\n        emit GaugeKilled(_gauge);\\n    }\\n\\n    function reviveGauge(address _gauge) external onlyAdmin {\\n        require(!isLive[_gauge], \\\"gauge is live\\\");\\n        isLive[_gauge] = true;\\n        emit GaugeRevived(_gauge);\\n    }\\n\\n    function listing_fee() public view returns (uint) {\\n        return (IERC20(base).totalSupply() - IERC20(_ve).totalSupply()) / 200;\\n    }\\n\\n    function reset(uint _tokenId) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        _reset(_tokenId);\\n        IVotingEscrow(_ve).abstain(_tokenId);\\n    }\\n\\n    function _reset(uint _tokenId) internal {\\n        require(IVotingEscrow(_ve).isVoteExpired(_tokenId),\\\"Vote Locked!\\\");\\n        address[] storage _gaugeVote = gaugeVote[_tokenId];\\n        uint _gaugeVoteCnt = _gaugeVote.length;\\n        uint256 _totalWeight = 0;\\n\\n        for (uint i = 0; i < _gaugeVoteCnt; i++) {\\n            address _gauge = _gaugeVote[i];\\n            uint256 _votes = votes[_tokenId][_gauge];\\n            if (_votes != 0) {\\n                _updateFor(_gauge);\\n                weights[_gauge] -= _votes;\\n                votes[_tokenId][_gauge] -= _votes;\\n                IBribe(bribes[_gauge])._withdraw(uint256(_votes), _tokenId);\\n                _totalWeight += _votes;\\n                emit Abstained(_tokenId, _votes);\\n            }\\n        }\\n        totalWeight -= uint256(_totalWeight);\\n        usedWeights[_tokenId] = 0;\\n        delete gaugeVote[_tokenId];\\n    }\\n\\n    // @param _tokenId the ID of the NFT to poke\\n    // @notice To be called on voters abusing their voting power\\n    // @notice _weights are the same as the last ID's vote !\\n    function poke(uint _tokenId) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        address[] memory _gaugeVote = gaugeVote[_tokenId];\\n        uint _gaugeCnt = _gaugeVote.length;\\n        uint256[] memory _weights = new uint256[](_gaugeCnt);\\n\\n        for (uint i = 0; i < _gaugeCnt; i++) {\\n            _weights[i] = votes[_tokenId][_gaugeVote[i]];\\n        }\\n\\n        _vote(_tokenId, _gaugeVote, _weights);\\n    }\\n\\n    function _vote(uint _tokenId, address[] memory _gaugeVote, uint256[] memory _weights) internal {\\n        _reset(_tokenId);\\n        // Lock vote for 1 WEEK\\n        IVotingEscrow(_ve).lockVote(_tokenId);\\n        uint _gaugeCnt = _gaugeVote.length;\\n        uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\\n        uint256 _totalVoteWeight = 0;\\n        uint256 _totalWeight = 0;\\n        uint256 _usedWeight = 0;\\n\\n        for (uint i = 0; i < _gaugeCnt; i++) {\\n            _totalVoteWeight += _weights[i];\\n        }\\n\\n        for (uint i = 0; i < _gaugeCnt; i++) {\\n            address _gauge = _gaugeVote[i];\\n            if (isGauge[_gauge]) {\\n                uint256 _gaugeWeight = _weights[i] * _weight / _totalVoteWeight;\\n                require(votes[_tokenId][_gauge] == 0);\\n                require(_gaugeWeight != 0);\\n                _updateFor(_gauge);\\n\\n                gaugeVote[_tokenId].push(_gauge);\\n\\n                weights[_gauge] += _gaugeWeight;\\n                votes[_tokenId][_gauge] += _gaugeWeight;\\n                IBribe(bribes[_gauge])._deposit(_gaugeWeight, _tokenId);\\n                _usedWeight += _gaugeWeight;\\n                _totalWeight += _gaugeWeight;\\n                emit Voted(msg.sender, _tokenId, _gaugeWeight);\\n            }\\n        }\\n        if (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\\n        totalWeight += _totalWeight;\\n        usedWeights[_tokenId] = _usedWeight;\\n    }\\n\\n    // @param _tokenId The id of the veNFT to vote with\\n    // @param _gaugeVote The list of gauges to vote for\\n    // @param _weights The list of weights to vote for each gauge\\n    // @notice the sum of weights is the total weight of the veNFT at max\\n    function vote(uint tokenId, address[] calldata _gaugeVote, uint256[] calldata _weights) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, tokenId));\\n        require(_gaugeVote.length == _weights.length);\\n        uint _lockEnd = IVotingEscrow(_ve).locked__end(tokenId);\\n        require(_nextPeriod() <= _lockEnd, \\\"lock expires soon\\\");\\n        _vote(tokenId, _gaugeVote, _weights);\\n    }\\n\\n    function whitelist(address _token) public checkPermissionMode {\\n        if(msg.sender != admin) {\\n            _safeTransferFrom(base, msg.sender, address(0), listing_fee());\\n        }\\n\\n        _whitelist(_token);\\n    }\\n\\n    function _whitelist(address _token) internal {\\n        require(!isWhitelisted[_token]);\\n        isWhitelisted[_token] = true;\\n        emit Whitelisted(msg.sender, _token);\\n    }\\n    \\n    function delist(address _token) public onlyAdmin {\\n        require(isWhitelisted[_token], \\\"!whitelisted\\\");\\n        isWhitelisted[_token] = false;\\n        emit Delisted(msg.sender, _token);\\n    }\\n\\n    function createGauge(address _pair) external returns (address) {\\n        require(gauges[_pair] == address(0x0), \\\"exists\\\");\\n        require(IBaseV1Factory(factory).isPair(_pair), \\\"!pair\\\");\\n        (address _tokenA, address _tokenB) = IBaseV1Core(_pair).tokens();\\n        require(isWhitelisted[_tokenA] && isWhitelisted[_tokenB], \\\"!whitelisted\\\");\\n        address _bribe = IBaseV1BribeFactory(bribeFactory).createBribe();\\n        address _gauge = IBaseV1GaugeFactory(gaugeFactory).createGauge(_pair, _bribe, _ve);\\n        IERC20(base).approve(_gauge, type(uint).max);\\n        bribes[_gauge] = _bribe;\\n        gauges[_pair] = _gauge;\\n        poolForGauge[_gauge] = _pair;\\n        isGauge[_gauge] = true;\\n        isLive[_gauge] = true;\\n        isReward[_gauge][_tokenA] = true;\\n        isReward[_gauge][_tokenB] = true;\\n        isReward[_gauge][base] = true;\\n        isBribe[_bribe][_tokenA] = true;\\n        isBribe[_bribe][_tokenB] = true;\\n        _updateFor(_gauge);\\n        allGauges.push(_gauge);\\n        emit GaugeCreated(_gauge, msg.sender, _bribe, _pair);\\n        return _gauge;\\n    }\\n\\n    function attachTokenToGauge(uint tokenId, address account) external {\\n        require(isGauge[msg.sender]);\\n        if (tokenId > 0) IVotingEscrow(_ve).attach(tokenId);\\n        emit Attach(account, msg.sender, tokenId);\\n    }\\n\\n    function emitDeposit(uint tokenId, address account, uint amount) external {\\n        require(isGauge[msg.sender]);\\n        emit Deposit(account, msg.sender, tokenId, amount);\\n    }\\n\\n    function detachTokenFromGauge(uint tokenId, address account) external {\\n        require(isGauge[msg.sender]);\\n        if (tokenId > 0) IVotingEscrow(_ve).detach(tokenId);\\n        emit Detach(account, msg.sender, tokenId);\\n    }\\n\\n    function emitWithdraw(uint tokenId, address account, uint amount) external {\\n        require(isGauge[msg.sender]);\\n        emit Withdraw(account, msg.sender, tokenId, amount);\\n    }\\n\\n    function length() external view returns (uint) {\\n        return allGauges.length;\\n    }\\n\\n    // @notice called by Minter contract to distribute weekly rewards\\n    // @param _amount the amount of tokens distributed\\n    function notifyRewardAmount(uint amount) external {\\n        _safeTransferFrom(base, msg.sender, address(this), amount); // transfer the distro in\\n        uint256 _ratio = amount * 1e18 / totalWeight; // 1e18 adjustment is removed during claim\\n        if (_ratio > 0) {\\n            index += _ratio;\\n        }\\n        emit NotifyReward(msg.sender, base, amount);\\n    }\\n\\n    function updateFor(address[] memory _gauges) external {\\n        for (uint i = 0; i < _gauges.length; i++) {\\n            _updateFor(_gauges[i]);\\n        }\\n    }\\n\\n    function updateForRange(uint start, uint end) public {\\n        for (uint i = start; i < end; i++) {\\n            _updateFor(allGauges[i]);\\n        }\\n    }\\n\\n    function updateAll() external {\\n        updateForRange(0, allGauges.length);\\n    }\\n\\n    // @notice update a gauge eligibility for rewards to the current index\\n    // @param _gauge the gauge to update\\n    function updateGauge(address _gauge) external {\\n        _updateFor(_gauge);\\n    }\\n\\n    function _updateFor(address _gauge) internal {\\n        uint256 _supplied = weights[_gauge];\\n        if (_supplied > 0) {\\n            uint _supplyIndex = supplyIndex[_gauge];\\n            uint _index = index; // get global index0 for accumulated distro\\n            supplyIndex[_gauge] = _index; // update _gauge current position to global position\\n            uint _delta = _index - _supplyIndex; // see if there is any difference that need to be accrued\\n            if (_delta > 0) {\\n                uint _share = uint(_supplied) * _delta / 1e18; // add accrued difference for each supplied token\\n                if (isLive[_gauge]) {\\n                    claimable[_gauge] += _share;\\n                }\\n            }\\n        } else {\\n            supplyIndex[_gauge] = index; // new users are set to the default global state\\n        }\\n    }\\n\\n    // @notice allow a gauge depositor to claim earned rewards if any\\n    // @param _gauges list of gauges contracts to claim rewards on\\n    // @param _tokens list of  tokens to claim\\n    function claimRewards(address[] memory _gauges, address[][] memory _tokens) external {\\n        for (uint i = 0; i < _gauges.length; i++) {\\n            IGauge(_gauges[i]).getReward(msg.sender, _tokens[i]);\\n        }\\n    }\\n\\n    // @notice allow a voter to claim earned bribes if any\\n    // @param _bribes list of bribes contracts to claims bribes on\\n    // @param _tokens list of the tokens to claim\\n    // @param _tokenId the ID of veNFT to claim bribes for\\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint _tokenId) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        for (uint i = 0; i < _bribes.length; i++) {\\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\\n        }\\n    }\\n\\n    // @notice allow voter to claim earned fees\\n    // @param _fees list of bribes contracts to claim fees on\\n    // @param _tokens list of the tokens to claim\\n    // @param _tokenId the ID of veNFT to claim fees for\\n    function claimFees(address[] memory _fees, address[][] memory _tokens, uint _tokenId) external {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\\n        for (uint i = 0; i < _fees.length; i++) {\\n            IBribe(_fees[i]).getRewardForOwner(_tokenId, _tokens[i]);\\n        }\\n    }\\n\\n    // @notice distribute earned fees to the bribe contract for a given gauge\\n    // @param _gauges the gauges to distribute fees for\\n    function distributeFees(address[] memory _gauges) external {\\n        for (uint i = 0; i < _gauges.length; i++) {\\n            IGauge(_gauges[i]).claimFees();\\n        }\\n    }\\n\\n    // @notice distribute earned fees to the bribe contract for all gauges\\n    function distroFees() external {\\n        for (uint i = 0; i < allGauges.length; i++) {\\n            IGauge(allGauges[i]).claimFees();\\n        }\\n    }\\n\\n    // @notice distribute fair share of rewards to a gauge\\n    // @param _gauge the gauge to distribute rewards to\\n    function distribute(address _gauge) public lock {\\n        IMinter(minter).update_period();\\n        _updateFor(_gauge);\\n        uint _claimable = claimable[_gauge];\\n        if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {\\n            claimable[_gauge] = 0;\\n            IGauge(_gauge).notifyRewardAmount(base, _claimable);\\n            emit DistributeReward(msg.sender, _gauge, _claimable);\\n        }\\n    }\\n\\n    function distro() external {\\n        distribute(0, allGauges.length);\\n    }\\n\\n    function distribute() external {\\n        distribute(0, allGauges.length);\\n    }\\n\\n    function distribute(uint start, uint finish) public {\\n        for (uint x = start; x < finish; x++) {\\n            distribute(allGauges[x]);\\n        }\\n    }\\n\\n    function distribute(address[] memory _gauges) external {\\n        for (uint x = 0; x < _gauges.length; x++) {\\n            distribute(_gauges[x]);\\n        }\\n    }\\n\\n    // @notice current active vote period\\n    // @return the UNIX timestamp of the beginning of the current vote period\\n    function _activePeriod() internal view returns (uint activePeriod) {\\n        activePeriod = block.timestamp / DURATION * DURATION;\\n    }\\n\\n    // @notice next vote period\\n    // @return the UNIX timestamp of the beginning of the next vote period\\n    function _nextPeriod() internal view returns(uint nextPeriod) {\\n        nextPeriod = (block.timestamp + DURATION) / DURATION * DURATION;\\n    }\\n\\n\\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nlibrary Math {\\n    \\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n    \\n    function min(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IVotingEscrow {\\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n    }\\n\\n    function user_point_epoch(uint tokenId) external view returns (uint);\\n    function epoch() external view returns (uint);\\n    function user_point_history(uint tokenId, uint loc) external view returns (Point memory);\\n    function point_history(uint loc) external view returns (Point memory);\\n    function checkpoint() external;\\n    function deposit_for(uint tokenId, uint value) external;\\n    function token() external view returns (address);\\n    function user_point_history__ts(uint tokenId, uint idx) external view returns (uint);\\n    function locked__end(uint _tokenId) external view returns (uint);\\n    function locked__amount(uint _tokenId) external view returns (uint);\\n    function approve(address spender, uint tokenId) external;\\n    function balanceOfNFT(uint) external view returns (uint);\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\n    function ownerOf(uint) external view returns (address);\\n    function transferFrom(address, address, uint) external;\\n    function totalSupply() external view returns (uint);\\n    function supply() external view returns (uint);\\n    function create_lock_for(uint, uint, address) external returns (uint);\\n    function lockVote(uint tokenId) external;\\n    function isVoteExpired(uint tokenId) external view returns (bool);\\n    function voteExpiry(uint _tokenId) external view returns (uint);\\n    function attach(uint tokenId) external;\\n    function detach(uint tokenId) external;\\n    function voting(uint tokenId) external;\\n    function abstain(uint tokenId) external;\\n    function voted(uint tokenId) external view returns (bool);\\n    function withdraw(uint tokenId) external;\\n    function create_lock(uint value, uint duration) external returns (uint);\\n    function setVoter(address voter) external;\\n    function balanceOf(address owner) external view returns (uint);\\n    function safeTransferFrom(address from, address to, uint tokenId) external;\\n    function burn(uint _tokenId) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBaseV1Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IBaseV1Factory {\\n    function allPairsLength() external view returns (uint);\\n    function isPair(address pair) external view returns (bool);\\n    function pairCodeHash() external pure returns (bytes32);\\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);\\n    function getInitializable() external view returns (address, address, bool);\\n    function setPause(bool _state) external;\\n    function acceptPauser() external;\\n    function setPauser(address _pauser) external;\\n    function isPaused() external view returns (bool);\\n    function getFee(bool _stable) external view returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBaseV1Core.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IBaseV1Core {\\n    function claimFees() external returns (uint, uint);\\n    function tokens() external returns (address, address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBaseV1GaugeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IBaseV1GaugeFactory {\\n    function createGauge(address, address, address) external returns (address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBaseV1BribeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IBaseV1BribeFactory {\\n    function createBribe() external returns (address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IGauge {\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function getReward(address account, address[] memory tokens) external;\\n    function claimFees() external returns (uint claimed0, uint claimed1);\\n    function left(address token) external view returns (uint);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBribe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IBribe {\\n    function _deposit(uint amount, uint tokenId) external;\\n    function _withdraw(uint amount, uint tokenId) external;\\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external;\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function left(address token) external view returns (uint);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IMinter {\\n    function update_period() external returns (uint);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__ve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gauges\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bribes\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"Abstained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Attach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Delisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Detach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bribe\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"GaugeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"GaugeKilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"GaugeRevived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotifyReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_ve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allGauges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"attachTokenToGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bribeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bribes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bribes\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimBribes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_fees\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"createGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"delist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"detachTokenFromGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disablePermissionMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"distributeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distro\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distroFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enablePermissionMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugeVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gauges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBribe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isGauge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"killGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listing_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permissionMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"poke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolForGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"reset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"reviveGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bribe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setBribe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"updateFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"updateForRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"updateGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedWeights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_gaugeVote\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_weights\",\"type\":\"uint256[]\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BaseV1Voter", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f070654b08595f8f358ff90170829892f3254c67000000000000000000000000ba06043a777652baf540ccc785edafd94ee05b370000000000000000000000005a63409c88ddd327a56eef3a3492bb0ce74ba795000000000000000000000000bc5aaf4970e50b2504c2441367b87b6f3d9ac504", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}