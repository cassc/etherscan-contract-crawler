{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/vote/VeDist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"../../lib/Math.sol\\\";\\r\\nimport \\\"../../interface/IERC20.sol\\\";\\r\\nimport \\\"../../interface/IVeDist.sol\\\";\\r\\nimport \\\"../../interface/IVe.sol\\\";\\r\\nimport \\\"../../lib/SafeERC20.sol\\\";\\r\\n\\r\\ncontract VeDist is IVeDist {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  event CheckpointToken(\\r\\n    uint time,\\r\\n    uint tokens\\r\\n  );\\r\\n\\r\\n  event Claimed(\\r\\n    uint tokenId,\\r\\n    uint amount,\\r\\n    uint claimEpoch,\\r\\n    uint maxEpoch\\r\\n  );\\r\\n\\r\\n  struct ClaimCalculationResult {\\r\\n    uint toDistribute;\\r\\n    uint userEpoch;\\r\\n    uint weekCursor;\\r\\n    uint maxUserEpoch;\\r\\n    bool success;\\r\\n  }\\r\\n\\r\\n\\r\\n  uint constant WEEK = 7 * 86400;\\r\\n\\r\\n  uint public startTime;\\r\\n  uint public timeCursor;\\r\\n  mapping(uint => uint) public timeCursorOf;\\r\\n  mapping(uint => uint) public userEpochOf;\\r\\n\\r\\n  uint public lastTokenTime;\\r\\n  uint[1000000000000000] public tokensPerWeek;\\r\\n\\r\\n  address public votingEscrow;\\r\\n  address public token;\\r\\n  uint public tokenLastBalance;\\r\\n\\r\\n  uint[1000000000000000] public veSupply;\\r\\n\\r\\n  address public depositor;\\r\\n\\r\\n  constructor(address _votingEscrow) {\\r\\n    uint _t = block.timestamp / WEEK * WEEK;\\r\\n    startTime = _t;\\r\\n    lastTokenTime = _t;\\r\\n    timeCursor = _t;\\r\\n    address _token = IVe(_votingEscrow).token();\\r\\n    token = _token;\\r\\n    votingEscrow = _votingEscrow;\\r\\n    depositor = msg.sender;\\r\\n    IERC20(_token).safeIncreaseAllowance(_votingEscrow, type(uint).max);\\r\\n  }\\r\\n\\r\\n  function timestamp() external view returns (uint) {\\r\\n    return block.timestamp / WEEK * WEEK;\\r\\n  }\\r\\n\\r\\n  function _checkpointToken() internal {\\r\\n    uint tokenBalance = IERC20(token).balanceOf(address(this));\\r\\n    uint toDistribute = tokenBalance - tokenLastBalance;\\r\\n    tokenLastBalance = tokenBalance;\\r\\n\\r\\n    uint t = lastTokenTime;\\r\\n    uint sinceLast = block.timestamp - t;\\r\\n    lastTokenTime = block.timestamp;\\r\\n    uint thisWeek = t / WEEK * WEEK;\\r\\n    uint nextWeek = 0;\\r\\n\\r\\n    for (uint i = 0; i < 20; i++) {\\r\\n      nextWeek = thisWeek + WEEK;\\r\\n      if (block.timestamp < nextWeek) {\\r\\n        tokensPerWeek[thisWeek] += _adjustToDistribute(toDistribute, block.timestamp, t, sinceLast);\\r\\n        break;\\r\\n      } else {\\r\\n        tokensPerWeek[thisWeek] += _adjustToDistribute(toDistribute, nextWeek, t, sinceLast);\\r\\n      }\\r\\n      t = nextWeek;\\r\\n      thisWeek = nextWeek;\\r\\n    }\\r\\n    emit CheckpointToken(block.timestamp, toDistribute);\\r\\n  }\\r\\n\\r\\n  /// @dev For testing purposes.\\r\\n  function adjustToDistribute(\\r\\n    uint toDistribute,\\r\\n    uint t0,\\r\\n    uint t1,\\r\\n    uint sinceLastCall\\r\\n  ) external pure returns (uint) {\\r\\n    return _adjustToDistribute(\\r\\n      toDistribute,\\r\\n      t0,\\r\\n      t1,\\r\\n      sinceLastCall\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function _adjustToDistribute(\\r\\n    uint toDistribute,\\r\\n    uint t0,\\r\\n    uint t1,\\r\\n    uint sinceLast\\r\\n  ) internal pure returns (uint) {\\r\\n    if (t0 <= t1 || t0 - t1 == 0 || sinceLast == 0) {\\r\\n      return toDistribute;\\r\\n    }\\r\\n    return toDistribute * (t0 - t1) / sinceLast;\\r\\n  }\\r\\n\\r\\n  function checkpointToken() external override {\\r\\n    require(msg.sender == depositor, \\\"!depositor\\\");\\r\\n    _checkpointToken();\\r\\n  }\\r\\n\\r\\n  function _findTimestampEpoch(address ve, uint _timestamp) internal view returns (uint) {\\r\\n    uint _min = 0;\\r\\n    uint _max = IVe(ve).epoch();\\r\\n    for (uint i = 0; i < 128; i++) {\\r\\n      if (_min >= _max) break;\\r\\n      uint _mid = (_min + _max + 2) / 2;\\r\\n      IVe.Point memory pt = IVe(ve).pointHistory(_mid);\\r\\n      if (pt.ts <= _timestamp) {\\r\\n        _min = _mid;\\r\\n      } else {\\r\\n        _max = _mid - 1;\\r\\n      }\\r\\n    }\\r\\n    return _min;\\r\\n  }\\r\\n\\r\\n  function findTimestampUserEpoch(address ve, uint tokenId, uint _timestamp, uint maxUserEpoch) external view returns (uint) {\\r\\n    return _findTimestampUserEpoch(ve, tokenId, _timestamp, maxUserEpoch);\\r\\n  }\\r\\n\\r\\n  function _findTimestampUserEpoch(address ve, uint tokenId, uint _timestamp, uint maxUserEpoch) internal view returns (uint) {\\r\\n    uint _min = 0;\\r\\n    uint _max = maxUserEpoch;\\r\\n    for (uint i = 0; i < 128; i++) {\\r\\n      if (_min >= _max) break;\\r\\n      uint _mid = (_min + _max + 2) / 2;\\r\\n      IVe.Point memory pt = IVe(ve).userPointHistory(tokenId, _mid);\\r\\n      if (pt.ts <= _timestamp) {\\r\\n        _min = _mid;\\r\\n      } else {\\r\\n        _max = _mid - 1;\\r\\n      }\\r\\n    }\\r\\n    return _min;\\r\\n  }\\r\\n\\r\\n  function veForAt(uint _tokenId, uint _timestamp) external view returns (uint) {\\r\\n    address ve = votingEscrow;\\r\\n    uint maxUserEpoch = IVe(ve).userPointEpoch(_tokenId);\\r\\n    uint epoch = _findTimestampUserEpoch(ve, _tokenId, _timestamp, maxUserEpoch);\\r\\n    IVe.Point memory pt = IVe(ve).userPointHistory(_tokenId, epoch);\\r\\n    return uint(int256(Math.positiveInt128(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))));\\r\\n  }\\r\\n\\r\\n  function _checkpointTotalSupply() internal {\\r\\n    address ve = votingEscrow;\\r\\n    uint t = timeCursor;\\r\\n    uint roundedTimestamp = block.timestamp / WEEK * WEEK;\\r\\n    IVe(ve).checkpoint();\\r\\n\\r\\n    // assume will be called more frequently than 20 weeks\\r\\n    for (uint i = 0; i < 20; i++) {\\r\\n      if (t > roundedTimestamp) {\\r\\n        break;\\r\\n      } else {\\r\\n        uint epoch = _findTimestampEpoch(ve, t);\\r\\n        IVe.Point memory pt = IVe(ve).pointHistory(epoch);\\r\\n        veSupply[t] = _adjustVeSupply(t, pt.ts, pt.bias, pt.slope);\\r\\n      }\\r\\n      t += WEEK;\\r\\n    }\\r\\n    timeCursor = t;\\r\\n  }\\r\\n\\r\\n  function adjustVeSupply(uint t, uint ptTs, int128 ptBias, int128 ptSlope) external pure returns (uint) {\\r\\n    return _adjustVeSupply(t, ptTs, ptBias, ptSlope);\\r\\n  }\\r\\n\\r\\n  function _adjustVeSupply(uint t, uint ptTs, int128 ptBias, int128 ptSlope) internal pure returns (uint) {\\r\\n    if (t < ptTs) {\\r\\n      return 0;\\r\\n    }\\r\\n    int128 dt = int128(int256(t - ptTs));\\r\\n    if (ptBias < ptSlope * dt) {\\r\\n      return 0;\\r\\n    }\\r\\n    return uint(int256(Math.positiveInt128(ptBias - ptSlope * dt)));\\r\\n  }\\r\\n\\r\\n  function checkpointTotalSupply() external override {\\r\\n    _checkpointTotalSupply();\\r\\n  }\\r\\n\\r\\n  function _claim(uint _tokenId, address ve, uint _lastTokenTime) internal returns (uint) {\\r\\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, ve, _lastTokenTime);\\r\\n    if (result.success) {\\r\\n      userEpochOf[_tokenId] = result.userEpoch;\\r\\n      timeCursorOf[_tokenId] = result.weekCursor;\\r\\n      emit Claimed(_tokenId, result.toDistribute, result.userEpoch, result.maxUserEpoch);\\r\\n    }\\r\\n    return result.toDistribute;\\r\\n  }\\r\\n\\r\\n  function _calculateClaim(uint _tokenId, address ve, uint _lastTokenTime) internal view returns (ClaimCalculationResult memory) {\\r\\n    uint userEpoch;\\r\\n    uint toDistribute;\\r\\n    uint maxUserEpoch = IVe(ve).userPointEpoch(_tokenId);\\r\\n    uint _startTime = startTime;\\r\\n\\r\\n    if (maxUserEpoch == 0) {\\r\\n      return ClaimCalculationResult(0, 0, 0, 0, false);\\r\\n    }\\r\\n\\r\\n    uint weekCursor = timeCursorOf[_tokenId];\\r\\n\\r\\n    if (weekCursor == 0) {\\r\\n      userEpoch = _findTimestampUserEpoch(ve, _tokenId, _startTime, maxUserEpoch);\\r\\n    } else {\\r\\n      userEpoch = userEpochOf[_tokenId];\\r\\n    }\\r\\n\\r\\n    if (userEpoch == 0) userEpoch = 1;\\r\\n\\r\\n    IVe.Point memory userPoint = IVe(ve).userPointHistory(_tokenId, userEpoch);\\r\\n    if (weekCursor == 0) {\\r\\n      weekCursor = (userPoint.ts + WEEK - 1) / WEEK * WEEK;\\r\\n    }\\r\\n    if (weekCursor >= lastTokenTime) {\\r\\n      return ClaimCalculationResult(0, 0, 0, 0, false);\\r\\n    }\\r\\n    if (weekCursor < _startTime) {\\r\\n      weekCursor = _startTime;\\r\\n    }\\r\\n\\r\\n    IVe.Point memory oldUserPoint;\\r\\n    {\\r\\n      for (uint i = 0; i < 50; i++) {\\r\\n        if (weekCursor >= _lastTokenTime) {\\r\\n          break;\\r\\n        }\\r\\n        if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\\r\\n          userEpoch += 1;\\r\\n          oldUserPoint = userPoint;\\r\\n          if (userEpoch > maxUserEpoch) {\\r\\n            userPoint = IVe.Point(0, 0, 0, 0);\\r\\n          } else {\\r\\n            userPoint = IVe(ve).userPointHistory(_tokenId, userEpoch);\\r\\n          }\\r\\n        } else {\\r\\n          int128 dt = int128(int256(weekCursor - oldUserPoint.ts));\\r\\n          uint balanceOf = uint(int256(Math.positiveInt128(oldUserPoint.bias - dt * oldUserPoint.slope)));\\r\\n          if (balanceOf == 0 && userEpoch > maxUserEpoch) {\\r\\n            break;\\r\\n          }\\r\\n          toDistribute += balanceOf * tokensPerWeek[weekCursor] / veSupply[weekCursor];\\r\\n          weekCursor += WEEK;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    return ClaimCalculationResult(\\r\\n      toDistribute,\\r\\n      Math.min(maxUserEpoch, userEpoch - 1),\\r\\n      weekCursor,\\r\\n      maxUserEpoch,\\r\\n      true\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function claimable(uint _tokenId) external view returns (uint) {\\r\\n    uint _lastTokenTime = lastTokenTime / WEEK * WEEK;\\r\\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, votingEscrow, _lastTokenTime);\\r\\n    return result.toDistribute;\\r\\n  }\\r\\n\\r\\n  function claim(uint _tokenId) external returns (uint) {\\r\\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\\r\\n    uint _lastTokenTime = lastTokenTime;\\r\\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\\r\\n    uint amount = _claim(_tokenId, votingEscrow, _lastTokenTime);\\r\\n    if (amount != 0) {\\r\\n      IVe(votingEscrow).depositFor(_tokenId, amount);\\r\\n      tokenLastBalance -= amount;\\r\\n    }\\r\\n    return amount;\\r\\n  }\\r\\n\\r\\n  function claimMany(uint[] memory _tokenIds) external returns (bool) {\\r\\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\\r\\n    uint _lastTokenTime = lastTokenTime;\\r\\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\\r\\n    address _votingEscrow = votingEscrow;\\r\\n    uint total = 0;\\r\\n\\r\\n    for (uint i = 0; i < _tokenIds.length; i++) {\\r\\n      uint _tokenId = _tokenIds[i];\\r\\n      if (_tokenId == 0) break;\\r\\n      uint amount = _claim(_tokenId, _votingEscrow, _lastTokenTime);\\r\\n      if (amount != 0) {\\r\\n        IVe(_votingEscrow).depositFor(_tokenId, amount);\\r\\n        total += amount;\\r\\n      }\\r\\n    }\\r\\n    if (total != 0) {\\r\\n      tokenLastBalance -= total;\\r\\n    }\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  // Once off event on contract initialize\\r\\n  function setDepositor(address _depositor) external {\\r\\n    require(msg.sender == depositor, \\\"!depositor\\\");\\r\\n    depositor = _depositor;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nlibrary Math {\\r\\n\\r\\n  function max(uint a, uint b) internal pure returns (uint) {\\r\\n    return a >= b ? a : b;\\r\\n  }\\r\\n\\r\\n  function min(uint a, uint b) internal pure returns (uint) {\\r\\n    return a < b ? a : b;\\r\\n  }\\r\\n\\r\\n  function positiveInt128(int128 value) internal pure returns (int128) {\\r\\n    return value < 0 ? int128(0) : value;\\r\\n  }\\r\\n\\r\\n  function closeTo(uint a, uint b, uint target) internal pure returns (bool) {\\r\\n    if (a > b) {\\r\\n      if (a - b <= target) {\\r\\n        return true;\\r\\n      }\\r\\n    } else {\\r\\n      if (b - a <= target) {\\r\\n        return true;\\r\\n      }\\r\\n    }\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  function sqrt(uint y) internal pure returns (uint z) {\\r\\n    if (y > 3) {\\r\\n      z = y;\\r\\n      uint x = y / 2 + 1;\\r\\n      while (x < z) {\\r\\n        z = x;\\r\\n        x = (y / x + x) / 2;\\r\\n      }\\r\\n    } else if (y != 0) {\\r\\n      z = 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens in existence.\\r\\n   */\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens owned by `account`.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remaining number of tokens that `spender` will be\\r\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n   * zero by default.\\r\\n   *\\r\\n   * This value changes when {approve} or {transferFrom} are called.\\r\\n   */\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n   * that someone may use both the old and the new allowance by unfortunate\\r\\n   * transaction ordering. One possible solution to mitigate this race\\r\\n   * condition is to first reduce the spender's allowance to 0 and set the\\r\\n   * desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n   * allowance mechanism. `amount` is then deducted from the caller's\\r\\n   * allowance.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n   * another (`to`).\\r\\n   *\\r\\n   * Note that `value` may be zero.\\r\\n   */\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n   * a call to {approve}. `value` is the new allowance.\\r\\n   */\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IVeDist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\ninterface IVeDist {\\r\\n\\r\\n  function checkpointToken() external;\\r\\n\\r\\n  function checkpointTotalSupply() external;\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interface/IVe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\ninterface IVe {\\r\\n\\r\\n  enum DepositType {\\r\\n    DEPOSIT_FOR_TYPE,\\r\\n    CREATE_LOCK_TYPE,\\r\\n    INCREASE_LOCK_AMOUNT,\\r\\n    INCREASE_UNLOCK_TIME,\\r\\n    MERGE_TYPE\\r\\n  }\\r\\n\\r\\n  struct Point {\\r\\n    int128 bias;\\r\\n    int128 slope; // # -dweight / dt\\r\\n    uint ts;\\r\\n    uint blk; // block\\r\\n  }\\r\\n  /* We cannot really do block numbers per se b/c slope is per time, not per block\\r\\n  * and per block could be fairly bad b/c Ethereum changes blocktimes.\\r\\n  * What we can do is to extrapolate ***At functions */\\r\\n\\r\\n  struct LockedBalance {\\r\\n    int128 amount;\\r\\n    uint end;\\r\\n  }\\r\\n\\r\\n  function token() external view returns (address);\\r\\n\\r\\n  function balanceOfNFT(uint) external view returns (uint);\\r\\n\\r\\n  function isApprovedOrOwner(address, uint) external view returns (bool);\\r\\n\\r\\n  function createLockFor(uint, uint, address) external returns (uint);\\r\\n\\r\\n  function userPointEpoch(uint tokenId) external view returns (uint);\\r\\n\\r\\n  function epoch() external view returns (uint);\\r\\n\\r\\n  function userPointHistory(uint tokenId, uint loc) external view returns (Point memory);\\r\\n\\r\\n  function pointHistory(uint loc) external view returns (Point memory);\\r\\n\\r\\n  function checkpoint() external;\\r\\n\\r\\n  function depositFor(uint tokenId, uint value) external;\\r\\n\\r\\n  function attachToken(uint tokenId) external;\\r\\n\\r\\n  function detachToken(uint tokenId) external;\\r\\n\\r\\n  function voting(uint tokenId) external;\\r\\n\\r\\n  function abstain(uint tokenId) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"../interface/IERC20.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint value\\r\\n  ) internal {\\r\\n    uint newAllowance = token.allowance(address(this), spender) + value;\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n    // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n    if (returndata.length > 0) {\\r\\n      // Return data is optional\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n  /**\\r\\n   * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    // This method relies on extcodesize/address.code.length, which returns 0\\r\\n    // for contracts in construction, since the code is only stored at the end\\r\\n    // of the constructor execution.\\r\\n\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n    (bool success, bytes memory returndata) = target.call(data);\\r\\n    return verifyCallResult(success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      // Look for revert reason and bubble it up if present\\r\\n      if (returndata.length > 0) {\\r\\n        // The easiest way to bubble the revert reason is using memory via assembly\\r\\n        assembly {\\r\\n          let returndata_size := mload(returndata)\\r\\n          revert(add(32, returndata), returndata_size)\\r\\n        }\\r\\n      } else {\\r\\n        revert(errorMessage);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_votingEscrow\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"CheckpointToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxEpoch\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toDistribute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sinceLastCall\",\"type\":\"uint256\"}],\"name\":\"adjustToDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ptTs\",\"type\":\"uint256\"},{\"internalType\":\"int128\",\"name\":\"ptBias\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"ptSlope\",\"type\":\"int128\"}],\"name\":\"adjustVeSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointTotalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claimMany\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxUserEpoch\",\"type\":\"uint256\"}],\"name\":\"findTimestampUserEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTokenTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"setDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeCursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeCursorOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLastBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensPerWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userEpochOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"veForAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"veSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingEscrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VeDist", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000841097f62a82c2fef8aa943a2f80b59773e5e02", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}