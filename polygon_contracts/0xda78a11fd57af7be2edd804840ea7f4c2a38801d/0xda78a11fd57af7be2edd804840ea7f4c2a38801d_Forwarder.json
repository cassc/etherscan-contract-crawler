{"SourceCode": "// File: @openzeppelin/contracts/cryptography/ECDSA.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: src/forwarder/IForwarder.sol\r\n\r\n// (SPDX)-License-Identifier:MIT\r\npragma solidity >=0.7.6;\r\npragma abicoder v2;\r\n\r\ninterface IForwarder {\r\n\r\n    struct ForwardRequest {\r\n        address from;\r\n        address to;\r\n        uint256 value;\r\n        uint256 gas;\r\n        uint256 nonce;\r\n        bytes data;\r\n        uint256 validUntil;\r\n    }\r\n\r\n    event DomainRegistered(bytes32 indexed domainSeparator, bytes domainValue);\r\n\r\n    event RequestTypeRegistered(bytes32 indexed typeHash, string typeStr);\r\n\r\n    function getNonce(address from)\r\n    external view\r\n    returns(uint256);\r\n\r\n    /**\r\n     * verify the transaction would execute.\r\n     * validate the signature and the nonce of the request.\r\n     * revert if either signature or nonce are incorrect.\r\n     * also revert if domainSeparator or requestTypeHash are not registered.\r\n     */\r\n    function verify(\r\n        ForwardRequest calldata forwardRequest,\r\n        bytes32 domainSeparator,\r\n        bytes32 requestTypeHash,\r\n        bytes calldata suffixData,\r\n        bytes calldata signature\r\n    ) external view;\r\n\r\n    /**\r\n     * execute a transaction\r\n     * @param forwardRequest - all transaction parameters\r\n     * @param domainSeparator - domain used when signing this request\r\n     * @param requestTypeHash - request type used when signing this request.\r\n     * @param suffixData - the extension data used when signing this request.\r\n     * @param signature - signature to validate.\r\n     *\r\n     * the transaction is verified, and then executed.\r\n     * the success and ret of \"call\" are returned.\r\n     * This method would revert only verification errors. target errors\r\n     * are reported using the returned \"success\" and ret string\r\n     */\r\n    function execute(\r\n        ForwardRequest calldata forwardRequest,\r\n        bytes32 domainSeparator,\r\n        bytes32 requestTypeHash,\r\n        bytes calldata suffixData,\r\n        bytes calldata signature\r\n    )\r\n    external payable\r\n    returns (bool success, bytes memory ret);\r\n\r\n    /**\r\n     * Register a new Request typehash.\r\n     * @param typeName - the name of the request type.\r\n     * @param typeSuffix - any extra data after the generic params.\r\n     *  (must add at least one param. The generic ForwardRequest type is always registered by the constructor)\r\n     */\r\n    function registerRequestType(string calldata typeName, string calldata typeSuffix) external;\r\n\r\n    /**\r\n     * Register a new domain separator.\r\n     * The domain separator must have the following fields: name,version,chainId, verifyingContract.\r\n     * the chainId is the current network's chainId, and the verifyingContract is this forwarder.\r\n     * This method is given the domain name and version to create and register the domain separator value.\r\n     * @param name the domain's display name\r\n     * @param version the domain/protocol version\r\n     */\r\n    function registerDomainSeparator(string calldata name, string calldata version) external;\r\n}\r\n\r\n// File: src/forwarder/Forwarder.sol\r\n\r\n// (SPDX)-License-Identifier:MIT\r\npragma solidity ^0.7.6;\r\n// pragma abicoder v2;\r\n\r\n\r\n\r\ncontract Forwarder is IForwarder {\r\n    using ECDSA for bytes32;\r\n\r\n    string public constant GENERIC_PARAMS = \"address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data,uint256 validUntil\";\r\n\r\n    string public constant EIP712_DOMAIN_TYPE = \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\";\r\n\r\n    mapping(bytes32 => bool) public typeHashes;\r\n    mapping(bytes32 => bool) public domains;\r\n\r\n    // Nonces of senders, used to prevent replay attacks\r\n    mapping(address => uint256) private nonces;\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    receive() external payable {}\r\n\r\n    function getNonce(address from)\r\n    public view override\r\n    returns (uint256) {\r\n        return nonces[from];\r\n    }\r\n\r\n    constructor() {\r\n\r\n        string memory requestType = string(abi.encodePacked(\"ForwardRequest(\", GENERIC_PARAMS, \")\"));\r\n        registerRequestTypeInternal(requestType);\r\n    }\r\n\r\n    function verify(\r\n        ForwardRequest calldata req,\r\n        bytes32 domainSeparator,\r\n        bytes32 requestTypeHash,\r\n        bytes calldata suffixData,\r\n        bytes calldata sig)\r\n    external override view {\r\n\r\n        _verifyNonce(req);\r\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\r\n    }\r\n\r\n    function execute(\r\n        ForwardRequest calldata req,\r\n        bytes32 domainSeparator,\r\n        bytes32 requestTypeHash,\r\n        bytes calldata suffixData,\r\n        bytes calldata sig\r\n    )\r\n    external payable\r\n    override\r\n    returns (bool success, bytes memory ret) {\r\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\r\n        _verifyAndUpdateNonce(req);\r\n\r\n        require(req.validUntil == 0 || req.validUntil > block.number, \"FWD: request expired\");\r\n\r\n        uint gasForTransfer = 0;\r\n        if ( req.value != 0 ) {\r\n            gasForTransfer = 40000; //buffer in case we need to move eth after the transaction.\r\n        }\r\n        bytes memory callData = abi.encodePacked(req.data, req.from);\r\n        require(gasleft()*63/64 >= req.gas + gasForTransfer, \"FWD: insufficient gas\");\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (success,ret) = req.to.call{gas : req.gas, value : req.value}(callData);\r\n        if ( req.value != 0 && address(this).balance>0 ) {\r\n            // can't fail: req.from signed (off-chain) the request, so it must be an EOA...\r\n            payable(req.from).transfer(address(this).balance);\r\n        }\r\n\r\n        return (success,ret);\r\n    }\r\n\r\n\r\n    function _verifyNonce(ForwardRequest calldata req) internal view {\r\n        require(nonces[req.from] == req.nonce, \"FWD: nonce mismatch\");\r\n    }\r\n\r\n    function _verifyAndUpdateNonce(ForwardRequest calldata req) internal {\r\n        require(nonces[req.from]++ == req.nonce, \"FWD: nonce mismatch\");\r\n    }\r\n\r\n    function registerRequestType(string calldata typeName, string calldata typeSuffix) external override {\r\n\r\n        for (uint i = 0; i < bytes(typeName).length; i++) {\r\n            bytes1 c = bytes(typeName)[i];\r\n            require(c != \"(\" && c != \")\", \"FWD: invalid typename\");\r\n        }\r\n\r\n        string memory requestType = string(abi.encodePacked(typeName, \"(\", GENERIC_PARAMS, \",\", typeSuffix));\r\n        registerRequestTypeInternal(requestType);\r\n    }\r\n\r\n    function registerDomainSeparator(string calldata name, string calldata version) external override {\r\n        uint256 chainId;\r\n        /* solhint-disable-next-line no-inline-assembly */\r\n        assembly { chainId := chainid() }\r\n\r\n        bytes memory domainValue = abi.encode(\r\n            keccak256(bytes(EIP712_DOMAIN_TYPE)),\r\n            keccak256(bytes(name)),\r\n            keccak256(bytes(version)),\r\n            chainId,\r\n            address(this));\r\n\r\n        bytes32 domainHash = keccak256(domainValue);\r\n\r\n        domains[domainHash] = true;\r\n        emit DomainRegistered(domainHash, domainValue);\r\n    }\r\n\r\n    function registerRequestTypeInternal(string memory requestType) internal {\r\n\r\n        bytes32 requestTypehash = keccak256(bytes(requestType));\r\n        typeHashes[requestTypehash] = true;\r\n        emit RequestTypeRegistered(requestTypehash, requestType);\r\n    }\r\n\r\n    function _verifySig(\r\n        ForwardRequest calldata req,\r\n        bytes32 domainSeparator,\r\n        bytes32 requestTypeHash,\r\n        bytes calldata suffixData,\r\n        bytes calldata sig)\r\n    internal\r\n    view\r\n    {\r\n        require(domains[domainSeparator], \"FWD: unregistered domain sep.\");\r\n        require(typeHashes[requestTypeHash], \"FWD: unregistered typehash\");\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\", domainSeparator,\r\n                keccak256(_getEncoded(req, requestTypeHash, suffixData))\r\n            ));\r\n        require(digest.recover(sig) == req.from, \"FWD: signature mismatch\");\r\n    }\r\n\r\n    function _getEncoded(\r\n        ForwardRequest calldata req,\r\n        bytes32 requestTypeHash,\r\n        bytes calldata suffixData\r\n    )\r\n    public\r\n    pure\r\n    returns (\r\n        bytes memory\r\n    ) {\r\n        // we use encodePacked since we append suffixData as-is, not as dynamic param.\r\n        // still, we must make sure all first params are encoded as abi.encode()\r\n        // would encode them - as 256-bit-wide params.\r\n        return abi.encodePacked(\r\n            requestTypeHash,\r\n            uint256(uint160(req.from)),\r\n            uint256(uint160(req.to)),\r\n            req.value,\r\n            req.gas,\r\n            req.nonce,\r\n            keccak256(req.data),\r\n            req.validUntil,\r\n            suffixData\r\n        );\r\n    }\r\n}\r\n", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"domainValue\",\"type\":\"bytes\"}],\"name\":\"DomainRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"typeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"typeStr\",\"type\":\"string\"}],\"name\":\"RequestTypeRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_TYPE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GENERIC_PARAMS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct IForwarder.ForwardRequest\",\"name\":\"req\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"requestTypeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"suffixData\",\"type\":\"bytes\"}],\"name\":\"_getEncoded\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"domains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct IForwarder.ForwardRequest\",\"name\":\"req\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"requestTypeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"suffixData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"ret\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"registerDomainSeparator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"typeName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"typeSuffix\",\"type\":\"string\"}],\"name\":\"registerRequestType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"typeHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct IForwarder.ForwardRequest\",\"name\":\"req\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"requestTypeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"suffixData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Forwarder", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}