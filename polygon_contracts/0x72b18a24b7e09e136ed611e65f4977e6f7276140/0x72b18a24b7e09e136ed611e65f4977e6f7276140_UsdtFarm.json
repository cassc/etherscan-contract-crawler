{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.12;\r\ninterface TokenLike {\r\n    function transferFrom(address,address,uint) external;\r\n    function transfer(address,uint) external;\r\n    function balanceOf(address) external view  returns (uint);\r\n}\r\ninterface ExchequerLike {\r\n    function fundPool(address) external returns (uint);\r\n    function getfundPool() external view returns (uint);\r\n}\r\ncontract UsdtFarm {\r\n\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external  auth { wards[usr] = 1; }\r\n    function deny(address usr) external  auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"UsdtFarm/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256    amount;   \r\n        int256    rewardDebt;\r\n        uint256    harved;\r\n        uint256[2][]  withdrawList;\r\n        uint256[2][]  harveList;\r\n        uint256[2][]  depositList;\r\n    }\r\n\r\n    uint256   public acclpPerShare;\r\n    TokenLike public token = TokenLike(0xEeE1e6e2eAb894F30aD66cf933AC9369E6958b4A);\r\n    TokenLike public lptoken = TokenLike(0xc2132D05D31c914a87C6611C10748AEb04B58e8F);\r\n    ExchequerLike public exchequer = ExchequerLike(0x9fb3312C38d9fbE43022d5D4DdA14C9Ad1fd3c88);\r\n\r\n    mapping (address => UserInfo) public userInfo;\r\n\r\n\r\n    event Deposit( address  indexed  owner,\r\n                   uint256           wad\r\n                  );\r\n    event Harvest( address  indexed  owner,\r\n                   uint256           wad\r\n                  );\r\n    event Withdraw( address  indexed  owner,\r\n                    uint256           wad\r\n                 );\r\n\r\n\r\n        // --- Math ---\r\n    function add(uint x, int y) internal pure returns (uint z) {\r\n        z = x + uint(y);\r\n        require(y >= 0 || z <= x);\r\n        require(y <= 0 || z >= x);\r\n    }\r\n    function sub(uint x, int y) internal pure returns (uint z) {\r\n        z = x - uint(y);\r\n        require(y <= 0 || z <= x);\r\n        require(y >= 0 || z >= x);\r\n    }\r\n    function mul(uint x, int y) internal pure returns (int z) {\r\n        z = int(x) * y;\r\n        require(int(x) >= 0);\r\n        require(y == 0 || z / y == int(x));\r\n    }\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    \r\n        return c;\r\n      }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"UsdtFarm/SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"UsdtFarm/SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function toUInt256(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0, \"Integer < 0\");\r\n        return uint256(a);\r\n    }\r\n    constructor() {\r\n        wards[msg.sender] = 1;\r\n    }\r\n    function setAddress(address _token,address _lptoken ,address _exchequer) external auth {\r\n        token = TokenLike(_token);\r\n        lptoken = TokenLike(_lptoken); \r\n        exchequer = ExchequerLike(_exchequer);\r\n    }\r\n    //The pledge LP  \r\n    function deposit(uint _amount) public {\r\n        updateReward();\r\n        lptoken.transferFrom(msg.sender, address(this), _amount);\r\n        UserInfo storage user = userInfo[msg.sender]; \r\n        user.amount = add(user.amount,_amount); \r\n        user.rewardDebt = add(user.rewardDebt,int256(mul(_amount,acclpPerShare) / 1e6));\r\n        uint256[2] memory list = [_amount,block.timestamp];\r\n        user.depositList.push(list); \r\n        emit Deposit(msg.sender,_amount);     \r\n    }\r\n    function depositAll() public {\r\n        uint _amount = lptoken.balanceOf(msg.sender);\r\n        if (_amount == 0) return;\r\n        deposit(_amount);\r\n    }\r\n    //Update mining data\r\n    function updateReward() internal {\r\n        uint lpSupply = lptoken.balanceOf(address(this));\r\n        if (lpSupply == 0) return;\r\n        uint256 yield = exchequer.fundPool(address(this));\r\n        uint256 lpReward = div(mul(yield,uint(1e6)),lpSupply);\r\n        acclpPerShare = add(acclpPerShare,lpReward);\r\n    }\r\n    //The harvest from mining\r\n    function harvest() public returns (uint256) {\r\n        return harvestForOther(msg.sender);  \r\n    }\r\n    function harvestForOther(address usr) public returns (uint256) {\r\n        updateReward();\r\n        UserInfo storage user = userInfo[usr];\r\n        int256 accumulatedlp = int(mul(user.amount,acclpPerShare) / 1e6);\r\n        uint256 _pendinglp = toUInt256(sub(accumulatedlp,user.rewardDebt));\r\n\r\n        // Effects\r\n        user.rewardDebt = accumulatedlp;\r\n\r\n        // Interactions\r\n        if (_pendinglp != 0) {\r\n            token.transfer(usr, _pendinglp);\r\n            user.harved = add(user.harved,_pendinglp);\r\n            uint256[2] memory list = [_pendinglp,block.timestamp];\r\n            user.harveList.push(list);\r\n        } \r\n        emit Harvest(usr,_pendinglp); \r\n       return  _pendinglp;    \r\n    }\r\n    //Withdrawal pledge currency\r\n    function withdraw(uint256 _amount) public {\r\n        if(_amount ==0) return;\r\n        updateReward();\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        user.rewardDebt = sub(user.rewardDebt,int(mul(_amount,acclpPerShare) / 1e6));\r\n        user.amount = sub(user.amount,_amount);\r\n        lptoken.transfer(msg.sender, _amount);\r\n        uint256[2] memory list = [_amount,block.timestamp];\r\n        user.withdrawList.push(list);\r\n        emit Withdraw(msg.sender,_amount);     \r\n    }\r\n\r\n    function withdrawAll() public {\r\n        UserInfo storage user = userInfo[msg.sender]; \r\n        uint256 _amount = user.amount;\r\n        if (_amount == 0) return;\r\n        withdraw(_amount);\r\n    }\r\n    function getUserInfo(address usr) public view returns (UserInfo memory) {\r\n       return userInfo[usr];\r\n    }\r\n\r\n    //Estimate the harvest\r\n    function beharvest(address usr) public view returns (uint256) {\r\n        uint lpSupply = lptoken.balanceOf(address(this));\r\n        if(lpSupply ==0) return 0;\r\n        uint256 yield = exchequer.getfundPool();\r\n        uint256 lpReward = div(mul(yield,uint(1e6)),lpSupply);\r\n        uint256 _acclpPerShare = add(acclpPerShare,lpReward);\r\n        UserInfo storage user = userInfo[usr];\r\n        int256 accumulatedlp = int(mul(user.amount,_acclpPerShare) / 1e6);\r\n        uint256 _pendinglp = toUInt256(sub(accumulatedlp,user.rewardDebt));\r\n        return _pendinglp;\r\n    }\r\n    function withdraw(address asses, uint256 amount, address ust) public auth {\r\n        TokenLike(asses).transfer(ust, amount);\r\n    }\r\n }", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acclpPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"beharvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchequer\",\"outputs\":[{\"internalType\":\"contract ExchequerLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rewardDebt\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"harved\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2][]\",\"name\":\"withdrawList\",\"type\":\"uint256[2][]\"},{\"internalType\":\"uint256[2][]\",\"name\":\"harveList\",\"type\":\"uint256[2][]\"},{\"internalType\":\"uint256[2][]\",\"name\":\"depositList\",\"type\":\"uint256[2][]\"}],\"internalType\":\"struct UsdtFarm.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"harvestForOther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lptoken\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lptoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchequer\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rewardDebt\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"harved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asses\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ust\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UsdtFarm", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8608c062ab4c9564ef2f65d40a1065b90e55f8080170a7dc832373095a9851cf"}