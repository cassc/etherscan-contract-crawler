{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"cache/solpp-generated-contracts/zksync/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Ownable Contract\\n/// @author Matter Labs\\ncontract Ownable {\\n    /// @dev Storage position of the masters address (keccak256('eip1967.proxy.admin') - 1)\\n    bytes32 private constant MASTER_POSITION = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /// @notice Contract constructor\\n    /// @dev Sets msg sender address as masters address\\n    /// @param masterAddress Master address\\n    constructor(address masterAddress) {\\n        setMaster(masterAddress);\\n    }\\n\\n    /// @notice Check if specified address is master\\n    /// @param _address Address to check\\n    function requireMaster(address _address) internal view {\\n        require(_address == getMaster(), \\\"1c\\\"); // oro11 - only by master\\n    }\\n\\n    /// @notice Returns contract masters address\\n    /// @return master Master's address\\n    function getMaster() public view returns (address master) {\\n        bytes32 position = MASTER_POSITION;\\n        assembly {\\n            master := sload(position)\\n        }\\n    }\\n\\n    /// @dev Sets new masters address\\n    /// @param _newMaster New master's address\\n    function setMaster(address _newMaster) internal {\\n        bytes32 position = MASTER_POSITION;\\n        assembly {\\n            sstore(position, _newMaster)\\n        }\\n    }\\n\\n    /// @notice Transfer mastership of the contract to new master\\n    /// @param _newMaster New masters address\\n    function transferMastership(address _newMaster) external {\\n        requireMaster(msg.sender);\\n        require(_newMaster != address(0), \\\"1d\\\"); // otp11 - new masters address can't be zero address\\n        setMaster(_newMaster);\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/Proxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Upgradeable.sol\\\";\\nimport \\\"./UpgradeableMaster.sol\\\";\\n\\n/// @title Proxy Contract\\n/// @dev NOTICE: Proxy must implement UpgradeableMaster interface to prevent calling some function of it not by master of proxy\\n/// @author Matter Labs\\ncontract Proxy is Upgradeable, Ownable {\\n    /// @dev Storage position of \\\"target\\\" (actual implementation address: keccak256('eip1967.proxy.implementation') - 1)\\n    bytes32 private constant TARGET_POSITION = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /// @notice Contract constructor\\n    /// @dev Calls Ownable contract constructor and initialize target\\n    /// @param target Initial implementation address\\n    /// @param targetInitializationParameters Target initialization parameters\\n    constructor(address target, bytes memory targetInitializationParameters) Ownable(msg.sender) {\\n        setTarget(target);\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool initializationSuccess, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"initialize(bytes)\\\", targetInitializationParameters));\\n        require(initializationSuccess, \\\"uin11\\\"); // uin11 - target initialization failed\\n    }\\n\\n    /// @notice Intercepts initialization calls\\n    function initialize(bytes calldata) external pure {\\n        revert(\\\"ini11\\\"); // ini11 - interception of initialization call\\n    }\\n\\n    /// @notice Intercepts upgrade calls\\n    function upgrade(bytes calldata) external pure {\\n        revert(\\\"upg11\\\"); // upg11 - interception of upgrade call\\n    }\\n\\n    /// @notice Returns target of contract\\n    /// @return target Actual implementation address\\n    function getTarget() public view returns (address target) {\\n        bytes32 position = TARGET_POSITION;\\n        assembly {\\n            target := sload(position)\\n        }\\n    }\\n\\n    /// @notice Sets new target of contract\\n    /// @param _newTarget New actual implementation address\\n    function setTarget(address _newTarget) internal {\\n        bytes32 position = TARGET_POSITION;\\n        assembly {\\n            sstore(position, _newTarget)\\n        }\\n    }\\n\\n    /// @notice Upgrades target\\n    /// @param newTarget New target\\n    /// @param newTargetUpgradeParameters New target upgrade parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetUpgradeParameters) external override {\\n        requireMaster(msg.sender);\\n\\n        setTarget(newTarget);\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool upgradeSuccess, ) = getTarget().delegatecall(abi.encodeWithSignature(\\\"upgrade(bytes)\\\", newTargetUpgradeParameters));\\n        require(upgradeSuccess, \\\"ufu11\\\"); // ufu11 - target upgrade failed\\n    }\\n\\n    /// @notice Performs a delegatecall to the contract implementation\\n    /// @dev Fallback function allowing to perform a delegatecall to the given implementation\\n    /// This function will return whatever the implementation call returns\\n    function _fallback() internal {\\n        address _target = getTarget();\\n        assembly {\\n            // The pointer to the free memory slot\\n            let ptr := mload(0x40)\\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\\n            calldatacopy(ptr, 0x0, calldatasize())\\n            // Delegatecall method of the implementation contract, returns 0 on error\\n            let result := delegatecall(gas(), _target, ptr, calldatasize(), 0x0, 0)\\n            // Get the size of the last return data\\n            let size := returndatasize()\\n            // Copy the size length of bytes from return data at zero position to pointer position\\n            returndatacopy(ptr, 0x0, size)\\n            // Depending on result value\\n            switch result\\n                case 0 {\\n                    // End execution and revert state changes\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    // Return data with length of size at pointers position\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n\\n    /// @notice Will run when no functions matches call data\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    /// @notice Same as fallback but called when calldata is empty\\n    receive() external payable {\\n        _fallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/Upgradeable.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable contract\\n/// @author Matter Labs\\ninterface Upgradeable {\\n    /// @notice Upgrades target of upgradeable contract\\n    /// @param newTarget New target\\n    /// @param newTargetInitializationParameters New target initialization parameters\\n    function upgradeTarget(address newTarget, bytes calldata newTargetInitializationParameters) external;\\n}\\n\"\r\n    },\r\n    \"cache/solpp-generated-contracts/zksync/UpgradeableMaster.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\n\\n\\n/// @title Interface of the upgradeable master contract (defines notice period duration and allows finish upgrade during preparation of it)\\n/// @author Matter Labs\\ninterface UpgradeableMaster {\\n    /// @notice Notice period before activation preparation status of upgrade mode\\n    function getNoticePeriod() external returns (uint256);\\n\\n    /// @notice Checks that contract is ready for upgrade\\n    /// @return bool flag indicating that contract is ready for upgrade\\n    function isReadyForUpgrade() external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"targetInitializationParameters\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"getMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"master\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"transferMastership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"newTargetUpgradeParameters\",\"type\":\"bytes\"}],\"name\":\"upgradeTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bfa352a683d82a04233cc45ac1308621ba63283f00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000100000000000000000000000000eae8e5180eae503e4ffef2f5d48e20164ed41b820000000000000000000000003545fb62209935ab6038f3a1b40403ddffe6e49c00000000000000000000000062351b47e060c61868ab7e05920cb42bd9a5f2b20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015f051753e6e9527e5b77fb7a7e6153767260336f8b9410648870e6702f421e50000000000000000000000000000000000000000000000000000000000000000c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x47d141c450a6c799dae7b150e050486e03637ae5", "SwarmSource": ""}