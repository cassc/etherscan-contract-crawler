{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Contract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\npragma experimental ABIEncoderV2;\\n\\ninterface IERC721Interface {\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\\ncontract DegenDefiAddresses {\\n    struct AddrStruct {\\n        address addr1;\\n        address addr2;\\n        address addr3;\\n    }\\n    address public owner;\\n\\n    IERC721Interface public token =\\n        IERC721Interface(0x7f760C16d3444dC90E04B8249E839e92a44e9F4e);\\n\\n    mapping(address => uint256) addressMap;\\n    mapping(address => bool) blacklistMap;\\n\\n    AddrStruct[] private allAddresses;\\n\\n    // Modifiers here\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only Owner can call this function\\\");\\n        _;\\n    }\\n\\n    modifier notBlacklisted(address addr) {\\n        require(blacklistMap[addr] == false, \\\"Wallet is Blacklisted\\\");\\n        _;\\n    }\\n\\n    modifier nftOwner() {\\n        require(token.balanceOf(msg.sender) > 0, \\\"User does not own the NFT\\\");\\n        _;\\n    }\\n\\n    // Constructor\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    // Owner functions\\n    function changeOwner(address newOwner) external onlyOwner {\\n        owner = newOwner;\\n    }\\n\\n    function changeNftContract(address nftContract) external onlyOwner {\\n        token = IERC721Interface(nftContract);\\n    }\\n\\n    function blacklistWallet(address addr) public onlyOwner {\\n        blacklistMap[addr] = true;\\n    }\\n\\n    function blacklistWipe(address addr) public onlyOwner {\\n        blacklistMap[addr] = false;\\n    }\\n\\n    function ownerUpdateAddresses(\\n        address wallet,\\n        address addr1,\\n        address addr2\\n    ) external onlyOwner {\\n        require(\\n            blacklistMap[wallet] == false,\\n            \\\"Wallet is Blacklisted - You need to unblacklist first\\\"\\n        );\\n        _updateAddresses(wallet, addr1, addr2);\\n    }\\n\\n    // Public functions\\n    function getIndex(address wallet) public view returns (uint256 index) {\\n        return addressMap[wallet];\\n    }\\n\\n    // Write functions\\n    function updateAddress(\\n        address addr,\\n        uint256 addrNum\\n    ) external notBlacklisted(msg.sender) nftOwner {\\n        _updateAddress(msg.sender, addr, addrNum);\\n    }\\n\\n    function _updateAddress(\\n        address wallet,\\n        address addr,\\n        uint256 addrNum\\n    ) internal {\\n        uint256 index = getIndex(wallet);\\n        require(index != 0, \\\"Address has not been added yet\\\");\\n        require(addrNum > 0 && addrNum < 3, \\\"Number can't be greater than 2\\\");\\n        AddrStruct storage item = allAddresses[index - 1];\\n        if (addrNum == 1) item.addr2 = addr;\\n        else item.addr3 = addr;\\n    }\\n\\n    function updateAddresses(\\n        address addr1,\\n        address addr2\\n    ) external notBlacklisted(msg.sender) {\\n        _updateAddresses(msg.sender, addr1, addr2);\\n    }\\n\\n    function _updateAddresses(\\n        address wallet,\\n        address addr1,\\n        address addr2\\n    ) internal {\\n        uint256 index = getIndex(wallet);\\n        // if 0 means it doesn't yet exist so we create a new one and add it to the array\\n        // otherwise we will update the existing one.\\n        if (index == 0) {\\n            uint256 aryLen = allAddresses.length + 1;\\n            AddrStruct memory newStruct = AddrStruct(wallet, addr1, addr2);\\n            allAddresses.push(newStruct);\\n            addressMap[wallet] = aryLen;\\n        } else {\\n            AddrStruct storage item = allAddresses[index - 1];\\n            item.addr1 = wallet;\\n            item.addr2 = addr1;\\n            item.addr3 = addr2;\\n        }\\n    }\\n\\n    // Read functions\\n    function getAddresses(\\n        address wallet\\n    )\\n        public\\n        view\\n        notBlacklisted(wallet)\\n        returns (address addr1, address addr2, address addr3)\\n    {\\n        uint256 index = getIndex(wallet);\\n        if (index == 0) {\\n            return (wallet, address(0), address(0));\\n        }\\n        AddrStruct memory item = allAddresses[index - 1];\\n        return (item.addr1, item.addr2, item.addr3);\\n    }\\n\\n    function showAllAddresses()\\n        external\\n        view\\n        onlyOwner\\n        returns (AddrStruct[] memory)\\n    {\\n        return allAddresses;\\n    }\\n\\n    function getAddressesLength()\\n        external\\n        view\\n        onlyOwner\\n        returns (uint256 length)\\n    {\\n        return allAddresses.length;\\n    }\\n\\n    function getItemAtIndex(\\n        uint256 index\\n    ) external view onlyOwner returns (AddrStruct memory) {\\n        require(\\n            index > 0 && index <= allAddresses.length,\\n            \\\"Index larger than Array\\\"\\n        );\\n        return allAddresses[index - 1];\\n    }\\n\\n    function isNftOwner(address wallet) external view returns (bool) {\\n        return token.balanceOf(wallet) > 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"blacklistWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"blacklistWipe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"changeNftContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr3\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getItemAtIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr3\",\"type\":\"address\"}],\"internalType\":\"struct DegenDefiAddresses.AddrStruct\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isNftOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"}],\"name\":\"ownerUpdateAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showAllAddresses\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr3\",\"type\":\"address\"}],\"internalType\":\"struct DegenDefiAddresses.AddrStruct[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC721Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addrNum\",\"type\":\"uint256\"}],\"name\":\"updateAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"}],\"name\":\"updateAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DegenDefiAddresses", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}