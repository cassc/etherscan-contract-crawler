{"SourceCode": "{\"EIP712Base.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ncontract EIP712Base {\\n\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        address verifyingContract;\\n        bytes32 salt;\\n    }\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes(\\\"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\\\"));\\n\\n    bytes32 internal domainSeparator;\\n\\n    constructor(string memory name, string memory version) {\\n        domainSeparator = keccak256(abi.encode(\\n            EIP712_DOMAIN_TYPEHASH,\\n            keccak256(bytes(name)),\\n            keccak256(bytes(version)),\\n            address(this),\\n            bytes32(getChainID())\\n        ));\\n    }\\n\\n    function getChainID() internal view returns (uint256 id) {\\n        assembly {\\n            id := chainid()\\n        }\\n    }\\n\\n    function getDomainSeparator() private view returns(bytes32) {\\n        return domainSeparator;\\n    }\\n\\n    /**\\n    * Accept message hash and returns hash message in EIP712 compatible form\\n    * So that it can be used to recover signer from signature signed using EIP712 formatted data\\n    * https://eips.ethereum.org/EIPS/eip-712\\n    * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\n    * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\n    */\\n    function toTypedMessageHash(bytes32 messageHash) internal view returns(bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", getDomainSeparator(), messageHash));\\n    }\\n\\n}\\n\"},\"EIP712MetaTransaction.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"./EIP712Base.sol\\\";\\n\\ncontract EIP712MetaTransaction is EIP712Base {\\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(bytes(\\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"));\\n\\n    event MetaTransactionExecuted(address userAddress, address payable relayerAddress, bytes functionSignature);\\n    mapping(address =\\u003e uint256) private nonces;\\n\\n    /*\\n     * Meta transaction structure.\\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\\n     * He should call the desired function directly in that case.\\n     */\\n    struct MetaTransaction {\\n        uint256 nonce;\\n        address from;\\n        bytes functionSignature;\\n    }\\n\\n    constructor(string memory name, string memory version) EIP712Base(name, version) {}\\n\\n    function convertBytesToBytes4(bytes memory inBytes) internal pure returns (bytes4 outBytes4) {\\n        if (inBytes.length == 0) {\\n            return 0x0;\\n        }\\n\\n        assembly {\\n            outBytes4 := mload(add(inBytes, 32))\\n        }\\n    }\\n\\n    function executeMetaTransaction(address userAddress,\\n        bytes memory functionSignature, bytes32 sigR, bytes32 sigS, uint8 sigV) public payable returns(bytes memory) {\\n        bytes4 destinationFunctionSig = convertBytesToBytes4(functionSignature);\\n        require(destinationFunctionSig != msg.sig, \\\"functionSignature can not be of executeMetaTransaction method\\\");\\n        MetaTransaction memory metaTx = MetaTransaction({\\n            nonce: nonces[userAddress],\\n            from: userAddress,\\n            functionSignature: functionSignature\\n        });\\n        require(verify(userAddress, metaTx, sigR, sigS, sigV), \\\"Signer and signature do not match\\\");\\n        nonces[userAddress] += 1;\\n        // Append userAddress at the end to extract it from calling context\\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, userAddress));\\n\\n        require(success, \\\"Function call not successful\\\");\\n        emit MetaTransactionExecuted(userAddress, payable(msg.sender), functionSignature);\\n        return returnData;\\n    }\\n\\n    function hashMetaTransaction(MetaTransaction memory metaTx) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            META_TRANSACTION_TYPEHASH,\\n            metaTx.nonce,\\n            metaTx.from,\\n            keccak256(metaTx.functionSignature)\\n        ));\\n    }\\n\\n    function getNonce(address user) external view returns(uint256 nonce) {\\n        nonce = nonces[user];\\n    }\\n\\n    function verify(address user, MetaTransaction memory metaTx, bytes32 sigR, bytes32 sigS, uint8 sigV) internal view returns (bool) {\\n        address signer = ecrecover(toTypedMessageHash(hashMetaTransaction(metaTx)), sigV, sigR, sigS);\\n        require(signer != address(0), \\\"Invalid signature\\\");\\n        return signer == user;\\n    }\\n\\n    function msgSender() internal view returns(address sender) {\\n        if(msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n            }\\n        } else {\\n            sender = msg.sender;\\n        }\\n        return sender;\\n    }\\n}\\n\"},\"GasSwap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"./EIP712MetaTransaction.sol\\\";\\n\\nstruct Transformation {\\n    uint32 _uint32;\\n    bytes _bytes;\\n}\\n\\ninterface IERC20 {\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\ncontract GasSwap is EIP712MetaTransaction(\\\"GasSwap\\\", \\\"2\\\") {\\n    address public owner;\\n    address public authorizedTarget;\\n\\n    constructor() {\\n        owner = msg.sender;\\n        authorizedTarget = 0xDef1C0ded9bec7F1a1670819833240f027b25EfF;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"ONLY_OWNER\\\");\\n        _;\\n    }\\n\\n    receive() external payable {\\n        require(isContract(msgSender()), \\\"REVERT_EOA_DEPOSIT\\\");\\n    }\\n\\n    function changeOwner(address newOwner)\\n        external\\n        onlyOwner\\n    {\\n        owner = newOwner;\\n    }\\n\\n    function changeTarget(address newTarget)\\n        external\\n        onlyOwner\\n    {\\n        require(isContract(newTarget), \\\"NO_CONTRACT_AT_ADDRESS\\\");\\n        authorizedTarget = newTarget;\\n    }\\n\\n    function withdrawToken(IERC20 token, uint256 amount)\\n        external\\n        onlyOwner\\n    {\\n        require(token.transfer(msg.sender, amount));\\n    }\\n\\n    // Transfer ETH held by this contract to the sender/owner.\\n    function withdrawETH(uint256 amount)\\n        external\\n        onlyOwner\\n    {\\n        payable(msg.sender).transfer(amount);\\n    }\\n\\n    // Swaps ERC20-\\u003eMATIC tokens held by this contract using a 0x-API quote.\\n    function fillQuote(address spender, bytes calldata swapCallData) external returns (uint256)\\n    {\\n        (address inputToken,address outputToken,uint256 inputAmount,uint256 minOutputAmount,) = abi.decode(swapCallData[4:], (address,address,uint256,uint256,Transformation[]));\\n        require(outputToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, \\\"INVALID_OUTPUT_TOKEN\\\");\\n        IERC20 sellToken = IERC20(inputToken);\\n        require(sellToken.transferFrom(msgSender(), address(this), inputAmount), \\\"TRANSFER_FAILED\\\");\\n        require(sellToken.approve(spender, uint256(0)), \\\"APPROVAL_WIPE_FAILED\\\");\\n        require(sellToken.approve(spender, inputAmount), \\\"REAPPROVAL_FAILED\\\");\\n        (bool success, bytes memory res) = authorizedTarget.call(swapCallData);\\n        require(success, string(concat(bytes(\\\"SWAP_FAILED: \\\"),bytes(getRevertMsg(res)))));\\n        uint256 outputTokenAmount = abi.decode(res, (uint256));\\n        require(outputTokenAmount \\u003e= minOutputAmount, \\\"SWAP_VALUE_MISMATCH\\\");\\n        payable(msgSender()).transfer(outputTokenAmount);\\n        return outputTokenAmount;\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory) {\\n        return abi.encodePacked(a, b);\\n    }\\n\\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\n        if (_returnData.length \\u003c 68)\\n            return \\\"Transaction reverted silently\\\";\\n\\n        assembly {\\n            _returnData := add(_returnData, 0x04)\\n        }\\n\\n        return abi.decode(_returnData, (string));\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authorizedTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTarget\",\"type\":\"address\"}],\"name\":\"changeTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"}],\"name\":\"fillQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GasSwap", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://71ed022bfcffe48993c4c21687711f39a825625503c465072af9768cc9db4374"}