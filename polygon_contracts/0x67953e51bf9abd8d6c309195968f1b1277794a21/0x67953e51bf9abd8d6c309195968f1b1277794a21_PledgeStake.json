{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\npragma solidity ^0.8.0;\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function getOwner() external view returns (address);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract PledgeStake {\r\n    using SafeMath for uint256; \r\n    IERC20 public Pledge;\r\n    uint256 private constant baseDivider = 10000;\r\n    uint256 private constant feePercents = 200;              \r\n    uint256 private constant minStake = 50e18;              \r\n    uint256 private constant maxStake = 2000e18;            \r\n    uint256 private constant freezeIncomePercents = 2500;    \r\n    uint256 private constant timeStep = 1 days;              \r\n    uint256 private constant dayPerCycle = 10 days;                \r\n    uint256 private constant dayRewardPercents = 150;                   \r\n    uint256 private constant maxAddFreeze = 40 days;              \r\n    uint256 private constant referDepth = 20;                     \r\n\r\n    uint256 private constant directPercents = 600;\r\n    uint256[4] private level4Percents = [100, 200, 200, 100];\r\n    uint256[15] private level5Percents = [100, 100, 100, 100, 100, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50];\r\n\r\n    uint256 private constant luckPoolPercents = 50;       \r\n    uint256 private constant starPoolPercents = 50;       \r\n    uint256 private constant topPoolPercents = 50;        \r\n\r\n    uint256[7] private balDown = [10e22, 30e22, 100e22, 500e22, 1000e22,1500e22,2000e22];\r\n    uint256[7] private balDownRate = [1000, 1500, 2000, 5000, 6000,7000,8000]; \r\n    uint256[7] private balRecover = [15e22, 50e22, 150e22, 500e22, 1000e22,1500e22, 2000e22];\r\n    mapping(uint256=>bool) public balStatus; // bal=>status\r\n\r\n    address public feeReceiver;\r\n    address public defaultRefer;\r\n    uint256 public startTime;\r\n    uint256 public lastDistribute;\r\n    uint256 public totalUser; \r\n    uint256 public luckPool;\r\n    uint256 public starPool;\r\n    uint256 public topPool;\r\n\r\n    mapping(uint256=>address[]) public dayLuckUsers;\r\n    mapping(uint256=>uint256[]) public dayLuckUsersStake;\r\n    mapping(uint256=>address[3]) public dayTopUsers;\r\n\r\n    address[] public starPoolUsers;\r\n\r\n    struct OrderInfo {\r\n        uint256 amount; \r\n        uint256 start;\r\n        uint256 unfreeze;  // time\r\n        bool isUnfreezed;\r\n    }\r\n\r\n    mapping(address => OrderInfo[]) public orderInfos;\r\n\r\n    address[] public stakers;\r\n\r\n    struct UserInfo {\r\n        address referrer;\r\n        uint256 start;\r\n        uint256 level; // \u03b1, \u03b2, \u03b3, \u03b4, \u03b6,\r\n        uint256 maxStake;\r\n        uint256 totalStake;\r\n        uint256 teamNum;\r\n        uint256 maxDirectStake;\r\n        uint256 teamTotalStake;\r\n        uint256 totalFreezed;\r\n        uint256 totalRevenue;\r\n    }\r\n\r\n    mapping(address=>UserInfo) public userInfo;\r\n    mapping(uint256 => mapping(address => uint256)) public userLayer1DayStake; // day=>user=>amount\r\n    mapping(address => mapping(uint256 => address[])) public teamUsers; \r\n\r\n    struct RewardInfo{\r\n        uint256 capitals;\r\n        uint256 statics;\r\n        uint256 directs;\r\n        uint256 level4Freezed;\r\n        uint256 level4Released;\r\n        uint256 level5Left;\r\n        uint256 level5Freezed;\r\n        uint256 level5Released;\r\n        uint256 star;\r\n        uint256 luck;\r\n        uint256 top;\r\n        uint256 split;\r\n        uint256 splitDebt;\r\n    }\r\n\r\n    struct RewardInfoFor3rdLevel{\r\n        uint256 level3Freezed;\r\n        uint256 level3Released;\r\n    }\r\n\r\n    mapping(address=>RewardInfo) public rewardInfo;\r\n    mapping(address=>RewardInfoFor3rdLevel) public rewardInfoFor3rdLevel;\r\n    \r\n    bool public isFreezeReward;\r\n\r\n    event Register(address user, address referral);\r\n    event Stake(address user, uint256 amount);\r\n    event StakeBySplit(address user, uint256 amount);\r\n    event TransferBySplit(address user, address receiver, uint256 amount);\r\n    event Withdraw(address user, uint256 withdrawable);\r\n\r\n    constructor(address _pledgeAddr, address _defaultRefer, address _feeReceiver) {\r\n        Pledge = IERC20(_pledgeAddr);\r\n        feeReceiver = _feeReceiver;\r\n        startTime = block.timestamp;\r\n        lastDistribute = block.timestamp;\r\n        defaultRefer = _defaultRefer;\r\n    }\r\n\r\n    function register(address _referral) external {\r\n        require(userInfo[_referral].totalStake > 0 || _referral == defaultRefer, \"invalid refer\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.referrer == address(0), \"referrer bonded\");\r\n        user.referrer = _referral;\r\n        user.start = block.timestamp;\r\n        _updateTeamNum(msg.sender);\r\n        totalUser = totalUser.add(1);\r\n        emit Register(msg.sender, _referral);\r\n    }\r\n\r\n    function stake(uint256 _amount) external {\r\n        Pledge.transferFrom(msg.sender, address(this), _amount);\r\n        _stake(msg.sender, _amount);\r\n        emit Stake(msg.sender, _amount);\r\n    }\r\n\r\n    function stakeBySplit(uint256 _amount) external {\r\n        require(_amount >= minStake && _amount.mod(minStake) == 0, \"amount err\");\r\n        require(userInfo[msg.sender].totalStake == 0, \"actived\");\r\n        uint256 splitLeft = getCurSplit(msg.sender);\r\n        require(splitLeft >= _amount, \"insufficient split\");\r\n        rewardInfo[msg.sender].splitDebt = rewardInfo[msg.sender].splitDebt.add(_amount);\r\n        _stake(msg.sender, _amount);\r\n        emit StakeBySplit(msg.sender, _amount);\r\n    }\r\n\r\n    function transferBySplit(address _receiver, uint256 _amount) external {\r\n        require(_amount >= minStake && _amount.mod(minStake) == 0, \"amount err\");\r\n        uint256 splitLeft = getCurSplit(msg.sender);\r\n        require(splitLeft >= _amount, \"insufficient income\");\r\n        rewardInfo[msg.sender].splitDebt = rewardInfo[msg.sender].splitDebt.add(_amount);\r\n        rewardInfo[_receiver].split = rewardInfo[_receiver].split.add(_amount);\r\n        emit TransferBySplit(msg.sender, _receiver, _amount);\r\n    }\r\n\r\n    function distributePoolRewards() public {\r\n        if(block.timestamp > lastDistribute.add(timeStep)){\r\n            uint256 dayNow = getCurDay();\r\n            _distributeStarPool();\r\n\r\n            _distributeLuckPool(dayNow);\r\n\r\n            _distributeTopPool(dayNow);\r\n            lastDistribute = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function withdraw() external {\r\n        distributePoolRewards();\r\n        (uint256 staticReward, uint256 staticSplit) = _calCurStaticRewards(msg.sender);\r\n        uint256 splitAmt = staticSplit;\r\n        uint256 withdrawable = staticReward;\r\n\r\n        (uint256 dynamicReward, uint256 dynamicSplit) = _calCurDynamicRewards(msg.sender);\r\n        withdrawable = withdrawable.add(dynamicReward);\r\n        splitAmt = splitAmt.add(dynamicSplit);\r\n\r\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\r\n        RewardInfoFor3rdLevel storage userRewardFor3rdLevel = rewardInfoFor3rdLevel[msg.sender];\r\n        \r\n        userRewards.split = userRewards.split.add(splitAmt);\r\n\r\n        userRewards.statics = 0;\r\n\r\n        userRewards.directs = 0;\r\n        userRewardFor3rdLevel.level3Released = 0;\r\n        userRewards.level4Released = 0;\r\n        userRewards.level5Released = 0;\r\n        userRewards.luck = 0;\r\n        userRewards.star = 0;\r\n        userRewards.top = 0;\r\n        \r\n        withdrawable = withdrawable.add(userRewards.capitals);\r\n        userRewards.capitals = 0;\r\n        \r\n        Pledge.transfer(msg.sender, withdrawable);\r\n        uint256 bal = Pledge.balanceOf(address(this));\r\n        _setFreezeReward(bal);\r\n\r\n        emit Withdraw(msg.sender, withdrawable);\r\n    }\r\n\r\n    function getCurDay() public view returns(uint256) {\r\n        return (block.timestamp.sub(startTime)).div(timeStep);\r\n    }\r\n\r\n    function getDayLuckLength(uint256 _day) external view returns(uint256) {\r\n        return dayLuckUsers[_day].length;\r\n    }\r\n\r\n    function getTeamUsersLength(address _user, uint256 _layer) external view returns(uint256) {\r\n        return teamUsers[_user][_layer].length;\r\n    }\r\n\r\n    function getOrderLength(address _user) external view returns(uint256) {\r\n        return orderInfos[_user].length;\r\n    }\r\n\r\n    function getStakersLength() external view returns(uint256) {\r\n        return stakers.length;\r\n    }\r\n\r\n    // function geting max user Freeze amount from orderInfos mapping\r\n    function getMaxFreezing(address _user) public view returns(uint256) {\r\n        uint256 maxFreezing; // amount\r\n        for(uint256 i = orderInfos[_user].length; i > 0; i--){\r\n            OrderInfo storage order = orderInfos[_user][i - 1];\r\n            if(order.unfreeze > block.timestamp){\r\n                if(order.amount > maxFreezing){\r\n                    maxFreezing = order.amount;\r\n                }\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n        return maxFreezing;\r\n    }\r\n\r\n    function getTeamStake(address _user) public view returns(uint256, uint256, uint256){\r\n        uint256 totalTeam;\r\n        uint256 maxTeam;\r\n        uint256 otherTeam;\r\n        for(uint256 i = 0; i < teamUsers[_user][0].length; i++){\r\n            uint256 userTotalTeam = userInfo[teamUsers[_user][0][i]].teamTotalStake.add(userInfo[teamUsers[_user][0][i]].totalStake);\r\n            totalTeam = totalTeam.add(userTotalTeam);\r\n            if(userTotalTeam > maxTeam){\r\n                maxTeam = userTotalTeam;\r\n            }\r\n        }\r\n        otherTeam = totalTeam.sub(maxTeam);\r\n        return(maxTeam, otherTeam, totalTeam);\r\n    }\r\n\r\n    function getCurSplit(address _user) public view returns(uint256){\r\n        (, uint256 staticSplit) = _calCurStaticRewards(_user);\r\n        (, uint256 dynamicSplit) = _calCurDynamicRewards(_user);\r\n        return rewardInfo[_user].split.add(staticSplit).add(dynamicSplit).sub(rewardInfo[_user].splitDebt);\r\n    }\r\n\r\n    function _calCurStaticRewards(address _user) private view returns(uint256, uint256) {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        uint256 totalRewards = userRewards.statics;\r\n        uint256 splitAmt = totalRewards.mul(freezeIncomePercents).div(baseDivider);\r\n        uint256 withdrawable = totalRewards.sub(splitAmt);\r\n        return(withdrawable, splitAmt);\r\n    }\r\n\r\n    function _calCurDynamicRewards(address _user) private view returns(uint256, uint256) {\r\n        RewardInfo storage userRewards = rewardInfo[_user];\r\n        RewardInfoFor3rdLevel storage user3rdLevelRewards = rewardInfoFor3rdLevel[_user];\r\n        uint256 totalRewards = userRewards.directs.add(user3rdLevelRewards.level3Released).add(userRewards.level4Released).add(userRewards.level5Released);\r\n        totalRewards = totalRewards.add(userRewards.luck.add(userRewards.star).add(userRewards.top));\r\n        uint256 splitAmt = totalRewards.mul(freezeIncomePercents).div(baseDivider);\r\n        uint256 withdrawable = totalRewards.sub(splitAmt);\r\n        return(withdrawable, splitAmt);\r\n    }\r\n\r\n    function _updateTeamNum(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\r\n                teamUsers[upline][i].push(_user);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateTopUser(address _user, uint256 _amount, uint256 _dayNow) private {\r\n        userLayer1DayStake[_dayNow][_user] = userLayer1DayStake[_dayNow][_user].add(_amount);\r\n        bool updated;\r\n        for(uint256 i = 0; i < 3; i++){\r\n            address topUser = dayTopUsers[_dayNow][i];\r\n            if(topUser == _user){\r\n                _reOrderTop(_dayNow);\r\n                updated = true;\r\n                break;\r\n            }\r\n        }\r\n        if(!updated){\r\n            address lastUser = dayTopUsers[_dayNow][2];\r\n            if(userLayer1DayStake[_dayNow][lastUser] < userLayer1DayStake[_dayNow][_user]){\r\n                dayTopUsers[_dayNow][2] = _user;\r\n                _reOrderTop(_dayNow);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _reOrderTop(uint256 _dayNow) private {\r\n        for(uint256 i = 3; i > 1; i--){\r\n            address topUser1 = dayTopUsers[_dayNow][i - 1];\r\n            address topUser2 = dayTopUsers[_dayNow][i - 2];\r\n            uint256 amount1 = userLayer1DayStake[_dayNow][topUser1];\r\n            uint256 amount2 = userLayer1DayStake[_dayNow][topUser2];\r\n            if(amount1 > amount2){\r\n                dayTopUsers[_dayNow][i - 1] = topUser2;\r\n                dayTopUsers[_dayNow][i - 2] = topUser1;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _removeInvalidStake(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                if(userInfo[upline].teamTotalStake > _amount){\r\n                    userInfo[upline].teamTotalStake = userInfo[upline].teamTotalStake.sub(_amount);\r\n                }else{\r\n                    userInfo[upline].teamTotalStake = 0;\r\n                }\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateReferInfo(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                userInfo[upline].teamTotalStake = userInfo[upline].teamTotalStake.add(_amount);\r\n                _updateLevel(upline);\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // this function will update user's level on Stake\r\n    function _updateLevel(address _user) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 levelNow = _calLevelNow(_user);\r\n        if(levelNow > user.level){\r\n            user.level = levelNow;\r\n            if(levelNow == 5 || levelNow == 4 || levelNow == 3) {\r\n                starPoolUsers.push(_user);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _calLevelNow(address _user) private view returns(uint256) {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 total = user.totalStake;\r\n        uint256 levelNow;\r\n        if(total >= 1000e18){\r\n            (uint256 maxTeam, uint256 otherTeam, ) = getTeamStake(_user);\r\n            if(total >= 2000e18 && user.teamNum >= 200 && maxTeam >= 50000e18 && otherTeam >= 50000e18){\r\n                levelNow = 5;\r\n            }else if(user.teamNum >= 50 && maxTeam >= 10000e18 && otherTeam >= 10000e18){\r\n                levelNow = 4;\r\n            }else if(user.teamNum >= 25 && maxTeam >= 5000e18 && otherTeam >= 5000e18){\r\n                levelNow = 3;\r\n            } else {\r\n                levelNow = 2;\r\n            }\r\n        }else if(total >= 500e18){\r\n            levelNow = 2;\r\n        }else if(total >= 50e18){\r\n            levelNow = 1;\r\n        }\r\n\r\n        return levelNow;\r\n    }\r\n\r\n    function _stake(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        require(user.referrer != address(0), \"register first\");\r\n        require(_amount >= minStake, \"less than min\");\r\n        require(_amount.mod(minStake) == 0 && _amount >= minStake, \"mod err\");\r\n        require(user.maxStake == 0 || _amount >= user.maxStake, \"less before\");\r\n\r\n        if(user.maxStake == 0){\r\n            user.maxStake = _amount;\r\n        }else if(user.maxStake < _amount){\r\n            user.maxStake = _amount;\r\n        }\r\n\r\n        _distributeStake(_amount);\r\n\r\n        if(user.totalStake == 0){\r\n            uint256 dayNow = getCurDay();\r\n            dayLuckUsers[dayNow].push(_user);\r\n            dayLuckUsersStake[dayNow].push(_amount);\r\n\r\n            _updateTopUser(user.referrer, _amount, dayNow);\r\n        }\r\n\r\n        stakers.push(_user);\r\n        \r\n        user.totalStake = user.totalStake.add(_amount);\r\n        user.totalFreezed = user.totalFreezed.add(_amount);\r\n\r\n        _updateLevel(msg.sender);\r\n\r\n        uint256 addFreeze = (orderInfos[_user].length.div(2)).mul(timeStep);\r\n        if(addFreeze > maxAddFreeze){\r\n            addFreeze = maxAddFreeze;\r\n        }\r\n\r\n        // this will return 10 + addFreeze amount of days\r\n        uint256 unfreezeTime = block.timestamp.add(dayPerCycle).add(addFreeze);\r\n        orderInfos[_user].push(OrderInfo(\r\n            _amount, \r\n            block.timestamp, \r\n            unfreezeTime,\r\n            false\r\n        ));\r\n\r\n        // At first time User Stake. if statement in below func didnt called\r\n        _unfreezeFundAndUpdateReward(msg.sender, _amount);\r\n\r\n        // Reward will be distributed to Star, Luck, Top Pools after 1 Day Period\r\n        distributePoolRewards();\r\n\r\n        _updateReferInfo(msg.sender, _amount);\r\n\r\n        // this function is setting level freeze rewards \r\n        // for all referrer\r\n        _updateReward(msg.sender, _amount);\r\n\r\n        // this func will release Freezed rewards\r\n        _releaseUpRewards(msg.sender, _amount);\r\n\r\n        uint256 bal = Pledge.balanceOf(address(this));\r\n        _balActived(bal);\r\n        if(isFreezeReward){\r\n            _setFreezeReward(bal);\r\n        }\r\n    }\r\n\r\n    function _unfreezeFundAndUpdateReward(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        bool isUnfreezeCapital;\r\n        for(uint256 i = 0; i < orderInfos[_user].length; i++){\r\n            OrderInfo storage order = orderInfos[_user][i];\r\n            if(block.timestamp > order.unfreeze  && order.isUnfreezed == false && _amount >= order.amount){\r\n                order.isUnfreezed = true;\r\n                isUnfreezeCapital = true;\r\n                \r\n                if(user.totalFreezed > order.amount){\r\n                    user.totalFreezed = user.totalFreezed.sub(order.amount);\r\n                }else {\r\n                    user.totalFreezed = 0;\r\n                }\r\n                \r\n                _removeInvalidStake(_user, order.amount);\r\n\r\n                uint256 staticReward = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDivider);\r\n                if(isFreezeReward){\r\n                    if(user.totalFreezed > user.totalRevenue){\r\n                        uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\r\n                        if(staticReward > leftCapital){\r\n                            staticReward = leftCapital;\r\n                        }\r\n                    }else{\r\n                        staticReward = 0;\r\n                    }\r\n                }\r\n                rewardInfo[_user].capitals = rewardInfo[_user].capitals.add(order.amount);\r\n\r\n                rewardInfo[_user].statics = rewardInfo[_user].statics.add(staticReward);\r\n                \r\n                user.totalRevenue = user.totalRevenue.add(staticReward);\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(!isUnfreezeCapital){ \r\n            RewardInfo storage userReward = rewardInfo[_user];\r\n            if(userReward.level5Freezed > 0){\r\n                uint256 release = _amount;\r\n                if(_amount >= userReward.level5Freezed){\r\n                    release = userReward.level5Freezed;\r\n                }\r\n                userReward.level5Freezed = userReward.level5Freezed.sub(release);\r\n                userReward.level5Released = userReward.level5Released.add(release);\r\n                user.totalRevenue = user.totalRevenue.add(release);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _distributeStarPool() private {\r\n        uint256 level4Count;\r\n        for(uint256 i = 0; i < starPoolUsers.length; i++){\r\n            if(userInfo[starPoolUsers[i]].level == 4 || userInfo[starPoolUsers[i]].level == 3){\r\n                level4Count = level4Count.add(1);\r\n            }\r\n        }\r\n        if(level4Count > 0){\r\n            uint256 reward = starPool.div(level4Count);\r\n            uint256 totalReward;\r\n            for(uint256 i = 0; i < starPoolUsers.length; i++){\r\n                if(userInfo[starPoolUsers[i]].level == 5 || userInfo[starPoolUsers[i]].level == 4 || userInfo[starPoolUsers[i]].level == 3){\r\n                    rewardInfo[starPoolUsers[i]].star = rewardInfo[starPoolUsers[i]].star.add(reward);\r\n                    userInfo[starPoolUsers[i]].totalRevenue = userInfo[starPoolUsers[i]].totalRevenue.add(reward);\r\n                    totalReward = totalReward.add(reward);\r\n                }\r\n            }\r\n            if(starPool > totalReward){\r\n                starPool = starPool.sub(totalReward);\r\n            }else{\r\n                starPool = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _distributeLuckPool(uint256 _dayNow) private {\r\n        uint256 dayStakeCount = dayLuckUsers[_dayNow - 1].length;\r\n        if(dayStakeCount > 0){\r\n            uint256 checkCount = 10;\r\n            if(dayStakeCount < 10){\r\n                checkCount = dayStakeCount;\r\n            }\r\n            uint256 totalStake;\r\n            uint256 totalReward;\r\n            for(uint256 i = dayStakeCount; i > dayStakeCount.sub(checkCount); i--){\r\n                totalStake = totalStake.add(dayLuckUsersStake[_dayNow - 1][i - 1]);\r\n            }\r\n\r\n            for(uint256 i = dayStakeCount; i > dayStakeCount.sub(checkCount); i--){\r\n                address userAddr = dayLuckUsers[_dayNow - 1][i - 1];\r\n                if(userAddr != address(0)){\r\n                    uint256 reward = luckPool.mul(dayLuckUsersStake[_dayNow - 1][i - 1]).div(totalStake);\r\n                    totalReward = totalReward.add(reward);\r\n                    rewardInfo[userAddr].luck = rewardInfo[userAddr].luck.add(reward);\r\n                    userInfo[userAddr].totalRevenue = userInfo[userAddr].totalRevenue.add(reward);\r\n                }\r\n            }\r\n            if(luckPool > totalReward){\r\n                luckPool = luckPool.sub(totalReward);\r\n            }else{\r\n                luckPool = 0;\r\n            }\r\n        }\r\n    }\r\n                                        \r\n    function _distributeTopPool(uint256 _dayNow) private {                          \r\n        uint16[3] memory rates = [5000, 3000, 2000];\r\n        uint72[3] memory maxReward = [2000e18, 1000e18, 500e18];\r\n        uint256 totalReward;\r\n        for(uint256 i = 0; i < 3; i++){\r\n            address userAddr = dayTopUsers[_dayNow - 1][i];\r\n            if(userAddr != address(0)){\r\n                uint256 reward = topPool.mul(rates[i]).div(baseDivider);\r\n                if(reward > maxReward[i]){\r\n                    reward = maxReward[i];\r\n                }\r\n                rewardInfo[userAddr].top = rewardInfo[userAddr].top.add(reward);\r\n                userInfo[userAddr].totalRevenue = userInfo[userAddr].totalRevenue.add(reward);\r\n                totalReward = totalReward.add(reward);\r\n            }\r\n        }\r\n        if(topPool > totalReward){\r\n            topPool = topPool.sub(totalReward);\r\n        }else{\r\n            topPool = 0;\r\n        }\r\n    }\r\n\r\n    function _distributeStake(uint256 _amount) private {\r\n        uint256 fee = _amount.mul(feePercents).div(baseDivider);\r\n        Pledge.transfer(feeReceiver, fee);\r\n        uint256 luck = _amount.mul(luckPoolPercents).div(baseDivider);\r\n        luckPool = luckPool.add(luck);\r\n        uint256 star = _amount.mul(starPoolPercents).div(baseDivider);\r\n        starPool = starPool.add(star);\r\n        uint256 top = _amount.mul(topPoolPercents).div(baseDivider);\r\n        topPool = topPool.add(top);\r\n    }\r\n\r\n    function _updateReward(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                uint256 newAmount = _amount;\r\n                if(upline != defaultRefer){\r\n                    uint256 maxFreezing = getMaxFreezing(upline);\r\n                    if(maxFreezing < _amount){\r\n                        newAmount = maxFreezing;\r\n                    }\r\n                }\r\n                RewardInfo storage upRewards = rewardInfo[upline];\r\n                RewardInfoFor3rdLevel storage thirdLevelReward = rewardInfoFor3rdLevel[upline];\r\n                uint256 reward;\r\n                if(i > 4){\r\n                    if(userInfo[upline].level > 4){\r\n                        reward = newAmount.mul(level5Percents[i - 5]).div(baseDivider);\r\n                        upRewards.level5Freezed = upRewards.level5Freezed.add(reward);\r\n                    }\r\n                }else if(i > 2) { // changed 3 to 2\r\n                    if( userInfo[upline].level > 3) {\r\n                        reward = newAmount.mul(level4Percents[i - 1]).div(baseDivider);\r\n                        upRewards.level4Freezed = upRewards.level4Freezed.add(reward);\r\n                    } \r\n                }else if(i > 0){\r\n                    if( userInfo[upline].level > 2) {\r\n                        reward = newAmount.mul(level4Percents[i - 1]).div(baseDivider);\r\n                        thirdLevelReward.level3Freezed = thirdLevelReward.level3Freezed.add(reward);\r\n                    }\r\n                }else{\r\n                    reward = newAmount.mul(directPercents).div(baseDivider);\r\n                    upRewards.directs = upRewards.directs.add(reward);\r\n                    userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\r\n                }\r\n                if(upline == defaultRefer) break;\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _releaseUpRewards(address _user, uint256 _amount) private {\r\n        UserInfo storage user = userInfo[_user];\r\n        address upline = user.referrer;\r\n        for(uint256 i = 0; i < referDepth; i++){\r\n            if(upline != address(0)){\r\n                uint256 newAmount = _amount;\r\n                if(upline != defaultRefer){\r\n                    uint256 maxFreezing = getMaxFreezing(upline);\r\n                    if(maxFreezing < _amount){\r\n                        newAmount = maxFreezing;\r\n                    }\r\n                }\r\n\r\n                RewardInfo storage upRewards = rewardInfo[upline];\r\n                RewardInfoFor3rdLevel storage thirdLevelReward = rewardInfoFor3rdLevel[upline];\r\n\r\n                if(i > 0 && i < 4 && userInfo[upline].level > 2){\r\n                    if(thirdLevelReward.level3Freezed > 0) {\r\n                        uint256 level3Reward = newAmount.mul(level4Percents[i - 1]).div(baseDivider);\r\n                        if(level3Reward > thirdLevelReward.level3Freezed){\r\n                            level3Reward = thirdLevelReward.level3Freezed;\r\n                        }\r\n                        thirdLevelReward.level3Freezed = thirdLevelReward.level3Freezed.sub(level3Reward); \r\n                        thirdLevelReward.level3Released = thirdLevelReward.level3Released.add(level3Reward);\r\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(level3Reward);\r\n                    }\r\n                }\r\n\r\n                if(i > 0 && i < 5 && userInfo[upline].level > 3) {\r\n                    if(upRewards.level4Freezed > 0){\r\n                        uint256 level4Reward = newAmount.mul(level4Percents[i - 1]).div(baseDivider);\r\n                        if(level4Reward > upRewards.level4Freezed){\r\n                            level4Reward = upRewards.level4Freezed;\r\n                        }\r\n                        upRewards.level4Freezed = upRewards.level4Freezed.sub(level4Reward); \r\n                        upRewards.level4Released = upRewards.level4Released.add(level4Reward);\r\n                        userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(level4Reward);\r\n                    }\r\n                }\r\n\r\n                if(i >= 5 && userInfo[upline].level > 4){\r\n                    if(upRewards.level5Left > 0){\r\n                        uint256 level5Reward = newAmount.mul(level5Percents[i - 5]).div(baseDivider);\r\n                        if(level5Reward > upRewards.level5Left){\r\n                            level5Reward = upRewards.level5Left;\r\n                        }\r\n                        upRewards.level5Left = upRewards.level5Left.sub(level5Reward); \r\n                        upRewards.level5Freezed = upRewards.level5Freezed.add(level5Reward);\r\n                    }\r\n                }\r\n                upline = userInfo[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _balActived(uint256 _bal) private {\r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n            if(_bal >= balDown[i - 1]){\r\n                balStatus[balDown[i - 1]] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setFreezeReward(uint256 _bal) private {\r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n            if(balStatus[balDown[i - 1]]){\r\n                uint256 maxDown = balDown[i - 1].mul(balDownRate[i - 1]).div(baseDivider);\r\n                if(_bal < balDown[i - 1].sub(maxDown)){\r\n                    isFreezeReward = true;\r\n                }else if(isFreezeReward && _bal >= balRecover[i - 1]){\r\n                    isFreezeReward = false;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pledgeAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Pledge\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayLuckUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayLuckUsersStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayTopUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePoolRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getCurSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getDayLuckLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxFreezing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFreezeReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"luckPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level4Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level4Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5Left\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level5Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"star\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luck\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"top\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"splitDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfoFor3rdLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"level3Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level3Released\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"starPoolUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDirectStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLayer1DayStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PledgeStake", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000036392e6e21920ac9b864512ec7aea7a8353ff560000000000000000000000008a3c4f92ac0b6e95f795fa2542c0aa917409a773000000000000000000000000c3ba2e20b9d2787ac5ae04d54095d7920a246ca0", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://83d3aaee1061fbab6e796d90b6634bad36dd5382a7b4a1885e0f11f8fe812e66"}