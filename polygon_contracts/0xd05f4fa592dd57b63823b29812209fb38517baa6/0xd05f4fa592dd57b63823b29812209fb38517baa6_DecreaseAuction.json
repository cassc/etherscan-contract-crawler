{"SourceCode": "// File: token/IERC721TokenReceiver.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n// File: utils/ISetter.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface ISetter {\r\n\r\n    /// @dev Interface of function setTokenToUsable of ELFCore.\r\n    function setTokenToUsable(uint256 tokenId, address addr) external;\r\n}\r\n// File: utils/IGetter.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IGetter {\r\n\r\n    /// @dev Interface used by server to check who can use the _tokenId.\r\n    function getUser(address _nftAddress,uint256 _tokenId) external view returns (address);\r\n    \r\n    /// @dev Interface used by server to check who can claim coin B earned by _tokenId.\r\n    function getCoinB(address _nftAddress,uint256 _tokenId) external view returns (address);\r\n}\r\n// File: token/IERC721.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n// File: security/AccessControl.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ncontract AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant NO_PERMISSION='no permission';\r\n    string constant INVALID_ADDRESS ='invalid address';\r\n    \r\n    /// @dev Administrator with highest authority. Should be a multisig wallet.\r\n    address payable superAdmin;\r\n\r\n    /// @dev Administrator of this contract.\r\n    address payable admin;\r\n\r\n    /// Sets the original admin and superAdmin of the contract to the sender account.\r\n    constructor(){\r\n        superAdmin=payable(msg.sender);\r\n        admin=payable(msg.sender);\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the superAdmin.\r\n    modifier onlySuperAdmin{\r\n        require(msg.sender==superAdmin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the admin.\r\n    modifier onlyAdmin{\r\n        require(msg.sender==admin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change superAdmin.\r\n    /// @param addr The address to transfer the right of superAdmin to.\r\n    function changeSuperAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        superAdmin=addr;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change admin.\r\n    /// @param addr The address to transfer the right of admin to.\r\n    function changeAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        admin=addr;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to withdraw balance.\r\n    function withdrawBalance(uint256 amount) external onlySuperAdmin{\r\n        superAdmin.transfer(amount);\r\n    }\r\n\r\n    fallback() external {}\r\n}\r\n// File: security/Pausable.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\ncontract Pausable is AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant PAUSED='paused';\r\n    string constant NOT_PAUSED='not paused';\r\n\r\n    /// @dev Keeps track whether the contract is paused. When this is true, most actions are blocked.\r\n    bool public paused = false;\r\n\r\n    /// @dev Modifier to allow actions only when the contract is not paused\r\n    modifier whenNotPaused {\r\n        require(!paused,PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract is paused\r\n    modifier whenPaused {\r\n        require(paused,NOT_PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to pause the contract. Used when something goes wrong\r\n    ///  and we need to limit damage.\r\n    function pause() external onlySuperAdmin whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the superAdmin.\r\n    function unpause() external onlySuperAdmin whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n// File: DecreaseAuction.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Clock auction for non-fungible tokens.\r\ncontract DecreaseAuction is Pausable, IGetter, IERC721TokenReceiver {\r\n    /// @dev Value should be returned when we transfer NFT to a contract via safeTransferFrom.\r\n    bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Seller of NFT\r\n        address seller;\r\n        // TokenId\r\n        uint256 id;\r\n        // Price (in wei) at beginning of auction\r\n        uint256 startingPrice;\r\n        // Price (in wei) at end of auction\r\n        uint256 endingPrice;\r\n        // Duration (in seconds) of auction\r\n        uint256 duration;\r\n        // Time when auction started. 0 if this auction has been concluded\r\n        uint256 startedAt;\r\n    }\r\n\r\n    Auction[] Auctions;\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public constant ownerCut = 9475;\r\n\r\n    mapping(uint256 => uint256) idToIndex;\r\n    mapping(uint256 => bool) idExist;\r\n\r\n    address public immutable ELFCoreAddress;\r\n\r\n    event AuctionCreated(\r\n        address indexed _seller,\r\n        uint256 indexed _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _startAt\r\n    );\r\n\r\n    event AuctionSuccessful(\r\n        uint256 indexed _tokenId,\r\n        uint256 _dealPrice,\r\n        address _winner\r\n    );\r\n\r\n    event AuctionCanceled(uint256 indexed _tokenId, address canceller);\r\n\r\n    modifier validId(uint256 id) {\r\n        require(idExist[id], \"token not on sale\");\r\n        _;\r\n    }\r\n\r\n    constructor(address addr) {\r\n        ELFCoreAddress = addr;\r\n    }\r\n\r\n    /// @dev Interface used by server to check who can use the _tokenId.\r\n    function getUser(address _nftAddress, uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        validId(_tokenId)\r\n        returns (address)\r\n    {\r\n        return Auctions[idToIndex[_tokenId]].seller;\r\n    }\r\n\r\n    /// @dev Interface used by server to check who can claim coin B earned by _tokenId.\r\n    function getCoinB(address _nftAddress, uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        validId(_tokenId)\r\n        returns (address)\r\n    {\r\n        return Auctions[idToIndex[_tokenId]].seller;\r\n    }\r\n\r\n    function getAuctions() external view returns (Auction[] memory) {\r\n        return Auctions;\r\n    }\r\n\r\n    /// @dev Returns auction info of an NFT on auction.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function getOneAuction(uint256 _tokenId)\r\n        external\r\n        view\r\n        validId(_tokenId)\r\n        returns (\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        Auction memory _auction = Auctions[idToIndex[_tokenId]];\r\n        uint256 price = _getCurrentPrice(_auction);\r\n        return (\r\n            _auction.seller,\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            _auction.startedAt,\r\n            price\r\n        );\r\n    }\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of time to move between starting\r\n    ///  price and ending price (in seconds).\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    ) external whenNotPaused {\r\n        address _seller = msg.sender;\r\n        require(_owns(_seller, _tokenId), NO_PERMISSION);\r\n        require(_duration <= 2592000, \"duration shuold less than 720 hours\");\r\n        Auction memory _auction = Auction(\r\n            _seller,\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            block.timestamp\r\n        );\r\n        idToIndex[_tokenId] = Auctions.length;\r\n        idExist[_tokenId] = true;\r\n        Auctions.push(_auction);\r\n        _escrow(_seller, _tokenId);\r\n        emit AuctionCreated(\r\n            _seller,\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            block.timestamp\r\n        );\r\n        ISetter sc = ISetter(ELFCoreAddress);\r\n        sc.setTokenToUsable(_tokenId, msg.sender);\r\n    }\r\n\r\n    /// @dev Bids on an open auction, completing the auction and transferring\r\n    ///  ownership of the NFT if enough Matic is supplied.\r\n    /// @param _tokenId - ID of token to bid on.\r\n    function bid(uint256 _tokenId)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n        validId(_tokenId)\r\n    {\r\n        // _bid will throw if the bid or funds transfer fails\r\n        _bid(_tokenId, msg.value);\r\n        _transfer(msg.sender, _tokenId);\r\n    }\r\n\r\n    /// @dev Cancels an auction that hasn't been won yet.\r\n    ///  Returns the NFT to original owner.\r\n    /// @notice This is a state-modifying function that can't\r\n    ///  be called while the contract is paused.\r\n    /// @param _tokenId - ID of token on auction\r\n    function cancelAuction(uint256 _tokenId)\r\n        external\r\n        validId(_tokenId)\r\n        whenNotPaused\r\n    {\r\n        address seller = Auctions[idToIndex[_tokenId]].seller;\r\n        require(msg.sender == seller, NO_PERMISSION);\r\n        _cancelAuction(_tokenId, seller);\r\n    }\r\n\r\n    /// @dev Cancels an auction when the contract is paused.\r\n    ///  Only the owner may do this, and NFTs are returned to\r\n    ///  the seller. This should only be used in emergencies.\r\n    /// @param _tokenId - ID of the NFT on auction to cancel.\r\n    function cancelAuctionWhenPaused(uint256 _tokenId)\r\n        external\r\n        whenPaused\r\n        onlyAdmin\r\n        validId(_tokenId)\r\n    {\r\n        _cancelAuction(_tokenId, Auctions[idToIndex[_tokenId]].seller);\r\n    }\r\n\r\n    /// @dev Gets the NFT contract instance from an address, validating that implementsERC721 is true.\r\n    function _getNftContract()\r\n        internal\r\n        view\r\n        returns (IERC721 candidateContract)\r\n    {\r\n        candidateContract = IERC721(ELFCoreAddress);\r\n    }\r\n\r\n    /// @dev Returns current price of an NFT on auction.\r\n    function _getCurrentPrice(Auction memory _auction)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 _secondsPassed = block.timestamp - _auction.startedAt;\r\n\r\n        return\r\n            _computeCurrentPrice(\r\n                _auction.startingPrice,\r\n                _auction.endingPrice,\r\n                _auction.duration,\r\n                _secondsPassed\r\n            );\r\n    }\r\n\r\n    /// @dev Computes the current price of an auction.\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    ) internal pure returns (uint256) {\r\n        if (_secondsPassed >= _duration || _duration == 0) {\r\n            return _endingPrice;\r\n        }\r\n        uint256 hr_pass = _secondsPassed / 3600;\r\n        uint256 _currentPrice;\r\n        if (_startingPrice >= _endingPrice) {\r\n            uint256 _totalPriceChange = _startingPrice - _endingPrice;\r\n            uint256 _priceChange = (_totalPriceChange * 3600) / _duration;\r\n            _currentPrice = _startingPrice - (hr_pass * _priceChange);\r\n        } else {\r\n            uint256 _totalPriceChange = _endingPrice - _startingPrice;\r\n            uint256 _priceChange = (_totalPriceChange * 3600) / _duration;\r\n            _currentPrice = _startingPrice + (hr_pass * _priceChange);\r\n        }\r\n        return _currentPrice;\r\n    }\r\n\r\n    /// @dev Returns true if the claimant owns the token.\r\n    /// @param _claimant - Address claiming to own the token.\r\n    /// @param _tokenId - ID of token whose ownership to verify.\r\n    function _owns(address _claimant, uint256 _tokenId)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        IERC721 _nftContract = _getNftContract();\r\n        return (_nftContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /// @dev Removes an auction from the list of open auctions.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function _removeAuction(uint256 _tokenId) internal {\r\n        delete idExist[_tokenId];\r\n        uint256 index = idToIndex[_tokenId];\r\n        uint256 lastIndex = Auctions.length - 1;\r\n        Auction memory _auction = Auctions[lastIndex];\r\n        Auctions[index] = _auction;\r\n        idToIndex[_auction.id] = index;\r\n        delete idToIndex[_tokenId];\r\n        Auctions.pop();\r\n    }\r\n\r\n    /// @dev Cancels an auction unconditionally.\r\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_tokenId);\r\n        _transfer(_seller, _tokenId);\r\n        emit AuctionCanceled(_tokenId, msg.sender);\r\n    }\r\n\r\n    /// @dev Escrows the NFT, assigning ownership to this contract.\r\n    /// Throws if the escrow fails.\r\n    /// @param _owner - Current owner address of token to escrow.\r\n    /// @param _tokenId - ID of token whose approval to verify.\r\n    function _escrow(address _owner, uint256 _tokenId) private {\r\n        IERC721 _nftContract = _getNftContract();\r\n        _nftContract.transferFrom(_owner, address(this), _tokenId);\r\n    }\r\n\r\n    /// @dev Transfers an NFT owned by this contract to another address.\r\n    /// Returns true if the transfer succeeds.\r\n    /// @param _receiver - Address to transfer NFT to.\r\n    /// @param _tokenId - ID of token to transfer.\r\n    function _transfer(address _receiver, uint256 _tokenId) internal {\r\n        IERC721 _nftContract = _getNftContract();\r\n        _nftContract.transferFrom(address(this), _receiver, _tokenId);\r\n    }\r\n\r\n    /// @dev Computes owner's cut of a sale.\r\n    /// @param _price - Sale price of NFT.\r\n    function _computeCut(uint256 _price) internal pure returns (uint256) {\r\n        return (_price * ownerCut) / 10000;\r\n    }\r\n\r\n    /// @dev Computes the price and transfers winnings.\r\n    /// Does NOT transfer ownership of token.\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount) internal {\r\n        Auction memory _auction = Auctions[idToIndex[_tokenId]];\r\n        require(msg.sender != _auction.seller, NO_PERMISSION);\r\n        uint256 _price = _getCurrentPrice(_auction);\r\n        require(_bidAmount >= _price, \"matic not enough\");\r\n        address payable _seller = payable(_auction.seller);\r\n        _removeAuction(_tokenId);\r\n        uint256 _sellerProceeds = _computeCut(_price);\r\n        _seller.transfer(_sellerProceeds);\r\n        if (_bidAmount > _price) {\r\n            uint256 _bidExcess = _bidAmount - _price;\r\n            payable(msg.sender).transfer(_bidExcess);\r\n        }\r\n        emit AuctionSuccessful(_tokenId, _price, msg.sender);\r\n    }\r\n\r\n    /// @dev Required for ERC721TokenReceiver compliance.\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external pure override returns (bytes4) {\r\n        return MAGIC_ON_ERC721_RECEIVED;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"canceller\",\"type\":\"address\"}],\"name\":\"AuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startAt\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_dealPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ELFCoreAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuctions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"internalType\":\"struct DecreaseAuction.Auction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCoinB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getOneAuction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DecreaseAuction", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fcd60b2d8acbc3869cbe1ddcda60d0a92da2d4cb", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5d435058e3b6822c724e13d962ce263cb3061fd07f469ed38f79b4cc893fbab5"}