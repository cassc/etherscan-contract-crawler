{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\ncontract LiquidityAdder {\r\n\r\n    function removeLiquidityETH(address router, address token, uint256 amountLP, uint256 tokenMin, uint256 ETHMin) external {\r\n\r\n        // fetch LP address\r\n        address LP = IUniswapV2Factory(IUniswapV2Router02(router).factory()).getPair(token, IUniswapV2Router02(router).WETH());\r\n\r\n        // transfer in LP tokens\r\n        uint256 amountLPReceived = _transferIn(LP, amountLP);\r\n\r\n        // approve LP tokens for router\r\n        IERC20(LP).approve(router, amountLPReceived);\r\n\r\n        // remove liquidity\r\n        IUniswapV2Router02(router).removeLiquidityETH(\r\n            token,\r\n            amountLPReceived,\r\n            tokenMin,\r\n            ETHMin,\r\n            address(this),\r\n            block.timestamp + 100\r\n        );\r\n\r\n        // transfer ETH + tokens to sender\r\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(s, 'ETH Send Failure');\r\n    }\r\n\r\n    function removeLiquidity(address router, address token0, address token1, uint256 amountLP, uint256 token0Min, uint256 token1Min) external {\r\n        \r\n        // fetch LP address\r\n        address LP = IUniswapV2Factory(IUniswapV2Router02(router).factory()).getPair(token0, token1);\r\n\r\n        // transfer in LP tokens\r\n        uint256 amountLPReceived = _transferIn(LP, amountLP);\r\n\r\n        // approve LP tokens for router\r\n        IERC20(LP).approve(router, amountLPReceived);\r\n\r\n        // remove liquidity\r\n        IUniswapV2Router02(router).removeLiquidity(\r\n            token0,\r\n            token1,\r\n            amountLPReceived,\r\n            token0Min,\r\n            token1Min,\r\n            address(this),\r\n            block.timestamp + 100\r\n        );\r\n\r\n        // transfer tokens to sender\r\n        IERC20(token0).transfer(msg.sender, IERC20(token0).balanceOf(address(this)));\r\n        IERC20(token1).transfer(msg.sender, IERC20(token1).balanceOf(address(this)));\r\n    }\r\n\r\n    function addLiquidityETH(address router, address token, uint256 amount, uint256 minToken, uint256 minETH) external payable {\r\n\r\n        // transfer in token\r\n        uint256 amountReceived = _transferIn(token, amount);\r\n\r\n        // approve token for router\r\n        IERC20(token).approve(router, amountReceived);\r\n\r\n        // add liquidity\r\n        IUniswapV2Router02(router).addLiquidityETH{value: msg.value}(\r\n            token,\r\n            amountReceived,\r\n            minToken,\r\n            minETH,\r\n            msg.sender,\r\n            block.timestamp + 100\r\n        );\r\n\r\n        // refund dust\r\n        if (IERC20(token).balanceOf(address(this)) > 0) {\r\n            IERC20(token).transfer(\r\n                msg.sender,\r\n                IERC20(token).balanceOf(address(this))\r\n            );\r\n        }\r\n        if (address(this).balance > 0) {\r\n            (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n            require(s, 'ETH Dust Failure');\r\n        }\r\n    }\r\n\r\n    function addLiquidity(address router, address token0, address token1, uint256 amount0, uint256 amount1, uint256 min0, uint256 min1) external {\r\n\r\n        // transfer in tokens\r\n        uint256 amount0Received = _transferIn(token0, amount0);\r\n        uint256 amount1Received = _transferIn(token1, amount1);\r\n\r\n        // approve router\r\n        IERC20(token0).approve(router, amount0Received);\r\n        IERC20(token1).approve(router, amount1Received);\r\n\r\n        // add liquidity\r\n        IUniswapV2Router02(router).addLiquidity(\r\n            token0,\r\n            token1,\r\n            amount0Received,\r\n            amount1Received,\r\n            min0,\r\n            min1,\r\n            msg.sender,\r\n            block.timestamp + 100\r\n        );\r\n\r\n        // refund dust\r\n        if (IERC20(token0).balanceOf(address(this)) > 0) {\r\n            IERC20(token0).transfer(\r\n                msg.sender,\r\n                IERC20(token0).balanceOf(address(this))\r\n            );\r\n        }\r\n\r\n        // refund dust\r\n        if (IERC20(token1).balanceOf(address(this)) > 0) {\r\n            IERC20(token1).transfer(\r\n                msg.sender,\r\n                IERC20(token1).balanceOf(address(this))\r\n            );\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _transferIn(address token, uint256 amount) internal returns (uint256) {\r\n        require(\r\n            IERC20(token).balanceOf(msg.sender) >= amount,\r\n            'Insufficient Balance'\r\n        );\r\n        require(\r\n            IERC20(token).allowance(msg.sender, address(this)) >= amount,\r\n            'Insufficient Allowance'\r\n        );\r\n\r\n        uint256 before = IERC20(token).balanceOf(address(this));\r\n        require(\r\n            IERC20(token).transferFrom(msg.sender, address(this), amount),\r\n            'ERR TransferFrom'\r\n        );\r\n        uint256 After = IERC20(token).balanceOf(address(this));\r\n        require(\r\n            After > before,\r\n            'Zero Received'\r\n        );\r\n        unchecked { \r\n            return After - before; \r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min1\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minETH\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Min\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ETHMin\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LiquidityAdder", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://00655df5700edad2b65a38ed0c5f8fab4e6050b7e0136474a9453a533322a248"}