{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OtterLake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// import 'hardhat/console.sol';\\n\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IPearlNote.sol';\\nimport './interfaces/IStakingDistributor.sol';\\nimport './interfaces/IOtterLake.sol';\\n\\nimport './libraries/SafeMath.sol';\\nimport './libraries/SafeERC20.sol';\\n\\nimport './types/Pausable.sol';\\nimport './types/ReentrancyGuard.sol';\\n\\n// @dev: Modified from: https://docs.synthetix.io/contracts/source/contracts/stakingrewards\\ncontract OtterLake is IOtterLake, ReentrancyGuard, Pausable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    struct Term {\\n        IPearlNote note;\\n        uint256 minLockAmount;\\n        uint256 lockPeriod;\\n        uint16 multiplier; // 100 = x1, 120 = x1.2\\n        bool enabled;\\n    }\\n\\n    struct Epoch {\\n        uint256 length;\\n        uint256 number;\\n        uint256 endTime;\\n        uint256 totalReward; // accumulated rewards\\n        uint256 reward;\\n        uint256 totalLocked;\\n        uint256 rewardPerBoostPoint;\\n    }\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IERC20 public immutable pearl;\\n    IStakingDistributor public distributor;\\n    bool public finalized;\\n\\n    uint256 _epoch;\\n    mapping(uint256 => Epoch) public epochs;\\n    // epoch -> unlocked boost points\\n    mapping(uint256 => uint256) public unlockedBoostPoints;\\n\\n    // note address -> term\\n    mapping(address => Term) public terms;\\n    address[] public termAddresses;\\n\\n    // note address -> token id -> reward paid\\n    mapping(address => mapping(uint256 => uint256))\\n        public rewardPerBoostPointPaid;\\n    // note address  -> token id -> reward\\n    mapping(address => mapping(uint256 => uint256)) public rewards;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address pearl_,\\n        uint256 epochLength_,\\n        uint256 firstEpochNumber_,\\n        uint256 firstEpochEndTime_\\n    ) {\\n        require(pearl_ != address(0));\\n        pearl = IERC20(pearl_);\\n\\n        epochs[firstEpochNumber_] = Epoch({\\n            length: epochLength_,\\n            number: firstEpochNumber_,\\n            endTime: firstEpochEndTime_,\\n            totalReward: 0,\\n            reward: 0,\\n            totalLocked: 0,\\n            rewardPerBoostPoint: 0\\n        });\\n        _epoch = firstEpochNumber_;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function epoch() external view override returns (uint256) {\\n        return _epoch;\\n    }\\n\\n    function totalLocked() external view returns (uint256) {\\n        return epochs[_epoch].totalLocked;\\n    }\\n\\n    function balanceOf(address noteAddr, uint256 tokenId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return terms[noteAddr].note.lockAmount(tokenId);\\n    }\\n\\n    function termsCount() external view returns (uint256) {\\n        return termAddresses.length;\\n    }\\n\\n    function totalBoostPoint(address owner)\\n        external\\n        view\\n        returns (uint256 sum)\\n    {\\n        for (uint256 i = 0; i < termAddresses.length; i++) {\\n            IPearlNote note = terms[termAddresses[i]].note;\\n            uint256 balance = note.balanceOf(owner);\\n            for (uint256 j = 0; j < balance; j++) {\\n                uint256 tokenId = note.tokenOfOwnerByIndex(owner, j);\\n                if (note.endEpoch(tokenId) > _epoch) {\\n                    sum = sum.add(\\n                        boostPointOf(\\n                            address(note),\\n                            note.tokenOfOwnerByIndex(owner, j)\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n    }\\n\\n    function boostPointOf(address noteAddr, uint256 tokenId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        Term memory term = terms[noteAddr];\\n        return term.note.lockAmount(tokenId).mul(term.multiplier).div(100);\\n    }\\n\\n    function validEpoch(address noteAddr, uint256 tokenId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        IPearlNote note = terms[noteAddr].note;\\n        return\\n            _epoch < note.endEpoch(tokenId)\\n                ? _epoch\\n                : note.endEpoch(tokenId).sub(1);\\n    }\\n\\n    function rewardPerBoostPoint(address noteAddr, uint256 tokenId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        // console.log(\\n        //     'reward/point: %s, paid: %s',\\n        //     epochs[e].rewardPerBoostPoint,\\n        //     rewardPerBoostPointPaid[noteAddr][tokenId]\\n        // );\\n        return\\n            epochs[validEpoch(noteAddr, tokenId)].rewardPerBoostPoint.sub(\\n                rewardPerBoostPointPaid[noteAddr][tokenId]\\n            );\\n    }\\n\\n    function reward(address noteAddr, uint256 tokenId)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            rewards[noteAddr][tokenId].add(_pendingReward(noteAddr, tokenId));\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function lock(address noteAddr, uint256 amount)\\n        external\\n        nonReentrant\\n        notPaused\\n    {\\n        // console.log(\\n        //     'lock epoch: %s term: %s: amount: %s',\\n        //     _epoch,\\n        //     termIndex,\\n        //     amount\\n        // );\\n        harvest();\\n\\n        Term memory term = terms[noteAddr];\\n        require(amount > 0, 'OtterLake: cannot lock 0 amount');\\n        require(term.enabled, 'PearVault: term disabled');\\n        require(\\n            amount >= term.minLockAmount,\\n            'OtterLake: amount < min lock amount'\\n        );\\n        pearl.safeTransferFrom(msg.sender, address(this), amount);\\n        pearl.safeApprove(address(term.note), amount);\\n        uint256 endEpoch = _epoch.add(term.lockPeriod);\\n        uint256 tokenId = term.note.mint(msg.sender, amount, endEpoch);\\n\\n        rewardPerBoostPointPaid[noteAddr][tokenId] = epochs[_epoch]\\n            .rewardPerBoostPoint;\\n        uint256 boostPoint = boostPointOf(noteAddr, tokenId);\\n        epochs[_epoch].totalLocked = epochs[_epoch].totalLocked.add(boostPoint);\\n        unlockedBoostPoints[endEpoch] = unlockedBoostPoints[endEpoch].add(\\n            boostPoint\\n        );\\n\\n        emit Locked(msg.sender, noteAddr, tokenId, amount);\\n    }\\n\\n    function extendLock(\\n        address noteAddr,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) public nonReentrant notPaused {\\n        harvest();\\n\\n        Term memory term = terms[noteAddr];\\n        require(amount > 0, 'OtterLake: cannot lock 0 amount');\\n        require(term.enabled, 'PearVault: term disabled');\\n        require(\\n            terms[noteAddr].note.ownerOf(tokenId) == msg.sender,\\n            'OtterLake: msg.sender is not the note owner'\\n        );\\n        uint256 prevEndEpoch = term.note.endEpoch(tokenId);\\n        require(prevEndEpoch > _epoch, 'OtterLake: the note is expired');\\n        _updateReward(noteAddr, tokenId);\\n\\n        pearl.safeTransferFrom(msg.sender, address(this), amount);\\n        pearl.safeApprove(address(term.note), amount);\\n\\n        uint256 prevBoostPoint = term\\n            .note\\n            .lockAmount(tokenId)\\n            .mul(term.multiplier)\\n            .div(100);\\n\\n        uint256 endEpoch = _epoch.add(term.lockPeriod);\\n        term.note.extendLock(tokenId, amount, endEpoch);\\n\\n        uint256 boostPoint = boostPointOf(noteAddr, tokenId);\\n        epochs[_epoch].totalLocked = epochs[_epoch].totalLocked.add(\\n            amount.mul(term.multiplier).div(100)\\n        );\\n        unlockedBoostPoints[prevEndEpoch] = unlockedBoostPoints[prevEndEpoch]\\n            .sub(prevBoostPoint);\\n        unlockedBoostPoints[endEpoch] = unlockedBoostPoints[endEpoch].add(\\n            boostPoint\\n        );\\n\\n        emit Locked(msg.sender, noteAddr, tokenId, amount);\\n    }\\n\\n    function claimAndLock(address noteAddr, uint256 tokenId) external {\\n        uint256 extendingReward = claimReward(noteAddr, tokenId);\\n        // console.log('claim and lock: %s', extendingReward);\\n        extendLock(noteAddr, tokenId, extendingReward);\\n    }\\n\\n    function redeem(address noteAddr, uint256 tokenId) public nonReentrant {\\n        harvest();\\n\\n        Term memory term = terms[noteAddr];\\n        require(\\n            terms[noteAddr].note.ownerOf(tokenId) == msg.sender,\\n            'OtterLake: msg.sender is not the note owner'\\n        );\\n        uint256 amount = term.note.burn(tokenId);\\n\\n        emit Redeemed(msg.sender, noteAddr, tokenId, amount);\\n    }\\n\\n    function claimReward(address noteAddr, uint256 tokenId)\\n        public\\n        nonReentrant\\n        returns (uint256)\\n    {\\n        harvest();\\n\\n        require(\\n            terms[noteAddr].note.ownerOf(tokenId) == msg.sender,\\n            'OtterLake: msg.sender is not the note owner'\\n        );\\n        uint256 claimableReward = _updateReward(noteAddr, tokenId);\\n        // uint256 reward = pendingReward(termIndex, tokenId);\\n        if (claimableReward > 0) {\\n            // console.log('reward: %s', claimableReward);\\n            rewards[noteAddr][tokenId] = 0;\\n            pearl.transfer(msg.sender, claimableReward);\\n            emit RewardPaid(msg.sender, noteAddr, tokenId, claimableReward);\\n            return claimableReward;\\n        }\\n        return 0;\\n    }\\n\\n    function exit(address note, uint256 tokenId) external {\\n        claimReward(note, tokenId);\\n        redeem(note, tokenId);\\n    }\\n\\n    function harvest() public {\\n        if (epochs[_epoch].endTime <= block.timestamp) {\\n            Epoch storage e = epochs[_epoch];\\n            if (e.totalLocked > 0) {\\n                e.rewardPerBoostPoint = e\\n                    .totalReward\\n                    .sub(epochs[_epoch.sub(1)].totalReward)\\n                    .mul(1e18)\\n                    .div(e.totalLocked)\\n                    .add(epochs[_epoch.sub(1)].rewardPerBoostPoint);\\n            } else {\\n                e.totalReward = e.totalReward.sub(e.reward);\\n            }\\n            // console.log(\\n            //     'distributed epoch: %s locked: %s reward/point: %s',\\n            //     _epoch,\\n            //     e.totalLocked,\\n            //     e.rewardPerBoostPoint\\n            // );\\n\\n            uint256 current = pearl.balanceOf(address(this));\\n            distributor.distribute();\\n            uint256 epochReward = pearl.balanceOf(address(this)).sub(current);\\n\\n            // advance to next epoch\\n            _epoch = _epoch.add(1);\\n            epochs[_epoch] = Epoch({\\n                length: e.length,\\n                number: _epoch,\\n                endTime: e.endTime.add(e.length),\\n                totalReward: e.totalReward.add(epochReward),\\n                reward: epochReward,\\n                totalLocked: e.totalLocked.sub(unlockedBoostPoints[_epoch]),\\n                rewardPerBoostPoint: e.rewardPerBoostPoint\\n            });\\n            // console.log(\\n            //     'start epoch: %s locked: %s reward: %s',\\n            //     _epoch,\\n            //     epochs[_epoch].totalLocked,\\n            //     epochReward\\n            // );\\n        }\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function _updateReward(address noteAddr, uint256 tokenId)\\n        internal\\n        returns (uint256)\\n    {\\n        rewards[noteAddr][tokenId] = rewards[noteAddr][tokenId].add(\\n            _pendingReward(noteAddr, tokenId)\\n        );\\n        rewardPerBoostPointPaid[noteAddr][tokenId] = epochs[\\n            validEpoch(noteAddr, tokenId)\\n        ].rewardPerBoostPoint;\\n        return rewards[noteAddr][tokenId];\\n    }\\n\\n    function _pendingReward(address noteAddr, uint256 tokenId)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            boostPointOf(noteAddr, tokenId)\\n                .mul(rewardPerBoostPoint(noteAddr, tokenId))\\n                .div(1e18);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setDistributor(address distributor_) external onlyOwner {\\n        distributor = IStakingDistributor(distributor_);\\n    }\\n\\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\\n        external\\n        onlyOwner\\n    {\\n        if (finalized) {\\n            // @dev if something wrong, dev can extract reward to recover the lose\\n            require(\\n                tokenAddress != address(pearl),\\n                'OtterLake: Cannot withdraw the pearl'\\n            );\\n        }\\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\\n        emit Recovered(tokenAddress, tokenAmount);\\n    }\\n\\n    function finalize() external onlyOwner {\\n        finalized = true;\\n    }\\n\\n    function addTerm(\\n        address note_,\\n        uint256 minLockAmount_,\\n        uint256 lockPeriod_,\\n        uint16 multiplier_\\n    ) public onlyOwner {\\n        require(\\n            multiplier_ < 1000,\\n            'OtterLake: multiplier cannot larger than x10'\\n        );\\n        require(\\n            terms[note_].multiplier == 0,\\n            'OtterLake: duplicate note added'\\n        );\\n        IPearlNote note = IPearlNote(note_);\\n        // @dev: check the note address is valid\\n        note.lockAmount(0);\\n        terms[note_] = Term({\\n            note: note,\\n            minLockAmount: minLockAmount_,\\n            lockPeriod: lockPeriod_,\\n            multiplier: multiplier_,\\n            enabled: true\\n        });\\n        termAddresses.push(note_);\\n        emit TermAdded(note_, minLockAmount_, lockPeriod_, multiplier_);\\n    }\\n\\n    enum TERM_SETTING {\\n        MIN_LOCK_AMOUNT,\\n        LOCK_PERIOD\\n    }\\n\\n    function setTerm(\\n        address note_,\\n        TERM_SETTING setting_,\\n        uint256 value_\\n    ) external onlyOwner {\\n        if (setting_ == TERM_SETTING.MIN_LOCK_AMOUNT) {\\n            // 0\\n            terms[note_].minLockAmount = value_;\\n        } else if (setting_ == TERM_SETTING.LOCK_PERIOD) {\\n            // 1\\n            terms[note_].lockPeriod = value_;\\n        }\\n        emit TermUpdated(note_, setting_, value_);\\n    }\\n\\n    function disableTerm(address note_) external onlyOwner {\\n        terms[note_].enabled = false;\\n        emit TermDisabled(note_);\\n    }\\n\\n    function removeTermAt(uint256 index) external onlyOwner {\\n        require(index < termAddresses.length);\\n        address termAddress = termAddresses[index];\\n        address note = address(terms[termAddress].note);\\n\\n        // delete from map\\n        delete terms[termAddress];\\n\\n        // delete from array\\n        termAddresses[index] = termAddresses[termAddresses.length - 1];\\n        delete termAddresses[termAddresses.length - 1];\\n\\n        emit TermRemoved(note);\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event TermAdded(\\n        address indexed note,\\n        uint256 minLockAmount,\\n        uint256 lockPeriod,\\n        uint16 multiplier\\n    );\\n    event TermDisabled(address indexed note);\\n    event TermRemoved(address indexed note);\\n    event TermUpdated(\\n        address indexed note,\\n        TERM_SETTING setting,\\n        uint256 value\\n    );\\n    event RewardAdded(uint256 epoch, uint256 reward);\\n    event Locked(\\n        address indexed user,\\n        address indexed note,\\n        uint256 indexed tokenId,\\n        uint256 amount\\n    );\\n    event Redeemed(\\n        address indexed user,\\n        address indexed note,\\n        uint256 indexed tokenId,\\n        uint256 amount\\n    );\\n    event RewardPaid(\\n        address indexed user,\\n        address indexed note,\\n        uint256 indexed tokenId,\\n        uint256 reward\\n    );\\n    event Recovered(address token, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC20Mintable {\\n    function mint(uint256 amount_) external;\\n\\n    function mint(address account_, uint256 ammount_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPearlNote.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity >=0.7.5;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol';\\n\\ninterface IPearlNote is IERC721Enumerable {\\n    function lockAmount(uint256 tokenId) external view returns (uint256);\\n\\n    function endEpoch(uint256 tokenId) external view returns (uint256);\\n\\n    /// @dev Extend the NFT lock period\\n    /// @param _tokenId the token id need to extend\\n    /// @param _amount The extra lock amount\\n    /// @param _endEpoch The lock due date\\n    function extendLock(\\n        uint256 _tokenId,\\n        uint256 _amount,\\n        uint256 _endEpoch\\n    ) external;\\n\\n    /// @dev Mint a new ERC721 to represent receipt of lock\\n    /// @param _user The locker, who will receive this token\\n    /// @param _amount The lock amount\\n    /// @param _endEpoch The lock due date\\n    /// @return token id minted\\n    function mint(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _endEpoch\\n    ) external returns (uint256);\\n\\n    /// @dev Burn the NFT and get token locked inside back\\n    /// @param tokenId the token id which got burned\\n    /// @return the amount of unlocked token\\n    function burn(uint256 tokenId) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity 0.7.5;\\n\\ninterface IStakingDistributor {\\n    function distribute() external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOtterLake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ninterface IOtterLake {\\n    function epoch() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, 'SafeMath: addition overflow');\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, 'SafeMath: subtraction overflow');\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, 'SafeMath: division by zero');\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\\n        if (a > 3) {\\n            c = a;\\n            uint256 b = add(div(a, 2), 1);\\n            while (b < c) {\\n                c = b;\\n                b = div(add(div(a, b), b), 2);\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport '../interfaces/IERC20.sol';\\n\\nimport './SafeMath.sol';\\nimport './Counters.sol';\\nimport './Address.sol';\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            'SafeERC20: approve from non-zero to non-zero allowance'\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(\\n            value\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\\n            value,\\n            'SafeERC20: decreased allowance below zero'\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            'SafeERC20: low-level call failed'\\n        );\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                'SafeERC20: ERC20 operation did not succeed'\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/types/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/contracts/pausable\\nabstract contract Pausable is Ownable {\\n    uint public lastPauseTime;\\n    bool public paused;\\n\\n    constructor() {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(_owner != address(0), \\\"Owner must be set\\\");\\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\\n    }\\n\\n    /**\\n     * @notice Change the paused state of the contract\\n     * @dev Only the contract owner may call this.\\n     */\\n    function setPaused(bool _paused) external onlyOwner {\\n        // Ensure we're actually changing the state before we do anything\\n        if (_paused == paused) {\\n            return;\\n        }\\n\\n        // Set our paused state.\\n        paused = _paused;\\n\\n        // If applicable, set the last pause time.\\n        if (paused) {\\n            lastPauseTime = block.timestamp;\\n        }\\n\\n        // Let everyone know that our pause state has changed.\\n        emit PauseChanged(paused);\\n    }\\n\\n    event PauseChanged(bool isPaused);\\n\\n    modifier notPaused {\\n        require(!paused, \\\"This action cannot be performed while the contract is paused\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/types/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\\n\\npragma solidity 0.7.5;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nimport './SafeMath.sol';\\n\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            'Address: insufficient balance'\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}('');\\n        require(\\n            success,\\n            'Address: unable to send value, recipient may have reverted'\\n        );\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, 'Address: low-level call failed');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'Address: low-level call with value failed'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'Address: insufficient balance for call'\\n        );\\n        require(isContract(target), 'Address: call to non-contract');\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 weiValue,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        require(isContract(target), 'Address: call to non-contract');\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\\n            data\\n        );\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                'Address: low-level static call failed'\\n            );\\n    }\\n\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), 'Address: static call to non-contract');\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionDelegateCall(\\n                target,\\n                data,\\n                'Address: low-level delegate call failed'\\n            );\\n    }\\n\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), 'Address: delegate call to non-contract');\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function addressToString(address _address)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes32 _bytes = bytes32(uint256(_address));\\n        bytes memory HEX = '0123456789abcdef';\\n        bytes memory _addr = new bytes(42);\\n\\n        _addr[0] = '0';\\n        _addr[1] = 'x';\\n\\n        for (uint256 i = 0; i < 20; i++) {\\n            _addr[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\\n            _addr[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\\n        }\\n\\n        return string(_addr);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/types/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n\\n    function renounceManagement() external;\\n\\n    function pushManagement(address newOwner_) external;\\n\\n    function pullManagement() external;\\n}\\n\\ncontract Ownable is IOwnable {\\n    address internal _owner;\\n    address internal _newOwner;\\n\\n    event OwnershipPushed(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n    event OwnershipPulled(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        _owner = msg.sender;\\n        emit OwnershipPushed(address(0), _owner);\\n    }\\n\\n    function owner() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, 'Ownable: caller is not the owner');\\n        _;\\n    }\\n\\n    function renounceManagement() public virtual override onlyOwner {\\n        emit OwnershipPushed(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function pushManagement(address newOwner_)\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n    {\\n        require(\\n            newOwner_ != address(0),\\n            'Ownable: new owner is the zero address'\\n        );\\n        emit OwnershipPushed(_owner, newOwner_);\\n        _newOwner = newOwner_;\\n    }\\n\\n    function pullManagement() public virtual override {\\n        require(msg.sender == _newOwner, 'Ownable: must be new owner to pull');\\n        emit OwnershipPulled(_owner, _newOwner);\\n        _owner = _newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pearl_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"epochLength_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstEpochNumber_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstEpochEndTime_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"note\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"note\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"note\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"note\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minLockAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"multiplier\",\"type\":\"uint16\"}],\"name\":\"TermAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"note\",\"type\":\"address\"}],\"name\":\"TermDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"note\",\"type\":\"address\"}],\"name\":\"TermRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"note\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum OtterLake.TERM_SETTING\",\"name\":\"setting\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TermUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"note_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minLockAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockPeriod_\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"multiplier_\",\"type\":\"uint16\"}],\"name\":\"addTerm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"boostPointOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimAndLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"note_\",\"type\":\"address\"}],\"name\":\"disableTerm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributor\",\"outputs\":[{\"internalType\":\"contract IStakingDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBoostPoint\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"note\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"extendLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pearl\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"pushManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeTermAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"rewardPerBoostPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardPerBoostPointPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"distributor_\",\"type\":\"address\"}],\"name\":\"setDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"note_\",\"type\":\"address\"},{\"internalType\":\"enum OtterLake.TERM_SETTING\",\"name\":\"setting_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"}],\"name\":\"setTerm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"termAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"contract IPearlNote\",\"name\":\"note\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minLockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"multiplier\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"termsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"totalBoostPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unlockedBoostPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"noteAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"validEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OtterLake", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000052a7f40bb6e9bd9183071cdbdd3a977d713f2e34000000000000000000000000000000000000000000000000000000000000708000000000000000000000000000000000000000000000000000000000000000cf0000000000000000000000000000000000000000000000000000000061dc5800", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}