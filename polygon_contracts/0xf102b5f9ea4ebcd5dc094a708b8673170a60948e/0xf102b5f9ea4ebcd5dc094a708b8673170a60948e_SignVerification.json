{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/other/verification/SignVerification.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n * This program has been developed by students from the bachelor Computer Science at Utrecht University within the Software Project course.\\r\\n * \u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)\\r\\n */\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {GenericSignatureHelper} from \\\"../../utils/GenericSignatureHelper.sol\\\";\\r\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SignVerification\\r\\n * @author Utrecht University\\r\\n * @notice This contracat requires a signer to provide proof of verification with a certain offchain service (example: GitHub) and assigns the respecitve stamp to the address.\\r\\n */\\r\\ncontract SignVerification is GenericSignatureHelper, Ownable {\\r\\n    // Map from user to their stamps\\r\\n    mapping(address => Stamp[]) internal stamps;\\r\\n    // Map from userhash to address to make sure the userhash isn't already used by another address\\r\\n    mapping(string => address) internal stampHashMap;\\r\\n    // Map to show if an address has ever been verified\\r\\n    mapping(address => bool) internal isMember;\\r\\n    address[] allMembers;\\r\\n\\r\\n    /// @notice The thresholdHistory array stores the history of the verifyThreshold variable. This is needed because we might want to check if some stamps were valid in the past.\\r\\n    Threshold[] thresholdHistory;\\r\\n\\r\\n    /// @notice The reverifyThreshold determines how long a user has to wait before they can re-verify their address, in days\\r\\n    uint reverifyThreshold;\\r\\n\\r\\n    /// @notice The signer is the address that can sign proofs of verification\\r\\n    address _signer;\\r\\n\\r\\n    /// @notice A stamp defines proof of verification for a user on a specific platform at a specific date\\r\\n    struct Stamp {\\r\\n        string providerId; // Unique id for the provider (github, proofofhumanity, etc.)\\r\\n        string userHash; // Hash of some unique user data of the provider (username, email, etc.)\\r\\n        uint[] verifiedAt; // Block number at which the user has verified\\r\\n    }\\r\\n\\r\\n    /// @notice A threshold defines the number of days for which a stamp is valid\\r\\n    struct Threshold {\\r\\n        uint blockNumber; // Block number at which the threshold was set\\r\\n        uint threshold; // Number of blocks for which a stamp is valid\\r\\n    }\\r\\n\\r\\n    /// @notice Initializes the owner of the contract\\r\\n    constructor(uint _threshold, uint _reverifyThreshold, address signer_) {\\r\\n        thresholdHistory.push(Threshold(block.number, _threshold));\\r\\n        reverifyThreshold = _reverifyThreshold;\\r\\n        _signer = signer_;\\r\\n    }\\r\\n\\r\\n    /// @notice This function can only be called by the owner, and it verifies an address. It's not possible to re-verify an address before half the verifyThreshold has passed.\\r\\n    /// @dev Verifies an address\\r\\n    /// @param _toVerify The address to verify\\r\\n    /// @param _userHash The hash of the user's unique data on the provider (username, email, etc.)\\r\\n    /// @param _timestamp The block number at which the proof was generated\\r\\n    /// @param _providerId Unique id for the provider (github, proofofhumanity, etc.)\\r\\n    /// @param _proofSignature The proof signed by the server\\r\\n    function verifyAddress(\\r\\n        address _toVerify,\\r\\n        string calldata _userHash,\\r\\n        uint _timestamp,\\r\\n        string calldata _providerId,\\r\\n        bytes calldata _proofSignature\\r\\n    ) external {\\r\\n        require(\\r\\n            stampHashMap[_userHash] == address(0) ||\\r\\n                stampHashMap[_userHash] == _toVerify,\\r\\n            \\\"ID already affiliated with another address\\\"\\r\\n        );\\r\\n\\r\\n        require(_toVerify != address(0), \\\"Address cannot be 0x0\\\");\\r\\n        require(\\r\\n            block.timestamp < _timestamp + 1 hours,\\r\\n            \\\"Proof expired, try verifying again\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            verify(_signer, keccak256(abi.encodePacked(_toVerify, _userHash, _timestamp, _providerId)), _proofSignature),\\r\\n            \\\"Proof is not valid\\\"\\r\\n        );\\r\\n\\r\\n        // Check if there is existing stamp with providerId\\r\\n        bool found; // = false;\\r\\n        uint foundIndex; // = 0;\\r\\n\\r\\n        for (uint i; i < stamps[_toVerify].length; ) {\\r\\n            if (\\r\\n                keccak256(abi.encodePacked(stamps[_toVerify][i].providerId)) ==\\r\\n                keccak256(abi.encodePacked(_providerId))\\r\\n            ) {\\r\\n                found = true;\\r\\n                foundIndex = i;\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!found) {\\r\\n            // Check if this is the first time this user has verified so we can add them to the allMembers list\\r\\n            if (!isMember[_toVerify]) {\\r\\n                isMember[_toVerify] = true;\\r\\n                allMembers.push(_toVerify);\\r\\n            }\\r\\n\\r\\n            // Create new stamp if user does not already have a stamp for this providerId\\r\\n            stamps[_toVerify].push(\\r\\n                createStamp(_providerId, _userHash, block.number)\\r\\n            );\\r\\n\\r\\n            // This only needs to happens once (namely the first time an account verifies)\\r\\n            stampHashMap[_userHash] = _toVerify;\\r\\n        } else {\\r\\n            // If user already has a stamp for this providerId\\r\\n            // Check how long it has been since the last verification\\r\\n            uint[] storage verifiedAt = stamps[_toVerify][foundIndex]\\r\\n                .verifiedAt;\\r\\n            uint blocksSinceLastVerification = block.number -\\r\\n                verifiedAt[verifiedAt.length - 1];\\r\\n\\r\\n            // If it has been more than reverifyThreshold days, update the stamp\\r\\n            if (blocksSinceLastVerification > reverifyThreshold) {\\r\\n                // Overwrite the userHash (in case the user changed their username or used another account to reverify)\\r\\n                stamps[_toVerify][foundIndex].userHash = _userHash;\\r\\n                verifiedAt.push(block.number);\\r\\n            } else {\\r\\n                revert(\\r\\n                    \\\"Address already verified; cannot re-verify yet, wait at least half the verifyThreshold\\\"\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Unverifies a provider from the sender\\r\\n    /// @param _providerId Unique id for the provider (github, proofofhumanity, etc.) to be removed\\r\\n    function unverify(string calldata _providerId) external {\\r\\n        // Assume all is good in the world\\r\\n        Stamp[] storage stampsAt = stamps[msg.sender];\\r\\n\\r\\n        // Look up the corresponding stamp for the provider\\r\\n        for (uint i; i < stampsAt.length; ) {\\r\\n            if (stringsAreEqual(stampsAt[i].providerId, _providerId)) {\\r\\n                // Remove the mapping from userhash to address\\r\\n                stampHashMap[stampsAt[i].userHash] = address(0);\\r\\n\\r\\n                // Remove stamp from stamps array (we don't care about order so we can just swap and pop)\\r\\n                stampsAt[i] = stampsAt[stampsAt.length - 1];\\r\\n                stampsAt.pop();\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        revert(\\r\\n            \\\"Could not find this provider among your stamps; are you sure you're verified with this provider?\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Solidity doesn't support string comparison, so we use keccak256 to compare strings\\r\\n    function stringsAreEqual(\\r\\n        string memory str1,\\r\\n        string memory str2\\r\\n    ) internal pure returns (bool) {\\r\\n        return\\r\\n            keccak256(abi.encodePacked(str1)) ==\\r\\n            keccak256(abi.encodePacked(str2));\\r\\n    }\\r\\n\\r\\n    /// @notice Creates a stamp for a user\\r\\n    /// @param _providerId Unique id for the provider (github, proofofhumanity, etc.)\\r\\n    /// @param _userHash Unique user hash on the platform of the stamp (GH, PoH, etc.)\\r\\n    /// @param _blockNumber Block number at which the proof was submitted\\r\\n    /// @return Stamp Returns the created stamp\\r\\n    function createStamp(\\r\\n        string memory _providerId,\\r\\n        string memory _userHash,\\r\\n        uint _blockNumber\\r\\n    ) internal returns (Stamp memory) {\\r\\n        uint[] memory verifiedAt = new uint[](1);\\r\\n        verifiedAt[0] = _blockNumber;\\r\\n        Stamp memory stamp = Stamp(_providerId, _userHash, verifiedAt);\\r\\n        stampHashMap[_userHash] = msg.sender;\\r\\n        return stamp;\\r\\n    }\\r\\n\\r\\n    /// @notice This function returns the stamps of an address\\r\\n    /// @param _toCheck The address to check\\r\\n    /// @return An array of stamps\\r\\n    function getStamps(\\r\\n        address _toCheck\\r\\n    ) external view returns (Stamp[] memory) {\\r\\n        return stamps[_toCheck];\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the *valid* stamps of an address at a specific block number\\r\\n    /// @param _toCheck The address to check\\r\\n    /// @param _blockNumber The block number to check\\r\\n    function getStampsAt(\\r\\n        address _toCheck,\\r\\n        uint _blockNumber\\r\\n    ) external view returns (Stamp[] memory) {\\r\\n        Stamp[] memory stampsAt = new Stamp[](stamps[_toCheck].length);\\r\\n        uint count; // = 0;\\r\\n\\r\\n        // Loop through all the user's stamps\\r\\n        for (uint i; i < stamps[_toCheck].length; ) {\\r\\n            // Get the list of all verification block numbers\\r\\n            uint[] storage verifiedAt = stamps[_toCheck][i].verifiedAt;\\r\\n\\r\\n            // Get the threshold at _blockNumber\\r\\n            uint currentBlockNumberIndex = thresholdHistory.length - 1;\\r\\n            while (\\r\\n                currentBlockNumberIndex > 0 &&\\r\\n                thresholdHistory[currentBlockNumberIndex].blockNumber > _blockNumber\\r\\n            ) {\\r\\n                currentBlockNumberIndex--;\\r\\n            }\\r\\n\\r\\n            uint verifyThreshold = thresholdHistory[currentBlockNumberIndex]\\r\\n                .threshold;\\r\\n\\r\\n            // Reverse for loop, because more recent dates are at the end of the array\\r\\n            for (uint j = verifiedAt.length; j > 0; j--) {\\r\\n                // If the stamp is valid at _blockNumber, add it to the stampsAt array\\r\\n                if (\\r\\n                    verifiedAt[j - 1] + verifyThreshold >\\r\\n                    _blockNumber &&\\r\\n                    verifiedAt[j - 1] < _blockNumber\\r\\n                ) {\\r\\n                    stampsAt[count] = stamps[_toCheck][i];\\r\\n                    count++;\\r\\n                    break;\\r\\n                } else if (\\r\\n                    verifiedAt[j - 1] + verifyThreshold <\\r\\n                    _blockNumber\\r\\n                ) {\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            unchecked {\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        Stamp[] memory stampsAtTrimmed = new Stamp[](count);\\r\\n\\r\\n        for (uint i = 0; i < count; i++) {\\r\\n            stampsAtTrimmed[i] = stampsAt[i];\\r\\n        }\\r\\n\\r\\n        return stampsAtTrimmed;\\r\\n    }\\r\\n\\r\\n    function getAllMembers() external view returns (address[] memory) {\\r\\n        return allMembers;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns whether or not the caller is or was a member at any time\\r\\n    /// @dev Loop through the array of all members and return true if the caller is found\\r\\n    /// @return bool Whether or not the caller is or was a member at any time\\r\\n    function isOrWasMember(address _toCheck) external view returns (bool) {\\r\\n        return isMember[_toCheck];\\r\\n    }\\r\\n\\r\\n    /// @notice Returns latest verifyThreshold\\r\\n    function getVerifyThreshold() external view returns (uint) {\\r\\n        return thresholdHistory[thresholdHistory.length - 1].threshold;\\r\\n    }\\r\\n\\r\\n    /// @notice This function can only be called by the owner to set the verifyThreshold\\r\\n    /// @dev Sets the verifyThreshold\\r\\n    /// @param _blocks The number of blocks to set the verifyThreshold to\\r\\n    function setVerifyThreshold(uint _blocks) external onlyOwner {\\r\\n        Threshold memory lastThreshold = thresholdHistory[\\r\\n            thresholdHistory.length - 1\\r\\n        ];\\r\\n        require(\\r\\n            lastThreshold.threshold != _blocks,\\r\\n            \\\"Threshold already set to this value\\\"\\r\\n        );\\r\\n\\r\\n        thresholdHistory.push(Threshold(block.number, _blocks));\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the reverifyThreshold\\r\\n    function getReverifyThreshold() external view returns (uint) {\\r\\n        return reverifyThreshold;\\r\\n    }\\r\\n\\r\\n    /// @notice This function can only be called by the owner to set the reverifyThreshold\\r\\n    /// @dev Sets the reverifyThreshold\\r\\n    /// @param _days The number of days to set the reverifyThreshold to\\r\\n    function setReverifyThreshold(uint _days) external onlyOwner {\\r\\n        reverifyThreshold = _days;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the full threshold history\\r\\n    /// @return An array of Threshold structs\\r\\n    function getThresholdHistory() external view returns (Threshold[] memory) {\\r\\n        return thresholdHistory;\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the signer address\\r\\n    /// @param signer_ new signer address\\r\\n    function setSigner(address signer_) external onlyOwner {\\r\\n        _signer = signer_;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the signer address\\r\\n    /// @return Signer address\\r\\n    function getSigner() external view returns (address) {\\r\\n        return _signer;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/GenericSignatureHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n  * This program has been developed by students from the bachelor Computer Science at Utrecht University within the Software Project course.\\r\\n  * \u00a9 Copyright Utrecht University (Department of Information and Computing Sciences)\\r\\n  */\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// Modified source from: https://solidity-by-example.org/signature/\\r\\n\\r\\n/* Signature Verification\\r\\n\\r\\nHow to Sign and Verify\\r\\n# Signing\\r\\n1. Create message to sign\\r\\n2. Hash the message\\r\\n3. Sign the hash (off chain, keep your private key secret)\\r\\n\\r\\n# Verify\\r\\n1. Recreate hash from the original message\\r\\n2. Recover signer from signature and hash\\r\\n3. Compare recovered signer to claimed signer\\r\\n*/\\r\\n\\r\\n/// @title Set of (helper) functions for signature verification\\r\\ncontract GenericSignatureHelper {\\r\\n    /// @notice Signs the messageHash with a standard prefix\\r\\n    /// @param _messageHash The hash of the packed message (messageHash) to be signed\\r\\n    /// @return bytes32 Returns the signed messageHash\\r\\n    function getEthSignedMessageHash(\\r\\n        bytes32 _messageHash\\r\\n    ) internal pure returns (bytes32) {\\r\\n        /*\\r\\n        Signature is produced by signing a keccak256 hash with the following format:\\r\\n        \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\r\\n        */\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\r\\n                    _messageHash\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @notice Verify a signature\\r\\n    /// @dev Generate the signed messageHash from the parameters to verify the signature against\\r\\n    /// @param _signer The signer of the signature (the owner of the contract)\\r\\n    /// @param _messageHash The hash of the packed message (messageHash) to be signed\\r\\n    /// @param _signature The signature of the proof signed by the signer\\r\\n    /// @return bool Returns the result of the verification, where true indicates success and false indicates failure\\r\\n    function verify(\\r\\n        address _signer,\\r\\n        bytes32 _messageHash,\\r\\n        bytes memory _signature\\r\\n    ) internal pure returns (bool) {\\r\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(_messageHash);\\r\\n\\r\\n        return recoverSigner(ethSignedMessageHash, _signature) == _signer;\\r\\n    }\\r\\n\\r\\n    /// @notice Recover the signer from the signed messageHash and the signature\\r\\n    /// @dev This uses ecrecover\\r\\n    /// @param _ethSignedMessageHash The signed messageHash created from the parameters\\r\\n    /// @param _signature The signature of the proof signed by the signer\\r\\n    /// @return address Returns the recovered address\\r\\n    function recoverSigner(\\r\\n        bytes32 _ethSignedMessageHash,\\r\\n        bytes memory _signature\\r\\n    ) internal pure returns (address) {\\r\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\r\\n\\r\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\r\\n    }\\r\\n\\r\\n    /// @notice Splits the signature into r, s, and v\\r\\n    /// @dev This is necessary for the ecrecover function\\r\\n    /// @param sig The signature\\r\\n    /// @return r Returns the first 32 bytes of the signature\\r\\n    /// @return s Returns the second 32 bytes of the signature\\r\\n    /// @return v Returns the last byte of the signature\\r\\n    function splitSignature(\\r\\n        bytes memory sig\\r\\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\\r\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\r\\n\\r\\n        assembly {\\r\\n            /*\\r\\n            First 32 bytes stores the length of the signature\\r\\n\\r\\n            add(sig, 32) = pointer of sig + 32\\r\\n            effectively, skips first 32 bytes of signature\\r\\n\\r\\n            mload(p) loads next 32 bytes starting at the memory address p into memory\\r\\n            */\\r\\n\\r\\n            // first 32 bytes, after the length prefix\\r\\n            r := mload(add(sig, 32))\\r\\n            // second 32 bytes\\r\\n            s := mload(add(sig, 64))\\r\\n            // final byte (first byte of the next 32 bytes)\\r\\n            v := byte(0, mload(add(sig, 96)))\\r\\n        }\\r\\n\\r\\n        // implicitly return (r, s, v)\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reverifyThreshold\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getAllMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReverifyThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toCheck\",\"type\":\"address\"}],\"name\":\"getStamps\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"providerId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"userHash\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"verifiedAt\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SignVerification.Stamp[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toCheck\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getStampsAt\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"providerId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"userHash\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"verifiedAt\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SignVerification.Stamp[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getThresholdHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct SignVerification.Threshold[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVerifyThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toCheck\",\"type\":\"address\"}],\"name\":\"isOrWasMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"setReverifyThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer_\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blocks\",\"type\":\"uint256\"}],\"name\":\"setVerifyThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_providerId\",\"type\":\"string\"}],\"name\":\"unverify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toVerify\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_userHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_providerId\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_proofSignature\",\"type\":\"bytes\"}],\"name\":\"verifyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SignVerification", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000278d00000000000000000000000000000000000000000000000000000000000013c680000000000000000000000000b7bde363992227b5225ad0be49b169574d8d5c04", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}