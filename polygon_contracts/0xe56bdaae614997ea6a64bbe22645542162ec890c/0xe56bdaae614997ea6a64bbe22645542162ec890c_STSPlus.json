{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set & change owner\r\n */\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n/**\r\n *  Contract: STS+ - Powered by XUSD\r\n *  Appreciating Stable Coin Inheriting The IP Of XUSD by xSurge\r\n *  Visit xsurge.net to learn more about appreciating stable coins\r\n */\r\ncontract STSPlus is IERC20, Ownable, ReentrancyGuard {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    // token data\r\n    string private constant _name = \"Stasis+\";\r\n    string private constant _symbol = \"STS+\";\r\n    uint8 private constant _decimals = 6;\r\n    uint256 private constant precision = 10**6;\r\n    \r\n    // 0 initial supply\r\n    uint256 private _totalSupply; \r\n    \r\n    // balances\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    // address -> Fee Exemption\r\n    mapping ( address => bool ) public isTransferFeeExempt;\r\n\r\n    // Token Activation\r\n    bool public tokenActivated;\r\n\r\n    // PCS Router\r\n    IUniswapV2Router02 public router;\r\n\r\n    // Underlying Asset Is Underlying\r\n    IERC20 public immutable underlying;\r\n\r\n    // Swap Path From MATIC -> Underlying\r\n    address[] private path;\r\n\r\n    // Fees\r\n    uint256 public mintFee        = 99000;            // 1% mint fee\r\n    uint256 public sellFee        = 99000;            // 1% redeem fee \r\n    uint256 public transferFee    = 99000;            // 1% transfer fee\r\n    uint256 private constant feeDenominator = 10**5;\r\n\r\n    // Fee Recipient\r\n    address public feeTo;\r\n\r\n    // Price Data Tracking\r\n    uint256[] public allPrices;\r\n\r\n    address public DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address public ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    // initialize some stuff\r\n    constructor(address underlying_, address router_, address feeTo_) {\r\n        require(goodAddress(feeTo_) == true, 'Invalid Address!');\r\n        require(goodAddress(router_) == true, 'Invalid Address!');\r\n        require(goodAddress(underlying_) == true, 'Invalid Address!');\r\n\r\n        // set underlying\r\n        underlying = IERC20(underlying_);\r\n\r\n        // set router\r\n        router = IUniswapV2Router02(router_);\r\n\r\n        // set swap path\r\n        path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = underlying_;\r\n\r\n        // set fee recipient setter\r\n        feeTo = feeTo_;\r\n\r\n        // exempt deployer and fee setter\r\n        isTransferFeeExempt[msg.sender] = true;\r\n        isTransferFeeExempt[feeTo_] = true;\r\n\r\n        // let token show on etherscan\r\n        emit Transfer(address(0), msg.sender, 0);\r\n    }\r\n\r\n    /** Returns the total number of tokens in existence */\r\n    function totalSupply() external view override returns (uint256) { \r\n        return _totalSupply; \r\n    }\r\n\r\n    /** Returns the number of tokens owned by `account` */\r\n    function balanceOf(address account) public view override returns (uint256) { \r\n        return _balances[account]; \r\n    }\r\n\r\n    /** Returns the number of tokens `spender` can transfer from `holder` */\r\n    function allowance(address holder, address spender) external view override returns (uint256) { \r\n        return _allowances[holder][spender]; \r\n    }\r\n    \r\n    /** Token Name */\r\n    function name() public pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /** Token Ticker Symbol */\r\n    function symbol() public pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /** Tokens decimals */\r\n    function decimals() public pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /** Approves `spender` to transfer `amount` tokens from caller */\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n  \r\n    /** Transfer Function */\r\n    function transfer(address recipient, uint256 amount) external override nonReentrant returns (bool) {\r\n        if (recipient == msg.sender) {\r\n            _sell(amount, msg.sender);\r\n            return true;\r\n        } else {\r\n            return _transferFrom(msg.sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    /** Transfer Function */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override nonReentrant returns (bool) {\r\n        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, 'Insufficient Allowance');\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n    \r\n    /** Internal Transfer */\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        // make standard checks\r\n        require(\r\n            recipient != address(0) && \r\n            sender != address(0),\r\n            \"Transfer To Zero\"\r\n        );\r\n        require(\r\n            amount > 0, \r\n            \"Transfer Amt Zero\"\r\n        );\r\n\r\n        // track price change\r\n        uint256 oldPrice = _calculatePrice();\r\n\r\n        // amount to give recipient\r\n        uint256 tAmount = (isTransferFeeExempt[sender] || isTransferFeeExempt[recipient]) ? amount : amount.mul(transferFee).div(feeDenominator);\r\n       \r\n        // tax taken from transfer\r\n        uint256 tax = amount.sub(tAmount);\r\n        \r\n        // subtract from sender\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n\r\n        // give reduced amount to receiver\r\n        _balances[recipient] = _balances[recipient].add(tAmount);\r\n\r\n        // burn the tax\r\n        if (tax > 0 && _totalSupply > 0) {\r\n            // Take Fee\r\n            _takeFee(tax);\r\n            _totalSupply = _totalSupply.sub(tax);\r\n            emit Transfer(sender, address(0), tax);\r\n        }\r\n        \r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n\r\n        // Transfer Event\r\n        emit Transfer(sender, recipient, tAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        Mint WhiteLabel Tokens With The Native Token ( Smart Chain MATIC )\r\n        This will purchase underlying with MATIC received\r\n        It will then mint tokens to `recipient` based on the number of stable coins received\r\n        `minOut` should be set to avoid the Transaction being front runned\r\n\r\n        @param recipient Account to receive minted WhiteLabel Tokens\r\n        @param minOut minimum amount out from MATIC -> underlying - prevents front run attacks\r\n        @return received number of WhiteLabel tokens received\r\n     */\r\n    function mintWithNative(address recipient, uint256 minOut) external payable returns (uint256) {\r\n        _checkGarbageCollector();\r\n        return _mintWithNative(recipient, minOut);\r\n    }\r\n\r\n\r\n    /** \r\n        Mint WhiteLabel Tokens For `recipient` By Depositing `underlying` Into The Contract\r\n            Requirements:\r\n                Approval from the `underlying` token prior to purchase\r\n        \r\n        @param numTokens number of underlying tokens to mint WhiteLabel with\r\n        @param recipient Account to receive minted WhiteLabel tokens\r\n        @return tokensMinted number of WhiteLabel tokens minted\r\n    */\r\n    function mintWithBacking(uint256 numTokens, address recipient) external nonReentrant returns (uint256) {\r\n        _checkGarbageCollector();\r\n        return _mintWithBacking(numTokens, recipient);\r\n    }\r\n\r\n    /** \r\n        Burns Sender's WhiteLabel Tokens and redeems their value in underlying\r\n        @param tokenAmount Number of WhiteLabel Tokens To Redeem, Must be greater than 0\r\n    */\r\n    function sell(uint256 tokenAmount) external nonReentrant returns (uint256) {\r\n        return _sell(tokenAmount, msg.sender);\r\n    }\r\n    \r\n    /** \r\n        Burns Sender's WhiteLabel Tokens and redeems their value in `underlying` for `recipient`\r\n        @param tokenAmount Number of WhiteLabel Tokens To Redeem, Must be greater than 0\r\n        @param recipient Recipient Of underlying token transfer, Must not be address(0)\r\n    */\r\n    function sell(uint256 tokenAmount, address recipient) external nonReentrant returns (uint256) {\r\n        return _sell(tokenAmount, recipient);\r\n    }\r\n    \r\n    /** \r\n        Allows A User To Erase Their Holdings From Supply \r\n        DOES NOT REDEEM UNDERLYING ASSET FOR USER\r\n        @param amount Number of WhiteLabel Tokens To Burn\r\n    */\r\n    function burn(uint256 amount) external nonReentrant {\r\n        // get balance of caller\r\n        uint256 bal = _balances[msg.sender];\r\n        require(bal >= amount && bal > 0, 'Zero Holdings');\r\n        // Track Change In Price\r\n        uint256 oldPrice = _calculatePrice();\r\n        // take fee\r\n        _takeFee(amount);\r\n        // burn tokens from sender + supply\r\n        _burn(msg.sender, amount);\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n        // Emit Call\r\n        emit Burn(msg.sender, amount);\r\n    }\r\n\r\n\r\n    ///////////////////////////////////\r\n    //////  INTERNAL FUNCTIONS  ///////\r\n    ///////////////////////////////////\r\n    \r\n    /** Purchases WhiteLabel Token and Deposits Them in Recipient's Address */\r\n    function _mintWithNative(address recipient, uint256 minOut) internal nonReentrant returns (uint256) {        \r\n        require(\r\n            msg.value > 0, \r\n            'Zero Value'\r\n        );\r\n        require(\r\n            recipient != address(0), \r\n            'Zero Address'\r\n        );\r\n        require(\r\n            tokenActivated || msg.sender == this.getOwner(),\r\n            'Token Not Activated'\r\n        );\r\n        \r\n        // calculate price change\r\n        uint256 oldPrice = _calculatePrice();\r\n        \r\n        // previous backing\r\n        uint256 previousBacking = underlying.balanceOf(address(this));\r\n        \r\n        // swap MATIC for stable\r\n        uint256 received = _purchaseUnderlying(minOut);\r\n\r\n        // if this is the first purchase, use new amount\r\n        uint256 relevantBacking = previousBacking == 0 ? underlying.balanceOf(address(this)) : previousBacking;\r\n\r\n        // mint to recipient\r\n        return _mintTo(recipient, received, relevantBacking, oldPrice);\r\n    }\r\n    \r\n    /** Stake Tokens and Deposits WhiteLabel in Sender's Address, Must Have Prior Approval For Underlying */\r\n    function _mintWithBacking(uint256 numUnderlying, address recipient) internal returns (uint256) {\r\n        require(\r\n            tokenActivated || msg.sender == this.getOwner(),\r\n            'Token Not Activated'\r\n        );\r\n        // users token balance\r\n        uint256 userTokenBalance = underlying.balanceOf(msg.sender);\r\n\r\n        // ensure user has enough to send\r\n        require(\r\n            userTokenBalance > 0 && \r\n            numUnderlying <= userTokenBalance, \r\n            'Insufficient Balance'\r\n        );\r\n\r\n        // calculate price change\r\n        uint256 oldPrice = _calculatePrice();\r\n\r\n        // previous backing\r\n        uint256 previousBacking = underlying.balanceOf(address(this));\r\n\r\n        // transfer in token\r\n        uint256 received = _transferIn(address(underlying), numUnderlying);\r\n\r\n        // if this is the first purchase, use new amount\r\n        uint256 relevantBacking = previousBacking == 0 ? underlying.balanceOf(address(this)) : previousBacking;\r\n\r\n        // Handle Minting\r\n        return _mintTo(recipient, received, relevantBacking, oldPrice);\r\n    }\r\n    \r\n    /** Burns WhiteLabel Tokens And Deposits Underlying Tokens into Recipients's Address */\r\n    function _sell(uint256 tokenAmount, address recipient) internal returns (uint256) {\r\n        \r\n        // seller of tokens\r\n        address seller = msg.sender;\r\n        \r\n        require(\r\n            tokenAmount > 0 && _balances[seller] >= tokenAmount,\r\n            'Insufficient Balance'\r\n        );\r\n        require(\r\n            recipient != address(0),\r\n            'Invalid Recipient'\r\n        );\r\n        \r\n        // calculate price change\r\n        uint256 oldPrice = _calculatePrice();\r\n        \r\n        // tokens post fee to swap for underlying asset\r\n        uint256 tokensToSwap = isTransferFeeExempt[seller] ? \r\n            tokenAmount.sub(10, 'Minimum Exemption') :\r\n            tokenAmount.mul(sellFee).div(feeDenominator);\r\n\r\n        // value of taxed tokens\r\n        uint256 amountUnderlyingAsset = amountOut(tokensToSwap);\r\n\r\n        // Take Fee\r\n        if (!isTransferFeeExempt[msg.sender]) {\r\n            uint fee = tokenAmount.sub(tokensToSwap);\r\n            _takeFee(fee);\r\n        }\r\n\r\n        // burn from sender + supply \r\n        _burn(seller, tokenAmount);\r\n\r\n        // send Tokens to Seller\r\n        require(\r\n            underlying.transfer(recipient, amountUnderlyingAsset), \r\n            'Underlying Transfer Failure'\r\n        );\r\n\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n        // Differentiate Sell\r\n        emit Redeemed(seller, tokenAmount, amountUnderlyingAsset);\r\n\r\n        // return token redeemed and amount underlying\r\n        return amountUnderlyingAsset;\r\n    }\r\n\r\n    /** Handles Minting Logic To Create New WhiteLabel */\r\n    function _mintTo(address recipient, uint256 received, uint256 totalBacking, uint256 oldPrice) internal returns(uint256) {\r\n        \r\n        // tokens to mint with no tax\r\n        uint256 nTokensToMint = tokensToMint(received, totalBacking);\r\n\r\n        // whether fee was applied or not\r\n        bool hasFee = !isTransferFeeExempt[msg.sender] && _totalSupply > 0;\r\n           \r\n        // ensure there are tokens to mint\r\n        require(\r\n            nTokensToMint > 0, \r\n            'Zero Amount To Mint'\r\n        );\r\n        \r\n        // mint to Buyer\r\n        _mint(recipient, nTokensToMint);\r\n\r\n        // apply fee to tax taken\r\n        if (hasFee) {\r\n            uint256 nTokensToMintNoTax = nTokensToMint.mul(feeDenominator).div(mintFee);\r\n            _takeFee(nTokensToMintNoTax.sub(nTokensToMint));\r\n        }\r\n\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n        \r\n        // differentiate purchase\r\n        emit Minted(recipient, nTokensToMint);\r\n        return nTokensToMint;\r\n    }\r\n\r\n    /** Takes Fee */\r\n    function _takeFee(uint mFee) internal {\r\n\r\n        // send percentage to fee recipient\r\n        uint256 fee = mFee / 5;\r\n        \r\n        if (fee > 0) {\r\n            unchecked {\r\n                _balances[feeTo] += fee;\r\n                _totalSupply += fee;\r\n            }\r\n            emit Transfer(address(0), feeTo, fee);\r\n        }\r\n    }\r\n\r\n    /** Swaps to underlying, must get at least `minOut` back from swap to be successful */\r\n    function _purchaseUnderlying(uint256 minOut) internal returns (uint256) {\r\n\r\n        // previous amount of Tokens before we received any\r\n        uint256 prevTokenAmount = underlying.balanceOf(address(this));\r\n\r\n        // swap MATIC For stable of choice\r\n        router.swapExactETHForTokens{value: address(this).balance}(minOut, path, address(this), block.timestamp + 300);\r\n\r\n        // amount after swap\r\n        uint256 currentTokenAmount = underlying.balanceOf(address(this));\r\n        require(\r\n            currentTokenAmount > prevTokenAmount,\r\n            'Zero Underlying Received'\r\n        );\r\n        return currentTokenAmount - prevTokenAmount;\r\n    }\r\n\r\n    /** Requires The Price Of WhiteLabel To Rise For The Transaction To Conclude */\r\n    function _requirePriceRises(uint256 oldPrice) internal {\r\n        // Calculate Price After Transaction\r\n        uint256 newPrice = _calculatePrice();\r\n        // Require Current Price >= Last Price\r\n        require(newPrice >= oldPrice, 'Price Cannot Fall');\r\n        // Emit The Price Change\r\n        emit PriceChange(oldPrice, newPrice, _totalSupply);\r\n        // Log The New Price\r\n        allPrices.push(newPrice);\r\n    }\r\n\r\n    /** \r\n        Transfers `amount` of `token` in, verifies the transaction success, returns the amount received\r\n        Also accounts for potential tx fees as it notes the contract balance before and after swap \r\n    */\r\n    function _transferIn(address _token, uint256 amount) internal returns (uint256) {\r\n        require(\r\n            IERC20(_token).balanceOf(msg.sender) >= amount,\r\n            'Insufficient Balance'\r\n        );\r\n        require(\r\n            IERC20(_token).allowance(msg.sender, address(this)) >= amount,\r\n            'Insufficient Allowance'\r\n        );\r\n        uint before = IERC20(_token).balanceOf(address(this));\r\n        IERC20(_token).transferFrom(msg.sender, address(this), amount);\r\n        uint After = IERC20(_token).balanceOf(address(this));\r\n        require(\r\n            After > before,\r\n            'Error On Transfer From'\r\n        );\r\n        return After - before;\r\n    }\r\n    \r\n    /** Mints Tokens to the Receivers Address */\r\n    function _mint(address receiver, uint amount) internal {\r\n        _balances[receiver] = _balances[receiver].add(amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        emit Transfer(address(0), receiver, amount);\r\n    }\r\n    \r\n    /** Burns `amount` of tokens from `account` */\r\n    function _burn(address account, uint amount) internal {\r\n        _balances[account] = _balances[account].sub(amount, 'Insufficient Balance');\r\n        _totalSupply = _totalSupply.sub(amount, 'Negative Supply');\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /** Make Sure there's no Native Tokens in contract */\r\n    function _checkGarbageCollector() internal {\r\n        uint256 bal = _balances[address(this)];\r\n        if (bal > 10**6) {\r\n            // Track Change In Price\r\n            uint256 oldPrice = _calculatePrice();\r\n            // take fee\r\n            _takeFee(bal);\r\n            // burn amount\r\n            _burn(address(this), bal);\r\n            // Emit Collection\r\n            emit GarbageCollected(bal);\r\n            // Require price rises\r\n            _requirePriceRises(oldPrice);\r\n        }\r\n    }\r\n    \r\n    ///////////////////////////////////\r\n    //////    READ FUNCTIONS    ///////\r\n    ///////////////////////////////////\r\n    \r\n\r\n    /** Price Of WhiteLabel in Underlying With 6 Points Of Precision */\r\n    function calculatePrice() external view returns (uint256) {\r\n        return _calculatePrice();\r\n    }\r\n    \r\n    /** Returns the Current Price of 1 Token */\r\n    function _calculatePrice() internal view returns (uint256) {\r\n        if (_totalSupply == 0) {\r\n            return 10**5;\r\n        }\r\n        uint256 backingValue = underlying.balanceOf(address(this));\r\n        return (backingValue.mul(precision)).div(_totalSupply);\r\n    }\r\n\r\n\r\n    /** Number Of Tokens To Mint */\r\n    function tokensToMint(uint256 received, uint256 totalBacking) public view returns (uint256) {\r\n        return \r\n            _totalSupply == 0 ? \r\n                ( received * 10 ) : // puts launch price at 0.1 `underlying`\r\n                isTransferFeeExempt[msg.sender] ? \r\n                    _totalSupply.mul(received).div(totalBacking).sub(100) : // sub 100 to avoid any round off error\r\n                    _totalSupply.mul(\r\n                        received\r\n                    ).div(\r\n                        totalBacking.add(\r\n                            mintFeeTaken(received)\r\n                        )\r\n                    )\r\n                    .mul(\r\n                        mintFee\r\n                    ).div(\r\n                        feeDenominator\r\n                    );\r\n    }\r\n\r\n    function mintFeeTaken(uint256 amount) public view returns (uint256) {\r\n        uint fee = ( amount * mintFee ) / feeDenominator;\r\n        return amount - fee;\r\n    }\r\n\r\n    /**\r\n        Amount Of Underlying To Receive For `numTokens` of WhiteLabel\r\n     */\r\n    function amountOut(uint256 numTokens) public view returns (uint256) {\r\n        return _calculatePrice().mul(numTokens).div(precision);\r\n    }\r\n\r\n    /** Returns the value of `holder`'s holdings */\r\n    function getValueOfHoldings(address holder) public view returns(uint256) {\r\n        return amountOut(_balances[holder]);\r\n    }\r\n\r\n    function viewAllPriceChanges() external view returns (uint256[] memory) {\r\n        return allPrices;\r\n    }\r\n\r\n    function numPricePoints() external view returns (uint256) {\r\n        return allPrices.length;\r\n    }\r\n\r\n    function viewPricePoints(uint startIndex, uint endIndex) external view returns (uint256[] memory pricePoints) {\r\n\r\n        pricePoints = new uint256[](endIndex - startIndex);\r\n        uint count = 0;\r\n        for (uint i = startIndex; i < endIndex;) {\r\n            pricePoints[count] = allPrices[i];\r\n            unchecked { ++count; ++i; }\r\n        }\r\n\r\n    }\r\n\r\n    function viewSelectPricePoints(uint256[] calldata indexes) external view returns (uint256[] memory pricePoints) {\r\n        uint len = indexes.length;\r\n        pricePoints = new uint256[](len);\r\n        for (uint i = 0; i < len;) {\r\n            pricePoints[i] = allPrices[indexes[i]];\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n    \r\n    ///////////////////////////////////\r\n    //////   OWNER FUNCTIONS    ///////\r\n    ///////////////////////////////////\r\n\r\n    /** Activates Token, Enabling Trading For All */\r\n    function activateToken() external onlyOwner {\r\n        tokenActivated = true;\r\n        emit TokenActivated(block.number);\r\n    }\r\n\r\n    /** Pauses Token Activation */\r\n    function deActivateToken() external onlyOwner {\r\n        tokenActivated = false;\r\n        emit TokenDeActivated(block.number);\r\n    }\r\n\r\n    /** Updates The Address Of The Router To Purchase Underlying */\r\n    function upgradeRouter(address newRouter) external onlyOwner {\r\n        require(newRouter != address(0));\r\n        router = IUniswapV2Router02(newRouter);\r\n        emit SetRouter(newRouter);\r\n    }\r\n\r\n    /** Withdraws Tokens Incorrectly Sent To WhiteLabel */\r\n    function withdrawNonStableToken(IERC20 token) external onlyOwner {\r\n        require(address(token) != address(underlying), 'Cannot Withdraw Underlying Asset');\r\n        require(address(token) != address(0), 'Zero Address');\r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n\r\n    \r\n    /** \r\n        Sets Mint, Transfer, Sell Fee\r\n        Must Be Within Bounds ( Between 0% - 10% ) \r\n    */\r\n    function setFees(uint256 _mintFee, uint256 _transferFee, uint256 _sellFee) external onlyOwner {\r\n        require(_mintFee >= 90000 && _mintFee <= 9990000);       // capped at 10% fee\r\n        require(_transferFee >= 90000 && _transferFee <= 9990000);   // capped at 10% fee\r\n        require(_sellFee >= 90000 && _sellFee <= 9990000);       // capped at 10% fee\r\n        \r\n        mintFee = _mintFee;\r\n        transferFee = _transferFee;\r\n        sellFee = _sellFee;\r\n        emit SetFees(_mintFee, _transferFee, _sellFee);\r\n    }\r\n    \r\n    /** Excludes Contract From Transfer Fees */\r\n    function setPermissions(address Contract, bool transferFeeExempt) external onlyOwner {\r\n        require(Contract != address(0), 'Zero Address');\r\n        isTransferFeeExempt[Contract] = transferFeeExempt;\r\n        emit SetPermissions(Contract, transferFeeExempt);\r\n    }\r\n\r\n    function setFeeTo(address newFeeTo) external {\r\n        require(msg.sender == feeTo, 'Only FeeTo');\r\n        require(newFeeTo != address(0), 'Zero Address');\r\n        feeTo = newFeeTo;\r\n        isTransferFeeExempt[newFeeTo] = true;\r\n    }\r\n\r\n    /** Mint Tokens to Buyer */\r\n    receive() external payable {\r\n        _mintWithNative(msg.sender, 0);\r\n        _checkGarbageCollector();\r\n    }\r\n\r\n    function goodAddress(address _target) internal returns (bool) {\r\n        if (\r\n            _target == DEAD || \r\n            _target == ZERO\r\n        ) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    \r\n    ///////////////////////////////////\r\n    //////        EVENTS        ///////\r\n    ///////////////////////////////////\r\n    \r\n    // Data Tracking\r\n    event PriceChange(uint256 previousPrice, uint256 currentPrice, uint256 totalSupply);\r\n    event TokenActivated(uint blockNo);\r\n    event TokenDeActivated(uint blockNo);\r\n\r\n    // Balance Tracking\r\n    event Burn(address from, uint256 amountTokensErased);\r\n    event GarbageCollected(uint256 amountTokensErased);\r\n    event Redeemed(address seller, uint256 amountWhiteLabel, uint256 amountUnderlying);\r\n    event Minted(address recipient, uint256 numTokens);\r\n\r\n    // Upgradable Contract Tracking\r\n    event SetMaxHoldings(uint256 maxHoldings);\r\n    event SetRouter(address newRouter);\r\n\r\n    // Governance Tracking\r\n    event SetPermissions(address Contract, bool feeExempt);\r\n    event SetMaxHoldingsExempt(address account, bool isExempt);\r\n    event SetFees(uint mintFee, uint transferFee, uint sellFee);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeTo_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokensErased\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokensErased\",\"type\":\"uint256\"}],\"name\":\"GarbageCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"PriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWhiteLabel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountUnderlying\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellFee\",\"type\":\"uint256\"}],\"name\":\"SetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxHoldings\",\"type\":\"uint256\"}],\"name\":\"SetMaxHoldings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExempt\",\"type\":\"bool\"}],\"name\":\"SetMaxHoldingsExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"feeExempt\",\"type\":\"bool\"}],\"name\":\"SetPermissions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"SetRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNo\",\"type\":\"uint256\"}],\"name\":\"TokenActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNo\",\"type\":\"uint256\"}],\"name\":\"TokenDeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"amountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculatePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deActivateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getValueOfHoldings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTransferFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintFeeTaken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintWithBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"mintWithNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPricePoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transferFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"transferFeeExempt\",\"type\":\"bool\"}],\"name\":\"setPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBacking\",\"type\":\"uint256\"}],\"name\":\"tokensToMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"upgradeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewAllPriceChanges\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"viewPricePoints\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pricePoints\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"name\":\"viewSelectPricePoints\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pricePoints\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawNonStableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "STSPlus", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000311e34a3492aa572195f4c8f3bdfbcbb9fe9c3ea", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://70f38894169ce7e40180921c098045c7c43cae6574596dd7b5872735443f67d5"}