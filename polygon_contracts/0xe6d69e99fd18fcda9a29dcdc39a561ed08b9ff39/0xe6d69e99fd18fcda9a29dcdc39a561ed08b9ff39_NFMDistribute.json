{"SourceCode": "//SPDX-License-Identifier:MIT\r\n\r\npragma solidity ^0.8.13;\r\n\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// LIBRARIES\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// SAFEMATH its a Openzeppelin Lib. Check out for more info @ https://docs.openzeppelin.com/contracts/2.x/api/math\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// INTERFACES\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// INFMCONTROLLER\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\ninterface INfmController {\r\n    function _checkWLSC(address Controller, address Client)\r\n        external\r\n        pure\r\n        returns (bool);\r\n\r\n    function _getNFM() external pure returns (address);\r\n}\r\n\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// IERC20\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n/// @title NFMDistribute.sol\r\n/// @author Fernando Viktor Seidl E-mail: viktorseidl@gmail.com\r\n/// @notice This contract is responsible for the distribution of the Developer Funds to all participants.\r\n/// @dev This extension includes all necessary functionalities for distributing the Funds.\r\n///\r\n///         \r\n///\r\n//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\ncontract NFMDistribute {\r\n    //include SafeMath\r\n    using SafeMath for uint256;\r\n    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    /*\r\n    CONTROLLER\r\n    OWNER = MSG.SENDER ownership will be handed over to dao\r\n    */\r\n    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    INfmController private _Controller;\r\n    address private _Owner;\r\n    address private _SController;\r\n    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    /*\r\n    address[] _PArray       => Contains the Distribution Array\r\n    uint256 Index           => Contains the upcoming index \r\n    */\r\n    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    address[] public _PArray;\r\n\r\n    mapping(address => bool) public _isP_allowed; \r\n    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    /*\r\n    MODIFIER\r\n    onlyOwner       => Only Controller listed Contracts and Owner can interact with this contract.\r\n     */\r\n    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    modifier onlyOwner() {\r\n        require(\r\n            _Owner == msg.sender,\r\n            \"oO\"\r\n        );\r\n        require(msg.sender != address(0), \"0A\");\r\n        _;\r\n    }\r\n \r\n    constructor(address Controller) {\r\n        _Owner = msg.sender;\r\n        INfmController Cont = INfmController(Controller);\r\n        _Controller = Cont;\r\n        _SController = Controller;\r\n    }\r\n\r\n    function allowOrblockP(address Person) public onlyOwner returns (bool){ \r\n        if(_isP_allowed[Person]==true){\r\n            _isP_allowed[Person]=false;\r\n        }else{\r\n            _isP_allowed[Person]=true;\r\n        }\r\n        return true;\r\n    }\r\n    function showAddressArray() public view onlyOwner returns (address[] memory Array){ \r\n        return _PArray;\r\n    }\r\n    function addP(address Person) public onlyOwner returns (bool){\r\n        _PArray.push(Person); \r\n        _isP_allowed[Person]=true;\r\n        return true;\r\n    }\r\n    function makecalculationsAndSendNFM(address Coin) public onlyOwner returns (bool){\r\n        uint256 balanceCoin=IERC20(address(Coin)).balanceOf(address(this));\r\n        uint256 allcount=0;        \r\n        uint256 Pcount=0;        \r\n        uint256 i=0;\r\n        for(i; i<_PArray.length;i++){\r\n            if(_isP_allowed[_PArray[i]]==true){\r\n                Pcount++;\r\n            }\r\n        }\r\n        i=0;\r\n        uint256 payCount=0;\r\n        uint256 Ppercent = SafeMath.div(100,Pcount);\r\n        uint256 share = SafeMath.div(SafeMath.mul(balanceCoin,Ppercent), 100);\r\n        for(i; i<_PArray.length;i++){\r\n            if(payCount==Pcount-1){\r\n                if(_isP_allowed[_PArray[i]]==true){\r\n                IERC20(address(Coin)).transfer(_PArray[i], SafeMath.sub(balanceCoin,allcount));     \r\n                }          \r\n            }else{\r\n                if(_isP_allowed[_PArray[i]]==true){\r\n                    IERC20(address(Coin)).transfer(_PArray[i], share);\r\n                    allcount+=share;\r\n                    payCount++;\r\n                }\r\n            }\r\n        }\r\n        if(IERC20(address(Coin)).balanceOf(address(this))==0){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n        \r\n    }\r\n    \r\n    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    /*\r\n    @_getWithdraw(address Coin,address To,uint256 amount,bool percent) returns (bool);\r\n    This function is used by NFMLiquidity and NFM Swap to execute transactions.\r\n     */\r\n    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n    function _getWithdraw(\r\n        address Coin,\r\n        address To,\r\n        uint256 amount,\r\n        bool percent\r\n    ) public onlyOwner returns (bool) {\r\n        require(To != address(0), \"0A\");\r\n        uint256 CoinAmount = IERC20(address(Coin)).balanceOf(address(this));\r\n        if (percent == true) {\r\n            //makeCalcs on Percentatge\r\n            uint256 AmountToSend = SafeMath.div(\r\n                SafeMath.mul(CoinAmount, amount),\r\n                100\r\n            );\r\n            IERC20(address(Coin)).transfer(To, AmountToSend);\r\n            return true;\r\n        } else {\r\n            if (amount == 0) {\r\n                IERC20(address(Coin)).transfer(To, CoinAmount);\r\n            } else {\r\n                IERC20(address(Coin)).transfer(To, amount);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_PArray\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Coin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"To\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"percent\",\"type\":\"bool\"}],\"name\":\"_getWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isP_allowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Person\",\"type\":\"address\"}],\"name\":\"addP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Person\",\"type\":\"address\"}],\"name\":\"allowOrblockP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Coin\",\"type\":\"address\"}],\"name\":\"makecalculationsAndSendNFM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showAddressArray\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"Array\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NFMDistribute", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000f4dc0c3c0141477742078e4676c909650e29a71b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8609ce776c08750235a10c2f51da9488417041d8f784e543c8842c85e95be744"}