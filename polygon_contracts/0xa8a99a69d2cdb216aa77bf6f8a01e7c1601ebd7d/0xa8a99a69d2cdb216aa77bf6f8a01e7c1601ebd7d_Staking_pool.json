{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at PolygonScan.com on 2023-08-08\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ncontract Staking_pool is Ownable {\\n    struct UserRewardInfo {\\n        uint256 amount;\\n        uint256 depositAt;\\n        uint256 canHarvestTimestamp;\\n        uint256 bonusRate;\\n        bool isPaid;\\n    }\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount; // How many MEAC tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n        uint256 doneDays;\\n        uint256 stakedDays;\\n        UserRewardInfo[] userRewardInfo;\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 lpToken; // Address of MEAC token contract.\\n    }\\n\\n    // The MeacToken TOKEN!\\n    IERC20 public local;\\n    // MeacToken tokens created per block.\\n    // Bonus muliplier for early local makers.\\n    uint256 public constant BONUS_MULTIPLIER = 1;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes MEAC tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n\\n    mapping(uint256 => uint256) public bonusRateForTime;\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmergencyWithdraw(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 amount\\n    );\\n\\n    constructor(IERC20 _local) {\\n        local = _local;\\n        bonusRateForTime[60] = 6;\\n        bonusRateForTime[90] = 9;\\n        bonusRateForTime[360] = 70;\\n\\n        poolInfo.push(PoolInfo({lpToken: local}));\\n    }\\n\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    // Add a new lp to the pool. Can only be called by the owner.\\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.  0x3bD0359740F05CE98739Feaf4EB9B7058d3FDF82\\n    function add(IERC20 _lpToken) public onlyOwner {\\n        poolInfo.push(PoolInfo({lpToken: _lpToken}));\\n    }\\n\\n    function getBonusRateFromLockedDate(\\n        uint256 _days\\n    ) public view returns (uint256 bonusRate) {\\n        if (_days >= 60 && _days < 90) {\\n            bonusRate = bonusRateForTime[60];\\n        } else if (_days >= 90 && _days < 360) {\\n            bonusRate = bonusRateForTime[90];\\n        } else if (_days >= 360) {\\n            bonusRate = bonusRateForTime[360];\\n        }\\n    }\\n\\n    // View function to see pending MeacToken on frontend.\\n    function pendingTokens(\\n        uint256 _pid,\\n        address _user\\n    ) public view returns (uint256) {\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 pending;\\n        if (user.amount > 0) {\\n            uint256 currentTime = block.timestamp;\\n            for (uint256 i = 0; i < user.userRewardInfo.length; i++) {\\n                UserRewardInfo storage rewardInfo = user.userRewardInfo[i];\\n                if (rewardInfo.isPaid) continue;\\n                if (currentTime > rewardInfo.canHarvestTimestamp) {\\n                    uint256 bonusRate = rewardInfo.bonusRate;\\n                    pending = rewardInfo.amount;\\n                    pending = pending + ((rewardInfo.amount * bonusRate) / 100);\\n                }\\n            }\\n        }\\n        return pending;\\n    }\\n\\n    // View function to see pending MeacToken on frontend by index.\\n    function pendingAmount(\\n        uint256 _pid,\\n        address _user\\n    ) public view returns (uint256) {\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 pending;\\n        uint256 totalEarning = 0;\\n        if (user.amount > 0) {\\n            uint256 currentTime = block.timestamp;\\n            for (uint256 i = 0; i < user.userRewardInfo.length; i++) {\\n                UserRewardInfo storage rewardInfo = user.userRewardInfo[i];\\n                if (rewardInfo.isPaid) continue;\\n                if (currentTime > rewardInfo.canHarvestTimestamp) {\\n                    uint256 bonusRate = rewardInfo.bonusRate;\\n                    pending = rewardInfo.amount;\\n                    pending = pending + ((rewardInfo.amount * bonusRate) / 100);\\n                    totalEarning += pending;\\n                }\\n            }\\n        }\\n        return totalEarning;\\n    }\\n\\n    // View function to see pending 2LC on frontend by index.\\n    function totalPending(\\n        uint256 _pid,\\n        address _user\\n    ) public view returns (uint256) {\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 pending;\\n        uint256 totalEarning = 0;\\n        if (user.amount > 0) {\\n            uint256 currentTime = block.timestamp;\\n            for (uint256 i = 0; i < user.userRewardInfo.length; i++) {\\n                UserRewardInfo storage rewardInfo = user.userRewardInfo[i];\\n                if (rewardInfo.isPaid) continue;\\n                if (currentTime > rewardInfo.canHarvestTimestamp) {\\n                    uint256 bonusRate = rewardInfo.bonusRate;\\n                    pending = (rewardInfo.amount * bonusRate) / 100;\\n                    totalEarning += pending;\\n                }\\n            }\\n        }\\n        return totalEarning;\\n    }\\n\\n    function addOldUsers(\\n        address[] memory _walletAddresses,\\n        uint256[] memory amounts,\\n        uint256[] memory doneDaysList,\\n        uint256[] memory stakedDaysList,\\n        uint256[] memory _pids\\n    ) public onlyOwner {\\n        require(\\n            _walletAddresses.length == amounts.length,\\n            \\\"different length of list\\\"\\n        );\\n        require(\\n            _walletAddresses.length == doneDaysList.length,\\n            \\\"different length of list\\\"\\n        );\\n        require(\\n            _walletAddresses.length == stakedDaysList.length,\\n            \\\"different length of list\\\"\\n        );\\n        for (uint256 i = 0; i < _walletAddresses.length; i++) {\\n            address _account = _walletAddresses[i];\\n            UserInfo storage user = userInfo[_pids[i]][_account];\\n            uint256 _amount = amounts[i];\\n            uint256 _doneDays = doneDaysList[i];\\n            uint256 _stakedDays = stakedDaysList[i];\\n            user.amount = user.amount + _amount;\\n            user.doneDays = user.doneDays + _doneDays;\\n            user.stakedDays = user.stakedDays + _stakedDays;\\n            if (_doneDays > _stakedDays) {\\n                user.userRewardInfo.push(\\n                    UserRewardInfo({\\n                        amount: _amount,\\n                        depositAt: block.timestamp - (_doneDays * 1 days),\\n                        canHarvestTimestamp: block.timestamp,\\n                        bonusRate: bonusRateForTime[_stakedDays],\\n                        isPaid: false\\n                    })\\n                );\\n            } else {\\n                uint256 harvestTime = _stakedDays - (_doneDays);\\n                user.userRewardInfo.push(\\n                    UserRewardInfo({\\n                        amount: _amount,\\n                        depositAt: block.timestamp - (_doneDays * 1 days),\\n                        canHarvestTimestamp: block.timestamp +\\n                            (harvestTime * 1 days),\\n                        bonusRate: bonusRateForTime[_stakedDays],\\n                        isPaid: false\\n                    })\\n                );\\n            }\\n        }\\n    }\\n\\n    /*\\n     *Updated addOldUser function //_amount is the MeacToken amount with decimals\\n     *Added new parameter StakedDays.\\n     *Both lockedDays and StakeDays Parameter will store in userInfo\\n     *lockedDays parameter will set DepositAt timestamp\\n     *stakedDays parameter will set the canHarvestTimestamp\\n     **/\\n    function addOldUser(\\n        address _walletAddress,\\n        uint256 _amount,\\n        uint256 _doneDays,\\n        uint256 _stakedDays,\\n        uint256 _pid\\n    ) public onlyOwner {\\n        UserInfo storage user = userInfo[_pid][_walletAddress];\\n        user.amount = user.amount + _amount;\\n        user.doneDays = user.doneDays + _doneDays;\\n        user.stakedDays = user.stakedDays + _stakedDays;\\n\\n        if (_doneDays > _stakedDays) {\\n            user.userRewardInfo.push(\\n                UserRewardInfo({\\n                    amount: _amount,\\n                    depositAt: block.timestamp - (_doneDays * 1 days),\\n                    canHarvestTimestamp: block.timestamp,\\n                    bonusRate: bonusRateForTime[_stakedDays],\\n                    isPaid: false\\n                })\\n            );\\n        } else {\\n            uint256 harvestTime = _stakedDays - _doneDays;\\n            user.userRewardInfo.push(\\n                UserRewardInfo({\\n                    amount: _amount,\\n                    depositAt: block.timestamp - (_doneDays * 1 days),\\n                    canHarvestTimestamp: block.timestamp +\\n                        (harvestTime * 1 days),\\n                    bonusRate: bonusRateForTime[_stakedDays],\\n                    isPaid: false\\n                })\\n            );\\n        }\\n    }\\n\\n    // Deposit MEAC tokens to MasterChef for MeacToken allocation.\\n    function deposit(uint256 _pid, uint256 _amount, uint256 _days) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        // updatePool(_pid);\\n        if (user.amount > 0) {\\n            uint256 currentTime = block.timestamp;\\n            uint256 pending;\\n            for (uint256 i = 0; i < user.userRewardInfo.length; i++) {\\n                UserRewardInfo storage rewardInfo = user.userRewardInfo[i];\\n                if (rewardInfo.isPaid) continue;\\n\\n                if (currentTime > rewardInfo.canHarvestTimestamp) {\\n                    uint256 bonusRate = rewardInfo.bonusRate;\\n                    pending =\\n                        pending +\\n                        (rewardInfo.amount +\\n                            ((rewardInfo.amount * bonusRate) / 100));\\n                    rewardInfo.isPaid = true;\\n                    user.amount = user.amount - rewardInfo.amount;\\n                    rewardInfo.amount = 0;\\n                }\\n            }\\n\\n            if (pending > 0) {\\n                safeLocalTransfer(msg.sender, pending);\\n            }\\n        }\\n\\n        if (_amount > 0) {\\n            pool.lpToken.transferFrom(msg.sender, address(this), _amount);\\n            user.amount = user.amount + _amount;\\n            user.userRewardInfo.push(\\n                UserRewardInfo({\\n                    amount: _amount,\\n                    depositAt: block.timestamp,\\n                    canHarvestTimestamp: block.timestamp + (_days * 1 days),\\n                    bonusRate: bonusRateForTime[_days],\\n                    isPaid: false\\n                })\\n            );\\n        }\\n        emit Deposit(msg.sender, _pid, _amount);\\n    }\\n\\n    function AuserRewardInfo(\\n        uint256 _pid,\\n        address account,\\n        uint256 index\\n    ) public view returns (uint256, uint256, uint256, bool) {\\n        UserInfo storage user = userInfo[_pid][account];\\n        UserRewardInfo storage rewardInfo = user.userRewardInfo[index];\\n        return (\\n            rewardInfo.amount,\\n            rewardInfo.canHarvestTimestamp,\\n            rewardInfo.bonusRate,\\n            rewardInfo.isPaid\\n        );\\n    }\\n\\n    // Withdraw MEAC tokens from MasterChef.\\n    function withdraw(uint256 _pid) public {\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount > 0, \\\"withdraw: not good\\\");\\n        if (user.amount > 0) {\\n            uint256 currentTime = block.timestamp;\\n            uint256 pending;\\n            uint256 sumAmount = 0;\\n            //uint256 restAmount;\\n            uint256 totalEarning = 0;\\n            for (uint256 i = 0; i < user.userRewardInfo.length; i++) {\\n                UserRewardInfo storage rewardInfo = user.userRewardInfo[i];\\n                if (rewardInfo.isPaid) continue;\\n                if (currentTime <= rewardInfo.canHarvestTimestamp) continue;\\n                uint256 bonusRate = rewardInfo.bonusRate;\\n                uint256 userAmount = rewardInfo.amount;\\n                sumAmount += userAmount;\\n                pending = userAmount + ((rewardInfo.amount * bonusRate) / 100);\\n                rewardInfo.isPaid = true;\\n                rewardInfo.amount = 0;\\n                totalEarning += pending;\\n            }\\n            require(totalEarning > 0, \\\"funds still in lock period.\\\");\\n            user.amount = user.amount - sumAmount; //_amount\\n            safeLocalTransfer(msg.sender, totalEarning); //_amount.add(pending)\\n        }\\n    }\\n\\n    // Safe local transfer function, just in case if rounding error causes pool to not have enough MeacToken.\\n    function safeLocalTransfer(address _to, uint256 _amount) internal {\\n        uint256 localBal = local.balanceOf(address(this));\\n        if (_amount > localBal) {\\n            local.transfer(_to, localBal);\\n        } else {\\n            local.transfer(_to, _amount);\\n        }\\n    }\\n\\n    //Shows the count of days since user had staked their MEAC tokens\\n    function userDoneDays(\\n        address _user,\\n        uint256 index\\n    ) public view returns (uint256 doneDays) {\\n        uint256 _pid = 0;\\n        UserInfo storage user = userInfo[_pid][_user];\\n        UserRewardInfo storage rewardInfo = user.userRewardInfo[index];\\n        doneDays = block.timestamp - rewardInfo.depositAt;\\n        doneDays = doneDays / 1 days;\\n        return doneDays;\\n    }\\n\\n    //Shows for how many days users staked the MEAC tokens\\n    function userStakedDays(\\n        address _user,\\n        uint256 index\\n    ) public view returns (uint256 stakedDays) {\\n        uint256 _pid = 0;\\n        UserInfo storage user = userInfo[_pid][_user];\\n        stakedDays =\\n            user.userRewardInfo[index].canHarvestTimestamp -\\n            (user.userRewardInfo[index].depositAt);\\n        stakedDays = stakedDays / (1 days);\\n        return stakedDays;\\n    }\\n\\n    //Allow owner to tranfer any IERC20 token from this contract to other addresses\\n    function transferERC20(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner returns (bool) {\\n        uint256 erc20balance = token.balanceOf(address(this));\\n        require(amount <= erc20balance, \\\"balance is low\\\");\\n        token.transfer(to, amount);\\n        return true;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_local\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"AuserRewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BONUS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_doneDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakedDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"addOldUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_walletAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"doneDaysList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakedDaysList\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_pids\",\"type\":\"uint256[]\"}],\"name\":\"addOldUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusRateForTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"getBonusRateFromLockedDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bonusRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"local\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"totalPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"userDoneDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"doneDays\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"doneDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedDays\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"userStakedDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedDays\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking_pool", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005783597ba1a5e5f5182db58dbce47657a9535eec", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://78e9bdb475c354fae517952eaa93a1521a07f786535a3fcb24635bb363dd13ec"}