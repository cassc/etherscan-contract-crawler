{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IYield {\r\n    function stake(address user, uint256 amount) external;\r\n}\r\n\r\ninterface ISTS {\r\n    function sellFeeRecipient() external view returns (address);\r\n    function sellFee() external view returns (uint256);\r\n    function getOwner() external view returns (address);\r\n}\r\n\r\ninterface IStasisIntermediary {\r\n    function addToReinvestAmount(address reinvestor, uint256 amount) external;\r\n}\r\n\r\ncontract CustomizedRewards {\r\n\r\n    struct FarmCustomization {\r\n        uint256 compoundPercent; // percent to be compounded\r\n        uint256 claimPercent; // percent to be claimed\r\n        uint256 liquidatePercent; // percent to be liquidated to STS+\r\n        bool claimToStaking; // whether or not to claim to STS Staking\r\n    }\r\n\r\n    struct StakingCustomization {\r\n        uint256 compoundPercent; // percent to be compounded\r\n        uint256 claimPercent; // percent to be claimed\r\n        uint256 liquidatePercent; // percent to be liquidated to STS+\r\n    }\r\n\r\n    struct UserInfo {\r\n        FarmCustomization STSPlusFarmRewards;\r\n        FarmCustomization MATICFarmRewards;\r\n        StakingCustomization StakingRewards;\r\n    }\r\n\r\n    // Maps user to their reward customizations\r\n    mapping ( address => UserInfo ) public userInfo;\r\n\r\n\r\n    // Addresses needed for customization\r\n    address public immutable STS;\r\n    address public immutable STSPlus;\r\n    address public immutable STSStaking;\r\n    address public immutable STSPlusFarm;\r\n    address public immutable MATICFarm;\r\n    IUniswapV2Router02 public immutable router;\r\n    address public stasisIntermediary;\r\n\r\n    // Liquidate Fee Denominator\r\n    uint256 public constant TAX_DENOM = 10000;\r\n\r\n    constructor(\r\n        address STS_,\r\n        address STSPlus_,\r\n        address STSStaking_,\r\n        address STSPlusFarm_,\r\n        address MATICFarm_,\r\n        address router_\r\n    ) {\r\n        STS = STS_;\r\n        STSPlus = STSPlus_;\r\n        STSStaking = STSStaking_;\r\n        STSPlusFarm = STSPlusFarm_;\r\n        MATICFarm = MATICFarm_;\r\n        router = IUniswapV2Router02(router_);\r\n    }\r\n\r\n    function setCustomizedFarmRewards(\r\n        bool maticFarm,\r\n        uint256 compound_,\r\n        uint256 claim_,\r\n        uint256 liquidate_,\r\n        bool claimToStaking_\r\n    ) external {\r\n        _setCustomizedFarmRewards(\r\n            msg.sender,\r\n            maticFarm,\r\n            compound_,\r\n            claim_,\r\n            liquidate_,\r\n            claimToStaking_\r\n        );\r\n    }\r\n\r\n    function setCustomizedStakingRewards(\r\n        uint256 compound_,\r\n        uint256 claim_,\r\n        uint256 liquidate_\r\n    ) external {\r\n        _setCustomizedStakingRewards(msg.sender, compound_, claim_, liquidate_);\r\n    }\r\n\r\n    function trigger(address user, uint256 amount, address yieldToken) external {\r\n\r\n        uint256 compound;\r\n        uint256 claim;\r\n        uint256 liquidate;\r\n        uint256 total;\r\n\r\n        uint256 bal = IERC20(STS).balanceOf(address(this));\r\n        if (amount > bal) {\r\n            amount = bal;\r\n        }\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        if (msg.sender == STSStaking) {\r\n            // STS Staking\r\n\r\n            // determine how to process rewards\r\n            compound = userInfo[user].StakingRewards.compoundPercent;\r\n            claim = userInfo[user].StakingRewards.claimPercent;\r\n            liquidate = userInfo[user].StakingRewards.liquidatePercent;\r\n            total = compound + claim + liquidate;\r\n\r\n            if (total == 0) {\r\n                // simply claim reward\r\n                require(\r\n                    IERC20(STS).transfer(user, amount),\r\n                    'Failure On Token Claim'\r\n                );\r\n            } else {\r\n\r\n                if (claim > 0) {\r\n                    uint256 claimAmount = ( amount * claim ) / total;\r\n                    if (claimAmount > 0) {\r\n                        _claim(claimAmount, user, false);\r\n                    }\r\n                }\r\n\r\n                if (liquidate > 0) {\r\n                    uint256 liquidateAmount = ( amount * liquidate ) / total;\r\n                    if (liquidateAmount > 0) {\r\n                        _liquidate(liquidateAmount, user);\r\n                    }\r\n                }\r\n\r\n                if (compound > 0) {\r\n                    uint256 compoundAmount = ( amount * compound ) / total;\r\n                    if (compoundAmount > 0) {\r\n                        _claim(compoundAmount, user, true);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        } else if (msg.sender == STSPlusFarm) {\r\n            // STSPlus Farm\r\n\r\n            // determine how to process rewards\r\n            compound = userInfo[user].STSPlusFarmRewards.compoundPercent;\r\n            claim = userInfo[user].STSPlusFarmRewards.claimPercent;\r\n            liquidate = userInfo[user].STSPlusFarmRewards.liquidatePercent;\r\n            total = compound + claim + liquidate;\r\n\r\n            if (total == 0) {\r\n                // simply claim reward\r\n                require(\r\n                    IERC20(STS).transfer(user, amount),\r\n                    'Failure On Token Claim'\r\n                );\r\n            } else {\r\n\r\n                if (claim > 0) {\r\n                    uint256 claimAmount = ( amount * claim ) / total;\r\n                    if (claimAmount > 0) {\r\n                        _claim(claimAmount, user, userInfo[user].STSPlusFarmRewards.claimToStaking);\r\n                    }\r\n                }\r\n\r\n                if (liquidate > 0) {\r\n                    uint256 liquidateAmount = ( amount * liquidate ) / total;\r\n                    if (liquidateAmount > 0) {\r\n                        _liquidate(liquidateAmount, user);\r\n                    }\r\n                }\r\n\r\n                if (compound > 0) {\r\n                    uint256 compoundAmount = ( amount * compound ) / total;\r\n                    if (compoundAmount > 1) {\r\n\r\n                        // convert STS into STS-STS+ LP Tokens\r\n                        uint256 half = compoundAmount / 2;\r\n\r\n                        // swap path for STS into MATIC\r\n                        address[] memory path = new address[](2);\r\n                        path[0] = STS;\r\n                        path[1] = STSPlus;\r\n\r\n                        // swap half STS into STS+, approve full amount for adding liquidity\r\n                        IERC20(STS).approve(address(router), compoundAmount);\r\n                        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                            half, 1, path, address(this), block.timestamp + 100\r\n                        );\r\n\r\n                        // approve of STSPlus Balance\r\n                        uint256 STSPBal = IERC20(STSPlus).balanceOf(address(this));\r\n                        IERC20(STSPlus).approve(address(router), STSPBal);\r\n\r\n                        // clear memory\r\n                        delete path;\r\n\r\n                        // add maticReceived and the other half of matic into liquidity\r\n                        // there will be STS+ dust left over from this, which will be sent back to the contract\r\n                        // to avoid users taking advantage of dust, we track MATIC balance before and after\r\n                        // owner can convert STS+ dust into more STS for rewards if he/she so chooses\r\n                        // by calling the function `rollOverDustIntoRewards()`\r\n                        router.addLiquidity(\r\n                            STS, STSPlus, compoundAmount - half, STSPBal, 1, 1, address(this), block.timestamp + 100\r\n                        );\r\n\r\n                        // refund STS+ dust to yield farm\r\n                        STSPBal = IERC20(STSPlus).balanceOf(address(this));\r\n                        if (STSPBal > 0) {\r\n                            IERC20(STSPlus).transfer(msg.sender, STSPBal);\r\n                        }\r\n\r\n                        // compound LP Balance\r\n                        _compoundYield(yieldToken, user);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        } else if (msg.sender == MATICFarm) {\r\n            // MATIC Farm\r\n\r\n            // determine how to process rewards\r\n            compound = userInfo[user].MATICFarmRewards.compoundPercent;\r\n            claim = userInfo[user].MATICFarmRewards.claimPercent;\r\n            liquidate = userInfo[user].MATICFarmRewards.liquidatePercent;\r\n            total = compound + claim + liquidate;\r\n\r\n            if (total == 0) {\r\n                // simply claim reward\r\n                require(\r\n                    IERC20(STS).transfer(user, amount),\r\n                    'Failure On Token Claim'\r\n                );\r\n            } else {\r\n\r\n                if (claim > 0) {\r\n                    uint256 claimAmount = ( amount * claim ) / total;\r\n                    if (claimAmount > 0) {\r\n                        _claim(claimAmount, user, userInfo[user].MATICFarmRewards.claimToStaking);\r\n                    }\r\n                }\r\n\r\n                if (liquidate > 0) {\r\n                    uint256 liquidateAmount = ( amount * liquidate ) / total;\r\n                    if (liquidateAmount > 0) {\r\n                        _liquidate(liquidateAmount, user);\r\n                    }\r\n                }\r\n\r\n                if (compound > 0) {\r\n                    uint256 compoundAmount = ( amount * compound ) / total;\r\n                    if (compoundAmount > 1) {\r\n\r\n                        // convert STS into STS-MATIC LP Tokens\r\n                        uint256 half = compoundAmount / 2;\r\n\r\n                        // swap path for STS into MATIC\r\n                        address[] memory path = new address[](2);\r\n                        path[0] = STS;\r\n                        path[1] = router.WETH();\r\n\r\n                        // swap half STS into MATIC, approve full amount for adding liquidity\r\n                        IERC20(STS).approve(address(router), compoundAmount);\r\n                        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                            half, 1, path, address(this), block.timestamp + 100\r\n                        );\r\n\r\n                        // clear memory\r\n                        delete path;\r\n\r\n                        // add maticReceived and the other half of matic into liquidity\r\n                        // there will be MATIC dust left over from this\r\n                        // to avoid users taking advantage of dust, we track MATIC balance before and after\r\n                        // owner can convert MATIC dust into more STS for rewards if he/she so chooses\r\n                        // by calling the function `rollOverDustIntoRewards()`\r\n                        router.addLiquidityETH{value: address(this).balance}(\r\n                            STS, compoundAmount - half, 1, 1, address(this), block.timestamp + 100\r\n                        );\r\n\r\n                        // refund MATIC dust to yield farm\r\n                        if (address(this).balance > 0) {\r\n                            (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n                            require(s);\r\n                        }\r\n\r\n                        // compound LP Balance\r\n                        _compoundYield(yieldToken, user);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function _takeSTSSellFee(uint256 amount) internal returns (uint256){\r\n        uint256 fee = ( amount * ISTS(STS).sellFee() ) / TAX_DENOM;\r\n        if (fee > 0) {\r\n            address recipient = ISTS(STS).sellFeeRecipient();\r\n            if (recipient != address(0)) {\r\n                IERC20(STS).transfer(recipient, fee);\r\n            }\r\n        }\r\n        return amount - fee;\r\n    }\r\n\r\n    function _liquidate(uint256 amount, address user) internal {\r\n        // liquidate token for STS+ using MATIC router\r\n        address[] memory path = new address[](2);\r\n        path[0] = STS;\r\n        path[1] = STSPlus;\r\n\r\n        // TAKE FEE IN STS\r\n        uint256 sellAmount = _takeSTSSellFee(amount);\r\n\r\n        // liquidates token for STS+\r\n        IERC20(STS).approve(address(router), sellAmount);\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            sellAmount, 1, path, user, block.timestamp + 100\r\n        );\r\n\r\n        // clear memory\r\n        delete path;\r\n    }\r\n\r\n    function _claim(uint256 amount, address user, bool toStaking) internal {\r\n\r\n        if (toStaking && stasisIntermediary != address(0)) {\r\n            // deposit claimAmount into staking contract on behalf of user\r\n            IERC20(STS).transfer(stasisIntermediary, amount);\r\n            IStasisIntermediary(stasisIntermediary).addToReinvestAmount(user, amount);\r\n        } else {\r\n            // transfer claimAmount tokens to user\r\n            require(\r\n                IERC20(STS).transfer(user, amount),\r\n                'Failure On Token Claim'\r\n            );\r\n        }\r\n    }\r\n\r\n    function _compoundYield(address yieldToken, address user) internal {\r\n        \r\n        // get LP balance received\r\n        uint256 LPBalance = IERC20(yieldToken).balanceOf(address(this));\r\n\r\n        // approve of yield farm\r\n        IERC20(yieldToken).approve(msg.sender, LPBalance);\r\n\r\n        // stake balance for user for user\r\n        IYield(msg.sender).stake(user, LPBalance);\r\n    }\r\n\r\n    function _setCustomizedFarmRewards(\r\n        address user,\r\n        bool maticFarm,\r\n        uint256 compound_,\r\n        uint256 claim_,\r\n        uint256 liquidate_,\r\n        bool claimToStaking_\r\n    ) internal {\r\n\r\n        FarmCustomization memory reward = FarmCustomization({\r\n            compoundPercent: compound_,\r\n            claimPercent: claim_,\r\n            liquidatePercent: liquidate_,\r\n            claimToStaking: claimToStaking_\r\n        });\r\n\r\n        if (maticFarm) {\r\n            userInfo[user].MATICFarmRewards = reward;\r\n        } else {\r\n            userInfo[user].STSPlusFarmRewards = reward;\r\n        }\r\n\r\n    }\r\n\r\n    function _setCustomizedStakingRewards(\r\n        address user,\r\n        uint256 compound_,\r\n        uint256 claim_,\r\n        uint256 liquidate_\r\n    ) internal {\r\n\r\n        userInfo[user].StakingRewards = StakingCustomization({\r\n            compoundPercent: compound_,\r\n            claimPercent: claim_,\r\n            liquidatePercent: liquidate_\r\n        });\r\n\r\n    }\r\n\r\n    function ownerSetCustomizedStakingRewards(\r\n        address user,\r\n        uint256 compound_,\r\n        uint256 claim_,\r\n        uint256 liquidate_\r\n    ) external {\r\n        require(msg.sender == ISTS(STS).getOwner(), 'Only Owner');\r\n        _setCustomizedStakingRewards(user, compound_, claim_, liquidate_);\r\n    }\r\n\r\n    function ownerSetCustomizedFarmRewards(\r\n        address user,\r\n        bool maticFarm,\r\n        uint256 compound_,\r\n        uint256 claim_,\r\n        uint256 liquidate_,\r\n        bool claimToStaking_\r\n    ) external {\r\n        require(msg.sender == ISTS(STS).getOwner(), 'Only Owner');\r\n        _setCustomizedFarmRewards(user, maticFarm, compound_, claim_, liquidate_, claimToStaking_);\r\n    }\r\n\r\n    function withdraw(address token) external {\r\n        require(msg.sender == ISTS(STS).getOwner(), 'Only Owner');\r\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function withdrawETH() external {\r\n        require(msg.sender == ISTS(STS).getOwner(), 'Only Owner');\r\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    function setStasisIntermediary(address stasisIntermediary_) external {\r\n        require(msg.sender == ISTS(STS).getOwner(), 'Only Owner');\r\n        stasisIntermediary = stasisIntermediary_;\r\n    }\r\n\r\n    receive() external payable{}\r\n\r\n    function getMaticFarmCustomization(address user) external view returns (FarmCustomization memory) {\r\n        return userInfo[user].MATICFarmRewards;\r\n    }\r\n\r\n    function getSTSPlusFarmCustomization(address user) external view returns (FarmCustomization memory) {\r\n        return userInfo[user].STSPlusFarmRewards;\r\n    }\r\n\r\n    function getStakingCustomization(address user) external view returns (StakingCustomization memory) {\r\n        return userInfo[user].StakingRewards;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"STS_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"STSPlus_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"STSStaking_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"STSPlusFarm_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"MATICFarm_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"MATICFarm\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STSPlus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STSPlusFarm\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STSStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TAX_DENOM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getMaticFarmCustomization\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"compoundPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidatePercent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimToStaking\",\"type\":\"bool\"}],\"internalType\":\"struct CustomizedRewards.FarmCustomization\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getSTSPlusFarmCustomization\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"compoundPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidatePercent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimToStaking\",\"type\":\"bool\"}],\"internalType\":\"struct CustomizedRewards.FarmCustomization\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getStakingCustomization\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"compoundPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidatePercent\",\"type\":\"uint256\"}],\"internalType\":\"struct CustomizedRewards.StakingCustomization\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"maticFarm\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"compound_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claim_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidate_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimToStaking_\",\"type\":\"bool\"}],\"name\":\"ownerSetCustomizedFarmRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"compound_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claim_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidate_\",\"type\":\"uint256\"}],\"name\":\"ownerSetCustomizedStakingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"maticFarm\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"compound_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claim_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidate_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimToStaking_\",\"type\":\"bool\"}],\"name\":\"setCustomizedFarmRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"compound_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claim_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidate_\",\"type\":\"uint256\"}],\"name\":\"setCustomizedStakingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stasisIntermediary_\",\"type\":\"address\"}],\"name\":\"setStasisIntermediary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stasisIntermediary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"yieldToken\",\"type\":\"address\"}],\"name\":\"trigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"compoundPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidatePercent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimToStaking\",\"type\":\"bool\"}],\"internalType\":\"struct CustomizedRewards.FarmCustomization\",\"name\":\"STSPlusFarmRewards\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"compoundPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidatePercent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimToStaking\",\"type\":\"bool\"}],\"internalType\":\"struct CustomizedRewards.FarmCustomization\",\"name\":\"MATICFarmRewards\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"compoundPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidatePercent\",\"type\":\"uint256\"}],\"internalType\":\"struct CustomizedRewards.StakingCustomization\",\"name\":\"StakingRewards\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CustomizedRewards", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fc3559771aa5a0666420f2365cf66139fbf4b37f000000000000000000000000e56bdaae614997ea6a64bbe22645542162ec890c000000000000000000000000c6b2c8783cb12436fa89253a746c5b92bff43f6b000000000000000000000000ae6324ae020436be7d652e0e41316aa7483007e4000000000000000000000000ee491003c3a3f0d6f69f9469c3ca7d157c27dfcc000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://86193396a0a00965e610994b2e235608f99a455886316ad3f9070cb9a53dfa21"}