{"SourceCode": "# @version 0.3.7\r\n\"\"\"\r\n@title Child-Chain Streamer\r\n@author Curve.Fi\r\n@license MIT\r\n@notice Evenly streams one or more reward tokens to a single recipient\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nstruct RewardToken:\r\n    distributor: address\r\n    period_finish: uint256\r\n    rate: uint256\r\n    duration: uint256\r\n    received: uint256\r\n    paid: uint256\r\n\r\n\r\nowner: public(address)\r\nfuture_owner: public(address)\r\n\r\nreward_receiver: public(address)\r\nreward_tokens: public(address[8])\r\nreward_count: public(uint256)\r\nreward_data: public(HashMap[address, RewardToken])\r\nlast_update_time: public(uint256)\r\n\r\n\r\n@external\r\ndef __init__(_owner: address, _receiver: address, _reward: address):\r\n    self.owner = _owner\r\n    self.reward_receiver = _receiver\r\n\r\n    self.reward_tokens[0] = _reward\r\n    self.reward_count = 1\r\n    self.reward_data[_reward].distributor = _owner\r\n    self.reward_data[_reward].duration = 86400 * 7\r\n\r\n\r\n@external\r\ndef add_reward(_token: address, _distributor: address, _duration: uint256):\r\n    \"\"\"\r\n    @notice Add a reward token\r\n    @param _token Address of the reward token\r\n    @param _distributor Address permitted to call `notify_reward_amount` for this token\r\n    @param _duration Number of seconds that rewards of this token are streamed over\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: owner only\r\n    assert self.reward_data[_token].distributor == empty(address), \"Reward token already added\"\r\n\r\n    idx: uint256 = self.reward_count\r\n    self.reward_tokens[idx] = _token\r\n    self.reward_count = idx + 1\r\n    self.reward_data[_token].distributor = _distributor\r\n    self.reward_data[_token].duration = _duration\r\n\r\n\r\n@external\r\ndef remove_reward(_token: address):\r\n    \"\"\"\r\n    @notice Remove a reward token\r\n    @dev Any remaining balance of the reward token is transferred to the owner\r\n    @param _token Address of the reward token\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert self.reward_data[_token].distributor != empty(address), \"Reward token not added\"\r\n\r\n    self.reward_data[_token] = empty(RewardToken)\r\n    amount: uint256 = ERC20(_token).balanceOf(self)\r\n    response: Bytes[32] = raw_call(\r\n        _token,\r\n        concat(\r\n            method_id(\"transfer(address,uint256)\"),\r\n            convert(msg.sender, bytes32),\r\n            convert(amount, bytes32),\r\n        ),\r\n        max_outsize=32,\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    idx: uint256 = self.reward_count - 1\r\n    for i in range(8):\r\n        if self.reward_tokens[i] == _token:\r\n            self.reward_tokens[i] = self.reward_tokens[idx]\r\n            self.reward_tokens[idx] = empty(address)\r\n            self.reward_count = idx\r\n            return\r\n    raise  # this should never be reached\r\n\r\n\r\n@internal\r\ndef _update_reward(_token: address, _last_update: uint256):\r\n    # update data about a reward and distribute any pending tokens to the receiver\r\n    last_time: uint256 = min(block.timestamp, self.reward_data[_token].period_finish)\r\n    if last_time > _last_update:\r\n        amount: uint256 = (last_time - _last_update) * self.reward_data[_token].rate\r\n        if amount > 0:\r\n            self.reward_data[_token].paid += amount\r\n            response: Bytes[32] = raw_call(\r\n                _token,\r\n                concat(\r\n                    method_id(\"transfer(address,uint256)\"),\r\n                    convert(self.reward_receiver, bytes32),\r\n                    convert(amount, bytes32),\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(response) != 0:\r\n                assert convert(response, bool)\r\n\r\n\r\n@external\r\ndef set_receiver(_receiver: address):\r\n    \"\"\"\r\n    @notice Set the reward receiver\r\n    @dev When the receiver is a smart contract, it must be capable of recognizing\r\n         rewards that are directly pushed to it (without a call to `get_reward`)\r\n    @param _receiver Address of the reward receiver\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    self.reward_receiver = _receiver\r\n\r\n\r\n@external\r\ndef get_reward():\r\n    \"\"\"\r\n    @notice Claim pending rewards for `reward_receiver`\r\n    \"\"\"\r\n    last_update: uint256 = self.last_update_time\r\n    for token in self.reward_tokens:\r\n        if token == empty(address):\r\n            break\r\n        self._update_reward(token, last_update)\r\n    self.last_update_time = block.timestamp\r\n\r\n\r\n@external\r\ndef notify_reward_amount(_token: address):\r\n    \"\"\"\r\n    @notice Notify the contract of a newly received reward\r\n    @dev Only callable by the distributor if there is an active reward period.\r\n         The reward tokens must be transferred into the contract prior to calling\r\n         this function. Rewards are distributed over `reward_duration` seconds.\r\n         Updating the reward amount while an existing reward period is still active\r\n         causes the remaining rewards to be evenly distributed over the new period.\r\n    @param _token Address of the reward token\r\n    \"\"\"\r\n    last_update: uint256 = self.last_update_time\r\n    is_updated: bool = False\r\n    for token in self.reward_tokens:\r\n        if token == empty(address):\r\n            break\r\n\r\n        self._update_reward(token, last_update)\r\n        if token == _token:\r\n            received: uint256 = self.reward_data[token].received\r\n            expected_balance: uint256 = received - self.reward_data[token].paid\r\n            actual_balance: uint256 = ERC20(token).balanceOf(self)\r\n\r\n            if actual_balance > expected_balance:\r\n                new_amount: uint256 = actual_balance - expected_balance\r\n                duration: uint256 = self.reward_data[token].duration\r\n\r\n                if block.timestamp >= self.reward_data[token].period_finish:\r\n                    self.reward_data[token].rate = new_amount / duration\r\n                else:\r\n                    assert msg.sender == self.reward_data[_token].distributor, \"Reward period still active\"\r\n                    remaining: uint256 = self.reward_data[token].period_finish - block.timestamp\r\n                    leftover: uint256 = remaining * self.reward_data[token].rate\r\n                    self.reward_data[token].rate = (new_amount + leftover) / duration\r\n\r\n                self.reward_data[token].period_finish = block.timestamp + duration\r\n                self.reward_data[token].received = received + new_amount\r\n                is_updated = True\r\n\r\n    assert is_updated, \"Invalid token or no new reward\"\r\n    self.last_update_time = block.timestamp\r\n\r\n\r\n@external\r\ndef set_reward_duration(_token: address, _duration: uint256):\r\n    \"\"\"\r\n    @notice Modify the duration that rewards are distributed over\r\n    @dev Only callable when there is not an active reward period\r\n    @param _token Address of the reward token\r\n    @param _duration Number of seconds to distribute rewards over\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert block.timestamp > self.reward_data[_token].period_finish, \"Reward period still active\"\r\n    self.reward_data[_token].duration = _duration\r\n\r\n\r\n@external\r\ndef set_reward_distributor(_token: address, _distributor: address):\r\n    \"\"\"\r\n    @notice Modify the reward distributor\r\n    @param _token Address of the reward token\r\n    @param _distributor Reward distributor\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    self.reward_data[_token].distributor = _distributor\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_owner: address):\r\n    \"\"\"\r\n    @notice Initiate ownership tansfer of the contract\r\n    @param _owner Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.future_owner = _owner\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept a pending ownership transfer\r\n    \"\"\"\r\n    owner: address = self.future_owner\r\n    assert msg.sender == owner  # dev: only new owner\r\n\r\n    self.owner = owner", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_reward\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_reward\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_distributor\",\"type\":\"address\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_reward\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_receiver\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"get_reward\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"notify_reward_amount\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_reward_duration\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_reward_distributor\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_distributor\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_tokens\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reward_data\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"distributor\",\"type\":\"address\"},{\"name\":\"period_finish\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"received\",\"type\":\"uint256\"},{\"name\":\"paid\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_update_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Child-Chain Streamer", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000ff12c0ac51248ab35485df75dd6bb14de1cc9b100000000000000000000000002fd595d3df1f9ecfe8f9fa3378ca26fdf087a40a00000000000000000000000027f485b62c4a7e635f561a87560adf5090239e93", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}