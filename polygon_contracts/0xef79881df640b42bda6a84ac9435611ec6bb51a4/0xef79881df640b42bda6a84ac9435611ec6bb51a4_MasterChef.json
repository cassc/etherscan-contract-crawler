{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nimport \\\"./interfaces/ERC20.sol\\\";\\nimport \\\"./interfaces/Address.sol\\\";\\nimport \\\"./interfaces/EnumerableSet.sol\\\";\\nimport \\\"./interfaces/Ownable.sol\\\";\\nimport \\\"./interfaces/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./interfaces/IStrategy.sol\\\";\\nimport \\\"./interfaces/IToken.sol\\\";\\n\\n/// @title MasterChef yield farming contract\\n/// @author CubFinance, @fbsloXBT\\n\\ncontract MasterChef is Ownable, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice Address of the reward token\\n    address public rewardToken;\\n    /// @notice Maximum number of issued tokens, 24.7M issues, 1.3M minted at launch (200k dev fund, 1M airdrop, 100k initial liquidity) = 26M total\\n    uint256 public maxIssued = 24700000 ether;\\n\\n    /// @notice Info of each user.\\n    struct UserInfo {\\n        uint256 shares; //How many LP tokens the user has provided.\\n        uint256 rewardDebt; //Reward debt. See explanation below.\\n\\n        // We do some fancy math here. Basically, any point in time, the amount of CUB\\n        // entitled to a user but is pending to be distributed is:\\n        //\\n        //   amount = user.shares / sharesTotal * wantLockedTotal\\n        //   pending reward = (amount * pool.accCubPerShare) - user.rewardDebt\\n        //\\n        // Whenever a user deposits or withdraws want tokens to a pool. Here's what happens:\\n        //   1. The pool's `accCubPerShare` (and `lastRewardBlock`) gets updated.\\n        //   2. User receives the pending reward sent to his/her address.\\n        //   3. User's `amount` gets updated.\\n        //   4. User's `rewardDebt` gets updated.\\n    }\\n\\n    /// @notice Info about each pool\\n    struct PoolInfo {\\n        IERC20 want; //Address of the want token.\\n        uint256 allocPoint; //How many allocation points assigned to this pool.\\n        uint256 lastRewardBlock; //Last block number that reward token distribution occurs.\\n        uint256 accTokensPerShare; //Accumulated tokens per share, times 1e12.\\n        address strat; //Strategy vault address that will auto compound want tokens\\n    }\\n\\n    /// @notice Number of tokens issued per block\\n    uint256 public tokensPerBlock = 0;\\n    /// @notice Block number from where inflation schedule is counted\\n    uint256 public startBlock = 0;\\n\\n    /// @notice Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    /// @notice Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n    /// @notice Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n\\n    /// @notice Store data about amount of locked reward tokens\\n    struct pendingRewards {\\n      uint256 startBlock;\\n      uint256 endBlock;\\n      uint256 amount;\\n      uint256 alreadyClaimed;\\n    }\\n    /// @notice An array of pendingRewards structs, storing data about user rewards\\n    mapping(address => pendingRewards[]) public pending;\\n    /// @notice Mapping of block numbers when user last claimed their tokens\\n    mapping(address => uint256) public lastClaim;\\n    /// @notice Number of tokens already issued\\n    uint256 public totalIssuedTokens;\\n\\n    /// @notice Contract where penalty (50% of claimed unlocked tokens) is sent\\n    address public penaltyAddress;\\n    /// @notice Number of blocks per day on Polygon network\\n    uint256 public blockPerDay = 43200;\\n    /// @notice reward lockup period, ~3 months\\n    uint256 public lockupPeriodBlocks = blockPerDay * 90;\\n\\n    /// @notice Information about reward emission schedule\\n    struct EmissionSchedule {\\n      uint256 amount;\\n      uint256 startBlock;\\n      bool alreadyUpdated;\\n    }\\n    /// @notice Array stroing EmissionSchedule structs that are string information about reward emissions\\n    EmissionSchedule[] public emissionScheduleArray;\\n    /// @notice Index of latest emission schedule update\\n    uint256 public emissionScheduleLatest = 0;\\n    /// @notice Number of latest monthly inflation cut\\n    uint256 public latestMonthlyInflationCut = 0;\\n\\n    /// @notice Event emitted when new tokens are deposited\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    /// @notice Event emitted when new tokens are withdrawn\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    /// @notice Event emitted when new tokens are withdrawn without claiming rewards (using emergencyWithdraw function)\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    /// @notice Event emitted when new emission rate is updated\\n    event UpdateEmissionRate(uint256 tokenPerBlock);\\n    /// @notice Event emitted when lockup period is updated\\n    event UpdateLockupPeriod(uint256 oldPeriod, uint256 newPeriod);\\n    /// @notice Event emitted when penalty address is updated\\n    event updatePenaltyAddress(address indexed _newPenaltyAddress);\\n    /// @notice Event emitted when reward tokens are claimed\\n    event Claim(address indexed user, uint256 amount, uint256 penalty);\\n\\n    /**\\n     * @notice Construct a new MasterChef contract\\n     * @param newPenaltyAddress An address where penaly tokens are sent\\n     * @param newStartBlock Block number from where inflation schedule is counted, if 0, it's current block number\\n     * @param newRewardToken The address of the reward token\\n     */\\n    constructor(address newPenaltyAddress, uint256 newStartBlock, address newRewardToken) public {\\n      require(newPenaltyAddress != address(0), '!address(0)');\\n      require(newRewardToken != address(0), '!address(0)');\\n\\n      penaltyAddress = newPenaltyAddress;\\n      rewardToken = newRewardToken;\\n\\n      if (newStartBlock == 0) newStartBlock = block.number;\\n\\n      uint256 blockPerWeek = blockPerDay * 7;\\n\\n      uint64[4] memory _emissionAmounts = [5 ether, 4 ether, 3 ether, 2 ether];\\n      uint256[4] memory _emissionDelays = [0 * blockPerWeek, 1 * blockPerWeek, 2 * blockPerWeek, 3 * blockPerWeek];\\n\\n      for (uint256 i = 0; i < _emissionAmounts.length; i++){\\n        emissionScheduleArray.push(EmissionSchedule(_emissionAmounts[i], newStartBlock + _emissionDelays[i], false));\\n      }\\n    }\\n\\n    /**\\n     * @notice Helper function return length of the poolInfo array.\\n     * @return Length of the poolInfo array\\n     */\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    /// @notice A record of already existing want token addresses\\n    mapping(IERC20 => bool) public poolExistence;\\n    /// @notice A modifier to prevent same want token being added more than once\\n    modifier nonDuplicated(IERC20 _want) {\\n        require(poolExistence[_want] == false, \\\"nonDuplicated: duplicated\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Function to add new pool, can be called  only by owner\\n     * @param _allocPoint Number of allocation points\\n     * @param _want Address of the wanted token\\n     * @param _withUpdate Boolean, if we want to update all pools first\\n     * @param _strat Address of startegy vault contract\\n     */\\n    function add(\\n        uint256 _allocPoint,\\n        IERC20 _want,\\n        bool _withUpdate,\\n        address _strat\\n    ) public onlyOwner nonDuplicated(_want) {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 lastRewardBlock =\\n            block.number > startBlock ? block.number : startBlock;\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n        poolInfo.push(\\n            PoolInfo({\\n                want: _want,\\n                allocPoint: _allocPoint,\\n                lastRewardBlock: lastRewardBlock,\\n                accTokensPerShare: 0,\\n                strat: _strat\\n            })\\n        );\\n\\n        poolExistence[_want] = true;\\n    }\\n\\n    /**\\n     * @notice Function to update the given pool's reward token allocation point. Can only be called by the owner.\\n     * @param _pid PID of the pool we want to update\\n     * @param _allocPoint Number of allocation points\\n     * @param _withUpdate Boolean, if we want to update all pools first\\n     */\\n    function set(\\n        uint256 _pid,\\n        uint256 _allocPoint,\\n        bool _withUpdate\\n    ) public onlyOwner {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\\n            _allocPoint\\n        );\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n    }\\n\\n    /**\\n     * @notice Helper function return difference between 2 numbers\\n     * @return Difference between 2 numbers\\n     */\\n    function getMultiplier(uint256 _from, uint256 _to)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return _to.sub(_from);\\n    }\\n\\n\\n    /**\\n     * @notice View function to see pending tokens that have not entered waiting period yet (user need to call collectPendingRewards(), deposit(), withdraw())\\n     * @return Number of pending tokens not yet int the waiting period\\n     */\\n    function pendingTokens(uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accTokensPerShare = pool.accTokensPerShare;\\n        uint256 sharesTotal = IStrategy(pool.strat).sharesTotal();\\n        if (block.number > pool.lastRewardBlock && sharesTotal != 0) {\\n            uint256 multiplier =\\n                getMultiplier(pool.lastRewardBlock, block.number);\\n            uint256 tokensReward =\\n                multiplier.mul(tokensPerBlock).mul(pool.allocPoint).div(\\n                    totalAllocPoint\\n                );\\n            accTokensPerShare = accTokensPerShare.add(\\n                tokensReward.mul(1e12).div(sharesTotal)\\n            );\\n        }\\n        return user.shares.mul(accTokensPerShare).div(1e12).sub(user.rewardDebt);\\n    }\\n\\n    /**\\n     * @notice View function to see tokens staked in the strategy vault on the frontend\\n     * @return Number of tokens staked in the strategy vault\\n     */\\n    function stakedWantTokens(uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n\\n        uint256 sharesTotal = IStrategy(pool.strat).sharesTotal();\\n        uint256 wantLockedTotal =\\n            IStrategy(poolInfo[_pid].strat).wantLockedTotal();\\n        if (sharesTotal == 0) {\\n            return 0;\\n        }\\n        return user.shares.mul(wantLockedTotal).div(sharesTotal);\\n    }\\n\\n\\n    /// @notice Function to update all pools\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    /**\\n     * @notice Function to update reward variables of the given pool to be up-to-date.\\n     * @param _pid PID of the pool we want to update\\n     */\\n    function updatePool(uint256 _pid) public {\\n        _updateEmission();\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n        uint256 sharesTotal = IStrategy(pool.strat).sharesTotal();\\n        if (sharesTotal == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        if (multiplier <= 0) {\\n            return;\\n        }\\n        uint256 tokensReward =\\n            multiplier.mul(tokensPerBlock).mul(pool.allocPoint).div(\\n                totalAllocPoint\\n            );\\n\\n        if (totalIssuedTokens + tokensReward <= maxIssued){\\n            totalIssuedTokens += tokensReward;\\n            IToken(rewardToken).mint(address(this), tokensReward);\\n        } else if (totalIssuedTokens < maxIssued && totalIssuedTokens + tokensReward > maxIssued) {\\n            tokensReward = maxIssued - totalIssuedTokens;\\n            totalIssuedTokens = maxIssued;\\n            IToken(rewardToken).mint(address(this), tokensReward);\\n        }\\n\\n        pool.accTokensPerShare = pool.accTokensPerShare.add(\\n            tokensReward.mul(1e12).div(sharesTotal)\\n        );\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    /**\\n     * @notice Internal function to update emission rate to match schedule\\n     */\\n    function _updateEmission() internal {\\n      //only for the first month we use emissionSchedule\\n      if (block.number < startBlock + (blockPerDay * 7 * 4)){\\n        if (emissionScheduleArray.length >= emissionScheduleLatest + 1){\\n          //update emission schedule\\n          if (emissionScheduleArray[emissionScheduleLatest].startBlock <= block.number && !emissionScheduleArray[emissionScheduleLatest].alreadyUpdated){\\n            tokensPerBlock = emissionScheduleArray[emissionScheduleLatest].amount;\\n            emissionScheduleArray[emissionScheduleLatest].alreadyUpdated = true;\\n            emissionScheduleLatest += 1;\\n            emit UpdateEmissionRate(tokensPerBlock);\\n          }\\n        }\\n      } else {\\n        //after first month, we just cut inflation by 50% every month\\n        if (latestMonthlyInflationCut == 0 || latestMonthlyInflationCut < block.number - (blockPerDay * 4 * 7)){\\n          latestMonthlyInflationCut = block.number;\\n          tokensPerBlock = tokensPerBlock.div(2);\\n          emit UpdateEmissionRate(tokensPerBlock);\\n        }\\n      }\\n    }\\n\\n    /**\\n     * @notice Claim tokens from pending queue. For 100 pending rewards, ~3M gas is used (~$1.8 on polygon)\\n     * @param _claimLocked Claim locked tokens too and only receive 50% of them, the rest is sent to penalty address\\n     * @param _limit In case if gas limit is lower than gas required to claim entire array of pendingRewards, use _limit to claim just a limited number of pendingRewards\\n     */\\n    function claim(bool _claimLocked, uint256 _limit) external nonReentrant {\\n      uint256 sumLocked;\\n      uint256 sumUnlocked;\\n\\n      if (_limit == 0) _limit = pending[msg.sender].length;\\n\\n      if (_limit > pending[msg.sender].length) _limit = pending[msg.sender].length;\\n\\n      for (uint256 i = 0; i < _limit; i++){\\n        //already fully unlocked\\n        if (block.number.sub(lockupPeriodBlocks) >= pending[msg.sender][i].endBlock){\\n          sumUnlocked = sumUnlocked.add(pending[msg.sender][i].amount.sub(pending[msg.sender][i].alreadyClaimed));\\n          //reset the fully claimed element\\n          delete pending[msg.sender][i];\\n        } else {\\n          uint256 duration = pending[msg.sender][i].endBlock.sub(pending[msg.sender][i].startBlock);\\n          uint256 amountPerBlock = pending[msg.sender][i].amount.div(duration);\\n          uint256 unlockedBlocks = block.number > (lockupPeriodBlocks + pending[msg.sender][i].startBlock) ?\\n            block.number.sub(lockupPeriodBlocks).sub(pending[msg.sender][i].startBlock) : 0;\\n          uint256 unlockedAmount = unlockedBlocks.mul(amountPerBlock);\\n          //remaining locked tokens\\n          sumLocked = sumLocked.add(pending[msg.sender][i].amount.sub(unlockedAmount.add(pending[msg.sender][i].alreadyClaimed)));\\n\\n          sumUnlocked = sumUnlocked.add(unlockedAmount.sub(pending[msg.sender][i].alreadyClaimed));\\n          pending[msg.sender][i].alreadyClaimed = pending[msg.sender][i].alreadyClaimed.add(unlockedAmount);\\n\\n          //if we are also claiming locked rewards, delete every element\\n          if (_claimLocked){\\n            delete pending[msg.sender][i];\\n          }\\n        }\\n      }\\n\\n      //remove only unlocked pendingRewards\\n      if (!_claimLocked){\\n        safeTokensTransfer(msg.sender, sumUnlocked);\\n      } else {\\n        safeTokensTransfer(msg.sender, sumUnlocked.add(sumLocked.div(2)));\\n        safeTokensTransfer(penaltyAddress, sumLocked.div(2));\\n      }\\n\\n      //Now remove deleted elements, so they won't stay in the array\\n      //Since using `delete` leaves a empty space, and using `for` loop could miss some elements,\\n      //we first check if element is deleted and if it is, we replace with with last element and then pop it\\n      //Since last element can also be deleted, we check, and retry again if it is\\n      //This will change the order\\n      uint256 i = 0;\\n      uint256 j = 0;\\n      while(j < _limit){\\n        if (pending[msg.sender][i].amount == 0){ //deleted element\\n          pending[msg.sender][i] = pending[msg.sender][pending[msg.sender].length - 1];\\n          pending[msg.sender].pop();\\n        } else {\\n          i++;\\n        }\\n        j++;\\n      }\\n\\n      Claim(msg.sender, sumUnlocked + sumLocked.div(2), sumLocked.div(2));\\n    }\\n\\n    /**\\n     * @notice Get the sum of all pending unlocked tokens\\n     * @return Number of unlocked tokens that can be claimed without penalty\\n     */\\n    function unlockedTokens(address _user) external view returns (uint256) {\\n      uint256 sumUnlocked;\\n\\n      for (uint256 i = 0; i < pending[_user].length; i++){\\n        //already fully unlocked\\n        if (block.number.sub(lockupPeriodBlocks) >= pending[_user][i].endBlock){\\n          sumUnlocked += pending[_user][i].amount - pending[_user][i].alreadyClaimed;\\n        } else {\\n          uint256 duration = pending[_user][i].endBlock.sub(pending[_user][i].startBlock);\\n          uint256 amountPerBlock = pending[_user][i].amount.div(duration);\\n          uint256 unlockedBlocks = block.number > (lockupPeriodBlocks + pending[msg.sender][i].startBlock) ?\\n            block.number.sub(lockupPeriodBlocks).sub(pending[msg.sender][i].startBlock) : 0;\\n          uint256 unlockedAmount = unlockedBlocks.mul(amountPerBlock);\\n          sumUnlocked += unlockedAmount.sub(pending[_user][i].alreadyClaimed);\\n        }\\n      }\\n\\n      return sumUnlocked;\\n    }\\n\\n    /**\\n     * @notice Get the sum of all pending locked tokens\\n     * @return Number of locked tokens that will require paying 50% penalty if claimed\\n     */\\n    function lockedTokens(address _user) external view returns (uint256) {\\n      uint256 sumLocked = 0;\\n\\n      for (uint256 i = 0; i < pending[_user].length; i++){\\n        if (block.number.sub(lockupPeriodBlocks) >= pending[_user][i].endBlock){\\n          //already fully unlocked\\n        } else {\\n          uint256 duration = pending[_user][i].endBlock.sub(pending[_user][i].startBlock);\\n          uint256 amountPerBlock = pending[_user][i].amount.div(duration);\\n          uint256 unlockedBlocks = block.number > (lockupPeriodBlocks + pending[msg.sender][i].startBlock) ?\\n            block.number.sub(lockupPeriodBlocks).sub(pending[msg.sender][i].startBlock) : 0;\\n          uint256 unlockedAmount = unlockedBlocks.mul(amountPerBlock);\\n          sumLocked += pending[_user][i].amount.sub(unlockedAmount.add(pending[_user][i].alreadyClaimed));\\n        }\\n      }\\n\\n      return sumLocked;\\n    }\\n\\n    /**\\n     * @notice Get the number of pendingRewards not claimed yet\\n     * @param user Address of the user\\n     * @return Length of pending array\\n     */\\n    function pendingLength(address user) external view returns (uint256) {\\n      return pending[user].length;\\n    }\\n\\n    /**\\n     * @notice Deposit Want tokens from user -> This contract -> Strategy (compounding)\\n     * @param _pid PID of the pool\\n     * @param _wantAmt Amount of tokens to deposit\\n     */\\n    function deposit(uint256 _pid, uint256 _wantAmt) public nonReentrant {\\n        updatePool(_pid);\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n\\n        if (user.shares > 0) {\\n            uint256 _pending =\\n                user.shares.mul(pool.accTokensPerShare).div(1e12).sub(\\n                    user.rewardDebt\\n                );\\n            if (_pending > 0) {\\n              pending[msg.sender].push(pendingRewards(\\n                  lastClaim[msg.sender],\\n                  block.number,\\n                  _pending,\\n                  0\\n              ));\\n            }\\n        }\\n        if (_wantAmt > 0) {\\n            pool.want.safeTransferFrom(\\n                address(msg.sender),\\n                address(this),\\n                _wantAmt\\n            );\\n\\n            pool.want.safeIncreaseAllowance(pool.strat, _wantAmt);\\n            uint256 sharesAdded =\\n                IStrategy(poolInfo[_pid].strat).deposit(_wantAmt);\\n            user.shares = user.shares.add(sharesAdded);\\n        }\\n        lastClaim[msg.sender] = block.number;\\n        user.rewardDebt = user.shares.mul(pool.accTokensPerShare).div(1e12);\\n        emit Deposit(msg.sender, _pid, _wantAmt);\\n    }\\n\\n    /**\\n     * @notice Withdraw LP tokens from Strategy (compounding) -> This contract -> user\\n     * @param _pid PID of the pool\\n     * @param _wantAmt Amount of tokens to withdraw\\n     */\\n    function withdraw(uint256 _pid, uint256 _wantAmt) public nonReentrant {\\n        updatePool(_pid);\\n\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n\\n        uint256 wantLockedTotal =\\n            IStrategy(poolInfo[_pid].strat).wantLockedTotal();\\n        uint256 sharesTotal = IStrategy(poolInfo[_pid].strat).sharesTotal();\\n\\n        require(user.shares > 0, \\\"user.shares is 0\\\");\\n        require(sharesTotal > 0, \\\"sharesTotal is 0\\\");\\n\\n        //collect rewards and add the to pending queue\\n        uint256 _pending =\\n            user.shares.mul(pool.accTokensPerShare).div(1e12).sub(\\n                user.rewardDebt\\n            );\\n        if (_pending > 0) {\\n          pending[msg.sender].push(pendingRewards(\\n              lastClaim[msg.sender],\\n              block.number,\\n              _pending,\\n              0\\n          ));\\n        }\\n        // Withdraw want tokens\\n        uint256 amount = user.shares.mul(wantLockedTotal).div(sharesTotal);\\n        if (_wantAmt > amount) {\\n            _wantAmt = amount;\\n        }\\n        if (_wantAmt > 0) {\\n            uint256 sharesRemoved =\\n                IStrategy(poolInfo[_pid].strat).withdraw(_wantAmt);\\n\\n            if (sharesRemoved > user.shares) {\\n                user.shares = 0;\\n            } else {\\n                user.shares = user.shares.sub(sharesRemoved);\\n            }\\n\\n            uint256 wantBal = IERC20(pool.want).balanceOf(address(this));\\n            if (wantBal < _wantAmt) {\\n                _wantAmt = wantBal;\\n            }\\n            pool.want.safeTransfer(address(msg.sender), _wantAmt);\\n        }\\n        lastClaim[msg.sender] = block.number;\\n        user.rewardDebt = user.shares.mul(pool.accTokensPerShare).div(1e12);\\n        emit Withdraw(msg.sender, _pid, _wantAmt);\\n    }\\n\\n    /**\\n     * @notice Withdraw all tokens from the pool\\n     * @param _pid PID of the pool\\n     */\\n    function withdrawAll(uint256 _pid) public nonReentrant {\\n        withdraw(_pid, uint256(-1));\\n    }\\n\\n    /**\\n     * @notice Withdraw all tokens from the pool, without caring about rewards. EMERGENCY ONLY.\\n     * @param _pid PID of the pool\\n     */\\n    function emergencyWithdraw(uint256 _pid) public nonReentrant {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n\\n        uint256 wantLockedTotal =\\n            IStrategy(poolInfo[_pid].strat).wantLockedTotal();\\n        uint256 sharesTotal = IStrategy(poolInfo[_pid].strat).sharesTotal();\\n        uint256 amount = user.shares.mul(wantLockedTotal).div(sharesTotal);\\n\\n        IStrategy(poolInfo[_pid].strat).withdraw(amount);\\n\\n        uint256 thisBalance = pool.want.balanceOf(address(this));\\n        if (amount > thisBalance){\\n          amount = thisBalance;\\n        }\\n\\n        pool.want.safeTransfer(address(msg.sender), amount);\\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\\n        user.shares = 0;\\n        user.rewardDebt = 0;\\n    }\\n\\n    /**\\n     * @notice Safe reward tokens transfer function, just in case if rounding error causes pool to not have enough\\n     * @param _to  Address to send tokens to\\n     * @param _tokenAmount Amount of tokens to send\\n     */\\n    function safeTokensTransfer(address _to, uint256 _tokenAmount) internal {\\n        uint256 tokenBal = IERC20(rewardToken).balanceOf(address(this));\\n        bool transferSuccess = false;\\n        if (_tokenAmount > tokenBal) {\\n            transferSuccess = IERC20(rewardToken).transfer(_to, tokenBal);\\n        } else {\\n            transferSuccess = IERC20(rewardToken).transfer(_to, _tokenAmount);\\n        }\\n        require(transferSuccess, \\\"safeTokensTransfer: transfer failed\\\");\\n    }\\n\\n    /**\\n     * @notice Function to transfer token from this contract, in case they are accidentally sent here. Only callable by owner!\\n     * @param _token Address of the token to transfer\\n     * @param _amount Amount to transfer\\n     */\\n    function rescueTokens(address _token, uint256 _amount)\\n        public\\n        onlyOwner\\n    {\\n        require(_token != rewardToken, \\\"!safe\\\");\\n        IERC20(_token).safeTransfer(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @notice Change emission schedule by owner.\\n     * @param _startBlock Block number from where inflation schedule is counted, if 0, it's current block number\\n     * @param _emissionAmounts Array of emission amounts\\n     * @param _emissionDelays Array of delays for each amount\\n     */\\n    function updateEmissionRateSchedule(uint256 _startBlock, uint256[] calldata _emissionAmounts, uint256[] calldata _emissionDelays) public onlyOwner {\\n        if (_startBlock == 0) _startBlock = block.number;\\n\\n        //delete previous emission schedule array\\n        for (uint256 i = 0; i < emissionScheduleArray.length; i++){\\n            delete emissionScheduleArray[i];\\n        }\\n        emissionScheduleLatest = 0;\\n\\n        for (uint256 i = 0; i < _emissionAmounts.length; i++){\\n            emissionScheduleArray[i] = EmissionSchedule(_emissionAmounts[i], _startBlock + _emissionDelays[i], false);\\n        }\\n    }\\n\\n    /**\\n     * @notice Manually update emission rate\\n     * @notice It can't override `maxIssued`!\\n     * @param _tokensPerBlock Number of tokens per block.\\n     */\\n    function updateEmissionRate(uint256 _tokensPerBlock) public onlyOwner {\\n        massUpdatePools();\\n        tokensPerBlock = _tokensPerBlock;\\n\\n        emit UpdateEmissionRate(_tokensPerBlock);\\n    }\\n\\n    /**\\n     * @notice Manually update lockup period\\n     * @param _lockup Number of blocks.\\n     */\\n    function setLockupPeriod(uint256 _lockup) external onlyOwner {\\n      emit UpdateLockupPeriod(lockupPeriodBlocks, _lockup);\\n      lockupPeriodBlocks = _lockup;\\n    }\\n\\n    /**\\n     * @notice Manually update penalty address\\n     * @param _newPenaltyAddress new penalty address\\n     */\\n    function setPenaltyAddress(address _newPenaltyAddress) external onlyOwner {\\n      require(_newPenaltyAddress != address(0), '!address(0)');\\n      penaltyAddress = _newPenaltyAddress;\\n      emit updatePenaltyAddress(_newPenaltyAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract ERC20 is Context, IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\r\\n     * a default value of 18.\\r\\n     *\\r\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\r\\n     *\\r\\n     * All three of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) public {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _decimals = 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\r\\n     * called.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount)\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(\\r\\n            sender,\\r\\n            _msgSender(),\\r\\n            _allowances[sender][_msgSender()].sub(\\r\\n                amount,\\r\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\r\\n            )\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue)\\r\\n        public\\r\\n        virtual\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender].add(addedValue)\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n        public\\r\\n        virtual\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender].sub(\\r\\n                subtractedValue,\\r\\n                \\\"ERC20: decreased allowance below zero\\\"\\r\\n            )\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(\\r\\n            amount,\\r\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\r\\n        );\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(\\r\\n            amount,\\r\\n            \\\"ERC20: burn amount exceeds balance\\\"\\r\\n        );\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\r\\n     *\\r\\n     * WARNING: This function should only be called from the constructor. Most\\r\\n     * applications that interact with token contracts will not expect\\r\\n     * {decimals} to ever change, and may work incorrectly if it does.\\r\\n     */\\r\\n    function _setupDecimals(uint8 decimals_) internal {\\r\\n        _decimals = decimals_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n// import \\\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(\\r\\n            address(this).balance >= amount,\\r\\n            \\\"Address: insufficient balance\\\"\\r\\n        );\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(\\r\\n            success,\\r\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data)\\r\\n        internal\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                value,\\r\\n                \\\"Address: low-level call with value failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(\\r\\n            address(this).balance >= value,\\r\\n            \\\"Address: insufficient balance for call\\\"\\r\\n        );\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) =\\r\\n            target.call{value: value}(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data)\\r\\n        internal\\r\\n        view\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return\\r\\n            functionStaticCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level static call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data)\\r\\n        internal\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return\\r\\n            functionDelegateCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level delegate call failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) private pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length > 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance =\\r\\n            token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(\\r\\n                token.approve.selector,\\r\\n                spender,\\r\\n                newAllowance\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance =\\r\\n            token.allowance(address(this), spender).sub(\\r\\n                value,\\r\\n                \\\"SafeERC20: decreased allowance below zero\\\"\\r\\n            );\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(\\r\\n                token.approve.selector,\\r\\n                spender,\\r\\n                newAllowance\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata =\\r\\n            address(token).functionCall(\\r\\n                data,\\r\\n                \\\"SafeERC20: low-level call failed\\\"\\r\\n            );\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(\\r\\n                abi.decode(returndata, (bool)),\\r\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\n// import \\\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/EnumerableSet.sol\\\";\\r\\nlibrary EnumerableSet {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping(bytes32 => uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) {\\r\\n            // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\r\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\r\\n\\r\\n            bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n            // Move the last value to the index where the value to delete is\\r\\n            set._values[toDeleteIndex] = lastvalue;\\r\\n            // Update the index for the moved value\\r\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value)\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function _at(Set storage set, uint256 index)\\r\\n        private\\r\\n        view\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        require(\\r\\n            set._values.length > index,\\r\\n            \\\"EnumerableSet: index out of bounds\\\"\\r\\n        );\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    // Bytes32Set\\r\\n\\r\\n    struct Bytes32Set {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(Bytes32Set storage set, bytes32 value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _add(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(Bytes32Set storage set, bytes32 value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _remove(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(Bytes32Set storage set, bytes32 value)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _contains(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(Bytes32Set storage set, uint256 index)\\r\\n        internal\\r\\n        view\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return _at(set._inner, index);\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _add(set._inner, bytes32(uint256(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _remove(set._inner, bytes32(uint256(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _contains(set._inner, bytes32(uint256(value)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(AddressSet storage set, uint256 index)\\r\\n        internal\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return address(uint256(_at(set._inner, index)));\\r\\n    }\\r\\n\\r\\n    // UintSet\\r\\n\\r\\n    struct UintSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(UintSet storage set, uint256 value)\\r\\n        internal\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _remove(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(UintSet storage set, uint256 value)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _contains(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function length(UintSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n     *\\r\\n     * Note that there are no guarantees on the ordering of values inside the\\r\\n     * array, and it may change when more values are added or removed.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `index` must be strictly less than {length}.\\r\\n     */\\r\\n    function at(UintSet storage set, uint256 index)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return uint256(_at(set._inner, index));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n// import \\\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\\";\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() internal {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Ownable: new owner is the zero address\\\"\\r\\n        );\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\n// \\\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\\";\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler's defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() internal {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\n// For interacting with our own strategy\\r\\ninterface IStrategy {\\r\\n    // Total want tokens managed by strategy\\r\\n    function wantLockedTotal() external view returns (uint256);\\r\\n\\r\\n    // Sum of all shares of users to wantLockedTotal\\r\\n    function sharesTotal() external view returns (uint256);\\r\\n\\r\\n    // Main want token compounding function\\r\\n    function earn() external;\\r\\n\\r\\n    // Transfer want tokens kingdom -> strategy\\r\\n    function deposit(uint256 _wantAmt)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    // Transfer want tokens strategy -> kingdom\\r\\n    function withdraw(uint256 _wantAmt)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    function inCaseTokensGetStuck(\\r\\n        address _token,\\r\\n        uint256 _amount,\\r\\n        address _to\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\ninterface IToken {\\r\\n    function mint(address user, uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\n// import \\\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\\\";\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPenaltyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newRewardToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPerBlock\",\"type\":\"uint256\"}],\"name\":\"UpdateEmissionRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"UpdateLockupPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newPenaltyAddress\",\"type\":\"address\"}],\"name\":\"updatePenaltyAddress\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_want\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_strat\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_claimLocked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wantAmt\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"emissionScheduleArray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"alreadyUpdated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionScheduleLatest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestMonthlyInflationCut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"lockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupPeriodBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxIssued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alreadyClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"pendingLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolExistence\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"want\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTokensPerShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"strat\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockup\",\"type\":\"uint256\"}],\"name\":\"setLockupPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPenaltyAddress\",\"type\":\"address\"}],\"name\":\"setPenaltyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"stakedWantTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalIssuedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"unlockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensPerBlock\",\"type\":\"uint256\"}],\"name\":\"updateEmissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_emissionAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_emissionDelays\",\"type\":\"uint256[]\"}],\"name\":\"updateEmissionRateSchedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wantAmt\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MasterChef", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000dead000000000000000000000000000000000000000000000000000000000186de800000000000000000000000007cc15fef543f205bf21018f038f591c6bada941c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}