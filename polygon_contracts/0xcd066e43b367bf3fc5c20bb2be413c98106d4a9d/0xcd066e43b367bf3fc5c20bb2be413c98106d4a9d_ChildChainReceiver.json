{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ChildChainReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"IERC20.sol\\\";\\nimport {Client} from \\\"Client.sol\\\";\\nimport {CCIPReceiver} from \\\"CCIPReceiver.sol\\\";\\n\\nimport {IChildChainStreamer} from \\\"IChildChainStreamer.sol\\\";\\n\\ncontract ChildChainReceiver is CCIPReceiver {\\n    string private VERSION = \\\"1.2.3\\\";\\n\\n    // Custom errors to provide more descriptive revert messages.\\n    error SourceChainNotWhitelisted(uint64 sourceChainSelector); // Used when the source chain has not been whitelisted by the contract owner.\\n    error SenderNotWhitelisted(address sender); // Used when the sender has not been whitelisted by the contract owner.\\n\\n    // Event emitted when a message is received from another chain.\\n    // The unique ID of the CCIP message.\\n    // The chain selector of the source chain.\\n    // The address of the sender from the source chain.\\n    // The text that was received.\\n    // The token address that was transferred.\\n    // The token amount that was transferred.\\n    event GaugeRewardReceived(\\n        bytes32 indexed messageId,\\n        uint64 indexed sourceChainSelector,\\n        address sender,\\n        address token,\\n        uint256 tokenAmount\\n    );\\n\\n    address public streamer; // ChildChainStreamer address\\n\\n    bytes32 private lastReceivedMessageId; // Store the last received messageId.\\n    address private lastReceivedTokenAddress; // Store the last received token address.\\n    uint256 private lastReceivedTokenAmount; // Store the last received amount.\\n\\n    address public owner;\\n\\n    // Mapping to keep track of whitelisted source chains.\\n    mapping(uint64 => bool) public whitelistedSourceChains;\\n\\n    // Mapping to keep track of whitelisted senders.\\n    mapping(address => bool) public whitelistedSenders;\\n\\n    /// @dev Modifier that checks whether the msg.sender is owner\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Not owner\\\");\\n        _;\\n    }\\n\\n    /// @dev Modifier that checks if the chain with the given sourceChainSelector is whitelisted.\\n    /// @param _sourceChainSelector The selector of the destination chain.\\n    modifier onlyWhitelistedSourceChain(uint64 _sourceChainSelector) {\\n        if (!whitelistedSourceChains[_sourceChainSelector]) {\\n            revert SourceChainNotWhitelisted(_sourceChainSelector);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Modifier that checks if the chain with the given sourceChainSelector is whitelisted.\\n    /// @param _sender The address of the sender.\\n    modifier onlyWhitelistedSenders(address _sender) {\\n        if (!whitelistedSenders[_sender]) revert SenderNotWhitelisted(_sender);\\n        _;\\n    }\\n\\n    /// @notice Constructor initializes the contract with the router address.\\n    /// @param _router The address of the router contract.\\n    /// @param _streamer The address of associated ChildChainStreamer contract.\\n    /// @param _owner The address of the contract owner.\\n    constructor(address _router, address _streamer, address _owner) CCIPReceiver(_router) {\\n        streamer = _streamer;\\n        owner = _owner;\\n    }\\n\\n    /* Parameters */\\n    function updateOwner(address _newOwner) external onlyOwner {\\n        owner = _newOwner;\\n    }\\n\\n    /**\\n     * @notice Returns the details of the last CCIP received message.\\n     * @dev This function retrieves the ID, text, token address, and token amount of the last received CCIP message.\\n     * @return messageId The ID of the last received CCIP message.\\n     * @return tokenAddress The address of the token in the last CCIP received message.\\n     * @return tokenAmount The amount of the token in the last CCIP received message.\\n     */\\n    function getLastReceivedMessageDetails()\\n        public\\n        view\\n        returns (bytes32 messageId, address tokenAddress, uint256 tokenAmount)\\n    {\\n        return (lastReceivedMessageId, lastReceivedTokenAddress, lastReceivedTokenAmount);\\n    }\\n\\n    /// handle a received message\\n    function _ccipReceive(Client.Any2EVMMessage memory message)\\n        internal\\n        override\\n        onlyWhitelistedSourceChain(message.sourceChainSelector)\\n        onlyWhitelistedSenders(abi.decode(message.sender, (address)))\\n    {\\n        lastReceivedMessageId = message.messageId; // fetch the messageId\\n        // Expect one token to be transferred at once, but you can transfer several tokens.\\n        address rewardToken = message.destTokenAmounts[0].token;\\n        uint256 rewardAmount = message.destTokenAmounts[0].amount;\\n        lastReceivedTokenAddress = rewardToken;\\n        lastReceivedTokenAmount = rewardAmount;\\n\\n        IERC20(rewardToken).transfer(streamer, rewardAmount);\\n        IChildChainStreamer(streamer).notify_reward_amount(rewardToken);\\n\\n        emit GaugeRewardReceived(\\n            message.messageId,\\n            message.sourceChainSelector, // fetch the source chain identifier (aka selector)\\n            abi.decode(message.sender, (address)), // abi-decoding of the sender address,\\n            rewardToken,\\n            rewardAmount\\n        );\\n    }\\n\\n    /* Admin */\\n    /// @notice Fallback function to allow the contract to receive Ether.\\n    /// @dev This function has no function body, making it a default function for receiving Ether.\\n    /// It is automatically called when Ether is transferred to the contract without any data.\\n    receive() external payable {}\\n\\n    /// @dev Whitelists a chain for transactions.\\n    /// @notice This function can only be called by the owner.\\n    /// @param _sourceChainSelector The selector of the source chain to be whitelisted.\\n    function whitelistSourceChain(uint64 _sourceChainSelector) external onlyOwner {\\n        whitelistedSourceChains[_sourceChainSelector] = true;\\n    }\\n\\n    /// @dev Denylists a chain for transactions.\\n    /// @notice This function can only be called by the owner.\\n    /// @param _sourceChainSelector The selector of the source chain to be denylisted.\\n    function denylistSourceChain(uint64 _sourceChainSelector) external onlyOwner {\\n        whitelistedSourceChains[_sourceChainSelector] = false;\\n    }\\n\\n    /// @dev Whitelists a sender.\\n    /// @notice This function can only be called by the owner.\\n    /// @param _sender The address of the sender.\\n    function whitelistSender(address _sender) external onlyOwner {\\n        whitelistedSenders[_sender] = true;\\n    }\\n\\n    /// @dev Denylists a sender.\\n    /// @notice This function can only be called by the owner.\\n    /// @param _sender The address of the sender.\\n    function denySender(address _sender) external onlyOwner {\\n        whitelistedSenders[_sender] = false;\\n    }\\n\\n    /// @notice Emergency withdraw\\n    /// @param _token Address of token to withdraw\\n    function emergencyWithdraw(address _beneficiary, address _token, uint256 _amount) external onlyOwner {\\n        IERC20(_token).transfer(_beneficiary, _amount);\\n    }\\n\\n    /// @notice Emergency withdraw native token\\n    /// @param _beneficiary Receiver of emergeny withdraw\\n    /// @param _amount Amount to withdraw\\n    function emergencyWithdrawNative(address _beneficiary, uint256 _amount) external onlyOwner {\\n        (bool sent,) = _beneficiary.call{value: _amount}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"Client.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\\n    bytes data; // Data payload\\n    EVMTokenAmount[] tokenAmounts; // Token transfers\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\\n  }\\n\\n  // extraArgs will evolve to support new features\\n  // bytes4(keccak256(\\\"CCIP EVMExtraArgsV1\\\"));\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\\n    bool strict; // See strict sequencing details below.\\n  }\\n\\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"\r\n    },\r\n    \"CCIPReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IAny2EVMMessageReceiver} from \\\"IAny2EVMMessageReceiver.sol\\\";\\n\\nimport {Client} from \\\"Client.sol\\\";\\n\\nimport {IERC165} from \\\"IERC165.sol\\\";\\n\\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\\n    address internal immutable i_router;\\n\\n    constructor(address router) {\\n        if (router == address(0)) revert InvalidRouter(address(0));\\n        i_router = router;\\n    }\\n\\n    /// @notice IERC165 supports an interfaceId\\n    /// @param interfaceId The interfaceId to check\\n    /// @return true if the interfaceId is supported\\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\\n        return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    /// @inheritdoc IAny2EVMMessageReceiver\\n    function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\\n        _ccipReceive(message);\\n    }\\n\\n    /// @notice Override this function in your implementation.\\n    /// @param message Any2EVMMessage\\n    function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\\n\\n    /////////////////////////////////////////////////////////////////////\\n    // Plumbing\\n    /////////////////////////////////////////////////////////////////////\\n\\n    /// @notice Return the current router\\n    /// @return i_router address\\n    function getRouter() public view returns (address) {\\n        return address(i_router);\\n    }\\n\\n    error InvalidRouter(address router);\\n\\n    /// @dev only calls from the set router are accepted.\\n    modifier onlyRouter() {\\n        if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"IAny2EVMMessageReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"Client.sol\\\";\\n\\n/// @notice Application contracts that intend to receive messages from\\n/// the router should implement this interface.\\ninterface IAny2EVMMessageReceiver {\\n  /// @notice Called by the Router to deliver a message.\\n  /// If this reverts, any token transfers also revert. The message\\n  /// will move to a FAILED state and become available for manual execution.\\n  /// @param message CCIP Message\\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IChildChainStreamer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IChildChainStreamer {\\n    struct RewardToken {\\n        address distributor;\\n        uint256 period_finish;\\n        uint256 rate;\\n        uint256 duration;\\n        uint256 received;\\n        uint256 paid;\\n    }\\n\\n    function get_reward() external;\\n    function notify_reward_amount(address _token) external;\\n    function reward_data(address _token) external returns (RewardToken memory);\\n    function set_reward_distributor(address _token, address _distributor) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"ChildChainReceiver.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_streamer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SenderNotWhitelisted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"}],\"name\":\"SourceChainNotWhitelisted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"GaugeRewardReceived\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"sender\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"destTokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Client.Any2EVMMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"ccipReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"denySender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_sourceChainSelector\",\"type\":\"uint64\"}],\"name\":\"denylistSourceChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastReceivedMessageDetails\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"streamer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"whitelistSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_sourceChainSelector\",\"type\":\"uint64\"}],\"name\":\"whitelistSourceChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedSenders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"whitelistedSourceChains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ChildChainReceiver", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003c3d92629a02a8d95d5cb9650fe49c3544f69b4300000000000000000000000066028bbbf2b92495fccda5f36113644b5fb1dd1d0000000000000000000000009715c357cc02a60906e137608f95ca0148f438e7", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}