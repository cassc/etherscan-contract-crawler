{"SourceCode": "{\"EIP712Base.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83c\udfb2 --\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ncontract EIP712Base {\\r\\n\\r\\n    struct EIP712Domain {\\r\\n        string name;\\r\\n        string version;\\r\\n        uint256 chainId;\\r\\n        address verifyingContract;\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"));\\r\\n    bytes32 internal domainSeperator;\\r\\n\\r\\n    constructor(string memory name, string memory version) {\\r\\n        domainSeperator = keccak256(abi.encode(\\r\\n\\t\\t\\tEIP712_DOMAIN_TYPEHASH,\\r\\n\\t\\t\\tkeccak256(bytes(name)),\\r\\n\\t\\t\\tkeccak256(bytes(version)),\\r\\n\\t\\t\\tgetChainID(),\\r\\n\\t\\t\\taddress(this)\\r\\n\\t\\t));\\r\\n    }\\r\\n\\r\\n    function getChainID() internal pure returns (uint256 id) {\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tid := 1 // set to Goerli for now, Mainnet later\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n    function getDomainSeperator() private view returns(bytes32) {\\r\\n\\t\\treturn domainSeperator;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n    * Accept message hash and returns hash message in EIP712 compatible form\\r\\n    * So that it can be used to recover signer from signature signed using EIP712 formatted data\\r\\n    * https://eips.ethereum.org/EIPS/eip-712\\r\\n    * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\r\\n    * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\r\\n    */\\r\\n    function toTypedMessageHash(bytes32 messageHash) internal view returns(bytes32) {\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", getDomainSeperator(), messageHash));\\r\\n    }\\r\\n}\\r\\n\"},\"EIP712MetaTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83d\udc8e --\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./EIP712Base.sol\\\";\\r\\n\\r\\nabstract contract EIP712MetaTransaction is EIP712Base {\\r\\n\\r\\n    bytes32 private constant META_TRANSACTION_TYPEHASH =\\r\\n        keccak256(\\r\\n            bytes(\\r\\n                \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\r\\n            )\\r\\n        );\\r\\n\\r\\n    event MetaTransactionExecuted(\\r\\n        address userAddress,\\r\\n        address payable relayerAddress,\\r\\n        bytes functionSignature\\r\\n    );\\r\\n\\r\\n    mapping(address =\\u003e uint256) internal nonces;\\r\\n\\r\\n    /*\\r\\n     * Meta transaction structure.\\r\\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\\r\\n     * He should call the desired function directly in that case.\\r\\n     */\\r\\n    struct MetaTransaction {\\r\\n\\t\\tuint256 nonce;\\r\\n\\t\\taddress from;\\r\\n        bytes functionSignature;\\r\\n\\t}\\r\\n\\r\\n    function executeMetaTransaction(\\r\\n        address userAddress,\\r\\n        bytes memory functionSignature,\\r\\n        bytes32 sigR,\\r\\n        bytes32 sigS,\\r\\n        uint8 sigV\\r\\n    )\\r\\n        public\\r\\n        payable\\r\\n        returns(bytes memory)\\r\\n    {\\r\\n        MetaTransaction memory metaTx = MetaTransaction(\\r\\n            {\\r\\n                nonce: nonces[userAddress],\\r\\n                from: userAddress,\\r\\n                functionSignature: functionSignature\\r\\n            }\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            verify(\\r\\n                userAddress,\\r\\n                metaTx,\\r\\n                sigR,\\r\\n                sigS,\\r\\n                sigV\\r\\n            ), \\\"Signer and signature do not match\\\"\\r\\n        );\\r\\n\\r\\n\\t    nonces[userAddress] =\\r\\n\\t    nonces[userAddress] + 1;\\r\\n\\r\\n        // Append userAddress at the end to extract it from calling context\\r\\n        (bool success, bytes memory returnData) = address(this).call(\\r\\n            abi.encodePacked(\\r\\n                functionSignature,\\r\\n                userAddress\\r\\n            )\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            success,\\r\\n            \\u0027Function call not successful\\u0027\\r\\n        );\\r\\n\\r\\n        emit MetaTransactionExecuted(\\r\\n            userAddress,\\r\\n            payable(msg.sender),\\r\\n            functionSignature\\r\\n        );\\r\\n\\r\\n        return returnData;\\r\\n    }\\r\\n\\r\\n    function hashMetaTransaction(\\r\\n        MetaTransaction memory metaTx\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n\\t\\treturn keccak256(\\r\\n\\t\\t    abi.encode(\\r\\n                META_TRANSACTION_TYPEHASH,\\r\\n                metaTx.nonce,\\r\\n                metaTx.from,\\r\\n                keccak256(metaTx.functionSignature)\\r\\n            )\\r\\n        );\\r\\n\\t}\\r\\n\\r\\n    function verify(\\r\\n        address user,\\r\\n        MetaTransaction memory metaTx,\\r\\n        bytes32 sigR,\\r\\n        bytes32 sigS,\\r\\n        uint8 sigV\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        address signer = ecrecover(\\r\\n            toTypedMessageHash(\\r\\n                hashMetaTransaction(metaTx)\\r\\n            ),\\r\\n            sigV,\\r\\n            sigR,\\r\\n            sigS\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            signer != address(0x0),\\r\\n            \\u0027Invalid signature\\u0027\\r\\n        );\\r\\n\\t\\treturn signer == user;\\r\\n\\t}\\r\\n\\r\\n    function msgSender() internal view returns(address sender) {\\r\\n        if(msg.sender == address(this)) {\\r\\n            bytes memory array = msg.data;\\r\\n            uint256 index = msg.data.length;\\r\\n            assembly {\\r\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\r\\n                sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\r\\n            }\\r\\n        } else {\\r\\n            sender = msg.sender;\\r\\n        }\\r\\n        return sender;\\r\\n    }\\r\\n\\r\\n    function getNonce(\\r\\n        address _user\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns(uint256 nonce)\\r\\n    {\\r\\n        nonce = nonces[_user];\\r\\n    }\\r\\n}\\r\\n\"},\"iceToken.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\uddca --\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport \\\"./EIP712MetaTransaction.sol\\\";\\r\\n\\r\\ncontract IceToken is EIP712MetaTransaction {\\r\\n\\r\\n    string private _name = \\\"Decentral Games ICE\\\";\\r\\n    string private _symbol = \\\"ICE\\\";\\r\\n    uint8 private _decimals = 18;\\r\\n\\r\\n    address public IceMaster;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    modifier onlyIceMaster {\\r\\n        require(\\r\\n            _msgSender() == IceMaster,\\r\\n            \\u0027IceToken: access denied\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _IceMaster\\r\\n    )\\r\\n        EIP712Base(\\u0027IceToken\\u0027, \\u0027v1.2\\u0027)\\r\\n    {\\r\\n        IceMaster = _IceMaster;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(\\r\\n        address _contractDAO\\r\\n    )\\r\\n        external\\r\\n        onlyIceMaster\\r\\n    {\\r\\n        IceMaster = _contractDAO;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership()\\r\\n        external\\r\\n        onlyIceMaster\\r\\n    {\\r\\n        IceMaster = address(0x0);\\r\\n    }\\r\\n\\r\\n    function name()\\r\\n        external\\r\\n        view\\r\\n        returns (string memory)\\r\\n    {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol()\\r\\n        external\\r\\n        view\\r\\n        returns (string memory)\\r\\n    {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals()\\r\\n        external\\r\\n        view\\r\\n        returns (uint8)\\r\\n    {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(\\r\\n        address _account\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _balances[_account];\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address _recipient,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transfer(\\r\\n            _msgSender(),\\r\\n            _recipient,\\r\\n            _amount\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address _sender,\\r\\n        address _recipient,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        _balances[_sender] =\\r\\n        _balances[_sender] - _amount;\\r\\n\\r\\n        _balances[_recipient] =\\r\\n        _balances[_recipient] + _amount;\\r\\n\\r\\n        emit Transfer(\\r\\n            _sender,\\r\\n            _recipient,\\r\\n            _amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address _sender,\\r\\n        address _recipient,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _sender,\\r\\n            _msgSender(),\\r\\n            _allowances[_sender][_msgSender()] - _amount\\r\\n        );\\r\\n\\r\\n        _transfer(\\r\\n            _sender,\\r\\n            _recipient,\\r\\n            _amount\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(\\r\\n        address _owner,\\r\\n        address _spender\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            _spender,\\r\\n            _amount\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address _owner,\\r\\n        address _spender,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        _allowances[_owner][_spender] = _amount;\\r\\n\\r\\n        emit Approval(\\r\\n            _owner,\\r\\n            _spender,\\r\\n            _amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function mint(\\r\\n        address _account,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external\\r\\n        onlyIceMaster\\r\\n    {\\r\\n        _totalSupply =\\r\\n        _totalSupply + _amount;\\r\\n\\r\\n        _balances[_account] =\\r\\n        _balances[_account] + _amount;\\r\\n\\r\\n        emit Transfer(\\r\\n            address(0x0),\\r\\n            _account,\\r\\n            _amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function burn(\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        _balances[_msgSender()] =\\r\\n        _balances[_msgSender()] - _amount;\\r\\n\\r\\n        _totalSupply =\\r\\n        _totalSupply - _amount;\\r\\n\\r\\n        emit Transfer(\\r\\n            _msgSender(),\\r\\n            address(0x0),\\r\\n            _amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _msgSender()\\r\\n        internal\\r\\n        view\\r\\n        returns (address sender)\\r\\n    {\\r\\n        if (msg.sender == address(this)) {\\r\\n            bytes memory array = msg.data;\\r\\n            uint256 index = msg.data.length;\\r\\n            assembly {\\r\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\r\\n                sender := and(\\r\\n                    mload(add(array, index)),\\r\\n                    0xffffffffffffffffffffffffffffffffffffffff\\r\\n                )\\r\\n            }\\r\\n        } else {\\r\\n            sender = msg.sender;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_IceMaster\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IceMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractDAO\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IceToken", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000008aef51b9eecaca6b4a9c73d5b0fe1937a072af04", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://04ea0b153cd30abf469addfbcdeb9e29cde5c3a3674e5ccd65a0943ebcf7bc24"}