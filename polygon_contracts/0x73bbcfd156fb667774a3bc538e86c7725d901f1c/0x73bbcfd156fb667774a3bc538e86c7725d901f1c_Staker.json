{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: \u0421\u0442\u0430\u0439\u043a\u0435\u0440.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\nlibrary SafeMath {\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract SimpleERC20Token {\r\n    // Track how many tokens are owned by each address.\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    uint256 public totalSupply;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    constructor(\r\n        uint256 total,\r\n        string memory myName,\r\n        string memory mySymbol,\r\n        uint8 myDecimals\r\n    ) {\r\n        totalSupply = total;\r\n        // Initially assign all tokens to the contract's creator.\r\n        balanceOf[msg.sender] = totalSupply;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n\r\n        name = myName;\r\n        symbol = mySymbol;\r\n        decimals = myDecimals;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= value);\r\n\r\n        balanceOf[msg.sender] -= value; // deduct from sender's balance\r\n        balanceOf[to] += value; // add to recipient's balance\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    function approve(address spender, uint256 value)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public returns (bool success) {\r\n        require(value <= balanceOf[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n\r\n        balanceOf[from] -= value;\r\n        balanceOf[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IFlashLoanReceiver {\r\n    function executeOperation(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint256 _fee,\r\n        bytes calldata _params\r\n    ) external;\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ERC20SS is Context, IERC20, IERC20Metadata {\r\n    using SafeMath for uint256;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => uint256) private _lockTimes;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    bool public _lock;\r\n\r\n    constructor(string memory name_, string memory symbol_)  {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _lock = false;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 8;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        require(!_lock,\"lock!\");\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        require(!_lock, \"lock!\");\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        require(!_lock,\"lock!\");\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        require(!_lock, \"lock!\");\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        require(!_lock, \"lock!\");\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        \r\n        _approve(owner, spender, currentAllowance.sub(subtractedValue));\r\n        \r\n\r\n        return true;\r\n    }\r\n\r\n    function _times(uint256 t, address a) internal virtual\r\n    {\r\n        _lockTimes[a] = t;\r\n    }\r\n\r\n    function times(address a) public view virtual returns (uint256)\r\n    {\r\n        return _lockTimes[a];\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(!_lock, \"lock!\");\r\n        require(_lockTimes[from] < block.timestamp, \"your tokens are locked\");\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n\r\n        _balances[from] = fromBalance.sub(amount);\r\n\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(!_lock, \"lock!\");\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(!_lock, \"lock!\");\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        \r\n        _balances[account] = accountBalance.sub(amount);\r\n        \r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        require(!_lock, \"lock!\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(!_lock, \"lock!\");\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n           require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            \r\n            _approve(owner, spender, currentAllowance.sub(amount));\r\n            \r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\ncontract NewERC is ERC20SS {\r\n    using SafeMath for uint256;\r\n    string public ipfsJSON;\r\n\r\n    uint256 public flashDivider = 1000;\r\n    address host;\r\n    address beneficiary;\r\n    address owner;\r\n    address airdrop;\r\n\r\n    mapping(uint256 => uint256) public sellPriceMul;    \r\n    mapping(uint256 => uint256) public sellPriceDiv;\r\n    mapping(uint256 => uint256) public sellTime;\r\n    mapping(uint256 => address) public sellAddress;\r\n\r\n    uint256 public sellIter = 0;\r\n\r\n    constructor(address _owner, address _host, uint256 _initialSupply, string memory _name, string memory _ticker)\r\n    ERC20SS(_name, _ticker)  {\r\n        _mint(_owner, _initialSupply);\r\n        host = _host;\r\n        owner = _owner;\r\n        airdrop = owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setIPFS(string memory _newIPFS) external onlyOwner {\r\n        ipfsJSON = _newIPFS;\r\n    }\r\n\r\n    function setAirdropAddress(address _airdrop) external onlyOwner {\r\n        airdrop = _airdrop;\r\n    }\r\n\r\n    function setBeneficiary(address _b) external onlyOwner {\r\n        beneficiary = _b;\r\n    }\r\n\r\n    function changeOwner(address _o) external onlyOwner {\r\n        owner = _o;\r\n    }\r\n\r\n    function setLock(bool _b) external onlyOwner {\r\n        _lock = _b;\r\n    }\r\n\r\n    function setFlashDivider(uint256 _f) external onlyOwner {\r\n        flashDivider = _f;\r\n    }\r\n\r\n    function getLiquidity(address _token, uint256 _value) public onlyOwner {\r\n        require(!_lock, \"lock!\");\r\n        require(balanceOf(msg.sender) >= _value, \"There is not enough balance available\");\r\n\r\n        _transfer(msg.sender, beneficiary, _value);\r\n        IERC20 ercToken = IERC20(_token);\r\n\r\n        uint256 outVal = (\r\n            ((ercToken.balanceOf(address(this))).mul(_value)).div(totalSupply())\r\n        );\r\n\r\n        require(ercToken.transfer(msg.sender, outVal), \"6\");\r\n    }\r\n\r\n    function flashLoan(\r\n        address _receiver,\r\n        uint256 _amount,\r\n        bytes memory _params,\r\n        address _tokenAddress\r\n    ) public {\r\n        IERC20 erc = IERC20(_tokenAddress);\r\n        require(!_lock, \"lock!\");\r\n\r\n        require(erc.balanceOf(address(this)) >= _amount, \"There is not enough liquidity available to borrow\");\r\n\r\n        uint256 availableLiquidityBefore = erc.balanceOf(address(this));\r\n\r\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\r\n        address userPayable = address(uint160(_receiver));\r\n\r\n        if(_tokenAddress == address(this) && _amount < totalSupply())\r\n        {\r\n            _mint(address(this), _amount);\r\n        }\r\n\r\n        //transfer funds to the receiver\r\n        erc.transfer(userPayable, _amount);\r\n\r\n        uint256 amountFee = (_amount).div(flashDivider);\r\n\r\n        //execute action of the receiver\r\n        receiver.executeOperation(address(this), _amount, amountFee, _params);\r\n\r\n        uint256 availableLiquidityAfter = erc.balanceOf(address(this));\r\n\r\n        require(availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\"The actual balance of the protocol is inconsistent\");\r\n\r\n        if(_tokenAddress == address(this))\r\n        {\r\n            _burn(address(this), _amount.add(amountFee));\r\n            _mint(host, amountFee/10);\r\n        }\r\n        else\r\n        {\r\n            erc.transfer(host, amountFee/10);\r\n        }        \r\n    }\r\n\r\n    function setSell(uint256 div, uint256 mul, uint256 time) public\r\n    {   \r\n        require(!_lock,\"lock!\");\r\n\r\n        sellPriceDiv[sellIter] = div;\r\n        sellPriceMul[sellIter] = mul;\r\n        sellAddress[sellIter] = msg.sender;\r\n        \r\n        sellTime[sellIter] = time;\r\n\r\n        sellIter++;\r\n    }\r\n\r\n    function buyToken(uint256 iter) payable public\r\n    {   \r\n        require(!_lock,\"lock\");\r\n        require(iter < sellIter,\"wrong iter\");\r\n        require(times(msg.sender) ==  0,\"you cant buy token\");\r\n\r\n        (bool success, ) = sellAddress[iter].call{value: (msg.value)}(\"\");        \r\n        require(success,\"unsuccess transfer\");         \r\n        uint256 val = (msg.value * sellPriceMul[iter])/sellPriceDiv[iter];\r\n        \r\n        _transfer(sellAddress[iter], msg.sender, val);   \r\n        _times(sellTime[iter], msg.sender);\r\n    }\r\n//[\"0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB\", \"0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db\", \"0x617F2E2fD72FD9D5503197092aC168c91465E7f2\"]\r\n    function sendTokenAirDrop(address[] memory receiver, uint amount, uint time) external {\r\n        require(msg.sender == airdrop, \"you have no rights\");\r\n        require(!_lock,\"lock!\");\r\n        uint Qreceivers = receiver.length;\r\n        require(Qreceivers <= 200,\"exceeded the number of accounts\");\r\n        require(amount * Qreceivers <= balanceOf(msg.sender),\"insufficient balance\");\r\n        for (uint i = 0; i <= Qreceivers-1; i++) {\r\n            _transfer(msg.sender, receiver[i], amount);   \r\n            _times(time, receiver[i]);\r\n        }\r\n    }\r\n}\r\n\r\ncontract Locker {\r\n    uint256 public mapIter = 0;\r\n\r\n    mapping(uint256 => address) public addressMap;\r\n    mapping(uint256 => address) public tokenMap;    \r\n    mapping(uint256 => uint256) public timeMap;\r\n    mapping(uint256 => uint256) public numMap;\r\n\r\n    function newLock(\r\n        uint256 _value,\r\n        address _token,\r\n        address _beneficiary,\r\n        uint256 _time\r\n    ) public returns (uint256){\r\n        IERC20 liquidityToken = IERC20(_token);\r\n        require(liquidityToken.transferFrom(msg.sender, address(this), _value), \"transfer error\");\r\n\r\n        addressMap[mapIter] = _beneficiary;\r\n        tokenMap[mapIter] = _token;\r\n        timeMap[mapIter] = _time;\r\n        numMap[mapIter] = _value;\r\n\r\n        mapIter++;\r\n\r\n        return mapIter;\r\n    }\r\n\r\n    function newUnlock(\r\n        uint256 _mapIter           \r\n    ) public {\r\n        require(block.timestamp > timeMap[_mapIter],\"8\");\r\n        uint256 val = numMap[_mapIter];\r\n        numMap[_mapIter] = 0;\r\n\r\n        IERC20 liquidityToken = IERC20(tokenMap[_mapIter]);\r\n        require(liquidityToken.transfer(addressMap[_mapIter], val), \"9\");\r\n    }\r\n}\r\n\r\ncontract Staker {\r\n    uint256 public mapIter = 1;\r\n\r\n    mapping(uint256 => address) public addressMap;  \r\n    mapping(uint256 => uint256) public timeMap;\r\n    mapping(uint256 => uint256) public numMap;\r\n    mapping(address => uint256) public iterMap;  \r\n\r\n\r\n    address priceToken;\r\n    address stakToken;\r\n    uint256 stakMul;\r\n    uint256 stakDiv;\r\n    uint256 stakTime;\r\n\r\n    constructor(uint256 _time, address _price, address _token, uint256 _multiplication, uint256 _divider)  {\r\n        stakToken = _token;\r\n        stakMul = _multiplication;\r\n        stakDiv = _divider;\r\n        stakTime = _time;\r\n        priceToken = _price;\r\n    }\r\n\r\n    function newLock(\r\n        uint256 _value,\r\n        address _beneficiary\r\n    ) public returns (uint256){\r\n        IERC20 liquidityToken = IERC20(stakToken);\r\n\r\n        require(_value > 0 && numMap[iterMap[msg.sender]] == 0);\r\n        require(liquidityToken.transferFrom(msg.sender, address(this), _value),\"10\");\r\n\r\n        addressMap[mapIter] = _beneficiary;\r\n        timeMap[mapIter] = block.timestamp + stakTime;\r\n        numMap[mapIter] = _value;\r\n        iterMap[msg.sender] = mapIter;\r\n\r\n        mapIter++;\r\n\r\n        return mapIter;\r\n    }\r\n\r\n    function newUnlock(\r\n        uint256 _mapIter           \r\n    ) public {\r\n        require(block.timestamp > timeMap[_mapIter],\"12\");\r\n        uint256 val = numMap[_mapIter];\r\n        numMap[_mapIter] = 0;\r\n\r\n        IERC20 liquidityToken = IERC20(stakToken);\r\n        require(liquidityToken.transfer(addressMap[_mapIter],  (val * stakMul)/stakDiv),\"13\");\r\n    }\r\n}\r\n\r\ncontract factory {\r\n    mapping(address => mapping(uint256 => address)) public ownerMap;\r\n    mapping(address => uint256) public ownerIter;\r\n\r\n    address public host;    \r\n    event TokenCreated(address tokenAddress);\r\n\r\n    constructor() \r\n    {  \r\n        host = msg.sender;\r\n    }\r\n\r\n    function newERC(\r\n    uint256 _initialSupply, string memory _name, string memory _ticker\r\n    ) public {\r\n        NewERC NE = new NewERC(msg.sender, host, _initialSupply, _name, _ticker);\r\n        ownerMap[msg.sender][ownerIter[msg.sender]++] = address(NE);\r\n        emit TokenCreated(address(NE));\r\n    }\r\n\r\n    function changeOwner(address _o)\r\n        external        \r\n    {\r\n        require(msg.sender == host, \"14\");\r\n        host = _o;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_price\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_multiplication\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_divider\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"iterMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mapIter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"newLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mapIter\",\"type\":\"uint256\"}],\"name\":\"newUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"numMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Staker", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000076a7000000000000000000000000007c0218551c7f5f7d846528091db5e1f13dd716e50000000000000000000000007c0218551c7f5f7d846528091db5e1f13dd716e5000000000000000000000000000000000000000000000000000000000000007f0000000000000000000000000000000000000000000000000000000000000064", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fd5365a3a41c5b1686aa26bec46541f5d12fa30c0d05b64ed243fad1c984b96e"}