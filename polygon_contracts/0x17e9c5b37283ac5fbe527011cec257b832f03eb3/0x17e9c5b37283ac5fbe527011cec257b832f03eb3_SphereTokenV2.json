{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SphereToken_flat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\nabstract contract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    constructor(\\n        string memory _tokenName,\\n        string memory _tokenSymbol,\\n        uint8 _tokenDecimals\\n    ) {\\n        _name = _tokenName;\\n        _symbol = _tokenSymbol;\\n        _decimals = _tokenDecimals;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\\ninterface IDEXRouter {\\n    function factory() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n    external\\n    returns (\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 liquidity\\n    );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n    external\\n    payable\\n    returns (\\n        uint256 amountToken,\\n        uint256 amountETH,\\n        uint256 liquidity\\n    );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut,\\n        uint256 fee\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut,\\n        uint256 fee\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n    external\\n    view\\n    returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n    external\\n    view\\n    returns (uint256[] memory amounts);\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface IDEXFactory {\\n    function getPair(address tokenA, address tokenB)\\n    external\\n    view\\n    returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB)\\n    external\\n    returns (address pair);\\n\\n    function validPairs(address _pair) external view returns (bool);\\n}\\n\\ninterface IBalanceOfSphere {\\n    function balanceOfSphere(address _address) external view returns (uint256);\\n}\\n\\ninterface IDEXPair {\\n    function sync() external;\\n}\\n\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipRenounced(address indexed previousOwner);\\n    event TransferOwnerShip(address indexed previousOwner);\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        _owner = msg.sender;\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == _owner, 'Not owner');\\n        _;\\n    }\\n\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipRenounced(_owner);\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        emit TransferOwnerShip(newOwner);\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), 'Owner can not be 0');\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\ncontract SphereTokenV2 is ERC20Detailed, Ownable, ReentrancyGuard {\\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\\n    address constant ZERO = 0x0000000000000000000000000000000000000000;\\n\\n    address[] public _makerPairs;\\n    address[] public partyArray;\\n    address[] public sphereGamesContracts;\\n    address[] public subContracts;\\n\\n    bool private feesOnNormalTransfers = true;\\n    bool private manualSyncRefresh = true;\\n    bool private doneInit = false;\\n    bool public autoRebase = true;\\n    bool public initialDistributionFinished = false;\\n    bool public isBurnEnabled = false;\\n    bool public isLiquidityEnabled = true;\\n    bool public isMoveBalance = false;\\n    bool public isSellHourlyLimit = true;\\n    bool public isTaxBracket = false;\\n    bool public isTaxBracketEnabledInMoveFee = false;\\n    bool public isWall = false;\\n    bool public partyTime = true;\\n    bool public swapEnabled = true;\\n\\n    mapping(address => InvestorInfo) public investorInfoMap;\\n    mapping(address => bool) _isBuyFeeExempt;\\n    mapping(address => bool) _isSellFeeExempt;\\n    mapping(address => bool) _isTotalFeeExempt;\\n    mapping(address => bool) canRebase;\\n    mapping(address => bool) canSetRewardYield;\\n    mapping(address => bool) public _disallowedToMove;\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n    mapping(address => bool) public partyArrayCheck;\\n    mapping(address => bool) public sphereGamesCheck;\\n    mapping(address => bool) public subContractCheck;\\n    mapping(address => uint256) public partyArrayFee;\\n    mapping(address => mapping(address => uint256)) private _allowedFragments;\\n    mapping(address => uint256) private _gonBalances;\\n\\n    uint256 private REWARD_YIELD_DENOMINATOR = 10000000000000000;\\n    uint256 private _gonsPerFragment;\\n    uint256 private _totalSupply;\\n\\n    uint256 private constant DECIMALS = 18;\\n    uint256 private constant FEE_DENOMINATOR = 1000;\\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY =\\n    5 * 10 ** 9 * 10 ** DECIMALS;\\n    uint256 private constant MAX_INVEST_REMOVABLE_DELAY = 7200;\\n    uint256 private constant MAX_PARTY_ARRAY = 491;\\n    uint256 private constant MAX_PARTY_LIST_DIVISOR_RATE = 75;\\n    uint256 private constant MAX_REBASE_FREQUENCY = 1800;\\n    uint256 private constant MAX_SUPPLY = ~uint128(0);\\n    uint256 private constant MAX_TAX_BRACKET_FEE_RATE = 50;\\n    uint256 private constant MAX_TOTAL_BUY_FEE_RATE = 250;\\n    uint256 private constant MAX_TOTAL_SELL_FEE_RATE = 250;\\n    uint256 private constant MAX_UINT256 = ~uint256(0);\\n    uint256 private constant MIN_BUY_AMOUNT_RATE = 500000 * 10 ** 18;\\n    uint256 private constant MIN_INVEST_REMOVABLE_PER_PERIOD = 1500000 * 10 ** 18;\\n    uint256 private constant MIN_SELL_AMOUNT_RATE = 500000 * 10 ** 18;\\n    uint256 private constant TOTAL_GONS =\\n    MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\n    uint256 private constant maxBracketTax = 10; // max bracket is holding 10%\\n\\n    uint256 private burnFee = 0;\\n    uint256 private buyGalaxyBondFee = 0;\\n    uint256 private gonSwapThreshold = TOTAL_GONS / 1000;\\n    uint256 private investRemovalDelay = 3600;\\n    uint256 private liquidityFee = 50;\\n    uint256 private partyListDivisor = 50;\\n    uint256 private realFeePartyArray = 490;\\n    uint256 private rebaseFrequency = 1800;\\n    uint256 private REWARD_YIELD = 3943560072416;\\n    uint256 private riskFreeValueFee = 50;\\n    uint256 private sellBurnFee = 0;\\n    uint256 private sellFeeRFVAdded = 50;\\n    uint256 private sellFeeTreasuryAdded = 20;\\n    uint256 private sellGalaxyBond = 0;\\n    uint256 private swapThreshold = 400000 * 10 ** 18;\\n    uint256 private treasuryFee = 30;\\n\\n    uint256 public _markerPairCount;\\n    uint256 public epochBuyPressure = 0;\\n    uint256 public epochCollectedBuyTax = 0;\\n    uint256 public epochCollectedSellTax = 0;\\n    uint256 public epochSellPressure = 0;\\n    uint256 public INDEX;\\n    uint256 public maxBuyTransactionAmount = 500000 * 10 ** 18;\\n    uint256 public maxSellTransactionAmount = 500000 * 10 ** 18;\\n    uint256 public nextRebase = 1647385255;\\n    uint256 public oldEpochBuyPressure = 0;\\n    uint256 public oldEpochCollectedBuyTax = 0;\\n    uint256 public oldEpochCollectedSellTax = 0;\\n    uint256 public oldEpochSellPressure = 0;\\n    uint256 public rebaseEpoch = 0;\\n    uint256 public taxBracketMultiplier = 50;\\n    uint256 public totalBuyFee =\\n    liquidityFee + (treasuryFee) + (riskFreeValueFee);\\n    uint256 public totalSellFee =\\n    totalBuyFee + (sellFeeTreasuryAdded) + (sellFeeRFVAdded);\\n    uint256 public wallDivisor = 2;\\n\\n    address public liquidityReceiver =\\n    0x1a2Ce410A034424B784D4b228f167A061B94CFf4;\\n    address public treasuryReceiver =\\n    0x20D61737f972EEcB0aF5f0a85ab358Cd083Dd56a;\\n    address public riskFreeValueReceiver =\\n    0x826b8d2d523E7af40888754E3De64348C00B99f4;\\n    address public galaxyBondReceiver =\\n    0x20D61737f972EEcB0aF5f0a85ab358Cd083Dd56a;\\n\\n    address public convertTo = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;\\n\\n    IDEXRouter public router;\\n    address public pair;\\n\\n    uint256 maxInvestRemovablePerPeriod = 1500000 * 10 ** 18;\\n\\n\\n    bool inSwap;\\n\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    modifier validRecipient(address to) {\\n        require(to != address(0x0), 'recipient is not valid');\\n        _;\\n    }\\n\\n    /* ======== STRUCTS ======== */\\n    struct Withdrawal {\\n        uint256 timestamp;\\n        uint256 withdrawAmount;\\n    }\\n\\n    struct InvestorInfo {\\n        uint256 totalInvestableExchanged;\\n        Withdrawal[] withdrawHistory;\\n    }\\n\\n    constructor() ERC20Detailed('Sphere Finance', 'SPHERE', uint8(DECIMALS)) {}\\n\\n    function init(address _router, address _pair) external onlyOwner {\\n        require(!doneInit, 'Already initialized');\\n        router = IDEXRouter(_router);\\n        pair = (_pair);\\n\\n        _allowedFragments[address(this)][address(router)] = type(uint256).max;\\n        _allowedFragments[address(this)][address(this)] = type(uint256).max;\\n        _allowedFragments[address(this)][pair] = type(uint256).max;\\n\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\n        _gonBalances[msg.sender] = TOTAL_GONS;\\n        _gonsPerFragment = TOTAL_GONS / (_totalSupply);\\n\\n        _isTotalFeeExempt[treasuryReceiver] = true;\\n        _isTotalFeeExempt[riskFreeValueReceiver] = true;\\n        _isTotalFeeExempt[galaxyBondReceiver] = true;\\n        _isTotalFeeExempt[address(this)] = true;\\n        _isTotalFeeExempt[msg.sender] = true;\\n        INDEX = gonsForBalance(1e18);\\n\\n        setWhitelistSetters(msg.sender, true, 1);\\n        setWhitelistSetters(msg.sender, true, 2);\\n\\n        doneInit = true;\\n        emit Transfer(address(0x0), msg.sender, _totalSupply);\\n    }\\n\\n    receive() external payable {}\\n\\n    //gets every token in circulation no matter where\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    //how much a user is allowed to transfer from own address to another one\\n    function allowance(address owner_, address spender)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n    {\\n        return _allowedFragments[owner_][spender];\\n    }\\n\\n    //get balance of user\\n    function balanceOf(address who) public view override returns (uint256) {\\n        if (_gonsPerFragment == 0) {\\n            return 0;\\n        }\\n        return _gonBalances[who] / (_gonsPerFragment);\\n    }\\n\\n    //get the address in the iteration\\n    function markerPairAddress(uint256 value) external view returns (address) {\\n        return _makerPairs[value];\\n    }\\n\\n    //get the current index of rebase\\n    function currentIndex() external view returns (uint256) {\\n        return balanceForGons(INDEX);\\n    }\\n\\n    //checks if a user is exempt from protocol fees\\n    function checkFeeExempt(address _addr) external view returns (bool) {\\n        return _isTotalFeeExempt[_addr];\\n    }\\n\\n    function gonsForBalance(uint256 amount) public view returns (uint256) {\\n        return amount * (_gonsPerFragment);\\n    }\\n\\n    function balanceForGons(uint256 gons) public view returns (uint256) {\\n        return gons / (_gonsPerFragment);\\n    }\\n\\n    //checks what the threshold is for swapping\\n    function checkSwapThreshold() external view returns (uint256) {\\n        return gonSwapThreshold / (_gonsPerFragment);\\n    }\\n\\n    // validate if the last rebase is in the past, thus execute\\n    function shouldRebase() internal view returns (bool) {\\n        return nextRebase <= block.timestamp;\\n    }\\n\\n    //enable tax bracket on users\\n    function isTaxBracketEnabled() internal view returns (bool) {\\n        return isTaxBracket;\\n    }\\n\\n    //validates if the sell limit is enabled\\n    function isSellHourlyLimitEnabled() internal view returns (bool) {\\n        return isSellHourlyLimit;\\n    }\\n\\n    //add the wall function that enables usages\\n    function isWallEnabled() internal view returns (bool) {\\n        return isWall;\\n    }\\n\\n    //validates if the swap back function should be initiated or not\\n    function shouldSwapBack() internal view returns (bool) {\\n        return\\n        !automatedMarketMakerPairs[msg.sender] &&\\n        !inSwap &&\\n        swapThreshold > 0 &&\\n        swapEnabled &&\\n        (totalBuyFee + totalSellFee) > 0 &&\\n        balanceOf(address(this)) >= (gonSwapThreshold / _gonsPerFragment);\\n    }\\n\\n    // check if the wallet should be taxed or not\\n    function shouldTakeFee(address from, address to)\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        if (_isTotalFeeExempt[from] || _isTotalFeeExempt[to]) {\\n            return false;\\n        } else if (feesOnNormalTransfers) {\\n            return true;\\n        } else {\\n            return (automatedMarketMakerPairs[from] ||\\n            automatedMarketMakerPairs[to]);\\n        }\\n    }\\n\\n    //this function iterates through all other contracts that are being part of the Sphere ecosystem\\n    //we add a new contract like wSPHERE or sSPHERE, whales could technically abuse this\\n    //by swapping to these contracts and leave the dynamic tax bracket\\n    function getBalanceContracts(address sender) public view returns (uint256) {\\n        uint256 userTotal;\\n\\n        for (uint256 i = 0; i < subContracts.length; i++) {\\n            userTotal +\\n            (IBalanceOfSphere(subContracts[i]).balanceOfSphere(sender));\\n        }\\n        for (uint256 i = 0; i < sphereGamesContracts.length; i++) {\\n            userTotal + (IERC20(sphereGamesContracts[i]).balanceOf(sender));\\n        }\\n\\n        return userTotal;\\n    }\\n\\n    //calculates circulating supply (dead and zero is not added due to them being phased out of circulation forrever)\\n    function getCirculatingSupply() external view returns (uint256) {\\n        return\\n        (TOTAL_GONS - _gonBalances[DEAD] - _gonBalances[ZERO] - _gonBalances[treasuryReceiver]) /\\n        _gonsPerFragment;\\n    }\\n\\n    function getCurrentTaxBracket(address _address)\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        //gets the total balance of the user\\n        uint256 userTotal = getUserTotalOnDifferentContractsSphere(_address);\\n\\n        //calculate the percentage\\n        uint256 totalCap = (userTotal * (100)) / (getTokensInLPCirculation());\\n\\n        //calculate what is smaller, and use that\\n        uint256 _bracket = totalCap < maxBracketTax ? totalCap : maxBracketTax;\\n\\n        //multiply the bracket with the multiplier\\n        _bracket *= taxBracketMultiplier;\\n\\n        return _bracket;\\n    }\\n\\n    function getRewardYield() external view returns (uint256, uint256) {\\n        return (REWARD_YIELD, REWARD_YIELD_DENOMINATOR);\\n    }\\n\\n    function getTokensInLPCirculation() public view returns (uint256) {\\n        uint256 LPTotal;\\n\\n        for (uint256 i = 0; i < _makerPairs.length; i++) {\\n            LPTotal += balanceOf(_makerPairs[i]);\\n        }\\n\\n        return LPTotal;\\n    }\\n\\n    //calculate the users total on different contracts\\n    function getUserTotalOnDifferentContractsSphere(address sender)\\n    public\\n    view\\n    returns (uint256)\\n    {\\n        uint256 userTotal = balanceOf(sender);\\n\\n        //calculate the balance of different contracts on different wallets and sum them\\n        return userTotal + (getBalanceContracts(sender));\\n    }\\n\\n    //sync every LP to make sure Theft-of-Liquidity can't be arbitraged\\n    function manualSync() public {\\n        for (uint256 i = 0; i < _makerPairs.length; i++) {\\n            try IDEXPair(_makerPairs[i]).sync() {} catch Error(\\n                string memory reason\\n            ) {\\n                emit GenericErrorEvent(\\n                    'manualSync(): _makerPairs.sync() Failed'\\n                );\\n                emit GenericErrorEvent(reason);\\n            }\\n        }\\n    }\\n\\n    //transfer from one valid to another\\n    function transfer(address to, uint256 value)\\n    external\\n    override\\n    validRecipient(to)\\n    returns (bool)\\n    {\\n        _transferFrom(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    //basic transfer from one wallet to the other\\n    function _basicTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        uint256 gonAmount = amount * (_gonsPerFragment);\\n        _gonBalances[from] = _gonBalances[from] - (gonAmount);\\n        _gonBalances[to] = _gonBalances[to] + (gonAmount);\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    //inherent transfer function that calculates the taxes and the limits\\n    //limits like sell per hour, party array check\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        bool excludedAccount = _isTotalFeeExempt[sender] ||\\n        _isTotalFeeExempt[recipient];\\n\\n        require(initialDistributionFinished || excludedAccount, 'Trade off');\\n\\n        if (automatedMarketMakerPairs[recipient] && !excludedAccount) {\\n            require(amount <= maxSellTransactionAmount, 'Too much sell');\\n        }\\n\\n        //update manualSync every second sell / buy to resolve possible K issues with QLaaS\\n        //only uses 60K gas\\n        if (\\n            automatedMarketMakerPairs[sender] ||\\n            automatedMarketMakerPairs[recipient]\\n        ) {\\n            if (manualSyncRefresh) {\\n                manualSync();\\n                manualSyncRefresh = false;\\n            } else {\\n                manualSyncRefresh = true;\\n            }\\n        }\\n\\n        if (\\n            automatedMarketMakerPairs[recipient] &&\\n            !excludedAccount &&\\n            partyArrayCheck[sender] &&\\n            partyTime\\n        ) {\\n            require(\\n                amount <= (maxSellTransactionAmount / (partyListDivisor)),\\n                'party div'\\n            );\\n        }\\n\\n        if (automatedMarketMakerPairs[sender] && !excludedAccount) {\\n            require(amount <= maxBuyTransactionAmount, 'too much buy');\\n        }\\n\\n        if (\\n            automatedMarketMakerPairs[recipient] &&\\n            !excludedAccount &&\\n            isSellHourlyLimitEnabled()\\n        ) {\\n            InvestorInfo storage investor = investorInfoMap[sender];\\n            //Make sure they can't withdraw too often.\\n            Withdrawal[] storage withdrawHistory = investor.withdrawHistory;\\n            uint256 authorizedWithdraw = (maxInvestRemovablePerPeriod -\\n            (getLastPeriodWithdrawals(sender)));\\n            require(amount <= authorizedWithdraw, 'max withdraw');\\n            withdrawHistory.push(\\n                Withdrawal({timestamp : block.timestamp, withdrawAmount : amount})\\n            );\\n        }\\n\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        uint256 gonAmount = amount * (_gonsPerFragment);\\n\\n        if (shouldSwapBack()) {\\n            swapBack();\\n        }\\n\\n        _gonBalances[sender] = _gonBalances[sender] - (gonAmount);\\n\\n        uint256 gonAmountReceived = shouldTakeFee(sender, recipient)\\n        ? takeFee(sender, recipient, gonAmount)\\n        : gonAmount;\\n        _gonBalances[recipient] = _gonBalances[recipient] + (gonAmountReceived);\\n\\n        if (\\n            shouldRebase() &&\\n            autoRebase &&\\n            !automatedMarketMakerPairs[sender] &&\\n            !automatedMarketMakerPairs[recipient]\\n        ) {\\n            _rebase();\\n            manualSync();\\n            setEpochCalculation();\\n        }\\n\\n        //calculate the amount of buy / sell\\n        if (automatedMarketMakerPairs[sender]) {\\n            epochBuyPressure += (gonAmount / (_gonsPerFragment));\\n            epochCollectedBuyTax += (gonAmount -\\n            (gonAmountReceived) /\\n            (_gonsPerFragment));\\n        } else if (automatedMarketMakerPairs[recipient]) {\\n            epochSellPressure += (gonAmount / (_gonsPerFragment));\\n            epochCollectedSellTax += (gonAmount -\\n            (gonAmountReceived) /\\n            (_gonsPerFragment));\\n        }\\n\\n        emit Transfer(\\n            sender,\\n            recipient,\\n            gonAmountReceived / (_gonsPerFragment)\\n        );\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override validRecipient(to) returns (bool) {\\n        if (_allowedFragments[from][msg.sender] != type(uint256).max) {\\n            _allowedFragments[from][msg.sender] =\\n            _allowedFragments[from][msg.sender] -\\n            (value);\\n        }\\n\\n        _transferFrom(from, to, value);\\n        return true;\\n    }\\n\\n    function swapBack() internal swapping {\\n        uint256 dynamicLiquidityFee = isLiquidityEnabled ? liquidityFee : 0;\\n        uint256 realTotalFee = totalBuyFee + (totalSellFee);\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        uint256 balanceBefore = address(this).balance;\\n\\n        uint256 amountToBurn = (contractTokenBalance *\\n        (burnFee + sellBurnFee)) / realTotalFee;\\n\\n        tokenBurner(amountToBurn);\\n\\n        uint256 amountToLiquidate = (contractTokenBalance *\\n        (dynamicLiquidityFee)) /\\n        (realTotalFee) /\\n        (2);\\n\\n        uint256 amountToSwap = contractTokenBalance -\\n        amountToLiquidate -\\n        amountToBurn;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = convertTo;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 amountMATIC = address(this).balance - (balanceBefore);\\n\\n        uint256 totalMATICFee = ((realTotalFee) -\\n        (dynamicLiquidityFee) /\\n        (2) -\\n        (burnFee + sellBurnFee));\\n\\n        uint256 amountMATICLiquidity = (amountMATIC * (dynamicLiquidityFee)) /\\n        (totalMATICFee) /\\n        (2);\\n\\n        uint256 amountToRFV = (amountMATIC *\\n        (riskFreeValueFee + (sellFeeRFVAdded))) / (totalMATICFee);\\n\\n        uint256 amountToGalaxyBond = (amountMATIC *\\n        (buyGalaxyBondFee + (sellGalaxyBond))) / (totalMATICFee);\\n\\n        uint256 amountToTreasury = amountMATIC -\\n        (amountMATICLiquidity) -\\n        (amountToRFV) -\\n        (amountToGalaxyBond);\\n\\n        (bool success,) = payable(treasuryReceiver).call{\\n        value : amountToTreasury,\\n        gas : 30000\\n        }('');\\n        (success,) = payable(riskFreeValueReceiver).call{\\n        value : amountToRFV,\\n        gas : 30000\\n        }('');\\n        (success,) = payable(galaxyBondReceiver).call{\\n        value : amountToGalaxyBond,\\n        gas : 30000\\n        }('');\\n\\n        success = false;\\n\\n        if (amountToLiquidate > 0) {\\n            router.addLiquidityETH{value : amountMATICLiquidity}(\\n                address(this),\\n                amountToLiquidate,\\n                0,\\n                0,\\n                liquidityReceiver,\\n                block.timestamp\\n            );\\n        }\\n    }\\n\\n    function manualSwapBack() external onlyOwner {\\n        swapBack();\\n    }\\n\\n    /** @dev Returns the total amount withdrawn by the _address during the last hour **/\\n\\n    function getLastPeriodWithdrawals(address _address)\\n    public\\n    view\\n    returns (uint256 totalWithdrawLastHour)\\n    {\\n        InvestorInfo storage investor = investorInfoMap[_address];\\n\\n        Withdrawal[] storage withdrawHistory = investor.withdrawHistory;\\n        for (uint256 i = 0; i < withdrawHistory.length; i++) {\\n            Withdrawal memory withdraw = withdrawHistory[i];\\n            if (\\n                withdraw.timestamp >= (block.timestamp - (investRemovalDelay))\\n            ) {\\n                totalWithdrawLastHour =\\n                totalWithdrawLastHour +\\n                (withdrawHistory[i].withdrawAmount);\\n            }\\n        }\\n\\n        return totalWithdrawLastHour;\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        address recipient,\\n        uint256 gonAmount\\n    ) internal returns (uint256) {\\n        uint256 _realFee = totalBuyFee;\\n\\n        if (isWallEnabled()) {\\n            _realFee = totalBuyFee / (wallDivisor);\\n        }\\n\\n        if (_isBuyFeeExempt[sender]) {\\n            _realFee = 0;\\n        }\\n\\n        //check if it's a sell fee embedded\\n        if (automatedMarketMakerPairs[recipient]) {\\n            _realFee = totalSellFee;\\n\\n            //trying to join our party? Become the party maker :)\\n            if (partyArrayCheck[sender] && partyTime) {\\n                if (_realFee < partyArrayFee[sender])\\n                    _realFee = partyArrayFee[sender];\\n            }\\n\\n            if (_isSellFeeExempt[sender]) {\\n                _realFee = 0;\\n            }\\n        }\\n\\n        if (!automatedMarketMakerPairs[sender]) {\\n            //calculate Tax\\n            if (isTaxBracketEnabled()) {\\n                _realFee += getCurrentTaxBracket(sender);\\n            }\\n        }\\n\\n        uint256 feeAmount = (gonAmount * (_realFee)) / (FEE_DENOMINATOR);\\n\\n        _gonBalances[address(this)] = _gonBalances[address(this)] + (feeAmount);\\n\\n        emit Transfer(sender, address(this), (feeAmount / (_gonsPerFragment)));\\n\\n        return gonAmount - (feeAmount);\\n    }\\n\\n    //burn tokens to the dead wallet\\n    function tokenBurner(uint256 _tokenAmount) private {\\n        _transferFrom(address(this), address(DEAD), _tokenAmount);\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n    external\\n    returns (bool)\\n    {\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\n        if (subtractedValue >= oldValue) {\\n            _allowedFragments[msg.sender][spender] = 0;\\n        } else {\\n            _allowedFragments[msg.sender][spender] =\\n            oldValue -\\n            (subtractedValue);\\n        }\\n        emit Approval(\\n            msg.sender,\\n            spender,\\n            _allowedFragments[msg.sender][spender]\\n        );\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n    external\\n    returns (bool)\\n    {\\n        _allowedFragments[msg.sender][spender] =\\n        _allowedFragments[msg.sender][spender] -\\n        (addedValue);\\n        emit Approval(\\n            msg.sender,\\n            spender,\\n            _allowedFragments[msg.sender][spender]\\n        );\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value)\\n    external\\n    override\\n    returns (bool)\\n    {\\n        _allowedFragments[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function _rebase() private {\\n        int256 supplyDelta;\\n        int256 i = 0;\\n        if (!inSwap) {\\n            do {\\n                supplyDelta = int256(\\n                    (_totalSupply * (REWARD_YIELD)) / (REWARD_YIELD_DENOMINATOR)\\n                );\\n                coreRebase(supplyDelta);\\n                i++;\\n            }\\n            while (nextRebase < block.timestamp && i < 100);\\n            manualSync();\\n        }\\n    }\\n\\n    //rebase everyone\\n    function coreRebase(int256 supplyDelta) private returns (uint256) {\\n        require(nextRebase <= block.timestamp, 'rebase too early');\\n        uint256 epoch = nextRebase;\\n\\n        if (supplyDelta == 0) {\\n            emit LogRebase(epoch, _totalSupply);\\n            return _totalSupply;\\n        }\\n\\n        if (supplyDelta < 0) {\\n            _totalSupply = _totalSupply - (uint256(- supplyDelta));\\n        } else {\\n            _totalSupply = _totalSupply + (uint256(supplyDelta));\\n        }\\n\\n        if (_totalSupply > MAX_SUPPLY) {\\n            _totalSupply = MAX_SUPPLY;\\n        }\\n\\n        _gonsPerFragment = TOTAL_GONS / (_totalSupply);\\n\\n        updateRebaseIndex(epoch);\\n\\n        emit LogRebase(epoch, _totalSupply);\\n        return _totalSupply;\\n    }\\n\\n    //set who is allowed to trigger the rebase or reward yield\\n    function setWhitelistSetters(\\n        address _addr,\\n        bool _value,\\n        uint256 _type\\n    ) public onlyOwner {\\n        if (_type == 1) {\\n            require(canRebase[_addr] != _value, 'Not changed');\\n            canRebase[_addr] = _value;\\n        } else if (_type == 2) {\\n            require(canSetRewardYield[_addr] != _value, 'Not changed');\\n            canSetRewardYield[_addr] = _value;\\n        }\\n\\n        emit SetRebaseWhitelist(_addr, _value, _type);\\n    }\\n\\n    //set the router in case of dex switch\\n    function setRouter(address _router, address _pair) external onlyOwner {\\n        router = IDEXRouter(_router);\\n        pair = _pair;\\n\\n        _allowedFragments[address(this)][address(router)] = type(uint256).max;\\n        _allowedFragments[address(this)][address(this)] = type(uint256).max;\\n        _allowedFragments[address(this)][pair] = type(uint256).max;\\n        setAutomatedMarketMakerPair(pair, true);\\n\\n        emit SetRouter(_router, _pair);\\n    }\\n\\n    //execute manual rebase\\n    function manualRebase() external nonReentrant {\\n        require(canRebase[msg.sender], 'can not rebase');\\n        require(!inSwap, 'Try again');\\n        require(nextRebase <= block.timestamp, 'Not in time');\\n\\n        int256 supplyDelta;\\n        int256 i = 0;\\n\\n        do {\\n            supplyDelta = int256(\\n                (_totalSupply * (REWARD_YIELD)) / (REWARD_YIELD_DENOMINATOR)\\n            );\\n            coreRebase(supplyDelta);\\n            i++;\\n        }\\n        while (nextRebase < block.timestamp && i < 100);\\n\\n        manualSync();\\n    }\\n\\n    //move full balance without the tax\\n    function moveBalance(address _to)\\n    external\\n    validRecipient(_to)\\n    returns (bool)\\n    {\\n        require(isMoveBalance, 'can not move');\\n        require(initialDistributionFinished, 'Trade off');\\n        // Allow to move balance only once\\n        require(!_disallowedToMove[msg.sender], 'not allowed');\\n        require(balanceOf(msg.sender) > 0, 'No tokens');\\n        uint256 balanceOfAllSubContracts = 0;\\n\\n        balanceOfAllSubContracts = getBalanceContracts(msg.sender);\\n        require(balanceOfAllSubContracts == 0, 'other balances');\\n\\n        // Once an address received funds moved from another address it should\\n        // not be able to move its balance again\\n        _disallowedToMove[msg.sender] = true;\\n        uint256 gonAmount = _gonBalances[msg.sender];\\n\\n        // reduce balance early\\n        _gonBalances[msg.sender] = _gonBalances[msg.sender] - (gonAmount);\\n\\n        // Move the balance to the to address\\n        _gonBalances[_to] = _gonBalances[_to] + (gonAmount);\\n\\n        emit Transfer(msg.sender, _to, (gonAmount / (_gonsPerFragment)));\\n        emit MoveBalance(msg.sender, _to);\\n        return true;\\n    }\\n\\n    function updateRebaseIndex(uint256 epoch) private {\\n        // update the next Rebase time\\n        nextRebase = epoch + rebaseFrequency;\\n\\n        //simply show how often we rebased since inception (how many epochs)\\n        rebaseEpoch += 1;\\n    }\\n\\n    //add new subcontracts to the protocol so they can be calculated\\n    function addSubContracts(address _subContract, bool _value)\\n    external\\n    onlyOwner\\n    {\\n        require(subContractCheck[_subContract] != _value, 'Value already set');\\n\\n        subContractCheck[_subContract] = _value;\\n\\n        if (_value) {\\n            subContracts.push(_subContract);\\n        } else {\\n            for (uint256 i = 0; i < subContracts.length; i++) {\\n                if (subContracts[i] == _subContract) {\\n                    subContracts[i] = subContracts[subContracts.length - 1];\\n                    subContracts.pop();\\n                    break;\\n                }\\n            }\\n        }\\n\\n        emit SetSubContracts(_subContract, _value);\\n    }\\n\\n    //Add S.P.H.E.R.E. Games Contracts\\n    function addSphereGamesAddies(address _sphereGamesAddy, bool _value)\\n    external\\n    onlyOwner\\n    {\\n        require(\\n            sphereGamesCheck[_sphereGamesAddy] != _value,\\n            'Value already set'\\n        );\\n\\n        sphereGamesCheck[_sphereGamesAddy] = _value;\\n\\n        if (_value) {\\n            sphereGamesContracts.push(_sphereGamesAddy);\\n        } else {\\n            require(sphereGamesContracts.length > 1, 'Required 1 pair');\\n            for (uint256 i = 0; i < sphereGamesContracts.length; i++) {\\n                if (sphereGamesContracts[i] == _sphereGamesAddy) {\\n                    sphereGamesContracts[i] = sphereGamesContracts[\\n                    sphereGamesContracts.length - 1\\n                    ];\\n                    sphereGamesContracts.pop();\\n                    break;\\n                }\\n            }\\n        }\\n\\n        emit SetSphereGamesAddresses(_sphereGamesAddy, _value);\\n    }\\n\\n    function addPartyAddies(\\n        address _partyAddy,\\n        bool _value,\\n        uint256 feeAmount\\n    ) external onlyOwner {\\n        partyArrayCheck[_partyAddy] = _value;\\n        partyArrayFee[_partyAddy] = feeAmount;\\n\\n        if (_value) {\\n            partyArray.push(_partyAddy);\\n        } else {\\n            for (uint256 i = 0; i < partyArray.length; i++) {\\n                if (partyArray[i] == _partyAddy) {\\n                    partyArray[i] = partyArray[partyArray.length - 1];\\n                    partyArray.pop();\\n                    break;\\n                }\\n            }\\n        }\\n\\n        emit SetPartyAddresses(_partyAddy, _value);\\n    }\\n\\n    function setAutomatedMarketMakerPair(address _pair, bool _value)\\n    public\\n    onlyOwner\\n    {\\n        require(automatedMarketMakerPairs[_pair] != _value, 'already set');\\n\\n        automatedMarketMakerPairs[_pair] = _value;\\n\\n        if (_value) {\\n            _makerPairs.push(_pair);\\n            _markerPairCount++;\\n        } else {\\n            require(_makerPairs.length > 1, 'Required 1 pair');\\n            for (uint256 i = 0; i < _makerPairs.length; i++) {\\n                if (_makerPairs[i] == _pair) {\\n                    _makerPairs[i] = _makerPairs[_makerPairs.length - 1];\\n                    _makerPairs.pop();\\n                    _markerPairCount--;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        emit SetAutomatedMarketMakerPair(_pair, _value);\\n    }\\n\\n    function setInitialDistributionFinished(bool _value) external onlyOwner {\\n        initialDistributionFinished = _value;\\n\\n        emit SetInitialDistribution(_value);\\n    }\\n\\n    function setInvestRemovalDelay(uint256 _value) external onlyOwner {\\n        require(_value < MAX_INVEST_REMOVABLE_DELAY, 'over 2 hours');\\n        investRemovalDelay = _value;\\n\\n        emit SetInvestRemovalDelay(_value);\\n    }\\n\\n    function setEpochCalculation() private {\\n        //store previous buy pressure\\n        oldEpochBuyPressure = epochBuyPressure;\\n        oldEpochCollectedBuyTax = epochCollectedBuyTax;\\n        epochBuyPressure = 0;\\n\\n        //store previous sell pressure\\n        oldEpochSellPressure = epochSellPressure;\\n        oldEpochCollectedSellTax = epochCollectedSellTax;\\n        epochSellPressure = 0;\\n    }\\n\\n    function setMaxInvestRemovablePerPeriod(uint256 _value) external onlyOwner {\\n        require(_value > MIN_INVEST_REMOVABLE_PER_PERIOD, 'Below minimum');\\n        maxInvestRemovablePerPeriod = _value;\\n\\n        emit SetMaxInvestRemovablePerPeriod(_value);\\n    }\\n\\n    function setSellHourlyLimit(bool _value) external onlyOwner {\\n        isSellHourlyLimit = _value;\\n\\n        emit SetHourlyLimit(_value);\\n    }\\n\\n    function setContractToChange(address _value) external onlyOwner {\\n        convertTo = _value;\\n\\n        emit SetContractToChange(_value);\\n    }\\n\\n    function setPartyListDivisor(uint256 _value) external onlyOwner {\\n        require(_value <= MAX_PARTY_LIST_DIVISOR_RATE, 'max party');\\n        partyListDivisor = _value;\\n\\n        emit SetPartyListDivisor(_value);\\n    }\\n\\n    function setMoveBalance(bool _value) external onlyOwner {\\n        isMoveBalance = _value;\\n\\n        emit SetMoveBalance(_value);\\n    }\\n\\n    function setFeeTypeExempt(\\n        address _addr,\\n        bool _value,\\n        uint256 _type\\n    ) external onlyOwner {\\n        if (_type == 1) {\\n            require(_isTotalFeeExempt[_addr] != _value, 'Not changed');\\n            _isTotalFeeExempt[_addr] = _value;\\n            emit SetTotalFeeExempt(_addr, _value);\\n        } else if (_type == 2) {\\n            require(_isBuyFeeExempt[_addr] != _value, 'Not changed');\\n            _isBuyFeeExempt[_addr] = _value;\\n            emit SetBuyFeeExempt(_addr, _value);\\n        } else if (_type == 3) {\\n            require(_isSellFeeExempt[_addr] != _value, 'Not changed');\\n            _isSellFeeExempt[_addr] = _value;\\n            emit SetSellFeeExempt(_addr, _value);\\n        }\\n    }\\n\\n    function setSwapBackSettings(\\n        bool _enabled,\\n        uint256 _num,\\n        uint256 _denom\\n    ) external onlyOwner {\\n        swapEnabled = _enabled;\\n        gonSwapThreshold = (TOTAL_GONS * (_num)) / (_denom);\\n        emit SetSwapBackSettings(_enabled, _num, _denom);\\n    }\\n\\n    function setFeeReceivers(\\n        address _liquidityReceiver,\\n        address _treasuryReceiver,\\n        address _riskFreeValueReceiver,\\n        address _galaxyBondReceiver\\n    ) external onlyOwner {\\n        liquidityReceiver = _liquidityReceiver;\\n        treasuryReceiver = _treasuryReceiver;\\n        riskFreeValueReceiver = _riskFreeValueReceiver;\\n        galaxyBondReceiver = _galaxyBondReceiver;\\n    }\\n\\n    function setFees(\\n        uint256 _liquidityFee,\\n        uint256 _riskFreeValueFee,\\n        uint256 _treasuryFee,\\n        uint256 _burnFee,\\n        uint256 _buyGalaxyBondFee,\\n        uint256 _sellFeeTreasuryAdded,\\n        uint256 _sellFeeRFVAdded,\\n        uint256 _sellBurnFee,\\n        uint256 _sellGalaxyBond,\\n        uint256 _realFeePartyArray,\\n        bool _isTaxBracketEnabledInMoveFee\\n    ) external onlyOwner {\\n        liquidityFee = _liquidityFee;\\n        riskFreeValueFee = _riskFreeValueFee;\\n        treasuryFee = _treasuryFee;\\n        sellFeeTreasuryAdded = _sellFeeTreasuryAdded;\\n        sellFeeRFVAdded = _sellFeeRFVAdded;\\n        buyGalaxyBondFee = _buyGalaxyBondFee;\\n        burnFee = _burnFee;\\n        sellBurnFee = _sellBurnFee;\\n        sellGalaxyBond = _sellGalaxyBond;\\n        realFeePartyArray = _realFeePartyArray;\\n\\n        uint256 maxTotalBuyFee = liquidityFee +\\n        (treasuryFee) +\\n        (burnFee) +\\n        (buyGalaxyBondFee) +\\n        (riskFreeValueFee);\\n\\n        uint256 maxTotalSellFee = maxTotalBuyFee +\\n        (sellFeeTreasuryAdded) +\\n        (sellFeeRFVAdded) +\\n        (sellBurnFee) +\\n        (sellGalaxyBond);\\n\\n        require(maxTotalBuyFee < MAX_TOTAL_BUY_FEE_RATE, 'max buy fees');\\n\\n        require(maxTotalSellFee < MAX_TOTAL_SELL_FEE_RATE, 'max sell fees');\\n\\n        require(realFeePartyArray < MAX_PARTY_ARRAY, 'max party fees');\\n\\n        totalBuyFee = maxTotalBuyFee;\\n        totalSellFee = maxTotalSellFee;\\n\\n        isTaxBracketEnabledInMoveFee = _isTaxBracketEnabledInMoveFee;\\n\\n        emit SetFees(\\n            _liquidityFee,\\n            _riskFreeValueFee,\\n            _treasuryFee,\\n            _sellFeeTreasuryAdded,\\n            _sellFeeRFVAdded,\\n            _burnFee,\\n            sellBurnFee,\\n            maxTotalBuyFee,\\n            _isTaxBracketEnabledInMoveFee\\n        );\\n    }\\n\\n    function setPartyTime(bool _value) external onlyOwner {\\n        partyTime = _value;\\n        emit SetPartyTime(_value, block.timestamp);\\n    }\\n\\n    function setTaxBracketFeeMultiplier(\\n        uint256 _taxBracketFeeMultiplier,\\n        bool _isTaxBracketEnabled\\n    ) external onlyOwner {\\n        require(\\n            _taxBracketFeeMultiplier <= MAX_TAX_BRACKET_FEE_RATE,\\n            'max bracket fee exceeded'\\n        );\\n        taxBracketMultiplier = _taxBracketFeeMultiplier;\\n        isTaxBracket = _isTaxBracketEnabled;\\n        emit SetTaxBracketFeeMultiplier(\\n            _taxBracketFeeMultiplier,\\n            _isTaxBracketEnabled,\\n            block.timestamp\\n        );\\n    }\\n\\n    function clearStuckBalance(address _receiver) external onlyOwner {\\n        uint256 balance = address(this).balance;\\n        payable(_receiver).transfer(balance);\\n        emit ClearStuckBalance(balance, _receiver, block.timestamp);\\n    }\\n\\n    function rescueToken(address tokenAddress)\\n    external\\n    onlyOwner\\n    returns (bool success)\\n    {\\n        uint256 tokens = ERC20Detailed(tokenAddress).balanceOf(address(this));\\n        emit RescueToken(tokenAddress, msg.sender, tokens, block.timestamp);\\n        return ERC20Detailed(tokenAddress).transfer(msg.sender, tokens);\\n    }\\n\\n    function setAutoRebase(bool _autoRebase) external onlyOwner {\\n        autoRebase = _autoRebase;\\n        emit SetAutoRebase(_autoRebase, block.timestamp);\\n    }\\n\\n    //set rebase frequency\\n    function setRebaseFrequency(uint256 _rebaseFrequency) external onlyOwner {\\n        require(_rebaseFrequency <= MAX_REBASE_FREQUENCY, 'Too high');\\n        rebaseFrequency = _rebaseFrequency;\\n        emit SetRebaseFrequency(_rebaseFrequency, block.timestamp);\\n    }\\n\\n    //set reward yield\\n    function setRewardYield(\\n        uint256 _rewardYield,\\n        uint256 _rewardYieldDenominator\\n    ) external {\\n        require(canSetRewardYield[msg.sender], 'Not allowed for reward yield');\\n        REWARD_YIELD = _rewardYield;\\n        REWARD_YIELD_DENOMINATOR = _rewardYieldDenominator;\\n        emit SetRewardYield(\\n            _rewardYield,\\n            _rewardYieldDenominator,\\n            block.timestamp,\\n            msg.sender\\n        );\\n    }\\n\\n    //set swap threshold\\n    function setSwapThreshold(uint256 _value) external onlyOwner {\\n        swapThreshold = _value;\\n    }\\n\\n    //enable fees on normal transfer\\n    function setFeesOnNormalTransfers(bool _enabled) external onlyOwner {\\n        feesOnNormalTransfers = _enabled;\\n    }\\n\\n    //set next rebase time\\n    function setNextRebase(uint256 _nextRebase) external onlyOwner {\\n        require(_nextRebase > block.timestamp, 'can not be in past');\\n        nextRebase = _nextRebase;\\n        emit SetNextRebase(_nextRebase, block.timestamp);\\n    }\\n\\n    function setIsLiquidityEnabled(bool _value) external onlyOwner {\\n        isLiquidityEnabled = _value;\\n        emit SetIsLiquidityEnabled(_value);\\n    }\\n\\n    function setMaxTransactionAmount(uint256 _maxSellTxn, uint256 _maxBuyTxn)\\n    external\\n    onlyOwner\\n    {\\n        require(\\n            _maxSellTxn > MIN_SELL_AMOUNT_RATE,\\n            'Below minimum sell amount'\\n        );\\n        require(_maxBuyTxn > MIN_BUY_AMOUNT_RATE, 'Below minimum buy amount');\\n        maxSellTransactionAmount = _maxSellTxn;\\n        maxBuyTransactionAmount = _maxBuyTxn;\\n        emit SetMaxTransactionAmount(_maxSellTxn, _maxBuyTxn, block.timestamp);\\n    }\\n\\n    function setWallDivisor(uint256 _wallDivisor, bool _isWall)\\n    external\\n    onlyOwner\\n    {\\n        wallDivisor = _wallDivisor;\\n        isWall = _isWall;\\n        emit SetWallDivisor(_wallDivisor, _isWall);\\n    }\\n\\n    event SwapBack(\\n        uint256 contractTokenBalance,\\n        uint256 amountToLiquify,\\n        uint256 amountToRFV,\\n        uint256 amountToTreasury,\\n        uint256 amountToGalaxyBond\\n    );\\n\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 MATICReceived,\\n        uint256 tokensIntoLiqudity\\n    );\\n\\n    event SetFeeReceivers(\\n        address indexed _liquidityReceiver,\\n        address indexed _treasuryReceiver,\\n        address indexed _riskFreeValueReceiver,\\n        address _galaxyBondReceiver\\n    );\\n\\n    event SetPartyTime(bool indexed state, uint256 indexed time);\\n\\n    event SetTaxBracketFeeMultiplier(\\n        uint256 indexed state,\\n        bool indexed _isTaxBracketEnabled,\\n        uint256 indexed time\\n    );\\n\\n    event ClearStuckBalance(\\n        uint256 indexed amount,\\n        address indexed receiver,\\n        uint256 indexed time\\n    );\\n\\n    event RescueToken(\\n        address indexed tokenAddress,\\n        address indexed sender,\\n        uint256 indexed tokens,\\n        uint256 time\\n    );\\n\\n    event SetAutoRebase(bool indexed value, uint256 indexed time);\\n\\n    event SetTaxBracket(bool indexed value, uint256 indexed time);\\n\\n    event SetRebaseFrequency(uint256 indexed frequency, uint256 indexed time);\\n\\n    event SetRewardYield(\\n        uint256 indexed rewardYield,\\n        uint256 indexed frequency,\\n        uint256 indexed time,\\n        address setter\\n    );\\n\\n    event SetFeesOnNormalTransfers(bool indexed value, uint256 indexed time);\\n\\n    event SetNextRebase(uint256 indexed value, uint256 indexed time);\\n\\n    event SetMaxTransactionAmount(\\n        uint256 indexed sell,\\n        uint256 indexed buy,\\n        uint256 indexed time\\n    );\\n\\n    event SetWallDivisor(uint256 indexed _wallDivisor, bool indexed _isWall);\\n\\n    event SetSwapBackSettings(\\n        bool indexed enabled,\\n        uint256 indexed num,\\n        uint256 indexed denum\\n    );\\n\\n    event SetFees(\\n        uint256 indexed _liquidityFee,\\n        uint256 indexed _riskFreeValue,\\n        uint256 indexed _treasuryFee,\\n        uint256 _sellFeeTreasuryAdded,\\n        uint256 _sellFeeRFVAdded,\\n        uint256 _burnFee,\\n        uint256 sellBurnFee,\\n        uint256 totalBuyFee,\\n        bool _isTaxBracketEnabledInMoveFee\\n    );\\n\\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n    event SetInitialDistribution(bool indexed value);\\n    event SetInvestRemovalDelay(uint256 indexed value);\\n    event SetMaxInvestRemovablePerPeriod(uint256 indexed value);\\n    event SetMoveBalance(bool indexed value);\\n    event SetIsLiquidityEnabled(bool indexed value);\\n    event SetPartyListDivisor(uint256 indexed value);\\n    event SetHourlyLimit(bool indexed value);\\n    event SetContractToChange(address indexed value);\\n    event SetSwapThreshold(uint256 indexed value);\\n    event SetTotalFeeExempt(address indexed addy, bool indexed value);\\n    event SetBuyFeeExempt(address indexed addy, bool indexed value);\\n    event SetSellFeeExempt(address indexed addy, bool indexed value);\\n    event SetRebaseWhitelist(\\n        address indexed addy,\\n        bool indexed value,\\n        uint256 indexed _type\\n    );\\n    event SetSubContracts(address indexed pair, bool indexed value);\\n    event SetPartyAddresses(address indexed pair, bool indexed value);\\n    event SetSphereGamesAddresses(address indexed pair, bool indexed value);\\n    event GenericErrorEvent(string reason);\\n    event SetRouter(address indexed _address, address indexed _pair);\\n    event MoveBalance(address from, address to);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"ClearStuckBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"GenericErrorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"MoveBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"RescueToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SetAutoRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetBuyFeeExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"SetContractToChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_liquidityReceiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_riskFreeValueReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_galaxyBondReceiver\",\"type\":\"address\"}],\"name\":\"SetFeeReceivers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_riskFreeValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_treasuryFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sellFeeTreasuryAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sellFeeRFVAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellBurnFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBuyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isTaxBracketEnabledInMoveFee\",\"type\":\"bool\"}],\"name\":\"SetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SetFeesOnNormalTransfers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetHourlyLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetInitialDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetInvestRemovalDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetIsLiquidityEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetMaxInvestRemovablePerPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SetMaxTransactionAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetMoveBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SetNextRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetPartyAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetPartyListDivisor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SetPartyTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"frequency\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SetRebaseFrequency\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"SetRebaseWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardYield\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"frequency\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"}],\"name\":\"SetRewardYield\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"SetRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetSellFeeExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetSphereGamesAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetSubContracts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"denum\",\"type\":\"uint256\"}],\"name\":\"SetSwapBackSettings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SetSwapThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SetTaxBracket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_isTaxBracketEnabled\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SetTaxBracketFeeMultiplier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetTotalFeeExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_wallDivisor\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_isWall\",\"type\":\"bool\"}],\"name\":\"SetWallDivisor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"MATICReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractTokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToLiquify\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToRFV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToTreasury\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToGalaxyBond\",\"type\":\"uint256\"}],\"name\":\"SwapBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"TransferOwnerShip\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_disallowedToMove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_makerPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_markerPairCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partyAddy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"addPartyAddies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sphereGamesAddy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"addSphereGamesAddies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_subContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"addSubContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gons\",\"type\":\"uint256\"}],\"name\":\"balanceForGons\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convertTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochBuyPressure\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochCollectedBuyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochCollectedSellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochSellPressure\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"galaxyBondReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getBalanceContracts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getCurrentTaxBracket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLastPeriodWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalWithdrawLastHour\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensInLPCirculation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getUserTotalOnDifferentContractsSphere\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"gonsForBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialDistributionFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorInfoMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalInvestableExchanged\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBurnEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLiquidityEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMoveBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSellHourlyLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTaxBracket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTaxBracketEnabledInMoveFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"markerPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"moveBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextRebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldEpochBuyPressure\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldEpochCollectedBuyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldEpochCollectedSellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldEpochSellPressure\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"partyArray\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partyArrayCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partyArrayFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partyTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riskFreeValueReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_autoRebase\",\"type\":\"bool\"}],\"name\":\"setAutoRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"setContractToChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_riskFreeValueReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_galaxyBondReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"setFeeTypeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_riskFreeValueFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyGalaxyBondFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFeeTreasuryAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFeeRFVAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellBurnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellGalaxyBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_realFeePartyArray\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isTaxBracketEnabledInMoveFee\",\"type\":\"bool\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setFeesOnNormalTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setInitialDistributionFinished\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setInvestRemovalDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setIsLiquidityEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMaxInvestRemovablePerPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSellTxn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBuyTxn\",\"type\":\"uint256\"}],\"name\":\"setMaxTransactionAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setMoveBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextRebase\",\"type\":\"uint256\"}],\"name\":\"setNextRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setPartyListDivisor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setPartyTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rebaseFrequency\",\"type\":\"uint256\"}],\"name\":\"setRebaseFrequency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardYield\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardYieldDenominator\",\"type\":\"uint256\"}],\"name\":\"setRewardYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setSellHourlyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denom\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxBracketFeeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isTaxBracketEnabled\",\"type\":\"bool\"}],\"name\":\"setTaxBracketFeeMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wallDivisor\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isWall\",\"type\":\"bool\"}],\"name\":\"setWallDivisor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"setWhitelistSetters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sphereGamesCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sphereGamesContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"subContractCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxBracketMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wallDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SphereTokenV2", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}