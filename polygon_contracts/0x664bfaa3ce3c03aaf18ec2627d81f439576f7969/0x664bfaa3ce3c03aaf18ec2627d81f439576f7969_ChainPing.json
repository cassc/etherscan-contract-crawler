{"SourceCode": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IStargateRouter {\r\n    function sgReceive(\r\n        uint16 _chainId, \r\n        bytes memory _srcAddress, \r\n        uint _nonce, \r\n        address _token, \r\n        uint amountLD, \r\n        bytes memory _payload\r\n    ) external;\r\n}\r\n\r\ncontract ChainPing is IStargateRouter {\r\n    address public owner;\r\n    address public stargateRouter;\r\n    event ReceivedOnDestination(address token, uint256 amountLD, bool success);\r\n\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender, \"Invalid Owner\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _stargateRouter) {\r\n        owner = msg.sender;\r\n        stargateRouter = _stargateRouter;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function balanceOf(address token) public view returns(uint256) {\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    function setOwner(address _owner) external onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    function setRouter(address _stargateRouter) external onlyOwner {\r\n        stargateRouter = _stargateRouter;\r\n    }\r\n\r\n    function rescueFunds(address token) public onlyOwner {\r\n        if (token == address(0)) {\r\n            payable(msg.sender).transfer(address(this).balance);\r\n        } else {\r\n            IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    function approve(address token, uint256 amount) public onlyOwner {\r\n        IERC20(token).approve(msg.sender, 0);\r\n        IERC20(token).approve(msg.sender, amount);\r\n    }\r\n\r\n\r\n    function callDataCall (\r\n        address payable _to, \r\n        address _token, \r\n        address _spender, \r\n        uint256 _amount,\r\n        bytes memory txData\r\n\t) public onlyOwner {\r\n        if (_token != address(0) && _amount > 0) {\r\n            IERC20(_token).approve(_spender, _amount);\r\n        }\r\n\t\t(bool success, ) = _to.call(txData);\r\n\t\trequire(success);\r\n\t}\r\n\r\n    /// @param _chainId The remote chainId sending the tokens\r\n    /// @param _srcAddress The remote Bridge address\r\n    /// @param _nonce The message ordering nonce\r\n    /// @param _token The token contract on the local chain\r\n    /// @param amountLD The qty of local _token contract tokens  \r\n    /// @param _payload The bytes containing the toAddress\r\n    function sgReceive(\r\n        uint16 _chainId,\r\n        bytes memory _srcAddress,\r\n        uint _nonce,\r\n        address _token,\r\n        uint amountLD,\r\n        bytes memory _payload\r\n    ) override external {\r\n        require(\r\n            msg.sender == address(stargateRouter) || msg.sender == owner, \r\n            \"only stargate router and owner can call sgReceive!\"\r\n        );\r\n        (\r\n            uint256 nativeFee, \r\n            uint256 _amount, \r\n            address _to, \r\n            address _user, \r\n            address _extraOrShareToken, \r\n            bytes memory txData\r\n        ) = abi.decode(_payload, (uint256, uint256, address, address, address,bytes));\r\n        IERC20(_token).approve(_to, _amount);\r\n\r\n        uint256 beforeTokens;\r\n        if (_extraOrShareToken != address(0)) beforeTokens = IERC20(_extraOrShareToken).balanceOf(address(this));\r\n\r\n        bool success;\r\n        if (amountLD >= _amount) {\r\n            if (nativeFee > 0) {\r\n                (success, ) = _to.call{value: nativeFee}(txData);\r\n            } else {\r\n                (success, ) = _to.call(txData);\r\n            }\r\n        }\r\n\r\n        uint256 anyDust;\r\n        if (!success) {\r\n            IERC20(_token).approve(_to, 0);\r\n            anyDust = amountLD;\r\n        } else if (amountLD > _amount) {\r\n            anyDust = amountLD - _amount;\r\n        }\r\n        \r\n        if (anyDust > 0) IERC20(_token).transfer(_user, anyDust);\r\n        if (success && _extraOrShareToken != address(0)) {\r\n            uint256 afterTokens = IERC20(_extraOrShareToken).balanceOf(address(this)); \r\n            if (afterTokens > beforeTokens) {\r\n                IERC20(_extraOrShareToken).transfer(_user, afterTokens-beforeTokens);\r\n            }\r\n        }\r\n        emit ReceivedOnDestination(_token, amountLD, success);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stargateRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLD\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"ReceivedOnDestination\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"}],\"name\":\"callDataCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stargateRouter\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountLD\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"sgReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargateRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ChainPing", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000045a01e4e04f14f7a4a6702c74187c5f6222033cd", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bfe1321c3c992b6c464a04b0180b4686d964aeff6fa6958b0532681102872af2"}