{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/onchainid/Identity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"./interface/IIdentity.sol\\\";\\nimport \\\"./interface/IClaimIssuer.sol\\\";\\nimport \\\"./version/Version.sol\\\";\\nimport \\\"./storage/Storage.sol\\\";\\n\\n/**\\n * @dev Implementation of the `IERC734` \\\"KeyHolder\\\" and the `IERC735` \\\"ClaimHolder\\\" interfaces\\n * into a common Identity Contract.\\n * This implementation has a separate contract were it declares all storage,\\n * allowing for it to be used as an upgradable logic contract.\\n */\\ncontract Identity is Storage, IIdentity, Version {\\n\\n    /**\\n     * @notice Prevent any direct calls to the implementation contract (marked by _canInteract = false).\\n     */\\n    modifier delegatedOnly() {\\n        require(_canInteract == true, \\\"Interacting with the library contract is forbidden.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice requires management key to call this function, or internal call\\n     */\\n    modifier onlyManager() {\\n        require(msg.sender == address(this) || keyHasPurpose(keccak256(abi.encode(msg.sender)), 1)\\n        , \\\"Permissions: Sender does not have management key\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice requires claim key to call this function, or internal call\\n     */\\n    modifier onlyClaimKey() {\\n        require(msg.sender == address(this) || keyHasPurpose(keccak256(abi.encode(msg.sender)), 3)\\n        , \\\"Permissions: Sender does not have claim signer key\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice constructor of the Identity contract\\n     * @param initialManagementKey the address of the management key at deployment\\n     * @param _isLibrary boolean value stating if the contract is library or not\\n     * calls __Identity_init if contract is not library\\n     */\\n    constructor(address initialManagementKey, bool _isLibrary) {\\n        require(initialManagementKey != address(0), \\\"invalid argument - zero address\\\");\\n\\n        if (!_isLibrary) {\\n            __Identity_init(initialManagementKey);\\n        } else {\\n            _initialized = true;\\n        }\\n    }\\n\\n    /**\\n     * @notice When using this contract as an implementation for a proxy, call this initializer with a delegatecall.\\n     *\\n     * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\\n     */\\n    function initialize(address initialManagementKey) external {\\n        require(initialManagementKey != address(0), \\\"invalid argument - zero address\\\");\\n        __Identity_init(initialManagementKey);\\n    }\\n\\n    /**\\n     * @dev See {IERC734-execute}.\\n     * @notice Passes an execution instruction to the keymanager.\\n     * If the sender is an ACTION key and the destination address is not the identity contract itself, then the\\n     * execution is immediately approved and performed.\\n     * If the destination address is the identity itself, then the execution would be performed immediately only if\\n     * the sender is a MANAGEMENT key.\\n     * Otherwise the execution request must be approved via the `approve` method.\\n     * @return executionId to use in the approve function, to approve or reject this execution.\\n     */\\n    function execute(address _to, uint256 _value, bytes memory _data)\\n    external\\n    delegatedOnly\\n    override\\n    payable\\n    returns (uint256 executionId)\\n    {\\n        uint256 _executionId = _executionNonce;\\n        _executions[_executionId].to = _to;\\n        _executions[_executionId].value = _value;\\n        _executions[_executionId].data = _data;\\n        _executionNonce++;\\n\\n        emit ExecutionRequested(_executionId, _to, _value, _data);\\n\\n        if (keyHasPurpose(keccak256(abi.encode(msg.sender)), 1)) {\\n            approve(_executionId, true);\\n        }\\n        else if (_to != address(this) && keyHasPurpose(keccak256(abi.encode(msg.sender)), 2)){\\n            approve(_executionId, true);\\n        }\\n\\n        return _executionId;\\n    }\\n\\n    /**\\n     * @dev See {IERC734-getKey}.\\n     * @notice Implementation of the getKey function from the ERC-734 standard\\n     * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\\n     * @return purposes Returns the full key data, if present in the identity.\\n     * @return keyType Returns the full key data, if present in the identity.\\n     * @return key Returns the full key data, if present in the identity.\\n     */\\n    function getKey(bytes32 _key)\\n    external\\n    override\\n    view\\n    returns(uint256[] memory purposes, uint256 keyType, bytes32 key)\\n    {\\n        return (_keys[_key].purposes, _keys[_key].keyType, _keys[_key].key);\\n    }\\n\\n    /**\\n    * @dev See {IERC734-getKeyPurposes}.\\n    * @notice gets the purposes of a key\\n    * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\\n    * @return _purposes Returns the purposes of the specified key\\n    */\\n    function getKeyPurposes(bytes32 _key)\\n    external\\n    override\\n    view\\n    returns(uint256[] memory _purposes)\\n    {\\n        return (_keys[_key].purposes);\\n    }\\n\\n    /**\\n    * @dev See {IERC734-getKeysByPurpose}.\\n    * @notice gets all the keys with a specific purpose from an identity\\n    * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\\n    * @return keys Returns an array of public key bytes32 hold by this identity and having the specified purpose\\n    */\\n    function getKeysByPurpose(uint256 _purpose)\\n    external\\n    override\\n    view\\n    returns(bytes32[] memory keys)\\n    {\\n        return _keysByPurpose[_purpose];\\n    }\\n\\n    /**\\n    * @dev See {IERC735-getClaimIdsByTopic}.\\n    * @notice Implementation of the getClaimIdsByTopic function from the ERC-735 standard.\\n    * used to get all the claims from the specified topic\\n    * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\\n    * @return claimIds Returns an array of claim IDs by topic.\\n    */\\n    function getClaimIdsByTopic(uint256 _topic)\\n    external\\n    override\\n    view\\n    returns(bytes32[] memory claimIds)\\n    {\\n        return _claimsByTopic[_topic];\\n    }\\n\\n    /**\\n    * @notice implementation of the addKey function of the ERC-734 standard\\n    * Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes:\\n    * 1: MANAGEMENT keys, which can manage the identity\\n    * 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.)\\n    * 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable.\\n    * 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims.\\n    * MUST only be done by keys of purpose 1, or the identity itself.\\n    * If its the identity itself, the approval process will determine its approval.\\n    * @param _key keccak256 representation of an ethereum address\\n    * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\\n    * @param _purpose a uint256 specifying the key type, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\\n    * @return success Returns TRUE if the addition was successful and FALSE if not\\n    */\\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _type)\\n    public\\n    delegatedOnly\\n    onlyManager\\n    override\\n    returns (bool success)\\n    {\\n        if (_keys[_key].key == _key) {\\n            uint256[] memory _purposes = _keys[_key].purposes;\\n            for (uint keyPurposeIndex = 0; keyPurposeIndex < _purposes.length; keyPurposeIndex++) {\\n                uint256 purpose = _purposes[keyPurposeIndex];\\n\\n                if (purpose == _purpose) {\\n                    revert(\\\"Conflict: Key already has purpose\\\");\\n                }\\n            }\\n\\n            _keys[_key].purposes.push(_purpose);\\n        } else {\\n            _keys[_key].key = _key;\\n            _keys[_key].purposes = [_purpose];\\n            _keys[_key].keyType = _type;\\n        }\\n\\n        _keysByPurpose[_purpose].push(_key);\\n\\n        emit KeyAdded(_key, _purpose, _type);\\n\\n        return true;\\n    }\\n\\n    /**\\n     *  @dev See {IERC734-approve}.\\n     *  @notice Approves an execution.\\n     *  If the sender is an ACTION key and the destination address is not the identity contract itself, then the\\n     *  approval is authorized and the operation would be performed.\\n     *  If the destination address is the identity itself, then the execution would be authorized and performed only\\n     *  if the sender is a MANAGEMENT key.\\n     */\\n    function approve(uint256 _id, bool _approve)\\n    public\\n    delegatedOnly\\n    override\\n    returns (bool success)\\n    {\\n        require(_id < _executionNonce, \\\"Cannot approve a non-existing execution\\\");\\n        require(!_executions[_id].executed, \\\"Request already executed\\\");\\n\\n        if(_executions[_id].to == address(this)) {\\n            require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 1), \\\"Sender does not have management key\\\");\\n        }\\n        else {\\n            require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), \\\"Sender does not have action key\\\");\\n        }\\n\\n        emit Approved(_id, _approve);\\n\\n        if (_approve == true) {\\n            _executions[_id].approved = true;\\n\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (success,) = _executions[_id].to.call{value:(_executions[_id].value)}(_executions[_id].data);\\n\\n            if (success) {\\n                _executions[_id].executed = true;\\n\\n                emit Executed(\\n                    _id,\\n                    _executions[_id].to,\\n                    _executions[_id].value,\\n                    _executions[_id].data\\n                );\\n\\n                return true;\\n            } else {\\n                emit ExecutionFailed(\\n                    _id,\\n                    _executions[_id].to,\\n                    _executions[_id].value,\\n                    _executions[_id].data\\n                );\\n\\n                return false;\\n            }\\n        } else {\\n            _executions[_id].approved = false;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n    * @dev See {IERC734-removeKey}.\\n    * @notice Remove the purpose from a key.\\n    */\\n    function removeKey(bytes32 _key, uint256 _purpose)\\n    public\\n    delegatedOnly\\n    onlyManager\\n    override\\n    returns (bool success)\\n    {\\n        require(_keys[_key].key == _key, \\\"NonExisting: Key isn't registered\\\");\\n        uint256[] memory _purposes = _keys[_key].purposes;\\n\\n        uint purposeIndex = 0;\\n        while (_purposes[purposeIndex] != _purpose) {\\n            purposeIndex++;\\n\\n            if (purposeIndex == _purposes.length) {\\n                revert(\\\"NonExisting: Key doesn't have such purpose\\\");\\n            }\\n        }\\n\\n        _purposes[purposeIndex] = _purposes[_purposes.length - 1];\\n        _keys[_key].purposes = _purposes;\\n        _keys[_key].purposes.pop();\\n\\n        uint keyIndex = 0;\\n        uint arrayLength = _keysByPurpose[_purpose].length;\\n\\n        while (_keysByPurpose[_purpose][keyIndex] != _key) {\\n            keyIndex++;\\n\\n            if (keyIndex >= arrayLength) {\\n                break;\\n            }\\n        }\\n\\n        _keysByPurpose[_purpose][keyIndex] = _keysByPurpose[_purpose][arrayLength - 1];\\n        _keysByPurpose[_purpose].pop();\\n\\n        uint keyType = _keys[_key].keyType;\\n\\n        if (_purposes.length - 1 == 0) {\\n            delete _keys[_key];\\n        }\\n\\n        emit KeyRemoved(_key, _purpose, keyType);\\n\\n        return true;\\n    }\\n\\n    /**\\n    * @dev See {IERC735-addClaim}.\\n    * @notice Implementation of the addClaim function from the ERC-735 standard\\n    *  Require that the msg.sender has claim signer key.\\n    *\\n    * @param _topic The type of claim\\n    * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.\\n    * @param _issuer The issuers identity contract address, or the address used to sign the above signature.\\n    * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity.\\n    * it MUST be a signed message of the following structure:\\n    * keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))\\n    * @param _data The hash of the claim data, sitting in another\\n    * location, a bit-mask, call data, or actual data based on the claim scheme.\\n    * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\\n    *\\n    * @return claimRequestId Returns claimRequestId: COULD be\\n    * send to the approve function, to approve or reject this claim.\\n    * triggers ClaimAdded event.\\n    */\\n    function addClaim(\\n        uint256 _topic,\\n        uint256 _scheme,\\n        address _issuer,\\n        bytes memory _signature,\\n        bytes memory _data,\\n        string memory _uri\\n    )\\n    public\\n    delegatedOnly\\n    onlyClaimKey\\n    override\\n    returns (bytes32 claimRequestId)\\n    {\\n        if (_issuer != address(this)) {\\n            require(IClaimIssuer(_issuer).isClaimValid(IIdentity(address(this)), _topic, _signature, _data), \\\"invalid claim\\\");\\n        }\\n\\n        bytes32 claimId = keccak256(abi.encode(_issuer, _topic));\\n        _claims[claimId].topic = _topic;\\n        _claims[claimId].scheme = _scheme;\\n        _claims[claimId].signature = _signature;\\n        _claims[claimId].data = _data;\\n        _claims[claimId].uri = _uri;\\n\\n        if (_claims[claimId].issuer != _issuer) {\\n            _claimsByTopic[_topic].push(claimId);\\n            _claims[claimId].issuer = _issuer;\\n\\n            emit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\\n        }\\n        else {\\n            emit ClaimChanged(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\\n        }\\n        return claimId;\\n    }\\n\\n    /**\\n    * @dev See {IERC735-removeClaim}.\\n    * @notice Implementation of the removeClaim function from the ERC-735 standard\\n    * Require that the msg.sender has management key.\\n    * Can only be removed by the claim issuer, or the claim holder itself.\\n    *\\n    * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\\n    *\\n    * @return success Returns TRUE when the claim was removed.\\n    * triggers ClaimRemoved event\\n    */\\n    function removeClaim(bytes32 _claimId)\\n    public\\n    delegatedOnly\\n    onlyClaimKey\\n    override\\n    returns\\n    (bool success) {\\n        uint256 _topic = _claims[_claimId].topic;\\n        if (_topic == 0) {\\n            revert(\\\"NonExisting: There is no claim with this ID\\\");\\n        }\\n\\n        uint claimIndex = 0;\\n        uint arrayLength = _claimsByTopic[_topic].length;\\n        while (_claimsByTopic[_topic][claimIndex] != _claimId) {\\n            claimIndex++;\\n\\n            if (claimIndex >= arrayLength) {\\n                break;\\n            }\\n        }\\n\\n        _claimsByTopic[_topic][claimIndex] =\\n        _claimsByTopic[_topic][arrayLength - 1];\\n        _claimsByTopic[_topic].pop();\\n\\n        emit ClaimRemoved(\\n            _claimId,\\n            _topic,\\n            _claims[_claimId].scheme,\\n            _claims[_claimId].issuer,\\n            _claims[_claimId].signature,\\n            _claims[_claimId].data,\\n            _claims[_claimId].uri\\n        );\\n\\n        delete _claims[_claimId];\\n\\n        return true;\\n    }\\n\\n    /**\\n    * @dev See {IERC735-getClaim}.\\n    * @notice Implementation of the getClaim function from the ERC-735 standard.\\n    *\\n    * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\\n    *\\n    * @return topic Returns all the parameters of the claim for the\\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n    * @return scheme Returns all the parameters of the claim for the\\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n    * @return issuer Returns all the parameters of the claim for the\\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n    * @return signature Returns all the parameters of the claim for the\\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n    * @return data Returns all the parameters of the claim for the\\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n    * @return uri Returns all the parameters of the claim for the\\n    * specified _claimId (topic, scheme, signature, issuer, data, uri) .\\n    */\\n    function getClaim(bytes32 _claimId)\\n    public\\n    override\\n    view\\n    returns(\\n        uint256 topic,\\n        uint256 scheme,\\n        address issuer,\\n        bytes memory signature,\\n        bytes memory data,\\n        string memory uri\\n    )\\n    {\\n        return (\\n        _claims[_claimId].topic,\\n        _claims[_claimId].scheme,\\n        _claims[_claimId].issuer,\\n        _claims[_claimId].signature,\\n        _claims[_claimId].data,\\n        _claims[_claimId].uri\\n        );\\n    }\\n\\n    /**\\n    * @dev See {IERC734-keyHasPurpose}.\\n    * @notice Returns true if the key has MANAGEMENT purpose or the specified purpose.\\n    */\\n    function keyHasPurpose(bytes32 _key, uint256 _purpose)\\n    public\\n    override\\n    view\\n    returns(bool result)\\n    {\\n        Key memory key = _keys[_key];\\n        if (key.key == 0) return false;\\n\\n        for (uint keyPurposeIndex = 0; keyPurposeIndex < key.purposes.length; keyPurposeIndex++) {\\n            uint256 purpose = key.purposes[keyPurposeIndex];\\n\\n            if (purpose == 1 || purpose == _purpose) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @dev Checks if a claim is valid. Claims issued by the identity are self-attested claims. They do not have a\\n     * built-in revocation mechanism and are considered valid as long as their signature is valid and they are still\\n     * stored by the identity contract.\\n     * @param _identity the identity contract related to the claim\\n     * @param claimTopic the claim topic of the claim\\n     * @param sig the signature of the claim\\n     * @param data the data field of the claim\\n     * @return claimValid true if the claim is valid, false otherwise\\n     */\\n    function isClaimValid(\\n        IIdentity _identity,\\n        uint256 claimTopic,\\n        bytes memory sig,\\n        bytes memory data)\\n    public override virtual view returns (bool claimValid)\\n    {\\n        bytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\\n        // Use abi.encodePacked to concatenate the message prefix and the message to sign.\\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", dataHash));\\n\\n        // Recover address of data signer\\n        address recovered = getRecoveredAddress(sig, prefixedHash);\\n\\n        // Take hash of recovered address\\n        bytes32 hashedAddr = keccak256(abi.encode(recovered));\\n\\n        // Does the trusted identifier have they key which signed the user's claim?\\n        //  && (isClaimRevoked(_claimId) == false)\\n        if (keyHasPurpose(hashedAddr, 3)) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @dev returns the address that signed the given data\\n     * @param sig the signature of the data\\n     * @param dataHash the data that was signed\\n     * returns the address that signed dataHash and created the signature sig\\n     */\\n    function getRecoveredAddress(bytes memory sig, bytes32 dataHash)\\n    public\\n    pure\\n    returns (address addr)\\n    {\\n        bytes32 ra;\\n        bytes32 sa;\\n        uint8 va;\\n\\n        // Check the signature length\\n        if (sig.length != 65) {\\n            return address(0);\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            ra := mload(add(sig, 32))\\n            sa := mload(add(sig, 64))\\n            va := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        if (va < 27) {\\n            va += 27;\\n        }\\n\\n        address recoveredAddress = ecrecover(dataHash, va, ra, sa);\\n\\n        return (recoveredAddress);\\n    }\\n\\n    /**\\n     * @notice Initializer internal function for the Identity contract.\\n     *\\n     * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __Identity_init(address initialManagementKey) internal {\\n        require(!_initialized || _isConstructor(), \\\"Initial key was already setup.\\\");\\n        _initialized = true;\\n        _canInteract = true;\\n\\n        bytes32 _key = keccak256(abi.encode(initialManagementKey));\\n        _keys[_key].key = _key;\\n        _keys[_key].purposes = [1];\\n        _keys[_key].keyType = 1;\\n        _keysByPurpose[1].push(_key);\\n        emit KeyAdded(_key, 1, 1);\\n    }\\n\\n    /**\\n     * @notice Computes if the context in which the function is called is a constructor or not.\\n     *\\n     * @return true if the context is a constructor.\\n     */\\n    function _isConstructor() private view returns (bool) {\\n        address self = address(this);\\n        uint256 cs;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { cs := extcodesize(self) }\\n        return cs == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/interface/IClaimIssuer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"./IIdentity.sol\\\";\\n\\ninterface IClaimIssuer is IIdentity {\\n\\n    /**\\n     * @dev Emitted when a claim is revoked.\\n     *\\n     * Specification: MUST be triggered when revoking a claim.\\n     */\\n    event ClaimRevoked(bytes indexed signature);\\n\\n    /**\\n     * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\\n     * @notice will fetch the claim from the identity contract (unsafe).\\n     * @param _claimId the id of the claim\\n     * @param _identity the address of the identity contract\\n     * @return isRevoked true when the claim is revoked\\n     */\\n    function revokeClaim(bytes32 _claimId, address _identity) external returns(bool);\\n\\n    /**\\n     * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\\n     * @param signature the signature of the claim\\n     */\\n    function revokeClaimBySignature(bytes calldata signature) external;\\n\\n    /**\\n     * @dev Returns revocation status of a claim.\\n     * @param _sig the signature of the claim\\n     * @return isRevoked true if the claim is revoked and false otherwise\\n     */\\n    function isClaimRevoked(bytes calldata _sig) external view returns (bool);\\n\\n    /**\\n     * @dev Checks if a claim is valid.\\n     * @param _identity the identity contract related to the claim\\n     * @param claimTopic the claim topic of the claim\\n     * @param sig the signature of the claim\\n     * @param data the data field of the claim\\n     * @return claimValid true if the claim is valid, false otherwise\\n     */\\n    function isClaimValid(\\n        IIdentity _identity,\\n        uint256 claimTopic,\\n        bytes calldata sig,\\n        bytes calldata data)\\n    external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/interface/IERC734.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\\n */\\ninterface IERC734 {\\n\\n    /**\\n     * @dev Emitted when an execution request was approved.\\n     *\\n     * Specification: MUST be triggered when approve was successfully called.\\n     */\\n    event Approved(uint256 indexed executionId, bool approved);\\n\\n    /**\\n     * @dev Emitted when an execute operation was approved and successfully performed.\\n     *\\n     * Specification: MUST be triggered when approve was called and the execution was successfully approved.\\n     */\\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n\\n    /**\\n     * @dev Emitted when an execution request was performed via `execute`.\\n     *\\n     * Specification: MUST be triggered when execute was successfully called.\\n     */\\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n\\n    /**\\n     * @dev Emitted when an execute operation was called and failed\\n     *\\n     * Specification: MUST be triggered when execute call failed\\n     */\\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n\\n    /**\\n     * @dev Emitted when a key was added to the Identity.\\n     *\\n     * Specification: MUST be triggered when addKey was successfully called.\\n     */\\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\\n\\n    /**\\n     * @dev Emitted when a key was removed from the Identity.\\n     *\\n     * Specification: MUST be triggered when removeKey was successfully called.\\n     */\\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\\n\\n    /**\\n     * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\\n     *\\n     * Triggers Event: `KeyAdded`\\n     *\\n     * Specification: MUST only be done by keys of purpose 1, or the identity\\n     * itself. If it's the identity itself, the approval process will determine its approval.\\n     */\\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\\n\\n    /**\\n    * @dev Approves an execution.\\n    *\\n    * Triggers Event: `Approved`\\n    * Triggers on execution successful Event: `Executed`\\n    * Triggers on execution failure Event: `ExecutionFailed`\\n    */\\n    function approve(uint256 _id, bool _approve) external returns (bool success);\\n\\n    /**\\n     * @dev Removes _purpose for _key from the identity.\\n     *\\n     * Triggers Event: `KeyRemoved`\\n     *\\n     * Specification: MUST only be done by keys of purpose 1, or the identity itself.\\n     * If it's the identity itself, the approval process will determine its approval.\\n     */\\n    function removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\\n\\n    /**\\n     * @dev Passes an execution instruction to an ERC734 identity.\\n     * How the execution is handled is up to the identity implementation:\\n     * An execution COULD be requested and require `approve` to be called with one or more keys of purpose 1 or 2 to\\n     * approve this execution.\\n     * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\\n     *\\n     * Triggers Event: ExecutionRequested\\n     * Triggers on direct execution Event: Executed\\n     */\\n    function execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\\n\\n    /**\\n     * @dev Returns the full key data, if present in the identity.\\n     */\\n    function getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\\n\\n    /**\\n     * @dev Returns the list of purposes associated with a key.\\n     */\\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory _purposes);\\n\\n    /**\\n     * @dev Returns an array of public key bytes32 held by this identity.\\n     */\\n    function getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\\n\\n    /**\\n     * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\\n     */\\n    function keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/interface/IERC735.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\\n */\\ninterface IERC735 {\\n\\n    /**\\n     * @dev Emitted when a claim was added.\\n     *\\n     * Specification: MUST be triggered when a claim was successfully added.\\n     */\\n    event ClaimAdded(\\n        bytes32 indexed claimId,\\n        uint256 indexed topic,\\n        uint256 scheme,\\n        address indexed issuer,\\n        bytes signature,\\n        bytes data,\\n        string uri);\\n\\n    /**\\n     * @dev Emitted when a claim was removed.\\n     *\\n     * Specification: MUST be triggered when removeClaim was successfully called.\\n     */\\n    event ClaimRemoved(\\n        bytes32 indexed claimId,\\n        uint256 indexed topic,\\n        uint256 scheme,\\n        address indexed issuer,\\n        bytes signature,\\n        bytes data,\\n        string uri);\\n\\n    /**\\n     * @dev Emitted when a claim was changed.\\n     *\\n     * Specification: MUST be triggered when addClaim was successfully called on an existing claimId.\\n     */\\n    event ClaimChanged(\\n        bytes32 indexed claimId,\\n        uint256 indexed topic,\\n        uint256 scheme,\\n        address indexed issuer,\\n        bytes signature,\\n        bytes data,\\n        string uri);\\n\\n    /**\\n     * @dev Add or update a claim.\\n     *\\n     * Triggers Event: `ClaimAdded`, `ClaimChanged`\\n     *\\n     * Specification: Add or update a claim from an issuer.\\n     *\\n     * _signature is a signed message of the following structure:\\n     * `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\\n     */\\n    function addClaim(\\n        uint256 _topic,\\n        uint256 _scheme,\\n        address issuer,\\n        bytes calldata _signature,\\n        bytes calldata _data,\\n        string calldata _uri)\\n    external returns (bytes32 claimRequestId);\\n\\n    /**\\n     * @dev Removes a claim.\\n     *\\n     * Triggers Event: `ClaimRemoved`\\n     *\\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\\n     */\\n    function removeClaim(bytes32 _claimId) external returns (bool success);\\n\\n    /**\\n     * @dev Get a claim by its ID.\\n     *\\n     * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\\n     */\\n    function getClaim(bytes32 _claimId)\\n    external view returns(\\n        uint256 topic,\\n        uint256 scheme,\\n        address issuer,\\n        bytes memory signature,\\n        bytes memory data,\\n        string memory uri);\\n\\n    /**\\n     * @dev Returns an array of claim IDs by topic.\\n     */\\n    function getClaimIdsByTopic(uint256 _topic) external view returns(bytes32[] memory claimIds);\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/interface/IIdentity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC734.sol\\\";\\nimport \\\"./IERC735.sol\\\";\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface IIdentity is IERC734, IERC735 {\\n    /**\\n     * @dev Checks if a claim is valid.\\n     * @param _identity the identity contract related to the claim\\n     * @param claimTopic the claim topic of the claim\\n     * @param sig the signature of the claim\\n     * @param data the data field of the claim\\n     * @return claimValid true if the claim is valid, false otherwise\\n     */\\n    function isClaimValid(\\n        IIdentity _identity,\\n        uint256 claimTopic,\\n        bytes calldata sig,\\n        bytes calldata data)\\n    external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/storage/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\nimport \\\"./Structs.sol\\\";\\n\\ncontract Storage is Structs {\\n    // nonce used by the execute/approve function\\n    uint256 internal _executionNonce;\\n\\n    // keys as defined by IERC734\\n    mapping(bytes32 => Key) internal _keys;\\n\\n    // keys for a given purpose\\n    // purpose 1 = MANAGEMENT\\n    // purpose 2 = ACTION\\n    // purpose 3 = CLAIM\\n    mapping(uint256 => bytes32[]) internal _keysByPurpose;\\n\\n    // execution data\\n    mapping(uint256 => Execution) internal _executions;\\n\\n    // claims held by the ONCHAINID\\n    mapping(bytes32 => Claim) internal _claims;\\n\\n    // array of claims for a given topic\\n    mapping(uint256 => bytes32[]) internal _claimsByTopic;\\n\\n    // status on initialization\\n    bool internal _initialized = false;\\n\\n    // status on potential interactions with the contract\\n    bool internal _canInteract = false;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/storage/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\ncontract Structs {\\n\\n   /**\\n    *  @dev Definition of the structure of a Key.\\n    *\\n    *  Specification: Keys are cryptographic public keys, or contract addresses associated with this identity.\\n    *  The structure should be as follows:\\n    *  key: A public key owned by this identity\\n    *  purposes: uint256[] Array of the key purposes, like 1 = MANAGEMENT, 2 = EXECUTION\\n    *  keyType: The type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\\n    *  key: bytes32 The public key. // Its the Keccak256 hash of the key\\n    */\\n    struct Key {\\n        uint256[] purposes;\\n        uint256 keyType;\\n        bytes32 key;\\n    }\\n\\n    /**\\n    *  @dev Definition of the structure of an Execution\\n    *\\n    *  Specification: Executions are requests for transactions to be issued by the ONCHAINID\\n    *  to: address of contract to interact with, can be address(this)\\n    *  value: ETH to transfer with the transaction\\n    *  data: payload of the transaction to execute\\n    *  approved: approval status of the Execution\\n    *  executed: execution status of the Execution (set as false when the Execution is created\\n    *  and updated to true when the Execution is processed)\\n    */\\n    struct Execution {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        bool approved;\\n        bool executed;\\n    }\\n\\n   /**\\n    *  @dev Definition of the structure of a Claim.\\n    *\\n    *  Specification: Claims are information an issuer has about the identity holder.\\n    *  The structure should be as follows:\\n    *  claim: A claim published for the Identity.\\n    *  topic: A uint256 number which represents the topic of the claim. (e.g. 1 biometric, 2 residence (ToBeDefined:\\n    *  number schemes, sub topics based on number ranges??))\\n    *  scheme : The scheme with which this claim SHOULD be verified or how it should be processed. Its a uint256 for\\n    *  different schemes. E.g. could 3 mean contract verification, where the data will be call data, and the issuer a\\n    *  contract address to call (ToBeDefined). Those can also mean different key types e.g. 1 = ECDSA, 2 = RSA, etc.\\n    *  (ToBeDefined)\\n    *  issuer: The issuers identity contract address, or the address used to sign the above signature. If an\\n    *  identity contract, it should hold the key with which the above message was signed, if the key is not present\\n    *  anymore, the claim SHOULD be treated as invalid. The issuer can also be a contract address itself, at which the\\n    *  claim can be verified using the call data.\\n    *  signature: Signature which is the proof that the claim issuer issued a claim of topic for this identity. it\\n    *  MUST be a signed message of the following structure: `keccak256(abi.encode(identityHolder_address, topic, data))`\\n    *  data: The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on\\n    *  the claim scheme.\\n    *  uri: The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\\n    */\\n    struct Claim {\\n        uint256 topic;\\n        uint256 scheme;\\n        address issuer;\\n        bytes signature;\\n        bytes data;\\n        string uri;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/version/Version.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Version contract gives the versioning information of the implementation contract\\n */\\ncontract Version {\\n    /**\\n     * @dev Returns the string of the current version.\\n     */\\n    function version() external pure returns (string memory) {\\n        // version 2.2.0\\n        return \\\"2.2.0\\\";\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialManagementKey\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isLibrary\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"claimId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"topic\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scheme\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"ClaimAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"claimId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"topic\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scheme\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"ClaimChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"claimId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"topic\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scheme\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"ClaimRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExecutionFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ExecutionRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"purpose\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keyType\",\"type\":\"uint256\"}],\"name\":\"KeyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"purpose\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"keyType\",\"type\":\"uint256\"}],\"name\":\"KeyRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_topic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_scheme\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_issuer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"addClaim\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"claimRequestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_purpose\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"addKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approve\",\"type\":\"bool\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"executionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_claimId\",\"type\":\"bytes32\"}],\"name\":\"getClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"topic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheme\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_topic\",\"type\":\"uint256\"}],\"name\":\"getClaimIdsByTopic\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"claimIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getKey\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"purposes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"keyType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getKeyPurposes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_purposes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_purpose\",\"type\":\"uint256\"}],\"name\":\"getKeysByPurpose\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"keys\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"getRecoveredAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialManagementKey\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IIdentity\",\"name\":\"_identity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"claimTopic\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"isClaimValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"claimValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_purpose\",\"type\":\"uint256\"}],\"name\":\"keyHasPurpose\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_claimId\",\"type\":\"bytes32\"}],\"name\":\"removeClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_key\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_purpose\",\"type\":\"uint256\"}],\"name\":\"removeKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Identity", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000dead0000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}