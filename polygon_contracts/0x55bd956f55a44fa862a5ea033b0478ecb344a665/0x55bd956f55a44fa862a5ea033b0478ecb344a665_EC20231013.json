{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n    function mint(address _to, uint256 _value) external returns (bool);\r\n    function burn(uint256 _value) external returns (bool);\r\n}\r\n\r\ncontract EC20231013 {\r\n\r\n    address public owner;\r\n    address public verifier;\r\n    address private challengeSigner;\r\n\r\n    // Constants\r\n    bytes32 constant VERIFIER_FEE_RATE = keccak256('VERIFIER_FEE_RATE');\r\n    bytes32 constant TIMEOUT_PENALTY_RATE = keccak256('TIMEOUT_PENALTY_RATE');\r\n    bytes32 constant DECLINE_PENALTY_RATE = keccak256('DECLINE_PENALTY_RATE');\r\n    bytes32 constant FAILED_PENALTY_RATE = keccak256('FAILED_PENALTY_RATE');\r\n    bytes32 constant DEPOSIT_RATE = keccak256('DEPOSIT_RATE');\r\n    bytes32 constant MAX_SLOT_FUEL_PER_NODE = keccak256('MAX_SLOT_FUEL_PER_NODE');\r\n    bytes32 constant CHALLENGE_SIGNER = keccak256('CHALLENGE_SIGNER');\r\n    bytes32 constant DEFAULT_PROGRAM_ID = keccak256('DEFAULT_PROGRAM_ID');\r\n    uint256 constant REQUESTED = 1;\r\n    uint256 constant PROCESSING = 2;\r\n    uint256 constant SUBMITTED = 3;\r\n    uint256 constant VERIFIED = 4;\r\n    uint256 constant CANCELED = 5;\r\n    uint256 constant TIMEOUT = 6;\r\n    uint256 constant FAILED = 7;\r\n    uint256 constant DECLINED = 8;\r\n\r\n    // Paramters\r\n    mapping(bytes32 => uint256) private PARAMETERS;\r\n\r\n    // EMT (Constants)\r\n    IERC20 immutable public emtToken;\r\n    uint256 immutable public startSlot;\r\n    uint256 constant BASE_SLOT_REWARD = 12000 * 24 * 1e18; // 12,000 EMT x 24\r\n    uint256 constant SLOT_INTERVAL = 24 hours;\r\n    uint256 constant DECREMENT_PERIOD = 365 days;\r\n    uint256 constant DECREMENT_RATE = 600 * 1e18; // 600 EMT\r\n\r\n    // Slots\r\n    mapping (uint256 => uint256) private slotTotalFuel; // (slotNumber => totalFuel)\r\n    mapping (uint256 => mapping(address => uint256)) public slotFuel; // (slotNumber => (nodeAddress => reward))\r\n    mapping (uint256 => mapping(address => uint256)) public slotBalances; // (slotNumber => (nodeAddress => reward))\r\n    mapping (address => uint256) public lastJobAssigned;\r\n\r\n    // Jobs\r\n    mapping(bytes16 => Job) public jobs;\r\n    mapping(bytes16 => JobDetail) public jobDetails;\r\n    mapping(bytes16 => JobAssign) public jobAssigns;\r\n    mapping(bytes16 => bytes16[]) public jobChildren;\r\n\r\n    // Programs\r\n    mapping(uint256 => Program) public programs;\r\n\r\n    // Events\r\n    event Status(bytes16 indexed jobId, address sender, uint256 status);\r\n\r\n    // Structs\r\n    struct Job {\r\n        bool exist;\r\n        bytes16 jobId;\r\n        bytes16 parentJob;\r\n        address owner;\r\n        uint256 deadline;\r\n        uint256 fuelLimit;\r\n        uint256 fuelPrice;\r\n        uint256 status; //0: requested, 1: assigned, 2: processing, 3: completed, 4: canceled\r\n        uint256 requestedAt;\r\n    }\r\n\r\n    struct JobDetail {\r\n        uint256 programId;\r\n        uint256 numParallel;\r\n        uint256 numEpoch;\r\n        string param;\r\n        string dataset;\r\n        string result;\r\n    }\r\n\r\n    struct JobAssign {\r\n        address node;\r\n        uint256 deposit;\r\n        uint256 fuelUsed;\r\n        uint256 startedAt;\r\n        uint256 submittedAt;\r\n        uint256 verifiedAt;\r\n        uint256 slot;\r\n    }\r\n\r\n    struct Program {\r\n        uint256 programId;\r\n        string programName;\r\n        uint256 intensity;\r\n        uint256 minFuelPrice;\r\n        uint256 cooldownPeriod;\r\n        uint256 defaultFuelLimit;\r\n        uint256 defaultFuelPrice;\r\n        uint256 minTarget;\r\n    }\r\n\r\n    // Modifiers\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'insufficient privilege');\r\n        _;\r\n    }\r\n\r\n    modifier onlyVerifier() {\r\n        require(msg.sender == verifier, \"Verifiable: msg.sender does not have the Verifier role\");\r\n        _;\r\n    }\r\n\r\n    function transferOwner(address _addr) external onlyOwner {\r\n        owner = _addr;\r\n    }\r\n\r\n    function transferVerifier(address _addr) external onlyVerifier {\r\n        verifier = _addr;\r\n    }\r\n\r\n    function setChallengeSigner(address _addr) external onlyOwner {\r\n        challengeSigner = _addr;\r\n    }\r\n\r\n    // Constructor\r\n    constructor(address _tokenAddress) {\r\n        owner = msg.sender;\r\n        verifier = msg.sender;\r\n        emtToken= IERC20(_tokenAddress);\r\n        startSlot = block.timestamp / SLOT_INTERVAL;\r\n\r\n        // Parameters\r\n        PARAMETERS[keccak256('TIMEOUT_PENALTY_RATE')] = 25000; // 25% of fee\r\n        PARAMETERS[keccak256('DECLINE_PENALTY_RATE')] = 25000; // 25% of fee\r\n        PARAMETERS[keccak256('FAILED_PENALTY_RATE')] = 25000; // 25% of fee\r\n        PARAMETERS[keccak256('DEPOSIT_RATE')] = 0; // Initially 0%, then 100% of fee\r\n        PARAMETERS[keccak256('VERIFIER_FEE_RATE')] = 0; // Initially 0%, then 5% of fee\r\n        PARAMETERS[keccak256('MAX_SLOT_FUEL_PER_NODE')] = 10000000000;\r\n        PARAMETERS[keccak256('MIN_TARGET')] = 16**60-1;\r\n        PARAMETERS[keccak256('DEFAULT_PROGRAM_ID')] = 84;\r\n    }\r\n\r\n    // Functions for Requester\r\n    function request(\r\n        bytes16 _jobId,\r\n        uint256 _programId,\r\n        bytes16 _parentJob,\r\n        uint256 _numParallel,\r\n        uint256 _numEpoch,\r\n        string calldata _dataset,\r\n        string calldata _param,\r\n        uint256 _fuelLimit,\r\n        uint256 _fuelPrice,\r\n        uint256 _deadline\r\n    ) external returns (bool) {\r\n        _request(_jobId, _programId, _parentJob, _numParallel, _numEpoch, _dataset, _param, _fuelLimit, _fuelPrice, _deadline);\r\n        return true;\r\n    }\r\n\r\n    function cancel(bytes16 _jobId) external returns (bool) {\r\n        Job storage job = jobs[_jobId];\r\n\r\n        require(job.exist, \"EmethCore: job doesn't exist\");\r\n        require(job.status == REQUESTED, \"Job is already being processed or canceled\");\r\n        require(jobs[_jobId].owner == msg.sender, \"EmethCore: job is not requested by your node\");\r\n\r\n        job.status = CANCELED;\r\n\r\n        uint256 feeLimit = job.fuelLimit * job.fuelPrice;\r\n        uint256 verifierFee = feeLimit * PARAMETERS[VERIFIER_FEE_RATE] / 100000;\r\n        uint256 feeTotal = feeLimit + verifierFee;\r\n        if (feeTotal > 0) emtToken.transfer(msg.sender, feeTotal);\r\n\r\n        emit Status(_jobId, msg.sender, CANCELED);\r\n        return true;\r\n    }\r\n\r\n    // Functions for Node \r\n    function process(bytes16 _jobId) external returns (bool) {\r\n        if (!jobs[_jobId].exist) _request(_jobId, 0, bytes16(0), 1, 1, \"\", \"\", 0, 0, block.timestamp);\r\n\r\n        Job storage job = jobs[_jobId];\r\n        JobDetail memory jobDetail = jobDetails[_jobId];\r\n        JobAssign storage jobAssign = jobAssigns[_jobId];\r\n\r\n        require(job.status == REQUESTED);\r\n        require(lastJobAssigned[msg.sender] + programs[jobDetail.programId].cooldownPeriod < block.timestamp, \"EmethCore: need wait for cooldown\");\r\n\r\n        uint256 feeLimit = job.fuelLimit * job.fuelPrice;\r\n        uint256 verifierFee = feeLimit * PARAMETERS[VERIFIER_FEE_RATE] / 100000;\r\n        uint256 deposit = feeLimit * PARAMETERS[DEPOSIT_RATE] / 100000;\r\n        require(emtToken.balanceOf(msg.sender) >= deposit, \"EmethCore: insufficient balance for deposit\");\r\n        require(emtToken.allowance(msg.sender, address(this)) >= deposit, \"EmethCore: insufficient allowance for deposit\");\r\n        if (deposit + verifierFee > 0) emtToken.transferFrom(msg.sender, address(this), deposit + verifierFee);\r\n\r\n        job.status = PROCESSING;\r\n        jobAssign.node = msg.sender;\r\n        jobAssign.deposit = deposit + verifierFee;\r\n        jobAssign.startedAt = block.timestamp;\r\n        lastJobAssigned[jobAssign.node] = jobAssign.startedAt;\r\n\r\n        emit Status(_jobId, msg.sender, PROCESSING);\r\n        return true;\r\n    }\r\n\r\n    function decline(bytes16 _jobId) external returns (bool) {\r\n        Job storage job = jobs[_jobId];\r\n        JobAssign storage jobAssign = jobAssigns[_jobId];\r\n\r\n\r\n        require(job.exist, \"EmethCore: job doesn't exist\");\r\n        require(job.status == PROCESSING, \"EmethCore: job is not being processed\");\r\n        require(jobAssigns[_jobId].node == msg.sender, \"EmethCore: job is not assigned to your node\");\r\n\r\n        job.status = DECLINED;\r\n\r\n        // Fee Refund\r\n        uint256 feeLimit = job.fuelLimit * job.fuelPrice;\r\n        uint256 verifierFee = feeLimit * PARAMETERS[VERIFIER_FEE_RATE] / 100000;\r\n        uint256 feeTotal = feeLimit + verifierFee;\r\n        if (feeTotal > 0) emtToken.transfer(job.owner, feeTotal);\r\n\r\n        // Deposit Refund with Penalty\r\n        uint256 penalty = feeLimit * PARAMETERS[DECLINE_PENALTY_RATE] / 100000;\r\n        if(penalty < jobAssign.deposit) {\r\n            emtToken.transfer(msg.sender, jobAssign.deposit - penalty);\r\n            emtToken.burn(penalty);\r\n        }\r\n\r\n        emit Status(_jobId, msg.sender, DECLINED);\r\n        return true;\r\n    }\r\n\r\n    function submit(bytes16 _jobId, string calldata _result, uint256 _fuelUsed) external returns (bool) {\r\n        _submit(_jobId, _result, _fuelUsed, msg.sender, 0);\r\n        return true;\r\n    }\r\n\r\n    function deligatedSubmit(bytes16 _jobId, string calldata _result, uint256 _fuelUsed, address _node) external returns (bool) {\r\n        _submit(_jobId, _result, _fuelUsed, _node, 0);\r\n        return true;\r\n    }\r\n\r\n    function directSubmit(bytes16 _jobId, string calldata _result, uint256 _fuelUsed, uint256 _programId) external returns (bool) {\r\n        _submit(_jobId, _result, _fuelUsed, msg.sender, _programId);\r\n        return true;\r\n    }\r\n\r\n    function _submit(bytes16 _jobId, string calldata _result, uint256 _fuelUsed, address _sender, uint256 _programId) internal returns (bool) {\r\n        Job storage job = jobs[_jobId];\r\n        JobDetail storage jobDetail = jobDetails[_jobId];\r\n        JobAssign storage jobAssign = jobAssigns[_jobId];\r\n\r\n        if (job.exist) {\r\n            require(jobAssign.node == _sender, \"EmethCore: job is not assigned to your node\");\r\n            require(job.status == PROCESSING, \"EmethCore: job is not being processed\");\r\n            require(job.fuelLimit >= _fuelUsed, \"EmethCore: fuelUsed exceeds fuelLimit\");\r\n\r\n            job.status = SUBMITTED;\r\n            jobDetail.result = _result;\r\n            jobAssign.fuelUsed = _fuelUsed;\r\n            jobAssign.submittedAt = block.timestamp;\r\n\r\n            emit Status(_jobId, _sender, SUBMITTED);\r\n        } else {\r\n            if (_programId == 0) _programId = PARAMETERS[DEFAULT_PROGRAM_ID];\r\n            Program memory program = programs[_programId];\r\n    \r\n            // Split _result into (challenge, nonce)\r\n            string memory challengeStr = subString(_result, 0, 130);\r\n            bytes memory challenge = str2Bytes(challengeStr);\r\n          \r\n            // Verify recover(_jobId, challenge) == requestSigner\r\n            {\r\n            bytes32 jobId32 = bytes32(_jobId) >> 128;\r\n            address signer = recover(jobId32, challenge);\r\n            require(signer == challengeSigner, \"EmethCore: invalid challenge\");\r\n            }\r\n\r\n            // Verify sha256(challenge + nonce) < difficulty\r\n            {\r\n            bytes memory resultBytes = str2Bytes(_result);\r\n            bytes32 hash = sha256(resultBytes);\r\n            require(uint256(hash) <= program.minTarget, \"EmethCore: invalid nonce\");\r\n            }\r\n\r\n            // Requirement\r\n            require(!jobs[_jobId].exist, \"EmethCore: The jobId already exists\");\r\n            require(program.defaultFuelLimit > 0, \"EmethCore: Invalid programId\");\r\n            require(lastJobAssigned[_sender] + program.cooldownPeriod < block.timestamp, \"EmethCore: need wait for cooldown\");\r\n\r\n            // Request\r\n            _request(_jobId, 0, bytes16(0), 1, 1, challengeStr, \"\", 0, 0, block.timestamp);\r\n\r\n            // Process\r\n            {\r\n            jobAssign.node = _sender;\r\n            jobAssign.startedAt = block.timestamp;\r\n            lastJobAssigned[_sender] = block.timestamp;\r\n            emit Status(_jobId, _sender, PROCESSING);\r\n            }\r\n            // Submit\r\n            jobDetail.result = _result;\r\n            jobAssign.fuelUsed = job.fuelLimit;\r\n            jobAssign.submittedAt = block.timestamp;\r\n            emit Status(_jobId, _sender, SUBMITTED);\r\n\r\n            // Verify\r\n            job.status = VERIFIED;\r\n            jobAssign.verifiedAt = block.timestamp;\r\n            jobAssign.slot = _putSlotReward(_jobId);\r\n            emtToken.mint(_sender, job.fuelLimit);\r\n            emit Status(_jobId, verifier, VERIFIED);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdrawSlotReward(address _node, uint256 _slot) external returns (bool) {\r\n        require(_slot < block.timestamp / SLOT_INTERVAL, \"The slot has not been closed\");\r\n        require(slotBalances[_slot][_node] > 0, \"The slot reward is empty\");\r\n\r\n        uint256 reward = _slotReward(_slot) * slotBalances[_slot][_node] / slotTotalFuel[_slot];\r\n        emtToken.mint(_node, reward);\r\n\r\n        slotBalances[_slot][_node] = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdrawSlotRewardInRange(address _node, uint256 _startSlot, uint256 _endSlot) external returns (bool) {\r\n        require(_startSlot <= _endSlot, \"endSlot should be later than startSlot\");\r\n        require(_endSlot < block.timestamp / SLOT_INTERVAL, \"The slot has not been closed\");\r\n\r\n        uint256 totalReward = 0;\r\n        for(uint256 slot = _startSlot; slot <= _endSlot; slot++) {\r\n            totalReward += _slotReward(slot) * slotBalances[slot][_node] / slotTotalFuel[slot];\r\n            slotBalances[slot][_node] = 0;\r\n        }\r\n\r\n        emtToken.mint(_node, totalReward);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Functions for Verifier\r\n    function verify(bytes16 _jobId) external onlyVerifier returns (bool) {\r\n        Job storage job = jobs[_jobId];\r\n        JobAssign storage jobAssign = jobAssigns[_jobId];\r\n\r\n        require(job.exist, \"EmethCore: job doesn't exist\");\r\n        require(job.status == SUBMITTED, \"EmethCore: job result is not submitted\");\r\n\r\n        job.status = VERIFIED;\r\n\r\n        // Put in Reward Slot\r\n        jobAssign.slot = _putSlotReward(_jobId);\r\n\r\n        // Return Deposit\r\n        emtToken.transfer(jobAssign.node, jobAssign.deposit);\r\n\r\n        // Distribute Fee\r\n        uint256 feeLimit = job.fuelLimit * job.fuelPrice;\r\n        uint256 verifierFee = feeLimit * PARAMETERS[VERIFIER_FEE_RATE] / 100000;\r\n        uint256 feeUsed = jobAssign.fuelUsed * job.fuelPrice;\r\n        uint256 refund = feeLimit - feeUsed;\r\n        if (feeUsed > 0) emtToken.transfer(jobAssign.node, feeUsed);\r\n        if (refund > 0) emtToken.transfer(job.owner, refund);\r\n\r\n        // Verifier Fee\r\n        if (verifierFee > 0) emtToken.transfer(verifier, verifierFee);\r\n\r\n        emit Status(_jobId, msg.sender, VERIFIED);\r\n        return true;\r\n    }\r\n\r\n    function timeout(bytes16 _jobId) external onlyVerifier returns (bool) {\r\n        Job storage job = jobs[_jobId];\r\n        JobAssign storage jobAssign = jobAssigns[_jobId];\r\n\r\n        require(job.exist, \"EmethCore: job doesn't exist\");\r\n        require(job.status == PROCESSING || job.status == REQUESTED, \"EmethCore: job is not in requested or processing status\");\r\n        require(job.deadline <= block.timestamp, \"EmethCore: still earlier than the deadline\");\r\n       \r\n        job.status = TIMEOUT;\r\n\r\n        // Tx Fee Refund\r\n        uint256 feeLimit = jobAssign.fuelUsed * job.fuelPrice;\r\n        uint256 verifierFee = feeLimit * PARAMETERS[VERIFIER_FEE_RATE] / 100000;\r\n        uint256 feeTotal = feeLimit + verifierFee;\r\n        if (feeTotal > 0) emtToken.transfer(job.owner, feeTotal);\r\n\r\n        // Deposit Refund with Penalty\r\n        if(job.status == PROCESSING) {\r\n            uint256 penalty = feeLimit * PARAMETERS[TIMEOUT_PENALTY_RATE] / 100000;\r\n            if(penalty < jobAssign.deposit) {\r\n                emtToken.transfer(jobAssign.node, jobAssign.deposit - penalty);\r\n                emtToken.burn(penalty);\r\n            }\r\n        }\r\n\r\n        emit Status(_jobId, msg.sender, TIMEOUT);\r\n        return true;\r\n    }\r\n\r\n    function rejectResult(bytes16 _jobId) external onlyVerifier returns (bool) {\r\n        Job storage job = jobs[_jobId];\r\n        JobAssign storage jobAssign = jobAssigns[_jobId];\r\n\r\n        require(job.exist, \"EmethCore: job doesn't exist\");\r\n        require(jobs[_jobId].status == SUBMITTED, \"EmethCore: job result is not submitted\");\r\n\r\n        job.status = FAILED;\r\n\r\n        // Tx Fee Refund\r\n        uint256 feeLimit = jobAssign.fuelUsed * job.fuelPrice;\r\n        uint256 verifierFee = feeLimit * PARAMETERS[VERIFIER_FEE_RATE] / 100000;\r\n        uint256 feeTotal = feeLimit + verifierFee;\r\n        if (feeTotal > 0) emtToken.transfer(job.owner, feeTotal);\r\n\r\n        // Deposit Refund with Penalty\r\n        uint256 penalty = feeLimit * PARAMETERS[FAILED_PENALTY_RATE] / 100000;\r\n        if(penalty < jobAssign.deposit) {\r\n            emtToken.transfer(jobAssign.node, jobAssign.deposit - verifierFee - penalty);\r\n            emtToken.burn(penalty);\r\n        }\r\n\r\n        // Verifier Fee\r\n        if (verifierFee > 0) emtToken.transfer(verifier, verifierFee);\r\n\r\n        emit Status(_jobId, msg.sender, FAILED);\r\n        return true;\r\n    }\r\n\r\n    // Admin\r\n    function setProgram(\r\n        uint256 _programId,\r\n        string memory _programName,\r\n        uint256 _intensity,\r\n        uint256 _minFuelPrice,\r\n        uint256 _cooldownPeriod,\r\n        uint256 _defaultFeeLimit,\r\n        uint256 _defaultFeePrice,\r\n        uint256 _minTarget) external onlyOwner returns (bool) {\r\n        programs[_programId] = Program(_programId, _programName, _intensity, _minFuelPrice, _cooldownPeriod, _defaultFeeLimit, _defaultFeePrice, _minTarget);\r\n        return true;\r\n    }\r\n\r\n    function setParameter(bytes32 _parameter, uint256 _value) external onlyOwner returns (bool) {\r\n        PARAMETERS[_parameter] = _value;\r\n        return true;\r\n    }\r\n\r\n    function setMinTargetByDifficulty(uint256 _programId, uint256 _difficulty) external onlyOwner returns (bool) {\r\n        programs[_programId].minTarget = (2**256 - 1) / _difficulty;\r\n        return true;\r\n    }\r\n\r\n    // Utilities\r\n    function getParameter(string memory _name) external view returns (uint256) {\r\n        return PARAMETERS[keccak256(bytes(_name))];\r\n    }\r\n    function getEstimatedFuel(uint256 _datasetSizeMB, uint256 _intensity) external pure returns (uint256) {\r\n        return _datasetSizeMB * _intensity / 1000;\r\n    }\r\n\r\n    function currentSlotReward() external view returns (uint256) {\r\n        return _slotReward(currentSlot());\r\n    }\r\n\r\n    function currentSlot() public view returns (uint256) {\r\n        return block.timestamp / SLOT_INTERVAL;\r\n    }\r\n\r\n    function slots(uint256 _slot) external view returns (uint256 _totalFuel, uint256 _totalReward) {\r\n        return (slotTotalFuel[_slot], _slotReward(_slot));\r\n    }\r\n\r\n    function slotRewards(uint256 _slot, address _node) external view returns (uint256 _fuel, uint256 _balance, uint256 _reward) {\r\n        uint256 reward = _slotReward(_slot) * slotBalances[_slot][_node] / slotTotalFuel[_slot];\r\n        return (slotFuel[_slot][_node], slotBalances[_slot][_node], reward);\r\n    }\r\n\r\n    // Private\r\n    function _putSlotReward(bytes16 _jobId) private returns (uint256) {\r\n        JobAssign storage jobAssign = jobAssigns[_jobId];\r\n        address node = jobAssigns[_jobId].node;\r\n        uint256 slot = block.timestamp / SLOT_INTERVAL;\r\n\r\n        uint256 fuelCounted = jobAssign.fuelUsed;\r\n        if(slotFuel[slot][node] + jobAssign.fuelUsed >= PARAMETERS[MAX_SLOT_FUEL_PER_NODE]) {\r\n            fuelCounted = PARAMETERS[MAX_SLOT_FUEL_PER_NODE] - slotFuel[slot][node];\r\n        }\r\n\r\n        slotTotalFuel[slot] = slotTotalFuel[slot] + fuelCounted;\r\n        slotFuel[slot][node] = slotFuel[slot][node] + fuelCounted;\r\n        slotBalances[slot][node] = slotBalances[slot][node] + fuelCounted;\r\n\r\n        return slot;\r\n    }\r\n\r\n    function _slotReward(uint256 _slot) private view returns (uint256) {\r\n        uint256 reward = 0;\r\n        uint256 halvingAmount = (_slot - startSlot) / (DECREMENT_PERIOD / SLOT_INTERVAL) * DECREMENT_RATE;\r\n        if(BASE_SLOT_REWARD > halvingAmount) {\r\n            reward = BASE_SLOT_REWARD - halvingAmount;\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    function _request(\r\n        bytes16 _jobId,\r\n        uint256 _programId,\r\n        bytes16 _parentJob,\r\n        uint256 _numParallel,\r\n        uint256 _numEpoch,\r\n        string memory _dataset,\r\n        string memory _param,\r\n        uint256 _fuelLimit,\r\n        uint256 _fuelPrice,\r\n        uint256 _deadline\r\n    ) private returns (bool) {\r\n        address jobOwner = msg.sender;\r\n        uint256 programId = _programId;\r\n        require(!jobs[_jobId].exist, \"EmethCore: Job ID already exists\");\r\n\r\n        if (_programId == 0) {\r\n            jobOwner = challengeSigner;\r\n            programId = PARAMETERS[DEFAULT_PROGRAM_ID];\r\n            Program memory program = programs[programId];\r\n            require(program.defaultFuelLimit > 0, \"EmethCore: no defualt program exists\");\r\n            _fuelLimit = program.defaultFuelLimit;\r\n            _fuelPrice = 0;\r\n        }\r\n\r\n        require(_fuelPrice >= programs[programId].minFuelPrice, \"EmethCore: fuelPrice too low\");\r\n\r\n        {\r\n          uint256 feeLimit = _fuelLimit * _fuelPrice;\r\n          uint256 feeTotal = feeLimit + (feeLimit * PARAMETERS[VERIFIER_FEE_RATE] / 100000);\r\n          if (_programId != 0) {\r\n            require(emtToken.balanceOf(msg.sender) >= feeTotal, \"EmethCore: insufficient balance for feeTotal\");\r\n            require(emtToken.allowance(msg.sender, address(this)) >= feeTotal, \"EmethCore: insufficient allowance for feeTotal\");\r\n            if (feeTotal > 0) emtToken.transferFrom(msg.sender, address(this), feeTotal);\r\n          }\r\n        }\r\n\r\n        jobs[_jobId] = Job({\r\n            exist: true,\r\n            jobId: _jobId,\r\n            parentJob: _parentJob,\r\n            owner: jobOwner,\r\n            deadline: _deadline,\r\n            fuelLimit: _fuelLimit,\r\n            fuelPrice: _fuelPrice,\r\n            status: REQUESTED,\r\n            requestedAt: block.timestamp\r\n        });\r\n\r\n        jobDetails[_jobId] = JobDetail({\r\n            programId: programId,\r\n            numParallel: _numParallel,\r\n            numEpoch: _numEpoch,\r\n            param: _param,\r\n            dataset: _dataset,\r\n            result: \"\"\r\n        });\r\n\r\n        jobAssigns[_jobId] = JobAssign({\r\n            node: address(0),\r\n            deposit: 0,\r\n            fuelUsed: 0,\r\n            startedAt: 0,\r\n            submittedAt: 0,\r\n            verifiedAt: 0,\r\n            slot: 0\r\n        });\r\n\r\n        //jobIndexes.push(_jobId);\r\n        if(_parentJob != bytes16(0)) jobChildren[_parentJob].push(_jobId);\r\n\r\n        emit Status(_jobId, jobOwner, REQUESTED);\r\n        return true;\r\n    }\r\n\r\n    // Library\r\n    function char2Int(uint8 c) internal pure returns (uint8) {\r\n        if (bytes1(c) >= bytes1('0') && bytes1(c) <= bytes1('9')) return c - uint8(bytes1('0'));\r\n        if (bytes1(c) >= bytes1('a') && bytes1(c) <= bytes1('f')) return 10 + c - uint8(bytes1('a'));\r\n        if (bytes1(c) >= bytes1('A') && bytes1(c) <= bytes1('F')) return 10 + c - uint8(bytes1('A'));\r\n        revert(\"Failed to convert str to bytes\");\r\n    }\r\n\r\n    function str2Bytes(string memory s) internal pure returns (bytes memory) {\r\n        bytes memory ss = bytes(s);\r\n        require(ss.length % 2 == 0, \"Length must be even\");\r\n        bytes memory r = new bytes(ss.length / 2);\r\n        for (uint256 i = 0; i < ss.length / 2; ++i) {\r\n            r[i] = bytes1(char2Int(uint8(ss[2*i])) * 16 + char2Int(uint8(ss[2*i+1])));\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function bytes2string(bytes memory _bytes) internal pure returns (string memory) {\r\n        bytes memory converted = new bytes(_bytes.length * 2);\r\n        bytes memory _base = \"0123456789abcdef\";\r\n\r\n        for (uint256 i = 0; i < _bytes.length; i++) {\r\n            converted[i * 2] = _base[uint8(_bytes[i]) / _base.length];\r\n            converted[i * 2 + 1] = _base[uint8(_bytes[i]) % _base.length];\r\n        }\r\n        return string(abi.encodePacked(\"0x\", converted));\r\n    }\r\n\r\n    function subString(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(str);\r\n        bytes memory result = new bytes(endIndex - startIndex);\r\n        for(uint i = startIndex; i < endIndex; i++) {\r\n            result[i - startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes memory sig) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        //Check the signature length\r\n        if (sig.length != 65) {\r\n        return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n            bytes32 prefixedHashMessage = keccak256(abi.encodePacked(prefix, hash));\r\n            return ecrecover(prefixedHashMessage, v, r, s);\r\n        }\r\n    }\r\n\r\n    // Debug\r\n    Last public lastValue;\r\n    struct Last {\r\n        bytes challenge;\r\n        address signer;\r\n        bytes32 hash;\r\n    }\r\n\r\n    // Test\r\n    function submitTest(bytes16 _jobId, string calldata _result, uint256 _fuelUsed) external returns (bool) {\r\n        address _sender = msg.sender;\r\n        Job storage job = jobs[_jobId];\r\n        JobDetail storage jobDetail = jobDetails[_jobId];\r\n        JobAssign storage jobAssign = jobAssigns[_jobId];\r\n\r\n        if (job.exist) {\r\n            require(jobAssign.node == _sender, \"EmethCore: job is not assigned to your node\");\r\n            require(job.status == PROCESSING, \"EmethCore: job is not being processed\");\r\n            require(job.fuelLimit >= _fuelUsed, \"EmethCore: fuelUsed exceeds fuelLimit\");\r\n\r\n            //job.status = SUBMITTED;\r\n            //jobDetail.result = _result;\r\n            //jobAssign.fuelUsed = _fuelUsed;\r\n            //jobAssign.submittedAt = block.timestamp;\r\n\r\n            //emit Status(_jobId, _sender, SUBMITTED);\r\n        } else {\r\n            Program memory program = programs[PARAMETERS[DEFAULT_PROGRAM_ID]];\r\n            bytes memory resultBytes = str2Bytes(_result);\r\n    \r\n            // Split _result into (challenge, nonce)\r\n            string memory challengeStr = subString(_result, 0, 130);\r\n            bytes memory challenge = str2Bytes(challengeStr);\r\n            lastValue.challenge = challenge;\r\n          \r\n            // Verify recover(_jobId, challenge) == requestSigner\r\n            {\r\n            bytes32 jobId32 = bytes32(_jobId) >> 128;\r\n            address signer = recover(jobId32, challenge);\r\n            lastValue.signer = signer;\r\n            }\r\n\r\n            // Verify sha256(challenge + nonce) < difficulty\r\n            bytes32 hash = sha256(resultBytes);\r\n            lastValue.hash = hash;\r\n\r\n            // Requirement\r\n            require(!jobs[_jobId].exist, \"EmethCore: The jobId already exists\");\r\n            require(program.defaultFuelLimit > 0, \"EmethCore: Invalid programId\");\r\n            require(lastJobAssigned[_sender] + program.cooldownPeriod < block.timestamp, \"EmethCore: need wait for cooldown\");\r\n\r\n            // Request\r\n            //_request(_jobId, 0, bytes16(0), 1, 1, challengeStr, \"\", 0, 0, block.timestamp);\r\n\r\n            // Process\r\n            //jobAssign.node = _sender;\r\n            //jobAssign.startedAt = block.timestamp;\r\n            //lastJobAssigned[_sender] = block.timestamp;\r\n            //emit Status(_jobId, _sender, PROCESSING);\r\n\r\n            // Submit\r\n            //jobDetail.result = _result;\r\n            //jobAssign.fuelUsed = job.fuelLimit;\r\n            //jobAssign.submittedAt = block.timestamp;\r\n            //emit Status(_jobId, _sender, SUBMITTED);\r\n\r\n            // Verify\r\n            //job.status = VERIFIED;\r\n            //jobAssign.verifiedAt = block.timestamp;\r\n            //jobAssign.slot = _putSlotReward(_jobId);\r\n            //emtToken.mint(_sender, job.fuelLimit);\r\n            //emit Status(_jobId, verifier, VERIFIED);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"jobId\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"Status\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSlotReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"}],\"name\":\"decline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"internalType\":\"string\",\"name\":\"_result\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_fuelUsed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_node\",\"type\":\"address\"}],\"name\":\"deligatedSubmit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"internalType\":\"string\",\"name\":\"_result\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_fuelUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_programId\",\"type\":\"uint256\"}],\"name\":\"directSubmit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_datasetSizeMB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_intensity\",\"type\":\"uint256\"}],\"name\":\"getEstimatedFuel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getParameter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"jobAssigns\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fuelUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"submittedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verifiedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"jobChildren\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"jobDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"programId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numParallel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numEpoch\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"param\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"dataset\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"jobs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exist\",\"type\":\"bool\"},{\"internalType\":\"bytes16\",\"name\":\"jobId\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"parentJob\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fuelLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fuelPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastJobAssigned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastValue\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"challenge\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"}],\"name\":\"process\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"programs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"programId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"programName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"intensity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFuelPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defaultFuelLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defaultFuelPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTarget\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"}],\"name\":\"rejectResult\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"_programId\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"_parentJob\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"_numParallel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numEpoch\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_dataset\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_param\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_fuelLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fuelPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"request\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setChallengeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_programId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_difficulty\",\"type\":\"uint256\"}],\"name\":\"setMinTargetByDifficulty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_parameter\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setParameter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_programId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_programName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_intensity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minFuelPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cooldownPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_defaultFeeLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_defaultFeePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTarget\",\"type\":\"uint256\"}],\"name\":\"setProgram\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"slotBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"slotFuel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_node\",\"type\":\"address\"}],\"name\":\"slotRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_fuel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slot\",\"type\":\"uint256\"}],\"name\":\"slots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalFuel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"internalType\":\"string\",\"name\":\"_result\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_fuelUsed\",\"type\":\"uint256\"}],\"name\":\"submit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"},{\"internalType\":\"string\",\"name\":\"_result\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_fuelUsed\",\"type\":\"uint256\"}],\"name\":\"submitTest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"}],\"name\":\"timeout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"transferVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_jobId\",\"type\":\"bytes16\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_node\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_slot\",\"type\":\"uint256\"}],\"name\":\"withdrawSlotReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_node\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endSlot\",\"type\":\"uint256\"}],\"name\":\"withdrawSlotRewardInRange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EC20231013", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000aa2b7bbef0d8331b6bfe6ffa770c510f54aa95e5", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e830ef8a5a66305b4cfe04325de3edfbbbbf116b68f9eb29b29276e36809491e"}