{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2023-01-20\r\n*/\r\n\r\n// Sources flattened with hardhat v2.12.2 https://hardhat.org\r\n\r\n// File contracts/proxy/Proxy.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\r\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\r\n * be specified by overriding the virtual {_implementation} function.\r\n *\r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n *\r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n\t/**\r\n\t * @dev Delegates the current call to `implementation`.\r\n\t *\r\n\t * This function does not return to its internal call site, it will return directly to the external caller.\r\n\t */\r\n\tfunction _delegate(address implementation) internal virtual {\r\n\t\tassembly {\r\n\t\t\t// Copy msg.data. We take full control of memory in this inline assembly\r\n\t\t\t// block because it will not return to Solidity code. We overwrite the\r\n\t\t\t// Solidity scratch pad at memory position 0.\r\n\t\t\tcalldatacopy(0, 0, calldatasize())\r\n\r\n\t\t\t// Call the implementation.\r\n\t\t\t// out and outsize are 0 because we don't know the size yet.\r\n\t\t\tlet result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n\t\t\t// Copy the returned data.\r\n\t\t\treturndatacopy(0, 0, returndatasize())\r\n\r\n\t\t\tswitch result\r\n\t\t\t// delegatecall returns 0 on error.\r\n\t\t\tcase 0 {\r\n\t\t\t\trevert(0, returndatasize())\r\n\t\t\t}\r\n\t\t\tdefault {\r\n\t\t\t\treturn(0, returndatasize())\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\r\n\t * and {_fallback} should delegate.\r\n\t */\r\n\tfunction _implementation() internal view virtual returns (address);\r\n\r\n\t/**\r\n\t * @dev Delegates the current call to the address returned by `_implementation()`.\r\n\t *\r\n\t * This function does not return to its internal call site, it will return directly to the external caller.\r\n\t */\r\n\tfunction _fallback() internal virtual {\r\n\t\t_beforeFallback();\r\n\t\t_delegate(_implementation());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n\t * function in the contract matches the call data.\r\n\t */\r\n\tfallback() external payable virtual {\r\n\t\t_fallback();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n\t * is empty.\r\n\t */\r\n\treceive() external payable virtual {\r\n\t\t_fallback();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\r\n\t * call, or as part of the Solidity `fallback` or `receive` functions.\r\n\t *\r\n\t * If overridden should call `super._beforeFallback()`.\r\n\t */\r\n\tfunction _beforeFallback() internal virtual {}\r\n}\r\n\r\n// File contracts/proxy/beacon/IBeacon.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\r\n */\r\ninterface IBeacon {\r\n\t/**\r\n\t * @dev Must return an address that can be used as a delegate call target.\r\n\t *\r\n\t * {BeaconProxy} will check that this address is a contract.\r\n\t */\r\n\tfunction implementation() external view returns (address);\r\n}\r\n\r\n// File contracts/utils/StorageSlot.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\r\n */\r\nlibrary StorageSlot {\r\n\tstruct AddressSlot {\r\n\t\taddress value;\r\n\t}\r\n\r\n\tstruct BooleanSlot {\r\n\t\tbool value;\r\n\t}\r\n\r\n\tstruct Bytes32Slot {\r\n\t\tbytes32 value;\r\n\t}\r\n\r\n\tstruct Uint256Slot {\r\n\t\tuint256 value;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n\t */\r\n\tfunction getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tr.slot := slot\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n\t */\r\n\tfunction getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tr.slot := slot\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n\t */\r\n\tfunction getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tr.slot := slot\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n\t */\r\n\tfunction getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n\t\t/// @solidity memory-safe-assembly\r\n\t\tassembly {\r\n\t\t\tr.slot := slot\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File contracts/interfaces/draft-IERC1822.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\r\n * proxy whose upgrades are fully controlled by the current implementation.\r\n */\r\ninterface IERC1822Proxiable {\r\n\t/**\r\n\t * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\r\n\t * address.\r\n\t *\r\n\t * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\r\n\t * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\r\n\t * function revert if invoked through a proxy.\r\n\t */\r\n\tfunction proxiableUUID() external view returns (bytes32);\r\n}\r\n\r\n// File contracts/utils/Address.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n\t/**\r\n\t * @dev Returns true if `account` is a contract.\r\n\t *\r\n\t * [IMPORTANT]\r\n\t * ====\r\n\t * It is unsafe to assume that an address for which this function returns\r\n\t * false is an externally-owned account (EOA) and not a contract.\r\n\t *\r\n\t * Among others, `isContract` will return false for the following\r\n\t * types of addresses:\r\n\t *\r\n\t *  - an externally-owned account\r\n\t *  - a contract in construction\r\n\t *  - an address where a contract will be created\r\n\t *  - an address where a contract lived, but was destroyed\r\n\t * ====\r\n\t *\r\n\t * [IMPORTANT]\r\n\t * ====\r\n\t * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n\t *\r\n\t * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n\t * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n\t * constructor.\r\n\t * ====\r\n\t */\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\t// This method relies on extcodesize/address.code.length, which returns 0\r\n\t\t// for contracts in construction, since the code is only stored at the end\r\n\t\t// of the constructor execution.\r\n\r\n\t\treturn account.code.length > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n\t * `recipient`, forwarding all available gas and reverting on errors.\r\n\t *\r\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n\t * imposed by `transfer`, making them unable to receive funds via\r\n\t * `transfer`. {sendValue} removes this limitation.\r\n\t *\r\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n\t *\r\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\r\n\t * taken to not create reentrancy vulnerabilities. Consider using\r\n\t * {ReentrancyGuard} or the\r\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n\t */\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\t\t(bool success, ) = recipient.call{ value: amount }(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Performs a Solidity function call using a low level `call`. A\r\n\t * plain `call` is an unsafe replacement for a function call: use this\r\n\t * function instead.\r\n\t *\r\n\t * If `target` reverts with a revert reason, it is bubbled up by this\r\n\t * function (like regular Solidity function calls).\r\n\t *\r\n\t * Returns the raw returned data. To convert to the expected return value,\r\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `target` must be a contract.\r\n\t * - calling `target` with `data` must not revert.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but also transferring `value` wei to `target`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the calling contract must have an ETH balance of at least `value`.\r\n\t * - the called Solidity function must be `payable`.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value\r\n\t) internal returns (bytes memory) {\r\n\t\treturn\r\n\t\t\tfunctionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\t(bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n\t\treturn verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(\r\n\t\taddress target,\r\n\t\tbytes memory data\r\n\t) internal view returns (bytes memory) {\r\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal view returns (bytes memory) {\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(\r\n\t\taddress target,\r\n\t\tbytes memory data\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n\t * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n\t *\r\n\t * _Available since v4.8._\r\n\t */\r\n\tfunction verifyCallResultFromTarget(\r\n\t\taddress target,\r\n\t\tbool success,\r\n\t\tbytes memory returndata,\r\n\t\tstring memory errorMessage\r\n\t) internal view returns (bytes memory) {\r\n\t\tif (success) {\r\n\t\t\tif (returndata.length == 0) {\r\n\t\t\t\t// only check isContract if the call was successful and the return data is empty\r\n\t\t\t\t// otherwise we already know that it was a contract\r\n\t\t\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\t\t\t}\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t_revert(returndata, errorMessage);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n\t * revert reason or using the provided one.\r\n\t *\r\n\t * _Available since v4.3._\r\n\t */\r\n\tfunction verifyCallResult(\r\n\t\tbool success,\r\n\t\tbytes memory returndata,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (bytes memory) {\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t_revert(returndata, errorMessage);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n\t\t// Look for revert reason and bubble it up if present\r\n\t\tif (returndata.length > 0) {\r\n\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\trevert(errorMessage);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File contracts/proxy/ERC1967/ERC1967Upgrade.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n/**\r\n * @dev This abstract contract provides getters and event emitting update functions for\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\r\n *\r\n * _Available since v4.1._\r\n *\r\n * @custom:oz-upgrades-unsafe-allow delegatecall\r\n */\r\nabstract contract ERC1967Upgrade {\r\n\t// This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\r\n\tbytes32 private constant _ROLLBACK_SLOT =\r\n\t\t0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n\r\n\t/**\r\n\t * @dev Storage slot with the address of the current implementation.\r\n\t * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n\t * validated in the constructor.\r\n\t */\r\n\tbytes32 internal constant _IMPLEMENTATION_SLOT =\r\n\t\t0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n\t/**\r\n\t * @dev Emitted when the implementation is upgraded.\r\n\t */\r\n\tevent Upgraded(address indexed implementation);\r\n\r\n\t/**\r\n\t * @dev Returns the current implementation address.\r\n\t */\r\n\tfunction _getImplementation() internal view returns (address) {\r\n\t\treturn StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stores a new address in the EIP1967 implementation slot.\r\n\t */\r\n\tfunction _setImplementation(address newImplementation) private {\r\n\t\trequire(\r\n\t\t\tAddress.isContract(newImplementation),\r\n\t\t\t\"ERC1967: new implementation is not a contract\"\r\n\t\t);\r\n\t\tStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Perform implementation upgrade\r\n\t *\r\n\t * Emits an {Upgraded} event.\r\n\t */\r\n\tfunction _upgradeTo(address newImplementation) internal {\r\n\t\t_setImplementation(newImplementation);\r\n\t\temit Upgraded(newImplementation);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Perform implementation upgrade with additional setup call.\r\n\t *\r\n\t * Emits an {Upgraded} event.\r\n\t */\r\n\tfunction _upgradeToAndCall(\r\n\t\taddress newImplementation,\r\n\t\tbytes memory data,\r\n\t\tbool forceCall\r\n\t) internal {\r\n\t\t_upgradeTo(newImplementation);\r\n\t\tif (data.length > 0 || forceCall) {\r\n\t\t\tAddress.functionDelegateCall(newImplementation, data);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\r\n\t *\r\n\t * Emits an {Upgraded} event.\r\n\t */\r\n\tfunction _upgradeToAndCallUUPS(\r\n\t\taddress newImplementation,\r\n\t\tbytes memory data,\r\n\t\tbool forceCall\r\n\t) internal {\r\n\t\t// Upgrades from old implementations will perform a rollback test. This test requires the new\r\n\t\t// implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\r\n\t\t// this special case will break upgrade paths from old UUPS implementation to new ones.\r\n\t\tif (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\r\n\t\t\t_setImplementation(newImplementation);\r\n\t\t} else {\r\n\t\t\ttry IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\r\n\t\t\t\trequire(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\r\n\t\t\t} catch {\r\n\t\t\t\trevert(\"ERC1967Upgrade: new implementation is not UUPS\");\r\n\t\t\t}\r\n\t\t\t_upgradeToAndCall(newImplementation, data, forceCall);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Storage slot with the admin of the contract.\r\n\t * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n\t * validated in the constructor.\r\n\t */\r\n\tbytes32 internal constant _ADMIN_SLOT =\r\n\t\t0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n\t/**\r\n\t * @dev Emitted when the admin account has changed.\r\n\t */\r\n\tevent AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n\t/**\r\n\t * @dev Returns the current admin.\r\n\t */\r\n\tfunction _getAdmin() internal view returns (address) {\r\n\t\treturn StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stores a new address in the EIP1967 admin slot.\r\n\t */\r\n\tfunction _setAdmin(address newAdmin) private {\r\n\t\trequire(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\r\n\t\tStorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Changes the admin of the proxy.\r\n\t *\r\n\t * Emits an {AdminChanged} event.\r\n\t */\r\n\tfunction _changeAdmin(address newAdmin) internal {\r\n\t\temit AdminChanged(_getAdmin(), newAdmin);\r\n\t\t_setAdmin(newAdmin);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\r\n\t * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\r\n\t */\r\n\tbytes32 internal constant _BEACON_SLOT =\r\n\t\t0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\r\n\r\n\t/**\r\n\t * @dev Emitted when the beacon is upgraded.\r\n\t */\r\n\tevent BeaconUpgraded(address indexed beacon);\r\n\r\n\t/**\r\n\t * @dev Returns the current beacon.\r\n\t */\r\n\tfunction _getBeacon() internal view returns (address) {\r\n\t\treturn StorageSlot.getAddressSlot(_BEACON_SLOT).value;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Stores a new beacon in the EIP1967 beacon slot.\r\n\t */\r\n\tfunction _setBeacon(address newBeacon) private {\r\n\t\trequire(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\r\n\t\trequire(\r\n\t\t\tAddress.isContract(IBeacon(newBeacon).implementation()),\r\n\t\t\t\"ERC1967: beacon implementation is not a contract\"\r\n\t\t);\r\n\t\tStorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\r\n\t * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\r\n\t *\r\n\t * Emits a {BeaconUpgraded} event.\r\n\t */\r\n\tfunction _upgradeBeaconToAndCall(\r\n\t\taddress newBeacon,\r\n\t\tbytes memory data,\r\n\t\tbool forceCall\r\n\t) internal {\r\n\t\t_setBeacon(newBeacon);\r\n\t\temit BeaconUpgraded(newBeacon);\r\n\t\tif (data.length > 0 || forceCall) {\r\n\t\t\tAddress.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File contracts/proxy/beacon/BeaconProxy.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\r\n\r\npragma solidity 0.8.13;\r\n\r\n/**\r\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\r\n *\r\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\r\n * conflict with the storage layout of the implementation behind the proxy.\r\n *\r\n * _Available since v3.4._\r\n */\r\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\r\n\t/**\r\n\t * @dev Initializes the proxy with `beacon`.\r\n\t *\r\n\t * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\r\n\t * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\r\n\t * constructor.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `beacon` must be a contract with the interface {IBeacon}.\r\n\t */\r\n\tconstructor(address beacon, bytes memory data) payable {\r\n\t\t_upgradeBeaconToAndCall(beacon, data, false);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the current beacon address.\r\n\t */\r\n\tfunction _beacon() internal view virtual returns (address) {\r\n\t\treturn _getBeacon();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the current implementation address of the associated beacon.\r\n\t */\r\n\tfunction _implementation() internal view virtual override returns (address) {\r\n\t\treturn IBeacon(_getBeacon()).implementation();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\r\n\t *\r\n\t * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `beacon` must be a contract.\r\n\t * - The implementation returned by `beacon` must be a contract.\r\n\t */\r\n\tfunction _setBeacon(address beacon, bytes memory data) internal virtual {\r\n\t\t_upgradeBeaconToAndCall(beacon, data, false);\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BeaconProxy", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000feb1c43757ec5f3e1289636184ca4390847d9b5b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000048129fc1c00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x3a01af7e851fd16cbd7aa4e930b2b20737097481", "SwarmSource": "ipfs://3704f3bad5f13c1ee274c76efb779b0fafefa3c71d520061c69727d8dca5d17d"}