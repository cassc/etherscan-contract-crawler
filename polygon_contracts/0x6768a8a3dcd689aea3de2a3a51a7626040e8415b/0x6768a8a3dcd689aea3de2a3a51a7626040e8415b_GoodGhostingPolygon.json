{"SourceCode": "// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/aave/ILendingPoolAddressesProvider.sol\r\n\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n/**\r\n@title ILendingPoolAddressesProvider interface\r\n@notice provides the interface to fetch the LendingPoolCore address\r\n */\r\n\r\nabstract contract ILendingPoolAddressesProvider {\r\n\r\n    function getLendingPool() public virtual view returns (address);\r\n    function setLendingPoolImpl(address _pool) public virtual;\r\n    function getAddress(bytes32 id) public virtual view returns (address);\r\n\r\n    function getLendingPoolCore() public virtual view returns (address payable);\r\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public virtual;\r\n\r\n    function getLendingPoolConfigurator() public virtual view returns (address);\r\n    function setLendingPoolConfiguratorImpl(address _configurator) public virtual;\r\n\r\n    function getLendingPoolDataProvider() public virtual view returns (address);\r\n    function setLendingPoolDataProviderImpl(address _provider) public virtual;\r\n\r\n    function getLendingPoolParametersProvider() public virtual view returns (address);\r\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public virtual;\r\n\r\n    function getTokenDistributor() public virtual view returns (address);\r\n    function setTokenDistributor(address _tokenDistributor) public virtual;\r\n\r\n\r\n    function getFeeProvider() public virtual view returns (address);\r\n    function setFeeProviderImpl(address _feeProvider) public virtual;\r\n\r\n    function getLendingPoolLiquidationManager() public virtual view returns (address);\r\n    function setLendingPoolLiquidationManager(address _manager) public virtual;\r\n\r\n    function getLendingPoolManager() public virtual view returns (address);\r\n    function setLendingPoolManager(address _lendingPoolManager) public virtual;\r\n\r\n    function getPriceOracle() public virtual view returns (address);\r\n    function setPriceOracle(address _priceOracle) public virtual;\r\n\r\n    function getLendingRateOracle() public virtual view returns (address);\r\n    function setLendingRateOracle(address _lendingRateOracle) public virtual;\r\n\r\n}\r\n\r\n// File: contracts/aave/ILendingPool.sol\r\n\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\ninterface ILendingPool {\r\n    function deposit(address _reserve, uint256 _amount, address onBehalfOf, uint16 _referralCode) external;\r\n    //see: https://github.com/aave/aave-protocol/blob/1ff8418eb5c73ce233ac44bfb7541d07828b273f/contracts/tokenization/AToken.sol#L218\r\n    function withdraw(address asset, uint amount, address to) external;\r\n}\r\n\r\ninterface AaveProtocolDataProvider {\r\n    function getReserveTokensAddresses(address asset) external view returns(address, address, address);\r\n}\r\n\r\n// File: contracts/aave/AToken.sol\r\n\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\ninterface AToken {\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/aave/IncentiveController.sol\r\n\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\ninterface IncentiveController {\r\n  function getRewardsBalance(address[] calldata assets, address user) external view returns(uint256);\r\n\r\n  function claimRewards(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address to\r\n    ) external returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Pausable.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: contracts/GoodGhosting.sol\r\n\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title GoodGhosting Game Contract\r\n/// @notice Used for games deployed on Ethereum Mainnet using Aave (v2) as the underlying pool, or for games deployed on Celo using Moola (v2) as the underlying pool\r\n/// @author Francis Odisi & Viraz Malhotra\r\ncontract GoodGhosting is Ownable, Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Controls if tokens were redeemed or not from the pool\r\n    bool public redeemed;\r\n    /// @notice Stores the total amount of net interest received in the game.\r\n    uint256 public totalGameInterest;\r\n    /// @notice total principal amount\r\n    uint256 public totalGamePrincipal;\r\n    /// @notice performance fee amount allocated to the admin\r\n    uint256 public adminFeeAmount;\r\n    /// @notice controls if admin withdrew or not the performance fee.\r\n    bool public adminWithdraw;\r\n    /// @notice total amount of incentive tokens to be distributed among winners\r\n    uint256 public totalIncentiveAmount = 0;\r\n    /// @notice Controls the amount of active players in the game (ignores players that early withdraw)\r\n    uint256 public activePlayersCount = 0;\r\n\r\n    /// @notice Address of the token used for depositing into the game by players (DAI)\r\n    IERC20 public immutable daiToken;\r\n    /// @notice Address of the interest bearing token received when funds are transferred to the external pool\r\n    AToken public immutable adaiToken;\r\n    /// @notice Which Aave instance we use to swap DAI to interest bearing aDAI\r\n    ILendingPoolAddressesProvider public immutable lendingPoolAddressProvider;\r\n    /// @notice Lending pool address\r\n    ILendingPool public lendingPool;\r\n    /// @notice The amount to be paid on each segment\r\n    uint256 public immutable segmentPayment;\r\n    /// @notice The number of segments in the game (segment count)\r\n    uint256 public immutable lastSegment;\r\n    /// @notice When the game started (deployed timestamp)\r\n    uint256 public immutable firstSegmentStart;\r\n    /// @notice The time duration (in seconds) of each segment\r\n    uint256 public immutable segmentLength;\r\n    /// @notice The early withdrawal fee (percentage)\r\n    uint256 public immutable earlyWithdrawalFee;\r\n    /// @notice The performance admin fee (percentage)\r\n    uint256 public immutable customFee;\r\n    /// @notice Defines the max quantity of players allowed in the game\r\n    uint256 public immutable maxPlayersCount;\r\n    /// @notice Defines an optional token address used to provide additional incentives to users. Accepts \"0x0\" adresses when no incentive token exists.\r\n    IERC20 public immutable incentiveToken;\r\n\r\n    struct Player {\r\n        address addr;\r\n        bool withdrawn;\r\n        bool canRejoin;\r\n        uint256 mostRecentSegmentPaid;\r\n        uint256 amountPaid;\r\n    }\r\n    /// @notice Stores info about the players in the game\r\n    mapping(address => Player) public players;\r\n    /// @notice controls the amount deposited in each segment that was not yet transferred to the external underlying pool\r\n    /// @notice list of players\r\n    address[] public iterablePlayers;\r\n    /// @notice list of winners\r\n    address[] public winners;\r\n\r\n    event JoinedGame(address indexed player, uint256 amount);\r\n    event Deposit(\r\n        address indexed player,\r\n        uint256 indexed segment,\r\n        uint256 amount\r\n    );\r\n    event Withdrawal(\r\n        address indexed player,\r\n        uint256 amount,\r\n        uint256 playerReward,\r\n        uint256 playerIncentive\r\n    );\r\n    event FundsRedeemedFromExternalPool(\r\n        uint256 totalAmount,\r\n        uint256 totalGamePrincipal,\r\n        uint256 totalGameInterest,\r\n        uint256 rewards,\r\n        uint256 totalIncentiveAmount\r\n    );\r\n    event WinnersAnnouncement(address[] winners);\r\n    event EarlyWithdrawal(\r\n        address indexed player,\r\n        uint256 amount,\r\n        uint256 totalGamePrincipal\r\n    );\r\n    event AdminWithdrawal(\r\n        address indexed admin,\r\n        uint256 totalGameInterest,\r\n        uint256 adminFeeAmount,\r\n        uint256 adminIncentiveAmount\r\n    );\r\n\r\n    modifier whenGameIsCompleted() {\r\n        require(isGameCompleted(), \"Game is not completed\");\r\n        _;\r\n    }\r\n\r\n    modifier whenGameIsNotCompleted() {\r\n        require(!isGameCompleted(), \"Game is already completed\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n        Creates a new instance of GoodGhosting game\r\n        @param _inboundCurrency Smart contract address of inbound currency used for the game.\r\n        @param _lendingPoolAddressProvider Smart contract address of the lending pool adddress provider.\r\n        @param _segmentCount Number of segments in the game.\r\n        @param _segmentLength Lenght of each segment, in seconds (i.e., 180 (sec) => 3 minutes).\r\n        @param _segmentPayment Amount of tokens each player needs to contribute per segment (i.e. 10*10**18 equals to 10 DAI - note that DAI uses 18 decimal places).\r\n        @param _earlyWithdrawalFee Fee paid by users on early withdrawals (before the game completes). Used as an integer percentage (i.e., 10 represents 10%).\r\n        @param _customFee performance fee charged by admin. Used as an integer percentage (i.e., 10 represents 10%). Does not accept \"decimal\" fees like \"0.5\".\r\n        @param _dataProvider id for getting the data provider contract address 0x1 to be passed.\r\n        @param _maxPlayersCount max quantity of players allowed to join the game\r\n        @param _incentiveToken optional token address used to provide additional incentives to users. Accepts \"0x0\" adresses when no incentive token exists.\r\n     */\r\n    constructor(\r\n        IERC20 _inboundCurrency,\r\n        ILendingPoolAddressesProvider _lendingPoolAddressProvider,\r\n        uint256 _segmentCount,\r\n        uint256 _segmentLength,\r\n        uint256 _segmentPayment,\r\n        uint256 _earlyWithdrawalFee,\r\n        uint256 _customFee,\r\n        address _dataProvider,\r\n        uint256 _maxPlayersCount,\r\n        IERC20 _incentiveToken\r\n    ) public {\r\n        require(_customFee <= 20, \"_customFee must be less than or equal to 20%\");\r\n        require(_earlyWithdrawalFee <= 10, \"_earlyWithdrawalFee must be less than or equal to 10%\");\r\n        require(_earlyWithdrawalFee > 0,  \"_earlyWithdrawalFee must be greater than zero\");\r\n        require(_maxPlayersCount > 0, \"_maxPlayersCount must be greater than zero\");\r\n        require(address(_inboundCurrency) != address(0), \"invalid _inboundCurrency address\");\r\n        require(address(_lendingPoolAddressProvider) != address(0), \"invalid _lendingPoolAddressProvider address\");\r\n        require(_segmentCount > 0, \"_segmentCount must be greater than zero\");\r\n        require(_segmentLength > 0, \"_segmentLength must be greater than zero\");\r\n        require(_segmentPayment > 0, \"_segmentPayment must be greater than zero\");\r\n        require(_dataProvider != address(0), \"invalid _dataProvider address\");\r\n        // Initializes default variables\r\n        firstSegmentStart = block.timestamp; //gets current time\r\n        lastSegment = _segmentCount;\r\n        segmentLength = _segmentLength;\r\n        segmentPayment = _segmentPayment;\r\n        earlyWithdrawalFee = _earlyWithdrawalFee;\r\n        customFee = _customFee;\r\n        daiToken = _inboundCurrency;\r\n        lendingPoolAddressProvider = _lendingPoolAddressProvider;\r\n        AaveProtocolDataProvider dataProvider =\r\n            AaveProtocolDataProvider(_dataProvider);\r\n        // lending pool needs to be approved in v2 since it is the core contract in v2 and not lending pool core\r\n        lendingPool = ILendingPool(\r\n            _lendingPoolAddressProvider.getLendingPool()\r\n        );\r\n        // atoken address in v2 is fetched from data provider contract\r\n        (address adaiTokenAddress, , ) =\r\n            dataProvider.getReserveTokensAddresses(address(_inboundCurrency));\r\n        adaiToken = AToken(adaiTokenAddress);\r\n        maxPlayersCount = _maxPlayersCount;\r\n        incentiveToken = _incentiveToken;\r\n    }\r\n\r\n    /// @notice pauses the game. This function can be called only by the contract's admin.\r\n    function pause() external onlyOwner whenNotPaused {\r\n        _pause();\r\n    }\r\n\r\n    /// @notice unpauses the game. This function can be called only by the contract's admin.\r\n    function unpause() external onlyOwner whenPaused {\r\n        _unpause();\r\n    }\r\n\r\n    /// @notice Allows the admin to withdraw the performance fee, if applicable. This function can be called only by the contract's admin.\r\n    /// @dev Cannot be called before the game ends.\r\n    function adminFeeWithdraw() external virtual onlyOwner whenGameIsCompleted {\r\n        require(redeemed, \"Funds not redeemed from external pool\");\r\n        require(!adminWithdraw, \"Admin has already withdrawn\");\r\n        adminWithdraw = true;\r\n\r\n        // when there are no winners, admin will be able to withdraw the\r\n        // additional incentives sent to the pool, avoiding locking the funds.\r\n        uint256 adminIncentiveAmount = 0;\r\n        if (winners.length == 0 && totalIncentiveAmount > 0) {\r\n            adminIncentiveAmount = totalIncentiveAmount;\r\n        }\r\n\r\n        emit AdminWithdrawal(owner(), totalGameInterest, adminFeeAmount, adminIncentiveAmount);\r\n\r\n        if (adminFeeAmount > 0) {\r\n            require(\r\n                IERC20(daiToken).transfer(owner(), adminFeeAmount),\r\n                \"Fail to transfer ER20 tokens to admin\"\r\n            );\r\n        }\r\n\r\n        if (adminIncentiveAmount > 0) {\r\n            require(\r\n                IERC20(incentiveToken).transfer(owner(), adminIncentiveAmount),\r\n                \"Fail to transfer ER20 incentive tokens to admin\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Allows a player to join the game\r\n    function joinGame()\r\n        external\r\n        virtual\r\n        whenNotPaused\r\n    {\r\n        _joinGame();\r\n    }\r\n\r\n    /// @notice Allows a player to withdraws funds before the game ends. An early withdrawl fee is charged.\r\n    /// @dev Cannot be called after the game is completed.\r\n    function earlyWithdraw() external whenNotPaused whenGameIsNotCompleted {\r\n        Player storage player = players[msg.sender];\r\n        require(player.amountPaid > 0, \"Player does not exist\");\r\n        require(!player.withdrawn, \"Player has already withdrawn\");\r\n        player.withdrawn = true;\r\n        activePlayersCount = activePlayersCount.sub(1);\r\n\r\n        // In an early withdraw, users get their principal minus the earlyWithdrawalFee % defined in the constructor.\r\n        uint256 withdrawAmount =\r\n            player.amountPaid.sub(\r\n                player.amountPaid.mul(earlyWithdrawalFee).div(100)\r\n            );\r\n        // Decreases the totalGamePrincipal on earlyWithdraw\r\n        totalGamePrincipal = totalGamePrincipal.sub(player.amountPaid);\r\n        uint256 currentSegment = getCurrentSegment();\r\n\r\n        // Users that early withdraw during the first segment, are allowed to rejoin.\r\n        if (currentSegment == 0) {\r\n            player.canRejoin = true;\r\n        }\r\n\r\n        emit EarlyWithdrawal(msg.sender, withdrawAmount, totalGamePrincipal);\r\n\r\n        lendingPool.withdraw(address(daiToken), withdrawAmount, address(this));\r\n        require(\r\n            IERC20(daiToken).transfer(msg.sender, withdrawAmount),\r\n            \"Fail to transfer ERC20 tokens on early withdraw\"\r\n        );\r\n    }\r\n\r\n    /// @notice Allows player to withdraw their funds after the game ends with no loss (fee). Winners get a share of the interest earned.\r\n    function withdraw() external virtual {\r\n        Player storage player = players[msg.sender];\r\n        require(player.amountPaid > 0, \"Player does not exist\");\r\n        require(!player.withdrawn, \"Player has already withdrawn\");\r\n        player.withdrawn = true;\r\n\r\n        // First player to withdraw redeems everyone's funds\r\n        if (!redeemed) {\r\n            redeemFromExternalPool();\r\n        }\r\n\r\n        uint256 payout = player.amountPaid;\r\n        uint256 playerIncentive = 0;\r\n        if (player.mostRecentSegmentPaid == lastSegment.sub(1)) {\r\n            // Player is a winner and gets a bonus!\r\n            payout = payout.add(totalGameInterest.div(winners.length));\r\n            // If there's additional incentives, distributes them to winners\r\n            if (totalIncentiveAmount > 0) {\r\n                playerIncentive = totalIncentiveAmount.div(winners.length);\r\n            }\r\n        }\r\n        emit Withdrawal(msg.sender, payout, 0, playerIncentive);\r\n\r\n        require(\r\n            IERC20(daiToken).transfer(msg.sender, payout),\r\n            \"Fail to transfer ERC20 tokens on withdraw\"\r\n        );\r\n\r\n        if (playerIncentive > 0) {\r\n            require(\r\n                IERC20(incentiveToken).transfer(msg.sender, playerIncentive),\r\n                \"Fail to transfer ERC20 incentive tokens on withdraw\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Allows players to make deposits for the game segments, after joining the game.\r\n    function makeDeposit() external whenNotPaused {\r\n        require(\r\n            !players[msg.sender].withdrawn,\r\n            \"Player already withdraw from game\"\r\n        );\r\n        // only registered players can deposit\r\n        require(\r\n            players[msg.sender].addr == msg.sender,\r\n            \"Sender is not a player\"\r\n        );\r\n\r\n        uint256 currentSegment = getCurrentSegment();\r\n        // User can only deposit between segment 1 and segment n-1 (where n is the number of segments for the game).\r\n        // Details:\r\n        // Segment 0 is paid when user joins the game (the first deposit window).\r\n        // Last segment doesn't accept payments, because the payment window for the last\r\n        // segment happens on segment n-1 (penultimate segment).\r\n        // Any segment greater than the last segment means the game is completed, and cannot\r\n        // receive payments\r\n        require(\r\n            currentSegment > 0 && currentSegment < lastSegment,\r\n            \"Deposit available only between segment 1 and segment n-1 (penultimate)\"\r\n        );\r\n\r\n        //check if current segment is currently unpaid\r\n        require(\r\n            players[msg.sender].mostRecentSegmentPaid != currentSegment,\r\n            \"Player already paid current segment\"\r\n        );\r\n\r\n        // check if player has made payments up to the previous segment\r\n        require(\r\n            players[msg.sender].mostRecentSegmentPaid == currentSegment.sub(1),\r\n            \"Player didn't pay the previous segment - game over!\"\r\n        );\r\n\r\n        // check if this is deposit for the last segment. If yes, the player is a winner.\r\n        if (currentSegment == lastSegment.sub(1)) {\r\n            winners.push(msg.sender);\r\n        }\r\n\r\n        emit Deposit(msg.sender, currentSegment, segmentPayment);\r\n        _transferDaiToContract();\r\n    }\r\n\r\n    /// @notice gets the number of players in the game\r\n    /// @return number of players\r\n    function getNumberOfPlayers() external view returns (uint256) {\r\n        return iterablePlayers.length;\r\n    }\r\n\r\n    /// @notice Redeems funds from the external pool and updates the internal accounting controls related to the game stats.\r\n    /// @dev Can only be called after the game is completed.\r\n    function redeemFromExternalPool() public virtual whenGameIsCompleted {\r\n        require(!redeemed, \"Redeem operation already happened for the game\");\r\n        redeemed = true;\r\n        // Withdraws funds (principal + interest + rewards) from external pool\r\n        if (adaiToken.balanceOf(address(this)) > 0) {\r\n            lendingPool.withdraw(\r\n                address(daiToken),\r\n                type(uint256).max,\r\n                address(this)\r\n            );\r\n        }\r\n        uint256 totalBalance = IERC20(daiToken).balanceOf(address(this));\r\n        // If there's an incentive token address defined, sets the total incentive amount to be distributed among winners.\r\n        if (address(incentiveToken) != address(0)) {\r\n            totalIncentiveAmount = IERC20(incentiveToken).balanceOf(address(this));\r\n        }\r\n\r\n        // calculates gross interest\r\n        uint256 grossInterest = 0;\r\n\r\n        // Sanity check to avoid reverting due to overflow in the \"subtraction\" below.\r\n        // This could only happen in case Aave changes the 1:1 ratio between\r\n        // aToken vs. Token in the future (i.e., 1 aDAI is worth less than 1 DAI)\r\n        if (totalBalance > totalGamePrincipal) {\r\n            grossInterest = totalBalance.sub(totalGamePrincipal);\r\n        }\r\n        // calculates the performance/admin fee (takes a cut - the admin percentage fee - from the pool's interest).\r\n        // calculates the \"gameInterest\" (net interest) that will be split among winners in the game\r\n        uint256 _adminFeeAmount;\r\n        if (customFee > 0) {\r\n            _adminFeeAmount = (grossInterest.mul(customFee)).div(100);\r\n            totalGameInterest = grossInterest.sub(_adminFeeAmount);\r\n        } else {\r\n            _adminFeeAmount = 0;\r\n            totalGameInterest = grossInterest;\r\n        }\r\n\r\n        // when there's no winners, admin takes all the interest + rewards\r\n        if (winners.length == 0) {\r\n            adminFeeAmount = grossInterest;\r\n        } else {\r\n            adminFeeAmount = _adminFeeAmount;\r\n        }\r\n\r\n        emit FundsRedeemedFromExternalPool(\r\n            totalBalance,\r\n            totalGamePrincipal,\r\n            totalGameInterest,\r\n            0,\r\n            totalIncentiveAmount\r\n        );\r\n        emit WinnersAnnouncement(winners);\r\n    }\r\n\r\n    /// @notice Calculates the current segment of the game.\r\n    /// @return current game segment\r\n    function getCurrentSegment() public view returns (uint256) {\r\n        return block.timestamp.sub(firstSegmentStart).div(segmentLength);\r\n    }\r\n\r\n    /// @notice Checks if the game is completed or not.\r\n    /// @return \"true\" if completeted; otherwise, \"false\".\r\n    function isGameCompleted() public view returns (bool) {\r\n        // Game is completed when the current segment is greater than \"lastSegment\" of the game.\r\n        return getCurrentSegment() > lastSegment;\r\n    }\r\n\r\n    /**\r\n        @dev Manages the transfer of funds from the player to the contract, recording\r\n        the required accounting operations to control the user's position in the pool.\r\n     */\r\n    function _transferDaiToContract() internal {\r\n        require(\r\n            daiToken.allowance(msg.sender, address(this)) >= segmentPayment,\r\n            \"You need to have allowance to do transfer DAI on the smart contract\"\r\n        );\r\n\r\n        uint256 currentSegment = getCurrentSegment();\r\n        players[msg.sender].mostRecentSegmentPaid = currentSegment;\r\n        players[msg.sender].amountPaid = players[msg.sender].amountPaid.add(\r\n            segmentPayment\r\n        );\r\n        totalGamePrincipal = totalGamePrincipal.add(segmentPayment);\r\n        require(\r\n            daiToken.transferFrom(msg.sender, address(this), segmentPayment),\r\n            \"Transfer failed\"\r\n        );\r\n\r\n\r\n        // Allows the lending pool to convert DAI deposited on this contract to aDAI on lending pool\r\n        uint256 contractBalance = daiToken.balanceOf(address(this));\r\n        require(\r\n            daiToken.approve(address(lendingPool), contractBalance),\r\n            \"Fail to approve allowance to lending pool\"\r\n        );\r\n\r\n        lendingPool.deposit(address(daiToken), contractBalance, address(this), 155);\r\n    }\r\n\r\n    /// @notice Allows a player to join the game and controls\r\n    function _joinGame() internal {\r\n        require(getCurrentSegment() == 0, \"Game has already started\");\r\n        require(\r\n            players[msg.sender].addr != msg.sender ||\r\n                players[msg.sender].canRejoin,\r\n            \"Cannot join the game more than once\"\r\n        );\r\n\r\n        activePlayersCount = activePlayersCount.add(1);\r\n        require(activePlayersCount <= maxPlayersCount, \"Reached max quantity of players allowed\");\r\n\r\n        bool canRejoin = players[msg.sender].canRejoin;\r\n        Player memory newPlayer =\r\n            Player({\r\n                addr: msg.sender,\r\n                mostRecentSegmentPaid: 0,\r\n                amountPaid: 0,\r\n                withdrawn: false,\r\n                canRejoin: false\r\n            });\r\n        players[msg.sender] = newPlayer;\r\n        if (!canRejoin) {\r\n            iterablePlayers.push(msg.sender);\r\n        }\r\n        emit JoinedGame(msg.sender, segmentPayment);\r\n        _transferDaiToContract();\r\n    }\r\n}\r\n\r\n// File: contracts/GoodGhostingPolygon.sol\r\n\r\n\r\n\r\npragma solidity 0.6.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title GoodGhosting Game Contract\r\n/// @author Francis Odisi & Viraz Malhotra\r\n/// @notice Used for the games deployed on Polygon using Aave as the underlying external pool.\r\ncontract GoodGhostingPolygon is GoodGhosting {\r\n    IncentiveController public incentiveController;\r\n    IERC20 public immutable matic;\r\n    uint256 public rewardsPerPlayer;\r\n\r\n    /**\r\n        Creates a new instance of GoodGhosting game\r\n        @param _inboundCurrency Smart contract address of inbound currency used for the game.\r\n        @param _lendingPoolAddressProvider Smart contract address of the lending pool adddress provider.\r\n        @param _segmentCount Number of segments in the game.\r\n        @param _segmentLength Lenght of each segment, in seconds (i.e., 180 (sec) => 3 minutes).\r\n        @param _segmentPayment Amount of tokens each player needs to contribute per segment (i.e. 10*10**18 equals to 10 DAI - note that DAI uses 18 decimal places).\r\n        @param _earlyWithdrawalFee Fee paid by users on early withdrawals (before the game completes). Used as an integer percentage (i.e., 10 represents 10%). Does not accept \"decimal\" fees like \"0.5\".\r\n        @param _customFee performance fee charged by admin. Used as an integer percentage (i.e., 10 represents 10%). Does not accept \"decimal\" fees like \"0.5\".\r\n        @param _dataProvider id for getting the data provider contract address 0x1 to be passed.\r\n        @param _maxPlayersCount max quantity of players allowed to join the game\r\n        @param _incentiveToken optional token address used to provide additional incentives to users. Accepts \"0x0\" adresses when no incentive token exists.\r\n        @param _incentiveController matic reward claim contract.\r\n        @param _matic matic token address.\r\n     */\r\n    constructor(\r\n        IERC20 _inboundCurrency,\r\n        ILendingPoolAddressesProvider _lendingPoolAddressProvider,\r\n        uint256 _segmentCount,\r\n        uint256 _segmentLength,\r\n        uint256 _segmentPayment,\r\n        uint256 _earlyWithdrawalFee,\r\n        uint256 _customFee,\r\n        address _dataProvider,\r\n        uint256 _maxPlayersCount,\r\n        IERC20 _incentiveToken,\r\n        address _incentiveController,\r\n        IERC20 _matic\r\n    )\r\n        public\r\n        GoodGhosting(\r\n            _inboundCurrency,\r\n            _lendingPoolAddressProvider,\r\n            _segmentCount,\r\n            _segmentLength,\r\n            _segmentPayment,\r\n            _earlyWithdrawalFee,\r\n            _customFee,\r\n            _dataProvider,\r\n            _maxPlayersCount,\r\n            _incentiveToken\r\n        )\r\n    {\r\n        require(_incentiveController != address(0), \"invalid _incentiveController address\");\r\n        require(address(_matic) != address(0), \"invalid _matic address\");\r\n        // initializing incentiveController contract\r\n        incentiveController = IncentiveController(_incentiveController);\r\n        matic = _matic;\r\n    }\r\n\r\n    /// @notice Allows the admin to withdraw the performance fee, if applicable. This function can be called only by the contract's admin.\r\n    /// @dev Cannot be called before the game ends.\r\n    function adminFeeWithdraw()\r\n        external\r\n        override\r\n        onlyOwner\r\n        whenGameIsCompleted\r\n    {\r\n        require(redeemed, \"Funds not redeemed from external pool\");\r\n        require(!adminWithdraw, \"Admin has already withdrawn\");\r\n        adminWithdraw = true;\r\n\r\n        // when there are no winners, admin will be able to withdraw the\r\n        // additional incentives sent to the pool, avoiding locking the funds.\r\n        uint256 adminIncentiveAmount = 0;\r\n        if (winners.length == 0 && totalIncentiveAmount > 0) {\r\n            adminIncentiveAmount = totalIncentiveAmount;\r\n        }\r\n\r\n        emit AdminWithdrawal(owner(), totalGameInterest, adminFeeAmount, adminIncentiveAmount);\r\n\r\n        if (adminFeeAmount > 0) {\r\n            require(\r\n                IERC20(daiToken).transfer(owner(), adminFeeAmount),\r\n                \"Fail to transfer ER20 tokens to admin\"\r\n            );\r\n        }\r\n\r\n        if (adminIncentiveAmount > 0) {\r\n            require(\r\n                IERC20(incentiveToken).transfer(owner(), adminIncentiveAmount),\r\n                \"Fail to transfer ER20 incentive tokens to admin\"\r\n            );\r\n        }\r\n\r\n        if (rewardsPerPlayer == 0) {\r\n            uint256 balance = IERC20(matic).balanceOf(address(this));\r\n            require(\r\n                IERC20(matic).transfer(owner(), balance),\r\n                \"Fail to transfer ERC20 rewards tokens to admin\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Allows player to withdraw their funds after the game ends with no loss (fee). Winners get a share of the interest earned.\r\n    function withdraw() external override {\r\n        Player storage player = players[msg.sender];\r\n        require(player.amountPaid > 0, \"Player does not exist\");\r\n        require(!player.withdrawn, \"Player has already withdrawn\");\r\n        player.withdrawn = true;\r\n\r\n        // First player to withdraw redeems everyone's funds\r\n        if (!redeemed) {\r\n            redeemFromExternalPool();\r\n        }\r\n\r\n        uint256 payout = player.amountPaid;\r\n        uint256 playerIncentive = 0;\r\n        uint256 playerReward = 0;\r\n        if (player.mostRecentSegmentPaid == lastSegment.sub(1)) {\r\n            // Player is a winner and gets a bonus!\r\n            payout = payout.add(totalGameInterest.div(winners.length));\r\n            playerReward = rewardsPerPlayer;\r\n            // If there's additional incentives, distributes them to winners\r\n            if (totalIncentiveAmount > 0) {\r\n                playerIncentive = totalIncentiveAmount.div(winners.length);\r\n            }\r\n        }\r\n        emit Withdrawal(msg.sender, payout, playerReward, playerIncentive);\r\n\r\n        require(\r\n            IERC20(daiToken).transfer(msg.sender, payout),\r\n            \"Fail to transfer ERC20 tokens on withdraw\"\r\n        );\r\n\r\n        if (playerIncentive > 0) {\r\n            require(\r\n                IERC20(incentiveToken).transfer(msg.sender, playerIncentive),\r\n                \"Fail to transfer ERC20 incentive tokens on withdraw\"\r\n            );\r\n        }\r\n\r\n        if (playerReward > 0) {\r\n            require(\r\n                IERC20(matic).transfer(msg.sender, playerReward),\r\n                \"Fail to transfer ERC20 rewards on withdraw\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Redeems funds from the external pool and updates the internal accounting controls related to the game stats.\r\n    /// @dev Can only be called after the game is completed.\r\n    function redeemFromExternalPool() public override whenGameIsCompleted {\r\n        require(!redeemed, \"Redeem operation already happened for the game\");\r\n        redeemed = true;\r\n        // Withdraws funds (principal + interest + rewards) from external pool\r\n        if (adaiToken.balanceOf(address(this)) > 0) {\r\n            lendingPool.withdraw(\r\n                address(daiToken),\r\n                type(uint256).max,\r\n                address(this)\r\n            );\r\n            // Claims the rewards from the external pool\r\n            address[] memory assets = new address[](1);\r\n            assets[0] = address(adaiToken);\r\n            uint256 claimableRewards = incentiveController.getRewardsBalance(\r\n                assets,\r\n                address(this)\r\n            );\r\n            if (claimableRewards > 0) {\r\n                incentiveController.claimRewards(\r\n                    assets,\r\n                    claimableRewards,\r\n                    address(this)\r\n                );\r\n            }\r\n        }\r\n\r\n        uint256 totalBalance = IERC20(daiToken).balanceOf(address(this));\r\n        uint256 rewardsAmount = IERC20(matic).balanceOf(address(this));\r\n        // If there's an incentive token address defined, sets the total incentive amount to be distributed among winners.\r\n        if (address(incentiveToken) != address(0)) {\r\n            totalIncentiveAmount = IERC20(incentiveToken).balanceOf(address(this));\r\n        }\r\n        // calculates gross interest\r\n        uint256 grossInterest = 0;\r\n        // Sanity check to avoid reverting due to overflow in the \"subtraction\" below.\r\n        // This could only happen in case Aave changes the 1:1 ratio between\r\n        // aToken vs. Token in the future (i.e., 1 aDAI is worth less than 1 DAI)\r\n        if (totalBalance > totalGamePrincipal) {\r\n            grossInterest = totalBalance.sub(totalGamePrincipal);\r\n        }\r\n        // calculates the performance/admin fee (takes a cut - the admin percentage fee - from the pool's interest).\r\n        // calculates the \"gameInterest\" (net interest) that will be split among winners in the game\r\n        uint256 _adminFeeAmount;\r\n        if (customFee > 0) {\r\n            _adminFeeAmount = (grossInterest.mul(customFee)).div(100);\r\n            totalGameInterest = grossInterest.sub(_adminFeeAmount);\r\n        } else {\r\n            _adminFeeAmount = 0;\r\n            totalGameInterest = grossInterest;\r\n        }\r\n\r\n        // when there's no winners, admin takes all the interest + rewards\r\n        if (winners.length == 0) {\r\n            rewardsPerPlayer = 0;\r\n            adminFeeAmount = grossInterest;\r\n        } else {\r\n            rewardsPerPlayer = rewardsAmount.div(winners.length);\r\n            adminFeeAmount = _adminFeeAmount;\r\n        }\r\n\r\n        emit FundsRedeemedFromExternalPool(\r\n            totalBalance,\r\n            totalGamePrincipal,\r\n            totalGameInterest,\r\n            rewardsAmount,\r\n            totalIncentiveAmount\r\n        );\r\n        emit WinnersAnnouncement(winners);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_inboundCurrency\",\"type\":\"address\"},{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"_lendingPoolAddressProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_segmentCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_segmentLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_segmentPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earlyWithdrawalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_customFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dataProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxPlayersCount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_incentiveToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_incentiveController\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_matic\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalGameInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminIncentiveAmount\",\"type\":\"uint256\"}],\"name\":\"AdminWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"segment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalGamePrincipal\",\"type\":\"uint256\"}],\"name\":\"EarlyWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalGamePrincipal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalGameInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalIncentiveAmount\",\"type\":\"uint256\"}],\"name\":\"FundsRedeemedFromExternalPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JoinedGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"}],\"name\":\"WinnersAnnouncement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerIncentive\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activePlayersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adaiToken\",\"outputs\":[{\"internalType\":\"contract AToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminFeeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlyWithdrawalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstSegmentStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSegment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfPlayers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incentiveController\",\"outputs\":[{\"internalType\":\"contract IncentiveController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incentiveToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGameCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"iterablePlayers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joinGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSegment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPoolAddressProvider\",\"outputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"matic\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPlayersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canRejoin\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"mostRecentSegmentPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemFromExternalPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerPlayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"segmentLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"segmentPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGameInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGamePrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalIncentiveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GoodGhostingPolygon", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "1", "Runs": "1500", "ConstructorArguments": "0000000000000000000000008f3cf7ad23cd3cadbd9735aff958023239c6a063000000000000000000000000d05e3e715d945b59290df0ae8ef85c1bdb684744000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000001275000000000000000000000000000000000000000000000000022b1c8c1227a00000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000007551b5d2763519d4e37e8b81929d336de671d46d000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000009c78ee466d6cb57a4d01fd887d2b5dfb2d46288f000000000000000000000000357d51124f59836ded84c8a1730d72b749d8bc230000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6e14de35f32162a72f06d00b61b82fc400554f9452f94e2c6a5dd6c6bb471afc"}