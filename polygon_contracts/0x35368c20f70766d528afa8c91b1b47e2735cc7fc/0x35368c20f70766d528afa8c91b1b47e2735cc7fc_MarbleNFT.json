{"SourceCode": "// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev ERC-721 non-fungible token standard. See https://goo.gl/pc9yoS.\r\n */\r\ninterface ERC721 {\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\r\n   * on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they mayb be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved The new approved NFT controller.\r\n   * @param _tokenId The NFT to approve.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice The contract MUST allow multiple operators per owner.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId The NFT to find the approved address for.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721TokenReceiver.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers. See https://goo.gl/pc9yoS.\r\n */\r\ninterface ERC721TokenReceiver {\r\n\r\n  /**\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n    \r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Math operations with safety checks that throw on error. This contract is based\r\n * on the source code at https://goo.gl/iyQsmU.\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n   * @dev Multiplies two numbers, throws on overflow.\r\n   * @param _a Factor number.\r\n   * @param _b Factor number.\r\n   */\r\n  function mul(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Integer division of two numbers, truncating the quotient.\r\n   * @param _a Dividend number.\r\n   * @param _b Divisor number.\r\n   */\r\n  function div(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    uint256 c = _a / _b;\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n   * @param _a Minuend number.\r\n   * @param _b Subtrahend number.\r\n   */\r\n  function sub(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds two numbers, throws on overflow.\r\n   * @param _a Number.\r\n   * @param _b Number.\r\n   */\r\n  function add(\r\n    uint256 _a,\r\n    uint256 _b\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    uint256 c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/utils/ERC165.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev A standard for detecting smart contract interfaces. See https://goo.gl/cxQCse.\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @dev Checks if the smart contract includes a specific interface.\r\n   * @notice This function uses less than 30,000 gas.\r\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/utils/SupportsInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @dev Implementation of standard for detect smart contract interfaces.\r\n */\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Mapping of supported intefraces.\r\n   * @notice You must not set element 0xffffffff to true.\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check which interfaces are suported by this contract.\r\n   * @param _interfaceID Id of the interface.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/utils/AddressUtils.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Utility library of inline functions on addresses.\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * @dev Returns whether the target address is a contract.\r\n   * @param _addr Address to check.\r\n   */\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    uint256 size;\r\n\r\n    /**\r\n     * XXX Currently there is no better way to check if there is a contract in an address than to\r\n     * check the size of the code at that address.\r\n     * See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\r\n     * TODO: Check this again before the Serenity release, because all addresses will be\r\n     * contracts then.\r\n     */\r\n    assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/NFToken.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of ERC-721 non-fungible token standard.\r\n */\r\ncontract NFToken is\r\n  ERC721,\r\n  SupportsInterface\r\n{\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  /**\r\n   * @dev A mapping from NFT ID to the address that owns it.\r\n   */\r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to approved address.\r\n   */\r\n  mapping (uint256 => address) internal idToApprovals;\r\n\r\n   /**\r\n   * @dev Mapping from owner address to count of his tokens.\r\n   */\r\n  mapping (address => uint256) internal ownerToNFTokenCount;\r\n\r\n  /**\r\n   * @dev Mapping from owner address to mapping of operator addresses.\r\n   */\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  /**\r\n   * @dev Magic value of a smart contract that can recieve NFT.\r\n   * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n   */\r\n  bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   * @param _from Sender of NFT (if address is zero address it indicates token creation).\r\n   * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\r\n   * @param _tokenId The NFT that got transfered.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   * @param _owner Owner of NFT.\r\n   * @param _approved Address that we are approving.\r\n   * @param _tokenId NFT which we are approving.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   * @param _owner Owner of NFT.\r\n   * @param _operator Address to which we are setting operator rights.\r\n   * @param _approved Status of operator rights(true if operator rights are given and false if\r\n   * revoked).\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  ) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n   * @param _tokenId ID of the NFT to transfer.\r\n   */\r\n  modifier canTransfer(\r\n    uint256 _tokenId\r\n  ) {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || getApproved(_tokenId) == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender]\r\n    );\r\n\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that _tokenId is a valid Token.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  ) {\r\n    require(idToOwner[_tokenId] != address(0));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0));\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n   * invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\r\n   * on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    external\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers the ownership of an NFT from one address to another address.\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they maybe be permanently lost.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from);\r\n    require(_to != address(0));\r\n\r\n    _transfer(_to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Set or reaffirm the approved address for an NFT.\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved Address to be approved for the given NFT ID.\r\n   * @param _tokenId ID of the token to be approved.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    canOperate(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner);\r\n\r\n    idToApprovals[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @notice This works even if sender doesn't own any tokens at the time.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n  {\r\n    require(_operator != address(0));\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Get the approved address for a single NFT.\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @param _tokenId ID of the NFT to query the approval of.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    public\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (address)\r\n  {\r\n    return idToApprovals[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(_owner != address(0));\r\n    require(_operator != address(0));\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @dev Actually perform the safeTransferFrom.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    internal\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from);\r\n    require(_to != address(0));\r\n\r\n    _transfer(_to, _tokenId);\r\n\r\n    if (_to.isContract()) {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Actually preforms the transfer.\r\n   * @notice Does NO checks.\r\n   * @param _to Address of a new owner.\r\n   * @param _tokenId The NFT that is being transferred.\r\n   */\r\n  function _transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    address from = idToOwner[_tokenId];\r\n    clearApproval(_tokenId);\r\n\r\n    removeNFToken(from, _tokenId);\r\n    addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n   \r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * mint function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _to The address that will own the minted NFT.\r\n   * @param _tokenId of the NFT to be minted by the msg.sender.\r\n   */\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    require(_to != address(0));\r\n    require(_tokenId != 0);\r\n    require(idToOwner[_tokenId] == address(0));\r\n\r\n    addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * burn function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _owner Address of the NFT owner.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    address _owner,\r\n    uint256 _tokenId\r\n  )\r\n    validNFToken(_tokenId)\r\n    internal\r\n  {\r\n    clearApproval(_tokenId);\r\n    removeNFToken(_owner, _tokenId);\r\n    emit Transfer(_owner, address(0), _tokenId);\r\n  }\r\n\r\n  /** \r\n   * @dev Clears the current approval of a given NFT ID.\r\n   * @param _tokenId ID of the NFT to be transferred.\r\n   */\r\n  function clearApproval(\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    if(idToApprovals[_tokenId] != 0)\r\n    {\r\n      delete idToApprovals[_tokenId];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a NFT from owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _from Address from wich we want to remove the NFT.\r\n   * @param _tokenId Which NFT we want to remove.\r\n   */\r\n  function removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n   internal\r\n  {\r\n    require(idToOwner[_tokenId] == _from);\r\n    assert(ownerToNFTokenCount[_from] > 0);\r\n    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from].sub(1);\r\n    delete idToOwner[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Assignes a new NFT to owner.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _to Address to wich we want to add the NFT.\r\n   * @param _tokenId Which NFT we want to add.\r\n   */\r\n  function addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    require(idToOwner[_tokenId] == address(0));\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Metadata.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\r\n * See https://goo.gl/pc9yoS.\r\n */\r\ninterface ERC721Metadata {\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string _name);\r\n\r\n  /**\r\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string _symbol);\r\n\r\n  /**\r\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\r\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\r\n   * that conforms to the \"ERC721 Metadata JSON Schema\".\r\n   */\r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string);\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenMetadata.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenMetadata is\r\n  NFToken,\r\n  ERC721Metadata\r\n{\r\n\r\n  /**\r\n   * @dev A descriptive name for a collection of NFTs.\r\n   */\r\n  string internal nftName;\r\n\r\n  /**\r\n   * @dev An abbreviated name for NFTokens.\r\n   */\r\n  string internal nftSymbol;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to metadata uri.\r\n   */\r\n  mapping (uint256 => string) internal idToUri;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is a internal function which should be called from user-implemented external\r\n   * burn function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _owner Address of the NFT owner.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    address _owner,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    super._burn(_owner, _tokenId);\r\n\r\n    if (bytes(idToUri[_tokenId]).length != 0) {\r\n      delete idToUri[_tokenId];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\r\n   * @notice this is a internal function which should be called from user-implemented external\r\n   * function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _tokenId Id for which we want uri.\r\n   * @param _uri String representing RFC 3986 URI.\r\n   */\r\n  function _setTokenUri(\r\n    uint256 _tokenId,\r\n    string _uri\r\n  )\r\n    validNFToken(_tokenId)\r\n    internal\r\n  {\r\n    idToUri[_tokenId] = _uri;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTokens.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string _name)\r\n  {\r\n    _name = nftName;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an abbreviated name for NFTokens.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string _symbol)\r\n  {\r\n    _symbol = nftSymbol;\r\n  }\r\n\r\n  /**\r\n   * @dev A distinct URI (RFC 3986) for a given NFT.\r\n   * @param _tokenId Id for which we want uri.\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  )\r\n    validNFToken(_tokenId)\r\n    external\r\n    view\r\n    returns (string)\r\n  {\r\n    return idToUri[_tokenId];\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/ERC721Enumerable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\r\n * See https://goo.gl/pc9yoS.\r\n */\r\ninterface ERC721Enumerable {\r\n\r\n  /**\r\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\r\n   * assigned and queryable owner not equal to the zero address.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\r\n   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\r\n   * representing invalid NFTs.\r\n   * @param _owner An address where we are interested in NFTs owned by them.\r\n   * @param _index A counter less than `balanceOf(_owner)`.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-erc721/contracts/tokens/NFTokenEnumerable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenEnumerable is\r\n  NFToken,\r\n  ERC721Enumerable\r\n{\r\n\r\n  /**\r\n   * @dev Array of all NFT IDs.\r\n   */\r\n  uint256[] internal tokens;\r\n\r\n  /**\r\n   * @dev Mapping from token ID its index in global tokens array.\r\n   */\r\n  mapping(uint256 => uint256) internal idToIndex;\r\n\r\n  /**\r\n   * @dev Mapping from owner to list of owned NFT IDs.\r\n   */\r\n  mapping(address => uint256[]) internal ownerToIds;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to its index in the owner tokens list.\r\n   */\r\n  mapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n  }\r\n\r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * mint function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _to The address that will own the minted NFT.\r\n   * @param _tokenId of the NFT to be minted by the msg.sender.\r\n   */\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    super._mint(_to, _tokenId);\r\n    tokens.push(_tokenId);\r\n    idToIndex[_tokenId] = tokens.length.sub(1);\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a NFT.\r\n   * @notice This is a private function which should be called from user-implemented external\r\n   * burn function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @param _owner Address of the NFT owner.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    address _owner,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    super._burn(_owner, _tokenId);\r\n    assert(tokens.length > 0);\r\n\r\n    uint256 tokenIndex = idToIndex[_tokenId];\r\n    // Sanity check. This could be removed in the future.\r\n    assert(tokens[tokenIndex] == _tokenId);\r\n    uint256 lastTokenIndex = tokens.length.sub(1);\r\n    uint256 lastToken = tokens[lastTokenIndex];\r\n\r\n    tokens[tokenIndex] = lastToken;\r\n\r\n    tokens.length--;\r\n    // Consider adding a conditional check for the last token in order to save GAS.\r\n    idToIndex[lastToken] = tokenIndex;\r\n    idToIndex[_tokenId] = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a NFT from an address.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _from Address from wich we want to remove the NFT.\r\n   * @param _tokenId Which NFT we want to remove.\r\n   */\r\n  function removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n   internal\r\n  {\r\n    super.removeNFToken(_from, _tokenId);\r\n    assert(ownerToIds[_from].length > 0);\r\n\r\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\r\n    uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n\r\n    ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n\r\n    ownerToIds[_from].length--;\r\n    // Consider adding a conditional check for the last token in order to save GAS.\r\n    idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n    idToOwnerIndex[_tokenId] = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Assignes a new NFT to an address.\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @param _to Address to wich we want to add the NFT.\r\n   * @param _tokenId Which NFT we want to add.\r\n   */\r\n  function addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    super.addNFToken(_to, _tokenId);\r\n\r\n    uint256 length = ownerToIds[_to].length;\r\n    ownerToIds[_to].push(_tokenId);\r\n    idToOwnerIndex[_tokenId] = length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the count of all existing NFTokens.\r\n   */\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return tokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns NFT ID by its index.\r\n   * @param _index A counter less than `totalSupply()`.\r\n   */\r\n  function tokenByIndex(\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < tokens.length);\r\n    // Sanity check. This could be removed in the future.\r\n    assert(idToIndex[tokens[_index]] == _index);\r\n    return tokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev returns the n-th NFT ID from a list of owner's tokens.\r\n   * @param _owner Token owner's address.\r\n   * @param _index Index number representing n-th token in owner's list of tokens.\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_index < ownerToIds[_owner].length);\r\n    return ownerToIds[_owner][_index];\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code\r\n * at https://goo.gl/n2ZGVt.\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    onlyOwner\r\n    public\r\n  {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: @0xcert/ethereum-utils/contracts/ownership/Claimable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code\r\n * at goo.gl/CfEAkv and upgrades Ownable contracts with additional claim step which makes ownership\r\n * transfers less prone to errors.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Allows the current owner to give new owner ability to claim the ownership of the contract.\r\n   * This differs from the Owner's function in that it allows setting pedingOwner address to 0x0,\r\n   * which effectively cancels an active claim.\r\n   * @param _newOwner The address which can claim ownership of the contract.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    onlyOwner\r\n    public\r\n  {\r\n    pendingOwner = _newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current pending owner to claim the ownership of the contract. It emits\r\n   * OwnershipTransferred event and resets pending owner to 0.\r\n   */\r\n  function claimOwnership()\r\n    public\r\n  {\r\n    require(msg.sender == pendingOwner);\r\n    address previousOwner = owner;\r\n    owner = pendingOwner;\r\n    pendingOwner = 0;\r\n    emit OwnershipTransferred(previousOwner, owner);\r\n  }\r\n}\r\n\r\n// File: contracts/Adminable.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Adminable\r\n * @dev Allows to manage privilages to special contract functionality.\r\n */\r\ncontract Adminable is Claimable {\r\n  mapping(address => uint) public adminsMap;\r\n  address[] public adminList;\r\n\r\n  /**\r\n   * @dev Returns true, if provided address has special privilages, otherwise false\r\n   * @param adminAddress - address to check\r\n   */\r\n  function isAdmin(address adminAddress)\r\n    public\r\n    view\r\n    returns(bool isIndeed)\r\n  {\r\n    if (adminAddress == owner) return true;\r\n\r\n    if (adminList.length == 0) return false;\r\n    return (adminList[adminsMap[adminAddress]] == adminAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Grants special rights for address holder\r\n   * @param adminAddress - address of future admin\r\n   */\r\n  function addAdmin(address adminAddress)\r\n    public\r\n    onlyOwner\r\n    returns(uint index)\r\n  {\r\n    require(!isAdmin(adminAddress), \"Address already has admin rights!\");\r\n\r\n    adminsMap[adminAddress] = adminList.push(adminAddress)-1;\r\n\r\n    return adminList.length-1;\r\n  }\r\n\r\n  /**\r\n   * @dev Removes special rights for provided address\r\n   * @param adminAddress - address of current admin\r\n   */\r\n  function removeAdmin(address adminAddress)\r\n    public\r\n    onlyOwner\r\n    returns(uint index)\r\n  {\r\n    // we can not remove owner from admin role\r\n    require(owner != adminAddress, \"Owner can not be removed from admin role!\");\r\n    require(isAdmin(adminAddress), \"Provided address is not admin.\");\r\n\r\n    uint rowToDelete = adminsMap[adminAddress];\r\n    address keyToMove = adminList[adminList.length-1];\r\n    adminList[rowToDelete] = keyToMove;\r\n    adminsMap[keyToMove] = rowToDelete;\r\n    adminList.length--;\r\n\r\n    return rowToDelete;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyAdmin() {\r\n    require(isAdmin(msg.sender), \"Can be executed only by admin accounts!\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: contracts/MarbleNFTInterface.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Marble NFT Interface\r\n * @dev Defines Marbles unique extension of NFT.\r\n * ...It contains methodes returning core properties what describe Marble NFTs and provides management options to create,\r\n * burn NFT or change approvals of it.\r\n */\r\ninterface MarbleNFTInterface {\r\n\r\n  /**\r\n   * @dev Mints Marble NFT.\r\n   * @notice This is a external function which should be called just by the owner of contract or any other user who has priviladge of being resposible\r\n   * of creating valid Marble NFT. Valid token contains all neccessary information to be able recreate marble card image.\r\n   * @param _tokenId The ID of new NFT.\r\n   * @param _owner Address of the NFT owner.\r\n   * @param _uri Unique URI proccessed by Marble services to be sure it is valid NFTs DNA. Most likely it is URL pointing to some website address.\r\n   * @param _metadataUri URI pointing to \"ERC721 Metadata JSON Schema\"\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function mint(\r\n    uint256 _tokenId,\r\n    address _owner,\r\n    address _creator,\r\n    string _uri,\r\n    string _metadataUri,\r\n    uint256 _created\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Burns Marble NFT. Should be fired only by address with proper authority as contract owner or etc.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function burn(\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Allowes to change approval for change of ownership even when sender is not NFT holder. Sender has to have special role granted by contract to use this tool.\r\n   * @notice Careful with this!!!! :))\r\n   * @param _tokenId ID of the NFT to be updated.\r\n   * @param _approved ETH address what supposed to gain approval to take ownership of NFT.\r\n   */\r\n  function forceApproval(\r\n    uint256 _tokenId,\r\n    address _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns properties used for generating NFT metadata image (a.k.a. card).\r\n   * @param _tokenId ID of the NFT.\r\n   */\r\n  function tokenSource(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (\r\n      string uri,\r\n      address creator,\r\n      uint256 created\r\n    );\r\n\r\n  /**\r\n   * @dev Returns ID of NFT what matches provided source URI.\r\n   * @param _uri URI of source website.\r\n   */\r\n  function tokenBySourceUri(string _uri)\r\n    external\r\n    view\r\n    returns (uint256 tokenId);\r\n\r\n  /**\r\n   * @dev Returns all properties of Marble NFT. Lets call it Marble NFT Model with properties described below:\r\n   * @param _tokenId ID  of NFT\r\n   * Returned model:\r\n   * uint256 id ID of NFT\r\n   * string uri  URI of source website. Website is used to mine data to crate NFT metadata image.\r\n   * string metadataUri URI to NFT metadata assets. In our case to our websevice providing JSON with additional information based on \"ERC721 Metadata JSON Schema\".\r\n   * address owner NFT owner address.\r\n   * address creator Address of creator of this NFT. It means that this addres placed sourceURI to candidate contract.\r\n   * uint256 created Date and time of creation of NFT candidate.\r\n   *\r\n   * (id, uri, metadataUri, owner, creator, created)\r\n   */\r\n  function getNFT(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns(\r\n      uint256 id,\r\n      string uri,\r\n      string metadataUri,\r\n      address owner,\r\n      address creator,\r\n      uint256 created\r\n    );\r\n\r\n\r\n    /**\r\n     * @dev Transforms URI to hash.\r\n     * @param _uri URI to be transformed to hash.\r\n     */\r\n    function getSourceUriHash(string _uri)\r\n      external\r\n      view\r\n      returns(uint256 hash);\r\n}\r\n\r\n// File: contracts/MarbleNFT.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title MARBLE NFT CONTRACT\r\n * @notice We omit a fallback function to prevent accidental sends to this contract.\r\n */\r\ncontract MarbleNFT is\r\n  Adminable,\r\n  NFTokenMetadata,\r\n  NFTokenEnumerable,\r\n  MarbleNFTInterface\r\n{\r\n\r\n  /*\r\n   * @dev structure storing additional information about created NFT\r\n   * uri: URI used as source/key/representation of NFT, it can be considered as tokens DNA\r\n   * creator:  address of candidate creator - a.k.a. address of person who initialy provided source URI\r\n   * created: date of NFT creation\r\n   */\r\n  struct MarbleNFTSource {\r\n\r\n    // URI used as source/key of NFT, we can consider it as tokens DNA\r\n    string uri;\r\n\r\n    // address of candidate creator - a.k.a. address of person who initialy provided source URI\r\n    address creator;\r\n\r\n    // date of NFT creation\r\n    uint256 created;\r\n  }\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to marble NFT source.\r\n   */\r\n  mapping (uint256 => MarbleNFTSource) public idToMarbleNFTSource;\r\n  /**\r\n   * @dev Mapping from marble NFT source uri hash TO NFT ID .\r\n   */\r\n  mapping (uint256 => uint256) public sourceUriHashToId;\r\n\r\n  constructor()\r\n    public\r\n  {\r\n    nftName = \"MARBLE-NFT\";\r\n    nftSymbol = \"MRBLNFT\";\r\n  }\r\n\r\n  /**\r\n   * @dev Mints a new NFT.\r\n   * @param _tokenId The unique number representing NFT\r\n   * @param _owner Holder of Marble NFT\r\n   * @param _creator Creator of Marble NFT\r\n   * @param _uri URI representing NFT\r\n   * @param _metadataUri URI pointing to \"ERC721 Metadata JSON Schema\"\r\n   * @param _created date of creation of NFT candidate\r\n   */\r\n  function mint(\r\n    uint256 _tokenId,\r\n    address _owner,\r\n    address _creator,\r\n    string _uri,\r\n    string _metadataUri,\r\n    uint256 _created\r\n  )\r\n    external\r\n    onlyAdmin\r\n  {\r\n    uint256 uriHash = _getSourceUriHash(_uri);\r\n\r\n    require(uriHash != _getSourceUriHash(\"\"), \"NFT URI can not be empty!\");\r\n    require(sourceUriHashToId[uriHash] == 0, \"NFT with same URI already exists!\");\r\n\r\n    _mint(_owner, _tokenId);\r\n    _setTokenUri(_tokenId, _metadataUri);\r\n\r\n    idToMarbleNFTSource[_tokenId] = MarbleNFTSource(_uri, _creator, _created);\r\n    sourceUriHashToId[uriHash] = _tokenId;\r\n  }\r\n\r\n  /**\r\n   * @dev Burns NFT. Sadly, trully.. ...probably someone marbled something ugly!!!! :)\r\n   * @param _tokenId ID of ugly NFT\r\n   */\r\n  function burn(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    onlyAdmin\r\n  {\r\n    address owner = idToOwner[_tokenId];\r\n\r\n    MarbleNFTSource memory marbleNFTSource = idToMarbleNFTSource[_tokenId];\r\n\r\n    if (bytes(marbleNFTSource.uri).length != 0) {\r\n      uint256 uriHash = _getSourceUriHash(marbleNFTSource.uri);\r\n      delete sourceUriHashToId[uriHash];\r\n      delete idToMarbleNFTSource[_tokenId];\r\n    }\r\n\r\n    _burn(owner, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to manage misstreated NFTs or to be able to extend our services for new cool stuff like auctions, weird games and so on......\r\n   * @param _tokenId ID of the NFT to be update.\r\n   * @param _approved Address to replace current approved address on NFT\r\n   */\r\n  function forceApproval(\r\n    uint256 _tokenId,\r\n    address _approved\r\n  )\r\n    external\r\n    onlyAdmin\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner,\"Owner can not be become new owner!\");\r\n\r\n    idToApprovals[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns model of Marble NFT source properties\r\n   * @param _tokenId ID of the NFT\r\n   */\r\n  function tokenSource(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (\r\n      string uri,\r\n      address creator,\r\n      uint256 created)\r\n  {\r\n    MarbleNFTSource memory marbleNFTSource = idToMarbleNFTSource[_tokenId];\r\n    return (marbleNFTSource.uri, marbleNFTSource.creator, marbleNFTSource.created);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns token ID related to provided source uri\r\n   * @param _uri URI representing created NFT\r\n   */\r\n  function tokenBySourceUri(string _uri)\r\n    external\r\n    view\r\n    returns (uint256 tokenId)\r\n  {\r\n    return sourceUriHashToId[_getSourceUriHash(_uri)];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whole Marble NFT model\r\n   * --------------------\r\n   *   MARBLE NFT MODEL\r\n   * --------------------\r\n   * uint256 id NFT unique identification\r\n   * string uri NFT source URI, source is whole site what was proccessed by marble to create this NFT, it is URI representation of NFT (call it DNA)\r\n   * string metadataUri  URI pointint to token NFT metadata shcema\r\n   * address owner Current NFT owner\r\n   * address creator First NFT owner\r\n   * uint256 created Date of NFT candidate creation\r\n   *\r\n   * (id, uri, metadataUri, owner, creator, created)\r\n   */\r\n  function getNFT(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns(\r\n      uint256 id,\r\n      string uri,\r\n      string metadataUri,\r\n      address owner,\r\n      address creator,\r\n      uint256 created\r\n    )\r\n  {\r\n\r\n    MarbleNFTSource memory marbleNFTSource = idToMarbleNFTSource[_tokenId];\r\n\r\n    return (\r\n      _tokenId,\r\n      marbleNFTSource.uri,\r\n      idToUri[_tokenId],\r\n      idToOwner[_tokenId],\r\n      marbleNFTSource.creator,\r\n      marbleNFTSource.created);\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Transforms URI to hash.\r\n   * @param _uri URI to be transformed to hash.\r\n   */\r\n  function getSourceUriHash(string _uri)\r\n     external\r\n     view\r\n     returns(uint256 hash)\r\n  {\r\n     return _getSourceUriHash(_uri);\r\n  }\r\n\r\n  /**\r\n   * @dev Transforms URI to hash.\r\n   * @param _uri URI to be transformed to hash.\r\n   */\r\n  function _getSourceUriHash(string _uri)\r\n    internal\r\n    pure\r\n    returns(uint256 hash)\r\n  {\r\n    return uint256(keccak256(abi.encodePacked(_uri)));\r\n  }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adminList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adminAddress\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_approved\",\"type\":\"address\"}],\"name\":\"forceApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"adminAddress\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"isIndeed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sourceUriHashToId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"tokenBySourceUri\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getNFT\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"uri\",\"type\":\"string\"},{\"name\":\"metadataUri\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"created\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToMarbleNFTSource\",\"outputs\":[{\"name\":\"uri\",\"type\":\"string\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"created\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adminAddress\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_uri\",\"type\":\"string\"},{\"name\":\"_metadataUri\",\"type\":\"string\"},{\"name\":\"_created\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenSource\",\"outputs\":[{\"name\":\"uri\",\"type\":\"string\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"created\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"adminsMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"getSourceUriHash\",\"outputs\":[{\"name\":\"hash\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "MarbleNFT", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}