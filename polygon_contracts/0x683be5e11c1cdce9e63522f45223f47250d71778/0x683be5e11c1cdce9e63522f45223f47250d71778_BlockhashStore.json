{"SourceCode": "\r\n// File: contracts/dev/BlockhashStore.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/**\r\n * @title BlockhashStore\r\n * @notice This contract provides a way to access blockhashes older than\r\n *   the 256 block limit imposed by the BLOCKHASH opcode.\r\n *   You may assume that any blockhash stored by the contract is correct.\r\n *   Note that the contract depends on the format of serialized Ethereum\r\n *   blocks. If a future hardfork of Ethereum changes that format, the \r\n *   logic in this contract may become incorrect and an updated version \r\n *   would have to be deployed.\r\n */\r\ncontract BlockhashStore {\r\n\r\n  mapping(uint => bytes32) internal s_blockhashes;\r\n\r\n  /**\r\n   * @notice stores blockhash of a given block, assuming it is available through BLOCKHASH\r\n   * @param n the number of the block whose blockhash should be stored\r\n   */\r\n  function store(uint256 n) public {\r\n    bytes32 h = blockhash(n);\r\n    require(h != 0x0, \"blockhash(n) failed\");\r\n    s_blockhashes[n] = h;\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice stores blockhash of the earliest block still available through BLOCKHASH.\r\n   */\r\n  function storeEarliest() external {\r\n    store(block.number - 256);\r\n  }\r\n\r\n  /**\r\n   * @notice stores blockhash after verifying blockheader of child/subsequent block\r\n   * @param n the number of the block whose blockhash should be stored\r\n   * @param header the rlp-encoded blockheader of block n+1. We verify its correctness by checking\r\n   *   that it hashes to a stored blockhash, and then extract parentHash to get the n-th blockhash.\r\n   */\r\n  function storeVerifyHeader(uint256 n, bytes memory header) public {\r\n    require(keccak256(header) == s_blockhashes[n + 1], \"header has unknown blockhash\");\r\n\r\n    // At this point, we know that header is the correct blockheader for block n+1.\r\n\r\n    // The header is an rlp-encoded list. The head item of that list is the 32-byte blockhash of the parent block.\r\n    // Based on how rlp works, we know that blockheaders always have the following form:\r\n    // 0xf9____a0PARENTHASH...\r\n    //   ^ ^   ^\r\n    //   | |   |\r\n    //   | |   +--- PARENTHASH is 32 bytes. rlpenc(PARENTHASH) is 0xa || PARENTHASH.\r\n    //   | |\r\n    //   | +--- 2 bytes containing the sum of the lengths of the encoded list items\r\n    //   |\r\n    //   +--- 0xf9 because we have a list and (sum of lengths of encoded list items) fits exactly into two bytes.\r\n    //\r\n    // As a consequence, the PARENTHASH is always at offset 4 of the rlp-encoded block header.\r\n\r\n    bytes32 parentHash;\r\n    assembly {\r\n      parentHash := mload(add(header, 36)) // 36 = 32 byte offset for length prefix of ABI-encoded array\r\n                                           //    +  4 byte offset of PARENTHASH (see above)\r\n    }\r\n\r\n    s_blockhashes[n] = parentHash;\r\n  }\r\n\r\n  /**\r\n   * @notice gets a blockhash from the store. If no hash is known, this function reverts.\r\n   * @param n the number of the block whose blockhash should be returned\r\n   */\r\n  function getBlockhash(uint256 n) external view returns (bytes32) {\r\n    bytes32 h = s_blockhashes[n];\r\n    require(h != 0x0, \"blockhash not found in store\");\r\n    return h;\r\n  }\r\n}\r\n", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getBlockhash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"store\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storeEarliest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"storeVerifyHeader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BlockhashStore", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}