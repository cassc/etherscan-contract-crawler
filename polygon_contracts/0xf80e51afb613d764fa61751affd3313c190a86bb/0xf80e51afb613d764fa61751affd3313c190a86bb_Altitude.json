{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.18;\r\npragma abicoder v2;\r\n\r\n/******************************************/\r\n/*      ReentrancyGuard starts here       */\r\n/******************************************/\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n/******************************************/\r\n/*           IERC20 starts here           */\r\n/******************************************/\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/******************************************/\r\n/*        IERC20Permit starts here        */\r\n/******************************************/\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n/******************************************/\r\n/*           Address starts here          */\r\n/******************************************/\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/******************************************/\r\n/*          SafeERC20 starts here         */\r\n/******************************************/\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/******************************************/\r\n/*           Context starts here          */\r\n/******************************************/\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/******************************************/\r\n/*           Ownable starts here          */\r\n/******************************************/\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/***************************************************/\r\n/*   ILayerZeroUserApplicationConfig starts here   */\r\n/***************************************************/\r\n\r\ninterface ILayerZeroUserApplicationConfig {\r\n    // @notice set the configuration of the LayerZero messaging library of the specified version\r\n    // @param _version - messaging library version\r\n    // @param _chainId - the chainId for the pending config change\r\n    // @param _configType - type of configuration. every messaging library has its own convention.\r\n    // @param _config - configuration in the bytes. can encode arbitrary content.\r\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\r\n\r\n    // @notice set the send() LayerZero messaging library version to _version\r\n    // @param _version - new messaging library version\r\n    function setSendVersion(uint16 _version) external;\r\n\r\n    // @notice set the lzReceive() LayerZero messaging library version to _version\r\n    // @param _version - new messaging library version\r\n    function setReceiveVersion(uint16 _version) external;\r\n\r\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\r\n    // @param _srcChainId - the chainId of the source chain\r\n    // @param _srcAddress - the contract address of the source contract at the source chain\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\r\n}\r\n\r\n/******************************************/\r\n/*     ILayerZeroEndpoint starts here     */\r\n/******************************************/\r\n\r\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\r\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\r\n    // @param _dstChainId - the destination chain identifier\r\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\r\n    // @param _payload - a custom bytes payload to send to the destination contract\r\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\r\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\r\n    // @param _adapterParams - parameters for custom functionality. ie: pay for a specified destination gasAmount, or receive airdropped native gas from the relayer on destination\r\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    // @notice used by the messaging library to publish verified payload\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source contract (as bytes) at the source chain\r\n    // @param _dstAddress - the address on destination chain\r\n    // @param _nonce - the unbound message ordering nonce\r\n    // @param _gasLimit - the gas limit for external contract execution\r\n    // @param _payload - verified payload to send to the destination contract\r\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\r\n\r\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\r\n\r\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\r\n    // @param _srcAddress - the source chain contract address\r\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\r\n\r\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\r\n    // @param _dstChainId - the destination chain identifier\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    // @param _payload - the custom message to send over LayerZero\r\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\r\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\r\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    // @notice get this Endpoint's immutable source identifier\r\n    function getChainId() external view returns (uint16);\r\n\r\n    // @notice the interface to retry failed message on this Endpoint destination\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    // @param _payload - the payload to be retried\r\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\r\n\r\n    // @notice query if any STORED payload (message blocking) at the endpoint.\r\n    // @param _srcChainId - the source chain identifier\r\n    // @param _srcAddress - the source chain contract address\r\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\r\n\r\n    // @notice query if the _libraryAddress is valid for sending msgs.\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n    // @notice query if the _libraryAddress is valid for receiving msgs.\r\n    // @param _userApplication - the user app address on this EVM chain\r\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\r\n\r\n    // @notice query if the non-reentrancy guard for send() is on\r\n    // @return true if the guard is on. false otherwise\r\n    function isSendingPayload() external view returns (bool);\r\n\r\n    // @notice query if the non-reentrancy guard for receive() is on\r\n    // @return true if the guard is on. false otherwise\r\n    function isReceivingPayload() external view returns (bool);\r\n\r\n    // @notice get the configuration of the LayerZero messaging library of the specified version\r\n    // @param _version - messaging library version\r\n    // @param _chainId - the chainId for the pending config change\r\n    // @param _userApplication - the contract address of the user application\r\n    // @param _configType - type of configuration. every messaging library has its own convention.\r\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\r\n\r\n    // @notice get the send() LayerZero messaging library version\r\n    // @param _userApplication - the contract address of the user application\r\n    function getSendVersion(address _userApplication) external view returns (uint16);\r\n\r\n    // @notice get the lzReceive() LayerZero messaging library version\r\n    // @param _userApplication - the contract address of the user application\r\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\r\n}\r\n\r\n/******************************************/\r\n/*     ILayerZeroReceiver starts here     */\r\n/******************************************/\r\n\r\ninterface ILayerZeroReceiver {\r\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\r\n    // @param _srcChainId - the source endpoint identifier\r\n    // @param _srcAddress - the source sending contract address from the source chain\r\n    // @param _nonce - the ordered message nonce\r\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\r\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\r\n}\r\n\r\n/******************************************/\r\n/*        IAltitudeFee starts here        */\r\n/******************************************/\r\n\r\ninterface IAltitudeFee {\r\n    // @notice query the rebalance fee based on local liquidity.\r\n    // @param idealBalance - the balance where local and remote liquidity pools are at equilibrium.\r\n    // @param preBalance - balance of local liquidity pool before removal of liquidity.\r\n    // @param amount - liquidity to be withdrawn from local liquidity pool.\r\n    function getRebalanceFee(uint256 idealBalance, uint256 preBalance, uint256 amount) external view returns (uint256);\r\n\r\n    // @notice query the parameters used to calculate the rebalance fee.\r\n    function getFeeParameters() external view returns (uint256, uint256, uint256, uint256, uint256);\r\n}\r\n\r\n/******************************************/\r\n/*          ILpToken starts here          */\r\n/******************************************/\r\n\r\ninterface ILpToken {\r\n    // @notice mint new LP tokens.\r\n    // @param _to - address to mint new LP tokens to.\r\n    // @param _amount - amount of LP tokens to mint.\r\n    function mint(address _to, uint256 _amount) external;\r\n\r\n    // @notice burn existing LP tokens.\r\n    // @param _from - address to burn existing LP tokens from.\r\n    // @param _amount - amount of LP tokens to burn.\r\n    function burn(address _from, uint256 _amount) external;\r\n}\r\n\r\n/******************************************/\r\n/*          IFactory starts here          */\r\n/******************************************/\r\n\r\ninterface IFactory {\r\n    // @notice deploy a LP token contract for a new chain path.\r\n    // @param _name - name of the LP token.\r\n    // @param _symbol - symbol of the LP token.\r\n    function newLpToken(string memory _name, string memory _symbol) external returns (address);\r\n}\r\n\r\n/******************************************/\r\n/*          ALTITUDE starts here          */\r\n/******************************************/\r\n\r\ncontract Altitude is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // CONSTANTS  \r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\r\n    uint8 internal constant TYPE_SWAP = 1;\r\n    uint8 internal constant TYPE_SWAP_CONFIRM = 2;\r\n    uint8 internal constant TYPE_SWAP_REVOKE = 3;\r\n    uint8 internal constant TYPE_ADD_LIQUIDITY = 4;\r\n    uint8 internal constant TYPE_REMOVE_LIQUIDITY_LOCAL = 5;\r\n    uint8 internal constant TYPE_REMOVE_LIQUIDITY_REMOTE = 6;\r\n    uint8 internal constant TYPE_REMOVE_LIQUIDITY_REMOTE_CONFIRM = 7;\r\n    uint8 internal constant TYPE_REMOVE_LIQUIDITY_REMOTE_REVOKE = 8;\r\n\r\n\r\n    // STRUCTS\r\n    struct ChainPath {\r\n        bool ready;\r\n        address srcToken;\r\n        uint16 dstChainId;\r\n        address dstToken;\r\n        uint256 remoteLiquidity;\r\n        uint256 localLiquidity;\r\n        uint256 rewardPoolSize;\r\n        address lpToken;\r\n        bool stopSwap;\r\n    }\r\n\r\n    struct PendingTx {\r\n        uint8 txType;\r\n        //ChainPath cp;\r\n        uint16 dstChainId;\r\n        address dstToken;\r\n        uint256 amount;\r\n        bytes from;\r\n    }\r\n\r\n    ILayerZeroEndpoint public layerZeroEndpoint;\r\n    IAltitudeFee public altitudeFee;\r\n    IFactory public altitudeFactory;\r\n    ChainPath[] public chainPaths;\r\n    address public feeTo;\r\n    mapping(uint16 => mapping(address => uint256)) public chainPathIndexLookup; // lookup for chainPath by chainId => token => index\r\n    mapping(uint16 => mapping(uint8 => uint256)) public gasLookup;              // lookup for gas fee by chainId => function => gas\r\n    mapping(uint16 => bytes) public trustedRemoteLookup;\r\n    mapping(address => PendingTx[]) public pendingTransactions;\r\n\r\n    // EVENTS\r\n    event Swap(uint16 _dstChainId, address _dstToken, uint256 _amount, bytes _to);\r\n    event Remote_Swap(uint16 _srcChainId, address _srcToken, uint256 _amount, address _to);\r\n    event Swap_Confirm(uint16 _dstChainId, address _dstToken, uint256 _amount, address _to, uint256 _rebalanceReward, uint256 _rebalanceFee, uint256 _protocolFee);\r\n    event Swap_Revoke(uint16 _dstChainId, address _dstToken, uint256 _amount, address _to);\r\n    event Callback_Swap_Confirm(uint16 _srcChainId, address _srcToken, uint256 _amount, address _to, uint256 _rebalanceFee, uint256 _protocolFee);\r\n    event Callback_Swap_Revoke(uint16 _srcChainId, address _srcToken, uint256 _amount, address _to);\r\n    event AddLiquidity(uint16 _dstChainId, address _dstToken, uint256 _amount);\r\n    event Remote_AddLiquidity(uint16 _srcChainId, address _srcToken, uint256 _amount);\r\n    event RemoveLiquidityLocal(uint16 _dstChainId, address _dstToken, uint256 _amount);\r\n    event Remote_RemoveLiquidityLocal(uint16 _srcChainId, address _srcToken, uint256 _amount);\r\n    event RemoveLiquidityRemote(uint16 _dstChainId, address _dstToken, uint256 _amount, address _to);\r\n    event Remote_RemoveLiquidityRemote(uint16 _srcChainId, address _srcToken, uint256 _amount, address _to);\r\n    event RemoveLiquidityRemote_Confirm(uint16 _dstChainId, address _dstToken, uint256 _amount, address _to);\r\n    event RemoveLiquidityRemote_Revoke(uint16 _dstChainId, address _dstToken, uint256 _amount, address _to);\r\n    event Callback_RemoveLiquidityRemote_Confirm(uint16 _srcChainId, address _srcToken, uint256 _amount, address _to);\r\n    event Callback_RemoveLiquidityRemote_Revoke(uint16 _srcChainId, address _srcToken, uint256 _amount, address _to);\r\n\r\n    constructor(address _endpoint, address _altitudeFee, address _altitudeFactory) {\r\n        layerZeroEndpoint = ILayerZeroEndpoint(_endpoint);\r\n        altitudeFee = IAltitudeFee(_altitudeFee);\r\n        altitudeFactory = IFactory(_altitudeFactory);\r\n    }\r\n\r\n/******************************************/\r\n/*           ADMIN starts here            */\r\n/******************************************/\r\n\r\n    /**\r\n     * @dev Add a new chain and token pair for swapping.\r\n     * @param _srcToken Token on the local chain.\r\n     * @param _dstChainId Destination chain ID.\r\n     * @param _dstToken Token on the destination chain.\r\n     * @param _name Name of the associated LP token.\r\n     * @param _symbol Symbol of the associated LP token.\r\n     */\r\n    function addChainPath(address _srcToken, uint16 _dstChainId, address _dstToken, string memory _name, string memory _symbol) external onlyOwner {\r\n        for (uint256 i = 0; i < chainPaths.length; ++i) {\r\n            ChainPath memory cp = chainPaths[i];\r\n            bool exists = cp.dstChainId == _dstChainId && cp.dstToken == _dstToken;\r\n            require(!exists, \"Altitude: cant createChainPath of existing _dstChainId and _dstToken\");\r\n        }\r\n        chainPathIndexLookup[_dstChainId][_dstToken] = chainPaths.length;\r\n        address lpToken = altitudeFactory.newLpToken(_name, _symbol);\r\n        chainPaths.push(ChainPath(false, _srcToken, _dstChainId, _dstToken, 0, 0, 0, lpToken, false));\r\n    }\r\n\r\n    /**\r\n     * @dev Enable swapping for a chain and token pair.\r\n     * @param _dstChainId Destination chain ID.\r\n     * @param _dstToken Token on the destination chain.\r\n     */\r\n    function activateChainPath(uint16 _dstChainId, address _dstToken) external onlyOwner {\r\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        require(cp.ready == false, \"Altitude: chainPath is already active\");\r\n        // this func will only be called once\r\n        cp.ready = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the Alititude contract for a destination chain.\r\n     * @param _dstChainId Destination chain ID.\r\n     * @param _dstAltitudeAddress Address of the Altitude contract at the destination chain.\r\n     */\r\n    function setTrustedRemoteLookup(uint16 _dstChainId, bytes calldata _dstAltitudeAddress) external onlyOwner {\r\n        trustedRemoteLookup[_dstChainId] = abi.encodePacked(_dstAltitudeAddress, address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Set the gas limit for a function type at a destination chain.\r\n     * @param _dstChainId Destination chain ID.\r\n     * @param _functionType Target function (SWAP, ADD, REMOVE, REDEEM).\r\n     * @param _gasAmount Gas limit used by the target function.\r\n     */\r\n    function setGasAmount(uint16 _dstChainId, uint8 _functionType, uint256 _gasAmount) external onlyOwner {\r\n        require(_functionType >= 1 && _functionType <= 8, \"Altitude: invalid _functionType\");\r\n        gasLookup[_dstChainId][_functionType] = _gasAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Deposit into chain path's reward pool.\r\n     * @param _dstChainId Destination chain ID.\r\n     * @param _dstToken Token on the destination chain.\r\n     * @param _amount Amount of reward tokens to deposit.\r\n     */\r\n    function depositRewardPool(uint16 _dstChainId, address _dstToken, uint256 _amount) external onlyOwner {\r\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        IERC20(cp.srcToken).transferFrom(msg.sender, address(this), _amount);\r\n        cp.rewardPoolSize += _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw from chain path's reward pool.\r\n     * @param _dstChainId Destination chain ID.\r\n     * @param _dstToken Token on the destination chain.\r\n     * @param _amount Amount of reward tokens to withdraw.\r\n     */\r\n    function withdrawRewardPool(uint16 _dstChainId, address _dstToken, uint256 _amount, address _to) external onlyOwner {\r\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstToken);  \r\n        require(cp.rewardPoolSize >= _amount, \"Altitude: not enough funds in reward pool.\");\r\n        IERC20(cp.srcToken).transferFrom(address(this), _to, _amount);\r\n        cp.rewardPoolSize -= _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the protocol fee receiving address.\r\n     */\r\n    function setFeeTo(address _feeTo) external onlyOwner {\r\n        require(_feeTo != address(0), \"Altitude: recipient can't be zero address.\");\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the address of the fee calculation contract.\r\n     */\r\n    function setFeeContract(address _newFeeContract) external onlyOwner {\r\n        altitudeFee = IAltitudeFee(_newFeeContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Disable swaps for a specific chain path.\r\n     */\r\n    function emergencyStopSwap(uint16 _dstChainId, address _dstToken, bool _enable) external onlyOwner {\r\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        cp.stopSwap = _enable;\r\n    }\r\n\r\n/******************************************/\r\n/*           LOCAL starts here            */\r\n/******************************************/\r\n\r\n    /**\r\n     * @dev Swap local tokens for tokens on another chain.\r\n     * @param _dstChainId ID of destination chain.\r\n     * @param _dstToken Address of token on the destination chain (in).\r\n     * @param _amount Amount of tokens to swap.\r\n     * @param _addressOnDst Address of recipient on the destination chain.\r\n     */\r\n    function swap(uint16 _dstChainId, address _dstToken, uint256 _amount, uint256 _nativeForDst, bytes memory _addressOnDst) external nonReentrant payable {\r\n        // (1) LOCAL:                                                              (Tokens IN)                     \r\n        // (2) REMOTE CONFIRM:      remoteLiquidity ++      localLiquidity --      (Tokens OUT)     \r\n        //     LOCAL CONFIRM:       remoteLiquidity --      localLiquidity ++\r\n        //     REMOTE REVOKE:           \r\n        //     LOCAL REVOKE:                                                       (Tokens OUT)  \r\n        address dstNativeAddr;\r\n        {\r\n            bytes memory dstNativeAddrBytes = _addressOnDst;\r\n            assembly {\r\n                dstNativeAddr := mload(add(dstNativeAddrBytes, 20))\r\n            }\r\n        }\r\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        require(dstNativeAddr != address(0x0), \"Altitude: swap to zero address.\");\r\n        require(cp.remoteLiquidity >= _amount, \"Altitude: not enough liquidity\");\r\n        require(cp.stopSwap == false, \"Altitude: swaps disabled.\");\r\n        // Deposit tokens without increasing local liquidity to prevent loss of funds in unconfirmed swap.\r\n        IERC20(cp.srcToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        bytes memory payload = abi.encode(TYPE_SWAP, abi.encodePacked(cp.srcToken), _amount, _addressOnDst, abi.encodePacked(msg.sender));\r\n        executeLayerZero(TYPE_SWAP, cp, payload, _nativeForDst , _addressOnDst);\r\n\r\n        emit Swap(_dstChainId, _dstToken, _amount, _addressOnDst);\r\n    }\r\n\r\n    /**\r\n     * @dev Add liquidity for swaps.\r\n     * @param _dstChainId ID of destination chain.\r\n     * @param _dstToken Address of token on the destination chain.\r\n     * @param _amount Amount of tokens to add as liquidity.\r\n     */\r\n    function addLiquidity(uint16 _dstChainId, address _dstToken, uint256 _amount) external nonReentrant payable {\r\n        //     LOCAL:               localLiquidity ++      (Tokens IN / LP Tokens OUT)               \r\n        //     REMOTE:              remoteLiquidity ++        \r\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        require(cp.ready == true, \"Altitude: chainPath is not active\");\r\n\r\n        IERC20(cp.srcToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n        ILpToken(cp.lpToken).mint(msg.sender, _amount);\r\n        cp.localLiquidity += _amount;\r\n\r\n        bytes memory payload = abi.encode(TYPE_ADD_LIQUIDITY, abi.encodePacked(cp.srcToken), _amount);\r\n        executeLayerZero(TYPE_ADD_LIQUIDITY, cp, payload, 0 , \"\");\r\n\r\n        emit AddLiquidity(_dstChainId, _dstToken, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove local liquidity for swaps.\r\n     * @param _dstChainId ID of destination chain.\r\n     * @param _dstToken Address of token on the destination chain.\r\n     * @param _amount Amount of tokens to remove from liquidity.\r\n     */\r\n    function removeLiquidityLocal(uint16 _dstChainId, address _dstToken, uint256 _amount) external nonReentrant payable {\r\n        //     LOCAL:               localLiquidity --      (Tokens OUT / LP Tokens BURN)               \r\n        //     REMOTE:              remoteLiquidity --  \r\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        require(cp.localLiquidity >= _amount, \"Altitude: not enough liquidity\");\r\n\r\n        ILpToken(cp.lpToken).burn(msg.sender, _amount);\r\n        cp.localLiquidity -= _amount;\r\n        IERC20(cp.srcToken).safeTransfer(msg.sender, _amount);\r\n\r\n        bytes memory payload = abi.encode(TYPE_REMOVE_LIQUIDITY_LOCAL, abi.encodePacked(cp.srcToken), _amount);\r\n        executeLayerZero(TYPE_REMOVE_LIQUIDITY_LOCAL, cp, payload, 0 , \"\");\r\n\r\n        emit RemoveLiquidityLocal(_dstChainId, _dstToken, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove remote liquidity for swaps.\r\n     * @param _dstChainId ID of destination chain.\r\n     * @param _dstToken Address of token on the destination chain (in).\r\n     * @param _amount Amount of tokens to remove from liquidity.\r\n     */\r\n    function removeLiquidityRemote(uint16 _dstChainId, address _dstToken, uint256 _amount, uint256 _nativeForDst, bytes memory _addressOnDst) external nonReentrant payable {\r\n        // (1) LOCAL:                                                              (LP Tokens IN)                     \r\n        // (2) REMOTE CONFIRM:                              localLiquidity --      (Tokens OUT)     \r\n        //     LOCAL CONFIRM:       remoteLiquidity --      \r\n        //     REMOTE REVOKE:                                                      (LP Tokens OUT)\r\n        //     LOCAL REVOKE:                                                       (LP Tokens BURN) \r\n        address dstNativeAddr;\r\n        {\r\n            bytes memory dstNativeAddrBytes = _addressOnDst;\r\n            assembly {\r\n                dstNativeAddr := mload(add(dstNativeAddrBytes, 20))\r\n            }\r\n        }\r\n        ChainPath storage cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        require(dstNativeAddr != address(0x0), \"Altitude: withdrawal to zero address.\");\r\n        require(cp.localLiquidity < _amount, \"Altitude: sufficient local liquidity\");\r\n        require(cp.remoteLiquidity >= _amount, \"Altitude: not enough liquidity\");\r\n        require(IERC20(cp.lpToken).balanceOf(msg.sender) >= _amount, \"Altitude: not enough LP tokens\");\r\n        // Burn LP Tokens only after confirmation to prevent loss of funds in unconfirmed withdrawal.\r\n        IERC20(cp.lpToken).safeTransferFrom(msg.sender, address(this), _amount);\r\n        \r\n        bytes memory payload = abi.encode(TYPE_REMOVE_LIQUIDITY_REMOTE, abi.encodePacked(cp.srcToken), _amount, _addressOnDst, abi.encodePacked(msg.sender));\r\n        executeLayerZero(TYPE_REMOVE_LIQUIDITY_REMOTE, cp, payload, _nativeForDst, _addressOnDst);\r\n        \r\n        emit RemoveLiquidityRemote(_dstChainId, _dstToken, _amount, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Confirm swap or withdrawal.\r\n     * @param _Id Id of pending swap or withdrawal.\r\n     */\r\n    function confirmPendingTransaction(uint256 _Id) external nonReentrant payable {\r\n        PendingTx storage pt = pendingTransactions[msg.sender][_Id];\r\n        ChainPath storage cp = getAndCheckCP(pt.dstChainId, pt.dstToken);\r\n\r\n        // SWAP REMOTE CONFIRM\r\n        if (pt.txType == TYPE_SWAP) {\r\n            require(cp.localLiquidity >= pt.amount, \"Altitude: not enough liquidity\");\r\n            // rebalance fee applies when swap moves local liquidity away from liquidity equilibrium. Deposit into local reward pool.\r\n            (uint256 rebalanceFee, uint256 protocolFee) = getFees(cp.dstChainId, cp.dstToken, pt.amount);\r\n            uint256 swapAmount = pt.amount - (rebalanceFee + protocolFee);\r\n            // rebalance reward applies when swap moves local liquidity to liquidity equilibrium. Disburse from local reward pool.\r\n            uint256 rebalanceReward = getRebalanceReward(cp.dstChainId, cp.dstToken, pt.amount);\r\n            cp.rewardPoolSize -= rebalanceReward;\r\n            cp.localLiquidity -= swapAmount;\r\n            cp.remoteLiquidity += swapAmount;\r\n            IERC20(cp.srcToken).safeTransfer(msg.sender, swapAmount + rebalanceReward);\r\n            bytes memory payload = abi.encode(TYPE_SWAP_CONFIRM, abi.encodePacked(cp.srcToken), pt.amount, rebalanceFee, protocolFee, abi.encodePacked(msg.sender));\r\n            executeLayerZero(TYPE_SWAP_CONFIRM, cp, payload, 0 , \"\");\r\n\r\n            emit Swap_Confirm(cp.dstChainId, cp.dstToken, swapAmount, msg.sender, rebalanceReward, rebalanceFee, protocolFee);\r\n        // REMOVE LIQUIDITY REMOTE CONFIRM\r\n        } else if (pt.txType == TYPE_REMOVE_LIQUIDITY_REMOTE) {\r\n            require(cp.localLiquidity >= pt.amount, \"Altitude: not enough liquidity\");\r\n            cp.localLiquidity -= pt.amount;\r\n            IERC20(cp.srcToken).safeTransfer(msg.sender, pt.amount);\r\n            bytes memory payload = abi.encode(TYPE_REMOVE_LIQUIDITY_REMOTE_CONFIRM, abi.encodePacked(cp.srcToken), pt.amount, abi.encodePacked(msg.sender));\r\n            executeLayerZero(TYPE_REMOVE_LIQUIDITY_REMOTE_CONFIRM, cp, payload, 0 , \"\");\r\n\r\n            emit RemoveLiquidityRemote_Confirm(cp.dstChainId, cp.dstToken, pt.amount, msg.sender);\r\n        }\r\n        uint256 arrayLength = pendingTransactions[msg.sender].length;\r\n        pendingTransactions[msg.sender][_Id] = pendingTransactions[msg.sender][arrayLength -1];\r\n        pendingTransactions[msg.sender].pop();\r\n    }\r\n\r\n    /**\r\n     * @dev Revoke swap or withdrawal.\r\n     * @param _Id Id of pending swap or withdrawal.\r\n     */\r\n    function revokePendingTransaction(uint256 _Id) external nonReentrant payable {\r\n        PendingTx storage pt = pendingTransactions[msg.sender][_Id];\r\n        ChainPath storage cp = getAndCheckCP(pt.dstChainId, pt.dstToken);\r\n\r\n        // SWAP REMOTE REVOKE\r\n        if (pt.txType == TYPE_SWAP) {\r\n            bytes memory payload = abi.encode(TYPE_SWAP_REVOKE, abi.encodePacked(cp.srcToken), pt.amount, pt.from);\r\n            executeLayerZero(TYPE_SWAP_REVOKE, cp, payload, 0 , \"\");\r\n\r\n            emit Swap_Revoke(cp.dstChainId, cp.dstToken, pt.amount, msg.sender);\r\n        // REMOVE LIQUIDITY REMOTE REVOKE\r\n        } else if (pt.txType == TYPE_REMOVE_LIQUIDITY_REMOTE) {\r\n            bytes memory payload = abi.encode(TYPE_REMOVE_LIQUIDITY_REMOTE_REVOKE, abi.encodePacked(cp.srcToken), pt.amount, pt.from);\r\n            executeLayerZero(TYPE_REMOVE_LIQUIDITY_REMOTE_REVOKE, cp, payload, 0, \"\");\r\n\r\n            emit RemoveLiquidityRemote_Revoke(cp.dstChainId, cp.dstToken, pt.amount, msg.sender);\r\n        }\r\n        uint256 arrayLength = pendingTransactions[msg.sender].length;\r\n        pendingTransactions[msg.sender][_Id] = pendingTransactions[msg.sender][arrayLength -1];\r\n        pendingTransactions[msg.sender].pop();\r\n    }\r\n\r\n    /**\r\n     * @dev Route messages containing a target to LayerZero.\r\n     */\r\n    function executeLayerZero(uint8 functionType, ChainPath storage cp, bytes memory payload, uint256 nativeForDst, bytes memory addressOnDst) internal {\r\n        bytes memory adapterParams = getAndCheckGasFee(functionType, cp.dstChainId, payload, nativeForDst, addressOnDst);\r\n        layerZeroEndpoint.send{value: msg.value}(cp.dstChainId, trustedRemoteLookup[cp.dstChainId], payload, payable(msg.sender), address(this), adapterParams);\r\n    }\r\n\r\n/******************************************/\r\n/*           REMOTE starts here           */\r\n/******************************************/\r\n\r\n    function lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 /*_nonce*/, bytes memory _payload) external override {\r\n        require(msg.sender == address(layerZeroEndpoint));\r\n        require(\r\n            _srcAddress.length == trustedRemoteLookup[_srcChainId].length && keccak256(_srcAddress) == keccak256(trustedRemoteLookup[_srcChainId]),\r\n            \"Altitude: Invalid source sender address. owner should call setTrustedSource() to enable source contract\"\r\n        );\r\n        \r\n        uint8 functionType;\r\n        assembly {\r\n            functionType := mload(add(_payload, 32))\r\n        }\r\n\r\n        // SWAP (DESTINATION)   \r\n        if (functionType == TYPE_SWAP) {\r\n            (, bytes memory token, uint256 amount, bytes memory to, bytes memory from) = abi.decode(_payload, (uint8, bytes, uint256, bytes, bytes));\r\n            address toAddress;\r\n            address srcTokenAddress;\r\n            assembly {\r\n                toAddress := mload(add(to, 20))\r\n                srcTokenAddress := mload(add(token, 20))\r\n            }\r\n            pendingTransactions[toAddress].push(PendingTx(TYPE_SWAP, _srcChainId, srcTokenAddress, amount, from));\r\n\r\n            emit Remote_Swap(_srcChainId, srcTokenAddress, amount, toAddress);\r\n\r\n        // SWAP CONFIRM (CALLBACK)\r\n        } else if (functionType == TYPE_SWAP_CONFIRM) {\r\n            (, bytes memory token, uint256 amount, uint256 rebalanceFee, uint256 protocolFee, bytes memory to) = abi.decode(_payload, (uint8, bytes, uint256, uint256, uint256, bytes));\r\n            address toAddress;\r\n            address srcTokenAddress;\r\n            assembly {\r\n                toAddress := mload(add(to, 20))\r\n                srcTokenAddress := mload(add(token, 20))\r\n            }\r\n            ChainPath storage cp = getAndCheckCP(_srcChainId, srcTokenAddress);\r\n            uint256 swapAmount = amount - (rebalanceFee + protocolFee);\r\n            cp.localLiquidity += swapAmount;\r\n            cp.remoteLiquidity -= swapAmount;\r\n            cp.rewardPoolSize += rebalanceFee;\r\n            IERC20(cp.srcToken).safeTransfer(feeTo, protocolFee);\r\n\r\n            emit Callback_Swap_Confirm(_srcChainId, srcTokenAddress, swapAmount, toAddress, rebalanceFee, protocolFee);\r\n        \r\n        // SWAP REVOKE (CALLBACK)  \r\n        } else if (functionType == TYPE_SWAP_REVOKE) {\r\n            (, bytes memory token, uint256 amount, bytes memory to) = abi.decode(_payload, (uint8, bytes, uint256, bytes));\r\n            address toAddress;\r\n            address srcTokenAddress;\r\n            assembly {\r\n                toAddress := mload(add(to, 20))\r\n                srcTokenAddress := mload(add(token, 20))\r\n            }\r\n            ChainPath storage cp = getAndCheckCP(_srcChainId, srcTokenAddress);\r\n            IERC20(cp.srcToken).safeTransfer(toAddress, amount);\r\n\r\n            emit Callback_Swap_Revoke(_srcChainId, srcTokenAddress, amount, toAddress);\r\n\r\n        // ADD LIQUIDITY (DESTINATION)      \r\n        } else if (functionType == TYPE_ADD_LIQUIDITY) {\r\n            (, bytes memory token, uint256 amount) = abi.decode(_payload, (uint8, bytes, uint256));\r\n            address srcTokenAddress;\r\n            assembly {\r\n                srcTokenAddress := mload(add(token, 20))\r\n            }\r\n            ChainPath storage cp = getAndCheckCP(_srcChainId, srcTokenAddress);\r\n            cp.remoteLiquidity += amount;\r\n\r\n            emit Remote_AddLiquidity(_srcChainId, srcTokenAddress, amount);\r\n\r\n        // REMOVE LIQUIDITY LOCAL (DESTINATION)     \r\n        } else if (functionType == TYPE_REMOVE_LIQUIDITY_LOCAL) {\r\n            (, bytes memory token, uint256 amount) = abi.decode(_payload, (uint8, bytes, uint256));\r\n            address srcTokenAddress;\r\n            assembly {\r\n                srcTokenAddress := mload(add(token, 20))\r\n            }\r\n            ChainPath storage cp = getAndCheckCP(_srcChainId, srcTokenAddress);\r\n            cp.remoteLiquidity -= amount;\r\n\r\n            emit Remote_RemoveLiquidityLocal(_srcChainId, srcTokenAddress, amount);\r\n\r\n        // REMOVE LIQUIDITY REMOTE (DESTINATION) \r\n        } else if (functionType == TYPE_REMOVE_LIQUIDITY_REMOTE) {\r\n            (, bytes memory token, uint256 amount, bytes memory to, bytes memory from) = abi.decode(_payload, (uint8, bytes, uint256, bytes, bytes));\r\n            address toAddress;\r\n            address srcTokenAddress;\r\n            assembly {\r\n                toAddress := mload(add(to, 20))\r\n                srcTokenAddress := mload(add(token, 20))\r\n            }\r\n            pendingTransactions[toAddress].push(PendingTx(TYPE_REMOVE_LIQUIDITY_REMOTE, _srcChainId, srcTokenAddress, amount, from));\r\n\r\n            emit Remote_RemoveLiquidityRemote(_srcChainId, srcTokenAddress, amount, toAddress);\r\n\r\n        // REMOVE LIQUIDITY REMOTE CONFIRM (CALLBACK)\r\n        } else if (functionType == TYPE_REMOVE_LIQUIDITY_REMOTE_CONFIRM) {\r\n            (, bytes memory token, uint256 amount, bytes memory to) = abi.decode(_payload, (uint8, bytes, uint256, bytes));\r\n            address toAddress;\r\n            address srcTokenAddress;\r\n            assembly {\r\n                toAddress := mload(add(to, 20))\r\n                srcTokenAddress := mload(add(token, 20))\r\n            }\r\n            ChainPath storage cp = getAndCheckCP(_srcChainId, srcTokenAddress);\r\n            cp.remoteLiquidity -= amount;\r\n            ILpToken(cp.lpToken).burn(address(this), amount);\r\n\r\n            emit Callback_RemoveLiquidityRemote_Confirm(_srcChainId, srcTokenAddress, amount, toAddress);\r\n        \r\n        // REMOVE LIQUIDITY REMOTE REVOKE (CALLBACK)      \r\n        } else if (functionType == TYPE_REMOVE_LIQUIDITY_REMOTE_REVOKE) {\r\n            (, bytes memory token, uint256 amount, bytes memory to) = abi.decode(_payload, (uint8, bytes, uint256, bytes));\r\n            address toAddress;\r\n            address srcTokenAddress;\r\n            assembly {\r\n                toAddress := mload(add(to, 20))\r\n                srcTokenAddress := mload(add(token, 20))\r\n            }\r\n            ChainPath storage cp = getAndCheckCP(_srcChainId, srcTokenAddress);\r\n            IERC20(cp.lpToken).transfer(toAddress, amount);\r\n\r\n            emit Callback_RemoveLiquidityRemote_Revoke(_srcChainId, srcTokenAddress, amount, toAddress);\r\n        }\r\n\r\n    }\r\n\r\n/******************************************/\r\n/*             FEE starts here            */\r\n/******************************************/\r\n\r\n    function getFees(uint16 _dstChainId, address _dstToken, uint256 _amount) public view returns (uint256 rebalanceFee, uint256 protocolFee) {\r\n        ChainPath memory cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        uint256 idealBalance = (cp.localLiquidity + cp.remoteLiquidity) / 2;\r\n        rebalanceFee = altitudeFee.getRebalanceFee(idealBalance, cp.localLiquidity, _amount);\r\n        (uint256 P,,,,) = altitudeFee.getFeeParameters();\r\n        protocolFee = _amount * P / 1e18;\r\n    }\r\n\r\n    function getRebalanceReward(uint16 _dstChainId, address _dstToken, uint256 _amount) public view returns (uint256 rebalanceReward) {\r\n        ChainPath memory cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        uint256 idealBalance = (cp.localLiquidity + cp.remoteLiquidity) / 2;\r\n        if (cp.remoteLiquidity < idealBalance) {\r\n            uint256 remoteLiquidityDeficit = idealBalance - cp.remoteLiquidity;\r\n            rebalanceReward = cp.rewardPoolSize * _amount / remoteLiquidityDeficit;\r\n            if (rebalanceReward > cp.rewardPoolSize) {\r\n                rebalanceReward = cp.rewardPoolSize;\r\n            }\r\n        } \r\n    }\r\n\r\n/******************************************/\r\n/*            VIEW starts here            */\r\n/******************************************/\r\n\r\n    function getAndCheckCP(uint16 _dstChainId, address _dstToken) internal view returns (ChainPath storage) {\r\n        require(chainPaths.length > 0, \"Altitude: no chainpaths exist\");\r\n        ChainPath storage cp = chainPaths[chainPathIndexLookup[_dstChainId][_dstToken]];\r\n        require(cp.dstChainId == _dstChainId && cp.dstToken == _dstToken, \"Altitude: local chainPath does not exist\");\r\n        return cp;\r\n    }\r\n\r\n    function getChainPath(uint16 _dstChainId, address _dstToken) external view returns (ChainPath memory) {\r\n        ChainPath memory cp = chainPaths[chainPathIndexLookup[_dstChainId][_dstToken]];\r\n        require(cp.dstChainId == _dstChainId && cp.dstToken == _dstToken, \"Altitude: local chainPath does not exist\");\r\n        return cp;\r\n    }\r\n\r\n    function getAndCheckGasFee(uint8 _type, uint16 _dstChainId, bytes memory _payload, uint256 _nativeForDst, bytes memory _addressOnDst) internal view returns (bytes memory adapterParams) {\r\n        adapterParams = txParamBuilder(_type, _dstChainId, _nativeForDst, _addressOnDst);\r\n        // get the fees we need to pay to LayerZero for message delivery\r\n        (uint256 nativeFee, ) = layerZeroEndpoint.estimateFees(_dstChainId, address(this), _payload, false, adapterParams);\r\n        require(msg.value >= nativeFee, \"Altitude: insufficient msg.value to pay to LayerZero for message delivery.\");\r\n    }\r\n\r\n    function quoteLayerZeroFee(uint8 _type, uint16 _dstChainId, address _dstToken, bytes memory _from, uint256 _nativeForDst, bytes memory _addressOnDst) external view returns (uint256) {\r\n        ChainPath memory cp = getAndCheckCP(_dstChainId, _dstToken);\r\n        bytes memory payload;\r\n        if(_type == 1 || _type == 6) {\r\n        payload = abi.encode(TYPE_SWAP, abi.encodePacked(cp.srcToken), 0, _addressOnDst, _from);\r\n        } else if (_type == 2) {\r\n        payload = abi.encode(TYPE_SWAP_CONFIRM, abi.encodePacked(cp.srcToken), 0, 0, 0, _addressOnDst);\r\n        } else if (_type == 3 || _type == 7 || _type == 8) {\r\n        payload = abi.encode(TYPE_SWAP_CONFIRM, abi.encodePacked(cp.srcToken), 0, _addressOnDst);\r\n        } else if (_type == 4 || _type == 5) {\r\n        payload = abi.encode(TYPE_ADD_LIQUIDITY, abi.encodePacked(cp.srcToken), 0);\r\n        }\r\n        bytes memory adapterParams = txParamBuilder(_type, _dstChainId, _nativeForDst, _addressOnDst);\r\n        // get the fees we need to pay to LayerZero for message delivery\r\n        (uint256 nativeFee, ) = layerZeroEndpoint.estimateFees(_dstChainId, address(this), payload, false, adapterParams);\r\n        return (nativeFee);\r\n    }\r\n\r\n    function txParamBuilder(uint8 _type, uint16 _dstChainId, uint256 _nativeForDst, bytes memory _addressOnDst) internal view returns (bytes memory) {\r\n        bytes memory adapterParams;\r\n        uint256 gasForDestinationLzReceive = gasLookup[_dstChainId][_type];\r\n        if (_nativeForDst > 0) {\r\n            adapterParams = txParamBuilderType2(gasForDestinationLzReceive, _nativeForDst, _addressOnDst);\r\n        } else {\r\n            adapterParams = txParamBuilderType1(gasForDestinationLzReceive);\r\n        }\r\n        return adapterParams;\r\n    }\r\n\r\n    function txParamBuilderType1(uint256 _gasAmount) internal pure returns (bytes memory) {\r\n        uint16 txType = 1;\r\n        return abi.encodePacked(txType, _gasAmount);\r\n    }\r\n\r\n    function txParamBuilderType2(uint256 _gasAmount, uint256 _dstNativeAmount, bytes memory _addressOnDst) internal pure returns (bytes memory) {\r\n        uint16 txType = 2;\r\n        return abi.encodePacked(txType, _gasAmount, _dstNativeAmount, _addressOnDst);\r\n    }\r\n\r\n    function viewPendingTx(address _user) public view returns (PendingTx[] memory) {\r\n        return (pendingTransactions[_user]);\r\n    }\r\n\r\n/******************************************/\r\n/*           CONFIG starts here           */\r\n/******************************************/\r\n\r\n    function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config) external override onlyOwner {\r\n        layerZeroEndpoint.setConfig(_version, _chainId, _configType, _config);\r\n    }\r\n\r\n    function setSendVersion(uint16 version) external override onlyOwner {\r\n        layerZeroEndpoint.setSendVersion(version);\r\n    }\r\n\r\n    function setReceiveVersion(uint16 version) external override onlyOwner {\r\n        layerZeroEndpoint.setReceiveVersion(version);\r\n    }\r\n\r\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\r\n        layerZeroEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\r\n    }\r\n\r\n    fallback() external payable {}\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_altitudeFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_altitudeFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Callback_RemoveLiquidityRemote_Confirm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Callback_RemoveLiquidityRemote_Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rebalanceFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"}],\"name\":\"Callback_Swap_Confirm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Callback_Swap_Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Remote_AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Remote_RemoveLiquidityLocal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Remote_RemoveLiquidityRemote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Remote_Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidityLocal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"RemoveLiquidityRemote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"RemoveLiquidityRemote_Confirm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"RemoveLiquidityRemote_Revoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_to\",\"type\":\"bytes\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rebalanceReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rebalanceFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"}],\"name\":\"Swap_Confirm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"Swap_Revoke\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"}],\"name\":\"activateChainPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_srcToken\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"addChainPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"altitudeFactory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"altitudeFee\",\"outputs\":[{\"internalType\":\"contract IAltitudeFee\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chainPathIndexLookup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chainPaths\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ready\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"remoteLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"localLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPoolSize\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stopSwap\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_Id\",\"type\":\"uint256\"}],\"name\":\"confirmPendingTransaction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"emergencyStopSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"gasLookup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"}],\"name\":\"getChainPath\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ready\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"remoteLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"localLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPoolSize\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stopSwap\",\"type\":\"bool\"}],\"internalType\":\"struct Altitude.ChainPath\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rebalanceFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getRebalanceReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rebalanceReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layerZeroEndpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingTransactions\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"txType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"from\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_from\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nativeForDst\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_addressOnDst\",\"type\":\"bytes\"}],\"name\":\"quoteLayerZeroFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityLocal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nativeForDst\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_addressOnDst\",\"type\":\"bytes\"}],\"name\":\"removeLiquidityRemote\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_Id\",\"type\":\"uint256\"}],\"name\":\"revokePendingTransaction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFeeContract\",\"type\":\"address\"}],\"name\":\"setFeeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_functionType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_gasAmount\",\"type\":\"uint256\"}],\"name\":\"setGasAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"setReceiveVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_dstAltitudeAddress\",\"type\":\"bytes\"}],\"name\":\"setTrustedRemoteLookup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nativeForDst\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_addressOnDst\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"trustedRemoteLookup\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewPendingTx\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"txType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"from\",\"type\":\"bytes\"}],\"internalType\":\"struct Altitude.PendingTx[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_dstToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Altitude", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003c2269811836af69497e5f486a85d7316753cf620000000000000000000000001d31b21fe28af5f73b8e8ae0c900504bbc7d151c000000000000000000000000d997841f20cbef49e8a2b1aadd3bb513914ab22d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3446222b936a6c05172ebbcc9f885f101b83cfcb60f108d7ada08582abb1158b"}