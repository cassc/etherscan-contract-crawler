{"SourceCode": "/*\n\n  /$$$$$$                                /$$                               \n /$$__  $$                              | $$                               \n| $$  \\__/  /$$$$$$   /$$$$$$   /$$$$$$ | $$ /$$   /$$                     \n| $$ /$$$$ /$$__  $$ /$$__  $$ /$$__  $$| $$| $$  | $$                     \n| $$|_  $$| $$$$$$$$| $$  \\ $$| $$  \\ $$| $$| $$  | $$                     \n| $$  \\ $$| $$_____/| $$  | $$| $$  | $$| $$| $$  | $$                     \n|  $$$$$$/|  $$$$$$$| $$$$$$$/|  $$$$$$/| $$|  $$$$$$$                     \n \\______/  \\_______/| $$____/  \\______/ |__/ \\____  $$                     \n                    | $$                     /$$  | $$                     \n                    | $$                    |  $$$$$$/                     \n                    |__/                     \\______/                      \n              /$$$$$$   /$$               /$$       /$$                    \n             /$$__  $$ | $$              | $$      |__/                    \n            | $$  \\__//$$$$$$    /$$$$$$ | $$   /$$ /$$ /$$$$$$$   /$$$$$$ \n            |  $$$$$$|_  $$_/   |____  $$| $$  /$$/| $$| $$__  $$ /$$__  $$\n             \\____  $$ | $$      /$$$$$$$| $$$$$$/ | $$| $$  \\ $$| $$  \\ $$\n             /$$  \\ $$ | $$ /$$ /$$__  $$| $$_  $$ | $$| $$  | $$| $$  | $$\n            |  $$$$$$/ |  $$$$/|  $$$$$$$| $$ \\  $$| $$| $$  | $$|  $$$$$$$\n             \\______/   \\___/   \\_______/|__/  \\__/|__/|__/  |__/ \\____  $$\n                                                                  /$$  \\ $$\n                                                                 |  $$$$$$/\n                                                                  \\______/ \n\n*/\n\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nabstract contract Roles is Ownable {\n\t/**\n\t * @dev keeps a key-value pair for all\n\t * the admins\n\t */\n    mapping(address => bool) private admins;\n    \n    /**\n     * @dev add the owner of the contract to\n     * admins\n     */\n    constructor() {\n        addToAdmins(_msgSender());\n    }\n\n    /**\n     * @dev creates a new admin by adding `_addr` to the \n     * key-value pair as true which will render this address\n     * to have supercow powers\n     */\n    function addToAdmins(address _addr) public onlyOwner {\n        admins[_addr] = true;\n    }\n    /**\n     * @dev sets `_addr` to `false` in the mapping which \n     * will render this to not have supercow powers anymore\n     */\n    function removeFromAdmins(address _addr) public onlyOwner {\n        admins[_addr] = false;\n    } \n    /**\n     * @dev a simple modifer to check if the current caller address \n     * of a any function using this modifier is in the mapping and \n     * is mapped to `true`. basically supercow powers people only area.\n     */\n    modifier isAdmin() {\n        require(admins[_msgSender()], \"Roles: This address is not an admin\");\n        _;\n    }\n}\n\ninterface GEOS20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\n\tfunction totalSupply() external view returns (uint256);\n\tfunction balanceOf(address wallet) external view returns(uint256);\n}\n\ninterface IUniswapV2Pair { \n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\tfunction totalSupply() external view returns (uint);\n\tfunction token1() external view returns (address);\n}\n\n\ncontract GeoStaking is Roles{\n\n\t/**\n\t * @dev pools are actually\n\t * momentaraly static, timley dyanmic\n\t * i.e: `lockTime` & `apy` might change\n\t * however, change is only applied\n\t * on new stakes not old ones\n\t */\n\tstruct Pool {\n\t\t// check existance\n\t\tbool exists;\n\t\t// maximum allowed in the pool\n\t\tuint256 maxAllowed;\n\t\t// current in the pool\n\t\tuint256 currentParticipation;\n\t\t// the APY dedicated to return\n\t\tuint256[] apy;\n\t\t// locktime on the pool\n\t\tuint256[] lockTimes;\n\t\t// minimum to stake on the pool\n\t\tuint256 minAllowed;\n\t\t// is an LP\n\t\tbool isLP;\n\t\t// address of token\n\t\taddress refTokenAddr;\n\t}\n\n\t/**\n\t * @dev each address will get\n\t * a structure for their stakes\n\t * although not completley effecient\n\t * in gas fees, is the best way to \n\t * track all possible stakes\n\t */\n\tstruct Stakes {\n\t\t// address reference for `ERC20` standard token\n\t\taddress stakingPool;\n\t\t// amount staked by the wallet\n\t\tuint256[] amountStaked;\n\t\t// the apy at the time of staking\n\t\tuint256[] roi;\n\t\t// the locktime+block.timestamp at the time of staking\n\t\tuint256[] unlockTimes;\n\t}\n\n\n\t/**\n\t * @dev a choice of locking times\n\t * between 15 days and 30 days\n\t */\n\tenum LOCKTIME {\n\t\tHALF,\n\t\tFULL\n\t}\n\n\tmapping(address => mapping(LOCKTIME => uint256)) _APYs;\n\tmapping(address => mapping(LOCKTIME => uint256)) _LTs;\n\t\n\n\n\t// to stake tokens you need to pay a small fee\n\tuint256 public stakingFee = 0.1 ether;\n\n\t// all the pool combined in a mapping\n\tmapping(address => Pool) private _pools;\n\n\t/**\n\t * @dev this serves so much better than a regular\n\t * mapping(address => mapping(address => uint256))\n\t * which is the standard for staking. This results in a\n\t * configurable staking pools, locktimes, and APY architicture.\n\t * any wallet that staked or will stake\n\t */\n\tmapping(address => Stakes[]) private _stakers;\n\n\t// keep track of all the fees being paid by the stakers\n\tuint256 private totalFees;\n\n\t// track all rewards\n\tuint256 private _totalRewards;\n\n\t// track all staked\n\tuint256 private _totalStaked;\n\n\tuint256 private _liqOfStake;\n\n\tuint256 private _Nexcess;\n\n\tfunction _getLocktime(address pool, LOCKTIME opt) internal view returns(uint256) {\n\t\treturn(_LTs[pool][opt]);\n\t}\n\n\t// internal transfer `ERC20` standard tokens into the contract for the staking\n\tfunction _pullTokens(address sender, address tokenAddr, uint256 tokenAmount) internal returns(bool){\n\t\trequire(GEOS20(tokenAddr).allowance(sender, address(this)) >= tokenAmount, \"You need to approve us to stake your tokens\");\n\t\trequire(GEOS20(tokenAddr).transferFrom(sender, address(this), tokenAmount), \"You need to transfer the tokens to stake them\");\n\t\treturn true;\n\t}\n\n\tfunction getStakes(address staker, address pool) external view returns(Stakes memory _stake){\n\t\trequire(_poolExists(pool), \"pool does not exist\");\n\t\tfor (uint256 i=0; i<_stakers[staker].length; i++){\n\t\t\tif(_stakers[staker][i].stakingPool == pool){\n\t\t\t\t_stake = _stakers[staker][i];\n\t\t\t}\n\t\t}\n\t}\n\n\t// internal transfer `ERC20` standard tokens from the contract into the staker as a payment (original + profit)\n\tfunction _pushTokens(address sender, address tokenAddr, uint256 tokenAmount) internal returns(bool){\n\t\trequire(GEOS20(tokenAddr).balanceOf(address(this)) >= tokenAmount, \"Balance of contract less than requested, please wait for next epoch\");\n\t\trequire(GEOS20(tokenAddr).transfer(sender,tokenAmount), \"Cannot currently transfer any tokens\");\n\t\treturn true;\t\t\n\t}\n\n\t// internal returns the current timestamp + locktime of the pool\n\tfunction _getStakingTS(address pool, LOCKTIME ltopt) internal view returns(uint256){\n\t\tuint256 _lt = _LTs[pool][ltopt];\n\t\treturn((block.timestamp + _lt));\n\t}\n\n\t/**\n\t * parameters: {pool address `(ERC20 token)`}  \n\t * \n\t * @dev as each staking pool is capped at a maximum \n\t * we can retreive the maximum a wallet can stake\n\t * for any particular pool\n\t */\n\tfunction getMaxAllowed(address pool) public view returns(uint256) {\n\t\trequire(_pools[pool].exists, \"This Pool Does not exist\");\n\t\treturn ((_pools[pool].maxAllowed - _pools[pool].currentParticipation));\n\t}\n\n\t/**\n\t * parameters: {pool address `(ERC20 token)`}  \n\t * \n\t * @dev get the current staked amount by all wallets \n\t * in one pool, by providing the address of the pool\n\t * throws if pool doesn't exist\n\t */\n\tfunction getCurrentStaked(address pool) public view returns(uint256){\n\t\trequire(_pools[pool].exists, \"this pool does not exist\");\n\t\treturn(_pools[pool].currentParticipation);\n\t}\n\n\t/**\n\t * parameters: {pool address `(ERC20 token)`} \n\t * \n\t * @dev get the current Annual Percentage Yeild (APY) of any pool\n\t * throws if pool doesn't exist\n\t */\n\tfunction getStakingReturn(address pool, LOCKTIME lockTime) public view returns(uint256){\n\t\trequire(_pools[pool].exists, \"this pool does not exist\");\n\t\tuint256 _sr = _APYs[pool][lockTime];\n\t\treturn(_sr);\n\t}\n\n\tfunction _canStakeWithCurrentLiquidity(address pool, LOCKTIME ltopt, uint256 amount) internal returns(bool){\n\t\tbool _isLP = _isLiquidityPool(pool);\n\t\taddress _refAddr = _getRefTokenAddr(pool);\n\t\tuint256 _tbr = _calcReturn(amount, getStakingReturn(pool, ltopt), _isLP , pool);\n\t\tuint256 bal = GEOS20(_refAddr).balanceOf(address(this));\n\t\tif(!_isLP){\n\t\t\t_tbr -= amount;\n\t\t}\n\t\tif((bal >= (_liqOfStake + _tbr))){\n\t\t\t_liqOfStake += _tbr;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * parameters: pool address (ERC20 token), amountToStake \n\t * \n\t * @dev checks if the current staked amount + the new amountToStake \n\t * is less than or equal to the maximum allowed for the pool in question\n\t * \n\t * internal => checks are required beforehand.\n\t */\n\tfunction _canStakeAmount(address pool, uint256 amount) internal view returns(bool){\n\t\tif((getCurrentStaked(pool)+amount <= getMaxAllowed(pool))){\n\t\t\treturn true;\n\t\t}\n\t  return false;\n\t}\n\n\t/**\n\t * parameters: pool address (ERC20 token)\n\t * \n\t * @dev checks if the current address corresponds to a pool\n\t */\n\tfunction _poolExists(address poolAddr) internal view returns(bool){\n\n\t\treturn(_pools[poolAddr].exists);\n\t}\n\n\t/**\n\t * parameters: pool address (ERC20 token), amount to convert\n\t * \n\t * @dev since each swap provides a different amount of LP tokens\n\t * it's safe to consider a general case where we check for the address\n\t * of the token either `token0` or `token1` and we calculate the returns\n\t * based on the ratio of the input amount * reserve in native token / the total supply to the lp.\n\t */\n\tfunction _getInGEOSFromLP(address pool, uint256 amount) public view returns(uint256) {\n\t\tuint112 _res = 0;\n\t\taddress _token1 = IUniswapV2Pair(pool).token1();\n\t\tuint _totalSupply = IUniswapV2Pair(pool).totalSupply();\n\t\t(uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(pool).getReserves();\n\t\tif (_getRefTokenAddr(pool) == _token1){\n\t\t\t_res = reserve1;\n\t\t}else{\n\t\t\t_res = reserve0;\n\t\t}\n\t\treturn(((amount*_res)/_totalSupply));\n\t}\n\n\t/**\n\t * parameters: address of staker, address of the pool\n\t * \n\t * @dev an intermiedtry function to send the staked tokens + profit back to the\n\t * wallet of which it was staked from.\n\t * throws if sending the tokens failed.\n\t */\n\tfunction returnStakes(address staker, address pool) internal returns(bool) {\n\t\t(uint256 _total, uint256 _nativeTotal) = totalReturnable(staker, pool);\n\t\trequire(_total > 0, \"Nothing to be returned yet.\");\n\t\tif(_isLiquidityPool(pool)){\n\t\t\trequire(_pushTokens(staker, pool, _nativeTotal), \"cannot allocate native pool tokens\");\n\t\t}\n\t\t_Nexcess += _total;\n\t\trequire(_pushTokens(staker, _getRefTokenAddr(pool), _total), \"cannot transfer GEOS20 tokens\");\n        return true;\n\t}\n\n\t/**\n\t * parameters: {amountStake uint256, APY(%) uint256, isAliquidityPoolAddress bool, pool address}, apy at the time of staking\n\t * \n\t * @dev calculates via a basic formula (amountStaked*AnnualPY)/12months\n\t */\n\tfunction _calcReturn(uint256 amount, uint256 annualPercentage, bool isALP, address pool) public view returns(uint256 finalAmount){\n\t\tuint256 _offset = 0;\n\t\tif(_APYs[pool][LOCKTIME.HALF] == annualPercentage){\n\t\t\t_offset = 24;\n\t\t}else{\n\t\t\t_offset = 12;\n\t\t}\n\t\tif (isALP){\n\t\t\tuint112 _res = 0;\n\t\t\taddress _token1 = IUniswapV2Pair(pool).token1();\n\t\t\tuint _totalSupply = IUniswapV2Pair(pool).totalSupply();\n\t\t\t(uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(pool).getReserves();\n\t\t\tif (_getRefTokenAddr(pool) == _token1){\n\t\t\t\t_res = reserve1;\n\t\t\t}else{\n\t\t\t\t_res = reserve0;\n\t\t\t}\n\t\t\tfinalAmount = ((amount*annualPercentage*_res)/(_offset*100*_totalSupply));\n\t\t}else{\n\t\t\tfinalAmount = (amount + ((amount*annualPercentage)/(_offset*100)));\n\t\t}\n\t}\n\n\t/**\n\t * parameters: pool address (ERC20 token), amount to remove\n\t * \n\t * @dev removes the staked amount from the currentParticpation\n\t * to keep track of the pool current staking\n\t * automatically throws if negative on uint256\n\t */\n\tfunction _removeFromPool(address pool, uint256 amountRemove) internal {\n\n\t\t_pools[pool].currentParticipation -= amountRemove;\n\t}\n\n\tfunction _removeFromStaker(address staker, address pool) internal returns(bool){\n\t\tuint256 currentTS = block.timestamp;\n\t\tfor(uint256 i=0; i<_stakers[staker].length; i++){\n\t\t\tif(_stakers[staker][i].stakingPool == pool){\n\t\t\t\tStakes storage _stake = _stakers[staker][i];\n\t\t\t\tfor(uint256 j=0; j<_stake.unlockTimes.length; j++){\n\t\t\t\t\tif(_stake.unlockTimes[j] <= currentTS){\n\t\t\t\t\t\t_removeFromPool(pool, _stake.amountStaked[j]);\n\t\t\t\t\t\t_stake.amountStaked[j] = 0;\n\t\t\t\t\t\t_stake.unlockTimes[j] = 0;\n\t\t\t\t\t\t_stake.roi[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t\n\t// checks if a contract address is a liquidity pool or not \n\tfunction _isLiquidityPool(address pool) internal view returns(bool){\n\n\t\treturn(_pools[pool].isLP);\n\t}\n\n\t// a simple XNOR gate\n\tfunction XNOR(bool A, bool B) internal pure returns(bool){\n\t\tif (A && B){\n\t\t\treturn true;\n\t\t}else if (!A && !B){\n\t\t\treturn true;\n\t\t}else { return false; }\n\t}\n\n\t// get the reference token address\n\tfunction _getRefTokenAddr(address pool) internal view returns(address){\n\n\t\treturn (_pools[pool].refTokenAddr);\n\t}\n\n\n\t/**\n\t * parameters: amount Added, current APY, unlocking timestamp\n\t * \n\t * @dev forms arrays in which will be added to Stakes[] of the wallet\n\t */\n    function _formArrays(uint256 amount, uint256 stakingROI, uint256 stakingTS) internal pure returns(uint256[] memory amnts, uint256[] memory stakesROI, uint256[] memory stakesTS){\n        amnts = new uint256[](1);\n\t\tstakesROI = new uint256[](1);\n\t\tstakesTS = new uint256[](1);\n\t\tamnts[0] = amount;\n        stakesROI[0] = stakingROI;\n        stakesTS[0] = stakingTS;\n    }\n\n\t/**\n\t * parameters: sender address, the Stakes index in the array, the amount to add\n\t * \n\t * @dev retreives the current Stakes by the address of the sender and access \n\t * the address of the staking pool to retreive information \n\t * adds the variables to their arrays respectivly `amountStaked, unlockTimes, roi`\n\t * throws if the amount to stake + current participation is above the max\n\t * throws if transfering the tokens of the contract returns false\n\t */\n\tfunction _addToStaking(address sender, uint256 stakesIdx, LOCKTIME lockTimeOption ,uint256 amount) internal returns(bool) {\n\t\tStakes storage _ogStake = _stakers[sender][stakesIdx];\n\t\taddress poolAddr = _ogStake.stakingPool;\n\t\trequire(_pullTokens(sender, poolAddr, amount), \"GEOS20: Transfer Failed\");\n\t\t_ogStake.amountStaked.push(amount);\n\t\t_ogStake.unlockTimes.push(_getStakingTS(poolAddr, lockTimeOption));\n\t\t_ogStake.roi.push(getStakingReturn(poolAddr, lockTimeOption));\n\t\tif(_isLiquidityPool(poolAddr)){\n\t\t\t_totalStaked += _getInGEOSFromLP(poolAddr, amount);\n\t\t}else{\n\t\t\t_totalStaked += amount;\n\t\t}\n\t\t_pools[poolAddr].currentParticipation += amount;\n\t\treturn true;\n\t}\n\n    /**\n     * parameters: sender address, address of the pool, the amount of staking\n     * \n     * @dev creates a new staking for the wallet of the address on the pool specified\n     * and appends to the array of Stakes[]\n     * throws if the amount to stake + current participation is equal to the max\n     */\n\tfunction _createNewStaking(address sender, address pool, LOCKTIME lockTimeOption , uint256 amount) internal returns(bool) {\n        (uint256[] memory a, uint256[] memory b, uint256[] memory c) = _formArrays(amount, getStakingReturn(pool, lockTimeOption), _getStakingTS(pool, lockTimeOption));\n\t\t_stakers[sender].push(Stakes(pool, a, b, c));\n\t\trequire(_pullTokens(sender, pool, amount), \"GEOS20: Transfer Failed\");\n\t\tif(_isLiquidityPool(pool)){\n\t\t\t_totalStaked += _getInGEOSFromLP(pool, amount);\n\t\t}else{\n\t\t\t_totalStaked += amount;\n\t\t}\n\t\t_pools[pool].currentParticipation += amount;\n\t\treturn true;\n\t}\n\n\t/**\n\t * { address wallet, address pool }\n\t * \n\t * @dev returns the total returnable at the current timestamp, returns 0 if no returns aval\n\t */\n\tfunction totalReturnable(address staker, address pool) public view returns(uint256 total, uint256 nativeTotal) {\n\t\tuint256 currentTS = block.timestamp;\n\t\tbool _lp = _isLiquidityPool(pool);\n\t\tfor(uint256 i=0; i<_stakers[staker].length; i++){\n\t\t\tif(_stakers[staker][i].stakingPool == pool){\n\t\t\t\tStakes memory _stake = _stakers[staker][i];\n\t\t\t\tfor(uint256 j=0; j<_stake.unlockTimes.length; j++){\n\t\t\t\t\tif(_stake.unlockTimes[j] <= currentTS){\n\t\t\t\t\t\ttotal += _calcReturn(_stake.amountStaked[j], _stake.roi[j], _lp, pool);\n\t\t\t\t\t\tnativeTotal += _stake.amountStaked[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn (total, nativeTotal);\t\n\t}\n\n\t/**\n\t * parameters: address of staker, address of the pool\n\t * \n\t * @dev returns the total staked amount of a particular pool specified\n\t * by the pool address\n\t * throws if pool doesnt exist.\n\t */\n\tfunction getTotalStakedAmount(address staker, address pool) public view returns(uint256 totalStaked){\n\t\trequire(_poolExists(pool), \"this pool does not exist\");\n\t\tfor(uint256 i=0; i<_stakers[staker].length; i++){\n\t\t\tif(_stakers[staker][i].stakingPool == pool){\n\t\t\t\tfor (uint256 j=0; j<_stakers[staker][i].amountStaked.length; j++){\n                    totalStaked += _stakers[staker][i].amountStaked[j];\n                }\n                break;\n\t\t\t}\n\t\t}\n\t}\n\n\t// get the pool properties from address\n\tfunction getPoolProps(address pool) external view returns(Pool memory){\n\t\trequire(_poolExists(pool), \"pool doesnt exist\");\n\t\treturn(_pools[pool]);\n\t}\n\n\t/**\n\t * parameters: address of the pool, amount to stake\n\t * \n\t * @dev external function to stake the tokens specified in _pools\n\t * throws if no payment of `StakingFee` to the contract\n\t * throws if pool does not exist\n\t * throws if the Stake exists and `_addToStaking` returns `false`\n\t * throws if the Stake does not exist and _createNewStaking returns `false`\n\t */\n\tfunction GeoStake(address pool, LOCKTIME lockTimeOption ,uint256 amount) external payable {\n\t\trequire(_poolExists(pool), \"This Staking Pool Does Not Exist\");\n\t\trequire(_canStakeAmount(pool, amount), \"Cannot Stake Above the maximum\");\n\t\trequire(_canStakeWithCurrentLiquidity(pool, lockTimeOption ,amount), \"No suffiecent liquidity to stake\");\n\t\trequire(msg.value >= stakingFee, \"Need to pay the fee for staking\");\n\t\tbool _didAdd = false;\n\t\ttotalFees += msg.value;\n\t\tStakes[] memory _ogStakes = _stakers[msg.sender];\n\t\tif(_ogStakes.length != 0 ){\n\t\t\tfor (uint256 i=0; i<_ogStakes.length; i++){\n\t\t\t\tif(_ogStakes[i].stakingPool == pool){\n\t\t\t\t\trequire(_addToStaking(msg.sender, i, lockTimeOption ,amount), \"Unable To Stake Currently\");\n\t\t\t\t\t_didAdd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!_didAdd){\n\t\t\t\trequire(_createNewStaking(msg.sender, pool, lockTimeOption ,amount), \"Unable To Stake currently\");\n\t\t\t\t_didAdd = true;\n\t\t\t}\n\t\t}else{\n\t\t\trequire(_createNewStaking(msg.sender, pool, lockTimeOption ,amount), \"Unable To Stake currently\");\n\t\t\t_didAdd = true;\n\t\t}\n\t\trequire(_didAdd, \"Unable to create a new staking instance\");\n\t}\n\n\t/**\n\t * parameters: address of the pool\n\t * \n\t * @dev returns the staked tokens + profit from staking\n\t * to msg.sender which had previously created a Stake in a supported pool\n\t * throws if pool does not exist\n\t * throws if staked amount is equal to 0\n\t * throws if the returned stakes throws\n\t */\n\tfunction GeoReturn(address pool) external {\n\t\trequire(returnStakes(msg.sender, pool), \"Currently cannot return stakes\");\n\t\trequire(_removeFromStaker(msg.sender, pool), \"Cannot evaluate post-unstaking amount\");\n\t}\n\n\t/**\n\t * parameters: pool address (ERC20 token), maximum allowed for staking, minimum allowed for staking, the locktime for any stake, the APY for the stake\n\t * \n\t * @dev initalizes a staking pool for the ERC20 token with the important features\n\t * throws if pool exists as it doesn't allow any overriding\n\t */\n\tfunction initPool(address pool, uint256 maximumStaking, uint256 minimumStaking, uint256[] memory lockTimesSeconds , uint256[] memory annualPercentageYeild, bool lp, address refAddr) external isAdmin {\n\t\trequire(!_poolExists(pool), \"Cannot Initalize An existing Pool\");\n\t\tif(lp){\n\t\t\trequire(pool != refAddr, \"To stake liquidity please provide the reference token\");\n\t\t}\n\t\t_pools[pool] = Pool(true, maximumStaking, uint256(0), annualPercentageYeild, lockTimesSeconds, minimumStaking, lp, refAddr);\n\t\t_APYs[pool][LOCKTIME.HALF] = annualPercentageYeild[0];\n\t\t_LTs[pool][LOCKTIME.HALF] =  lockTimesSeconds[0];\n\t\t_APYs[pool][LOCKTIME.FULL] = annualPercentageYeild[1];\n\t\t_LTs[pool][LOCKTIME.FULL] = lockTimesSeconds[1];\n\t}\n\n\t/**\n\t * parameters: address of the pool\n\t * \n\t * @dev removes a pool by reseting Pool() variables from the struct\n\t * throws if the pool still has participation \n\t * Can only remove if the currentparticipation is 0\n\t */\n\tfunction removePool(address pool) external isAdmin {\n\t\trequire(_poolExists(pool), \"This pool does not exist\");\n\t\trequire(getCurrentStaked(pool) == 0, \"This pool still has investments\");\n\t\tuint256[] memory _locktimes = new uint256[](0);\n\n\t\t_pools[pool] = Pool(false, uint256(0), uint256(0), _locktimes, _locktimes, uint256(0), false, address(0));\n\t}\n\n\t/**\n\t * @dev transfers the fees associated with Geostake\n\t * from the contract, this should not be something to worry\n\t * as it's implemented in uint256 value and not address(this).balance\n\t */\n\tfunction withdrawFees() external onlyOwner {\n\t\trequire(payable(msg.sender).send(totalFees));\n\t\ttotalFees = 0;\n\t}\n\n\t/**\n\t * parameters: new fee for staking\n\t * \n\t * @dev changes the fee associated with Geostake\n\t */\n\tfunction changeFee(uint256 newFee) external isAdmin {\n\n\t\tstakingFee = newFee;\n\t}\n\n\t/**\n\t * parameters:  pool address (ERC20 token), maximum allowed for staking, minimum allowed for staking, the locktime for any stake, the APY for the stake\n\t * \n\t * @dev edits the current pool for new parameters as this creates a configurable pool\n\t * however, everything is momentarly applied, i.e: when a person stakes they will get their staking done with the parameters specifed at the time of staking\n\t * throws if maximum allowed for staking is less than the current being staked\n\t * throws if the APY is 0 \n\t */\n\tfunction changePoolParams(address pool, uint256 maximumStaking, uint256 minimumStaking, uint256[] memory lockTimesSeconds, uint256[] memory annualPercentageYeild, bool lp, address refAddr) external isAdmin{\n\t \trequire(_poolExists(pool), \"Cannot Edit A Non-initalized Pool\");\n\t\trequire(XNOR(lp , _isLiquidityPool(pool)), \"Cannot change from an lp to a non-lp\");\n\t\trequire(_getRefTokenAddr(pool) == refAddr, \"Cannot change the reference address for an LP\");\n\t \tuint256 currentWalletStakes = getCurrentStaked(pool);\n\t \trequire(maximumStaking >= currentWalletStakes, \"The maximum of staking needs to be more than the currently staked\");\n\t\trequire(lockTimesSeconds.length == annualPercentageYeild.length, \"Array mismatch\");\n\t \t_pools[pool] = Pool(true, maximumStaking, currentWalletStakes, annualPercentageYeild, lockTimesSeconds, minimumStaking, lp, refAddr);\n\t\t_APYs[pool][LOCKTIME.HALF] = annualPercentageYeild[0];\n\t\t_LTs[pool][LOCKTIME.HALF] =  lockTimesSeconds[0];\n\t\t_APYs[pool][LOCKTIME.FULL] = annualPercentageYeild[1];\n\t\t_LTs[pool][LOCKTIME.FULL] = lockTimesSeconds[1];\n\t }\n\n\n\tfunction withdraw() external onlyOwner {\n\t\trequire(payable(msg.sender).send(address(this).balance));\n\t}\n\n\n\tfunction getExcess(address token) external view returns(uint256 removable, uint256 excess, uint256 original){\n\t\tuint256 _balance = GEOS20(token).balanceOf(address(this));\n\t\tremovable = _balance + _Nexcess - _liqOfStake;\n\t\texcess = _Nexcess;\n\t\toriginal = _liqOfStake;\n\t}\n\n\n\tfunction withdrawExcess(address token, uint256 amount) external onlyOwner{\n\t\tuint256 _balance = GEOS20(token).balanceOf(address(this));\n\t\tuint256 removable = _balance + _Nexcess - _liqOfStake;\n\t\tif(amount <= removable){\n\t\t\trequire(GEOS20(token).transfer(msg.sender, amount));\n\t\t}\n\t}\n\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"GeoReturn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"enum GeoStaking.LOCKTIME\",\"name\":\"lockTimeOption\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GeoStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"annualPercentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isALP\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"_calcReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_getInGEOSFromLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addToAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"lockTimesSeconds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"annualPercentageYeild\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"lp\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"refAddr\",\"type\":\"address\"}],\"name\":\"changePoolParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getCurrentStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getExcess\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"removable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"excess\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"original\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getMaxAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getPoolProps\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxAllowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentParticipation\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"apy\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"lockTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minAllowed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLP\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"refTokenAddr\",\"type\":\"address\"}],\"internalType\":\"struct GeoStaking.Pool\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakingPool\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amountStaked\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"roi\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"unlockTimes\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GeoStaking.Stakes\",\"name\":\"_stake\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"enum GeoStaking.LOCKTIME\",\"name\":\"lockTime\",\"type\":\"uint8\"}],\"name\":\"getStakingReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getTotalStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"lockTimesSeconds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"annualPercentageYeild\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"lp\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"refAddr\",\"type\":\"address\"}],\"name\":\"initPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeFromAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"removePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"totalReturnable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawExcess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GeoStaking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}