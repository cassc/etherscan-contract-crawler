{"SourceCode": "/*\r\n * AutoDoubleRewardsJackpot Token\r\n *\r\n * Written by: MrGreenCrypto\r\n * Co-Founder of CodeCraftrs.com\r\n * \r\n * SPDX-License-Identifier: None\r\n */\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IDEXPair {function sync() external;}\r\ninterface IHelper {\r\n    function giveMeMyMoneyBack(uint256 tax) external returns (bool);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);    \r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(address token,uint amountTokenDesired,uint amountTokenMin,uint amountETHMin,address to,uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n    \r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);    \r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;\r\n}\r\n\r\ncontract AutoDoubleRewardsJackpot is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 constant _decimals = 18;\r\n    uint256 _totalSupply;\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public limitless;\r\n    mapping(address => bool) public ai;\r\n    mapping(address => bool) public isExludedFromMaxWallet;\r\n    mapping(address => address) public chosenReward;\r\n\r\n    bool public renounced = false;\r\n\r\n    uint256 public tax;\r\n    uint256 public rewards = 1;\r\n    uint256 public liq = 1;\r\n    uint256 public marketing = 1;\r\n    uint256 public immutable ip;\r\n    uint256 public jackpot = 1;\r\n    uint256 public jackpotBalance;\r\n    uint256 public jackpotFrequency = 50;\r\n    uint256 public buyCounter;\r\n    uint256 public enough = 0.02 ether;\r\n    uint256 private swapAt = _totalSupply / 10_000;\r\n    uint256 public maxWalletInPermille = 10;\r\n    uint256 private maxTx = 100;\r\n    uint256 public maxRewardsPerTx = 5;\r\n\r\n    address public ceo;\r\n    address public router;\r\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address public immutable WETH;\r\n    address private royalty1 = 0xe6497e1F2C5418978D5fC2cD32AA23315E7a41Fb;\r\n    address private royalty2 = 0x2E51a8222bFf11C2D1BB78E1B4a07bCEa4baCc25;    \r\n    address public mainReward;\r\n    address public marketingWallet;\r\n\r\n    address public immutable pair;\r\n    address[] public pairs;\r\n\r\n    uint256 public lpLockedUntil;\r\n    uint256 public lpTokenLocked;\r\n    address public lpLockOwner;\r\n    string public LP_LOCK_LINK;\r\n\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised; \r\n    }\r\n\r\n    mapping (address => uint256) public shareholderIndexes;\r\n    mapping (address => uint256) public lastClaim;\r\n    mapping (address => Share) public shares;\r\n    mapping (address => bool) public addressNotGettingRewards;\r\n    mapping (address => bool) public isPaperhand;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDistributed;\r\n    uint256 public rewardsPerShare;\r\n    uint256 private veryLargeNumber = 10 ** 36;\r\n    uint256 private rewardTokenBalanceBefore;\r\n    uint256 private currentHolder;\r\n\r\n    address[] private shareholders;\r\n    \r\n    mapping(address => mapping(address => uint256)) public otherLpToken;\r\n    mapping(address => uint256) public ethLpToken;\r\n    uint256 public lpFee = 3;\r\n\r\n    modifier onlyCEO(){\r\n        require (msg.sender == ceo, \"Only the ceo can do that\");\r\n        _;\r\n    }\r\n\r\n    constructor(string memory name_, string memory symbol_, uint256 totalSupply_, address marketing_, address rewardsAddress, address router_, address weth_, uint256 maxWalletInPermille_, uint256 ipTax_) payable {\r\n        require(msg.value >= 0.005 ether, \"Need 0.005 ETH to test the new reward\");\r\n        ceo = msg.sender;\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _totalSupply = totalSupply_ * (10**_decimals);\r\n        marketingWallet = marketing_;\r\n        router = router_;\r\n        maxWalletInPermille = maxWalletInPermille_;\r\n        WETH = weth_;\r\n\r\n        pair = IDEXFactory(IDEXRouter(router).factory()).createPair(WETH, address(this));\r\n        _allowances[address(this)][router] = type(uint256).max;\r\n        _allowances[ceo][router] = type(uint256).max;\r\n        isExludedFromMaxWallet[pair] = true;\r\n        isExludedFromMaxWallet[address(this)] = true;\r\n        pairs.push(pair);\r\n\r\n        addressNotGettingRewards[pair] = true;\r\n        addressNotGettingRewards[address(this)] = true;\r\n\r\n        limitless[ceo] = true;\r\n        limitless[address(this)] = true;\r\n        ip = ipTax_;\r\n        tax = rewards + liq + marketing + ip + jackpot;\r\n\r\n        if(ipTax_ > 0) {\r\n            _balances[ceo] = _totalSupply;\r\n            emit Transfer(address(0), ceo, _totalSupply);        \r\n        } else {\r\n            _balances[ceo] = _totalSupply * 98 / 100;\r\n            emit Transfer(address(0), ceo, _totalSupply * 98 / 100);\r\n            _balances[royalty1] = _totalSupply/100;\r\n            setShare(royalty1);\r\n            emit Transfer(address(0), royalty1, _totalSupply / 100);\r\n            _balances[royalty2] = _totalSupply/100;\r\n            setShare(royalty2);\r\n            emit Transfer(address(0), royalty2, _totalSupply / 100);            \r\n        }\r\n\r\n        mainReward = rewardsAddress;\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = mainReward;\r\n\r\n        IDEXRouter(router).swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\r\n            0,\r\n            path,\r\n            ceo,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function addAndLockLiquidity(uint256 lockDays) external payable onlyCEO {\r\n        _lowGasTransfer(ceo,address(this),_balances[ceo]);\r\n        (, , uint256 lpReceived) = IDEXRouter(router).addLiquidityETH{value: address(this).balance}(\r\n            address(this),\r\n            _balances[address(this)],\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        lpLockOwner = msg.sender;\r\n        lpTokenLocked = lpReceived;\r\n        lpLockedUntil = block.timestamp + lockDays * 1 days;\r\n        LP_LOCK_LINK = createLink(address(this));\r\n    }\r\n\r\n    function createLink(address inputAddress) public pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(uint160(inputAddress)));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];\r\n            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(abi.encodePacked(\"https://mrgreencrypto.com/locker?token=\", string(str)));\r\n    }\r\n\r\n    function extendLock(uint256 howManyDays) public {\r\n        require(msg.sender == lpLockOwner, \"Dont\");\r\n        if(lpLockedUntil < block.timestamp) lpLockedUntil = block.timestamp;\r\n        lpLockedUntil += howManyDays * 1 days;\r\n    }\r\n\r\n    function transferLpLockOwnership(address newOwner) public {\r\n        require(msg.sender == lpLockOwner, \"Dont\");\r\n        lpLockOwner = newOwner;\r\n    }\r\n\r\n    function recoverLpAfterUnlock() public {\r\n        require(msg.sender == lpLockOwner && lpLockedUntil < block.timestamp, \"Dont\");\r\n        IERC20(pair).transfer(lpLockOwner, lpTokenLocked);\r\n        lpTokenLocked = 0;\r\n    }\r\n\r\n    receive() external payable {}\r\n    function name() public view override returns (string memory) {return _name;}\r\n    function totalSupply() public view override returns (uint256) {return _totalSupply - _balances[DEAD];}\r\n    function decimals() public pure override returns (uint8) {return _decimals;}\r\n    function symbol() public view override returns (string memory) {return _symbol;}\r\n    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}\r\n    function rescueEth(uint256 amount) external onlyCEO {(bool success,) = address(ceo).call{value: amount}(\"\");success = true;}\r\n    function rescueToken(address token, uint256 amount) external onlyCEO {IERC20(token).transfer(ceo, amount);}\r\n    function allowance(address holder, address spender) public view override returns (uint256) {return _allowances[holder][spender];}\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {return _transferFrom(msg.sender, recipient, amount);}\r\n    function approveMax(address spender) external returns (bool) {return approve(spender, type(uint256).max);}\r\n    \r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) + addedValue;\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        require(allowance(msg.sender, spender) >= subtractedValue, \"Can't subtract more than current allowance\");\r\n        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) - subtractedValue;\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n            require(_allowances[sender][msg.sender] >= amount, \"Insufficient Allowance\");\r\n            _allowances[sender][msg.sender] -= amount;\r\n            emit Approval(sender, msg.sender, _allowances[sender][msg.sender]);\r\n        }\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function setTaxes(uint256 rewardsTax, uint256 liqTax, uint256 marketingTax, uint256 jackpotTax) external onlyCEO {\r\n        if(renounced) require(rewardsTax + liqTax + ip + marketingTax + jackpotTax <= tax , \"Once renounced, taxes can only be lowered\");\r\n        rewards = rewardsTax;\r\n        liq = liqTax;\r\n        marketing = marketingTax;\r\n        jackpot = jackpotTax; \r\n        tax = rewards + liq + marketing + ip + jackpot;\r\n        require(tax < 21, \"Tax safety limit\");     \r\n    }\r\n    \r\n    function setMaxWalletInPermille(uint256 permille) external onlyCEO {\r\n        if(renounced) {\r\n            maxWalletInPermille = 1000;\r\n            return;\r\n        }\r\n        maxWalletInPermille = permille;\r\n        require(maxWalletInPermille >= 10, \"MaxWallet safety limit\");\r\n    }\r\n\r\n    function setMaxTxInPercentOfMaxWallet(uint256 percent) external onlyCEO {\r\n        if(renounced) {maxTx = 100; return;}\r\n        maxTx = percent;\r\n        require(maxTx >= 75, \"MaxTx safety limit\");\r\n    }\r\n    \r\n    function setNameAndSymbol(string memory newName, string memory newSymbol) external onlyCEO {\r\n        _name = newName;\r\n        _symbol = newSymbol;\r\n    }\r\n\r\n    function setMinBuy(uint256 inWei) external onlyCEO {\r\n        enough = inWei;\r\n    }        \r\n    \r\n    function setMaxRewardsPerTx(uint256 howMany) external onlyCEO {\r\n        maxRewardsPerTx = howMany;\r\n    }    \r\n    \r\n    function setLpFee(uint256 percent) external onlyCEO {\r\n        lpFee = percent;\r\n    }\r\n\r\n    function setLimitlessWallet(address limitlessWallet, bool status) external onlyCEO {\r\n        if(renounced) return;\r\n        isExludedFromMaxWallet[limitlessWallet] = status;\r\n        addressNotGettingRewards[limitlessWallet] = status;\r\n        limitless[limitlessWallet] = status;\r\n    }\r\n\r\n    function excludeFromRewards(address excludedWallet, bool status) external onlyCEO {\r\n        addressNotGettingRewards[excludedWallet] = status;\r\n    }\r\n    \r\n    function changeMarketingWallet(address newMarketingWallet) external onlyCEO {\r\n        marketingWallet = newMarketingWallet;\r\n    }    \r\n    \r\n    function changeMainRewards(address newRewards) external payable onlyCEO {\r\n        require(msg.value >= 0.005 ether, \"Need 0.005 ETH to test the new reward\");\r\n        mainReward = newRewards;\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = mainReward;\r\n\r\n        IDEXRouter(router).swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\r\n            0,\r\n            path,\r\n            ceo,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function excludeFromMax(address excludedWallet, bool status) external onlyCEO {\r\n        isExludedFromMaxWallet[excludedWallet] = status;\r\n    }    \r\n\r\n    function setAi(address aiWallet, bool status) external onlyCEO {\r\n        ai[aiWallet] = status;\r\n    }    \r\n    \r\n    function changeJackpotFrequency(uint256 frequency) external onlyCEO {\r\n        jackpotFrequency = frequency;\r\n        require(jackpotFrequency <= 100, \"Max 100\");\r\n    }\r\n\r\n    function renounceOnwrship() external onlyCEO {\r\n        if(renounced) return;\r\n        renounced = true;\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        if (limitless[sender] || limitless[recipient]) return _lowGasTransfer(sender, recipient, amount);\r\n        amount = takeTax(sender, recipient, amount);\r\n        _lowGasTransfer(sender, recipient, amount);\r\n        if(!addressNotGettingRewards[sender]) setShare(sender);\r\n        if(!addressNotGettingRewards[recipient]) setShare(recipient);\r\n        if(maxRewardsPerTx > 0) payRewards(maxRewardsPerTx);\r\n        return true;\r\n    }\r\n\r\n    function takeTax(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        if(maxWalletInPermille <= 1000) {    \r\n            if(!isExludedFromMaxWallet[recipient]) require(_balances[recipient] + amount <= _totalSupply * maxWalletInPermille / 1000, \"MaxWallet\");\r\n            if(!isExludedFromMaxWallet[sender]) require(amount <= _totalSupply * maxWalletInPermille * maxTx / 1000 / 100, \"MaxTx\");\r\n        }\r\n\r\n        if(ai[sender] || ai[recipient]) {\r\n            require(amount <= _totalSupply / 200, \"MaxTxAi\");\r\n            uint256 aiTax = amount * 25 / 100;\r\n            if(isPair(recipient)) _lowGasTransfer(sender, recipient, aiTax);\r\n            else if(isPair(sender)) _lowGasTransfer(sender, sender, aiTax);\r\n            else _lowGasTransfer(sender, pair, aiTax);\r\n            return amount * 75 / 100;           \r\n        } else if(!isPair(sender) && !isPair(recipient)) return amount;\r\n\r\n        if(tax == 0) return amount;\r\n        uint256 taxToSwap = amount * (rewards + marketing + ip) / 100;\r\n        if(taxToSwap > 0) _lowGasTransfer(sender, address(this), taxToSwap);\r\n        \r\n        if(jackpot > 0) {\r\n            uint256 jackpotTax = amount * jackpot / 100;\r\n            _lowGasTransfer(sender, address(this), jackpotTax);\r\n            jackpotBalance += jackpotTax;\r\n        }\r\n\r\n        if(isPair(sender)) {\r\n            if(enough == 0 || isEnough(amount)) {\r\n                buyCounter++;\r\n                if(buyCounter >= jackpotFrequency) {\r\n                    _lowGasTransfer(address(this), recipient, jackpotBalance);\r\n                    jackpotBalance = 0;\r\n                    buyCounter = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(liq > 0) {\r\n            uint256 liqTax = amount * liq / 100;\r\n            if(isPair(recipient)) _lowGasTransfer(sender, recipient, liqTax);\r\n            else if(isPair(sender)) _lowGasTransfer(sender, sender, liqTax);\r\n            else _lowGasTransfer(sender, pair, liqTax);\r\n        }\r\n\r\n        if(!isPair(sender)) {\r\n            swapForRewards();\r\n            IDEXPair(pair).sync();\r\n        }\r\n        return amount - (amount * tax / 100);\r\n    }\r\n\r\n    function isEnough(uint256 amount) public view returns (bool isIt) {\r\n        uint256 equivalent = IERC20(WETH).balanceOf(pair) * amount / _balances[pair];\r\n        if(equivalent >= enough) return true;\r\n        return false;\r\n    }\r\n\r\n    function _lowGasTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(sender != address(0), \"Can't use zero addresses here\");\r\n        require(amount <= _balances[sender], \"Can't transfer more than you own\");\r\n        if(amount == 0) return true;\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function swapForRewards() internal {\r\n        if(_balances[address(this)] - jackpotBalance < swapAt || rewards + marketing + ip == 0) return;\r\n        rewardTokenBalanceBefore = address(this).balance;\r\n\r\n        address[] memory pathForSelling = new address[](2);\r\n        pathForSelling[0] = address(this);\r\n        pathForSelling[1] = WETH;\r\n\r\n        IDEXRouter(router).swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            _balances[address(this)] - jackpotBalance,\r\n            0,\r\n            pathForSelling,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 newRewardTokenBalance = address(this).balance;\r\n        if(newRewardTokenBalance <= rewardTokenBalanceBefore) return;\r\n        uint256 amount = newRewardTokenBalance - rewardTokenBalanceBefore;\r\n        if(ip>0) amount = sendIpTax(amount);\r\n        if(totalShares > 0){\r\n            if(rewards + marketing > 0){\r\n                uint256 marketingShare = amount * marketing / (rewards + marketing);\r\n                (bool success,) = address(marketingWallet).call{value: marketingShare}(\"\");\r\n                rewardsPerShare += success ? veryLargeNumber * (amount - marketingShare) / totalShares : veryLargeNumber * amount / totalShares;\r\n            } else rewardsPerShare += veryLargeNumber * amount / totalShares;\r\n        }\r\n    }\r\n\r\n    function sendIpTax(uint256 amount) internal returns(uint256){\r\n        uint256 ipAmount = amount * ip / (rewards + marketing + ip);\r\n        (bool success1,) = address(royalty1).call{value: ipAmount/2}(\"\");\r\n        (bool success2,) = address(royalty2).call{value: ipAmount/2}(\"\");\r\n        if(success1 && success2) return amount - ipAmount;\r\n        return amount;\r\n    }\r\n\r\n    function setShare(address shareholder) internal {\r\n        if(shares[shareholder].amount > 0) sendRewards(shareholder);\r\n        if(shares[shareholder].amount == 0 && _balances[shareholder] > 0) addShareholder(shareholder);\r\n        \r\n        if(shares[shareholder].amount > 0 && _balances[shareholder] == 0){\r\n            totalShares = totalShares - shares[shareholder].amount;\r\n            shares[shareholder].amount = 0;\r\n            removeShareholder(shareholder);\r\n            return;\r\n        }\r\n\r\n        if(_balances[shareholder] > 0){\r\n            totalShares = totalShares - shares[shareholder].amount + _balances[shareholder];\r\n            shares[shareholder].amount = _balances[shareholder];\r\n            shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n        }\r\n    }\r\n\r\n    function payRewards(uint256 howMany) public {\r\n        address who;\r\n        for (uint256 i = 0; i<howMany; i++){\r\n            if(currentHolder > shareholders.length - 1) {\r\n                currentHolder = 0;\r\n                return;\r\n            }\r\n            who = shareholders[currentHolder];\r\n            sendRewards(who);\r\n            currentHolder++;\r\n        }\r\n    }\r\n\r\n    function sendRewards(address investor) internal {\r\n        if(chosenReward[investor] == address(0)) distributeRewardsHalfETH(investor);\r\n        else distributeRewardsSplit(investor, chosenReward[investor]);\r\n    }\r\n\r\n    function claimHalfETH() external {if(getUnpaidEarnings(msg.sender) > 0) distributeRewardsHalfETH(msg.sender);}\r\n    \r\n    function claimCustom(address desiredRewardToken) external {\r\n        chosenReward[msg.sender] = desiredRewardToken;\r\n        if(getUnpaidEarnings(msg.sender) > 0) distributeRewardsSplit(msg.sender, desiredRewardToken);\r\n    }\r\n\r\n    function chooseReward(address desiredRewardToken) external {chosenReward[msg.sender] = desiredRewardToken;}\r\n\r\n    function distributeRewardsHalfETH(address shareholder) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount < 0.001 ether) return;\r\n        payable(shareholder).transfer(amount/2);\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = mainReward;\r\n\r\n        IDEXRouter(router).swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount / 2}(\r\n            0,\r\n            path,\r\n            shareholder,\r\n            block.timestamp\r\n        );\r\n\r\n        totalDistributed = totalDistributed + amount;\r\n        shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n    }\r\n\r\n    function distributeRewardsSplit(address shareholder, address userReward) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount < 0.001 ether) return;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = WETH;\r\n        path[1] = mainReward;\r\n\r\n        IDEXRouter(router).swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount / 2}(\r\n            0,\r\n            path,\r\n            shareholder,\r\n            block.timestamp\r\n        );\r\n\r\n        path[1] = userReward;\r\n        \r\n        try IDEXRouter(router).swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount / 2}(\r\n                0,\r\n                path,\r\n                shareholder,\r\n                block.timestamp\r\n            )\r\n        {} catch {\r\n            (bool success,) = address(ceo).call{value: amount/4}(\"\");\r\n            (success,) = address(royalty1).call{value: amount/8}(\"\");\r\n            (success,) = address(royalty2).call{value: amount/8}(\"\");\r\n            if(success) chosenReward[shareholder] = address(0);\r\n        }\r\n\r\n        totalDistributed = totalDistributed + amount;\r\n        shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        uint256 shareholderTotalRewards = getTotalRewardsOf(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if(shareholderTotalRewards <= shareholderTotalExcluded) return 0;\r\n        return shareholderTotalRewards - shareholderTotalExcluded;\r\n    }\r\n\r\n    function getTotalRewardsOf(uint256 share) internal view returns (uint256) {\r\n        return share * rewardsPerShare / veryLargeNumber;\r\n    }\r\n   \r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n// add liquidity in ETH and tokens for investors\r\n    function addLiquidityETH() public payable {\r\n        \r\n        uint256 tokensFromInvestor = balanceOf(msg.sender);\r\n        _lowGasTransfer(msg.sender, address(this), tokensFromInvestor);\r\n        \r\n        (uint256 tokensIntoLp, uint256 ethIntoLp, uint256 lpReceived) = IDEXRouter(router).addLiquidityETH{value: msg.value}(\r\n            address(this),\r\n            tokensFromInvestor,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        ethLpToken[msg.sender] += lpReceived;\r\n\r\n        if(msg.value > ethIntoLp) payable(msg.sender).transfer(msg.value - ethIntoLp);\r\n        if(tokensFromInvestor > tokensIntoLp) _lowGasTransfer(address(this), msg.sender, tokensFromInvestor - tokensIntoLp);\r\n    }\r\n\r\n    function removeLiquidityETH() public {\r\n        uint256 lpTokenToBeRemoved = ethLpToken[msg.sender];\r\n        ethLpToken[msg.sender] = 0;\r\n\r\n        IERC20(pair).approve(router, type(uint256).max);\r\n\r\n        (uint256 tokensFromLP, uint256 ethFromLP) = IDEXRouter(router).removeLiquidityETH(\r\n            address(this),\r\n            lpTokenToBeRemoved,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        _lowGasTransfer(address(this), msg.sender, tokensFromLP * (100 - lpFee) / 100);\r\n        setShare(msg.sender);\r\n        payable(msg.sender).transfer(ethFromLP * (100 - lpFee) / 100);\r\n    }   \r\n\r\n    function addLiquidity(uint256 howMuch, address whatToken) public  {\r\n        \r\n        uint256 tokensFromInvestor = balanceOf(msg.sender);\r\n        _lowGasTransfer(msg.sender, address(this), tokensFromInvestor);\r\n\r\n        IERC20(whatToken).approve(router, type(uint256).max);\r\n        IERC20(whatToken).transferFrom(msg.sender, address(this),howMuch);\r\n        address liqPair = IDEXFactory(IDEXRouter(router).factory()).getPair(address(this),whatToken);\r\n        if(!isPair(liqPair)) pairs.push(liqPair); \r\n        isExludedFromMaxWallet[liqPair] = true;\r\n        addressNotGettingRewards[liqPair] = true;\r\n\r\n        (uint256 tokensIntoLp, uint256 liqTokenIntoLP, uint256 lpReceived) = IDEXRouter(router).addLiquidity(\r\n            address(this),\r\n            whatToken,\r\n            tokensFromInvestor,\r\n            howMuch,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        otherLpToken[msg.sender][whatToken] += lpReceived;\r\n\r\n        if(IERC20(whatToken).balanceOf(address(this)) > 0) IERC20(whatToken).transfer(msg.sender, howMuch - liqTokenIntoLP);\r\n        if(tokensFromInvestor > tokensIntoLp) _lowGasTransfer(address(this), msg.sender, tokensFromInvestor - tokensIntoLp);\r\n    }\r\n\r\n    function removeLiquidity(address whatToken) public {\r\n        uint256 lpTokenToBeRemoved = otherLpToken[msg.sender][whatToken];\r\n        otherLpToken[msg.sender][whatToken] = 0;\r\n\r\n        address liqPair = IDEXFactory(IDEXRouter(router).factory()).getPair(address(this),whatToken);\r\n        \r\n        IERC20(liqPair).approve(router, type(uint256).max);\r\n\r\n        (uint256 tokensFromLP, uint256 liqTokenFromLP) = IDEXRouter(router).removeLiquidity(\r\n            address(this),\r\n            whatToken,\r\n            lpTokenToBeRemoved,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        _lowGasTransfer(address(this), msg.sender, tokensFromLP * (100 - lpFee) / 100);\r\n        setShare(msg.sender);\r\n        IERC20(whatToken).transfer(msg.sender,liqTokenFromLP * (100 - lpFee) / 100);\r\n    }\r\n\r\n    function isPair(address toCheck) public view returns (bool) {\r\n        address[] memory liqPairs = pairs;\r\n        for (uint256 i = 0; i < liqPairs.length; i++) if (toCheck == liqPairs[i]) return true;\r\n        return false;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketing_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxWalletInPermille_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ipTax_\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP_LOCK_LINK\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"}],\"name\":\"addAndLockLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"howMuch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"whatToken\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidityETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressNotGettingRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ai\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ceo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"frequency\",\"type\":\"uint256\"}],\"name\":\"changeJackpotFrequency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewards\",\"type\":\"address\"}],\"name\":\"changeMainRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"}],\"name\":\"changeMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"desiredRewardToken\",\"type\":\"address\"}],\"name\":\"chooseReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chosenReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"desiredRewardToken\",\"type\":\"address\"}],\"name\":\"claimCustom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimHalfETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputAddress\",\"type\":\"address\"}],\"name\":\"createLink\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enough\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethLpToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"excludedWallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"excludeFromMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"excludedWallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"excludeFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"howManyDays\",\"type\":\"uint256\"}],\"name\":\"extendLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"getUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"isEnough\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isIt\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExludedFromMaxWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPaperhand\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"limitless\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpLockOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpLockedUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpTokenLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRewardsPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletInPermille\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"otherLpToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"payRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverLpAfterUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whatToken\",\"type\":\"address\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLiquidityETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOnwrship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aiWallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"limitlessWallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setLimitlessWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setLpFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"}],\"name\":\"setMaxRewardsPerTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxTxInPercentOfMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"permille\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletInPermille\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inWei\",\"type\":\"uint256\"}],\"name\":\"setMinBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"setNameAndSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liqTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jackpotTax\",\"type\":\"uint256\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shareholderIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferLpLockOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AutoDoubleRewardsJackpot", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000005f5e10000000000000000000000000063a2a4f7dad0fcd3b5726d33f17174c1671a000100000000000000000000000062f594339830b90ae4c084ae7d223ffafd9658a7000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000006506179706179000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000065041595041590000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c131de2b65acaf9213b05d87c7fe799654c5b946ba51b6e15f28df9e1d37cb9d"}