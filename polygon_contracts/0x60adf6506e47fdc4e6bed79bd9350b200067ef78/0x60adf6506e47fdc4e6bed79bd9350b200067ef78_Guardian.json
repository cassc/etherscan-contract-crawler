{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Guardian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.2;\\n\\n/*\\n *     ,_,\\n *    (',')\\n *    {/\\\"\\\\}\\n *    -\\\"-\\\"-\\n */\\n\\nimport \\\"ILockERC721.sol\\\";\\n\\ncontract Guardian {\\n\\n\\tstruct UserData {\\n\\t\\taddress guardian;\\n\\t\\tuint256[] lockedAssets;\\n\\t\\tmapping(uint256 => uint256) assetToIndex;\\n\\t}\\n\\n\\tILockERC721 public immutable LOCKABLE;\\n\\n\\tmapping(address => address) public guardians;\\n\\tmapping(address => UserData) public userData;\\n\\tmapping(address => mapping(uint256 => address)) public guardianToUsers;\\n\\tmapping(address => mapping(address => uint256)) public guardianToUserIndex;\\n\\tmapping(address => uint256) public guardianUserCount;\\n\\n\\tevent GuardianSet(address indexed guardian, address indexed user);\\n\\tevent GuardianRenounce(address indexed guardian, address indexed user);\\n\\n\\tconstructor(address _lockable) public {\\n\\t\\tLOCKABLE = ILockERC721(_lockable);\\n\\t}\\n\\n\\tfunction setGuardian(address _guardian) external {\\n\\t\\trequire(guardians[msg.sender] == address(0), \\\"Guardian set\\\");\\n\\t\\trequire(msg.sender != _guardian, \\\"Guardian must be a different wallet\\\");\\n\\n\\t\\tguardians[msg.sender] = _guardian;\\n\\t\\tuserData[msg.sender].guardian = _guardian;\\n\\t\\t_pushGuardianrray(_guardian, msg.sender);\\n\\t\\temit GuardianSet(_guardian, msg.sender);\\n\\t}\\n\\n\\tfunction renounce(address _protege) external {\\n\\t\\trequire(guardians[_protege] == msg.sender, \\\"!guardian\\\");\\n\\n\\t\\tguardians[_protege] = address(0);\\n\\t\\tuserData[_protege].guardian = address(0);\\n\\t\\t_popGuardianrray(msg.sender, _protege);\\n\\t\\temit GuardianRenounce(msg.sender, _protege);\\n\\t}\\n\\n\\tfunction lockMany(uint256[] calldata _tokenIds) external {\\n\\t\\taddress owner = LOCKABLE.ownerOf(_tokenIds[0]);\\n\\t\\trequire(guardians[owner] == msg.sender, \\\"!guardian\\\");\\n\\n\\t\\tUserData storage _userData = userData[owner];\\n\\t\\tuint256 len = _userData.lockedAssets.length;\\n\\t\\tfor (uint256 i = 0; i < _tokenIds.length; i++) {\\n\\t\\t\\trequire(LOCKABLE.ownerOf(_tokenIds[i]) == owner, \\\"!owner\\\");\\n\\t\\t\\tLOCKABLE.lockId(_tokenIds[i]);\\n\\t\\t\\t_pushTokenInArray(_userData, _tokenIds[i], len + i);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction unlockMany(uint256[] calldata _tokenIds) external {\\n\\t\\taddress owner = LOCKABLE.ownerOf(_tokenIds[0]);\\n\\t\\trequire(guardians[owner] == msg.sender, \\\"!guardian\\\");\\n\\n\\t\\tUserData storage _userData = userData[owner];\\n\\t\\tuint256 len = _userData.lockedAssets.length;\\n\\t\\tfor (uint256 i = 0; i < _tokenIds.length; i++) {\\n\\t\\t\\trequire(LOCKABLE.ownerOf(_tokenIds[i]) == owner, \\\"!owner\\\");\\n\\t\\t\\tLOCKABLE.unlockId(_tokenIds[i]);\\n\\t\\t\\t_popTokenFromArray(_userData, _tokenIds[i], len--);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction unlockManyAndTransfer(uint256[] calldata _tokenIds, address _recipient) external {\\n\\t\\taddress owner = LOCKABLE.ownerOf(_tokenIds[0]);\\n\\t\\trequire(guardians[owner] == msg.sender, \\\"!guardian\\\");\\n\\n\\t\\tUserData storage _userData = userData[owner];\\n\\t\\tuint256 len = _userData.lockedAssets.length;\\n\\t\\tfor (uint256 i = 0; i < _tokenIds.length; i++) {\\n\\t\\t\\trequire(LOCKABLE.ownerOf(_tokenIds[i]) == owner, \\\"!owner\\\");\\n\\t\\t\\tLOCKABLE.unlockId(_tokenIds[i]);\\n\\t\\t\\tLOCKABLE.safeTransferFrom(owner, _recipient, _tokenIds[i]);\\n\\t\\t\\t_popTokenFromArray(_userData, _tokenIds[i], len--);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getLockedAssetsOfUsers(address _user) external view returns(uint256[] memory lockedAssets) {\\n\\t\\tuint256 len = userData[_user].lockedAssets.length;\\n\\t\\tlockedAssets = new uint256[](len);\\n\\t\\tfor (uint256 i = 0; i < len; i++) {\\n\\t\\t\\tlockedAssets[i] = userData[_user].lockedAssets[i];\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getLockedAssetsOfUsers(address _user, uint256 _startIndex, uint256 _maxLen) external view returns(uint256[] memory lockedAssets) {\\n\\t\\tuint256 len = userData[_user].lockedAssets.length;\\n\\n\\t\\tif (len == 0 || _startIndex >= len) {\\n\\t\\t\\tlockedAssets = new uint256[](0);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t_maxLen = (len - _startIndex) < _maxLen  ? len - _startIndex : _maxLen;\\n\\t\\t\\tlockedAssets = new uint256[](_maxLen);\\n\\t\\t\\tfor (uint256 i = _startIndex; i < _startIndex + _maxLen; i++) {\\n\\t\\t\\t\\tlockedAssets[i] = userData[_user].lockedAssets[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getProtegesFromGuardian(address _guardian) external view returns(address[] memory proteges) {\\n\\t\\tuint256 len = guardianUserCount[_guardian];\\n\\t\\tproteges = new address[](len);\\n\\t\\tfor (uint256 i = 0; i < len; i++) {\\n\\t\\t\\tproteges[i] = guardianToUsers[_guardian][i];\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _pushTokenInArray(UserData storage _userData, uint256 _token, uint256 _index) internal {\\n\\t\\t_userData.lockedAssets.push(_token);\\n\\t\\t_userData.assetToIndex[_token] = _index;\\n\\t}\\n\\n\\tfunction _popTokenFromArray(UserData storage _userData, uint256 _token, uint256 _len) internal {\\n\\t\\tuint256 index = _userData.assetToIndex[_token];\\n\\t\\tdelete _userData.assetToIndex[_token];\\n\\t\\tuint256 lastId = _userData.lockedAssets[_len - 1];\\n\\t\\t_userData.assetToIndex[lastId] = index;\\n\\t\\t_userData.lockedAssets[index] = lastId;\\n\\t\\t_userData.lockedAssets.pop();\\n\\t}\\n\\n\\tfunction _pushGuardianrray(address _guardian, address _protege) internal {\\n\\t\\tuint256 count = guardianUserCount[_guardian];\\n\\t\\tguardianToUsers[_guardian][count] = _protege;\\n\\t\\tguardianToUserIndex[_guardian][_protege] = count;\\n\\t\\tguardianUserCount[_guardian]++;\\n\\t}\\n\\n\\tfunction _popGuardianrray(address _guardian, address _protege) internal {\\n\\t\\tuint256 index = guardianToUserIndex[_guardian][_protege];\\n\\t\\tdelete guardianToUserIndex[_guardian][_protege];\\n\\t\\tguardianToUsers[_guardian][index] = guardianToUsers[_guardian][guardianUserCount[_guardian] - 1];\\n\\t\\tdelete guardianToUsers[_guardian][guardianUserCount[_guardian] - 1];\\n\\t\\tguardianUserCount[_guardian]--;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"ILockERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.2;\\n\\nimport \\\"IERC721.sol\\\";\\n\\ninterface ILockERC721 is IERC721 {\\n\\tfunction lockId(uint256 _id) external;\\n\\tfunction unlockId(uint256 _id) external;\\n\\tfunction freeId(uint256 _id, address _contract) external;\\n}\"\r\n    },\r\n    \"IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lockable\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"GuardianRenounce\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"GuardianSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LOCKABLE\",\"outputs\":[{\"internalType\":\"contract ILockERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLockedAssetsOfUsers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"lockedAssets\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxLen\",\"type\":\"uint256\"}],\"name\":\"getLockedAssetsOfUsers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"lockedAssets\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"getProtegesFromGuardian\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"proteges\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"guardianToUserIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"guardianToUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"guardianUserCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"guardians\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"lockMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protege\",\"type\":\"address\"}],\"name\":\"renounce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unlockMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"unlockManyAndTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Guardian", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000005df72d911e52ab122f7d9955728bc96a718782c", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}