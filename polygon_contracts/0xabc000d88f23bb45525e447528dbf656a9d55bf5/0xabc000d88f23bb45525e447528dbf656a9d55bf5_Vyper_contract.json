{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Child Liquidity Gauge Factory\r\n@license MIT\r\n@author Curve Finance\r\n\"\"\"\r\n\r\n\r\ninterface ChildGauge:\r\n    def initialize(_lp_token: address, _manager: address): nonpayable\r\n    def integrate_fraction(_user: address) -> uint256: view\r\n    def user_checkpoint(_user: address) -> bool: nonpayable\r\n\r\ninterface CallProxy:\r\n    def anyCall(\r\n        _to: address, _data: Bytes[1024], _fallback: address, _to_chain_id: uint256\r\n    ): nonpayable\r\n\r\n\r\nevent DeployedGauge:\r\n    _implementation: indexed(address)\r\n    _lp_token: indexed(address)\r\n    _deployer: indexed(address)\r\n    _salt: bytes32\r\n    _gauge: address\r\n\r\nevent Minted:\r\n    _user: indexed(address)\r\n    _gauge: indexed(address)\r\n    _new_total: uint256\r\n\r\nevent UpdateImplementation:\r\n    _old_implementation: address\r\n    _new_implementation: address\r\n\r\nevent UpdateVotingEscrow:\r\n    _old_voting_escrow: address\r\n    _new_voting_escrow: address\r\n\r\nevent UpdateCallProxy:\r\n    _old_call_proxy: address\r\n    _new_call_proxy: address\r\n\r\nevent UpdateMirrored:\r\n    _gauge: indexed(address)\r\n    _mirrored: bool\r\n\r\nevent TransferOwnership:\r\n    _old_owner: address\r\n    _new_owner: address\r\n\r\n\r\nWEEK: constant(uint256) = 86400 * 7\r\n\r\n\r\nCRV: immutable(address)\r\n\r\n\r\nget_implementation: public(address)\r\nvoting_escrow: public(address)\r\n\r\nowner: public(address)\r\nfuture_owner: public(address)\r\n\r\ncall_proxy: public(address)\r\n# [last_request][has_counterpart][is_valid_gauge]\r\ngauge_data: public(HashMap[address, uint256])\r\n# user -> gauge -> value\r\nminted: public(HashMap[address, HashMap[address, uint256]])\r\n\r\nget_gauge_from_lp_token: public(HashMap[address, address])\r\nget_gauge_count: public(uint256)\r\nget_gauge: public(address[MAX_INT128])\r\n\r\n\r\n@external\r\ndef __init__(_call_proxy: address, _crv: address, _owner: address):\r\n    CRV = _crv\r\n\r\n    self.call_proxy = _call_proxy\r\n    log UpdateCallProxy(ZERO_ADDRESS, _call_proxy)\r\n\r\n    self.owner = _owner\r\n    log TransferOwnership(ZERO_ADDRESS, _owner)\r\n\r\n\r\n@internal\r\ndef _psuedo_mint(_gauge: address, _user: address):\r\n    gauge_data: uint256 = self.gauge_data[_gauge]\r\n    assert gauge_data != 0  # dev: invalid gauge\r\n\r\n    # if is_mirrored and last_request != this week\r\n    if bitwise_and(gauge_data, 2) != 0 and shift(gauge_data, -2) / WEEK != block.timestamp / WEEK:\r\n        CallProxy(self.call_proxy).anyCall(\r\n            self,\r\n            _abi_encode(_gauge, method_id=method_id(\"transmit_emissions(address)\")),\r\n            ZERO_ADDRESS,\r\n            1,\r\n        )\r\n        # update last request time\r\n        self.gauge_data[_gauge] = shift(block.timestamp, 2) + 3\r\n\r\n    assert ChildGauge(_gauge).user_checkpoint(_user)\r\n    total_mint: uint256 = ChildGauge(_gauge).integrate_fraction(_user)\r\n    to_mint: uint256 = total_mint - self.minted[_user][_gauge]\r\n\r\n    if to_mint != 0:\r\n        # transfer tokens to user\r\n        response: Bytes[32] = raw_call(\r\n            CRV,\r\n            _abi_encode(_user, to_mint, method_id=method_id(\"transfer(address,uint256)\")),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n        self.minted[_user][_gauge] = total_mint\r\n\r\n        log Minted(_user, _gauge, total_mint)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef mint(_gauge: address):\r\n    \"\"\"\r\n    @notice Mint everything which belongs to `msg.sender` and send to them\r\n    @param _gauge `LiquidityGauge` address to get mintable amount from\r\n    \"\"\"\r\n    self._psuedo_mint(_gauge, msg.sender)\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef mint_many(_gauges: address[32]):\r\n    \"\"\"\r\n    @notice Mint everything which belongs to `msg.sender` across multiple gauges\r\n    @param _gauges List of `LiquidityGauge` addresses\r\n    \"\"\"\r\n    for i in range(32):\r\n        if _gauges[i] == ZERO_ADDRESS:\r\n            pass\r\n        self._psuedo_mint(_gauges[i], msg.sender)\r\n\r\n\r\n@external\r\ndef deploy_gauge(_lp_token: address, _salt: bytes32, _manager: address = msg.sender) -> address:\r\n    \"\"\"\r\n    @notice Deploy a liquidity gauge\r\n    @param _lp_token The token to deposit in the gauge\r\n    @param _manager The address to set as manager of the gauge\r\n    @param _salt A value to deterministically deploy a gauge\r\n    \"\"\"\r\n    if self.get_gauge_from_lp_token[_lp_token] != ZERO_ADDRESS:\r\n        # overwriting lp_token -> gauge mapping requires\r\n        assert msg.sender == self.owner  # dev: only owner\r\n\r\n    gauge_data: uint256 = 1  # set is_valid_gauge = True\r\n    implementation: address = self.get_implementation\r\n    gauge: address = create_forwarder_to(\r\n        implementation, salt=keccak256(_abi_encode(chain.id, msg.sender, _salt))\r\n    )\r\n\r\n    if msg.sender == self.call_proxy:\r\n        gauge_data += 2  # set mirrored = True\r\n        log UpdateMirrored(gauge, True)\r\n        # issue a call to the root chain to deploy a root gauge\r\n        CallProxy(self.call_proxy).anyCall(\r\n            self,\r\n            _abi_encode(chain.id, _salt, method_id=method_id(\"deploy_gauge(uint256,bytes32)\")),\r\n            ZERO_ADDRESS,\r\n            1\r\n        )\r\n\r\n    self.gauge_data[gauge] = gauge_data\r\n\r\n    idx: uint256 = self.get_gauge_count\r\n    self.get_gauge[idx] = gauge\r\n    self.get_gauge_count = idx + 1\r\n    self.get_gauge_from_lp_token[_lp_token] = gauge\r\n\r\n    ChildGauge(gauge).initialize(_lp_token, _manager)\r\n\r\n    log DeployedGauge(implementation, _lp_token, msg.sender, _salt, gauge)\r\n    return gauge\r\n\r\n\r\n@external\r\ndef set_voting_escrow(_voting_escrow: address):\r\n    \"\"\"\r\n    @notice Update the voting escrow contract\r\n    @param _voting_escrow Contract to use as the voting escrow oracle\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    log UpdateVotingEscrow(self.voting_escrow, _voting_escrow)\r\n    self.voting_escrow = _voting_escrow\r\n\r\n\r\n@external\r\ndef set_implementation(_implementation: address):\r\n    \"\"\"\r\n    @notice Set the implementation\r\n    @param _implementation The address of the implementation to use\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    log UpdateImplementation(self.get_implementation, _implementation)\r\n    self.get_implementation = _implementation\r\n\r\n\r\n@external\r\ndef set_mirrored(_gauge: address, _mirrored: bool):\r\n    \"\"\"\r\n    @notice Set the mirrored bit of the gauge data for `_gauge`\r\n    @param _gauge The gauge of interest\r\n    @param _mirrored Boolean deteremining whether to set the mirrored bit to True/False\r\n    \"\"\"\r\n    gauge_data: uint256 = self.gauge_data[_gauge]\r\n    assert gauge_data != 0  # dev: invalid gauge\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    gauge_data = shift(shift(gauge_data, -2), 2) + 1  # set is_valid_gauge = True\r\n    if _mirrored:\r\n        gauge_data += 2  # set is_mirrored = True\r\n\r\n    self.gauge_data[_gauge] = gauge_data\r\n    log UpdateMirrored(_gauge, _mirrored)\r\n\r\n\r\n@external\r\ndef set_call_proxy(_new_call_proxy: address):\r\n    \"\"\"\r\n    @notice Set the address of the call proxy used\r\n    @dev _new_call_proxy should adhere to the same interface as defined\r\n    @param _new_call_proxy Address of the cross chain call proxy\r\n    \"\"\"\r\n    assert msg.sender == self.owner\r\n\r\n    log UpdateCallProxy(self.call_proxy, _new_call_proxy)\r\n    self.call_proxy = _new_call_proxy\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_future_owner: address):\r\n    \"\"\"\r\n    @notice Transfer ownership to `_future_owner`\r\n    @param _future_owner The account to commit as the future owner\r\n    \"\"\"\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.future_owner = _future_owner\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept the transfer of ownership\r\n    @dev Only the committed future owner can call this function\r\n    \"\"\"\r\n    assert msg.sender == self.future_owner  # dev: only future owner\r\n\r\n    log TransferOwnership(self.owner, msg.sender)\r\n    self.owner = msg.sender\r\n\r\n\r\n@view\r\n@external\r\ndef is_valid_gauge(_gauge: address) -> bool:\r\n    \"\"\"\r\n    @notice Query whether the gauge is a valid one deployed via the factory\r\n    @param _gauge The address of the gauge of interest\r\n    \"\"\"\r\n    return self.gauge_data[_gauge] != 0\r\n\r\n\r\n@view\r\n@external\r\ndef is_mirrored(_gauge: address) -> bool:\r\n    \"\"\"\r\n    @notice Query whether the gauge is mirrored on Ethereum mainnet\r\n    @param _gauge The address of the gauge of interest\r\n    \"\"\"\r\n    return bitwise_and(self.gauge_data[_gauge], 2) != 0\r\n\r\n\r\n@view\r\n@external\r\ndef last_request(_gauge: address) -> uint256:\r\n    \"\"\"\r\n    @notice Query the timestamp of the last cross chain request for emissions\r\n    @param _gauge The address of the gauge of interest\r\n    \"\"\"\r\n    return shift(self.gauge_data[_gauge], -2)", "ABI": "[{\"name\":\"DeployedGauge\",\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_lp_token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_deployer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_salt\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"_gauge\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Minted\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_new_total\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateImplementation\",\"inputs\":[{\"name\":\"_old_implementation\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_implementation\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateVotingEscrow\",\"inputs\":[{\"name\":\"_old_voting_escrow\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_voting_escrow\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateCallProxy\",\"inputs\":[{\"name\":\"_old_call_proxy\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_call_proxy\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateMirrored\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"_mirrored\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TransferOwnership\",\"inputs\":[{\"name\":\"_old_owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"_new_owner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_call_proxy\",\"type\":\"address\"},{\"name\":\"_crv\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint_many\",\"inputs\":[{\"name\":\"_gauges\",\"type\":\"address[32]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_gauge\",\"inputs\":[{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_salt\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_gauge\",\"inputs\":[{\"name\":\"_lp_token\",\"type\":\"address\"},{\"name\":\"_salt\",\"type\":\"bytes32\"},{\"name\":\"_manager\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_voting_escrow\",\"inputs\":[{\"name\":\"_voting_escrow\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_implementation\",\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_mirrored\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_mirrored\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_call_proxy\",\"inputs\":[{\"name\":\"_new_call_proxy\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_future_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_valid_gauge\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_mirrored\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_request\",\"inputs\":[{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_implementation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voting_escrow\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"call_proxy\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_data\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minted\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge_from_lp_token\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000037414a8662bc1d25be3ee51fb27c2686e2490a89000000000000000000000000172370d5cd63279efa6d502dab29171933a610af000000000000000000000000919124f5f5135d3020a0b075412679755545f7c5", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}