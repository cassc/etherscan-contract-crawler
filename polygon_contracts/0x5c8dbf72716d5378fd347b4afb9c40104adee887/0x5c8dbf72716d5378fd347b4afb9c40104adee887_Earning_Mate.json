{"SourceCode": "pragma solidity >=0.4.23 <0.6.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ncontract Earning_Mate {\r\n    struct User {\r\n        uint id;\r\n        address referrer;\r\n        uint partnersCount;\r\n        uint levelBought;\r\n        mapping(uint8 => bool) activeS3Levels;  \r\n        mapping(uint8 => bool) activeS6Levels;  \r\n        mapping(uint8 => bool) activeS30Levels;\r\n        mapping(uint8 => S3) s3Matrix;     \r\n        mapping(uint8 => S6) s6Matrix;      \r\n    }\r\n    struct S3 {\r\n        address currentReferrer;\r\n        address[] referrals;\r\n        bool blocked;\r\n        uint reinvestCount;\r\n    }\r\n    struct S6 {\r\n        address currentReferrer;\r\n        address[] firstLevelReferrals;\r\n        address[] secondLevelReferrals;\r\n        bool blocked;\r\n        uint reinvestCount;\r\n        address closedPart;\r\n    }\r\n    \r\n    \r\n    uint8 public constant LAST_LEVEL = 15;\r\n    IERC20 public tokenDai;\r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n    mapping(address => uint) public balances;\r\n    //START S30\r\n    struct goldInfo {\r\n        uint currentParent;\r\n        uint position;\r\n        address[] childs;\r\n    }\r\n    mapping (address => mapping(uint => goldInfo)) public activeGoldInfos;\r\n    mapping (address => mapping(uint => goldInfo[])) public archivedGoldInfos;\r\n    uint public maxDownLimit = 2;\r\n    //END S30\r\n    uint public lastUserId = 1;\r\n    address public id1=0xe8415248bd7619AeFD9c0b0B9Bb4B4FE0b42c5E7;\r\n    address public excesslevel=0x04DEe2650AB67225f39bce54231a8Bad437E591C;\r\n    address public deductionlevel=0xC9c45a7fB19F8296FAe79A7b802dC74F4B48E53C;\r\n\r\n    mapping(uint8 => uint) public levelS3Price;\r\n    mapping(uint8 => uint) public levelS6Price;\r\n    mapping(uint8 => uint) public levelS30Price;\r\n    uint256 directreward=3e6; \r\n    uint256 levelreward=38e5; \r\n    uint256 levelfee=2e5; \r\n    uint256[10] private levelPercents = [20,18,15,10,7,5,5,6,7,7];\r\n    uint256[10] private levelCondition = [1,1,2,2,3,3,4,5,6,7];\r\n    event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\r\n    event Reinvest(address indexed user, address indexed currentReferrer, address indexed caller, uint8 matrix, uint8 level,uint8 mtype);\r\n    event Payment(address indexed from, address indexed to, uint256 value,uint8 mtype);\r\n    event Upgrade(address indexed user, address indexed referrer, uint8 matrix, uint8 level);\r\n    event NewUserPlace(address indexed user, address indexed referrer, uint8 matrix, uint8 level, uint8 place);\r\n    event MissedEthReceive(address indexed receiver, address indexed from, uint8 matrix, uint8 level);\r\n    event SentExtraEthDividends(address indexed from, address indexed receiver, uint8 matrix, uint8 level);\r\n    \r\n    \r\n    event levelBuyEv(uint amount, uint toID, uint level, uint timeNow);\r\n    constructor(address _token) public {\r\n        \r\n        levelS3Price[1] = 2e6;\r\n        levelS6Price[1] = 2e6;\r\n        levelS30Price[1] = 4e6;\r\n\r\n        for (uint8 i = 2; i <= 15; i++) {\r\n            levelS3Price[i] = levelS3Price[i-1] * 2;            \r\n            levelS6Price[i] = levelS6Price[i-1] * 2;            \r\n            levelS30Price[i] = levelS30Price[i-1] * 2;\r\n        }\r\n        \r\n        tokenDai = IERC20(_token);\r\n        \r\n        User memory user = User({\r\n            id: 1,\r\n            referrer: address(0),\r\n            partnersCount: uint(0),\r\n            levelBought:15\r\n        });\r\n        users[id1] = user;\r\n        idToAddress[1] = id1;\r\n        \r\n        for (uint8 i = 1; i <= LAST_LEVEL; i++) {   \r\n            users[id1].activeS3Levels[i] = true;\r\n            users[id1].activeS6Levels[i] = true; \r\n            users[id1].activeS30Levels[i] = true;          \r\n        }  \r\n        goldInfo memory temp;\r\n        temp.currentParent = 1;\r\n        temp.position = 0;\r\n        for(uint i=1;i<=15;i++)\r\n        {\r\n            activeGoldInfos[id1][i] = temp;\r\n        }\r\n    }\r\n    function registrationExt(address referrerAddress) external {\r\n        tokenDai.transferFrom(msg.sender, address(this), 15e6);\r\n        registration(msg.sender, referrerAddress);\r\n    }\r\n    function registrationFor(address referrerAddress,address userAddress) external {\r\n        tokenDai.transferFrom(msg.sender, address(this), 15e6);\r\n        registration(userAddress, referrerAddress);\r\n    }\r\n    function buyNewLevel(uint8 matrix, uint8 level) external {         \r\n        _buyNewLevel(msg.sender, matrix, level);\r\n    }\r\n    function buyNewLevelFor(address userAddress,uint8 matrix, uint8 level) external {         \r\n        _buyNewLevel(userAddress, matrix, level);\r\n    }\r\n    function _buyNewLevel(address _userAddress, uint8 matrix, uint8 level) internal {\r\n        require(isUserExists(_userAddress), \"user is not exists. Register first.\");\r\n        require(matrix == 1 || matrix == 2 || matrix == 3, \"invalid matrix\");       \r\n\r\n        if (matrix == 1) {\r\n            tokenDai.transferFrom(msg.sender, address(this), levelS3Price[level]);\r\n            require(level > 1 && level <= LAST_LEVEL, \"invalid level\");\r\n            require(users[_userAddress].activeS3Levels[level-1], \"buy previous level first\");\r\n            require(!users[_userAddress].activeS3Levels[level], \"level already activated\");\r\n\r\n            if (users[_userAddress].s3Matrix[level-1].blocked) {\r\n                users[_userAddress].s3Matrix[level-1].blocked = false;\r\n            }\r\n    \r\n            address freeS3Referrer = findFreeS3Referrer(_userAddress, level);\r\n            users[_userAddress].s3Matrix[level].currentReferrer = freeS3Referrer;\r\n            users[_userAddress].activeS3Levels[level] = true;\r\n            updateS3Referrer(_userAddress, freeS3Referrer, level);\r\n            \r\n            emit Upgrade(_userAddress, freeS3Referrer, 1, level);\r\n\r\n        } else if (matrix == 2){\r\n            tokenDai.transferFrom(msg.sender, address(this), levelS6Price[level]);\r\n            require(!users[_userAddress].activeS6Levels[level], \"level already activated\"); \r\n            require(level > 1 && level <= LAST_LEVEL, \"invalid level\");\r\n            require(users[_userAddress].activeS6Levels[level-1], \"buy previous level first\");                \r\n\r\n            if (users[_userAddress].s6Matrix[level-1].blocked) {\r\n                users[_userAddress].s6Matrix[level-1].blocked = false;\r\n            }\r\n            address freeS6Referrer = findFreeS6Referrer(_userAddress, level);\r\n            users[_userAddress].activeS6Levels[level] = true;\r\n            updateS6Referrer(_userAddress, freeS6Referrer, level);\r\n            \r\n            emit Upgrade(_userAddress, freeS6Referrer, 2, level);\r\n        }\r\n        else \r\n        {\r\n            tokenDai.transferFrom(msg.sender, address(this), levelS30Price[level]);\r\n            require(!users[_userAddress].activeS30Levels[level], \"level already activated\"); \r\n            require(level > 1 && level <= LAST_LEVEL, \"invalid level\");\r\n            require(users[_userAddress].activeS30Levels[level-1], \"buy previous level first\");\r\n            users[_userAddress].activeS30Levels[level] = true; \r\n            buyLevel_(_userAddress,level,true);\r\n            tokenDai.transfer(users[_userAddress].referrer,levelS30Price[level]/2);\r\n            emit Payment(_userAddress,users[_userAddress].referrer,levelS30Price[level]/2,8);\r\n            emit Upgrade(_userAddress, id1, 3, level);\r\n        }\r\n    }\r\n    \r\n    function registration(address userAddress, address referrerAddress) private {\r\n        require(!isUserExists(userAddress), \"user exists\");\r\n        require(isUserExists(referrerAddress), \"referrer not exists\");\r\n        lastUserId++;\r\n        User memory user = User({\r\n            id: lastUserId,\r\n            referrer: referrerAddress,\r\n            partnersCount: 0,\r\n            levelBought:1\r\n        });        \r\n        users[userAddress] = user;\r\n        idToAddress[lastUserId] = userAddress;        \r\n        users[userAddress].referrer = referrerAddress;\r\n        users[userAddress].activeS3Levels[1] = true; \r\n        users[userAddress].activeS6Levels[1] = true; \r\n        users[userAddress].activeS30Levels[1] = true; \r\n        users[referrerAddress].partnersCount++;        \r\n\r\n        address freeS3Referrer = findFreeS3Referrer(userAddress, 1);\r\n        users[userAddress].s3Matrix[1].currentReferrer = freeS3Referrer;\r\n        updateS3Referrer(userAddress, freeS3Referrer, 1);\r\n        \r\n        address freeS6Referrer = findFreeS6Referrer(userAddress, 1);\r\n        updateS6Referrer(userAddress, freeS6Referrer, 1);\r\n\r\n        joinedS30Matix(userAddress,referrerAddress,true,levelS30Price[1]);        \r\n        _distributelevelIncome(userAddress);\r\n        emit Registration(userAddress, referrerAddress, users[userAddress].id, users[referrerAddress].id);\r\n    }\r\n    \r\n    function _distributelevelIncome(address _user) private {\r\n        address _referrer = users[_user].referrer;\r\n        tokenDai.transfer(_referrer, directreward); \r\n        emit Payment(_user,_referrer,directreward,1);\r\n        address upline = _referrer;        \r\n        uint8 i = 0;\r\n        for(; i <10; i++){\r\n            if(upline != address(0)){\r\n                uint256 reward=levelreward*levelPercents[i]/100;\r\n                tokenDai.transfer(upline, reward); \r\n                emit Payment(_user,upline,reward,2);\r\n                upline = users[upline].referrer;\r\n            }else{\r\n                break;\r\n            }\r\n        }\r\n        uint256 totalrestreward=0;\r\n        for(; i <10; i++){  \r\n            uint256 reward=levelreward*levelPercents[i]/100;        \r\n            totalrestreward+=reward;          \r\n        }\r\n        tokenDai.transfer(excesslevel, totalrestreward);\r\n        tokenDai.transfer(deductionlevel, levelfee);\r\n\r\n    }\r\n    function updateS3Referrer(address userAddress, address referrerAddress, uint8 level) private {\r\n        users[referrerAddress].s3Matrix[level].referrals.push(userAddress);\r\n\r\n        if (users[referrerAddress].s3Matrix[level].referrals.length < 3) {\r\n            emit NewUserPlace(userAddress, referrerAddress, 1, level, uint8(users[referrerAddress].s3Matrix[level].referrals.length));\r\n            return sendETHDividendsS3(referrerAddress, userAddress, 1, level);\r\n        }\r\n        \r\n        emit NewUserPlace(userAddress, referrerAddress, 1, level, 3);\r\n        //close matrix\r\n        users[referrerAddress].s3Matrix[level].referrals = new address[](0);\r\n        if (!users[referrerAddress].activeS3Levels[level+1] && level != LAST_LEVEL && users[referrerAddress].s3Matrix[level].reinvestCount>0) {\r\n            users[referrerAddress].s3Matrix[level].blocked = true;\r\n        }\r\n\r\n        //create new one by recursion\r\n        if (referrerAddress != id1) {\r\n            //check referrer active level\r\n            address freeReferrerAddress = findFreeS3Referrer(referrerAddress, level);\r\n            if (users[referrerAddress].s3Matrix[level].currentReferrer != freeReferrerAddress) {\r\n                users[referrerAddress].s3Matrix[level].currentReferrer = freeReferrerAddress;\r\n            }\r\n            \r\n            users[referrerAddress].s3Matrix[level].reinvestCount++;\r\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 1, level,1);\r\n            updateS3Referrer(referrerAddress, freeReferrerAddress, level);\r\n        } else {\r\n            sendETHDividendsS3(id1, userAddress, 1, level);\r\n            users[id1].s3Matrix[level].reinvestCount++;\r\n            emit Reinvest(id1, address(0), userAddress, 1, level,1);\r\n        }\r\n    }   \r\n\r\n    function updateS6Referrer(address userAddress, address referrerAddress, uint8 level) private {\r\n        require(users[referrerAddress].activeS6Levels[level], \"500. Referrer level is inactive\");\r\n        \r\n        if (users[referrerAddress].s6Matrix[level].firstLevelReferrals.length < 2) {\r\n            users[referrerAddress].s6Matrix[level].firstLevelReferrals.push(userAddress);\r\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, uint8(users[referrerAddress].s6Matrix[level].firstLevelReferrals.length));\r\n            \r\n            //set current level\r\n            users[userAddress].s6Matrix[level].currentReferrer = referrerAddress;\r\n\r\n            if (referrerAddress == id1) {\r\n                return sendETHDividendsS6(referrerAddress, userAddress, 2, level);\r\n            }\r\n            \r\n            address ref = users[referrerAddress].s6Matrix[level].currentReferrer;            \r\n            users[ref].s6Matrix[level].secondLevelReferrals.push(userAddress); \r\n            \r\n            uint len = users[ref].s6Matrix[level].firstLevelReferrals.length;\r\n            \r\n            if ((len == 2) && \r\n                (users[ref].s6Matrix[level].firstLevelReferrals[0] == referrerAddress) &&\r\n                (users[ref].s6Matrix[level].firstLevelReferrals[1] == referrerAddress)) {\r\n                if (users[referrerAddress].s6Matrix[level].firstLevelReferrals.length == 1) {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 5);\r\n                } else {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 6);\r\n                }\r\n            }  else if ((len == 1 || len == 2) &&\r\n                    users[ref].s6Matrix[level].firstLevelReferrals[0] == referrerAddress) {\r\n                if (users[referrerAddress].s6Matrix[level].firstLevelReferrals.length == 1) {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 3);\r\n                } else {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 4);\r\n                }\r\n            } else if (len == 2 && users[ref].s6Matrix[level].firstLevelReferrals[1] == referrerAddress) {\r\n                if (users[referrerAddress].s6Matrix[level].firstLevelReferrals.length == 1) {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 5);\r\n                } else {\r\n                    emit NewUserPlace(userAddress, ref, 2, level, 6);\r\n                }\r\n            }\r\n            return updateS6ReferrerSecondLevel(userAddress, ref, level);\r\n        }\r\n        \r\n        users[referrerAddress].s6Matrix[level].secondLevelReferrals.push(userAddress);\r\n\r\n        if (users[referrerAddress].s6Matrix[level].closedPart != address(0)) {\r\n            if ((users[referrerAddress].s6Matrix[level].firstLevelReferrals[0] == \r\n                users[referrerAddress].s6Matrix[level].firstLevelReferrals[1]) &&\r\n                (users[referrerAddress].s6Matrix[level].firstLevelReferrals[0] ==\r\n                users[referrerAddress].s6Matrix[level].closedPart)) {\r\n\r\n                updateX6(userAddress, referrerAddress, level, true);\r\n                return updateS6ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n            } else if (users[referrerAddress].s6Matrix[level].firstLevelReferrals[0] == \r\n                users[referrerAddress].s6Matrix[level].closedPart) {\r\n                updateX6(userAddress, referrerAddress, level, true);\r\n                return updateS6ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n            } else {\r\n                updateX6(userAddress, referrerAddress, level, false);\r\n                return updateS6ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n            }\r\n        }\r\n\r\n        if (users[referrerAddress].s6Matrix[level].firstLevelReferrals[1] == userAddress) {\r\n            updateX6(userAddress, referrerAddress, level, false);\r\n            return updateS6ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n        } else if (users[referrerAddress].s6Matrix[level].firstLevelReferrals[0] == userAddress) {\r\n            updateX6(userAddress, referrerAddress, level, true);\r\n            return updateS6ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n        }\r\n        \r\n        if (users[users[referrerAddress].s6Matrix[level].firstLevelReferrals[0]].s6Matrix[level].firstLevelReferrals.length <= \r\n            users[users[referrerAddress].s6Matrix[level].firstLevelReferrals[1]].s6Matrix[level].firstLevelReferrals.length) {\r\n            updateX6(userAddress, referrerAddress, level, false);\r\n        } else {\r\n            updateX6(userAddress, referrerAddress, level, true);\r\n        }\r\n        \r\n        updateS6ReferrerSecondLevel(userAddress, referrerAddress, level);\r\n    }\r\n\r\n    function updateX6(address userAddress, address referrerAddress, uint8 level, bool x2) private {\r\n        if (!x2) {\r\n            users[users[referrerAddress].s6Matrix[level].firstLevelReferrals[0]].s6Matrix[level].firstLevelReferrals.push(userAddress);\r\n            emit NewUserPlace(userAddress, users[referrerAddress].s6Matrix[level].firstLevelReferrals[0], 2, level, uint8(users[users[referrerAddress].s6Matrix[level].firstLevelReferrals[0]].s6Matrix[level].firstLevelReferrals.length));\r\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 2 + uint8(users[users[referrerAddress].s6Matrix[level].firstLevelReferrals[0]].s6Matrix[level].firstLevelReferrals.length));\r\n            //set current level\r\n            users[userAddress].s6Matrix[level].currentReferrer = users[referrerAddress].s6Matrix[level].firstLevelReferrals[0];\r\n        } else {\r\n            users[users[referrerAddress].s6Matrix[level].firstLevelReferrals[1]].s6Matrix[level].firstLevelReferrals.push(userAddress);\r\n            emit NewUserPlace(userAddress, users[referrerAddress].s6Matrix[level].firstLevelReferrals[1], 2, level, uint8(users[users[referrerAddress].s6Matrix[level].firstLevelReferrals[1]].s6Matrix[level].firstLevelReferrals.length));\r\n            emit NewUserPlace(userAddress, referrerAddress, 2, level, 4 + uint8(users[users[referrerAddress].s6Matrix[level].firstLevelReferrals[1]].s6Matrix[level].firstLevelReferrals.length));\r\n            //set current level\r\n            users[userAddress].s6Matrix[level].currentReferrer = users[referrerAddress].s6Matrix[level].firstLevelReferrals[1];\r\n        }\r\n    }\r\n    \r\n    function updateS6ReferrerSecondLevel(address userAddress, address referrerAddress, uint8 level) private {\r\n        if (users[referrerAddress].s6Matrix[level].secondLevelReferrals.length < 4) {\r\n            return sendETHDividendsS6(referrerAddress, userAddress, 2, level);\r\n        }\r\n        \r\n        address[] memory x6 = users[users[referrerAddress].s6Matrix[level].currentReferrer].s6Matrix[level].firstLevelReferrals;\r\n        \r\n        if (x6.length == 2) {\r\n            if (x6[0] == referrerAddress ||\r\n                x6[1] == referrerAddress) {\r\n                users[users[referrerAddress].s6Matrix[level].currentReferrer].s6Matrix[level].closedPart = referrerAddress;\r\n            } else if (x6.length == 1) {\r\n                if (x6[0] == referrerAddress) {\r\n                    users[users[referrerAddress].s6Matrix[level].currentReferrer].s6Matrix[level].closedPart = referrerAddress;\r\n                }\r\n            }\r\n        }\r\n        \r\n        users[referrerAddress].s6Matrix[level].firstLevelReferrals = new address[](0);\r\n        users[referrerAddress].s6Matrix[level].secondLevelReferrals = new address[](0);\r\n        users[referrerAddress].s6Matrix[level].closedPart = address(0);\r\n\r\n        if (!users[referrerAddress].activeS6Levels[level+1] && level != LAST_LEVEL && users[referrerAddress].s6Matrix[level].reinvestCount>0) {\r\n            users[referrerAddress].s6Matrix[level].blocked = true;\r\n        }\r\n\r\n        users[referrerAddress].s6Matrix[level].reinvestCount++;\r\n        \r\n        if (referrerAddress != id1) {\r\n            address freeReferrerAddress = findFreeS6Referrer(referrerAddress, level);\r\n\r\n            emit Reinvest(referrerAddress, freeReferrerAddress, userAddress, 2, level,1);\r\n            updateS6Referrer(referrerAddress, freeReferrerAddress, level);\r\n        } else {\r\n            emit Reinvest(id1, address(0), userAddress, 2, level,1);\r\n            sendETHDividendsS6(id1, userAddress, 2, level);\r\n        }\r\n    }\r\n    \r\n    function findFreeS3Referrer(address userAddress, uint8 level) public view returns(address) {\r\n        while (true) {\r\n            if (users[users[userAddress].referrer].activeS3Levels[level]) {\r\n                return users[userAddress].referrer;\r\n            }\r\n            \r\n            userAddress = users[userAddress].referrer;\r\n        }\r\n    }\r\n    function findFreeS6Referrer(address userAddress, uint8 level) public view returns(address) {\r\n        while (true) {\r\n            if (users[users[userAddress].referrer].activeS6Levels[level]) {\r\n                return users[userAddress].referrer;\r\n            }\r\n            \r\n            userAddress = users[userAddress].referrer;\r\n        }\r\n    }\r\n        \r\n    function usersactiveS3Levels(address userAddress, uint8 level) public view returns(bool) {\r\n        return users[userAddress].activeS3Levels[level];\r\n    }\r\n    function usersactiveS6Levels(address userAddress, uint8 level) public view returns(bool) {\r\n        return users[userAddress].activeS6Levels[level];\r\n    }\r\n    function usersactiveS30Levels(address userAddress, uint8 level) public view returns(bool) {\r\n        return users[userAddress].activeS30Levels[level];\r\n    }\r\n\r\n    function userss3Matrix(address userAddress, uint8 level) public view returns(address, address[] memory, bool) {\r\n        return (users[userAddress].s3Matrix[level].currentReferrer,\r\n                users[userAddress].s3Matrix[level].referrals,\r\n                users[userAddress].s3Matrix[level].blocked);\r\n    }\r\n\r\n    function userss6Matrix(address userAddress, uint8 level) public view returns(address, address[] memory, address[] memory, bool, address) {\r\n        return (users[userAddress].s6Matrix[level].currentReferrer,\r\n                users[userAddress].s6Matrix[level].firstLevelReferrals,\r\n                users[userAddress].s6Matrix[level].secondLevelReferrals,\r\n                users[userAddress].s6Matrix[level].blocked,\r\n                users[userAddress].s6Matrix[level].closedPart);\r\n    }\r\n\r\n    function isUserExists(address user) public view returns (bool) {\r\n        return (users[user].id != 0);\r\n    }\r\n    function findEthReceiver(address userAddress, address _from, uint8 matrix, uint8 level) private returns(address, bool) {\r\n        address receiver = userAddress;\r\n        bool isExtraDividends;\r\n        if (matrix == 1) {\r\n            while (true) {\r\n                if (users[receiver].s3Matrix[level].blocked) {\r\n                    emit MissedEthReceive(receiver, _from, 1, level);\r\n                    isExtraDividends = true;\r\n                    receiver = users[receiver].s3Matrix[level].currentReferrer;\r\n                } else {\r\n                    return (receiver, isExtraDividends);\r\n                }\r\n            }\r\n        } else {\r\n            while (true) {\r\n                if (users[receiver].s6Matrix[level].blocked) {\r\n                    emit MissedEthReceive(receiver, _from, 2, level);\r\n                    isExtraDividends = true;\r\n                    receiver = users[receiver].s6Matrix[level].currentReferrer;\r\n                } else {\r\n                    return (receiver, isExtraDividends);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function sendETHDividendsS3(address userAddress, address _from, uint8 matrix, uint8 level) private {\r\n        (address receiver, bool isExtraDividends) = findEthReceiver(userAddress, _from, matrix, level);\r\n        tokenDai.transfer(receiver, levelS3Price[level]); \r\n        emit Payment(userAddress,receiver, levelS3Price[level],3);    \r\n        if (isExtraDividends) {\r\n            emit SentExtraEthDividends(_from, receiver, matrix, level);\r\n        }\r\n    }\r\n    function sendETHDividendsS6(address userAddress, address _from, uint8 matrix, uint8 level) private {\r\n        (address receiver, bool isExtraDividends) = findEthReceiver(userAddress, _from, matrix, level);\r\n        tokenDai.transfer(receiver, levelS6Price[level]);  \r\n        emit Payment(userAddress,receiver, levelS6Price[level],4);      \r\n        if (isExtraDividends) {\r\n            emit SentExtraEthDividends(_from, receiver, matrix, level);\r\n        }\r\n    }    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n    function joinedS30Matix(address userAddress,address referrerAddress,bool pay, uint _amount) private {\r\n        uint _referrerID = users[referrerAddress].id;\r\n        (uint user4thParent,) = getPosition(userAddress, 1); \r\n        require(user4thParent<30, \"no place under this referrer\");\r\n        (uint _parentID,bool treeComplete) = findFreeParentInDown(_referrerID, 1);\r\n        require(!treeComplete, \"No free place\");\r\n\r\n        goldInfo memory temp;\r\n        temp.currentParent = _parentID;\r\n        temp.position = activeGoldInfos[idToAddress[_parentID]][1].childs.length + 1;\r\n        activeGoldInfos[userAddress][1] = temp;\r\n        activeGoldInfos[idToAddress[_parentID]][1].childs.push(userAddress);\r\n       \r\n        uint userPosition;\r\n        (userPosition, user4thParent) = getPosition(userAddress, 1);\r\n        (,treeComplete) = findFreeParentInDown(user4thParent, 1);\r\n        if(userPosition > 26 && userPosition < 31 ) \r\n        {\r\n            payForLevel(userAddress, 1, true, pay,true);\r\n        }       \r\n        else\r\n        {\r\n            payForLevel(userAddress, 1, false, pay, true);\r\n        }        \r\n        if(treeComplete)\r\n        {\r\n            emit Reinvest(idToAddress[user4thParent], address(0), userAddress, 3, 1,1);\r\n            recyclePosition(user4thParent,1, pay );\r\n        }\r\n        emit NewUserPlace(userAddress,idToAddress[temp.currentParent], 3, 1, uint8(temp.position));\r\n        uint price_ = _amount/2;    \r\n        tokenDai.transfer(referrerAddress, price_);\r\n        emit Payment(userAddress,referrerAddress,price_,8);\r\n    }\r\n    function getPosition(address _user, uint _level) public view returns(uint recyclePosition_, uint recycleID)\r\n    {\r\n        uint a;\r\n        uint b;\r\n        uint c;\r\n        uint d;\r\n        bool id1Found;\r\n        a = activeGoldInfos[_user][_level].position;\r\n        uint parent_ = activeGoldInfos[_user][_level].currentParent;\r\n        b = activeGoldInfos[idToAddress[parent_]][_level].position;\r\n        if(parent_ == 1 ) id1Found = true;\r\n        if(!id1Found)\r\n        {\r\n            parent_ = activeGoldInfos[idToAddress[parent_]][_level].currentParent;\r\n            c = activeGoldInfos[idToAddress[parent_]][_level].position;\r\n            if(parent_ == 1 ) id1Found = true;\r\n        }\r\n        if(!id1Found)\r\n        {\r\n            parent_ = activeGoldInfos[idToAddress[parent_]][_level].currentParent;\r\n            d = activeGoldInfos[idToAddress[parent_]][_level].position;\r\n            if(parent_ == 1 ) id1Found = true;\r\n        }        \r\n        if(!id1Found) parent_ = activeGoldInfos[idToAddress[parent_]][_level].currentParent;        \r\n        if (a == 2 && b == 2 && c == 2 && d == 2 ) return (30, parent_);\r\n        if (a == 1 && b == 2 && c == 2 && d == 2 ) return (29, parent_);\r\n        if (a == 2 && b == 1 && c == 2 && d == 2 ) return (28, parent_);\r\n        if (a == 1 && b == 1 && c == 2 && d == 2 ) return (27, parent_);\r\n        if (a == 2 && b == 1 && c == 1 && d == 1 ) return (16, parent_);\r\n        if (a == 1 && b == 2 && c == 1 && d == 1 ) return (17, parent_);\r\n        if (a == 2 && b == 2 && c == 1 && d == 1 ) return (18, parent_);\r\n        if (a == 1 && b == 1 && c == 2 && d == 1 ) return (19, parent_);        \r\n        else return (1,parent_);\r\n\r\n    }\r\n    function findFreeParentInDown(uint  refID_ , uint _level) public view returns(uint parentID, bool noFreeReferrer)\r\n    {\r\n        address _user = idToAddress[refID_];\r\n        if(activeGoldInfos[_user][_level].childs.length < maxDownLimit) return (refID_, false);\r\n        address[14] memory childss;\r\n        uint[14] memory parenT;\r\n        childss[0] = activeGoldInfos[_user][_level].childs[0];\r\n        parenT[0] = refID_;\r\n        childss[1] = activeGoldInfos[_user][_level].childs[1];\r\n        parenT[1] = refID_;\r\n        address freeReferrer;\r\n        noFreeReferrer = true;\r\n        goldInfo memory temp;\r\n        for(uint i = 0; i < 14; i++)\r\n        {\r\n            temp = getCorrectGold(childss[i],_level, parenT[i] );\r\n            if(temp.childs.length == maxDownLimit) {\r\n                if(i < 6) {\r\n                    childss[(i+1)*2] = temp.childs[0];\r\n                    parenT[(i+1)*2] = users[childss[i]].id;\r\n                    childss[((i+1)*2)+1] = temp.childs[1];\r\n                    parenT[((i+1)*2)+1] = parenT[(i+1)*2];\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = childss[i];\r\n                break;\r\n            } \r\n        } \r\n        if(noFreeReferrer) return (0, noFreeReferrer);      \r\n        return (users[freeReferrer].id, noFreeReferrer);\r\n    }\r\n    function payForLevel(address _user, uint8 _level, bool recycle, bool pay, bool payAll) internal returns(bool)\r\n    {\r\n        uint[4] memory percentPayout;\r\n        percentPayout[0] = 10;\r\n        percentPayout[1] = 20;\r\n        percentPayout[2] = 20;\r\n        if(payAll) percentPayout[3] = 50;\r\n\r\n        address parent_ = idToAddress[activeGoldInfos[_user][_level].currentParent];\r\n        uint price_ = levelS30Price[_level]/2;\r\n        for(uint i = 1;i<=4; i++)\r\n        {\r\n            if(i<4)\r\n            {\r\n                if(pay) tokenDai.transfer(address(uint160(parent_)), price_ * percentPayout[i-1] / 100);\r\n                emit Payment(_user,parent_,price_ * percentPayout[i-1] / 100,5);\r\n            }\r\n            else if(recycle == false)\r\n            {\r\n                if(pay) tokenDai.transfer(address(uint160(parent_)), price_ * percentPayout[i-1] / 100);\r\n                emit Payment(_user,parent_,price_ * percentPayout[i-1] / 100,5);                \r\n            }\r\n            parent_ = idToAddress[activeGoldInfos[parent_][_level].currentParent];\r\n        }\r\n        return true;\r\n    }\r\n    function recyclePosition(uint _userID, uint8 _level, bool pay)  internal returns(bool)\r\n    {\r\n        uint prc = levelS30Price[_level];\r\n        address msgSender = idToAddress[_userID];\r\n        if(users[msgSender].referrer!=address(0))\r\n        {\r\n            uint price_ = prc/2;    \r\n            tokenDai.transfer(users[msgSender].referrer, price_);\r\n            emit Payment(msgSender,users[msgSender].referrer,price_,8);\r\n        }\r\n        archivedGoldInfos[msgSender][_level].push(activeGoldInfos[msgSender][_level]); \r\n        if(_userID == 1) \r\n        {\r\n            goldInfo memory tmp;\r\n            tmp.currentParent = 1;\r\n            tmp.position = 0;\r\n            activeGoldInfos[msgSender][_level] = tmp;\r\n            payForLevel(msgSender, _level, false, pay, true);\r\n            emit NewUserPlace(msgSender,id1, 3, _level, 0);\r\n            return true;\r\n        }\r\n        address _refAddress = users[msgSender].referrer;       \r\n        if(_refAddress == address(0)) _refAddress = id1;\r\n        uint _parentID =   getValidRef(_refAddress, _level);\r\n        (_parentID,) = findFreeParentInDown(_parentID, _level);\r\n\r\n        goldInfo memory temp;\r\n        temp.currentParent = _parentID;\r\n        temp.position = activeGoldInfos[idToAddress[_parentID]][_level].childs.length + 1;\r\n        activeGoldInfos[msgSender][_level] = temp;\r\n        activeGoldInfos[idToAddress[_parentID]][_level].childs.push(msgSender);        \r\n        uint userPosition;        \r\n        (userPosition, prc ) = getPosition(msgSender, _level);\r\n        (,bool treeComplete) = findFreeParentInDown(prc, _level);\r\n        if(userPosition > 26 && userPosition < 31 ) \r\n        {\r\n            payForLevel(msgSender, _level, true, pay, true);\r\n        }             \r\n        else\r\n        {\r\n            payForLevel(msgSender, _level, false, pay, true);      \r\n        }\r\n        emit NewUserPlace(msgSender,idToAddress[temp.currentParent], 3, _level, uint8(temp.position));\r\n        if(treeComplete)\r\n        {           \r\n            emit Reinvest(idToAddress[prc], address(0), msgSender, 3, _level,1);\r\n            recyclePosition(prc, _level, pay);\r\n        }\r\n        return true;\r\n    }\r\n    function getCorrectGold(address childss,uint _level,  uint parenT ) internal view returns (goldInfo memory tmps)\r\n    {\r\n        uint len = archivedGoldInfos[childss][_level].length;\r\n        if(activeGoldInfos[childss][_level].currentParent == parenT) return activeGoldInfos[childss][_level];\r\n        if(len > 0 )\r\n        {\r\n            for(uint j=len-1; j>=0; j--)\r\n            {\r\n                tmps = archivedGoldInfos[childss][_level][j];\r\n                if(tmps.currentParent == parenT)\r\n                {\r\n                    break;                    \r\n                }\r\n                if(j==0) \r\n                {\r\n                    tmps = activeGoldInfos[childss][_level];\r\n                    break;\r\n                }\r\n            }\r\n        } \r\n        else\r\n        {\r\n            tmps = activeGoldInfos[childss][_level];\r\n        }       \r\n        return tmps;\r\n    }\r\n    function getValidRef(address _user, uint _level) public view returns(uint)\r\n    {\r\n        uint refID = users[_user].id;\r\n        uint lvlBgt = users[idToAddress[refID]].levelBought;\r\n        while(lvlBgt < _level)\r\n        {\r\n            refID = users[users[idToAddress[refID]].referrer].id;\r\n            lvlBgt = users[idToAddress[refID]].levelBought;\r\n        }\r\n        return refID;\r\n    }\r\n    function buyLevel_(address msgsender, uint8 _level, bool pay) internal returns(bool)\r\n    {\r\n        (uint user4thParent, ) = getPosition(msgsender, 1); \r\n        address _refAddress = users[msgsender].referrer;\r\n        if(_refAddress == address(0)) _refAddress = id1;\r\n        uint _referrerID = users[_refAddress].id;\r\n        while(users[idToAddress[_referrerID]].levelBought < _level)\r\n        {\r\n            _referrerID = users[users[idToAddress[_referrerID]].referrer].id;\r\n        }\r\n        bool treeComplete;\r\n        (_referrerID,treeComplete) = findFreeParentInDown(_referrerID, _level);\r\n        require(!treeComplete, \"no free place\");\r\n        users[msgsender].levelBought = _level; \r\n        goldInfo memory temp;\r\n        temp.currentParent = _referrerID;\r\n        temp.position = activeGoldInfos[idToAddress[_referrerID]][_level].childs.length + 1;\r\n        activeGoldInfos[msgsender][_level] = temp;\r\n        activeGoldInfos[idToAddress[_referrerID]][_level].childs.push(msgsender);\r\n        uint userPosition;\r\n        (userPosition, user4thParent) = getPosition(msgsender, _level);\r\n        (,treeComplete) = findFreeParentInDown(user4thParent, _level);\r\n        if(userPosition > 26 && userPosition < 31 ) \r\n        {\r\n            payForLevel(msgsender, _level, true, pay, true);\r\n        }        \r\n        else\r\n        {\r\n            payForLevel(msgsender, _level, false, pay, true);\r\n        }        \r\n        if(treeComplete)\r\n        {           \r\n            emit Reinvest(idToAddress[user4thParent], address(0), msgsender, 3, _level,1);\r\n            recyclePosition(user4thParent, _level, pay);\r\n\r\n        }\r\n        emit NewUserPlace(msgsender,idToAddress[_referrerID], 3, _level, uint8(temp.position));\r\n        return true;\r\n    }\r\n    function viewChilds(address _user, uint _level, bool _archived, uint _archivedIndex) public view returns(address[2] memory _child)\r\n    {\r\n        uint len;\r\n        if(!_archived)\r\n        {\r\n            len = activeGoldInfos[_user][_level].childs.length;\r\n            if(len > 0) _child[0] = activeGoldInfos[_user][_level].childs[0];\r\n            if(len > 1) _child[1] = activeGoldInfos[_user][_level].childs[1];\r\n        }\r\n        else\r\n        {\r\n            len = archivedGoldInfos[_user][_level][_archivedIndex].childs.length;\r\n            if(len > 0) _child[0] = archivedGoldInfos[_user][_level][_archivedIndex].childs[0];\r\n            if(len > 1) _child[1] = archivedGoldInfos[_user][_level][_archivedIndex].childs[1];            \r\n        }\r\n        return (_child);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"MissedEthReceive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"place\",\"type\":\"uint8\"}],\"name\":\"NewUserPlace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"mtype\",\"type\":\"uint8\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerId\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentReferrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"mtype\",\"type\":\"uint8\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"SentExtraEthDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"levelBuyEv\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"LAST_LEVEL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activeGoldInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentParent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"archivedGoldInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentParent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"buyNewLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"buyNewLevelFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deductionlevel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"excesslevel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"refID_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"findFreeParentInDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"parentID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"noFreeReferrer\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"findFreeS3Referrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"findFreeS6Referrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"recyclePosition_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recycleID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"getValidRef\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"id1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelS30Price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelS3Price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelS6Price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDownLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"registrationExt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"registrationFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenDai\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"partnersCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelBought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersactiveS30Levels\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersactiveS3Levels\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersactiveS6Levels\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"userss3Matrix\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"userss6Matrix\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_archived\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_archivedIndex\",\"type\":\"uint256\"}],\"name\":\"viewChilds\",\"outputs\":[{\"internalType\":\"address[2]\",\"name\":\"_child\",\"type\":\"address[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Earning_Mate", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://db400b4b8356089ae86a310d795895626f60432a0e5f72df6686b816123d6452"}