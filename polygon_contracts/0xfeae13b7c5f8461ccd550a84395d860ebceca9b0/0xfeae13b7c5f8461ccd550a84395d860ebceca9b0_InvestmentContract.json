{"SourceCode": "// Sources flattened with hardhat v2.12.7 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.8.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.8.1\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.8.1\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.8.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Counters.sol@v4.8.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/investmetComponents/investmentLib.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract InvestmentLib {\r\n    \r\n\r\n    function convertToDecimal6(\r\n        address _TokenAddress,\r\n        uint256 _amountInStableCoin\r\n    ) public view returns (uint256) {\r\n        uint8 stableCoinDecimal = decimal(_TokenAddress);\r\n        return _amountInStableCoin / 10 ** (stableCoinDecimal - 6);\r\n    }\r\n\r\n    function convertDecimal6ToAnyDecimal(\r\n        address _TokenAddress,\r\n        uint256 _amount\r\n    ) public view returns (uint256) {\r\n        uint8 tokenDecimal = decimal(_TokenAddress);\r\n        return _amount * 10 ** (tokenDecimal - 6);\r\n    }\r\n\r\n    function decimal(address _TokenAddress) public view returns (uint8) {\r\n        return IERC20Metadata(_TokenAddress).decimals();\r\n    }\r\n\r\n    function calculateAllocationTokenDecimal6ToDecimal6(\r\n        uint256 amount,\r\n        uint256 tokenPrice\r\n    ) internal pure returns (uint256) {\r\n        uint256 allocationToken = (100 * amount) / tokenPrice;\r\n        return allocationToken;\r\n    }\r\n\r\n    function calculateAllocationTokenAnyDecimalTo6(\r\n        address _tokenAddress,\r\n        uint256 _investmentAmount,\r\n        uint256 _tokenPrice\r\n    ) internal view returns (uint256) {\r\n        uint8 stableCoinDecimal = decimal(_tokenAddress);\r\n        uint8 WSDMDecimal = 6;\r\n\r\n        uint256 allocationToken = (100 * _investmentAmount) /\r\n            _tokenPrice /\r\n            10 ** (stableCoinDecimal - WSDMDecimal);\r\n        return allocationToken;\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::transferFrom: transferFrom failed\"\r\n        );\r\n    }\r\n}\r\n\r\n\r\n// File contracts/investmetComponents/payableTokens.sol\r\n\r\n\r\npragma solidity ^0.8.17;\r\n\r\ncontract PayableTokens {\r\n    mapping(address => bool) private acceptedTokenMapping;\r\n\r\n\r\n    function _isTokenAccepted(address _token) internal view returns (bool) {\r\n        return acceptedTokenMapping[_token];\r\n    }\r\n\r\n    function _initializeTokenMappingFromList(address[] memory _acceptedToken) internal{\r\n        for (uint256 i = 0; i < _acceptedToken.length; i++) {\r\n            acceptedTokenMapping[_acceptedToken[i]] = true;\r\n        }\r\n    }\r\n\r\n    function _addOrRemoveAcceptedToken(address _token, bool _status) internal{\r\n        acceptedTokenMapping[_token] = _status;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/referral.sol\r\n\r\npragma solidity ^0.8.17;\r\ncontract ReferralContract is Ownable, InvestmentLib {\r\n    address public invesmentContractAddress;\r\n    address public immutable TWSDMTokenAddress;\r\n    address public immutable USDTokenAddress;\r\n    address public immutable TWSDMTreasury;\r\n    address public immutable USDTreasury;\r\n    ReferralStatistic referralStatistic;\r\n    GeneralStatistic generalStatistic;\r\n\r\n    enum StatusType {\r\n        DONE,\r\n        PENDING,\r\n        CONFIRMED,\r\n        REJECTED,\r\n        CANCELED\r\n    }\r\n    enum Currency {\r\n        TWSDM,\r\n        USD\r\n    }\r\n    struct GeneralStatistic {\r\n        uint256 totalAmountOfReferralInTWSDM;\r\n        uint256 totalAmountOfReferralInUSD;\r\n        uint256 totalAmountOfWithdrawnTWSDM;\r\n        uint256 totalAmountOfWithdrawnUSD;\r\n        uint256 totalAmountOfReferreeInTWSDM;\r\n    }\r\n    struct ReferralStatistic {\r\n        uint256 totalNumberOfReferrer;\r\n        uint256 totalNumberOfReferree;\r\n    }\r\n    struct Person {\r\n        Referral referralBalance;\r\n        Withdraw lastWithdraw;\r\n        uint256 registredAt;\r\n        string referrerClass;\r\n    }\r\n\r\n    struct Referral {\r\n        uint256 bonusInUSD;\r\n        uint256 bonusInTWSDM;\r\n        uint256 blockInUSD;\r\n        uint256 blockInTWSDM;\r\n    }\r\n    struct Withdraw {\r\n        uint256 amountInTWSDM;\r\n        uint256 amountInUSD;\r\n        uint TWSDMWithdrawalPercentage;\r\n        StatusType status;\r\n    }\r\n    struct ReferrerClass {\r\n        uint256 shareOfReferrerToTWSDM;\r\n        uint256 shareOfReferrerToUSD;\r\n        uint256 shareOfRefereeToTWSDM;\r\n        bool canRefer;\r\n    }\r\n    modifier onlyInvestmentContract() {\r\n        require(\r\n            msg.sender == invesmentContractAddress,\r\n            \"ReferralContract: only invesment contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    mapping(address => Person) public addressPersonMap;\r\n    mapping(string => ReferrerClass) private referrerClassKeyReferrerClassMap;\r\n\r\n    event newReferralClassAdded(string key);\r\n\r\n    event newPersonAdded(address person, address referrer);\r\n    event newReferral(\r\n        address indexed referrer,\r\n        address indexed referree,\r\n        uint256 referrerBonusInTWSDM,\r\n        uint256 referrerBonusInUSD\r\n    );\r\n    event Withdrawal(\r\n        address indexed person,\r\n        uint256 amountInTWSDM,\r\n        uint256 amountInUSD,\r\n        uint TWSDMWithdrawalPercentage,\r\n        StatusType status\r\n    );\r\n\r\n    constructor(\r\n        address _TWSDMTokenAddress,\r\n        address _USDTokenAddress,\r\n        address _TWSDMTreasury,\r\n        address _USDTreasury,\r\n        ReferrerClass memory _defaultReferrerClass\r\n    ) {\r\n        _addOrUpdateReferrerClass(\"default\", _defaultReferrerClass);\r\n        TWSDMTokenAddress = _TWSDMTokenAddress;\r\n        USDTokenAddress = _USDTokenAddress;\r\n        TWSDMTreasury = _TWSDMTreasury;\r\n        USDTreasury = _USDTreasury;\r\n    }\r\n\r\n    function referral(\r\n        address _referrer,\r\n        address _referee,\r\n        uint256 _investedAmount,\r\n        uint256 _TWSDMPriceInCent\r\n    ) public onlyInvestmentContract {\r\n        if (_referrer != address(0)) {\r\n            require(\r\n                _referee != _referrer,\r\n                \"ReferralContract: You cannot refer yourself\"\r\n            );\r\n            _setReferralData(\r\n                _referrer,\r\n                _referee,\r\n                _investedAmount,\r\n                _TWSDMPriceInCent\r\n            );\r\n            _setRefereeData(\r\n                _referrer,\r\n                _referee,\r\n                _investedAmount,\r\n                _TWSDMPriceInCent\r\n            );\r\n        }\r\n        if (addressPersonMap[_referee].registredAt == 0)\r\n            _addPerson(_referee, _referrer, \"default\");\r\n    }\r\n\r\n    function setInvestmentContractAddress(\r\n        address _invesmentContractAddress\r\n    ) public onlyOwner {\r\n        invesmentContractAddress = _invesmentContractAddress;\r\n    }\r\n\r\n    function addPerson(\r\n        address _person,\r\n        string memory _referrerClassKey\r\n    ) public onlyOwner {\r\n        _addPerson(_person, msg.sender, _referrerClassKey);\r\n    }\r\n\r\n    function addOrUpdateReferrerClass(\r\n        string memory _referrerClassKey,\r\n        ReferrerClass memory _referrerClass\r\n    ) public onlyOwner {\r\n        _addOrUpdateReferrerClass(_referrerClassKey, _referrerClass);\r\n    }\r\n\r\n    function updatePersonReferrerClass(\r\n        address _person,\r\n        string memory _referrerClassKey\r\n    ) public onlyOwner {\r\n        addressPersonMap[_person].referrerClass = _referrerClassKey;\r\n    }\r\n\r\n    function requestWithdraw(uint _TWSDMWithdrawalPercentage) public {\r\n        require(\r\n            _TWSDMWithdrawalPercentage <= 100,\r\n            \"ReferralContract: The input value must be between 0 and 100\"\r\n        );\r\n        Withdraw memory _lastWithdraw = addressPersonMap[msg.sender]\r\n            .lastWithdraw;\r\n\r\n        require(\r\n            _lastWithdraw.status != StatusType.PENDING,\r\n            \"ReferralContract: You have already registered a withdrawal request\"\r\n        );\r\n\r\n        require(\r\n            addressPersonMap[msg.sender].referralBalance.bonusInUSD >0 ||\r\n            addressPersonMap[msg.sender].referralBalance.bonusInTWSDM >0 ,\r\n            \"ReferralContract: Insufficient referral balance\"\r\n        );\r\n\r\n        uint256 _amountInTWSDM = (addressPersonMap[msg.sender]\r\n            .referralBalance\r\n            .bonusInTWSDM * _TWSDMWithdrawalPercentage) / 100;\r\n        uint256 _amountInUSD = (addressPersonMap[msg.sender]\r\n            .referralBalance\r\n            .bonusInUSD * (100 - _TWSDMWithdrawalPercentage)) / 100;\r\n\r\n        Withdraw memory _withdraw = Withdraw({\r\n            amountInTWSDM: _amountInTWSDM,\r\n            amountInUSD: _amountInUSD,\r\n            status: StatusType.PENDING,\r\n            TWSDMWithdrawalPercentage: _TWSDMWithdrawalPercentage\r\n        });\r\n        addressPersonMap[msg.sender].lastWithdraw = _withdraw;\r\n        addressPersonMap[msg.sender].referralBalance.blockInTWSDM = addressPersonMap[msg.sender].referralBalance.bonusInTWSDM;\r\n        addressPersonMap[msg.sender].referralBalance.blockInUSD= addressPersonMap[msg.sender].referralBalance.bonusInUSD;\r\n\r\n        addressPersonMap[msg.sender].referralBalance.bonusInTWSDM = 0;\r\n        addressPersonMap[msg.sender].referralBalance.bonusInUSD = 0;\r\n\r\n        emit Withdrawal(\r\n            msg.sender,\r\n            _amountInTWSDM,\r\n            _amountInUSD,\r\n            _TWSDMWithdrawalPercentage,\r\n            StatusType.PENDING\r\n        );\r\n    }\r\n\r\n    function cancelRequestWithdraw() public {\r\n        Withdraw storage _lastWithdraw = addressPersonMap[msg.sender]\r\n            .lastWithdraw;\r\n        require(\r\n            _lastWithdraw.status == StatusType.PENDING,\r\n            \"ReferralContract: No requests have been registered for you\"\r\n        );\r\n        _lastWithdraw.status = StatusType.CANCELED;\r\n        _increaseBalanceAmount(\r\n            msg.sender        );\r\n        emit Withdrawal(\r\n            msg.sender,\r\n            _lastWithdraw.amountInTWSDM,\r\n            _lastWithdraw.amountInUSD,\r\n            _lastWithdraw.TWSDMWithdrawalPercentage,\r\n            _lastWithdraw.status\r\n        );\r\n    }\r\n\r\n    function withdraw(address _person, StatusType _status) public onlyOwner {\r\n        Withdraw storage _lastWithdraw = addressPersonMap[_person].lastWithdraw;\r\n\r\n        require(\r\n            _lastWithdraw.status == StatusType.PENDING,\r\n            \"ReferralContract: No withdrawal request has been registered for this person\"\r\n        );\r\n\r\n        if (_status == StatusType.REJECTED) {\r\n            _lastWithdraw.status = _status;\r\n            _increaseBalanceAmount(\r\n                _person\r\n            );\r\n        } else if (_status == StatusType.CONFIRMED) {\r\n            _lastWithdraw.status = _status;\r\n\r\n            if (_lastWithdraw.amountInUSD > 0) {\r\n                safeTransferFrom(\r\n                    USDTokenAddress,\r\n                    USDTreasury,\r\n                    _person,\r\n                    convertDecimal6ToAnyDecimal(\r\n                        USDTokenAddress,\r\n                        _lastWithdraw.amountInUSD\r\n                    )\r\n                );\r\n                generalStatistic.totalAmountOfWithdrawnUSD += _lastWithdraw\r\n                    .amountInUSD;\r\n            }\r\n            if (_lastWithdraw.amountInTWSDM > 0) {\r\n                safeTransferFrom(\r\n                    TWSDMTokenAddress,\r\n                    TWSDMTreasury,\r\n                    _person,\r\n                    _lastWithdraw.amountInTWSDM\r\n                );\r\n                generalStatistic.totalAmountOfWithdrawnTWSDM += _lastWithdraw\r\n                    .amountInTWSDM;\r\n            }\r\n            addressPersonMap[_person].referralBalance.blockInTWSDM = 0;   \r\n            addressPersonMap[_person].referralBalance.blockInUSD = 0;\r\n\r\n        } else {\r\n            revert(\"ReferralContract: Unexpected status!\");\r\n        }\r\n        emit Withdrawal(\r\n            _person,\r\n            _lastWithdraw.amountInTWSDM,\r\n            _lastWithdraw.amountInUSD,\r\n            _lastWithdraw.TWSDMWithdrawalPercentage,\r\n            _lastWithdraw.status\r\n        );\r\n    }\r\n\r\n    // getter\r\n\r\n    function getPersonData(\r\n        address _person\r\n    ) public view returns (Person memory) {\r\n        return addressPersonMap[_person];\r\n    }\r\n\r\n    function getPersonAvailableBalance(\r\n        address _person\r\n    ) public view returns (uint256 TWSDM, uint256 USD) {\r\n        TWSDM = addressPersonMap[_person].referralBalance.bonusInTWSDM;\r\n        USD = addressPersonMap[_person].referralBalance.bonusInUSD;\r\n    }\r\n\r\n    function getNumberOfTotalRefereeAndReferrer()\r\n        public\r\n        view\r\n        returns (ReferralStatistic memory)\r\n    {\r\n        return (referralStatistic);\r\n    }\r\n\r\n    function getGeneralStatisticsOfPaidTokens()\r\n        public\r\n        view\r\n        returns (GeneralStatistic memory)\r\n    {\r\n        return (generalStatistic);\r\n    }\r\n\r\n    function getReferrerClassByKey(\r\n        string memory _referrerClassKey\r\n    ) public view returns (ReferrerClass memory) {\r\n        return referrerClassKeyReferrerClassMap[_referrerClassKey];\r\n    }\r\n\r\n    // private function\r\n\r\n    function _setReferralData(\r\n        address _referrer,\r\n        address _referee,\r\n        uint256 _investedAmount,\r\n        uint256 _TWSDMPriceInCent\r\n    ) private {\r\n        ReferrerClass\r\n            memory refererClassData = referrerClassKeyReferrerClassMap[\r\n                addressPersonMap[_referrer].referrerClass\r\n            ];\r\n\r\n        require(\r\n            refererClassData.canRefer,\r\n            \"ReferralContract: Referrer not found with this address\"\r\n        );\r\n\r\n        uint256 _referrerBonusInUSD = ((refererClassData.shareOfReferrerToUSD) *\r\n            _investedAmount) / 100;\r\n        uint256 _referrerBonusInTWSDM = ((\r\n            refererClassData.shareOfReferrerToTWSDM\r\n        ) * _investedAmount) / _TWSDMPriceInCent;\r\n\r\n        addressPersonMap[_referrer]\r\n            .referralBalance\r\n            .bonusInUSD += _referrerBonusInUSD;\r\n        addressPersonMap[_referrer]\r\n            .referralBalance\r\n            .bonusInTWSDM += _referrerBonusInTWSDM;\r\n        generalStatistic.totalAmountOfReferralInTWSDM += _referrerBonusInTWSDM;\r\n        generalStatistic.totalAmountOfReferralInUSD += _referrerBonusInUSD;\r\n        emit newReferral(\r\n            _referrer,\r\n            _referee,\r\n            _referrerBonusInTWSDM,\r\n            _referrerBonusInUSD\r\n        );\r\n    }\r\n\r\n    function _setRefereeData(\r\n        address _referrer,\r\n        address _referee,\r\n        uint256 _investedAmount,\r\n        uint256 _TWSDMPriceInCent\r\n    ) private {\r\n        ReferrerClass\r\n            memory refererClassData = referrerClassKeyReferrerClassMap[\r\n                addressPersonMap[_referrer].referrerClass\r\n            ];\r\n\r\n        uint256 _refereeBonusInTWSDM = ((refererClassData.shareOfRefereeToTWSDM) *\r\n            _investedAmount) / _TWSDMPriceInCent;\r\n\r\n        referralStatistic.totalNumberOfReferree += 1;\r\n        generalStatistic.totalAmountOfReferreeInTWSDM += _refereeBonusInTWSDM;\r\n        \r\n        safeTransferFrom(\r\n            TWSDMTokenAddress,\r\n            TWSDMTreasury,\r\n            _referee,\r\n            _refereeBonusInTWSDM\r\n        );\r\n    }\r\n\r\n    function _addPerson(\r\n        address _person,\r\n        address _referrer,\r\n        string memory _referrerClassKey\r\n    ) private {\r\n        require(\r\n            addressPersonMap[_person].registredAt == 0,\r\n            \"ReferralContract: This address is in our persons list\"\r\n        );\r\n        addressPersonMap[_person].registredAt = block.timestamp;\r\n        addressPersonMap[_person].referrerClass = _referrerClassKey;\r\n        referralStatistic.totalNumberOfReferrer += 1;\r\n        emit newPersonAdded(_person, _referrer);\r\n    }\r\n\r\n    function _addOrUpdateReferrerClass(\r\n        string memory _referrerClassKey,\r\n        ReferrerClass memory _ReferrerClass\r\n    ) private {\r\n        referrerClassKeyReferrerClassMap[_referrerClassKey] = _ReferrerClass;\r\n        emit newReferralClassAdded(_referrerClassKey);\r\n    }\r\n\r\n    function _increaseBalanceAmount(\r\n        address _person\r\n    ) private {\r\n        addressPersonMap[_person].referralBalance.bonusInTWSDM +=addressPersonMap[_person].referralBalance.blockInTWSDM;\r\n        addressPersonMap[_person].referralBalance.blockInTWSDM = 0;   \r\n        addressPersonMap[_person].referralBalance.bonusInUSD +=addressPersonMap[_person].referralBalance.blockInUSD;\r\n        addressPersonMap[_person].referralBalance.blockInUSD = 0;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/investment.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.17;\r\n\r\ncontract InvestmentContract is Ownable, PayableTokens, InvestmentLib {\r\n    using Counters for Counters.Counter;\r\n    address public immutable TWSDMTokenAddress;\r\n    address public immutable investmentWallet;\r\n    address referralContractAddress;\r\n    address immutable TWSDMTreasury;\r\n    uint8 currentRoundNumber;\r\n    Counters.Counter public countOfRoundNumber;\r\n\r\n//TODO:per round\r\n    struct Participant{\r\n        uint256 totalInvestor;\r\n        uint256 totalInvestment;\r\n    }\r\n\r\n    struct Investment {\r\n        uint256 investorAmountDeposit;\r\n        uint256 allocatedTWSDMToken;\r\n        address tokenContractAddress;\r\n        uint256 roundNumber;\r\n    }\r\n    struct InvestmentRound {\r\n        uint256 startTime;\r\n        uint256 TWSDMPriceInCent;\r\n        uint256 minTicketSizeInUSD;\r\n        uint256 maxTicketSizeInUSD;\r\n        uint256 hardCapInUSD;\r\n        uint256 totalInvestedInUSD;\r\n        bool isFinished;\r\n    }\r\n\r\n    mapping(uint256 => InvestmentRound) private roundIdRoundMap;\r\n    mapping(address => Investment[]) private addressInvestorMap;\r\n    mapping(uint256 => Participant) private roundIdParticipantMap;\r\n\r\n    modifier addressIsNotZero(address _address) {\r\n        require(\r\n            address(0) != _address,\r\n            \"InvestmentContract: Address is equal to ZERO\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier investmentRoundIsNotStarted(uint256 _roundNumber) {\r\n        require(\r\n            roundIdRoundMap[_roundNumber].startTime > block.timestamp,\r\n            \"InvestmentContract: Investment Round is started\"\r\n        );\r\n        _;\r\n    }\r\n    modifier investmentRoundIsExisted(uint256 _roundNumber) {\r\n        require(\r\n            _roundNumber > 0,\r\n            \"InvestmentContract: There is no zero round\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    event newInvestment(\r\n        address indexed investor,\r\n        uint256 indexed roundNumber,\r\n        uint256 allocatedTWSDMToken,\r\n        address tokenAddress,\r\n        uint256 investmentAmount\r\n    );\r\n\r\n    //test\r\n    constructor(\r\n        address _TWSDMTokenAddress,\r\n        address _TWSDMTreasury,\r\n        address _investmentWallet,\r\n        address _referralContractAddress,\r\n        address[] memory _acceptedToken\r\n    ) {\r\n        TWSDMTokenAddress = _TWSDMTokenAddress;\r\n        TWSDMTreasury = _TWSDMTreasury;\r\n        investmentWallet = _investmentWallet;\r\n        referralContractAddress = _referralContractAddress;\r\n        _initializeTokenMappingFromList(_acceptedToken);\r\n    }\r\n\r\n    function addOrRemoveAcceptedToken(address token, bool status) public onlyOwner{\r\n        _addOrRemoveAcceptedToken(token,status);\r\n    }\r\n\r\n    function setCurrentRoundNumber(uint8 _roundNumber) public onlyOwner {\r\n        currentRoundNumber = _roundNumber;\r\n    }\r\n\r\n    function createNewRound(\r\n        uint256 _startTime,\r\n        uint256 _TWSDMPriceInCent,\r\n        uint256 _minTicketSizeInUSD,\r\n        uint256 _maxTicketSizeInUSD,\r\n        uint256 _hardCapInUSD\r\n    ) public onlyOwner {\r\n        countOfRoundNumber.increment();\r\n\r\n        InvestmentRound memory newInvestmentRound = InvestmentRound({\r\n            startTime: _startTime,\r\n            TWSDMPriceInCent: _TWSDMPriceInCent,\r\n            minTicketSizeInUSD: _minTicketSizeInUSD,\r\n            maxTicketSizeInUSD: _maxTicketSizeInUSD,\r\n            hardCapInUSD: _hardCapInUSD,\r\n            totalInvestedInUSD: 0,\r\n            isFinished: false\r\n        });\r\n        roundIdRoundMap[countOfRoundNumber.current()] = newInvestmentRound;\r\n    }\r\n\r\n    function changeRoundStartTime(\r\n        uint256 _roundNumber,\r\n        uint256 _newStartTime\r\n    ) public onlyOwner investmentRoundIsExisted(_roundNumber) investmentRoundIsNotStarted(_roundNumber) {\r\n        roundIdRoundMap[_roundNumber].startTime = _newStartTime;\r\n    }\r\n\r\n    function changeHardCapInUSD(\r\n        uint256 _roundNumber,\r\n        uint256 _hardCapInUSD\r\n    ) public onlyOwner investmentRoundIsExisted(_roundNumber) investmentRoundIsNotStarted(_roundNumber) {\r\n        roundIdRoundMap[_roundNumber].hardCapInUSD = _hardCapInUSD;\r\n    }\r\n\r\n    function changeMinTicketSizeInUSD(\r\n        uint256 _roundNumber,\r\n        uint256 _minTicketSizeInUSD\r\n    ) public onlyOwner investmentRoundIsExisted(_roundNumber) {\r\n        roundIdRoundMap[_roundNumber].minTicketSizeInUSD = _minTicketSizeInUSD;\r\n    }\r\n\r\n    function changeMaxTicketSizeInUSD(\r\n        uint256 _roundNumber,\r\n        uint256 _maxTicketSizeInUSD\r\n    ) public onlyOwner investmentRoundIsExisted(_roundNumber) {\r\n        roundIdRoundMap[_roundNumber].maxTicketSizeInUSD = _maxTicketSizeInUSD;\r\n    }\r\n\r\n    function changeTWSDMPriceInCent(\r\n        uint256 _roundNumber,\r\n        uint256 _TWSDMPriceInCent\r\n    ) public onlyOwner investmentRoundIsExisted(_roundNumber) investmentRoundIsNotStarted(_roundNumber) {\r\n        roundIdRoundMap[_roundNumber].TWSDMPriceInCent = _TWSDMPriceInCent;\r\n    }\r\n\r\n    function changeRoundFinishedStatus(\r\n        uint256 _roundNumber,\r\n        bool _isFinished\r\n    ) public onlyOwner investmentRoundIsExisted(_roundNumber) {\r\n        roundIdRoundMap[_roundNumber].isFinished = _isFinished;\r\n    }\r\n\r\n    function investByInvestor(\r\n        address _tokenContractAddress,\r\n        uint256 _investmentAmount,\r\n        address _referralAddress\r\n    ) public addressIsNotZero(_tokenContractAddress) investmentRoundIsExisted(currentRoundNumber) {\r\n        require(\r\n            _isTokenAccepted(_tokenContractAddress),\r\n            \"InvestmentContract: this token is not whitelisted!\"\r\n        );\r\n        require(\r\n            block.timestamp >= roundIdRoundMap[currentRoundNumber].startTime &&\r\n            !roundIdRoundMap[currentRoundNumber].isFinished,\r\n            \"InvestmentContract: this round is not started or finished already\"\r\n        );\r\n        uint256 _investmentAmountDecimal6 = convertToDecimal6(\r\n            _tokenContractAddress,\r\n            _investmentAmount\r\n        );\r\n        require(\r\n            _investmentAmountDecimal6 >=\r\n                roundIdRoundMap[currentRoundNumber].minTicketSizeInUSD &&\r\n                _investmentAmountDecimal6 <=\r\n                roundIdRoundMap[currentRoundNumber].maxTicketSizeInUSD,\r\n            \"InvestmentContract: The investment amount is out of range!\"\r\n        );\r\n        require(\r\n            roundIdRoundMap[currentRoundNumber].totalInvestedInUSD + _investmentAmountDecimal6 <=\r\n                roundIdRoundMap[currentRoundNumber].hardCapInUSD,\r\n            \"InvestmentContract: The final investment amount is reached\"\r\n        );\r\n\r\n        safeTransferFrom(\r\n            _tokenContractAddress,\r\n            msg.sender,\r\n            investmentWallet,\r\n            _investmentAmount\r\n        );\r\n\r\n        uint256 allocatedToken = calculateAllocationTokenDecimal6ToDecimal6(\r\n            _investmentAmountDecimal6,\r\n            roundIdRoundMap[currentRoundNumber].TWSDMPriceInCent\r\n        );\r\n        safeTransferFrom(\r\n            TWSDMTokenAddress,\r\n            TWSDMTreasury,\r\n            msg.sender,\r\n            allocatedToken\r\n        );\r\n\r\n        Investment memory _newInvestment = Investment({\r\n            investorAmountDeposit: _investmentAmount,\r\n            roundNumber: currentRoundNumber,\r\n            allocatedTWSDMToken: allocatedToken,\r\n            tokenContractAddress: _tokenContractAddress\r\n        });\r\n        _increaseParticipationStatistics();\r\n        addressInvestorMap[msg.sender].push(_newInvestment);\r\n        _increaseTotalInvestedInUSDInCurrentRound(_investmentAmountDecimal6);\r\n        ReferralContract(referralContractAddress).referral(\r\n            _referralAddress,\r\n            msg.sender,\r\n            _investmentAmountDecimal6,\r\n            roundIdRoundMap[currentRoundNumber].TWSDMPriceInCent\r\n        );\r\n        \r\n        emit newInvestment(\r\n            msg.sender,\r\n            currentRoundNumber,\r\n            allocatedToken,\r\n            _tokenContractAddress,\r\n            _investmentAmountDecimal6\r\n        );\r\n    }\r\n\r\n\r\n    function _increaseTotalInvestedInUSDInCurrentRound(\r\n        uint256 _amount\r\n    ) private {\r\n        roundIdRoundMap[currentRoundNumber].totalInvestedInUSD += _amount;\r\n    }\r\n\r\n    function _increaseParticipationStatistics() private {\r\n        if (addressInvestorMap[msg.sender].length == 0) roundIdParticipantMap[currentRoundNumber].totalInvestor += 1;\r\n        roundIdParticipantMap[currentRoundNumber].totalInvestment += 1;\r\n        \r\n    }\r\n\r\n    function setReferralContractAddress(\r\n        address _referralContractAddress\r\n    ) public onlyOwner {\r\n        referralContractAddress = _referralContractAddress;\r\n    }\r\n\r\n    function getParticipationRate(uint256 _roundNumber)\r\n        public\r\n        view\r\n        returns (Participant memory)\r\n    {\r\n        return roundIdParticipantMap[_roundNumber];\r\n    }\r\n\r\n    function calculateAllocationToken(\r\n        address _tokenAddress,\r\n        uint256 _amount\r\n    ) public view returns (uint256) {\r\n        uint256 _tokenPrice = roundIdRoundMap[currentRoundNumber]\r\n            .TWSDMPriceInCent;\r\n        return\r\n            calculateAllocationTokenAnyDecimalTo6(\r\n                _tokenAddress,\r\n                _amount,\r\n                _tokenPrice\r\n            );\r\n    }\r\n\r\n    function getInvestorInvestments(\r\n        address _investorAddress\r\n    ) public view returns (Investment[] memory) {\r\n        return\r\n            addressInvestorMap[_investorAddress];\r\n    }\r\n\r\n    function getCurrentRoundNumber() public view returns (uint256) {\r\n        return currentRoundNumber;\r\n    }\r\n\r\n    function getRoundDetails(\r\n        uint256 _roundNumber\r\n    ) public view returns (InvestmentRound memory) {\r\n        return roundIdRoundMap[_roundNumber];\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_TWSDMTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_TWSDMTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_investmentWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referralContractAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_acceptedToken\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocatedTWSDMToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investmentAmount\",\"type\":\"uint256\"}],\"name\":\"newInvestment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TWSDMTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"addOrRemoveAcceptedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateAllocationToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hardCapInUSD\",\"type\":\"uint256\"}],\"name\":\"changeHardCapInUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTicketSizeInUSD\",\"type\":\"uint256\"}],\"name\":\"changeMaxTicketSizeInUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTicketSizeInUSD\",\"type\":\"uint256\"}],\"name\":\"changeMinTicketSizeInUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isFinished\",\"type\":\"bool\"}],\"name\":\"changeRoundFinishedStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newStartTime\",\"type\":\"uint256\"}],\"name\":\"changeRoundStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TWSDMPriceInCent\",\"type\":\"uint256\"}],\"name\":\"changeTWSDMPriceInCent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_TokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"convertDecimal6ToAnyDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_TokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountInStableCoin\",\"type\":\"uint256\"}],\"name\":\"convertToDecimal6\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countOfRoundNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_TWSDMPriceInCent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTicketSizeInUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTicketSizeInUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hardCapInUSD\",\"type\":\"uint256\"}],\"name\":\"createNewRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_TokenAddress\",\"type\":\"address\"}],\"name\":\"decimal\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRoundNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investorAddress\",\"type\":\"address\"}],\"name\":\"getInvestorInvestments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"investorAmountDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocatedTWSDMToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roundNumber\",\"type\":\"uint256\"}],\"internalType\":\"struct InvestmentContract.Investment[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"}],\"name\":\"getParticipationRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalInvestor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestment\",\"type\":\"uint256\"}],\"internalType\":\"struct InvestmentContract.Participant\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundNumber\",\"type\":\"uint256\"}],\"name\":\"getRoundDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TWSDMPriceInCent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTicketSizeInUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTicketSizeInUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hardCapInUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestedInUSD\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFinished\",\"type\":\"bool\"}],\"internalType\":\"struct InvestmentContract.InvestmentRound\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_investmentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"investByInvestor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investmentWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_roundNumber\",\"type\":\"uint8\"}],\"name\":\"setCurrentRoundNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referralContractAddress\",\"type\":\"address\"}],\"name\":\"setReferralContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "InvestmentContract", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000f4e2f0b6e9f5ea97d2f959f6a3b4534d03f140400000000000000000000000047742a9b57b13dd909909e511ed2a6982af32cd20000000000000000000000002ec518a5fddcffd7326011feb905768db0bdf9370000000000000000000000002ce91ce931b2772fd35a84cf23c06ccec19ad27f00000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f0000000000000000000000008f3cf7ad23cd3cadbd9735aff958023239c6a0630000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://99f668fce9d71ed2ad2502132a0e9e965c1188c7376f3b2cd307de56a3968de7"}