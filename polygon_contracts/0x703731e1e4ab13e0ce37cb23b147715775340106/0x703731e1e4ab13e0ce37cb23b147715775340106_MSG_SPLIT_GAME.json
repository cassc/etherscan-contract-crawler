{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MSG_SPLIT_GAME.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract MSG_SPLIT_GAME {\\n    using SafeMath for uint256; \\n    uint256 private constant timeStep = 1 days;\\n    uint256 private constant dayPerCycle = 10 days; \\n    uint256 private constant maxAddFreeze = 20 days;\\n    uint256 private constant predictDuration = 30 minutes;\\n    uint256 private constant initDayNewbies = 10;\\n    uint256 private constant incInterval = 2;\\n    uint256 private constant incNumber = 2;\\n    uint256 private constant unlimitDay = 250;\\n    uint256 private constant predictFee = 1e6;\\n    uint256 private constant dayPredictLimit = 10;\\n    uint256 private constant maxSearchDepth = 3000;\\n    uint256 private constant baseDividend = 10000;\\n    uint256 private constant incomeFeePercents = 700;\\n    uint256 private constant bonusPercents = 500;\\n    uint256 private constant splitPercents = 3000;\\n    uint256 private constant transferFeePercents = 1000;\\n    uint256 private constant dayRewardPercents = 150;\\n    uint256 private constant predictPoolPercents = 300;\\n    uint256 private constant unfreezeWithoutIncomePercents = 15000;\\n    uint256 private constant unfreezeWithIncomePercents = 20000;\\n    uint256[5] private levelTeam = [0, 0, 0, 50, 200];\\n    uint256[5] private levelInvite = [0, 0, 0, 10000e6, 20000e6];\\n    uint256[5] private levelDeposit = [50e6, 500e6, 1000e6, 2000e6, 3000e6];\\n    uint256[5] private balReached = [50e10, 100e10, 200e10, 500e10, 1000e10];\\n    uint256[5] private balFreeze = [35e10, 70e10, 100e10, 300e10, 500e10];\\n    uint256[5] private balUnfreeze = [80e10, 150e10, 200e10, 500e10, 1000e10];\\n    uint256[20] private invitePercents = [700, 200, 300, 400, 200, 100, 100, 100, 50, 50, 50, 50, 30, 30, 30, 30, 30, 30, 30, 30];\\n    uint256[20] private predictWinnerPercents = [3000, 2000, 1000, 500, 500, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200];\\n\\n    IERC20 private usdt;\\n    address private defaultRefer;\\n    address private feeReceiver;\\n    uint256 private startTime;\\n    uint256 private lastDistribute;\\n    uint256 private totalUsers;\\n    uint256 private totalDeposit;\\n    uint256 private freezedTimes;\\n    uint256 private predictPool;\\n    uint256 private totalPredictPool;\\n    uint256 private totalWinners;\\n    bool private isFreezing;\\n    address[] private depositors;\\n    mapping(uint256=>bool) private balStatus;\\n    mapping(uint256=>address[]) private dayNewbies;\\n    mapping(uint256=>uint256) private freezeTime;\\n    mapping(uint256=>uint256) private unfreezeTime;\\n    mapping(uint256=>uint256) private dayPredictPool;\\n    mapping(uint256=>uint256) private dayDeposits;\\n    mapping(address=>mapping(uint256=>bool)) private isUnfreezedReward;\\n    mapping(uint256=>mapping(uint256=>address[])) private dayPredictors;\\n    mapping(uint256=>mapping(address=>PredictInfo[])) private userPredicts;\\n    \\n    struct UserInfo {\\n        address referrer;\\n        uint256 level;\\n        uint256 maxDeposit;\\n        uint256 maxDepositable;\\n        uint256 teamNum;\\n        uint256 teamTotalDeposit;\\n        uint256 totalFreezed;\\n        uint256 totalRevenue;\\n        uint256 unfreezeIndex;\\n        uint256 startTime;\\n        bool isMaxFreezing;\\n    }\\n    struct RewardInfo{\\n        uint256 capitals;\\n        uint256 statics;\\n        uint256 invited;\\n        uint256 bonusFreezed;\\n        uint256 bonusReleased;\\n        uint256 l5Freezed;\\n        uint256 l5Released;\\n        uint256 predictWin;\\n        uint256 split;\\n        uint256 lastWithdaw;\\n    }\\n    struct OrderInfo {\\n        uint256 amount;\\n        uint256 start;\\n        uint256 unfreeze;\\n        bool isUnfreezed;\\n    }\\n    struct PredictInfo {\\n        uint256 time;\\n        uint256 number;\\n    }\\n    mapping(address=>UserInfo) private userInfo;\\n    mapping(address=>RewardInfo) private rewardInfo;\\n    mapping(address=>OrderInfo[]) private orderInfos;\\n    mapping(address=>mapping(uint256=>uint256)) private userCycleMax;\\n    mapping(address=>mapping(uint256=>address[])) private teamUsers;\\n\\n    event Register(address user, address referral);\\n    event Deposit(address user, uint256 types, uint256 amount, bool isFreezing);\\n    event TransferBySplit(address user, uint256 subBal, address receiver, uint256 amount);\\n    event Withdraw(address user, uint256 incomeFee, uint256 poolFee, uint256 split, uint256 withdraw);\\n    event Predict(uint256 time, address user, uint256 amount);\\n    event DistributePredictPool(uint256 day, uint256 reward, uint256 pool, uint256 time);\\n\\n    constructor(address _usdtAddr, address _defaultRefer, address _feeReceiver, uint256 _startTime) {\\n        usdt = IERC20(_usdtAddr);\\n        defaultRefer = _defaultRefer;\\n        feeReceiver = _feeReceiver;\\n        startTime = _startTime;\\n        lastDistribute = _startTime;\\n    }\\n\\n    function register(address _referral) external {\\n        require(userInfo[_referral].maxDeposit > 0 || _referral == defaultRefer, \\\"invalid refer\\\");\\n        require(userInfo[msg.sender].referrer == address(0), \\\"referrer bonded\\\");\\n        userInfo[msg.sender].referrer = _referral;\\n        emit Register(msg.sender, _referral);\\n    }\\n\\n    function deposit(uint256 _amount) external {\\n        _deposit(msg.sender, _amount, 0);\\n    }\\n\\n    function depositBySplit(uint256 _amount) public {\\n        _deposit(msg.sender, _amount, 1);\\n\\n    }\\n\\n    function redeposit() public {\\n        _deposit(msg.sender, 0, 2);\\n    }\\n\\n    function _deposit(address _userAddr, uint256 _amount, uint256 _types) private {\\n        require(block.timestamp >= startTime, \\\"not start\\\");\\n        UserInfo storage user = userInfo[_userAddr];\\n        require(user.referrer != address(0), \\\"not register\\\");\\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\\n        if(_types == 0){\\n            usdt.transferFrom(_userAddr, address(this), _amount);\\n            _balActived();\\n        }else if(_types == 1){\\n            require(user.level == 0, \\\"actived\\\");\\n            require(userRewards.split >= _amount, \\\"insufficient\\\");\\n            require(_amount.mod(levelDeposit[0].mul(2)) == 0, \\\"amount err\\\");\\n            userRewards.split = userRewards.split.sub(_amount);\\n        }else{\\n            require(user.level > 0, \\\"newbie\\\");\\n            _amount = orderInfos[_userAddr][user.unfreezeIndex].amount;\\n        }\\n\\n        uint256 curCycle = getCurCycle();\\n        (uint256 userCurMin, uint256 userCurMax) = getUserCycleDepositable(_userAddr, curCycle);\\n        require(_amount >= userCurMin && _amount <= userCurMax && _amount.mod(levelDeposit[0]) == 0, \\\"amount err\\\");\\n        if(isFreezing && !isUnfreezedReward[_userAddr][freezedTimes]) isUnfreezedReward[_userAddr][freezedTimes] = true;\\n        \\n        uint256 curDay = getCurDay();\\n        dayDeposits[curDay] = dayDeposits[curDay].add(_amount);\\n        totalDeposit = totalDeposit.add(_amount);\\n        depositors.push(_userAddr);\\n\\n        if(user.level == 0){\\n            if(curDay < unlimitDay) require(dayNewbies[curDay].length < getMaxDayNewbies(curDay), \\\"reach max\\\");\\n            dayNewbies[curDay].push(_userAddr);\\n            totalUsers = totalUsers + 1;\\n            user.startTime = block.timestamp;\\n            if(_types == 0) {\\n                userRewards.bonusFreezed = _amount.mul(bonusPercents).div(baseDividend);\\n                user.totalRevenue = user.totalRevenue.add(userRewards.bonusFreezed);\\n            }\\n        }\\n        _updateUplineReward(_userAddr, _amount);\\n        _unfreezeCapitalOrReward(_userAddr, _amount, _types);\\n        bool isMaxFreezing = _addNewOrder(_userAddr, _amount, _types, user.startTime, user.isMaxFreezing);\\n        user.isMaxFreezing = isMaxFreezing;\\n        _updateUserMax(_userAddr, _amount, userCurMax, curCycle);\\n        _updateLevel(_userAddr);\\n        if(isFreezing) _setFreezeReward();\\n        emit Deposit(_userAddr, _types, _amount, isFreezing);\\n    }\\n\\n    function _updateUplineReward(address _userAddr, uint256 _amount) private {\\n        address upline = userInfo[_userAddr].referrer;\\n        for(uint256 i = 0; i < invitePercents.length; i++){\\n            if(upline != address(0)){\\n                if(!isFreezing || isUnfreezedReward[upline][freezedTimes]){\\n                    OrderInfo[] storage upOrders = orderInfos[upline];\\n                    if(upOrders.length > 0){\\n                        uint256 latestUnFreezeTime = getOrderUnfreezeTime(upline, upOrders.length - 1);\\n                        uint256 maxFreezing = latestUnFreezeTime > block.timestamp ? upOrders[upOrders.length - 1].amount : 0;\\n                        uint256 newAmount = maxFreezing < _amount ? maxFreezing : _amount;\\n                        if(newAmount > 0){\\n                            RewardInfo storage upRewards = rewardInfo[upline];\\n                            uint256 reward = newAmount.mul(invitePercents[i]).div(baseDividend);\\n                            if(i == 0 || (i < 4 && userInfo[upline].level >= 4)){\\n                                upRewards.invited = upRewards.invited.add(reward);\\n                                userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\n                            }else if(userInfo[upline].level >= 5){\\n                                upRewards.l5Freezed = upRewards.l5Freezed.add(reward);\\n                            }\\n                        }\\n                    }\\n                }\\n                if(upline == defaultRefer) break;\\n                upline = userInfo[upline].referrer;\\n            }else{\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _unfreezeCapitalOrReward(address _userAddr, uint256 _amount, uint256 _types) private {\\n        (uint256 unfreezed, uint256 rewards) = _unfreezeOrder(_userAddr, _amount);\\n        if(_types == 0){\\n            require(_amount > unfreezed, \\\"redeposit only\\\");\\n        }else if(_types >= 2){\\n            require(_amount == unfreezed, \\\"redeposit err\\\");\\n        }\\n\\n        UserInfo storage user = userInfo[_userAddr];\\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\\n        if(unfreezed > 0){\\n            user.unfreezeIndex = user.unfreezeIndex + 1;\\n            if(userRewards.bonusFreezed > 0){\\n                userRewards.bonusReleased = userRewards.bonusFreezed;\\n                userRewards.bonusFreezed = 0;\\n            }\\n\\n            if(rewards > 0) userRewards.statics = userRewards.statics.add(rewards);\\n            if(_types < 2) userRewards.capitals = userRewards.capitals.add(unfreezed);\\n        }else{\\n            uint256 l5Freezed = userRewards.l5Freezed;\\n            if(l5Freezed > 0){\\n                rewards = _amount <= l5Freezed ? _amount : l5Freezed;\\n                userRewards.l5Freezed = l5Freezed.sub(rewards);\\n                userRewards.l5Released = userRewards.l5Released.add(rewards);\\n            }\\n        }\\n        user.totalRevenue = user.totalRevenue.add(rewards);\\n        _updateFreezeAndTeamDeposit(_userAddr, _amount, unfreezed);\\n    }\\n\\n    function _unfreezeOrder(address _userAddr, uint256 _amount) private returns(uint256 unfreezed, uint256 rewards){\\n        if(orderInfos[_userAddr].length > 0){\\n            UserInfo storage user = userInfo[_userAddr];\\n            OrderInfo storage order = orderInfos[_userAddr][user.unfreezeIndex];\\n            uint256 orderUnfreezeTime = getOrderUnfreezeTime(_userAddr, user.unfreezeIndex);\\n            // below lv5, deposit once per cycle\\n            if(user.level > 0 && user.level < 5) require(block.timestamp >= orderUnfreezeTime, \\\"freezing\\\");\\n            if(order.isUnfreezed == false && block.timestamp >= orderUnfreezeTime && _amount >= order.amount){\\n                order.isUnfreezed = true;\\n                unfreezed = order.amount;\\n                rewards = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDividend);\\n                if(isFreezing){\\n                    if(user.totalFreezed > user.totalRevenue){\\n                        uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\\n                        if(rewards > leftCapital){\\n                            rewards = leftCapital;\\n                        }\\n                    }else{\\n                        rewards = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _updateFreezeAndTeamDeposit(address _userAddr, uint256 _amount, uint256 _unfreezed) private {\\n        UserInfo storage user = userInfo[_userAddr];\\n        if(_amount > _unfreezed){\\n            uint256 incAmount = _amount.sub(_unfreezed);\\n            user.totalFreezed = user.totalFreezed.add(incAmount);\\n            address upline = user.referrer;\\n            for(uint256 i = 0; i < invitePercents.length; i++){\\n                if(upline != address(0)){\\n                    UserInfo storage upUser = userInfo[upline];\\n                    if(user.level == 0 && _userAddr != upline){\\n                        upUser.teamNum = upUser.teamNum + 1;\\n                        teamUsers[upline][i].push(_userAddr);\\n                    }\\n                    upUser.teamTotalDeposit = upUser.teamTotalDeposit.add(incAmount);\\n                    if(upline == defaultRefer) break;\\n                    upline = upUser.referrer;\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _addNewOrder(address _userAddr, uint256 _amount, uint256 _types, uint256 _startTime, bool _isMaxFreezing) private returns(bool isMaxFreezing){\\n        uint256 addFreeze;\\n        OrderInfo[] storage orders = orderInfos[_userAddr];\\n        if(_isMaxFreezing){\\n            isMaxFreezing = true;\\n        }else{\\n            if((freezedTimes > 0 && _types == 1) || (!isFreezing && _startTime < freezeTime[freezedTimes])){\\n                isMaxFreezing = true;\\n            }else{\\n                addFreeze = (orders.length).mul(timeStep);\\n                if(addFreeze > maxAddFreeze) isMaxFreezing = true;\\n            }\\n        }\\n        uint256 unfreeze = isMaxFreezing ? block.timestamp.add(dayPerCycle).add(maxAddFreeze) : block.timestamp.add(dayPerCycle).add(addFreeze);\\n        orders.push(OrderInfo(_amount, block.timestamp, unfreeze, false));\\n    }\\n\\n    function _updateUserMax(address _userAddr, uint256 _amount, uint256 _userCurMax, uint256 _curCycle) internal {\\n        UserInfo storage user = userInfo[_userAddr];\\n        if(_amount > user.maxDeposit) user.maxDeposit = _amount;\\n        userCycleMax[_userAddr][_curCycle] = _userCurMax;\\n        uint256 nextMaxDepositable;\\n        if(_amount == _userCurMax){\\n            uint256 curMaxDepositable = getCurMaxDepositable();\\n            if(_userCurMax >= curMaxDepositable){\\n                nextMaxDepositable = curMaxDepositable;\\n            }else{\\n                if(_userCurMax < levelDeposit[3]){\\n                    nextMaxDepositable = _userCurMax.add(levelDeposit[1]);\\n                }else{\\n                    nextMaxDepositable = _userCurMax.add(levelDeposit[2]);\\n                }\\n            }\\n        }else{\\n            nextMaxDepositable = _userCurMax;\\n        }\\n        userCycleMax[_userAddr][_curCycle + 1] = nextMaxDepositable;\\n        user.maxDepositable = nextMaxDepositable;\\n    }\\n\\n    function _updateLevel(address _userAddr) private {\\n        UserInfo storage user = userInfo[_userAddr];\\n        for(uint256 i = user.level; i < levelDeposit.length; i++){\\n            if(user.maxDeposit >= levelDeposit[i]){\\n                if(i < 3){\\n                    user.level = i + 1;\\n                }else{\\n                    (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_userAddr);\\n                    if(maxTeam >= levelInvite[i] && otherTeam >= levelInvite[i] && user.teamNum >= levelTeam[i]){\\n                        user.level = i + 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function withdraw() external {\\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\\n        uint256 rewardsStatic = userRewards.statics.add(userRewards.invited).add(userRewards.bonusReleased).add(userRewards.predictWin);\\n        uint256 incomeFee = rewardsStatic.mul(incomeFeePercents).div(baseDividend);\\n        usdt.transfer(feeReceiver, incomeFee);\\n        uint256 predictPoolFee = rewardsStatic.mul(predictPoolPercents).div(baseDividend);\\n        predictPool = predictPool.add(predictPoolFee);\\n        totalPredictPool = totalPredictPool.add(predictPoolFee);\\n        uint256 leftReward = rewardsStatic.add(userRewards.l5Released).sub(incomeFee).sub(predictPoolFee);\\n        uint256 split = leftReward.mul(splitPercents).div(baseDividend);\\n        uint256 withdrawable = leftReward.sub(split);\\n        uint256 capitals = userRewards.capitals;\\n        userRewards.capitals = 0;\\n        userRewards.statics = 0;\\n        userRewards.invited = 0;\\n        userRewards.bonusReleased = 0;\\n        userRewards.l5Released = 0;\\n        userRewards.predictWin = 0;\\n        userRewards.split = userRewards.split.add(split);\\n        userRewards.lastWithdaw = block.timestamp;\\n        withdrawable = withdrawable.add(capitals);\\n        usdt.transfer(msg.sender, withdrawable);\\n        if(!isFreezing) _setFreezeReward();\\n        emit Withdraw(msg.sender, incomeFee, predictPoolFee, split, withdrawable);\\n    }\\n\\n    function predict(uint256 _amount) external {\\n        require(userInfo[msg.sender].referrer != address(0), \\\"not register\\\");\\n        require(_amount.mod(levelDeposit[0]) == 0, \\\"amount err\\\");\\n        uint256 curDay = getCurDay();\\n        require(userPredicts[curDay][msg.sender].length < dayPredictLimit, \\\"reached day limit\\\");\\n        uint256 predictEnd = startTime.add(curDay.mul(timeStep)).add(predictDuration);\\n        require(block.timestamp < predictEnd, \\\"today is over\\\");\\n        usdt.transferFrom(msg.sender, address(this), predictFee);\\n        dayPredictors[curDay][_amount].push(msg.sender);\\n        userPredicts[curDay][msg.sender].push(PredictInfo(block.timestamp, _amount));\\n        if(isFreezing) _setFreezeReward();\\n        emit Predict(block.timestamp, msg.sender, _amount);\\n    }\\n\\n    function transferBySplit(address _receiver, uint256 _amount) external {\\n        uint256 minTransfer = levelDeposit[0].mul(2);\\n        require(_amount >= minTransfer && _amount.mod(minTransfer) == 0, \\\"amount err\\\");\\n        uint256 subBal = _amount.add(_amount.mul(transferFeePercents).div(baseDividend));\\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\\n        require(userRewards.split >= subBal, \\\"insufficient split\\\");\\n        userRewards.split = userRewards.split.sub(subBal);\\n        rewardInfo[_receiver].split = rewardInfo[_receiver].split.add(_amount);\\n        emit TransferBySplit(msg.sender, subBal, _receiver, _amount);\\n    }\\n\\n    function distributePredictPool() external {\\n        if(block.timestamp >= lastDistribute.add(timeStep)){\\n            uint256 curDay = getCurDay();\\n            uint256 lastDay = curDay - 1;\\n            uint256 totalReward;\\n            if(predictPool > 0){\\n                address[] memory winners = getPredictWinners(lastDay);\\n                for(uint256 i = 0; i < winners.length; i++){\\n                    if(winners[i] != address(0)){\\n                        uint256 reward = predictPool.mul(predictWinnerPercents[i]).div(baseDividend);\\n                        totalReward = totalReward.add(reward);\\n                        rewardInfo[winners[i]].predictWin = rewardInfo[winners[i]].predictWin.add(reward);\\n                        userInfo[winners[i]].totalRevenue = userInfo[winners[i]].totalRevenue.add(reward);\\n                        totalWinners++;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                dayPredictPool[lastDay] = predictPool;\\n                predictPool = predictPool > totalReward ? predictPool.sub(totalReward) : 0;\\n            }\\n            lastDistribute = startTime.add(curDay.mul(timeStep));\\n            emit DistributePredictPool(lastDay, totalReward, predictPool, lastDistribute);\\n        }\\n    }\\n\\n    function _balActived() private {\\n        uint256 bal = usdt.balanceOf(address(this));\\n        for(uint256 i = balReached.length; i > 0; i--){\\n            if(bal >= balReached[i - 1]){\\n                balStatus[balReached[i - 1]] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _setFreezeReward() private {\\n        uint256 bal = usdt.balanceOf(address(this));\\n        for(uint256 i = balReached.length; i > 0; i--){\\n            if(balStatus[balReached[i - 1]]){\\n                if(!isFreezing){\\n                    if(bal < balFreeze[i - 1]){\\n                        isFreezing = true;\\n                        freezedTimes = freezedTimes + 1;\\n                        freezeTime[freezedTimes] = block.timestamp;\\n                    }\\n                }else{\\n                    if(bal >= balUnfreeze[i - 1]){\\n                        isFreezing = false;\\n                        unfreezeTime[freezedTimes] = block.timestamp;\\n                    }\\n                }\\n                break;\\n            }\\n        }\\n    }\\n\\n    function getOrderUnfreezeTime(address _userAddr, uint256 _index) public view returns(uint256 orderUnfreezeTime) {\\n        OrderInfo storage order = orderInfos[_userAddr][_index];\\n        orderUnfreezeTime = order.unfreeze;\\n        if(!isFreezing && !order.isUnfreezed && userInfo[_userAddr].startTime < freezeTime[freezedTimes]){\\n            orderUnfreezeTime =  order.start.add(dayPerCycle).add(maxAddFreeze);\\n        }\\n    }\\n\\n    function getUserCycleDepositable(address _userAddr, uint256 _cycle) public view returns(uint256 cycleMin, uint256 cycleMax) {\\n        UserInfo storage user = userInfo[_userAddr];\\n        if(user.maxDeposit > 0){\\n            cycleMin = user.maxDeposit;\\n            cycleMax = userCycleMax[_userAddr][_cycle];\\n            if(cycleMax == 0) cycleMax = user.maxDepositable;\\n            uint256 curMaxDepositable = getCurMaxDepositable();\\n            if(isFreezing){\\n                if(user.startTime < freezeTime[freezedTimes] && !isUnfreezedReward[_userAddr][freezedTimes]){\\n                    cycleMin = user.totalFreezed > user.totalRevenue ? cycleMin.mul(unfreezeWithoutIncomePercents).div(baseDividend) : cycleMin.mul(unfreezeWithIncomePercents).div(baseDividend);\\n                    cycleMax = curMaxDepositable;\\n                }\\n            }else{\\n                if(user.startTime < freezeTime[freezedTimes]) cycleMax = curMaxDepositable;\\n            }\\n        }else{\\n            cycleMin = levelDeposit[0];\\n            cycleMax = levelDeposit[1];\\n        }\\n\\n        if(cycleMin > cycleMax) cycleMin = cycleMax;\\n    }\\n\\n    function getPredictWinners(uint256 _day) public view returns(address[] memory winners) {\\n        uint256 steps = dayDeposits[_day].div(levelDeposit[0]);\\n        uint256 maxWinners = predictWinnerPercents.length;\\n        winners = new address[](maxWinners);\\n        uint256 counter;\\n        for(uint256 i = steps; i >= 0; i--){\\n            uint256 winAmount = i.mul(levelDeposit[0]);\\n            for(uint256 j = 0; j < dayPredictors[_day][winAmount].length; j++){\\n                address predictUser = dayPredictors[_day][winAmount][j];\\n                if(predictUser != address(0)){\\n                    winners[counter] = predictUser;\\n                    counter++;\\n                    if(counter >= maxWinners) break;\\n                }\\n            }\\n            if(counter >= maxWinners || i == 0 || steps.sub(i) >= maxSearchDepth) break;\\n        }\\n    }\\n\\n    function getTeamDeposit(address _userAddr) public view returns(uint256 maxTeam, uint256 otherTeam, uint256 totalTeam){\\n        address[] memory directTeamUsers = teamUsers[_userAddr][0];\\n        for(uint256 i = 0; i < directTeamUsers.length; i++){\\n            UserInfo storage user = userInfo[directTeamUsers[i]];\\n            uint256 userTotalTeam = user.teamTotalDeposit.add(user.totalFreezed);\\n            totalTeam = totalTeam.add(userTotalTeam);\\n            if(userTotalTeam > maxTeam) maxTeam = userTotalTeam;\\n            if(i >= maxSearchDepth) break;\\n        }\\n        otherTeam = totalTeam.sub(maxTeam);\\n    }\\n\\n    function getCurDay() public view returns(uint256) {\\n        return (block.timestamp.sub(startTime)).div(timeStep);\\n    }\\n\\n    function getCurCycle() public view returns(uint256) {\\n        return (block.timestamp.sub(startTime)).div(dayPerCycle);\\n    }\\n\\n    function getCurMaxDepositable() public view returns(uint256) {\\n        return levelDeposit[4].mul(2**freezedTimes);\\n    }\\n\\n    // \\n    function getMaxDayNewbies(uint256 _day) public pure returns(uint256) {\\n        uint256 incrementPeriods = _day.div(incInterval);\\n        return initDayNewbies + incrementPeriods.mul(incNumber);\\n    }\\n\\n    function getOrderLength(address _userAddr) public view returns(uint256) {\\n        return orderInfos[_userAddr].length;\\n    }\\n\\n    function getLatestDepositors(uint256 _length) public view returns(address[] memory latestDepositors) {\\n        uint256 totalCount = depositors.length;\\n        if(_length > totalCount) _length = totalCount;\\n        latestDepositors = new address[](_length);\\n        for(uint256 i = totalCount; i > totalCount - _length; i--){\\n            latestDepositors[totalCount - i] = depositors[i - 1];\\n        }\\n    }\\n\\n    function getTeamUsers(address _userAddr, uint256 _layer) public view returns(address[] memory) {\\n        return teamUsers[_userAddr][_layer];\\n    }\\n\\n    function getUserDayPredicts(address _userAddr, uint256 _day) public view returns(PredictInfo[] memory) {\\n        return userPredicts[_day][_userAddr];\\n    }\\n\\n    function getDayPredictors(uint256 _day, uint256 _number) external view returns(address[] memory) {\\n        return dayPredictors[_day][_number];\\n    }\\n\\n    function getDayInfos(uint256 _day) external view returns(address[] memory newbies, uint256 deposits, uint256 pool){\\n        return (dayNewbies[_day], dayDeposits[_day], dayPredictPool[_day]);\\n    }\\n\\n    function getBalStatus(uint256 _bal) external view returns(bool) {\\n        return balStatus[_bal];\\n    }\\n\\n    function getUserCycleMax(address _userAddr, uint256 _cycle) external view returns(uint256){\\n        return userCycleMax[_userAddr][_cycle];\\n    }\\n\\n    function getUserInfos(address _userAddr) external view returns(UserInfo memory user, RewardInfo memory reward, OrderInfo[] memory orders, bool unfreeze) {\\n        user = userInfo[_userAddr];\\n        reward = rewardInfo[_userAddr];\\n        orders = orderInfos[_userAddr];\\n        unfreeze = isUnfreezedReward[_userAddr][freezedTimes];\\n    }\\n\\n    function getContractInfos() external view returns(address[3] memory infos0, uint256[10] memory infos1, bool freezing) {\\n        infos0[0] = address(usdt);\\n        infos0[1] = feeReceiver;\\n        infos0[2] = defaultRefer;\\n        infos1[0] = startTime;\\n        infos1[1] = lastDistribute;\\n        infos1[2] = totalUsers;\\n        infos1[3] = totalDeposit;\\n        infos1[4] = predictPool;\\n        infos1[5] = totalPredictPool;\\n        infos1[6] = totalWinners;\\n        infos1[7] = freezedTimes;\\n        infos1[8] = freezeTime[freezedTimes];\\n        infos1[9] = unfreezeTime[freezedTimes];\\n        freezing = isFreezing;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"types\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFreezing\",\"type\":\"bool\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"DistributePredictPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Predict\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subBal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdraw\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePredictPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bal\",\"type\":\"uint256\"}],\"name\":\"getBalStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractInfos\",\"outputs\":[{\"internalType\":\"address[3]\",\"name\":\"infos0\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[10]\",\"name\":\"infos1\",\"type\":\"uint256[10]\"},{\"internalType\":\"bool\",\"name\":\"freezing\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurMaxDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getDayInfos\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"newbies\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getDayPredictors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"getLatestDepositors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"latestDepositors\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getMaxDayNewbies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getOrderUnfreezeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderUnfreezeTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getPredictWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"otherTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleMax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getUserDayPredicts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct MSG_SPLIT_GAME.PredictInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getUserInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreezeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMaxFreezing\",\"type\":\"bool\"}],\"internalType\":\"struct MSG_SPLIT_GAME.UserInfo\",\"name\":\"user\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusReleased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l5Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l5Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictWin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdaw\",\"type\":\"uint256\"}],\"internalType\":\"struct MSG_SPLIT_GAME.RewardInfo\",\"name\":\"reward\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"internalType\":\"struct MSG_SPLIT_GAME.OrderInfo[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"unfreeze\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"predict\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MSG_SPLIT_GAME", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000e3d283998a24545fd3b91ae3a848d618bf48e407000000000000000000000000fb51f14a7b47598f9ae0f333cfd900e3ee85ebbd0000000000000000000000000000000000000000000000000000000064bcbad8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}