{"SourceCode": "{\"AccessController.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83c\udfb2 --\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ncontract AccessController {\\r\\n\\r\\n    address public ceoAddress;\\r\\n\\r\\n    mapping (address =\\u003e bool) public isWorker;\\r\\n\\r\\n    event CEOSet(\\r\\n        address newCEO\\r\\n    );\\r\\n\\r\\n    event WorkerAdded(\\r\\n        address newWorker\\r\\n    );\\r\\n\\r\\n    event WorkerRemoved(\\r\\n        address existingWorker\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n\\r\\n        address creator = msg.sender;\\r\\n\\r\\n        ceoAddress = creator;\\r\\n\\r\\n        isWorker[creator] = true;\\r\\n\\r\\n        emit CEOSet(\\r\\n            creator\\r\\n        );\\r\\n\\r\\n        emit WorkerAdded(\\r\\n            creator\\r\\n        );\\r\\n    }\\r\\n\\r\\n    modifier onlyCEO() {\\r\\n        require(\\r\\n            msg.sender == ceoAddress,\\r\\n            \\u0027AccessControl: CEO access denied\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWorker() {\\r\\n        require(\\r\\n            isWorker[msg.sender] == true,\\r\\n            \\u0027AccessControl: worker access denied\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier nonZeroAddress(address checkingAddress) {\\r\\n        require(\\r\\n            checkingAddress != address(0x0),\\r\\n            \\u0027AccessControl: invalid address\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setCEO(\\r\\n        address _newCEO\\r\\n    )\\r\\n        external\\r\\n        nonZeroAddress(_newCEO)\\r\\n        onlyCEO\\r\\n    {\\r\\n        ceoAddress = _newCEO;\\r\\n\\r\\n        emit CEOSet(\\r\\n            ceoAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function addWorker(\\r\\n        address _newWorker\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        _addWorker(\\r\\n            _newWorker\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function addWorkerBulk(\\r\\n        address[] calldata _newWorkers\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        for (uint8 index = 0; index \\u003c _newWorkers.length; index++) {\\r\\n            _addWorker(_newWorkers[index]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _addWorker(\\r\\n        address _newWorker\\r\\n    )\\r\\n        internal\\r\\n        nonZeroAddress(_newWorker)\\r\\n    {\\r\\n        require(\\r\\n            isWorker[_newWorker] == false,\\r\\n            \\u0027AccessControl: worker already exist\\u0027\\r\\n        );\\r\\n\\r\\n        isWorker[_newWorker] = true;\\r\\n\\r\\n        emit WorkerAdded(\\r\\n            _newWorker\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function removeWorker(\\r\\n        address _existingWorker\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        _removeWorker(\\r\\n            _existingWorker\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function removeWorkerBulk(\\r\\n        address[] calldata _workerArray\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        for (uint8 index = 0; index \\u003c _workerArray.length; index++) {\\r\\n            _removeWorker(_workerArray[index]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _removeWorker(\\r\\n        address _existingWorker\\r\\n    )\\r\\n        internal\\r\\n        nonZeroAddress(_existingWorker)\\r\\n    {\\r\\n        require(\\r\\n            isWorker[_existingWorker] == true,\\r\\n            \\\"AccessControl: worker not detected\\\"\\r\\n        );\\r\\n\\r\\n        isWorker[_existingWorker] = false;\\r\\n\\r\\n        emit WorkerRemoved(\\r\\n            _existingWorker\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"},\"EIP712Base.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83c\udfb2 --\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ncontract EIP712Base {\\r\\n\\r\\n    struct EIP712Domain {\\r\\n        string name;\\r\\n        string version;\\r\\n        uint256 chainId;\\r\\n        address verifyingContract;\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"));\\r\\n    bytes32 internal domainSeperator;\\r\\n\\r\\n    constructor(string memory name, string memory version) {\\r\\n        domainSeperator = keccak256(abi.encode(\\r\\n\\t\\t\\tEIP712_DOMAIN_TYPEHASH,\\r\\n\\t\\t\\tkeccak256(bytes(name)),\\r\\n\\t\\t\\tkeccak256(bytes(version)),\\r\\n\\t\\t\\tgetChainID(),\\r\\n\\t\\t\\taddress(this)\\r\\n\\t\\t));\\r\\n    }\\r\\n\\r\\n    function getChainID() internal pure returns (uint256 id) {\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tid := 1 // set to Goerli for now, Mainnet later\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n    function getDomainSeperator() private view returns(bytes32) {\\r\\n\\t\\treturn domainSeperator;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n    * Accept message hash and returns hash message in EIP712 compatible form\\r\\n    * So that it can be used to recover signer from signature signed using EIP712 formatted data\\r\\n    * https://eips.ethereum.org/EIPS/eip-712\\r\\n    * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\r\\n    * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\r\\n    */\\r\\n    function toTypedMessageHash(bytes32 messageHash) internal view returns(bytes32) {\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", getDomainSeperator(), messageHash));\\r\\n    }\\r\\n}\\r\\n\"},\"EIP712MetaTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83d\udc8e --\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./EIP712Base.sol\\\";\\r\\n\\r\\nabstract contract EIP712MetaTransaction is EIP712Base {\\r\\n\\r\\n    bytes32 private constant META_TRANSACTION_TYPEHASH =\\r\\n        keccak256(\\r\\n            bytes(\\r\\n                \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\r\\n            )\\r\\n        );\\r\\n\\r\\n    event MetaTransactionExecuted(\\r\\n        address userAddress,\\r\\n        address payable relayerAddress,\\r\\n        bytes functionSignature\\r\\n    );\\r\\n\\r\\n    mapping(address =\\u003e uint256) internal nonces;\\r\\n\\r\\n    /*\\r\\n     * Meta transaction structure.\\r\\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\\r\\n     * He should call the desired function directly in that case.\\r\\n     */\\r\\n    struct MetaTransaction {\\r\\n\\t\\tuint256 nonce;\\r\\n\\t\\taddress from;\\r\\n        bytes functionSignature;\\r\\n\\t}\\r\\n\\r\\n    function executeMetaTransaction(\\r\\n        address userAddress,\\r\\n        bytes memory functionSignature,\\r\\n        bytes32 sigR,\\r\\n        bytes32 sigS,\\r\\n        uint8 sigV\\r\\n    )\\r\\n        public\\r\\n        payable\\r\\n        returns(bytes memory)\\r\\n    {\\r\\n        MetaTransaction memory metaTx = MetaTransaction(\\r\\n            {\\r\\n                nonce: nonces[userAddress],\\r\\n                from: userAddress,\\r\\n                functionSignature: functionSignature\\r\\n            }\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            verify(\\r\\n                userAddress,\\r\\n                metaTx,\\r\\n                sigR,\\r\\n                sigS,\\r\\n                sigV\\r\\n            ), \\\"Signer and signature do not match\\\"\\r\\n        );\\r\\n\\r\\n\\t    nonces[userAddress] =\\r\\n\\t    nonces[userAddress] + 1;\\r\\n\\r\\n        // Append userAddress at the end to extract it from calling context\\r\\n        (bool success, bytes memory returnData) = address(this).call(\\r\\n            abi.encodePacked(\\r\\n                functionSignature,\\r\\n                userAddress\\r\\n            )\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            success,\\r\\n            \\u0027Function call not successful\\u0027\\r\\n        );\\r\\n\\r\\n        emit MetaTransactionExecuted(\\r\\n            userAddress,\\r\\n            payable(msg.sender),\\r\\n            functionSignature\\r\\n        );\\r\\n\\r\\n        return returnData;\\r\\n    }\\r\\n\\r\\n    function hashMetaTransaction(\\r\\n        MetaTransaction memory metaTx\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n\\t\\treturn keccak256(\\r\\n\\t\\t    abi.encode(\\r\\n                META_TRANSACTION_TYPEHASH,\\r\\n                metaTx.nonce,\\r\\n                metaTx.from,\\r\\n                keccak256(metaTx.functionSignature)\\r\\n            )\\r\\n        );\\r\\n\\t}\\r\\n\\r\\n    function verify(\\r\\n        address user,\\r\\n        MetaTransaction memory metaTx,\\r\\n        bytes32 sigR,\\r\\n        bytes32 sigS,\\r\\n        uint8 sigV\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        address signer = ecrecover(\\r\\n            toTypedMessageHash(\\r\\n                hashMetaTransaction(metaTx)\\r\\n            ),\\r\\n            sigV,\\r\\n            sigR,\\r\\n            sigS\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            signer != address(0x0),\\r\\n            \\u0027Invalid signature\\u0027\\r\\n        );\\r\\n\\t\\treturn signer == user;\\r\\n\\t}\\r\\n\\r\\n    function msgSender() internal view returns(address sender) {\\r\\n        if(msg.sender == address(this)) {\\r\\n            bytes memory array = msg.data;\\r\\n            uint256 index = msg.data.length;\\r\\n            assembly {\\r\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\r\\n                sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\r\\n            }\\r\\n        } else {\\r\\n            sender = msg.sender;\\r\\n        }\\r\\n        return sender;\\r\\n    }\\r\\n\\r\\n    function getNonce(\\r\\n        address _user\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns(uint256 nonce)\\r\\n    {\\r\\n        nonce = nonces[_user];\\r\\n    }\\r\\n}\\r\\n\"},\"Events.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83d\udc8e --\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ncontract Events {\\r\\n\\r\\n    event UpgradeItem(\\r\\n        uint256 indexed itemId,\\r\\n        uint256 issuedId,\\r\\n        address indexed tokenOwner,\\r\\n        uint256 indexed tokenId,\\r\\n        address tokenAddress,\\r\\n        uint256 requestIndex\\r\\n    );\\r\\n\\r\\n    event UpgradeResolved(\\r\\n        uint256 indexed newItemId,\\r\\n        address indexed tokenOwner,\\r\\n        uint256 indexed newTokenId,\\r\\n        address tokenAddress\\r\\n    );\\r\\n\\r\\n    event LevelEdit(\\r\\n        uint256 indexed level,\\r\\n        uint256 dgCostAmount,\\r\\n        uint256 dgMoveAmount,\\r\\n        uint256 iceCostAmount,\\r\\n        uint256 iceMoveAmount,\\r\\n        bool isActive\\r\\n    );\\r\\n\\r\\n    event IceLevelTransfer(\\r\\n        address oldOwner,\\r\\n        address indexed newOwner,\\r\\n        address indexed tokenAddress,\\r\\n        uint256 indexed tokenId\\r\\n    );\\r\\n\\r\\n    event InitialMinting(\\r\\n        uint256 indexed tokenId,\\r\\n        uint256 indexed mintCount,\\r\\n        address indexed tokenOwner\\r\\n    );\\r\\n\\r\\n    event SupplyCheck(\\r\\n        string rarity,\\r\\n        uint256 maxSupply,\\r\\n        uint256 price,\\r\\n        address indexed beneficiary,\\r\\n        string indexed metadata,\\r\\n        string indexed contentHash\\r\\n    );\\r\\n}\\r\\n\"},\"iceRegistrant.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83e\uddca --\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./EIP712MetaTransaction.sol\\\";\\r\\nimport \\\"./AccessController.sol\\\";\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./Events.sol\\\";\\r\\n\\r\\ncontract IceRegistrant is AccessController, TransferHelper, EIP712MetaTransaction, Events {\\r\\n\\r\\n    uint256 public upgradeCount;\\r\\n    uint256 public upgradeRequestCount;\\r\\n\\r\\n    address public tokenAddressDG;\\r\\n    address public tokenAddressICE;\\r\\n\\r\\n    address public depositAddressDG;\\r\\n    address public depositAddressNFT;\\r\\n\\r\\n    address public paymentToken;\\r\\n    uint256 public mintingPrice;\\r\\n\\r\\n    uint256 public saleCount;\\r\\n\\r\\n    uint256 public saleLimit;\\r\\n    uint256 public saleFrame;\\r\\n\\r\\n    bool public allowChangeSaleLimit;\\r\\n\\r\\n    struct Level {\\r\\n        bool isActive;\\r\\n        uint256 costAmountDG;\\r\\n        uint256 moveAmountDG;\\r\\n        uint256 costAmountICE;\\r\\n        uint256 moveAmountICE;\\r\\n        uint256 floorBonus;\\r\\n        uint256 deltaBonus;\\r\\n    }\\r\\n\\r\\n    struct Upgrade {\\r\\n        uint256 level;\\r\\n        uint256 bonus;\\r\\n    }\\r\\n\\r\\n    struct Request {\\r\\n        uint256 itemId;\\r\\n        uint256 tokenId;\\r\\n        address tokenAddress;\\r\\n        address tokenOwner;\\r\\n    }\\r\\n\\r\\n    mapping (bytes32 =\\u003e address) public owners;\\r\\n    mapping (address =\\u003e address) public targets;\\r\\n\\r\\n    mapping (address =\\u003e uint256) public frames;\\r\\n    mapping (uint256 =\\u003e uint256) public limits;\\r\\n\\r\\n    mapping (uint256 =\\u003e Level) public levels;\\r\\n    mapping (uint256 =\\u003e Request) public requests;\\r\\n\\r\\n    mapping (address =\\u003e mapping (bytes32 =\\u003e Upgrade)) public registrer;\\r\\n\\r\\n    constructor(\\r\\n        uint256 _mintingPrice,\\r\\n        address _paymentToken,\\r\\n        address _tokenAddressDG,\\r\\n        address _tokenAddressICE,\\r\\n        address _accessoriesContract\\r\\n    )\\r\\n        EIP712Base(\\u0027IceRegistrant\\u0027, \\u0027v1.3\\u0027)\\r\\n    {\\r\\n        saleLimit = 500;\\r\\n        saleFrame = 1 hours;\\r\\n\\r\\n        paymentToken = _paymentToken;\\r\\n        mintingPrice = _mintingPrice;\\r\\n\\r\\n        tokenAddressDG = _tokenAddressDG;\\r\\n        tokenAddressICE = _tokenAddressICE;\\r\\n\\r\\n        allowChangeSaleLimit = true;\\r\\n\\r\\n        targets[_accessoriesContract] = _accessoriesContract;\\r\\n\\r\\n        levels[0].floorBonus = 1;\\r\\n        levels[0].deltaBonus = 6;\\r\\n\\r\\n        limits[0] = 100;\\r\\n    }\\r\\n\\r\\n    function changeTokenAddressICE(\\r\\n        address _newTokenAddressICE\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        tokenAddressICE = _newTokenAddressICE;\\r\\n    }\\r\\n\\r\\n    function changeTokenAddressDG(\\r\\n        address _newTokenAddressDG\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        tokenAddressDG = _newTokenAddressDG;\\r\\n    }\\r\\n\\r\\n    function changeDepositAddressDG(\\r\\n        address _newDepositAddressDG\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        depositAddressDG = _newDepositAddressDG;\\r\\n    }\\r\\n\\r\\n    function changeDepositAddressNFT(\\r\\n        address _newDepositAddressNFT\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        depositAddressNFT = _newDepositAddressNFT;\\r\\n    }\\r\\n\\r\\n    function changeMintingPrice(\\r\\n        uint256 _newMintingPrice\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        mintingPrice = _newMintingPrice;\\r\\n    }\\r\\n\\r\\n    function changeMintLimits(\\r\\n        uint256 _itemId,\\r\\n        uint256 _newLimit\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        limits[_itemId] = _newLimit;\\r\\n    }\\r\\n\\r\\n    function changeSaleFrame(\\r\\n        uint256 _newSaleFrame\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        saleFrame = _newSaleFrame;\\r\\n    }\\r\\n\\r\\n    function changeSaleLimit(\\r\\n        uint256 _newSaleLimit\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        require(\\r\\n            allowChangeSaleLimit == true,\\r\\n            \\u0027iceRegistrant: change disabled\\u0027\\r\\n        );\\r\\n\\r\\n        saleLimit = _newSaleLimit;\\r\\n    }\\r\\n\\r\\n    function disabledSaleLimitChange()\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        allowChangeSaleLimit = false;\\r\\n    }\\r\\n\\r\\n    function changePaymentToken(\\r\\n        address _newPaymentToken\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        paymentToken = _newPaymentToken;\\r\\n    }\\r\\n\\r\\n    function changeTargetContract(\\r\\n        address _tokenAddress,\\r\\n        address _accessoriesContract\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        targets[_tokenAddress] = _accessoriesContract;\\r\\n    }\\r\\n\\r\\n    function manageLevel(\\r\\n        uint256 _level,\\r\\n        uint256 _costAmountDG,\\r\\n        uint256 _moveAmountDG,\\r\\n        uint256 _costAmountICE,\\r\\n        uint256 _moveAmountICE,\\r\\n        uint256 _floorBonus,\\r\\n        uint256 _deltaBonus,\\r\\n        bool _isActive\\r\\n    )\\r\\n        external\\r\\n        onlyCEO\\r\\n    {\\r\\n        levels[_level].costAmountDG = _costAmountDG;\\r\\n        levels[_level].moveAmountDG = _moveAmountDG;\\r\\n\\r\\n        levels[_level].costAmountICE = _costAmountICE;\\r\\n        levels[_level].moveAmountICE = _moveAmountICE;\\r\\n\\r\\n        levels[_level].floorBonus = _floorBonus;\\r\\n        levels[_level].deltaBonus = _deltaBonus;\\r\\n\\r\\n        levels[_level].isActive = _isActive;\\r\\n\\r\\n        emit LevelEdit(\\r\\n            _level,\\r\\n            _costAmountDG,\\r\\n            _moveAmountDG,\\r\\n            _costAmountICE,\\r\\n            _moveAmountICE,\\r\\n            _isActive\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function mintToken(\\r\\n        uint256 _itemId,\\r\\n        address _minterAddress,\\r\\n        address _tokenAddress\\r\\n    )\\r\\n        external\\r\\n        onlyWorker\\r\\n    {\\r\\n        require(\\r\\n            saleLimit \\u003e saleCount,\\r\\n            \\u0027iceRegistrant: sold-out\\u0027\\r\\n        );\\r\\n\\r\\n        unchecked {\\r\\n            saleCount =\\r\\n            saleCount + 1;\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            limits[_itemId] \\u003e 0,\\r\\n            \\u0027iceRegistrant: limited\\u0027\\r\\n        );\\r\\n\\r\\n        unchecked {\\r\\n            limits[_itemId] =\\r\\n            limits[_itemId] - 1;\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            canPurchaseAgain(_minterAddress) == true,\\r\\n            \\u0027iceRegistrant: cool-down detected\\u0027\\r\\n        );\\r\\n\\r\\n        frames[_minterAddress] = block.timestamp;\\r\\n\\r\\n        safeTransferFrom(\\r\\n            paymentToken,\\r\\n            _minterAddress,\\r\\n            ceoAddress,\\r\\n            mintingPrice\\r\\n        );\\r\\n\\r\\n        DGAccessories target = DGAccessories(\\r\\n            targets[_tokenAddress]\\r\\n        );\\r\\n\\r\\n        uint256 newTokenId = target.encodeTokenId(\\r\\n            _itemId,\\r\\n            getSupply(_itemId, targets[_tokenAddress]) + 1\\r\\n        );\\r\\n\\r\\n        bytes32 newHash = getHash(\\r\\n            targets[_tokenAddress],\\r\\n            newTokenId\\r\\n        );\\r\\n\\r\\n        owners[newHash] = _minterAddress;\\r\\n\\r\\n        registrer[_minterAddress][newHash].level = 1;\\r\\n        registrer[_minterAddress][newHash].bonus = getNumber(\\r\\n            levels[0].floorBonus,\\r\\n            levels[0].deltaBonus,\\r\\n            saleCount,\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        address[] memory beneficiaries = new address[](1);\\r\\n        beneficiaries[0] = _minterAddress;\\r\\n\\r\\n        uint256[] memory itemIds = new uint256[](1);\\r\\n        itemIds[0] = _itemId;\\r\\n\\r\\n        target.issueTokens(\\r\\n            beneficiaries,\\r\\n            itemIds\\r\\n        );\\r\\n\\r\\n        emit InitialMinting(\\r\\n            newTokenId,\\r\\n            saleCount,\\r\\n            _minterAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function upgradeToken(\\r\\n        address _tokenOwner,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenId,\\r\\n        uint256 _itemId\\r\\n    )\\r\\n        external\\r\\n        onlyWorker\\r\\n    {\\r\\n        require(\\r\\n            targets[_tokenAddress] != address(0x0),\\r\\n            \\u0027iceRegistrant: invalid token target\\u0027\\r\\n        );\\r\\n\\r\\n        ERC721 tokenNFT = ERC721(_tokenAddress);\\r\\n        address tokenOwner = _tokenOwner;\\r\\n\\r\\n        require(\\r\\n            tokenNFT.ownerOf(_tokenId) == tokenOwner,\\r\\n            \\u0027iceRegistrant: invalid owner\\u0027\\r\\n        );\\r\\n\\r\\n        bytes32 tokenHash = getHash(\\r\\n            _tokenAddress,\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        uint256 nextLevel = getLevel(\\r\\n            tokenOwner,\\r\\n            tokenHash\\r\\n        ) + 1;\\r\\n\\r\\n        require(\\r\\n            levels[nextLevel].isActive,\\r\\n            \\u0027iceRegistrant: inactive level\\u0027\\r\\n        );\\r\\n\\r\\n        uint256 requestIndex = upgradeRequestCount;\\r\\n\\r\\n        tokenNFT.transferFrom(\\r\\n            tokenOwner,\\r\\n            address(this),\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        DGAccessories target = DGAccessories(\\r\\n            targets[_tokenAddress]\\r\\n        );\\r\\n\\r\\n        (uint256 itemId, uint256 issuedId) = target.decodeTokenId(\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        requests[requestIndex].itemId = itemId;\\r\\n        requests[requestIndex].tokenId = _tokenId;\\r\\n        requests[requestIndex].tokenAddress = _tokenAddress;\\r\\n        requests[requestIndex].tokenOwner = tokenOwner;\\r\\n\\r\\n        unchecked {\\r\\n            upgradeRequestCount =\\r\\n            upgradeRequestCount + 1;\\r\\n        }\\r\\n\\r\\n        emit UpgradeItem(\\r\\n            itemId,\\r\\n            issuedId,\\r\\n            tokenOwner,\\r\\n            _tokenId,\\r\\n            _tokenAddress,\\r\\n            requestIndex\\r\\n        );\\r\\n\\r\\n        _resolveUpgradeMint(\\r\\n            requestIndex,\\r\\n            _itemId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _resolveUpgradeMint(\\r\\n        uint256 _requestIndex,\\r\\n        uint256 _itemId\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        uint256 tokenId = requests[_requestIndex].tokenId;\\r\\n        address tokenAddress = requests[_requestIndex].tokenAddress;\\r\\n        address tokenOwner = requests[_requestIndex].tokenOwner;\\r\\n\\r\\n        delete requests[_requestIndex];\\r\\n\\r\\n        bytes32 tokenHash = getHash(\\r\\n            tokenAddress,\\r\\n            tokenId\\r\\n        );\\r\\n\\r\\n        uint256 nextLevel = getLevel(\\r\\n            tokenOwner,\\r\\n            tokenHash\\r\\n        ) + 1;\\r\\n\\r\\n        delete owners[tokenHash];\\r\\n        delete registrer[tokenOwner][tokenHash];\\r\\n\\r\\n        _takePayment(\\r\\n            tokenOwner,\\r\\n            levels[nextLevel].costAmountDG,\\r\\n            levels[nextLevel].costAmountICE\\r\\n        );\\r\\n\\r\\n        ERC721(tokenAddress).transferFrom(\\r\\n            address(this),\\r\\n            depositAddressNFT,\\r\\n            tokenId\\r\\n        );\\r\\n\\r\\n        DGAccessories target = DGAccessories(\\r\\n            targets[tokenAddress]\\r\\n        );\\r\\n\\r\\n        uint256 newTokenId = target.encodeTokenId(\\r\\n            _itemId,\\r\\n            getSupply(_itemId, targets[tokenAddress]) + 1\\r\\n        );\\r\\n\\r\\n        bytes32 newHash = getHash(\\r\\n            targets[tokenAddress],\\r\\n            newTokenId\\r\\n        );\\r\\n\\r\\n        owners[newHash] = tokenOwner;\\r\\n\\r\\n        registrer[tokenOwner][newHash].level = nextLevel;\\r\\n        registrer[tokenOwner][newHash].bonus = getNumber(\\r\\n            levels[nextLevel].floorBonus,\\r\\n            levels[nextLevel].deltaBonus,\\r\\n            upgradeCount,\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        unchecked {\\r\\n            upgradeCount =\\r\\n            upgradeCount + 1;\\r\\n        }\\r\\n\\r\\n        address[] memory beneficiaries = new address[](1);\\r\\n        beneficiaries[0] = tokenOwner;\\r\\n\\r\\n        uint256[] memory itemIds = new uint256[](1);\\r\\n        itemIds[0] = _itemId;\\r\\n\\r\\n        target.issueTokens(\\r\\n            beneficiaries,\\r\\n            itemIds\\r\\n        );\\r\\n\\r\\n        emit UpgradeResolved(\\r\\n            _itemId,\\r\\n            tokenOwner,\\r\\n            newTokenId,\\r\\n            tokenAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function reIceNFT(\\r\\n        address _oldOwner,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            targets[_tokenAddress] != address(0x0),\\r\\n            \\u0027iceRegistrant: invalid token\\u0027\\r\\n        );\\r\\n\\r\\n        ERC721 token = ERC721(_tokenAddress);\\r\\n        address newOwner = msgSender();\\r\\n\\r\\n        require(\\r\\n            token.ownerOf(_tokenId) == newOwner,\\r\\n            \\u0027iceRegistrant: invalid owner\\u0027\\r\\n        );\\r\\n\\r\\n        bytes32 tokenHash = getHash(\\r\\n            _tokenAddress,\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        uint256 currentLevel = getLevelById(\\r\\n            _oldOwner,\\r\\n            _tokenAddress,\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        _takePayment(\\r\\n            newOwner,\\r\\n            levels[currentLevel].moveAmountDG,\\r\\n            levels[currentLevel].moveAmountICE\\r\\n        );\\r\\n\\r\\n        uint256 reIceLevel = registrer[_oldOwner][tokenHash].level;\\r\\n        uint256 reIceBonus = registrer[_oldOwner][tokenHash].bonus;\\r\\n\\r\\n        require(\\r\\n            reIceLevel \\u003e registrer[newOwner][tokenHash].level,\\r\\n            \\u0027iceRegistrant: preventing level downgrade\\u0027\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            reIceBonus \\u003e registrer[newOwner][tokenHash].bonus,\\r\\n            \\u0027iceRegistrant: preventing bonus downgrade\\u0027\\r\\n        );\\r\\n\\r\\n        delete registrer[_oldOwner][tokenHash];\\r\\n\\r\\n        registrer[newOwner][tokenHash].level = reIceLevel;\\r\\n        registrer[newOwner][tokenHash].bonus = reIceBonus;\\r\\n\\r\\n        owners[tokenHash] = newOwner;\\r\\n\\r\\n        emit IceLevelTransfer(\\r\\n            _oldOwner,\\r\\n            newOwner,\\r\\n            _tokenAddress,\\r\\n            _tokenId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function adjustRegistrantEntry(\\r\\n        address _tokenOwner,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenId,\\r\\n        uint256 _bonusValue,\\r\\n        uint256 _levelValue\\r\\n    )\\r\\n        external\\r\\n        onlyWorker\\r\\n    {\\r\\n        bytes32 tokenHash = getHash(\\r\\n            _tokenAddress,\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        owners[tokenHash] = _tokenOwner;\\r\\n\\r\\n        registrer[_tokenOwner][tokenHash].level = _levelValue;\\r\\n        registrer[_tokenOwner][tokenHash].bonus = _bonusValue;\\r\\n    }\\r\\n\\r\\n    function getSupply(\\r\\n        uint256 _itemId,\\r\\n        address _accessoriesContract\\r\\n    )\\r\\n        public\\r\\n        returns (uint256)\\r\\n    {\\r\\n        (   string memory rarity,\\r\\n            uint256 maxSupply,\\r\\n            uint256 totalSupply,\\r\\n            uint256 price,\\r\\n            address beneficiary,\\r\\n            string memory metadata,\\r\\n            string memory contentHash\\r\\n\\r\\n        ) = DGAccessories(_accessoriesContract).items(_itemId);\\r\\n\\r\\n        emit SupplyCheck(\\r\\n            rarity,\\r\\n            maxSupply,\\r\\n            price,\\r\\n            beneficiary,\\r\\n            metadata,\\r\\n            contentHash\\r\\n        );\\r\\n\\r\\n        return totalSupply;\\r\\n    }\\r\\n\\r\\n    function _takePayment(\\r\\n        address _payer,\\r\\n        uint256 _dgAmount,\\r\\n        uint256 _iceAmount\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        if (_dgAmount \\u003e 0) {\\r\\n            safeTransferFrom(\\r\\n                tokenAddressDG,\\r\\n                _payer,\\r\\n                depositAddressDG,\\r\\n                _dgAmount\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (_iceAmount \\u003e 0) {\\r\\n            safeTransferFrom(\\r\\n                tokenAddressICE,\\r\\n                _payer,\\r\\n                address(this),\\r\\n                _iceAmount\\r\\n            );\\r\\n\\r\\n            ERC20 iceToken = ERC20(tokenAddressICE);\\r\\n            iceToken.burn(_iceAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getLevel(\\r\\n        address _tokenOwner,\\r\\n        bytes32 _tokenHash\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return registrer[_tokenOwner][_tokenHash].level;\\r\\n    }\\r\\n\\r\\n    function getLevelById(\\r\\n        address _tokenOwner,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        bytes32 tokenHash = getHash(\\r\\n            _tokenAddress,\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        return registrer[_tokenOwner][tokenHash].level;\\r\\n    }\\r\\n\\r\\n    function getIceBonus(\\r\\n        address _tokenOwner,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        bytes32 tokenHash = getHash(\\r\\n            _tokenAddress,\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        return registrer[_tokenOwner][tokenHash].bonus;\\r\\n    }\\r\\n\\r\\n    function isIceEnabled(\\r\\n        address _tokenOwner,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 iceBonus = getIceBonus(\\r\\n            _tokenOwner,\\r\\n            _tokenAddress,\\r\\n            _tokenId\\r\\n        );\\r\\n\\r\\n        return iceBonus \\u003e 0;\\r\\n    }\\r\\n\\r\\n    function canPurchaseAgain(\\r\\n        address _minterAddress\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return block.timestamp - frames[_minterAddress] \\u003e saleFrame;\\r\\n    }\\r\\n\\r\\n    function getHash(\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        public\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return keccak256(abi.encodePacked(\\r\\n            _tokenAddress,\\r\\n            _tokenId\\r\\n        ));\\r\\n    }\\r\\n\\r\\n    function getNumber(\\r\\n        uint256 _floorValue,\\r\\n        uint256 _deltaValue,\\r\\n        uint256 _nonceValue,\\r\\n        uint256 _randomValue\\r\\n    )\\r\\n        public\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _floorValue + uint256(keccak256(abi.encodePacked(_nonceValue, _randomValue))) % (_deltaValue + 1);\\r\\n    }\\r\\n}\\r\\n\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83d\udc8e --\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface ERC721 {\\r\\n\\r\\n    function ownerOf(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external;\\r\\n}\\r\\n\\r\\ninterface ERC20 {\\r\\n\\r\\n    function burn(\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external;\\r\\n}\\r\\n\\r\\ninterface DGAccessories  {\\r\\n\\r\\n    function issueTokens(\\r\\n        address[] calldata _beneficiaries,\\r\\n        uint256[] calldata _itemIds\\r\\n    )\\r\\n        external;\\r\\n\\r\\n    function encodeTokenId(\\r\\n        uint256 _itemId,\\r\\n        uint256 _issuedId\\r\\n    )\\r\\n        external\\r\\n        pure\\r\\n        returns (uint256 id);\\r\\n\\r\\n    function decodeTokenId(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 itemId,\\r\\n            uint256 issuedId\\r\\n        );\\r\\n\\r\\n    function items(\\r\\n        uint256 _id\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            string memory rarity,\\r\\n            uint256 maxSupply,\\r\\n            uint256 totalSupply,\\r\\n            uint256 price,\\r\\n            address beneficiary,\\r\\n            string memory metadata,\\r\\n            string memory contentHash\\r\\n        );\\r\\n\\r\\n    function itemsCount()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n}\\r\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: -- \ud83c\udfb2 --\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ncontract TransferHelper {\\r\\n\\r\\n    bytes4 private constant TRANSFER = bytes4(\\r\\n        keccak256(\\r\\n            bytes(\\r\\n                \\u0027transfer(address,uint256)\\u0027 // 0xa9059cbb\\r\\n            )\\r\\n        )\\r\\n    );\\r\\n\\r\\n    bytes4 private constant TRANSFER_FROM = bytes4(\\r\\n        keccak256(\\r\\n            bytes(\\r\\n                \\u0027transferFrom(address,address,uint256)\\u0027 // 0x23b872dd\\r\\n            )\\r\\n        )\\r\\n    );\\r\\n\\r\\n    function safeTransfer(\\r\\n        address _token,\\r\\n        address _to,\\r\\n        uint256 _value\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        (bool success, bytes memory data) = _token.call(\\r\\n            abi.encodeWithSelector(\\r\\n                TRANSFER, // 0xa9059cbb\\r\\n                _to,\\r\\n                _value\\r\\n            )\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            success \\u0026\\u0026 (\\r\\n                data.length == 0 || abi.decode(\\r\\n                    data, (bool)\\r\\n                )\\r\\n            ),\\r\\n            \\u0027TransferHelper: TRANSFER_FAILED\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address _token,\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint _value\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        (bool success, bytes memory data) = _token.call(\\r\\n            abi.encodeWithSelector(\\r\\n                TRANSFER_FROM,\\r\\n                _from,\\r\\n                _to,\\r\\n                _value\\r\\n            )\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            success \\u0026\\u0026 (\\r\\n                data.length == 0 || abi.decode(\\r\\n                    data, (bool)\\r\\n                )\\r\\n            ),\\r\\n            \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddressDG\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddressICE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_accessoriesContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCEO\",\"type\":\"address\"}],\"name\":\"CEOSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"IceLevelTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"mintCount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"InitialMinting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dgCostAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dgMoveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iceCostAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iceMoveAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"LevelEdit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"rarity\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"contentHash\",\"type\":\"string\"}],\"name\":\"SupplyCheck\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issuedId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"UpgradeItem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newItemId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"UpgradeResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newWorker\",\"type\":\"address\"}],\"name\":\"WorkerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"existingWorker\",\"type\":\"address\"}],\"name\":\"WorkerRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWorker\",\"type\":\"address\"}],\"name\":\"addWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newWorkers\",\"type\":\"address[]\"}],\"name\":\"addWorkerBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_levelValue\",\"type\":\"uint256\"}],\"name\":\"adjustRegistrantEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowChangeSaleLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minterAddress\",\"type\":\"address\"}],\"name\":\"canPurchaseAgain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDepositAddressDG\",\"type\":\"address\"}],\"name\":\"changeDepositAddressDG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDepositAddressNFT\",\"type\":\"address\"}],\"name\":\"changeDepositAddressNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"changeMintLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMintingPrice\",\"type\":\"uint256\"}],\"name\":\"changeMintingPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPaymentToken\",\"type\":\"address\"}],\"name\":\"changePaymentToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSaleFrame\",\"type\":\"uint256\"}],\"name\":\"changeSaleFrame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSaleLimit\",\"type\":\"uint256\"}],\"name\":\"changeSaleLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_accessoriesContract\",\"type\":\"address\"}],\"name\":\"changeTargetContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenAddressDG\",\"type\":\"address\"}],\"name\":\"changeTokenAddressDG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenAddressICE\",\"type\":\"address\"}],\"name\":\"changeTokenAddressICE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAddressDG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAddressNFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disabledSaleLimitChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frames\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getIceBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_tokenHash\",\"type\":\"bytes32\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLevelById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_floorValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deltaValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonceValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_randomValue\",\"type\":\"uint256\"}],\"name\":\"getNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_accessoriesContract\",\"type\":\"address\"}],\"name\":\"getSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isIceEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWorker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"costAmountDG\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"moveAmountDG\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"costAmountICE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"moveAmountICE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"floorBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deltaBonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"limits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_costAmountDG\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_moveAmountDG\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_costAmountICE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_moveAmountICE\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_floorBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deltaBonus\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"manageLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_minterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"mintToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"reIceNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"registrer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_existingWorker\",\"type\":\"address\"}],\"name\":\"removeWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_workerArray\",\"type\":\"address[]\"}],\"name\":\"removeWorkerBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleFrame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"targets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddressDG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddressICE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeRequestCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"}],\"name\":\"upgradeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IceRegistrant", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002a93172c8dccbfbc60a39d56183b7279a2f647b4000000000000000000000000c6c855ad634dcdad23e64da71ba85b8c51e5ad7c000000000000000000000000cb06f6aee0655252a3f6f2884680421d55d3c645", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://429d5fc54bbb848bd01a49a2f82b7daa85127b5d95f6afd81a49a364fbb17de1"}