{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/swap/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function decimals() external view returns (uint8);\\n    function symbol() external view returns (string memory);\\n    function balanceOf(address) external view returns (uint);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\"\r\n    },\r\n    \"contracts/swap/interfaces/IPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IPair {\\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1);\\n    function claimFees() external returns (uint, uint);\\n    function tokens() external view returns (address, address);\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function mint(address to) external returns (uint liquidity);\\n    function getReserves() external view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast);\\n    function getAmountOut(uint, address) external view returns (uint);\\n\\n    function name() external view returns(string memory);\\n    function symbol() external view returns(string memory);\\n    function totalSupply() external view returns (uint);\\n    function decimals() external view returns (uint8);\\n\\n    function claimable0(address _user) external view returns (uint);\\n    function claimable1(address _user) external view returns (uint);\\n\\n    function isStable() external view returns(bool);\\n}\\n\"\r\n    },\r\n    \"contracts/swap/interfaces/IPairFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IPairFactory {\\n    function allPairsLength() external view returns (uint);\\n    function isPair(address pair) external view returns (bool);\\n    function allPairs(uint index) external view returns (address);\\n    function pairCodeHash() external pure returns (bytes32);\\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/swap/interfaces/IRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IRouter {\\n    function pairFor(address tokenA, address tokenB, bool stable) external view returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/swap/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/swap/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nlibrary Math {\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n    function min(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n    function cbrt(uint256 n) internal pure returns (uint256) { unchecked {\\n        uint256 x = 0;\\n        for (uint256 y = 1 << 255; y > 0; y >>= 3) {\\n            x <<= 1;\\n            uint256 z = 3 * x * (x + 1) + 1;\\n            if (n / y >= z) {\\n                n -= y * z;\\n                x += 1;\\n            }\\n        }\\n        return x;\\n    }}\\n}\\n\"\r\n    },\r\n    \"contracts/swap/Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport './libraries/Math.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/IPair.sol';\\nimport './interfaces/IPairFactory.sol';\\nimport './interfaces/IRouter.sol';\\nimport './interfaces/IWETH.sol';\\n\\ncontract Router is IRouter {\\n\\n    struct route {\\n        address from;\\n        address to;\\n        bool stable;\\n    }\\n\\n    address public immutable factory;\\n    IWETH public immutable weth;\\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\\n    bytes32 immutable pairCodeHash;\\n\\n    // create swap event with sender and amountIn for the referral event reader system\\n    event Swap(address indexed sender,uint amount0In,address _tokenIn, address indexed to);  \\n\\n    modifier ensure(uint deadline) {\\n        require(deadline >= block.timestamp, 'Router: EXPIRED');\\n        _;\\n    }\\n    constructor(address _factory, address _weth) {\\n        factory = _factory;\\n        pairCodeHash = IPairFactory(_factory).pairCodeHash();\\n        weth = IWETH(_weth);\\n    }\\n\\n\\n    receive() external payable {\\n        assert(msg.sender == address(weth)); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'Router: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'Router: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address tokenA, address tokenB, bool stable) public view returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint160(uint256(keccak256(abi.encodePacked(\\n            hex'ff',\\n            factory,\\n            keccak256(abi.encodePacked(token0, token1, stable)),\\n            pairCodeHash // init code hash\\n        )))));\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quoteLiquidity(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'Router: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'Router: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA * reserveB / reserveA;\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address tokenA, address tokenB, bool stable) public view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IPair(pairFor(tokenA, tokenB, stable)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable) {\\n        address pair = pairFor(tokenIn, tokenOut, true);\\n        uint amountStable;\\n        uint amountVolatile;\\n        if (IPairFactory(factory).isPair(pair)) {\\n            amountStable = IPair(pair).getAmountOut(amountIn, tokenIn);\\n        }\\n        pair = pairFor(tokenIn, tokenOut, false);\\n        if (IPairFactory(factory).isPair(pair)) {\\n            amountVolatile = IPair(pair).getAmountOut(amountIn, tokenIn);\\n        }\\n        return amountStable > amountVolatile ? (amountStable, true) : (amountVolatile, false);\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(uint amountIn, route[] memory routes) public view returns (uint[] memory amounts) {\\n        require(routes.length >= 1, 'Router: INVALID_PATH');\\n        amounts = new uint[](routes.length+1);\\n        amounts[0] = amountIn;\\n        for (uint i = 0; i < routes.length; i++) {\\n            address pair = pairFor(routes[i].from, routes[i].to, routes[i].stable);\\n            if (IPairFactory(factory).isPair(pair)) {\\n                amounts[i+1] = IPair(pair).getAmountOut(amounts[i], routes[i].from);\\n            }\\n        }\\n    }\\n\\n    function isPair(address pair) external view returns (bool) {\\n        return IPairFactory(factory).isPair(pair);\\n    }\\n\\n    function quoteAddLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        bool stable,\\n        uint amountADesired,\\n        uint amountBDesired\\n    ) external view returns (uint amountA, uint amountB, uint liquidity) {\\n        // create the pair if it doesn't exist yet\\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\\n        (uint reserveA, uint reserveB) = (0,0);\\n        uint _totalSupply = 0;\\n        if (_pair != address(0)) {\\n            _totalSupply = IERC20(_pair).totalSupply();\\n            (reserveA, reserveB) = getReserves(tokenA, tokenB, stable);\\n        }\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n            liquidity = Math.sqrt(amountA * amountB) - MINIMUM_LIQUIDITY;\\n        } else {\\n\\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal <= amountBDesired) {\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\\n            } else {\\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n                liquidity = Math.min(amountA * _totalSupply / reserveA, amountB * _totalSupply / reserveB);\\n            }\\n        }\\n    }\\n\\n    function quoteRemoveLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        bool stable,\\n        uint liquidity\\n    ) external view returns (uint amountA, uint amountB) {\\n        // create the pair if it doesn't exist yet\\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\\n\\n        if (_pair == address(0)) {\\n            return (0,0);\\n        }\\n\\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\\n        uint _totalSupply = IERC20(_pair).totalSupply();\\n\\n        amountA = liquidity * reserveA / _totalSupply; // using balances ensures pro-rata distribution\\n        amountB = liquidity * reserveB / _totalSupply; // using balances ensures pro-rata distribution\\n\\n    }\\n\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        bool stable,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin\\n    ) internal returns (uint amountA, uint amountB) {\\n        require(amountADesired >= amountAMin);\\n        require(amountBDesired >= amountBMin);\\n        // create the pair if it doesn't exist yet\\n        address _pair = IPairFactory(factory).getPair(tokenA, tokenB, stable);\\n        if (_pair == address(0)) {\\n            _pair = IPairFactory(factory).createPair(tokenA, tokenB, stable);\\n        }\\n        (uint reserveA, uint reserveB) = getReserves(tokenA, tokenB, stable);\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint amountBOptimal = quoteLiquidity(amountADesired, reserveA, reserveB);\\n            if (amountBOptimal <= amountBDesired) {\\n                require(amountBOptimal >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint amountAOptimal = quoteLiquidity(amountBDesired, reserveB, reserveA);\\n                assert(amountAOptimal <= amountADesired);\\n                require(amountAOptimal >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        bool stable,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, stable, amountADesired, amountBDesired, amountAMin, amountBMin);\\n        address pair = pairFor(tokenA, tokenB, stable);\\n        _safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n        _safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n        liquidity = IPair(pair).mint(to);\\n    }\\n\\n    function addLiquidityETH(\\n        address token,\\n        bool stable,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\\n        (amountToken, amountETH) = _addLiquidity(\\n            token,\\n            address(weth),\\n            stable,\\n            amountTokenDesired,\\n            msg.value,\\n            amountTokenMin,\\n            amountETHMin\\n        );\\n        address pair = pairFor(token, address(weth), stable);\\n        _safeTransferFrom(token, msg.sender, pair, amountToken);\\n        weth.deposit{value: amountETH}();\\n        assert(weth.transfer(pair, amountETH));\\n        liquidity = IPair(pair).mint(to);\\n        // refund dust eth, if any\\n        if (msg.value > amountETH) _safeTransferETH(msg.sender, msg.value - amountETH);\\n    }\\n\\n    // **** REMOVE LIQUIDITY ****\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        bool stable,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) public ensure(deadline) returns (uint amountA, uint amountB) {\\n        address pair = pairFor(tokenA, tokenB, stable);\\n        require(IPair(pair).transferFrom(msg.sender, pair, liquidity)); // send liquidity to pair\\n        (uint amount0, uint amount1) = IPair(pair).burn(to);\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n        require(amountA >= amountAMin, 'Router: INSUFFICIENT_A_AMOUNT');\\n        require(amountB >= amountBMin, 'Router: INSUFFICIENT_B_AMOUNT');\\n    }\\n\\n    function removeLiquidityETH(\\n        address token,\\n        bool stable,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) public ensure(deadline) returns (uint amountToken, uint amountETH) {\\n        (amountToken, amountETH) = removeLiquidity(\\n            token,\\n            address(weth),\\n            stable,\\n            liquidity,\\n            amountTokenMin,\\n            amountETHMin,\\n            address(this),\\n            deadline\\n        );\\n        _safeTransfer(token, to, amountToken);\\n        weth.withdraw(amountETH);\\n        _safeTransferETH(to, amountETH);\\n    }\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        bool stable,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB) {\\n        address pair = pairFor(tokenA, tokenB, stable);\\n        {\\n            uint value = approveMax ? type(uint).max : liquidity;\\n            IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        }\\n\\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, stable, liquidity, amountAMin, amountBMin, to, deadline);\\n    }\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        bool stable,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH) {\\n        address pair = pairFor(token, address(weth), stable);\\n        uint value = approveMax ? type(uint).max : liquidity;\\n        IPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n        (amountToken, amountETH) = removeLiquidityETH(token, stable, liquidity, amountTokenMin, amountETHMin, to, deadline);\\n    }\\n\\n    // **** SWAP ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(uint[] memory amounts, route[] memory routes, address _to) internal virtual {\\n        for (uint i = 0; i < routes.length; i++) {\\n            (address token0,) = sortTokens(routes[i].from, routes[i].to);\\n            uint amountOut = amounts[i + 1];\\n            (uint amount0Out, uint amount1Out) = routes[i].from == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\n            address to = i < routes.length - 1 ? pairFor(routes[i+1].from, routes[i+1].to, routes[i+1].stable) : _to;\\n            IPair(pairFor(routes[i].from, routes[i].to, routes[i].stable)).swap(\\n                amount0Out, amount1Out, to, new bytes(0)\\n            );\\n        }\\n        emit Swap(msg.sender, amounts[0], routes[0].from, _to);\\n    }\\n\\n    function swapExactTokensForTokensSimple(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address tokenFrom,\\n        address tokenTo,\\n        bool stable,\\n        address to,\\n        uint deadline\\n    ) external ensure(deadline) returns (uint[] memory amounts) {\\n        route[] memory routes = new route[](1);\\n        routes[0].from = tokenFrom;\\n        routes[0].to = tokenTo;\\n        routes[0].stable = stable;\\n        amounts = getAmountsOut(amountIn, routes);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n        _safeTransferFrom(\\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\\n        );\\n        _swap(amounts, routes, to);\\n    }\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        route[] calldata routes,\\n        address to,\\n        uint deadline\\n    ) external ensure(deadline) returns (uint[] memory amounts) {\\n        amounts = getAmountsOut(amountIn, routes);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n        _safeTransferFrom(\\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\\n        );\\n        _swap(amounts, routes, to);\\n    }\\n\\n    function swapExactETHForTokens(uint amountOutMin, route[] calldata routes, address to, uint deadline) external payable ensure(deadline) returns (uint[] memory amounts)\\n    {\\n        require(routes[0].from == address(weth), 'Router: INVALID_PATH');\\n        amounts = getAmountsOut(msg.value, routes);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n        weth.deposit{value: amounts[0]}();\\n        assert(weth.transfer(pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]));\\n        _swap(amounts, routes, to);\\n    }\\n\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, route[] calldata routes, address to, uint deadline)\\n    external\\n    ensure(deadline)\\n    returns (uint[] memory amounts)\\n    {\\n        require(routes[routes.length - 1].to == address(weth), 'Router: INVALID_PATH');\\n        amounts = getAmountsOut(amountIn, routes);\\n        require(amounts[amounts.length - 1] >= amountOutMin, 'Router: INSUFFICIENT_OUTPUT_AMOUNT');\\n        _safeTransferFrom(\\n            routes[0].from, msg.sender, pairFor(routes[0].from, routes[0].to, routes[0].stable), amounts[0]\\n        );\\n        _swap(amounts, routes, address(this));\\n        weth.withdraw(amounts[amounts.length - 1]);\\n        _safeTransferETH(to, amounts[amounts.length - 1]);\\n    }\\n\\n    function _safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n\\n    function _safeTransfer(address token, address to, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"internalType\":\"struct Router.route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"name\":\"pairFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"}],\"name\":\"quoteAddLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"quoteRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"sortTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"internalType\":\"struct Router.route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"internalType\":\"struct Router.route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"}],\"internalType\":\"struct Router.route[]\",\"name\":\"routes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stable\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSimple\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Router", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000078ae0bacb5771e265fe530a4ef9dddbd3467f6eb0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}