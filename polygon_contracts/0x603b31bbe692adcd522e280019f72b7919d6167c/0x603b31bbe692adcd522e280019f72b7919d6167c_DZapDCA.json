{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Error.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nerror InvalidInterval();\\nerror InvalidMask();\\n\\nerror UnauthorizedCaller();\\nerror ZeroAddress();\\n\\nerror HighPlatformFeeRatio();\\nerror HighFee();\\nerror InvalidToken();\\nerror InvalidNoOfSwaps();\\n\\nerror InvalidPermitSender();\\nerror InvalidPermitData();\\nerror InvalidPermit();\\nerror InvalidAmountTransferred();\\n\\nerror InvalidLength();\\nerror NoAvailableSwap();\\nerror InvalidSwapAmount();\\nerror InvalidReturnAmount();\\nerror SwapCallFailed();\\nerror InvalidBlankSwap();\\n\\nerror InvalidPosition();\\nerror InvalidNativeAmount();\\nerror NotWNative();\\nerror NativeTransferFailed();\\nerror UnauthorizedTokens();\\nerror InvalidTokens();\\nerror InvalidAmount();\\nerror UnauthorizedInterval();\\nerror InvalidRate();\\nerror NoChanges();\\nerror ZeroSwappedTokens();\\n\"\r\n    },\r\n    \"contracts/common/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\n/**\\n * @notice User position info\\n * swapWhereLastUpdated: swaps at which position was last updated (create, modify, withdraw)\\n * startingSwap: swap at position will start (1st swap = 0)\\n * finalSwap: swap at the all the swaps for position will be finished\\n * swapIntervalMask: How frequently the position's swaps should be executed\\n * rate: How many \\\"from\\\" tokens need to be traded in each swap\\n * from: The token that the user deposited and will be swapped in exchange for \\\"to\\\"\\n * to: The token that the user will get in exchange for their \\\"from\\\" tokens in each swap\\n * owner: address of position owner\\n */\\nstruct UserPosition {\\n    address owner;\\n    address from;\\n    address to;\\n    bytes1 swapIntervalMask;\\n    uint256 rate;\\n    uint256 swapWhereLastUpdated;\\n    uint256 startingSwap;\\n    uint256 finalSwap;\\n}\\n\\n/**\\n * @notice User position info\\n * @dev to get more readable information\\n * owner: address of position owner\\n * from: The token that the user deposited and will be swapped in exchange for \\\"to\\\"\\n * to: The token that the user will get in exchange for their \\\"from\\\" tokens in each swap\\n * swapInterval: How frequently the position's swaps should be executed\\n * rate: How many \\\"from\\\" tokens need to be traded in each swap\\n * swapsExecuted: How many swaps were executed since creation, last modification, or last withdraw\\n * swapsLeft: How many swaps left the position has to execute\\n * swapped: How many to swaps are available to withdraw\\n * unswapped:How many \\\"from\\\" tokens there are left to swap\\n */\\nstruct PositionInfo {\\n    address owner;\\n    address from;\\n    address to;\\n    uint32 swapInterval;\\n    uint256 rate;\\n    uint256 swapsExecuted;\\n    uint256 swapsLeft;\\n    uint256 swapped;\\n    uint256 unswapped;\\n}\\n\\n/**\\n * @notice Create Position Details\\n * @dev Will be use in createPosition and createBatchPositions as input arg\\n * @dev For Native token user NATIVE_TOKEN as address\\n * from: The address of the \\\"from\\\" token\\n * to: The address of the \\\"to\\\" token\\n * swapInterval: How frequently the position's swaps should be executed\\n * amount: How many \\\"from\\\" tokens will be swapped in total\\n * noOfSwaps: How many swaps to execute for this position\\n * permit: Permit callData, erc20Permit, daiPermit and permit2 are supported\\n */\\nstruct CreatePositionDetails {\\n    address from;\\n    address to;\\n    uint32 swapInterval;\\n    uint256 amount;\\n    uint256 noOfSwaps;\\n    bytes permit;\\n}\\n\\n/**\\n * @notice Swap information about a specific pair\\n * performedSwaps: How many swaps have been executed\\n * nextAmountToSwap: How much of \\\"from\\\" token will be swapped on the next swap\\n * nextToNextAmountToSwap: How much of \\\"from\\\" token will be swapped on the nextToNext swap\\n * lastSwappedAt: Timestamp of the last swap\\n */\\nstruct SwapData {\\n    uint256 performedSwaps;\\n    uint256 nextAmountToSwap;\\n    uint256 nextToNextAmountToSwap;\\n    uint256 lastSwappedAt;\\n}\\n\\n/**\\n * @notice Information about a swap\\n * @dev totalAmount of \\\"from\\\" tokens used is equal swappedAmount + reward + fee\\n * from: The address of the \\\"from\\\" token\\n * to: The address of the \\\"to\\\" token\\n * swappedAmount: The actual amount of \\\"from\\\" tokens that were swapped\\n * receivedAmount:The actual amount of \\\"tp\\\" tokens that were received\\n * reward: The amount of \\\"from\\\" token that were given as rewards\\n * fee: The amount of \\\"from\\\" token that were given as fee\\n * intervalsInSwap: The different interval for which swap has taken place\\n */\\nstruct SwapInfo {\\n    address from;\\n    address to;\\n    uint256 swappedAmount;\\n    uint256 receivedAmount;\\n    uint256 reward;\\n    uint256 fee;\\n    bytes1 intervalsInSwap;\\n}\\n\\n/**\\n * @notice Swap Details\\n * @dev Will be use in swap as input arg\\n * executor: DEX's or aggregator address\\n * tokenProxy: Who should we approve the tokens to (as an example: Paraswap makes you approve one address and send data to other)\\n * from: The address of the \\\"from\\\" token\\n * to: The address of the \\\"to\\\" token\\n * amount: The amount of \\\"from\\\" token which will be swapped (totalSwappedAmount - feeAmount)\\n * minReturnAmount: Minimum amount of \\\"to\\\" token which will be received from swap\\n * swapCallData: call to make to the dex\\n */\\nstruct SwapDetails {\\n    address executor;\\n    address tokenProxy;\\n    address from;\\n    address to;\\n    uint256 amount;\\n    uint256 minReturnAmount;\\n    bytes swapCallData;\\n}\\n\\n/**\\n * @notice A pair of tokens\\n * from: The address of the \\\"from\\\" token\\n * to: The address of the \\\"to\\\" token\\n */\\nstruct Pair {\\n    address from;\\n    address to;\\n}\\n\\nenum PermitType {\\n    PERMIT2_APPROVE,\\n    PERMIT2_TRANSFER_FROM,\\n    PERMIT\\n}\\n\"\r\n    },\r\n    \"contracts/core/DCAConfigHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\\\";\\n\\nimport \\\"./DCAParameters.sol\\\";\\nimport \\\"./../utils/Governable.sol\\\";\\nimport \\\"./../libraries/Intervals.sol\\\";\\nimport \\\"../interfaces/IDCAConfigHandler.sol\\\";\\nimport \\\"./../interfaces/IWNative.sol\\\";\\n\\nimport { ZeroAddress, InvalidInterval, HighFee, HighPlatformFeeRatio, InvalidToken, InvalidNoOfSwaps, InvalidLength } from \\\"./../common/Error.sol\\\";\\n\\nabstract contract DCAConfigHandler is DCAParameters, Governable, Pausable, IDCAConfigHandler {\\n    bytes1 public allowedSwapIntervals;\\n\\n    mapping(address => bool) public allowedTokens;\\n    mapping(address => uint256) public tokenMagnitude;\\n    mapping(address => bool) public admins;\\n    mapping(address => bool) public swapExecutors;\\n    mapping(bytes1 => uint256) internal _swapFeeMap;\\n\\n    IWNative public immutable wNative;\\n    address public feeVault;\\n\\n    address public constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    uint256 public maxNoOfSwap;\\n    uint256 public nextToNextTimeThreshold = 10 minutes;\\n    uint256 public platformFeeRatio;\\n    uint256 public constant MAX_FEE = 1000; // 10%\\n    uint256 public constant MAX_PLATFORM_FEE_RATIO = 10000; // 100%\\n    uint256 public constant BPS_DENOMINATOR = 10000; // 2 point precision\\n\\n    /* ========= CONSTRUCTOR ========= */\\n\\n    constructor(address governor_, address wNative_, address feeVault_, uint256 maxNoOfSwap_) Governable(governor_) {\\n        if (feeVault_ == address(0) || wNative_ == address(0)) revert ZeroAddress();\\n        if (maxNoOfSwap_ < 2) revert InvalidNoOfSwaps(); \\n\\n        wNative = IWNative(wNative_);\\n        feeVault = feeVault_;\\n        maxNoOfSwap = maxNoOfSwap_;\\n    }\\n\\n    /* ========== MODIFIERS ==========  */\\n\\n    modifier onlyAdminOrGovernor() {\\n        if (!admins[_msgSender()] && _msgSender() != governance()) revert UnauthorizedCaller();\\n        _;\\n    }\\n\\n    modifier onlySwapper() {\\n        if (!swapExecutors[_msgSender()]) revert UnauthorizedCaller();\\n        _;\\n    }\\n\\n    /* ========= VIEWS ========= */\\n\\n    function getSwapFee(uint32 interval_) external view returns (uint256) {\\n        return _swapFeeMap[Intervals.intervalToMask(interval_)];\\n    }\\n\\n    /* ========= RESTRICTED FUNCTIONS ========= */\\n\\n    function pause() external onlyGovernance {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyGovernance {\\n        _unpause();\\n    }\\n\\n    function addAdmins(address[] calldata accounts_) external onlyGovernance {\\n        _setAdmin(accounts_, true);\\n        emit AdminAdded(accounts_);\\n    }\\n\\n    function removeAdmins(address[] calldata accounts_) external onlyGovernance {\\n        _setAdmin(accounts_, false);\\n        emit AdminRemoved(accounts_);\\n    }\\n\\n    function addSwapExecutors(address[] calldata executor_) external onlyGovernance {\\n        _setSwapExecutor(executor_, true);\\n        emit SwapExecutorAdded(executor_);\\n    }\\n\\n    function removeSwapExecutors(address[] calldata executor_) external onlyGovernance {\\n        _setSwapExecutor(executor_, false);\\n        emit SwapExecutorRemoved(executor_);\\n    }\\n\\n    function addAllowedTokens(address[] calldata tokens_) external onlyAdminOrGovernor {\\n        _setAllowedTokens(tokens_, true);\\n        emit TokensAdded(tokens_);\\n    }\\n\\n    function removeAllowedTokens(address[] calldata tokens_) external onlyAdminOrGovernor {\\n        _setAllowedTokens(tokens_, false);\\n        emit TokensRemoved(tokens_);\\n    }\\n\\n    function addSwapIntervalsToAllowedList(uint32[] calldata swapIntervals_) external onlyAdminOrGovernor {\\n        for (uint256 i; i < swapIntervals_.length; ++i) {\\n            allowedSwapIntervals |= Intervals.intervalToMask(swapIntervals_[i]);\\n        }\\n        emit SwapIntervalsAdded(swapIntervals_);\\n    }\\n\\n    function removeSwapIntervalsFromAllowedList(uint32[] calldata swapIntervals_) external onlyAdminOrGovernor {\\n        for (uint256 i; i < swapIntervals_.length; ++i) {\\n            allowedSwapIntervals &= ~Intervals.intervalToMask(swapIntervals_[i]);\\n        }\\n        emit SwapIntervalsRemoved(swapIntervals_);\\n    }\\n\\n    function updateMaxSwapLimit(uint256 maxNoOfSwap_) external onlyAdminOrGovernor {\\n        if (maxNoOfSwap_ < 2) revert InvalidNoOfSwaps();\\n        maxNoOfSwap = maxNoOfSwap_;\\n        emit SwapLimitUpdated(maxNoOfSwap_);\\n    }\\n\\n    function updateSwapTimeThreshold(uint256 nextToNextTimeThreshold_) external onlyAdminOrGovernor {\\n        nextToNextTimeThreshold = nextToNextTimeThreshold_;\\n        emit SwapThresholdUpdated(nextToNextTimeThreshold_);\\n    }\\n\\n    function setFeeVault(address newVault_) external onlyGovernance {\\n        if (newVault_ == address(0)) revert ZeroAddress();\\n        feeVault = newVault_;\\n        emit FeeVaultUpdated(newVault_);\\n    }\\n\\n    function setSwapFee(uint32[] calldata intervals_, uint256[] calldata swapFee_) external onlyGovernance {\\n        if (intervals_.length != swapFee_.length) revert InvalidLength();\\n        for (uint256 i; i < intervals_.length; i++) {\\n            if (swapFee_[i] > MAX_FEE) revert HighFee();\\n\\n            _swapFeeMap[Intervals.intervalToMask(intervals_[i])] = swapFee_[i];\\n        }\\n\\n        emit SwapFeeUpdated(intervals_, swapFee_);\\n    }\\n\\n    function setPlatformFeeRatio(uint256 platformFeeRatio_) external onlyGovernance {\\n        if (platformFeeRatio_ > MAX_PLATFORM_FEE_RATIO) revert HighPlatformFeeRatio();\\n        platformFeeRatio = platformFeeRatio_;\\n        emit PlatformFeeRatioUpdated(platformFeeRatio_);\\n    }\\n\\n    /* ========= INTERNAL/PRIVATE FUNCTIONS ========= */\\n\\n    function _setAllowedTokens(address[] calldata tokens_, bool allowed_) private {\\n        for (uint256 i; i < tokens_.length; ++i) {\\n            address token = tokens_[i];\\n            if (token == address(0) || token == NATIVE_TOKEN) revert InvalidToken();\\n            allowedTokens[token] = allowed_;\\n            if (tokenMagnitude[token] == 0) {\\n                tokenMagnitude[token] = 10**IERC20Metadata(token).decimals();\\n            }\\n        }\\n    }\\n\\n    function _setAdmin(address[] calldata accounts_, bool state_) private {\\n        for (uint256 i; i < accounts_.length; i++) {\\n            if (accounts_[i] == address(0)) revert ZeroAddress();\\n            admins[accounts_[i]] = state_;\\n        }\\n    }\\n\\n    function _setSwapExecutor(address[] calldata accounts_, bool state_) private {\\n        for (uint256 i; i < accounts_.length; i++) {\\n            if (accounts_[i] == address(0)) revert ZeroAddress();\\n            swapExecutors[accounts_[i]] = state_;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/DCAParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"./../interfaces/IDCAParameters.sol\\\";\\n\\nimport { SwapData } from \\\"./../common/Types.sol\\\";\\n\\nabstract contract DCAParameters is IDCAParameters {\\n    /* ========= VIEWS ========= */\\n\\n    mapping(address => mapping(address => bytes1)) public activeSwapIntervals;\\n\\n    mapping(address => mapping(address => mapping(bytes1 => SwapData))) public swapData;\\n\\n    mapping(address => mapping(address => mapping(bytes1 => mapping(uint256 => uint256)))) public swapAmountDelta;\\n\\n    mapping(address => mapping(address => mapping(bytes1 => mapping(uint256 => uint256)))) public accumRatio;\\n}\\n\"\r\n    },\r\n    \"contracts/core/DCAPositionHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"./../interfaces/IDCAPositionHandler.sol\\\";\\nimport \\\"./../utils/Permitable.sol\\\";\\nimport \\\"./DCAConfigHandler.sol\\\";\\n\\nimport { UserPosition, PositionInfo, CreatePositionDetails, PermitType } from \\\"./../common/Types.sol\\\";\\nimport { ZeroAddress, NotWNative, NativeTransferFailed, UnauthorizedTokens, InvalidAmount, InvalidNoOfSwaps, UnauthorizedInterval, InvalidRate, NoChanges, ZeroSwappedTokens, InvalidAmountTransferred, InvalidNativeAmount, InvalidPosition } from \\\"./../common/Error.sol\\\";\\n\\nabstract contract DCAPositionHandler is Permitable, DCAConfigHandler, IDCAPositionHandler {\\n    using SafeERC20 for IERC20;\\n\\n    mapping(uint256 => UserPosition) public userPositions;\\n    mapping(uint256 => uint256) internal _swappedBeforeModified; // positionId -> swappedAmount\\n\\n    uint256 public totalCreatedPositions;\\n\\n    /* ========= CONSTRUCTOR ========= */\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(address permit2_) Permitable(permit2_) {}\\n\\n    /* ========= VIEWS ========= */\\n\\n    function getPositionDetails(uint256 positionId_) external view returns (PositionInfo memory positionInfo) {\\n        UserPosition memory userPosition = userPositions[positionId_];\\n\\n        uint256 performedSwaps = swapData[userPosition.from][userPosition.to][userPosition.swapIntervalMask].performedSwaps;\\n\\n        positionInfo.owner = userPosition.owner;\\n        positionInfo.from = userPosition.from;\\n        positionInfo.to = userPosition.to;\\n        positionInfo.rate = userPosition.rate;\\n\\n\\n        positionInfo.swapsLeft = _remainingNoOfSwaps(userPosition.startingSwap, userPosition.finalSwap, performedSwaps);\\n        positionInfo.swapsExecuted = userPosition.finalSwap - userPosition.startingSwap - positionInfo.swapsLeft;\\n        positionInfo.unswapped = _calculateUnswapped(userPosition, performedSwaps);\\n\\n        if (userPosition.swapIntervalMask > 0) {\\n            positionInfo.swapInterval = Intervals.maskToInterval(userPosition.swapIntervalMask);\\n            positionInfo.swapped = _calculateSwapped(positionId_, userPosition, performedSwaps);\\n        }\\n    }\\n\\n    /* ========= FUNCTIONS ========= */\\n\\n    function createPosition(CreatePositionDetails calldata details_) external payable whenNotPaused {\\n        if (details_.from == NATIVE_TOKEN && msg.value != details_.amount) revert InvalidNativeAmount();\\n\\n        (uint256 positionId, bool isNative) = _create(details_);\\n\\n        emit Created(_msgSender(), positionId, isNative);\\n    }\\n\\n    function createBatchPositions(CreatePositionDetails[] calldata details_) external payable whenNotPaused {\\n        uint256 value = msg.value;\\n        bool[] memory isNative = new bool[](details_.length);\\n\\n        for (uint256 i; i < details_.length; ++i) {\\n            if (details_[i].from == NATIVE_TOKEN) {\\n                if (details_[i].amount > value) revert InvalidNativeAmount();\\n                value -= details_[i].amount;\\n            }\\n\\n            (, isNative[i]) = _create(details_[i]);\\n        }\\n\\n        if (value != 0) revert InvalidNativeAmount();\\n\\n        emit CreatedBatched(_msgSender(), totalCreatedPositions, details_.length, isNative);\\n    }\\n\\n    function modifyPosition(uint256 positionId_, uint256 amount_, uint256 noOfSwaps_, bool isIncrease_, bool isNative_, bytes calldata permit_) external payable whenNotPaused {\\n        UserPosition memory userPosition = userPositions[positionId_];\\n        _assertPositionExistsAndCallerIsOwner(userPosition);\\n\\n        if (amount_ == 0) {\\n            // only noOfSwaps is updated\\n            _assertTokensAreAllowed(userPosition.from, userPosition.to);\\n            if (msg.value != 0) revert InvalidNativeAmount();\\n        } else if (isIncrease_) {\\n            // increase\\n            _assertTokensAreAllowed(userPosition.from, userPosition.to);\\n\\n            _deposit(isNative_, userPosition.from, amount_, permit_);\\n        }\\n\\n        (uint256 rate, uint256 startingSwap, uint256 finalSwap) = _modify(userPosition, positionId_, amount_, noOfSwaps_, isIncrease_);\\n\\n        // reduce\\n        if (!isIncrease_ && amount_ > 0) _pay(isNative_, userPosition.from, _msgSender(), amount_);\\n\\n        emit Modified(_msgSender(), positionId_, rate, startingSwap, finalSwap, isNative_);\\n    }\\n\\n    function terminatePosition(uint256 positionId_, address recipient_, bool isNative_) external {\\n        if (recipient_ == address(0)) revert ZeroAddress();\\n\\n        UserPosition memory userPosition = userPositions[positionId_];\\n        _assertPositionExistsAndCallerIsOwner(userPosition);\\n\\n        (uint256 unswapped, uint256 swapped) = _terminate(userPosition, positionId_);\\n\\n        if (isNative_) {\\n            if (userPosition.from == address(wNative)) {\\n                _unwrapAndTransfer(recipient_, unswapped);\\n                IERC20(userPosition.to).safeTransfer(recipient_, swapped);\\n            } else if ((userPosition.to == address(wNative))) {\\n                IERC20(userPosition.from).safeTransfer(recipient_, unswapped);\\n                _unwrapAndTransfer(recipient_, swapped);\\n            } else revert NotWNative();\\n        } else {\\n            IERC20(userPosition.from).safeTransfer(recipient_, unswapped);\\n            IERC20(userPosition.to).safeTransfer(recipient_, swapped);\\n        }\\n\\n        emit Terminated(_msgSender(), recipient_, positionId_, swapped, unswapped, isNative_);\\n    }\\n\\n    function withdrawPosition(uint256 positionId_, address recipient_, bool isNative_) external {\\n        if (recipient_ == address(0)) revert ZeroAddress();\\n\\n        UserPosition memory userPosition = userPositions[positionId_];\\n        _assertPositionExistsAndCallerIsOwner(userPosition);\\n\\n        uint256 swapped = _withdraw(userPosition, positionId_);\\n        if (swapped == 0) revert ZeroSwappedTokens();\\n\\n        _pay(isNative_, userPosition.to, recipient_, swapped);\\n\\n        emit Withdrawn(_msgSender(), recipient_, positionId_, swapped, isNative_);\\n    }\\n\\n    function transferPositionOwnership(uint256 positionId_, address newOwner_) external whenNotPaused {\\n        if (newOwner_ == address(0)) revert ZeroAddress();\\n\\n        UserPosition memory userPosition = userPositions[positionId_];\\n        _assertPositionExistsAndCallerIsOwner(userPosition);\\n\\n        userPositions[positionId_].owner = newOwner_;\\n\\n        emit PositionOwnerUpdated(userPosition.owner, newOwner_, positionId_);\\n    }\\n\\n    /* ========= INTERNAL ========= */\\n\\n    function _deposit(bool isNative_, address token_, uint256 amount_, bytes calldata permit_) private {\\n        if (isNative_) {\\n            if (msg.value != amount_) revert InvalidNativeAmount();\\n            if (token_ != address(wNative)) revert NotWNative();\\n            _wrap(amount_);\\n        } else {\\n            _permitAndTransferFrom(token_, permit_, amount_);\\n        }\\n    }\\n\\n    function _pay(bool isNative_, address token_, address recipient_, uint256 amount_) private {\\n        if (isNative_) {\\n            if (token_ != address(wNative)) revert NotWNative();\\n            _unwrapAndTransfer(recipient_, amount_);\\n        } else {\\n            IERC20(token_).safeTransfer(recipient_, amount_);\\n        }\\n    }\\n\\n    function _safeNativeTransfer(address recipient_, uint256 amount_) internal {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool sent, ) = recipient_.call{ value: amount_ }(new bytes(0));\\n        if (!sent) revert NativeTransferFailed();\\n    }\\n \\n    function _permitAndTransferFrom(address token_, bytes calldata permit_, uint256 amount_) internal {\\n        (PermitType permitType, bytes memory data) = abi.decode(permit_, (PermitType, bytes)); \\n\\n        if(permitType == PermitType.PERMIT2_APPROVE)  {\\n            _permit2Approve(token_, data);\\n            IPermit2(PERMIT2).transferFrom(\\n                _msgSender(),\\n                address(this),\\n                uint160(amount_),\\n                token_\\n            );\\n        } else if (permitType == PermitType.PERMIT2_TRANSFER_FROM) {\\n            _permit2TransferFrom(token_, data, amount_);\\n        } else {\\n            _permit(token_, data);\\n            IERC20(token_).safeTransferFrom(_msgSender(), address(this), amount_);\\n        }\\n    }\\n\\n    function _wrap(uint256 amount_) internal {\\n        if (amount_ > 0) wNative.deposit{ value: amount_ }();\\n    }\\n\\n    function _unwrapAndTransfer(address recipient_, uint256 amount_) internal {\\n        if (amount_ > 0) {\\n            wNative.withdraw(amount_);\\n            _safeNativeTransfer(recipient_, amount_);\\n        }\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _create(CreatePositionDetails calldata details_) private returns (uint256 positionId, bool isNative) {\\n        if (details_.from == address(0) || details_.to == address(0)) revert ZeroAddress();\\n        if (details_.amount == 0) revert InvalidAmount();\\n        if (details_.noOfSwaps == 0 || details_.noOfSwaps > maxNoOfSwap) revert InvalidNoOfSwaps();\\n\\n        bool isFromNative = details_.from == NATIVE_TOKEN;\\n        bool isToNative = details_.to == NATIVE_TOKEN;\\n        isNative = isFromNative || isToNative;\\n\\n        address from = isFromNative ? address(wNative) : details_.from;\\n        address to = isToNative ? address(wNative) : details_.to;\\n\\n        if (from == to) revert InvalidToken();\\n        _assertTokensAreAllowed(from, to);\\n\\n        bytes1 swapIntervalMask = Intervals.intervalToMask(details_.swapInterval);\\n        if (allowedSwapIntervals & swapIntervalMask == 0) revert InvalidInterval();\\n\\n        uint256 rate = _calculateRate(details_.amount, details_.noOfSwaps);\\n        if (rate == 0) revert InvalidRate();\\n\\n        // transfer tokens\\n        if (isFromNative) _wrap(details_.amount);\\n        else _permitAndTransferFrom(from, details_.permit, details_.amount);\\n\\n        positionId = ++totalCreatedPositions;\\n        uint256 performedSwaps = swapData[from][to][swapIntervalMask].performedSwaps;\\n\\n        // updateActiveIntervals\\n        if (activeSwapIntervals[from][to] & swapIntervalMask == 0) activeSwapIntervals[from][to] |= swapIntervalMask;\\n\\n        (uint256 startingSwap, uint256 finalSwap) = _addToDelta(from, to, swapIntervalMask, rate, performedSwaps, performedSwaps + details_.noOfSwaps\\n        );\\n\\n        userPositions[positionId] = UserPosition({\\n            owner: _msgSender(), from: from, to: to, swapIntervalMask: swapIntervalMask, rate: rate, \\n            swapWhereLastUpdated: performedSwaps, startingSwap: startingSwap, finalSwap: finalSwap\\n        });\\n    }\\n\\n    function _modify(UserPosition memory userPosition_, uint256 positionId_, uint256 amount_, uint256 noOfSwaps_, bool isIncrease_) \\n        internal returns (uint256 newRate,uint256 newStartingSwap,uint256 newFinalSwap) \\n    {\\n        uint256 performedSwaps = swapData[userPosition_.from][userPosition_.to][userPosition_.swapIntervalMask].performedSwaps;\\n        uint256 remainingNoOfSwaps = _remainingNoOfSwaps(userPosition_.startingSwap, userPosition_.finalSwap, performedSwaps);\\n        uint256 unswapped = remainingNoOfSwaps * userPosition_.rate;\\n        uint256 tempUnswapped = unswapped;\\n\\n        if (isIncrease_) tempUnswapped += amount_;\\n        else {\\n            if (amount_ > unswapped) revert InvalidAmount();\\n            tempUnswapped -= amount_;\\n        }\\n\\n        if (tempUnswapped == unswapped && noOfSwaps_ == remainingNoOfSwaps) revert NoChanges();\\n        if (\\n            (tempUnswapped > 0 && (noOfSwaps_ == 0 || noOfSwaps_ > maxNoOfSwap)) ||\\n            (tempUnswapped == 0 && noOfSwaps_ > 0)\\n        ) revert InvalidNoOfSwaps();\\n\\n        if (noOfSwaps_ > 0) newRate = _calculateRate(tempUnswapped, noOfSwaps_);\\n        if (newRate > 0) {\\n            newStartingSwap = performedSwaps;\\n            newFinalSwap = performedSwaps + noOfSwaps_;\\n        }\\n\\n        // store current claimable swap tokens.\\n        _swappedBeforeModified[positionId_] = _calculateSwapped(positionId_, userPosition_, performedSwaps);\\n\\n        // remove the prev position\\n        _removeFromDelta(userPosition_, performedSwaps);\\n\\n        if(newRate > 0) {\\n            // add updated position\\n            (newStartingSwap, newFinalSwap) = _addToDelta(userPosition_.from, userPosition_.to, userPosition_.swapIntervalMask, newRate, newStartingSwap, newFinalSwap);\\n\\n            if((activeSwapIntervals[userPosition_.from][userPosition_.to] & userPosition_.swapIntervalMask == 0)) {\\n                // add in activeSwapIntervals\\n                activeSwapIntervals[userPosition_.from][userPosition_.to] |= userPosition_.swapIntervalMask;\\n            }\\n        } else {\\n             // remove from activeSwapIntervals (if no other positions exist)\\n             SwapData memory data = swapData[userPosition_.from][userPosition_.to][userPosition_.swapIntervalMask];\\n             \\n             if (data.nextAmountToSwap == 0 && data.nextToNextAmountToSwap == 0)\\n                activeSwapIntervals[userPosition_.from][userPosition_.to] &= ~userPosition_.swapIntervalMask;\\n        }\\n\\n        userPositions[positionId_].rate = newRate;\\n        userPositions[positionId_].swapWhereLastUpdated = performedSwaps;\\n        userPositions[positionId_].startingSwap = newStartingSwap;\\n        userPositions[positionId_].finalSwap = newFinalSwap;\\n    }\\n\\n    function _terminate(UserPosition memory userPosition_, uint256 positionId_) private returns (uint256 unswapped, uint256 swapped){\\n        uint256 performedSwaps = swapData[userPosition_.from][userPosition_.to][userPosition_.swapIntervalMask].performedSwaps;\\n\\n        swapped = _calculateSwapped(positionId_, userPosition_, performedSwaps);\\n        unswapped = _calculateUnswapped(userPosition_, performedSwaps);\\n\\n        // removeFromDelta\\n        _removeFromDelta(userPosition_, performedSwaps);\\n\\n        SwapData memory data = swapData[userPosition_.from][userPosition_.to][userPosition_.swapIntervalMask];\\n             \\n        if (data.nextAmountToSwap == 0 && data.nextToNextAmountToSwap == 0)\\n            activeSwapIntervals[userPosition_.from][userPosition_.to] &= ~userPosition_.swapIntervalMask;\\n\\n        delete userPositions[positionId_];\\n        _swappedBeforeModified[positionId_] = 0;\\n    }\\n\\n    function _withdraw(UserPosition memory userPosition_, uint256 positionId_) internal returns (uint256 swapped) {\\n        uint256 performedSwaps = swapData[userPosition_.from][userPosition_.to][userPosition_.swapIntervalMask].performedSwaps;\\n\\n        swapped = _calculateSwapped(positionId_, userPosition_, performedSwaps);\\n\\n        userPositions[positionId_].swapWhereLastUpdated = performedSwaps;\\n        _swappedBeforeModified[positionId_] = 0;\\n    }\\n\\n    function _addToDelta(address from_, address to_, bytes1 swapIntervalMask_, uint256 rate_, uint256 startingSwap_, uint256 finalSwap_) internal returns (uint256, uint256) {\\n        (bool isPartOfNextSwap, uint256 timeUntilThreshold) = _getTimeUntilThreshold(from_, to_, swapIntervalMask_);\\n        SwapData storage data = swapData[from_][to_][swapIntervalMask_];\\n\\n        if (isPartOfNextSwap && block.timestamp > timeUntilThreshold) {\\n            startingSwap_ += 1;\\n            finalSwap_ += 1;\\n            data.nextToNextAmountToSwap += rate_;\\n        } else {\\n            data.nextAmountToSwap += rate_;\\n        }\\n\\n        swapAmountDelta[from_][to_][swapIntervalMask_][finalSwap_ + 1] += rate_;\\n        return (startingSwap_, finalSwap_);\\n    }\\n\\n    function _removeFromDelta(UserPosition memory userPosition_, uint256 performedSwaps_) internal {\\n        if (userPosition_.finalSwap > performedSwaps_) {\\n            SwapData storage data = swapData[userPosition_.from][userPosition_.to][userPosition_.swapIntervalMask];\\n\\n            if (userPosition_.startingSwap > performedSwaps_) {\\n                data.nextToNextAmountToSwap -= userPosition_.rate;\\n            } else {\\n                data.nextAmountToSwap -= userPosition_.rate;\\n            }\\n            swapAmountDelta[userPosition_.from][userPosition_.to][userPosition_.swapIntervalMask][\\n                userPosition_.finalSwap + 1\\n            ] -= userPosition_.rate;\\n        }\\n    }\\n\\n    function _calculateSwapped( uint256 positionId_, UserPosition memory userPosition_, uint256 performedSwaps_) internal view returns (uint256) {\\n        uint256 finalNo = Math.min(performedSwaps_, userPosition_.finalSwap);\\n\\n        // If last update happened after the position's final swap, then a withdraw was executed, and we just return 0\\n        if (userPosition_.swapWhereLastUpdated > finalNo) return 0;\\n        // If the last update matches the positions's final swap, then we can avoid all calculation below\\n        else if (userPosition_.swapWhereLastUpdated == finalNo) return _swappedBeforeModified[positionId_];\\n\\n        uint256 startingNo= Math.max(userPosition_.swapWhereLastUpdated, userPosition_.startingSwap);\\n        uint256 avgAccumulationPrice = accumRatio[userPosition_.from][userPosition_.to][userPosition_.swapIntervalMask][finalNo] -\\n            accumRatio[userPosition_.from][userPosition_.to][userPosition_.swapIntervalMask][startingNo];\\n\\n        return ((avgAccumulationPrice * userPosition_.rate) / tokenMagnitude[userPosition_.from]) + _swappedBeforeModified[positionId_];\\n    }\\n\\n    function _remainingNoOfSwaps(uint256 startingSwap_, uint256 finalSwap_, uint256 performedSwaps_) private pure returns (uint256 remainingNoOfSwap) {\\n        uint256 noOfSwaps = finalSwap_ - startingSwap_;\\n        uint256 totalSwapExecutedFromStart = _subtractIfPossible(performedSwaps_, startingSwap_);\\n        remainingNoOfSwap = totalSwapExecutedFromStart > noOfSwaps ? 0 : noOfSwaps - totalSwapExecutedFromStart;\\n    }\\n\\n    function _calculateUnswapped(UserPosition memory userPosition_, uint256 performedSwaps_) internal pure returns (uint256){\\n        return _remainingNoOfSwaps(userPosition_.startingSwap, userPosition_.finalSwap, performedSwaps_) * userPosition_.rate;\\n    }\\n\\n    function _calculateRate(uint256 amount_, uint256 noOfSwaps_) internal pure returns (uint256) {\\n        return amount_ / noOfSwaps_;\\n    }\\n\\n    function _assertTokensAreAllowed(address tokenA_, address tokenB_) internal view {\\n        if (!allowedTokens[tokenA_] || !allowedTokens[tokenB_]) revert UnauthorizedTokens();\\n    }\\n\\n    function _assertPositionExistsAndCallerIsOwner(UserPosition memory userPosition_) internal view {\\n        if (userPosition_.swapIntervalMask == 0) revert InvalidPosition();\\n        if (_msgSender() != userPosition_.owner) revert UnauthorizedCaller();\\n    }\\n\\n    function _subtractIfPossible(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ > b_ ? a_ - b_ : 0;\\n    }\\n\\n    function _getTimeUntilThreshold(address from_, address to_, bytes1 interval_) private view returns (bool, uint256) {\\n        bytes1 activeIntervals = activeSwapIntervals[from_][to_];\\n        bytes1 mask = 0x01;\\n        bytes1 intervalsInSwap;\\n        uint256 nextSwapTimeEnd = type(uint256).max;\\n\\n        while (activeIntervals >= mask && mask > 0) {\\n            if (activeIntervals & mask == mask || interval_ == mask) {\\n                SwapData memory swapDataMem = swapData[from_][to_][mask];\\n                uint32 swapInterval = Intervals.maskToInterval(mask);\\n                uint256 currSwapTime = (block.timestamp / swapInterval) * swapInterval; \\n                uint256 nextSwapTime = swapDataMem.lastSwappedAt == 0\\n                    ? currSwapTime\\n                    : ((swapDataMem.lastSwappedAt / swapInterval) + 1) * swapInterval;\\n                \\n                // as swaps will only be done in current window\\n                // so if next window is smaller than current window then update the next window\\n                if(currSwapTime > nextSwapTime) nextSwapTime = currSwapTime;\\n                uint256 tempNextSwapTimeEnd = nextSwapTime + swapInterval;\\n\\n                if (\\n                    (block.timestamp > nextSwapTime && block.timestamp < tempNextSwapTimeEnd) &&\\n                    (swapDataMem.nextAmountToSwap > 0 || mask == interval_)\\n                ) {\\n                    intervalsInSwap |= mask;\\n                    if (tempNextSwapTimeEnd < nextSwapTimeEnd) {\\n                        nextSwapTimeEnd = tempNextSwapTimeEnd;\\n                    }\\n                }\\n            }\\n            mask <<= 1;\\n        }\\n        return (intervalsInSwap & interval_ == interval_, nextSwapTimeEnd - nextToNextTimeThreshold);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/DCASwapHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"./../interfaces/IDCASwapHandler.sol\\\";\\nimport \\\"./DCAConfigHandler.sol\\\";\\n\\nimport { SwapInfo, Pair, SwapDetails } from \\\"./../common/Types.sol\\\";\\nimport { InvalidLength, NoAvailableSwap, InvalidSwapAmount, InvalidReturnAmount, SwapCallFailed, InvalidBlankSwap } from \\\"./../common/Error.sol\\\";\\n\\nabstract contract DCASwapHandler is DCAConfigHandler, IDCASwapHandler {\\n    using SafeERC20 for IERC20;\\n\\n    /* ========= VIEWS ========= */\\n\\n    function secondsUntilNextSwap(Pair[] calldata pairs_) external view returns (uint256[] memory) {\\n        uint256[] memory secondsArr = new uint256[](pairs_.length);\\n        for (uint256 i; i < pairs_.length; i++) secondsArr[i] = _secondsUntilNextSwap(pairs_[i].from, pairs_[i].to);\\n        return secondsArr;\\n    }\\n\\n    function getNextSwapInfo(Pair[] calldata pairs_) external view returns (SwapInfo[] memory) {\\n        SwapInfo[] memory swapInformation = new SwapInfo[](pairs_.length);\\n\\n        for (uint256 i; i < pairs_.length; ++i) {\\n            Pair memory pair = pairs_[i];\\n\\n            (uint256 amountToSwap, bytes1 intervalsInSwap, uint256 swapperReward, uint256 platformFee) = _getTotalAmountsToSwap(pair.from, pair.to);\\n\\n            swapInformation[i] = SwapInfo(pair.from, pair.to, amountToSwap, 0, swapperReward, platformFee, intervalsInSwap);\\n        }\\n\\n        return swapInformation;\\n    }\\n\\n    /* ========= PUBLIC ========= */\\n\\n    function swap(SwapDetails[] calldata data_, address rewardRecipient_) external onlySwapper whenNotPaused {\\n        if (data_.length == 0) revert InvalidLength();\\n        SwapInfo[] memory swapInfo = new SwapInfo[](data_.length);\\n\\n        for (uint256 i; i < data_.length; ++i) {\\n            SwapDetails memory data = data_[i];\\n            (uint256 amountToSwap, bytes1 intervalsInSwap, uint256 swapperReward, uint256 platformFee) = _getTotalAmountsToSwap(data.from, data.to);\\n\\n            if (amountToSwap == 0 || intervalsInSwap == 0) revert NoAvailableSwap();\\n            if (data.amount != amountToSwap) revert InvalidSwapAmount();\\n\\n            // execute Swap\\n            uint256 returnAmount = _executeSwap(data);\\n\\n            if (returnAmount < data.minReturnAmount) revert InvalidReturnAmount();\\n\\n            // register swap\\n            _registerSwap(data.from, data.to, amountToSwap, returnAmount, intervalsInSwap);\\n\\n            swapInfo[i] = SwapInfo(data.from, data.to, amountToSwap, returnAmount, swapperReward, platformFee, intervalsInSwap);\\n\\n            // transfer reward and fee\\n            if (platformFee > 0) IERC20(data.from).safeTransfer(feeVault, platformFee);\\n            if (swapperReward > 0) IERC20(data.from).safeTransfer(rewardRecipient_, swapperReward);\\n        }\\n        emit Swapped(_msgSender(), rewardRecipient_, swapInfo);\\n    }\\n\\n    /**\\n        wont come under this until it all positions have a blank swap active\\n        dont update lastSwappedAt;\\n         swapAmountDelta:\\n            in create in will be grater than swapDataMem.performSwap + 1\\n            in modify if will have been updated\\n    */\\n    function blankSwap(address from_, address to_, bytes1 maskedInterval_) external onlySwapper whenNotPaused {\\n        SwapData storage data = swapData[from_][to_][maskedInterval_];\\n        \\n        if (data.nextAmountToSwap > 0 || data.nextToNextAmountToSwap == 0) revert InvalidBlankSwap();\\n        // require(data.nextAmountToSwap == 0 && data.nextToNextAmountToSwap > 0, \\\"InvalidBlankSwap\\\");\\n\\n        accumRatio[from_][to_][maskedInterval_][data.performedSwaps + 1] = accumRatio[from_][to_][maskedInterval_][data.performedSwaps];\\n\\n        data.nextAmountToSwap += data.nextToNextAmountToSwap;\\n        data.nextToNextAmountToSwap = 0;\\n        data.performedSwaps += 1;\\n\\n        emit BlankSwapped(_msgSender(), from_, to_, maskedInterval_);\\n    }\\n\\n    /* ========= INTERNAL ========= */\\n\\n    function _executeSwap(SwapDetails memory data_) private returns (uint256 returnAmount) {\\n        uint256 balanceBefore = IERC20(data_.to).balanceOf(address(this));\\n        IERC20(data_.from).approve(data_.tokenProxy, data_.amount);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = data_.executor.call(data_.swapCallData);\\n        if (!success) revert SwapCallFailed();\\n\\n        returnAmount = IERC20(data_.to).balanceOf(address(this)) - balanceBefore;\\n    }\\n\\n    function _getSwapAmountAndFee(uint256 amount_, uint256 fee_) private pure returns (uint256, uint256) {\\n        uint256 feeAmount = (amount_ * fee_) / BPS_DENOMINATOR;\\n        return (amount_ - feeAmount, feeAmount);\\n    }\\n\\n    function _getTotalAmountsToSwap(address from_, address to_) private view \\n        returns (uint256 amountToSwap, bytes1 intervalsInSwap, uint256 swapperReward, uint256 platformFee) \\n    {\\n        bytes1 activeIntervalsMem = activeSwapIntervals[from_][to_];\\n        bytes1 mask = 0x01;\\n\\n        while (activeIntervalsMem >= mask && mask > 0) {\\n            if (activeIntervalsMem & mask != 0) {\\n                SwapData memory swapDataMem = swapData[from_][to_][mask];\\n                uint32 swapInterval = Intervals.maskToInterval(mask);\\n\\n                // Note: this 'break' is both an optimization and a search for more CoW. Since this loop starts with the smaller intervals, it is\\n                // highly unlikely that if a small interval can't be swapped, a bigger interval can. It could only happen when a position was just\\n                // created for a new swap interval. At the same time, by adding this check, we force intervals to be swapped together.\\n                if (((swapDataMem.lastSwappedAt / swapInterval) + 1) * swapInterval > block.timestamp) break;\\n\\n                if (swapDataMem.nextAmountToSwap > 0) {\\n                    intervalsInSwap |= mask;\\n                    (uint256 amountToSwapForInterval, uint256 feeAmount) = _getSwapAmountAndFee(swapDataMem.nextAmountToSwap, _swapFeeMap[mask]);\\n                    (uint256 reward, uint256 fee) = _getSwapAmountAndFee(feeAmount, platformFeeRatio);\\n\\n                    amountToSwap += amountToSwapForInterval;\\n                    swapperReward += reward;\\n                    platformFee += fee;\\n                }\\n            }\\n\\n            mask <<= 1;\\n        }\\n\\n        if (amountToSwap == 0) intervalsInSwap = 0;\\n    }\\n\\n    function _registerSwap(address tokenA_, address tokenB_,uint256 amountToSwap_, uint256 totalReturnAmount_, bytes1 intervalsInSwap_) private {\\n        bytes1 mask = 0x01;\\n        bytes1 activeIntervals = activeSwapIntervals[tokenA_][tokenB_];\\n\\n        while (activeIntervals >= mask && mask != 0) {\\n            // nextAmountToSwap > 0. \\n            // nextAmountToSwap > 0. nextToNext > 0\\n            SwapData memory swapDataMem = swapData[tokenA_][tokenB_][mask];\\n\\n            if (intervalsInSwap_ & mask != 0 && swapDataMem.nextAmountToSwap > 0) {\\n                (uint256 amountToSwapForIntervalWithoutFee, ) = _getSwapAmountAndFee(swapDataMem.nextAmountToSwap, _swapFeeMap[mask]);\\n                uint256 returnAmountForInterval = totalReturnAmount_ * amountToSwapForIntervalWithoutFee * tokenMagnitude[tokenA_] / amountToSwap_;\\n                uint256 swapPrice = returnAmountForInterval / swapDataMem.nextAmountToSwap;\\n\\n                // accumRatio[currSwapNo] = accumRatio[prevSwapNo] + swapPriceForInterval\\n                accumRatio[tokenA_][tokenB_][mask][swapDataMem.performedSwaps + 1] = accumRatio[tokenA_][tokenB_][mask][swapDataMem.performedSwaps] + swapPrice;\\n\\n                // nextAmountToSwap = nextAmountToSwap - amounts for position which have to finished\\n                swapData[tokenA_][tokenB_][mask] = SwapData(\\n                    swapDataMem.performedSwaps + 1,\\n                    swapDataMem.nextAmountToSwap +\\n                        swapDataMem.nextToNextAmountToSwap -\\n                        swapAmountDelta[tokenA_][tokenB_][mask][swapDataMem.performedSwaps + 2],\\n                    0,\\n                    block.timestamp\\n                );\\n\\n                // remove swapInterval from  activeSwapIntervals if all swaps for it are been executed\\n                if (swapData[tokenA_][tokenB_][mask].nextAmountToSwap == 0) activeSwapIntervals[tokenA_][tokenB_] &= ~mask;\\n\\n                delete swapAmountDelta[tokenA_][tokenB_][mask][swapDataMem.performedSwaps + 2];\\n            } else if (swapDataMem.nextAmountToSwap == 0 && swapDataMem.nextToNextAmountToSwap > 0) {\\n                // nextAmountToSwap = 0. nextToNext > 0\\n                SwapData storage data = swapData[tokenA_][tokenB_][mask];\\n\\n                accumRatio[tokenA_][tokenB_][mask][swapDataMem.performedSwaps + 1] = accumRatio[tokenA_][tokenB_][mask][swapDataMem.performedSwaps];\\n\\n                data.nextAmountToSwap = swapDataMem.nextAmountToSwap + swapDataMem.nextToNextAmountToSwap;\\n                data.nextToNextAmountToSwap = 0;\\n                data.performedSwaps += 1;\\n\\n                // emit BlankSwapped(_msgSender(), tokenA_, tokenB_, mask);\\n            }\\n            mask <<= 1;\\n        }\\n    }\\n\\n    function _secondsUntilNextSwap(address from_, address to_) private view returns (uint256) {\\n        bytes1 activeIntervals = activeSwapIntervals[from_][to_];\\n        bytes1 mask = 0x01;\\n        uint256 smallerIntervalBlocking;\\n\\n        while (activeIntervals >= mask && mask > 0) {\\n            if (activeIntervals & mask == mask) {\\n                SwapData memory swapDataMem = swapData[from_][to_][mask];\\n                uint32 swapInterval = Intervals.maskToInterval(mask);\\n                uint256 nextAvailable = ((swapDataMem.lastSwappedAt / swapInterval) + 1) * swapInterval;\\n\\n                if (swapDataMem.nextAmountToSwap > 0) {\\n                    if (nextAvailable <= block.timestamp) return smallerIntervalBlocking;\\n                    else return nextAvailable - block.timestamp;\\n                } else if (nextAvailable > block.timestamp) {\\n                    smallerIntervalBlocking = smallerIntervalBlocking == 0 ? nextAvailable - block.timestamp : smallerIntervalBlocking;\\n                }\\n            }\\n            mask <<= 1;\\n        }\\n        return type(uint256).max;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/DZapDCA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"./../interfaces/IDZapDCA.sol\\\";\\n\\nimport \\\"./DCAParameters.sol\\\";\\nimport \\\"./DCAConfigHandler.sol\\\";\\nimport \\\"./DCAPositionHandler.sol\\\"; \\nimport \\\"./DCASwapHandler.sol\\\";\\n\\nimport { ZeroAddress } from \\\"./../common/Error.sol\\\";\\n\\ncontract DZapDCA is DCAParameters, DCAConfigHandler, DCASwapHandler, DCAPositionHandler, IDZapDCA {\\n    using SafeERC20 for IERC20;\\n\\n    constructor(address governor_, address wNative_, address feeVault_, address permit2_, uint256 maxNoOfSwap_) DCAConfigHandler(governor_, wNative_, feeVault_, maxNoOfSwap_) DCAPositionHandler(permit2_) {} // solhint-disable-line no-empty-blocks\\n\\n    /* ========= USER FUNCTIONS ========= */\\n\\n    function batchCall(bytes[] calldata data_) external returns (bytes[] memory results) {\\n        results = new bytes[](data_.length);\\n        for (uint256 i; i < data_.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data_[i]);\\n        }\\n        return results;\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDAIPermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\ninterface IDAIPermit {\\n    /**\\n     * @dev Sets the allowance of `spender` over ``holder``'s tokens,\\n     * given ``holder``'s signed approval.\\n     */\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDCAConfigHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"./IWNative.sol\\\";\\n\\ninterface IDCAConfigHandler {\\n    /* ========= EVENTS ========= */\\n\\n    event AdminAdded(address[] accounts);\\n\\n    event AdminRemoved(address[] accounts);\\n\\n    event SwapExecutorAdded(address[] accounts);\\n\\n    event SwapExecutorRemoved(address[] accounts);\\n\\n    event SwapLimitUpdated(uint256 noOfSwaps);\\n\\n    event SwapThresholdUpdated(uint256 threshold);\\n\\n    event TokensAdded(address[] tokens);\\n\\n    event TokensRemoved(address[] tokens);\\n\\n    event SwapIntervalsAdded(uint32[] swapIntervals);\\n\\n    event SwapIntervalsRemoved(uint32[] swapIntervals);\\n\\n    event FeeVaultUpdated(address feeVault);\\n\\n    event SwapFeeUpdated(uint32[] intervals, uint256[] swapFee);\\n\\n    event PlatformFeeRatioUpdated(uint256 platformFeeRatio);\\n\\n    /* ========= VIEWS ========= */\\n\\n    /// @notice Returns a byte that represents allowed swap intervals\\n    function allowedSwapIntervals() external view returns (bytes1);\\n\\n    /// @notice Returns if a token is currently allowed or not\\n    function allowedTokens(address token_) external view returns (bool);\\n\\n    /// @notice Returns token's magnitude (10**decimals)\\n    function tokenMagnitude(address token_) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns whether account is admin or not\\n     * @param account_ account to check\\n     */\\n    function admins(address account_) external view returns (bool);\\n\\n    /**\\n     * @notice Returns whether account is a swap executors or not\\n     * @param account_ account to check\\n     */\\n    function swapExecutors(address account_) external view returns (bool);\\n\\n    /// @notice Returns address of wNative token\\n    function wNative() external view returns (IWNative);\\n\\n    /// @notice Returns the address of vault where platform fee will be deposited\\n    function feeVault() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address which will be used for Native tokens\\n     * @dev Cannot be modified\\n     * @return Native token\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function NATIVE_TOKEN() external view returns (address);\\n\\n    /// @notice Returns the percent of fee that will be charged on swaps\\n    function getSwapFee(uint32 interval_) external view returns (uint256);\\n\\n    /// @notice Returns the percent of swapFee that platform will take\\n    function platformFeeRatio() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the max fee that can be set for swaps\\n     * @dev Cannot be modified\\n     * @return The maximum possible fee\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function MAX_FEE() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the max fee ratio that can be set\\n     * @dev Cannot be modified\\n     * @return The maximum possible value\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function MAX_PLATFORM_FEE_RATIO() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the BPS denominator to be used\\n     * @dev Cannot be modified\\n     * @dev swapFee and platformFeeRatio need to use the precision used by BPS_DENOMINATOR\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function BPS_DENOMINATOR() external view returns (uint256);\\n\\n    /* ========= RESTRICTED FUNCTIONS ========= */\\n\\n    /// @notice Pauses all swaps and deposits\\n    function pause() external;\\n\\n    /// @notice UnPauses if contract is paused\\n    function unpause() external;\\n\\n    /**\\n     * @notice @notice Add admins which can set allowed tokens and intervals\\n     * @dev Can be called by governance\\n     * @param accounts_ array of accounts\\n     */\\n    function addAdmins(address[] calldata accounts_) external;\\n\\n    /**\\n     * @notice @notice Remove admins\\n     * @dev Can be called by governance\\n     * @param accounts_ array of accounts\\n     */\\n    function removeAdmins(address[] calldata accounts_) external;\\n\\n    /**\\n     * @notice @notice Add executors which can do swaps\\n     * @dev Can be called by governance\\n     * @param executor_ array of accounts\\n     */\\n    function addSwapExecutors(address[] calldata executor_) external;\\n\\n    /**\\n     * @notice @notice Remove executors\\n     * @dev Can be called by governance\\n     * @param executor_ array of accounts\\n     */\\n    function removeSwapExecutors(address[] calldata executor_) external;\\n\\n    /**\\n     * @notice Adds new tokens to the allowed list\\n     * @dev Can be called by governance or admins\\n     * @param tokens_ array of tokens\\n     */\\n    function addAllowedTokens(address[] calldata tokens_) external;\\n\\n    /**\\n     * @notice Removes tokens from the allowed list\\n     * @dev Can be called by governance or admins\\n     * @param tokens_ array of tokens\\n     */\\n    function removeAllowedTokens(address[] calldata tokens_) external;\\n\\n    /**\\n     * @notice Adds new swap intervals to the allowed list\\n     * @dev Can be called by governance or admins\\n     * @param swapIntervals_ The new swap intervals\\n     */\\n    function addSwapIntervalsToAllowedList(uint32[] calldata swapIntervals_) external;\\n\\n    /**\\n     * @notice Removes some swap intervals from the allowed list\\n     * @dev Can be called by governance or admins\\n     * @param swapIntervals_ The swap intervals to remove\\n     */\\n    function removeSwapIntervalsFromAllowedList(uint32[] calldata swapIntervals_) external;\\n\\n    /**\\n     * @notice Sets a the fee vault address\\n     * @dev Can be called by governance\\n     * @param newVault_ New vault address\\n     */\\n    function setFeeVault(address newVault_) external;\\n\\n    /**\\n     * @notice Sets a swap fee for different interval\\n     * @dev Can be called by governance\\n     * @dev Will revert with HighFee if the fee is higher than the maximum\\n     * @dev set it in multiple of 100 (1.5% = 150)\\n     * @param intervals_ Array of intervals\\n     * @param swapFee_ Array of fees in respect to intervals\\n     */\\n    function setSwapFee(uint32[] calldata intervals_, uint256[] calldata swapFee_) external;\\n\\n    /**\\n     * @notice Sets a new platform fee ratio\\n     * @dev Can be called by governance\\n     * @dev Will revert with HighPlatformFeeRatio if given ratio is too high\\n     * @dev set it in multiple of 100 (1.5% = 150)\\n     * @param platformFeeRatio_ The new ratio\\n     */\\n    function setPlatformFeeRatio(uint256 platformFeeRatio_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDCAParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\ninterface IDCAParameters {\\n    /* ========= VIEWS ========= */\\n\\n    /// @notice Returns the byte representation of the set of active swap intervals for the given pair\\n    function activeSwapIntervals(address from_, address to_) external view returns (bytes1);\\n\\n    /**\\n     * @notice Returns swapping information about a specific pair\\n     * @param swapInterval_ The byte representation of the swap interval to check\\n     */\\n    function swapData(address from_, address to_, bytes1 swapInterval_) external view \\n        returns (uint256 performedSwaps, uint256 nextAmountToSwap, uint256 nextToNextSwap, uint256 lastSwappedAt);\\n\\n    /// @notice Returns The difference of tokens to swap between a swap, and the previous one\\n    function swapAmountDelta(address from_, address to_, bytes1 swapInterval_, uint256 swapNo_) external view returns (uint256);\\n\\n    /// @notice Returns the sum of the ratios reported in all swaps executed until the given swap number\\n    function accumRatio(address from_, address to_, bytes1 swapInterval_, uint256 swapNo_) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDCAPositionHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { PositionInfo, CreatePositionDetails } from \\\"./../common/Types.sol\\\";\\n\\ninterface IDCAPositionHandler {\\n    /* ========= EVENTS ========= */\\n\\n    event Created(address indexed user, uint256 positionId, bool isNative);\\n\\n    event CreatedBatched(address indexed user, uint256 finalIndex, uint256 noOfPositions, bool[] isNative);\\n\\n    event Modified(address indexed user, uint256 positionId, uint256 rate, uint256 startingSwap, uint256 finalSwap, bool isNative);\\n    event Terminated(address indexed user, address indexed recipient, uint256 positionId, uint256 unswapped, uint256 swapped, bool isNative);\\n    event Withdrawn(address indexed user, address indexed recipient, uint256 positionId, uint256 swapped, bool isNative);\\n    event PositionOwnerUpdated(address indexed oldOwner, address indexed newOwner, uint256 positionId);\\n\\n    /* ========= VIEWS ========= */\\n\\n    /*\\n     * @notice Returns user position info\\n     * @param positionId_ The information about the user position\\n     */\\n    function userPositions(uint256 positionId_) external view returns (address owner, address from, address to, bytes1 swapIntervalMask, uint256 rate, uint256 swapWhereLastUpdated, uint256 startingSwap, uint256 finalSwap);\\n\\n    /// @notice Returns total positions that have been created\\n    function totalCreatedPositions() external view returns (uint256);\\n\\n    /*\\n     * @notice Returns position info\\n     * @dev swapsExecuted, swapsLeft, swapped, unswapped are also returned here\\n     * @param positionId_ The information about the position\\n     */\\n    function getPositionDetails(uint256 positionId_) external view returns (PositionInfo memory positionInfo);\\n\\n    /* ========= USER FUNCTIONS ========= */\\n\\n    /*\\n     * @notice Creates a new position\\n     * @dev can only be call if contract is not pause\\n     * @dev to use positions with native tokens use NATIVE_TOKEN as address\\n     * @dev native token will be internally wrapped to wNative tokens\\n     * @param details_ details for position creation\\n     */\\n    function createPosition(CreatePositionDetails calldata details_) external payable;\\n\\n    /*\\n     * @notice Creates multiple new positions\\n     * @dev can only be call if contract is not pause\\n     * @dev to use positions with native tokens use NATIVE_TOKEN as address\\n     * @dev native token will be internally wrapped to wNative tokens\\n     * @param details_ array of details for position creation\\n     */\\n    function createBatchPositions(CreatePositionDetails[] calldata details_) external payable;\\n\\n    /*\\n     * @notice Modify(increase/reduce/changeOnlyNoOfSwaps) position\\n     * @dev can only be call if contract is not pause\\n     * @param positionId_ The position's id\\n     * @param amount_ Amount of funds to add or remove to the position\\n     * @param noOfSwaps_ The new no of swaps\\n     * @param isIncrease_ Set it as true for increasing\\n     * @param isNative_ Set it as true for increasing/reducing using native token\\n     * @param permit_ permit calldata, erc20Permit, daiPermit, and permit2 both can be used here\\n     */\\n    function modifyPosition(uint256 positionId_, uint256 amount_, uint256 noOfSwaps_, bool isIncrease_, bool isNative_, bytes calldata permit_) external payable;\\n\\n    /*\\n     * @notice Terminate a position and withdraw swapped and unswapped tokens\\n     * @param positionId_ The position's id\\n     * @param recipient_ account where tokens will be transferred\\n     * @param isNative_ Set it as true unwrap wNative to native token\\n     */\\n    function terminatePosition(uint256 positionId_, address recipient_, bool isNative_) external;\\n\\n    /*\\n     * @notice Withdraw swapped tokens\\n     * @param positionId_ The position's id\\n     * @param recipient_ account where tokens will be transferred\\n     * @param isNative_ Set it as true unwrap wNative to native token\\n     */\\n    function withdrawPosition(uint256 positionId_, address recipient_, bool isNative_) external;\\n\\n    /*\\n     * @notice Transfer position ownership to other account\\n     * @dev can only be call if contract is not pause\\n     * @param positionId_ The position's id\\n     * @param newOwner_ New owner to set\\n     */\\n    function transferPositionOwnership(uint256 positionId_, address newOwner_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDCASwapHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { SwapInfo, SwapDetails, Pair } from \\\"./../common/Types.sol\\\";\\n\\ninterface IDCASwapHandler {\\n    /* ========= EVENTS ========= */\\n\\n    event Swapped(address indexed sender, address indexed rewardRecipient, SwapInfo[] swapInformation);\\n   \\n    event BlankSwapped(address indexed sender, address from, address to, bytes1 interval);\\n\\n    /* ========= VIEWS ========= */\\n\\n    /// @notice Returns the time after which next swap chan be done\\n    /// @param pairs_ The pairs that you want to swap.\\n    /// @return time after which swap can can be done\\n    function secondsUntilNextSwap(Pair[] calldata pairs_) external view returns (uint256[] memory);\\n\\n    /// @notice Returns all information related to the next swap\\n    /// @dev Zero will returned for SwapInfo.receivedAmount\\n    /// @param pairs_ The pairs that you want to swap.\\n    /// @return The information about the next swap\\n    function getNextSwapInfo(Pair[] calldata pairs_) external view returns (SwapInfo[] memory);\\n\\n    /* ========= RESTRICTED ========= */\\n\\n    /// @notice Executes a swap\\n    /// @dev Can only be call by swapExecutors\\n    /// @param data_ Array of swap details\\n    /// @param rewardRecipient_ The address to send the reward to\\n    function swap(SwapDetails[] calldata data_, address rewardRecipient_) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDZapDCA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"./IDCAConfigHandler.sol\\\";\\nimport \\\"./IDCAPositionHandler.sol\\\";\\nimport \\\"./IDCASwapHandler.sol\\\";\\nimport \\\"./IDCAParameters.sol\\\";\\n\\ninterface IDZapDCA is IDCAParameters, IDCAConfigHandler, IDCAPositionHandler, IDCASwapHandler {\\n    /* ========= EVENTS ========= */\\n\\n    event TokensRescued(address indexed to, address indexed token, uint256 amount);\\n\\n    /* ========= OPEN ========= */\\n\\n    /// @notice Receives and executes a batch of function calls on this contract.\\n    function batchCall(bytes[] calldata data_) external returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermit2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\ninterface IPermit2 {\\n struct PermitDetails {\\n        address token;\\n        uint160 amount;\\n        uint48 expiration;\\n        uint48 nonce;\\n    }\\n\\n    struct PermitSingle {\\n        PermitDetails details;\\n        address spender;\\n        uint256 sigDeadline;\\n    }\\n\\n    struct TokenPermissions {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    struct PermitTransferFrom {\\n        TokenPermissions permitted;\\n        uint256 nonce;\\n        uint256 deadline;\\n    }\\n\\n    struct SignatureTransferDetails {\\n        address to;\\n        uint256 requestedAmount;\\n    }\\n\\n    function permit(\\n        address owner,\\n        PermitSingle memory permitSingle,\\n        bytes calldata signature\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint160 amount,\\n        address token\\n    ) external;\\n\\n    function permitTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWNative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\n\\ninterface IWNative is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Intervals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { InvalidInterval, InvalidMask } from \\\"./../common/Error.sol\\\";\\n\\n/// @title Intervals library\\n/// @notice Provides functions to easily convert from swap intervals to their byte representation and viceversa\\nlibrary Intervals {\\n    /// @notice Takes a swap interval and returns its byte representation\\n    /// @dev Will revert with InvalidInterval if the swap interval is not valid\\n    /// @param swapInterval_ The swap interval\\n    /// @return The interval's byte representation\\n    // solhint-disable-next-line code-complexity\\n    function intervalToMask(uint32 swapInterval_) internal pure returns (bytes1) {\\n        if (swapInterval_ == 1 hours) return 0x01;\\n        if (swapInterval_ == 4 hours) return 0x02;\\n        if (swapInterval_ == 12 hours) return 0x04;\\n        if (swapInterval_ == 1 days) return 0x08;\\n        if (swapInterval_ == 3 days) return 0x10;\\n        if (swapInterval_ == 1 weeks) return 0x20;\\n        if (swapInterval_ == 2 weeks) return 0x40;\\n        if (swapInterval_ == 30 days) return 0x80;\\n        revert InvalidInterval();\\n    }\\n\\n    /// @notice Takes a byte representation of a swap interval and returns the swap interval\\n    /// @dev Will revert with InvalidMask if the byte representation is not valid\\n    /// @param mask_ The byte representation\\n    /// @return The swap interval\\n    // solhint-disable-next-line code-complexity\\n    function maskToInterval(bytes1 mask_) internal pure returns (uint32) {\\n        if (mask_ == 0x01) return 1 hours;\\n        if (mask_ == 0x02) return 4 hours;\\n        if (mask_ == 0x04) return 12 hours;\\n        if (mask_ == 0x08) return 1 days;\\n        if (mask_ == 0x10) return 3 days;\\n        if (mask_ == 0x20) return 1 weeks;\\n        if (mask_ == 0x40) return 2 weeks;\\n        if (mask_ == 0x80) return 30 days;\\n        revert InvalidMask();\\n    }\\n\\n    /// @notice Takes a byte representation of a set of swap intervals and returns which ones are in the set\\n    /// @dev Will always return an array of length 8, with zeros at the end if there are less than 8 intervals\\n    /// @param byte_ The byte representation\\n    /// @return intervals The swap intervals in the set\\n    function intervalsInByte(bytes1 byte_) internal pure returns (uint32[] memory intervals) {\\n        intervals = new uint32[](8);\\n        uint8 _index;\\n        bytes1 mask_ = 0x01;\\n        while (byte_ >= mask_ && mask_ > 0) {\\n            if (byte_ & mask_ != 0) intervals[_index++] = maskToInterval(mask_);\\n            mask_ <<= 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\nimport { UnauthorizedCaller, ZeroAddress } from \\\"../common/Error.sol\\\";\\n\\nabstract contract Governable is Context {\\n    address private _governance;\\n\\n    event GovernanceChanged(address indexed formerGov, address indexed newGov);\\n\\n    /**\\n     * @dev Throws if called by any account other than the governance.\\n     */\\n    modifier onlyGovernance() {\\n        if (governance() != _msgSender()) revert UnauthorizedCaller();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial governance.\\n     */\\n    constructor(address governance_) {\\n        if (governance_ == address(0)) revert ZeroAddress();\\n        _governance = governance_;\\n        emit GovernanceChanged(address(0), governance_);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current governance.\\n     */\\n    function governance() public view virtual returns (address) {\\n        return _governance;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newGov`).\\n     * Can only be called by the current governance.\\n     */\\n    function changeGovernance(address newGov) external virtual onlyGovernance {\\n        if (newGov == address(0)) revert ZeroAddress();\\n        emit GovernanceChanged(_governance, newGov);\\n        _governance = newGov;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Permitable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\nimport { ZeroAddress, InvalidPermit, InvalidPermitData, InvalidPermitSender } from \\\"./../common/Error.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"./../interfaces/IDAIPermit.sol\\\";\\n\\nimport \\\"./../interfaces/IPermit2.sol\\\";\\n\\nabstract contract Permitable {\\n    // solhint-disable-next-line var-name-mixedcase\\n    address public immutable PERMIT2;\\n\\n    constructor(address permit2_) {\\n        if (permit2_ == address(0)) revert ZeroAddress();\\n        PERMIT2 = permit2_;\\n    }\\n\\n    function _permit2Approve(address token_, bytes memory data_) internal {\\n        if(data_.length > 0) {\\n            (uint160 allowanceAmount, uint48 nonce, uint48 expiration, uint256 sigDeadline, bytes memory signature) = abi.decode(data_, (uint160, uint48, uint48, uint256, bytes));\\n            IPermit2(PERMIT2).permit(\\n                msg.sender, \\n                IPermit2.PermitSingle(\\n                    IPermit2.PermitDetails(\\n                        token_,\\n                        allowanceAmount, \\n                        expiration, \\n                        nonce\\n                    ),\\n                    address(this),\\n                    sigDeadline\\n                ),\\n                signature\\n            );\\n        }\\n    }\\n\\n    function _permit2TransferFrom(address token_, bytes memory data_, uint256 amount_) internal {\\n        (uint256 nonce, uint256 deadline, bytes memory signature) = abi.decode(data_, (uint256, uint256, bytes));\\n        IPermit2(PERMIT2).permitTransferFrom(\\n            IPermit2.PermitTransferFrom(\\n                IPermit2.TokenPermissions(token_, amount_),\\n                nonce,\\n                deadline\\n            ),\\n            IPermit2.SignatureTransferDetails(address(this), amount_),\\n            msg.sender,\\n            signature\\n        );\\n    }\\n\\n    function _permit(address token_, bytes memory data_) internal {\\n        if (data_.length > 0) {\\n            bool success;\\n            \\n            if (data_.length == 32 * 7) {\\n                (success, ) = token_.call(abi.encodePacked(IERC20Permit.permit.selector, data_));\\n            } else if (data_.length == 32 * 8) {\\n                (success, ) = token_.call(abi.encodePacked(IDAIPermit.permit.selector, data_));\\n            } else {\\n                revert InvalidPermitData();\\n            }\\n            if (!success) revert InvalidPermit();\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wNative_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeVault_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"permit2_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxNoOfSwap_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"HighFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HighPlatformFeeRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBlankSwap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInterval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMask\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNativeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNoOfSwaps\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPermit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPermitData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPosition\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReturnAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSwapAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAvailableSwap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoChanges\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWNative\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnauthorizedTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroSwappedTokens\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes1\",\"name\":\"interval\",\"type\":\"bytes1\"}],\"name\":\"BlankSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isNative\",\"type\":\"bool\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"noOfPositions\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"isNative\",\"type\":\"bool[]\"}],\"name\":\"CreatedBatched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeVault\",\"type\":\"address\"}],\"name\":\"FeeVaultUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"formerGov\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGov\",\"type\":\"address\"}],\"name\":\"GovernanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingSwap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalSwap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isNative\",\"type\":\"bool\"}],\"name\":\"Modified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"platformFeeRatio\",\"type\":\"uint256\"}],\"name\":\"PlatformFeeRatioUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"PositionOwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"SwapExecutorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"SwapExecutorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"intervals\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"swapFee\",\"type\":\"uint256[]\"}],\"name\":\"SwapFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"swapIntervals\",\"type\":\"uint32[]\"}],\"name\":\"SwapIntervalsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"swapIntervals\",\"type\":\"uint32[]\"}],\"name\":\"SwapIntervalsRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"noOfSwaps\",\"type\":\"uint256\"}],\"name\":\"SwapLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"SwapThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardRecipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swappedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"intervalsInSwap\",\"type\":\"bytes1\"}],\"indexed\":false,\"internalType\":\"struct SwapInfo[]\",\"name\":\"swapInformation\",\"type\":\"tuple[]\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unswapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isNative\",\"type\":\"bool\"}],\"name\":\"Terminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"TokensAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"TokensRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensRescued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isNative\",\"type\":\"bool\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BPS_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PLATFORM_FEE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NATIVE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accumRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"activeSwapIntervals\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts_\",\"type\":\"address[]\"}],\"name\":\"addAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens_\",\"type\":\"address[]\"}],\"name\":\"addAllowedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"executor_\",\"type\":\"address[]\"}],\"name\":\"addSwapExecutors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"swapIntervals_\",\"type\":\"uint32[]\"}],\"name\":\"addSwapIntervalsToAllowedList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowedSwapIntervals\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data_\",\"type\":\"bytes[]\"}],\"name\":\"batchCall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"maskedInterval_\",\"type\":\"bytes1\"}],\"name\":\"blankSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGov\",\"type\":\"address\"}],\"name\":\"changeGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"swapInterval\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noOfSwaps\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permit\",\"type\":\"bytes\"}],\"internalType\":\"struct CreatePositionDetails[]\",\"name\":\"details_\",\"type\":\"tuple[]\"}],\"name\":\"createBatchPositions\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"swapInterval\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noOfSwaps\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permit\",\"type\":\"bytes\"}],\"internalType\":\"struct CreatePositionDetails\",\"name\":\"details_\",\"type\":\"tuple\"}],\"name\":\"createPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"internalType\":\"struct Pair[]\",\"name\":\"pairs_\",\"type\":\"tuple[]\"}],\"name\":\"getNextSwapInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swappedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"intervalsInSwap\",\"type\":\"bytes1\"}],\"internalType\":\"struct SwapInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId_\",\"type\":\"uint256\"}],\"name\":\"getPositionDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"swapInterval\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapsExecuted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapped\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unswapped\",\"type\":\"uint256\"}],\"internalType\":\"struct PositionInfo\",\"name\":\"positionInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"interval_\",\"type\":\"uint32\"}],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxNoOfSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noOfSwaps_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isIncrease_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isNative_\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"permit_\",\"type\":\"bytes\"}],\"name\":\"modifyPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextToNextTimeThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformFeeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts_\",\"type\":\"address[]\"}],\"name\":\"removeAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens_\",\"type\":\"address[]\"}],\"name\":\"removeAllowedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"executor_\",\"type\":\"address[]\"}],\"name\":\"removeSwapExecutors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"swapIntervals_\",\"type\":\"uint32[]\"}],\"name\":\"removeSwapIntervalsFromAllowedList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"internalType\":\"struct Pair[]\",\"name\":\"pairs_\",\"type\":\"tuple[]\"}],\"name\":\"secondsUntilNextSwap\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newVault_\",\"type\":\"address\"}],\"name\":\"setFeeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"platformFeeRatio_\",\"type\":\"uint256\"}],\"name\":\"setPlatformFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"intervals_\",\"type\":\"uint32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"swapFee_\",\"type\":\"uint256[]\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapCallData\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapDetails[]\",\"name\":\"data_\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"rewardRecipient_\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swapAmountDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"name\":\"swapData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"performedSwaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextAmountToSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextToNextAmountToSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSwappedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"swapExecutors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isNative_\",\"type\":\"bool\"}],\"name\":\"terminatePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenMagnitude\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCreatedPositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferPositionOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxNoOfSwap_\",\"type\":\"uint256\"}],\"name\":\"updateMaxSwapLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nextToNextTimeThreshold_\",\"type\":\"uint256\"}],\"name\":\"updateSwapTimeThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userPositions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes1\",\"name\":\"swapIntervalMask\",\"type\":\"bytes1\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapWhereLastUpdated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalSwap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wNative\",\"outputs\":[{\"internalType\":\"contract IWNative\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isNative_\",\"type\":\"bool\"}],\"name\":\"withdrawPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DZapDCA", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000179b36e59b880a9fbb98796d993d720c8166a4dc0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270000000000000000000000000545044020ffa4611fb0f2b7ede12d13becfceca3000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba30000000000000000000000000000000000000000000000000000000000002238", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}