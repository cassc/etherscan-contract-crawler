{"SourceCode": "# @version 0.3.7\r\n\r\n\"\"\"\r\n@title Bare-bones Token implementation\r\n@notice\r\n    Based on the ERC-20 token standard as defined at\r\n    https://github.com/ethereum/EIPs/issues/20\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\n# ERC20 Token Metadata\r\nNAME: constant(String[20]) = \"Cloud AUD\"\r\nSYMBOL: constant(String[5]) = \"CAUD\"\r\nDECIMALS: constant(uint8) = 8\r\n\r\n\r\n# batchTransfer defaults for gas accounting.\r\n\r\n# Use to reserve remaining gas in case calling from contract that needs to do more\r\n# things. 30,000 gas is roughly one function call.\r\nMIN_GAS_REMAINING: constant(uint256) = 30000\r\n\r\n# Max size of batchTransfer payment batches.\r\nMAX_PAYMENTS: constant(uint256) = 200\r\n\r\n# Initial estimate of the cost for a single payment transfer.\r\nEST_GAS_PER_TRANSFER: constant(uint256) = 35600\r\n\r\n\r\n# ERC20 State Variables\r\ntotalSupply: public(uint256)\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\n\r\n\r\n# Events\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    amount: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    amount: uint256\r\n\r\nevent OwnershipTransfer:\r\n    previousOwner: indexed(address)\r\n    newOwner: indexed(address)\r\n\r\nevent BatchTransfer:\r\n    sender: indexed(address)\r\n    sender_balance: uint256\r\n    tx_count: uint256\r\n    tx_value: uint256\r\n    gas_per_tx: uint256\r\n    gas_exhausted: bool\r\n\r\nevent MinterTransfer:\r\n    previousMinter: indexed(address)\r\n    newMinter: indexed(address)\r\n\r\n\r\nowner: public(address)\r\nminter: public(address)\r\n\r\n\r\n@external\r\ndef __init__():\r\n    self.owner = msg.sender\r\n    self.minter = msg.sender\r\n    self.totalSupply = 0\r\n\r\n\r\n@pure\r\n@external\r\ndef name() -> String[20]:\r\n    return NAME\r\n\r\n\r\n@pure\r\n@external\r\ndef symbol() -> String[5]:\r\n    return SYMBOL\r\n\r\n\r\n@pure\r\n@external\r\ndef decimals() -> uint8:\r\n    return DECIMALS\r\n\r\n\r\n@external\r\ndef transfer(receiver: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfers an amount of tokens from the caller to the receiver, if caller's\r\n        token balance allows.\r\n    @param receiver The address for the tokens to be sent to.\r\n    @param amount The amount of tokens to be transferred, in raw integer format.\r\n    \"\"\"\r\n    assert receiver != empty(address), \"Cannot transfer to null address.\"\r\n    self.balanceOf[msg.sender] -= amount\r\n    self.balanceOf[receiver] += amount\r\n\r\n    log Transfer(msg.sender, receiver, amount)\r\n    return True\r\n\r\n\r\n# Payment structure - compose an array of no more than MAX_PAYMENTS of these.\r\n# Do not allow any receiver addresses to be 0 address as burns are not allowed.\r\nstruct Payment:\r\n    receiver: address\r\n    amount: uint256\r\n\r\n\r\n@external\r\ndef batchTransfer(\r\n    payments: DynArray[Payment, MAX_PAYMENTS],\r\n    min_gas_remaining: uint256 = MIN_GAS_REMAINING\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Saves gas fees by batching multiple transfers from a single\r\n        address into one tx. Performs gas accounting to safely execute\r\n        as many txs in the batch as possible without hitting gas exhaustion\r\n        forcing a tx revert.\r\n\r\n        Publishes one Transfer event per payment processed.\r\n\r\n        Publishes one BatchTransfer event at the end reporting the sending\r\n        wallet address, its remaining balance, how many payments were transferred,\r\n        the total value, the max per transfer gas, and whether or not the batch had\r\n        left over payments due to gas exhaustion.\r\n\r\n    @param payments A DynArray of payments. See struct above.\r\n\r\n    @param min_gas_remaining In order to support gas-safe calls from other smart\r\n        contracts, this function takes a min_gas_remaining parameter so batchTransfer's\r\n        gas accounting will ensure at least that qty of gas remains for any follow on\r\n        functions that the calling contract may need to finish its own processing.\r\n        This saves client code from having to do lots of complex and non-deterministic\r\n        gas accounting of its own before sending batches.\r\n\r\n    @return a uint of how many transactions were sent. batchTransfer will attempt to\r\n        make as many payments from the batch as possible with the gas budget available.\r\n        It is up to the caller to manage resubmitting any payments that did not get\r\n        processed in the initial batch.\r\n    \"\"\"\r\n    pay_count: uint256 = 0\r\n    pay_value: uint256 = 0\r\n    per_transfer_cost: uint256 = EST_GAS_PER_TRANSFER\r\n    gas_remaining: uint256 = msg.gas\r\n    gas_exhausted: bool = False\r\n\r\n    sender_balance: uint256 = self.balanceOf[msg.sender]\r\n\r\n    for payment in payments:\r\n        # Break if we don't have sufficient gas.\r\n        if msg.gas < (min_gas_remaining + per_transfer_cost):\r\n            gas_exhausted = True\r\n            break\r\n\r\n        # We're complete if any receiver is a zero address.\r\n        if payment.receiver == empty(address):\r\n            break\r\n\r\n        # End if insufficient funds remaining during the batch.\r\n        if sender_balance < payment.amount:\r\n            break\r\n\r\n        # If sender & receiver are different addresses then do the math.\r\n        if msg.sender != payment.receiver:\r\n            sender_balance -= payment.amount\r\n            self.balanceOf[payment.receiver] += payment.amount\r\n\r\n        # Send one Transfer event per successful payment.\r\n        log Transfer(msg.sender, payment.receiver, payment.amount)\r\n\r\n        pay_count += 1\r\n        pay_value += payment.amount\r\n\r\n        if per_transfer_cost == EST_GAS_PER_TRANSFER:\r\n            per_transfer_cost = gas_remaining - msg.gas\r\n        if per_transfer_cost < gas_remaining - msg.gas:\r\n            per_transfer_cost = gas_remaining - msg.gas\r\n        gas_remaining = msg.gas\r\n\r\n    if pay_value > 0:\r\n        self.balanceOf[msg.sender] = sender_balance\r\n\r\n    # Report the final disposition for this Payment batch.\r\n    log BatchTransfer(\r\n        msg.sender,\r\n        self.balanceOf[msg.sender],\r\n        pay_count,\r\n        pay_value,\r\n        per_transfer_cost,\r\n        gas_exhausted\r\n    )\r\n\r\n    return pay_count\r\n\r\n\r\n@external\r\ndef transferFrom(sender: address, receiver: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice\r\n        Similar to transfer, but used for allowing contracts to send tokens on your\r\n        behalf. For example a decentralized exchange would make use of this method,\r\n        once given authorization via the approve method.\r\n    \"\"\"\r\n    assert receiver != empty(address), \"Cannot transfer to null address.\"\r\n    self.allowance[sender][msg.sender] -= amount\r\n    self.balanceOf[sender] -= amount\r\n    self.balanceOf[receiver] += amount\r\n\r\n    log Transfer(sender, receiver, amount)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(spender: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    @param spender The address that will execute on owner behalf.\r\n    @param amount The amount of token to be transfered.\r\n    \"\"\"\r\n    self.allowance[msg.sender][spender] = amount\r\n\r\n    log Approval(msg.sender, spender, amount)\r\n    return True\r\n\r\n\r\n@external\r\ndef burn(amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Burns the supplied amount of tokens from the sender wallet.\r\n    @param amount The amount of token to be burned.\r\n    @return A boolean that indicates if the operation was successful.\r\n    \"\"\"\r\n    assert self.balanceOf[msg.sender] >= amount, \"Burn amount exceeds balance.\"\r\n\r\n    self.balanceOf[msg.sender] -= amount\r\n    self.totalSupply -= amount\r\n\r\n    log Transfer(msg.sender, empty(address), amount)\r\n    return True\r\n\r\n\r\n@external\r\ndef mint(receiver: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Function to mint new tokens.\r\n    @param receiver The address that will receive the minted tokens.\r\n    @param amount The amount of tokens to mint.\r\n    @return A boolean that indicates if the operation was successful.\r\n    \"\"\"\r\n    assert msg.sender == self.minter, \"Access denied.\"\r\n    assert receiver != empty(address), \"Cannot mint to null address.\"\r\n\r\n    self.totalSupply += amount\r\n    self.balanceOf[receiver] += amount\r\n\r\n    log Transfer(empty(address), receiver, amount)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferOwnership(target: address) -> bool:\r\n    \"\"\"\r\n    @notice Function to transfer ownership from one address to another.\r\n    @param target Address of the new owner.\r\n    @return A boolean that indicates if the operation was successful.\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"Access denied.\"\r\n    assert target != empty(address), \"Cannot add null address as owner.\"\r\n\r\n    self.owner = target\r\n\r\n    log OwnershipTransfer(msg.sender, target)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferMinter(target: address) -> bool:\r\n    \"\"\"\r\n    @notice Function to transfer minter role from one address to another.\r\n    @param target Address of the new minter.\r\n    @return A boolean that indicates if the operation was successful.\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"Access denied.\"\r\n    assert target != empty(address), \"Cannot add null address as minter.\"\r\n\r\n    previous_minter: address = self.minter\r\n    self.minter = target\r\n\r\n    log MinterTransfer(previous_minter, target)\r\n    return True", "ABI": "[{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OwnershipTransfer\",\"inputs\":[{\"name\":\"previousOwner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"newOwner\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BatchTransfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sender_balance\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tx_count\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tx_value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"gas_per_tx\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"gas_exhausted\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"MinterTransfer\",\"inputs\":[{\"name\":\"previousMinter\",\"type\":\"address\",\"indexed\":true},{\"name\":\"newMinter\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"batchTransfer\",\"inputs\":[{\"name\":\"payments\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}]}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"batchTransfer\",\"inputs\":[{\"name\":\"payments\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}]},{\"name\":\"min_gas_remaining\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferOwnership\",\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferMinter\",\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}