{"SourceCode": "// File: @solidstate/contracts/proxy/diamond/writable/IDiamondWritableInternal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IDiamondWritableInternal {\r\n    enum FacetCutAction {\r\n        ADD,\r\n        REPLACE,\r\n        REMOVE\r\n    }\r\n\r\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\r\n\r\n    error DiamondWritable__InvalidInitializationParameters();\r\n    error DiamondWritable__RemoveTargetNotZeroAddress();\r\n    error DiamondWritable__ReplaceTargetIsIdentical();\r\n    error DiamondWritable__SelectorAlreadyAdded();\r\n    error DiamondWritable__SelectorIsImmutable();\r\n    error DiamondWritable__SelectorNotFound();\r\n    error DiamondWritable__SelectorNotSpecified();\r\n    error DiamondWritable__TargetHasNoCode();\r\n\r\n    struct FacetCut {\r\n        address target;\r\n        FacetCutAction action;\r\n        bytes4[] selectors;\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/writable/IDiamondWritable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n/**\r\n * @title Diamond proxy upgrade interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\r\n */\r\ninterface IDiamondWritable is IDiamondWritableInternal {\r\n    /**\r\n     * @notice update diamond facets and optionally execute arbitrary initialization function\r\n     * @param facetCuts array of structured Diamond facet update data\r\n     * @param target optional target of initialization delegatecall\r\n     * @param data optional initialization function call data\r\n     */\r\n    function diamondCut(\r\n        FacetCut[] calldata facetCuts,\r\n        address target,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title Diamond proxy introspection interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\r\n */\r\ninterface IDiamondReadable {\r\n    struct Facet {\r\n        address target;\r\n        bytes4[] selectors;\r\n    }\r\n\r\n    /**\r\n     * @notice get all facets and their selectors\r\n     * @return diamondFacets array of structured facet data\r\n     */\r\n    function facets() external view returns (Facet[] memory diamondFacets);\r\n\r\n    /**\r\n     * @notice get all selectors for given facet address\r\n     * @param facet address of facet to query\r\n     * @return selectors array of function selectors\r\n     */\r\n    function facetFunctionSelectors(\r\n        address facet\r\n    ) external view returns (bytes4[] memory selectors);\r\n\r\n    /**\r\n     * @notice get addresses of all facets used by diamond\r\n     * @return addresses array of facet addresses\r\n     */\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory addresses);\r\n\r\n    /**\r\n     * @notice get the address of the facet associated with given selector\r\n     * @param selector function selector to query\r\n     * @return facet facet address (zero address if not found)\r\n     */\r\n    function facetAddress(\r\n        bytes4 selector\r\n    ) external view returns (address facet);\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\r\n */\r\nlibrary DiamondBaseStorage {\r\n    struct Layout {\r\n        // function selector => (facet address, selector slot position)\r\n        mapping(bytes4 => bytes32) facets;\r\n        // total number of selectors registered\r\n        uint16 selectorCount;\r\n        // array of selector slots with 8 selectors per slot\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        address fallbackAddress;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.DiamondBase');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n/**\r\n * @title EIP-2535 \"Diamond\" proxy introspection contract\r\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\r\n */\r\nabstract contract DiamondReadable is IDiamondReadable {\r\n    /**\r\n     * @inheritdoc IDiamondReadable\r\n     */\r\n    function facets() external view returns (Facet[] memory diamondFacets) {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        diamondFacets = new Facet[](l.selectorCount);\r\n\r\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\r\n            bytes32 slot = l.selectorSlots[slotIndex];\r\n\r\n            for (\r\n                uint256 selectorSlotIndex;\r\n                selectorSlotIndex < 8;\r\n                selectorSlotIndex++\r\n            ) {\r\n                selectorIndex++;\r\n\r\n                if (selectorIndex > l.selectorCount) {\r\n                    break;\r\n                }\r\n\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(l.facets[selector]));\r\n\r\n                bool continueLoop;\r\n\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (diamondFacets[facetIndex].target == facet) {\r\n                        diamondFacets[facetIndex].selectors[\r\n                            numFacetSelectors[facetIndex]\r\n                        ] = selector;\r\n                        // probably will never have more than 256 functions from one facet contract\r\n                        require(numFacetSelectors[facetIndex] < 255);\r\n                        numFacetSelectors[facetIndex]++;\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (continueLoop) {\r\n                    continue;\r\n                }\r\n\r\n                diamondFacets[numFacets].target = facet;\r\n                diamondFacets[numFacets].selectors = new bytes4[](\r\n                    l.selectorCount\r\n                );\r\n                diamondFacets[numFacets].selectors[0] = selector;\r\n                numFacetSelectors[numFacets] = 1;\r\n                numFacets++;\r\n            }\r\n        }\r\n\r\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n            uint256 numSelectors = numFacetSelectors[facetIndex];\r\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\r\n\r\n            // setting the number of selectors\r\n            assembly {\r\n                mstore(selectors, numSelectors)\r\n            }\r\n        }\r\n\r\n        // setting the number of facets\r\n        assembly {\r\n            mstore(diamondFacets, numFacets)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondReadable\r\n     */\r\n    function facetFunctionSelectors(\r\n        address facet\r\n    ) external view returns (bytes4[] memory selectors) {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        selectors = new bytes4[](l.selectorCount);\r\n\r\n        uint256 numSelectors;\r\n        uint256 selectorIndex;\r\n\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\r\n            bytes32 slot = l.selectorSlots[slotIndex];\r\n\r\n            for (\r\n                uint256 selectorSlotIndex;\r\n                selectorSlotIndex < 8;\r\n                selectorSlotIndex++\r\n            ) {\r\n                selectorIndex++;\r\n\r\n                if (selectorIndex > l.selectorCount) {\r\n                    break;\r\n                }\r\n\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n\r\n                if (facet == address(bytes20(l.facets[selector]))) {\r\n                    selectors[numSelectors] = selector;\r\n                    numSelectors++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // set the number of selectors in the array\r\n        assembly {\r\n            mstore(selectors, numSelectors)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondReadable\r\n     */\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory addresses)\r\n    {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        addresses = new address[](l.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n\r\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\r\n            bytes32 slot = l.selectorSlots[slotIndex];\r\n\r\n            for (\r\n                uint256 selectorSlotIndex;\r\n                selectorSlotIndex < 8;\r\n                selectorSlotIndex++\r\n            ) {\r\n                selectorIndex++;\r\n\r\n                if (selectorIndex > l.selectorCount) {\r\n                    break;\r\n                }\r\n\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(l.facets[selector]));\r\n\r\n                bool continueLoop;\r\n\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facet == addresses[facetIndex]) {\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (continueLoop) {\r\n                    continue;\r\n                }\r\n\r\n                addresses[numFacets] = facet;\r\n                numFacets++;\r\n            }\r\n        }\r\n\r\n        // set the number of facet addresses in the array\r\n        assembly {\r\n            mstore(addresses, numFacets)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondReadable\r\n     */\r\n    function facetAddress(\r\n        bytes4 selector\r\n    ) external view returns (address facet) {\r\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/IProxy.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IProxy {\r\n    error Proxy__ImplementationIsNotContract();\r\n\r\n    fallback() external payable;\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/base/IDiamondBase.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\ninterface IDiamondBase is IProxy {}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/fallback/IDiamondFallback.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\ninterface IDiamondFallback is IDiamondBase {\r\n    /**\r\n     * @notice query the address of the fallback implementation\r\n     * @return fallbackAddress address of fallback implementation\r\n     */\r\n    function getFallbackAddress()\r\n        external\r\n        view\r\n        returns (address fallbackAddress);\r\n\r\n    /**\r\n     * @notice set the address of the fallback implementation\r\n     * @param fallbackAddress address of fallback implementation\r\n     */\r\n    function setFallbackAddress(address fallbackAddress) external;\r\n}\r\n\r\n// File: @solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary ERC165BaseStorage {\r\n    struct Layout {\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.ERC165Base');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/interfaces/IERC165Internal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title ERC165 interface registration interface\r\n */\r\ninterface IERC165Internal {\r\n\r\n}\r\n\r\n// File: @solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC165BaseInternal is IERC165Internal {\r\n    error ERC165Base__InvalidInterfaceId();\r\n}\r\n\r\n// File: @solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n/**\r\n * @title ERC165 implementation\r\n */\r\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\r\n    /**\r\n     * @notice indicates whether an interface is already supported based on the interfaceId\r\n     * @param interfaceId id of interface to check\r\n     * @return bool indicating whether interface is supported\r\n     */\r\n    function _supportsInterface(\r\n        bytes4 interfaceId\r\n    ) internal view virtual returns (bool) {\r\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @notice sets status of interface support\r\n     * @param interfaceId id of interface to set status for\r\n     * @param status boolean indicating whether interface will be set as supported\r\n     */\r\n    function _setSupportsInterface(\r\n        bytes4 interfaceId,\r\n        bool status\r\n    ) internal virtual {\r\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\r\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/interfaces/IERC165.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n/**\r\n * @title ERC165 interface registration interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 is IERC165Internal {\r\n    /**\r\n     * @notice query whether contract has registered support for given interface\r\n     * @param interfaceId interface id\r\n     * @return bool whether interface is supported\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @solidstate/contracts/introspection/ERC165/base/IERC165Base.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\r\n\r\n// File: @solidstate/contracts/introspection/ERC165/base/ERC165Base.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC165 implementation\r\n */\r\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\r\n    /**\r\n     * @inheritdoc IERC165\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return _supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/access/ownable/SafeOwnableStorage.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary SafeOwnableStorage {\r\n    struct Layout {\r\n        address nomineeOwner;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.SafeOwnable');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/access/ownable/OwnableStorage.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary OwnableStorage {\r\n    struct Layout {\r\n        address owner;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.Ownable');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/utils/UintUtils.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title utility functions for uint256 operations\r\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\r\n */\r\nlibrary UintUtils {\r\n    error UintUtils__InsufficientHexLength();\r\n\r\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\r\n\r\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\r\n        return b < 0 ? sub(a, -b) : a + uint256(b);\r\n    }\r\n\r\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\r\n        return b < 0 ? add(a, -b) : a - uint256(b);\r\n    }\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return '0';\r\n        }\r\n\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n\r\n        bytes memory buffer = new bytes(digits);\r\n\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return '0x00';\r\n        }\r\n\r\n        uint256 length = 0;\r\n\r\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\r\n            unchecked {\r\n                length++;\r\n            }\r\n        }\r\n\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    function toHexString(\r\n        uint256 value,\r\n        uint256 length\r\n    ) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = '0';\r\n        buffer[1] = 'x';\r\n\r\n        unchecked {\r\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\r\n                value >>= 4;\r\n            }\r\n        }\r\n\r\n        if (value != 0) revert UintUtils__InsufficientHexLength();\r\n\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/utils/AddressUtils.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\nlibrary AddressUtils {\r\n    using UintUtils for uint256;\r\n\r\n    error AddressUtils__InsufficientBalance();\r\n    error AddressUtils__NotContract();\r\n    error AddressUtils__SendValueFailed();\r\n\r\n    function toString(address account) internal pure returns (string memory) {\r\n        return uint256(uint160(account)).toHexString(20);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable account, uint256 amount) internal {\r\n        (bool success, ) = account.call{ value: amount }('');\r\n        if (!success) revert AddressUtils__SendValueFailed();\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCall(target, data, 'AddressUtils: failed low-level call');\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory error\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, error);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                'AddressUtils: failed low-level call with value'\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory error\r\n    ) internal returns (bytes memory) {\r\n        if (value > address(this).balance)\r\n            revert AddressUtils__InsufficientBalance();\r\n        return _functionCallWithValue(target, data, value, error);\r\n    }\r\n\r\n    /**\r\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\r\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\r\n     * @param target recipient of call\r\n     * @param gasAmount gas allowance for call\r\n     * @param value native token value to include in call\r\n     * @param maxCopy maximum number of bytes to copy from return data\r\n     * @param data encoded call data\r\n     * @return success whether call is successful\r\n     * @return returnData copied return data\r\n     */\r\n    function excessivelySafeCall(\r\n        address target,\r\n        uint256 gasAmount,\r\n        uint256 value,\r\n        uint16 maxCopy,\r\n        bytes memory data\r\n    ) internal returns (bool success, bytes memory returnData) {\r\n        returnData = new bytes(maxCopy);\r\n\r\n        assembly {\r\n            // execute external call via assembly to avoid automatic copying of return data\r\n            success := call(\r\n                gasAmount,\r\n                target,\r\n                value,\r\n                add(data, 0x20),\r\n                mload(data),\r\n                0,\r\n                0\r\n            )\r\n\r\n            // determine whether to limit amount of data to copy\r\n            let toCopy := returndatasize()\r\n\r\n            if gt(toCopy, maxCopy) {\r\n                toCopy := maxCopy\r\n            }\r\n\r\n            // store the length of the copied bytes\r\n            mstore(returnData, toCopy)\r\n\r\n            // copy the bytes from returndata[0:toCopy]\r\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\r\n        }\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory error\r\n    ) private returns (bytes memory) {\r\n        if (!isContract(target)) revert AddressUtils__NotContract();\r\n\r\n        (bool success, bytes memory returnData) = target.call{ value: value }(\r\n            data\r\n        );\r\n\r\n        if (success) {\r\n            return returnData;\r\n        } else if (returnData.length > 0) {\r\n            assembly {\r\n                let returnData_size := mload(returnData)\r\n                revert(add(32, returnData), returnData_size)\r\n            }\r\n        } else {\r\n            revert(error);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\nabstract contract DiamondWritableInternal is IDiamondWritableInternal {\r\n    using AddressUtils for address;\r\n\r\n    bytes32 private constant CLEAR_ADDRESS_MASK =\r\n        bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 private constant CLEAR_SELECTOR_MASK =\r\n        bytes32(uint256(0xffffffff << 224));\r\n\r\n    /**\r\n     * @notice update functions callable on Diamond proxy\r\n     * @param facetCuts array of structured Diamond facet update data\r\n     * @param target optional recipient of initialization delegatecall\r\n     * @param data optional initialization call data\r\n     */\r\n    function _diamondCut(\r\n        FacetCut[] memory facetCuts,\r\n        address target,\r\n        bytes memory data\r\n    ) internal {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        unchecked {\r\n            uint256 originalSelectorCount = l.selectorCount;\r\n            uint256 selectorCount = originalSelectorCount;\r\n            bytes32 selectorSlot;\r\n\r\n            // Check if last selector slot is not full\r\n            if (selectorCount & 7 > 0) {\r\n                // get last selectorSlot\r\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\r\n            }\r\n\r\n            for (uint256 i; i < facetCuts.length; i++) {\r\n                FacetCut memory facetCut = facetCuts[i];\r\n                FacetCutAction action = facetCut.action;\r\n\r\n                if (facetCut.selectors.length == 0)\r\n                    revert DiamondWritable__SelectorNotSpecified();\r\n\r\n                if (action == FacetCutAction.ADD) {\r\n                    (selectorCount, selectorSlot) = _addFacetSelectors(\r\n                        l,\r\n                        selectorCount,\r\n                        selectorSlot,\r\n                        facetCut\r\n                    );\r\n                } else if (action == FacetCutAction.REPLACE) {\r\n                    _replaceFacetSelectors(l, facetCut);\r\n                } else if (action == FacetCutAction.REMOVE) {\r\n                    (selectorCount, selectorSlot) = _removeFacetSelectors(\r\n                        l,\r\n                        selectorCount,\r\n                        selectorSlot,\r\n                        facetCut\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (selectorCount != originalSelectorCount) {\r\n                l.selectorCount = uint16(selectorCount);\r\n            }\r\n\r\n            // If last selector slot is not full\r\n            if (selectorCount & 7 > 0) {\r\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n            }\r\n\r\n            emit DiamondCut(facetCuts, target, data);\r\n            _initialize(target, data);\r\n        }\r\n    }\r\n\r\n    function _addFacetSelectors(\r\n        DiamondBaseStorage.Layout storage l,\r\n        uint256 selectorCount,\r\n        bytes32 selectorSlot,\r\n        FacetCut memory facetCut\r\n    ) internal returns (uint256, bytes32) {\r\n        unchecked {\r\n            if (\r\n                facetCut.target != address(this) &&\r\n                !facetCut.target.isContract()\r\n            ) revert DiamondWritable__TargetHasNoCode();\r\n\r\n            for (uint256 i; i < facetCut.selectors.length; i++) {\r\n                bytes4 selector = facetCut.selectors[i];\r\n                bytes32 oldFacet = l.facets[selector];\r\n\r\n                if (address(bytes20(oldFacet)) != address(0))\r\n                    revert DiamondWritable__SelectorAlreadyAdded();\r\n\r\n                // add facet for selector\r\n                l.facets[selector] =\r\n                    bytes20(facetCut.target) |\r\n                    bytes32(selectorCount);\r\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\r\n\r\n                // clear selector position in slot and add selector\r\n                selectorSlot =\r\n                    (selectorSlot &\r\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\r\n                    (bytes32(selector) >> selectorInSlotPosition);\r\n\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n                    selectorSlot = 0;\r\n                }\r\n\r\n                selectorCount++;\r\n            }\r\n\r\n            return (selectorCount, selectorSlot);\r\n        }\r\n    }\r\n\r\n    function _removeFacetSelectors(\r\n        DiamondBaseStorage.Layout storage l,\r\n        uint256 selectorCount,\r\n        bytes32 selectorSlot,\r\n        FacetCut memory facetCut\r\n    ) internal returns (uint256, bytes32) {\r\n        unchecked {\r\n            if (facetCut.target != address(0))\r\n                revert DiamondWritable__RemoveTargetNotZeroAddress();\r\n\r\n            uint256 selectorSlotCount = selectorCount >> 3;\r\n            uint256 selectorInSlotIndex = selectorCount & 7;\r\n\r\n            for (uint256 i; i < facetCut.selectors.length; i++) {\r\n                bytes4 selector = facetCut.selectors[i];\r\n                bytes32 oldFacet = l.facets[selector];\r\n\r\n                if (address(bytes20(oldFacet)) == address(0))\r\n                    revert DiamondWritable__SelectorNotFound();\r\n\r\n                if (address(bytes20(oldFacet)) == address(this))\r\n                    revert DiamondWritable__SelectorIsImmutable();\r\n\r\n                if (selectorSlot == 0) {\r\n                    selectorSlotCount--;\r\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    // replace selector with last selector in l.facets\r\n                    lastSelector = bytes4(\r\n                        selectorSlot << (selectorInSlotIndex << 5)\r\n                    );\r\n\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        l.facets[lastSelector] =\r\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                            bytes20(l.facets[lastSelector]);\r\n                    }\r\n\r\n                    delete l.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = l.selectorSlots[\r\n                        oldSelectorsSlotCount\r\n                    ];\r\n\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n\r\n                    // update storage with the modified slot\r\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    selectorSlot =\r\n                        (selectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete l.selectorSlots[selectorSlotCount];\r\n                    selectorSlot = 0;\r\n                }\r\n            }\r\n\r\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\r\n\r\n            return (selectorCount, selectorSlot);\r\n        }\r\n    }\r\n\r\n    function _replaceFacetSelectors(\r\n        DiamondBaseStorage.Layout storage l,\r\n        FacetCut memory facetCut\r\n    ) internal {\r\n        unchecked {\r\n            if (!facetCut.target.isContract())\r\n                revert DiamondWritable__TargetHasNoCode();\r\n\r\n            for (uint256 i; i < facetCut.selectors.length; i++) {\r\n                bytes4 selector = facetCut.selectors[i];\r\n                bytes32 oldFacet = l.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n\r\n                if (oldFacetAddress == address(0))\r\n                    revert DiamondWritable__SelectorNotFound();\r\n                if (oldFacetAddress == address(this))\r\n                    revert DiamondWritable__SelectorIsImmutable();\r\n                if (oldFacetAddress == facetCut.target)\r\n                    revert DiamondWritable__ReplaceTargetIsIdentical();\r\n\r\n                // replace old facet address\r\n                l.facets[selector] =\r\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                    bytes20(facetCut.target);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _initialize(address target, bytes memory data) private {\r\n        if ((target == address(0)) != (data.length == 0))\r\n            revert DiamondWritable__InvalidInitializationParameters();\r\n\r\n        if (target != address(0)) {\r\n            if (target != address(this)) {\r\n                if (!target.isContract())\r\n                    revert DiamondWritable__TargetHasNoCode();\r\n            }\r\n\r\n            (bool success, ) = target.delegatecall(data);\r\n\r\n            if (!success) {\r\n                assembly {\r\n                    returndatacopy(0, 0, returndatasize())\r\n                    revert(0, returndatasize())\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/Proxy.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n/**\r\n * @title Base proxy contract\r\n */\r\nabstract contract Proxy is IProxy {\r\n    using AddressUtils for address;\r\n\r\n    /**\r\n     * @notice delegate all calls to implementation contract\r\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\r\n     * @dev memory location in use by assembly may be unsafe in other contexts\r\n     */\r\n    fallback() external payable virtual {\r\n        address implementation = _getImplementation();\r\n\r\n        if (!implementation.isContract())\r\n            revert Proxy__ImplementationIsNotContract();\r\n\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(\r\n                gas(),\r\n                implementation,\r\n                0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice get logic implementation address\r\n     * @return implementation address\r\n     */\r\n    function _getImplementation() internal virtual returns (address);\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/base/DiamondBase.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title EIP-2535 \"Diamond\" proxy base contract\r\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\r\n */\r\nabstract contract DiamondBase is IDiamondBase, Proxy {\r\n    /**\r\n     * @inheritdoc Proxy\r\n     */\r\n    function _getImplementation()\r\n        internal\r\n        view\r\n        virtual\r\n        override\r\n        returns (address implementation)\r\n    {\r\n        // inline storage layout retrieval uses less gas\r\n        DiamondBaseStorage.Layout storage l;\r\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n\r\n        implementation = address(bytes20(l.facets[msg.sig]));\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/interfaces/IERC173Internal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title Partial ERC173 interface needed by internal functions\r\n */\r\ninterface IERC173Internal {\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n}\r\n\r\n// File: @solidstate/contracts/access/ownable/IOwnableInternal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\ninterface IOwnableInternal is IERC173Internal {\r\n    error Ownable__NotOwner();\r\n    error Ownable__NotTransitiveOwner();\r\n}\r\n\r\n// File: @solidstate/contracts/access/ownable/ISafeOwnableInternal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\ninterface ISafeOwnableInternal is IOwnableInternal {\r\n    error SafeOwnable__NotNomineeOwner();\r\n}\r\n\r\n// File: @solidstate/contracts/interfaces/IERC173.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n/**\r\n * @title Contract ownership standard interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-173\r\n */\r\ninterface IERC173 is IERC173Internal {\r\n    /**\r\n     * @notice get the ERC173 contract owner\r\n     * @return contract owner\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * @notice transfer contract ownership to new account\r\n     * @param account address of new owner\r\n     */\r\n    function transferOwnership(address account) external;\r\n}\r\n\r\n// File: @solidstate/contracts/access/ownable/OwnableInternal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\nabstract contract OwnableInternal is IOwnableInternal {\r\n    using AddressUtils for address;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\r\n        _;\r\n    }\r\n\r\n    modifier onlyTransitiveOwner() {\r\n        if (msg.sender != _transitiveOwner())\r\n            revert Ownable__NotTransitiveOwner();\r\n        _;\r\n    }\r\n\r\n    function _owner() internal view virtual returns (address) {\r\n        return OwnableStorage.layout().owner;\r\n    }\r\n\r\n    function _transitiveOwner() internal view virtual returns (address owner) {\r\n        owner = _owner();\r\n\r\n        while (owner.isContract()) {\r\n            try IERC173(owner).owner() returns (address transitiveOwner) {\r\n                owner = transitiveOwner;\r\n            } catch {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _transferOwnership(address account) internal virtual {\r\n        _setOwner(account);\r\n    }\r\n\r\n    function _setOwner(address account) internal virtual {\r\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\r\n        emit OwnershipTransferred(l.owner, account);\r\n        l.owner = account;\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title EIP-2535 \"Diamond\" proxy update contract\r\n */\r\nabstract contract DiamondWritable is\r\n    IDiamondWritable,\r\n    DiamondWritableInternal,\r\n    OwnableInternal\r\n{\r\n    /**\r\n     * @inheritdoc IDiamondWritable\r\n     */\r\n    function diamondCut(\r\n        FacetCut[] calldata facetCuts,\r\n        address target,\r\n        bytes calldata data\r\n    ) external onlyOwner {\r\n        _diamondCut(facetCuts, target, data);\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/fallback/DiamondFallback.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Fallback feature for EIP-2535 \"Diamond\" proxy\r\n */\r\nabstract contract DiamondFallback is\r\n    IDiamondFallback,\r\n    OwnableInternal,\r\n    DiamondBase\r\n{\r\n    /**\r\n     * @inheritdoc IDiamondFallback\r\n     */\r\n    function getFallbackAddress()\r\n        external\r\n        view\r\n        returns (address fallbackAddress)\r\n    {\r\n        fallbackAddress = _getFallbackAddress();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondFallback\r\n     */\r\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\r\n        _setFallbackAddress(fallbackAddress);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc DiamondBase\r\n     * @notice query custom fallback address is no implementation is found\r\n     */\r\n    function _getImplementation()\r\n        internal\r\n        view\r\n        virtual\r\n        override\r\n        returns (address implementation)\r\n    {\r\n        implementation = super._getImplementation();\r\n\r\n        if (implementation == address(0)) {\r\n            implementation = _getFallbackAddress();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice query the address of the fallback implementation\r\n     * @return fallbackAddress address of fallback implementation\r\n     */\r\n    function _getFallbackAddress()\r\n        internal\r\n        view\r\n        virtual\r\n        returns (address fallbackAddress)\r\n    {\r\n        fallbackAddress = DiamondBaseStorage.layout().fallbackAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice set the address of the fallback implementation\r\n     * @param fallbackAddress address of fallback implementation\r\n     */\r\n    function _setFallbackAddress(address fallbackAddress) internal virtual {\r\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/access/ownable/SafeOwnableInternal.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\nabstract contract SafeOwnableInternal is ISafeOwnableInternal, OwnableInternal {\r\n    modifier onlyNomineeOwner() {\r\n        if (msg.sender != _nomineeOwner())\r\n            revert SafeOwnable__NotNomineeOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice get the nominated owner who has permission to call acceptOwnership\r\n     */\r\n    function _nomineeOwner() internal view virtual returns (address) {\r\n        return SafeOwnableStorage.layout().nomineeOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice accept transfer of contract ownership\r\n     */\r\n    function _acceptOwnership() internal virtual {\r\n        _setOwner(msg.sender);\r\n        delete SafeOwnableStorage.layout().nomineeOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice grant permission to given address to claim contract ownership\r\n     */\r\n    function _transferOwnership(address account) internal virtual override {\r\n        _setNomineeOwner(account);\r\n    }\r\n\r\n    /**\r\n     * @notice set nominee owner\r\n     */\r\n    function _setNomineeOwner(address account) internal virtual {\r\n        SafeOwnableStorage.layout().nomineeOwner = account;\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/access/ownable/IOwnable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\ninterface IOwnable is IOwnableInternal, IERC173 {}\r\n\r\n// File: @solidstate/contracts/access/ownable/ISafeOwnable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\ninterface ISafeOwnable is ISafeOwnableInternal, IOwnable {\r\n    /**\r\n     * @notice get the nominated owner who has permission to call acceptOwnership\r\n     */\r\n    function nomineeOwner() external view returns (address);\r\n\r\n    /**\r\n     * @notice accept transfer of contract ownership\r\n     */\r\n    function acceptOwnership() external;\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ISolidStateDiamond is\r\n    IDiamondBase,\r\n    IDiamondFallback,\r\n    IDiamondReadable,\r\n    IDiamondWritable,\r\n    ISafeOwnable,\r\n    IERC165\r\n{\r\n    receive() external payable;\r\n}\r\n\r\n// File: @solidstate/contracts/access/ownable/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ownership access control based on ERC173\r\n */\r\nabstract contract Ownable is IOwnable, OwnableInternal {\r\n    /**\r\n     * @inheritdoc IERC173\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IERC173\r\n     */\r\n    function transferOwnership(address account) public virtual onlyOwner {\r\n        _transferOwnership(account);\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/access/ownable/SafeOwnable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ownership access control based on ERC173 with ownership transfer safety check\r\n */\r\nabstract contract SafeOwnable is ISafeOwnable, Ownable, SafeOwnableInternal {\r\n    /**\r\n     * @inheritdoc ISafeOwnable\r\n     */\r\n    function nomineeOwner() public view virtual returns (address) {\r\n        return _nomineeOwner();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ISafeOwnable\r\n     */\r\n    function acceptOwnership() public virtual onlyNomineeOwner {\r\n        _acceptOwnership();\r\n    }\r\n\r\n    function _transferOwnership(\r\n        address account\r\n    ) internal virtual override(OwnableInternal, SafeOwnableInternal) {\r\n        super._transferOwnership(account);\r\n    }\r\n}\r\n\r\n// File: @solidstate/contracts/proxy/diamond/SolidStateDiamond.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SolidState \"Diamond\" proxy reference implementation\r\n */\r\nabstract contract SolidStateDiamond is\r\n    ISolidStateDiamond,\r\n    DiamondBase,\r\n    DiamondFallback,\r\n    DiamondReadable,\r\n    DiamondWritable,\r\n    SafeOwnable,\r\n    ERC165Base\r\n{\r\n    constructor() {\r\n        bytes4[] memory selectors = new bytes4[](12);\r\n        uint256 selectorIndex;\r\n\r\n        // register DiamondFallback\r\n\r\n        selectors[selectorIndex++] = IDiamondFallback\r\n            .getFallbackAddress\r\n            .selector;\r\n        selectors[selectorIndex++] = IDiamondFallback\r\n            .setFallbackAddress\r\n            .selector;\r\n\r\n        _setSupportsInterface(type(IDiamondFallback).interfaceId, true);\r\n\r\n        // register DiamondWritable\r\n\r\n        selectors[selectorIndex++] = IDiamondWritable.diamondCut.selector;\r\n\r\n        _setSupportsInterface(type(IDiamondWritable).interfaceId, true);\r\n\r\n        // register DiamondReadable\r\n\r\n        selectors[selectorIndex++] = IDiamondReadable.facets.selector;\r\n        selectors[selectorIndex++] = IDiamondReadable\r\n            .facetFunctionSelectors\r\n            .selector;\r\n        selectors[selectorIndex++] = IDiamondReadable.facetAddresses.selector;\r\n        selectors[selectorIndex++] = IDiamondReadable.facetAddress.selector;\r\n\r\n        _setSupportsInterface(type(IDiamondReadable).interfaceId, true);\r\n\r\n        // register ERC165\r\n\r\n        selectors[selectorIndex++] = IERC165.supportsInterface.selector;\r\n\r\n        _setSupportsInterface(type(IERC165).interfaceId, true);\r\n\r\n        // register SafeOwnable\r\n\r\n        selectors[selectorIndex++] = Ownable.owner.selector;\r\n        selectors[selectorIndex++] = SafeOwnable.nomineeOwner.selector;\r\n        selectors[selectorIndex++] = Ownable.transferOwnership.selector;\r\n        selectors[selectorIndex++] = SafeOwnable.acceptOwnership.selector;\r\n\r\n        _setSupportsInterface(type(IERC173).interfaceId, true);\r\n\r\n        // diamond cut\r\n\r\n        FacetCut[] memory facetCuts = new FacetCut[](1);\r\n\r\n        facetCuts[0] = FacetCut({\r\n            target: address(this),\r\n            action: FacetCutAction.ADD,\r\n            selectors: selectors\r\n        });\r\n\r\n        _diamondCut(facetCuts, address(0), '');\r\n\r\n        // set owner\r\n\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _transferOwnership(\r\n        address account\r\n    ) internal virtual override(OwnableInternal, SafeOwnable) {\r\n        super._transferOwnership(account);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc DiamondFallback\r\n     */\r\n    function _getImplementation()\r\n        internal\r\n        view\r\n        override(DiamondBase, DiamondFallback)\r\n        returns (address implementation)\r\n    {\r\n        implementation = super._getImplementation();\r\n    }\r\n}\r\n\r\n// File: contracts/nft/AvatarDiamond.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\ncontract AvatarDiamond is SolidStateDiamond {}", "ABI": "[{\"inputs\":[],\"name\":\"DiamondWritable__InvalidInitializationParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__RemoveTargetNotZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__ReplaceTargetIsIdentical\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorIsImmutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorNotSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__TargetHasNoCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC165Base__InvalidInterfaceId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotTransitiveOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Proxy__ImplementationIsNotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeOwnable__NotNomineeOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondWritableInternal.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondWritableInternal.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondWritableInternal.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondWritableInternal.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondReadable.Facet[]\",\"name\":\"diamondFacets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFallbackAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fallbackAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nomineeOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fallbackAddress\",\"type\":\"address\"}],\"name\":\"setFallbackAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AvatarDiamond", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5a05e367b58a54f1a3016a112b5e88a2430ae694d6736bc6b8c255eeadad45c8"}