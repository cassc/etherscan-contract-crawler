{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/pools/fixedRate/FixedRateExchange.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\nimport \\\"../../interfaces/IFixedRateExchange.sol\\\";\\nimport \\\"../../interfaces/IERC20.sol\\\";\\nimport \\\"../../interfaces/IERC20Template.sol\\\";\\nimport \\\"../../interfaces/IERC721Template.sol\\\";\\nimport \\\"../../interfaces/IFactoryRouter.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"../../utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @title FixedRateExchange\\n * @dev FixedRateExchange is a fixed rate exchange Contract\\n *      Marketplaces uses this contract to allow consumers\\n *      exchanging datatokens with ocean token using a fixed\\n *      exchange rate.\\n */\\n\\n\\n\\ncontract FixedRateExchange is ReentrancyGuard, IFixedRateExchange {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    uint256 private constant BASE = 1e18;\\n    uint public constant MIN_FEE           = BASE / 1e4;\\n    uint public constant MAX_FEE           = 5e17;\\n    uint public constant MIN_RATE          = 1e10;\\n\\n    address public router;\\n    \\n    struct Exchange {\\n        bool active;\\n        address exchangeOwner;\\n        address datatoken;\\n        address baseToken;\\n        uint256 fixedRate;\\n        uint256 dtDecimals;\\n        uint256 btDecimals;\\n        uint256 dtBalance;\\n        uint256 btBalance;\\n        uint256 marketFee;\\n        address marketFeeCollector;\\n        uint256 marketFeeAvailable;\\n        uint256 oceanFeeAvailable;\\n        bool withMint;\\n        address allowedSwapper;\\n    }\\n\\n    // maps an exchangeId to an exchange\\n    mapping(bytes32 => Exchange) private exchanges;\\n    bytes32[] private exchangeIds;\\n\\n    modifier onlyActiveExchange(bytes32 exchangeId) {\\n        require(\\n            //exchanges[exchangeId].fixedRate != 0 &&\\n                exchanges[exchangeId].active,\\n            \\\"FixedRateExchange: Exchange does not exist!\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyExchangeOwner(bytes32 exchangeId) {\\n        // allow only ERC20 Deployers or NFT Owner\\n        IERC20Template dt = IERC20Template(exchanges[exchangeId].datatoken);\\n        require(\\n            dt.isERC20Deployer(msg.sender) || \\n            IERC721Template(dt.getERC721Address()).ownerOf(1) == msg.sender\\n            ,\\n            \\\"FixedRateExchange: invalid exchange owner\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyRouter() {\\n        require(msg.sender == router, \\\"FixedRateExchange: only router\\\");\\n        _;\\n    }\\n\\n    event ExchangeCreated(\\n        bytes32 indexed exchangeId,\\n        address indexed baseToken,\\n        address indexed datatoken,\\n        address exchangeOwner,\\n        uint256 fixedRate\\n    );\\n\\n    event ExchangeRateChanged(\\n        bytes32 indexed exchangeId,\\n        address indexed exchangeOwner,\\n        uint256 newRate\\n    );\\n\\n    //triggered when the withMint state is changed \\n    event ExchangeMintStateChanged(\\n        bytes32 indexed exchangeId,\\n        address indexed exchangeOwner,\\n        bool withMint\\n    );\\n    \\n    event ExchangeActivated(\\n        bytes32 indexed exchangeId,\\n        address indexed exchangeOwner\\n    );\\n\\n    event ExchangeDeactivated(\\n        bytes32 indexed exchangeId,\\n        address indexed exchangeOwner\\n    );\\n\\n    event ExchangeAllowedSwapperChanged(\\n        bytes32 indexed exchangeId,\\n        address indexed allowedSwapper\\n    );\\n    \\n    event Swapped(\\n        bytes32 indexed exchangeId,\\n        address indexed by,\\n        uint256 baseTokenSwappedAmount,\\n        uint256 datatokenSwappedAmount,\\n        address tokenOutAddress,\\n        uint256 marketFeeAmount,\\n        uint256 oceanFeeAmount,\\n        uint256 consumeMarketFeeAmount\\n    );\\n\\n    event TokenCollected(\\n        bytes32 indexed exchangeId,\\n        address indexed to,\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    event OceanFeeCollected(\\n        bytes32 indexed exchangeId,\\n        address indexed feeToken,\\n        uint256 feeAmount\\n    );\\n    event MarketFeeCollected(\\n        bytes32 indexed exchangeId,\\n        address indexed feeToken,\\n        uint256 feeAmount\\n    );\\n    // emited for fees sent to consumeMarket\\n    event ConsumeMarketFee(\\n        bytes32 indexed exchangeId,\\n        address to,\\n        address token,\\n        uint256 amount);\\n    event SWAP_FEES(\\n        bytes32 indexed exchangeId,\\n        uint oceanFeeAmount,\\n        uint marketFeeAmount,\\n        uint consumeMarketFeeAmount,\\n        address tokenFeeAddress);\\n    event PublishMarketFeeChanged(\\n        bytes32 indexed exchangeId,\\n        address caller,\\n        address newMarketCollector,\\n        uint256 swapFee);\\n\\n\\n    constructor(address _router) {\\n        require(_router != address(0), \\\"FixedRateExchange: Wrong Router address\\\");\\n        router = _router;\\n    }\\n\\n    /**\\n     * @dev getId\\n     *      Return template id in case we need different ABIs. \\n     *      If you construct your own template, please make sure to change the hardcoded value\\n     */\\n    function getId() pure public returns (uint8) {\\n        return 1;\\n    }\\n    \\n    function getOPCFee(address baseTokenAddress) public view returns (uint) {\\n        return IFactoryRouter(router).getOPCFee(baseTokenAddress);\\n    }\\n  \\n\\n    /**\\n     * @dev create\\n     *      creates new exchange pairs between a baseToken\\n     *      (ocean token) and datatoken.\\n     * datatoken refers to a datatoken contract address\\n     * addresses  - array of addresses with the following struct:\\n     *                [0] - baseToken\\n     *                [1] - owner\\n     *                [2] - marketFeeCollector\\n     *                [3] - allowedSwapper - if != address(0), only that is allowed to swap (used for ERC20Enterprise)\\n     * uints  - array of uints with the following struct:\\n     *                [0] - baseTokenDecimals\\n     *                [1] - datatokenDecimals\\n     *                [2] - fixedRate\\n     *                [3] - marketFee\\n     *                [4] - withMint\\n     */\\n    function createWithDecimals(\\n        address datatoken,\\n        address[] memory addresses, \\n        uint256[] memory uints \\n    ) external onlyRouter returns (bytes32 exchangeId) {\\n       require(uints.length >=5, 'Invalid uints length');\\n       require(addresses.length >=4, 'Invalid addresses length');\\n        require(\\n            addresses[0] != address(0),\\n            \\\"FixedRateExchange: Invalid baseToken,  zero address\\\"\\n        );\\n        require(\\n            datatoken != address(0),\\n            \\\"FixedRateExchange: Invalid datatoken,  zero address\\\"\\n        );\\n        require(\\n            addresses[0] != datatoken,\\n            \\\"FixedRateExchange: Invalid datatoken,  equals baseToken\\\"\\n        );\\n        require(\\n            uints[2] >= MIN_RATE,\\n            \\\"FixedRateExchange: Invalid exchange rate value\\\"\\n        );\\n        exchangeId = generateExchangeId(addresses[0], datatoken);\\n        require(\\n            exchanges[exchangeId].fixedRate == 0,\\n            \\\"FixedRateExchange: Exchange already exists!\\\"\\n        );\\n        bool withMint=true;\\n        if(uints[4] == 0) withMint = false;\\n        exchanges[exchangeId] = Exchange({\\n            active: true,\\n            exchangeOwner: addresses[1],\\n            datatoken: datatoken,\\n            baseToken: addresses[0],\\n            fixedRate: uints[2],\\n            dtDecimals: uints[1],\\n            btDecimals: uints[0],\\n            dtBalance: 0,\\n            btBalance: 0,\\n            marketFee: uints[3],\\n            marketFeeCollector: addresses[2],\\n            marketFeeAvailable: 0,\\n            oceanFeeAvailable: 0,\\n            withMint: withMint,\\n            allowedSwapper: addresses[3]\\n        });\\n        require(uints[3] ==0 || uints[3] >= MIN_FEE,'SwapFee too low');\\n        require(uints[3] <= MAX_FEE,'SwapFee too high');\\n        exchangeIds.push(exchangeId);\\n\\n        emit ExchangeCreated(\\n            exchangeId,\\n            addresses[0], // \\n            datatoken,\\n            addresses[1],\\n            uints[2]\\n        );\\n\\n        emit ExchangeActivated(exchangeId, addresses[1]);\\n        emit ExchangeAllowedSwapperChanged(exchangeId, addresses[3]);\\n        emit PublishMarketFeeChanged(exchangeId,msg.sender, addresses[2], uints[3]);\\n    }\\n\\n    /**\\n     * @dev generateExchangeId\\n     *      creates unique exchange identifier for two token pairs.\\n     * @param baseToken refers to a base token contract address\\n     * @param datatoken refers to a datatoken contract address\\n     */\\n    function generateExchangeId(\\n        address baseToken,\\n        address datatoken\\n    ) public pure returns (bytes32) {\\n        //make sure that there can only be one exchange for a given pair (datatoken <-> basetoken)\\n        return keccak256(abi.encode(baseToken, datatoken));\\n    }\\n\\n    struct Fees{\\n            uint256 baseTokenAmount;\\n            uint256 oceanFeeAmount;\\n            uint256 publishMarketFeeAmount;\\n            uint256 consumeMarketFeeAmount;\\n    }\\n        \\n    function _getBaseTokenOutPrice(bytes32 exchangeId, uint256 datatokenAmount) \\n    internal view returns (uint256 baseTokenAmount){\\n        baseTokenAmount = datatokenAmount\\n            .mul(exchanges[exchangeId].fixedRate)\\n            .mul(10**exchanges[exchangeId].btDecimals)\\n            .div(10**exchanges[exchangeId].dtDecimals)\\n            .div(BASE);\\n    }\\n    /**\\n     * @dev calcBaseInGivenOutDT\\n     *      Calculates how many baseTokens are needed to get exact amount of datatokens\\n     * @param exchangeId a unique exchange idnetifier\\n     * @param datatokenAmount the amount of datatokens to be exchanged\\n     * @param consumeMarketSwapFeeAmount fee amount for consume market\\n     */\\n    function calcBaseInGivenOutDT(bytes32 exchangeId, uint256 datatokenAmount, uint256 consumeMarketSwapFeeAmount)\\n        public\\n        view\\n        onlyActiveExchange(exchangeId)\\n        returns (\\n            uint256 baseTokenAmount,\\n            uint256 oceanFeeAmount,\\n            uint256 publishMarketFeeAmount,\\n            uint256 consumeMarketFeeAmount\\n        )\\n\\n\\n    {\\n        uint256 baseTokenAmountBeforeFee = _getBaseTokenOutPrice(exchangeId, datatokenAmount);\\n        Fees memory fee = Fees(0,0,0,0);\\n        uint256 opcFee = getOPCFee(exchanges[exchangeId].baseToken);\\n        if (opcFee != 0) {\\n            fee.oceanFeeAmount = baseTokenAmountBeforeFee\\n                .mul(opcFee)\\n                .div(BASE);\\n        }\\n        else\\n            fee.oceanFeeAmount = 0;\\n\\n        if( exchanges[exchangeId].marketFee !=0){\\n            fee.publishMarketFeeAmount = baseTokenAmountBeforeFee\\n            .mul(exchanges[exchangeId].marketFee)\\n            .div(BASE);\\n        }\\n        else{\\n            fee.publishMarketFeeAmount = 0;\\n        }\\n\\n        if( consumeMarketSwapFeeAmount !=0){\\n            fee.consumeMarketFeeAmount = baseTokenAmountBeforeFee\\n            .mul(consumeMarketSwapFeeAmount)\\n            .div(BASE);\\n        }\\n        else{\\n            fee.consumeMarketFeeAmount = 0;\\n        }\\n       \\n        \\n        fee.baseTokenAmount = baseTokenAmountBeforeFee.add(fee.publishMarketFeeAmount)\\n            .add(fee.oceanFeeAmount).add(fee.consumeMarketFeeAmount);\\n      \\n        return(fee.baseTokenAmount,fee.oceanFeeAmount,fee.publishMarketFeeAmount,fee.consumeMarketFeeAmount);\\n    }\\n\\n    \\n    /**\\n     * @dev calcBaseOutGivenInDT\\n     *      Calculates how many basteTokens you will get for selling exact amount of baseTokens\\n     * @param exchangeId a unique exchange idnetifier\\n     * @param datatokenAmount the amount of datatokens to be exchanged\\n     * @param consumeMarketSwapFeeAmount fee amount for consume market\\n     */\\n    function calcBaseOutGivenInDT(bytes32 exchangeId, uint256 datatokenAmount, uint256 consumeMarketSwapFeeAmount)\\n        public\\n        view\\n        onlyActiveExchange(exchangeId)\\n        returns (\\n            uint256 baseTokenAmount,\\n            uint256 oceanFeeAmount,\\n            uint256 publishMarketFeeAmount,\\n            uint256 consumeMarketFeeAmount\\n        )\\n    {\\n        uint256 baseTokenAmountBeforeFee = _getBaseTokenOutPrice(exchangeId, datatokenAmount);\\n\\n        Fees memory fee = Fees(0,0,0,0);\\n        uint256 opcFee = getOPCFee(exchanges[exchangeId].baseToken);\\n        if (opcFee != 0) {\\n            fee.oceanFeeAmount = baseTokenAmountBeforeFee\\n                .mul(opcFee)\\n                .div(BASE);\\n        }\\n        else fee.oceanFeeAmount=0;\\n      \\n        if(exchanges[exchangeId].marketFee !=0 ){\\n            fee.publishMarketFeeAmount = baseTokenAmountBeforeFee\\n                .mul(exchanges[exchangeId].marketFee)\\n                .div(BASE);\\n        }\\n        else{\\n            fee.publishMarketFeeAmount = 0;\\n        }\\n\\n        if( consumeMarketSwapFeeAmount !=0){\\n            fee.consumeMarketFeeAmount = baseTokenAmountBeforeFee\\n                .mul(consumeMarketSwapFeeAmount)\\n                .div(BASE);\\n        }\\n        else{\\n            fee.consumeMarketFeeAmount = 0;\\n        }\\n\\n        fee.baseTokenAmount = baseTokenAmountBeforeFee.sub(fee.publishMarketFeeAmount)\\n            .sub(fee.oceanFeeAmount).sub(fee.consumeMarketFeeAmount);\\n        return(fee.baseTokenAmount,fee.oceanFeeAmount,fee.publishMarketFeeAmount,fee.consumeMarketFeeAmount);\\n    }\\n\\n    \\n    /**\\n     * @dev swap\\n     *      atomic swap between two registered fixed rate exchange.\\n     * @param exchangeId a unique exchange idnetifier\\n     * @param datatokenAmount the amount of datatokens to be exchanged\\n     * @param maxBaseTokenAmount maximum amount of base tokens to pay\\n     * @param consumeMarketAddress consumeMarketAddress\\n     * @param consumeMarketSwapFeeAmount fee amount for consume market\\n     */\\n    function buyDT(bytes32 exchangeId, uint256 datatokenAmount, uint256 maxBaseTokenAmount,\\n        address consumeMarketAddress, uint256 consumeMarketSwapFeeAmount)\\n        external\\n        onlyActiveExchange(exchangeId)\\n        nonReentrant\\n    {\\n        require(\\n            datatokenAmount != 0,\\n            \\\"FixedRateExchange: zero datatoken amount\\\"\\n        );\\n        require(consumeMarketSwapFeeAmount ==0 || consumeMarketSwapFeeAmount >= MIN_FEE,'ConsumeSwapFee too low');\\n        require(consumeMarketSwapFeeAmount <= MAX_FEE,'ConsumeSwapFee too high');\\n        if(exchanges[exchangeId].allowedSwapper != address(0)){\\n            require(\\n                exchanges[exchangeId].allowedSwapper == msg.sender,\\n                \\\"FixedRateExchange: This address is not allowed to swap\\\"\\n            );\\n        }\\n        if(consumeMarketAddress == address(0)) consumeMarketSwapFeeAmount=0; \\n        Fees memory fee = Fees(0,0,0,0);\\n        (fee.baseTokenAmount,\\n            fee.oceanFeeAmount,\\n            fee.publishMarketFeeAmount,\\n            fee.consumeMarketFeeAmount\\n        )\\n         = calcBaseInGivenOutDT(exchangeId, datatokenAmount, consumeMarketSwapFeeAmount);\\n        require(\\n            fee.baseTokenAmount <= maxBaseTokenAmount,\\n            \\\"FixedRateExchange: Too many base tokens\\\"\\n        );\\n        // we account fees , fees are always collected in baseToken\\n        exchanges[exchangeId].oceanFeeAvailable = exchanges[exchangeId]\\n            .oceanFeeAvailable\\n            .add(fee.oceanFeeAmount);\\n        exchanges[exchangeId].marketFeeAvailable = exchanges[exchangeId]\\n            .marketFeeAvailable\\n            .add(fee.publishMarketFeeAmount);\\n        _pullUnderlying(exchanges[exchangeId].baseToken,msg.sender,\\n                address(this),\\n                fee.baseTokenAmount);\\n        uint256 baseTokenAmountBeforeFee = fee.baseTokenAmount.sub(fee.oceanFeeAmount).\\n            sub(fee.publishMarketFeeAmount).sub(fee.consumeMarketFeeAmount);\\n        exchanges[exchangeId].btBalance = (exchanges[exchangeId].btBalance).add(\\n            baseTokenAmountBeforeFee\\n        );\\n\\n        if (datatokenAmount > exchanges[exchangeId].dtBalance) {\\n            //first, let's try to mint\\n            if(exchanges[exchangeId].withMint \\n            && IERC20Template(exchanges[exchangeId].datatoken).isMinter(address(this)))\\n            {\\n                IERC20Template(exchanges[exchangeId].datatoken).mint(msg.sender,datatokenAmount);\\n            }\\n            else{\\n                    _pullUnderlying(exchanges[exchangeId].datatoken,exchanges[exchangeId].exchangeOwner,\\n                    msg.sender,\\n                    datatokenAmount);\\n            }\\n        } else {\\n            exchanges[exchangeId].dtBalance = (exchanges[exchangeId].dtBalance)\\n                .sub(datatokenAmount);\\n            IERC20(exchanges[exchangeId].datatoken).safeTransfer(\\n                msg.sender,\\n                datatokenAmount\\n            );\\n        }\\n        if(consumeMarketAddress!= address(0) && fee.consumeMarketFeeAmount>0){\\n            IERC20(exchanges[exchangeId].baseToken).safeTransfer(consumeMarketAddress, fee.consumeMarketFeeAmount);\\n            emit ConsumeMarketFee(\\n                exchangeId,\\n                consumeMarketAddress,\\n                exchanges[exchangeId].baseToken,\\n                fee.consumeMarketFeeAmount);\\n        }\\n        emit Swapped(\\n            exchangeId,\\n            msg.sender,\\n            fee.baseTokenAmount,\\n            datatokenAmount,\\n            exchanges[exchangeId].datatoken,\\n            fee.publishMarketFeeAmount,\\n            fee.oceanFeeAmount,\\n            fee.consumeMarketFeeAmount\\n        );\\n    }\\n\\n\\n    /**\\n     * @dev sellDT\\n     *      Sell datatokenAmount while expecting at least minBaseTokenAmount\\n     * @param exchangeId a unique exchange idnetifier\\n     * @param datatokenAmount the amount of datatokens to be exchanged\\n     * @param minBaseTokenAmount minimum amount of base tokens to cash in\\n     * @param consumeMarketAddress consumeMarketAddress\\n     * @param consumeMarketSwapFeeAmount fee amount for consume market\\n     */\\n    function sellDT(bytes32 exchangeId, uint256 datatokenAmount,\\n    uint256 minBaseTokenAmount, address consumeMarketAddress, uint256 consumeMarketSwapFeeAmount)\\n        external\\n        onlyActiveExchange(exchangeId)\\n        nonReentrant\\n    {\\n        require(\\n            datatokenAmount != 0,\\n            \\\"FixedRateExchange: zero datatoken amount\\\"\\n        );\\n        require(consumeMarketSwapFeeAmount ==0 || consumeMarketSwapFeeAmount >= MIN_FEE,'ConsumeSwapFee too low');\\n        require(consumeMarketSwapFeeAmount <= MAX_FEE,'ConsumeSwapFee too high');\\n        if(exchanges[exchangeId].allowedSwapper != address(0)){\\n            require(\\n                exchanges[exchangeId].allowedSwapper == msg.sender,\\n                \\\"FixedRateExchange: This address is not allowed to swap\\\"\\n            );\\n        }\\n        Fees memory fee = Fees(0,0,0,0);\\n        if(consumeMarketAddress == address(0)) consumeMarketSwapFeeAmount=0; \\n        (fee.baseTokenAmount,\\n            fee.oceanFeeAmount,\\n            fee.publishMarketFeeAmount,\\n            fee.consumeMarketFeeAmount\\n        ) = calcBaseOutGivenInDT(exchangeId, datatokenAmount, consumeMarketSwapFeeAmount);\\n        require(\\n            fee.baseTokenAmount >= minBaseTokenAmount,\\n            \\\"FixedRateExchange: Too few base tokens\\\"\\n        );\\n        // we account fees , fees are always collected in baseToken\\n        exchanges[exchangeId].oceanFeeAvailable = exchanges[exchangeId]\\n            .oceanFeeAvailable\\n            .add(fee.oceanFeeAmount);\\n        exchanges[exchangeId].marketFeeAvailable = exchanges[exchangeId]\\n            .marketFeeAvailable\\n            .add(fee.publishMarketFeeAmount);\\n        uint256 baseTokenAmountWithFees = fee.baseTokenAmount.add(fee.oceanFeeAmount)\\n            .add(fee.publishMarketFeeAmount).add(fee.consumeMarketFeeAmount);\\n        _pullUnderlying(exchanges[exchangeId].datatoken,msg.sender,\\n                address(this),\\n                datatokenAmount);\\n        exchanges[exchangeId].dtBalance = (exchanges[exchangeId].dtBalance).add(\\n            datatokenAmount\\n        );\\n        if (baseTokenAmountWithFees > exchanges[exchangeId].btBalance) {\\n                _pullUnderlying(exchanges[exchangeId].baseToken,exchanges[exchangeId].exchangeOwner,\\n                    address(this),\\n                    baseTokenAmountWithFees);\\n                IERC20(exchanges[exchangeId].baseToken).safeTransfer(\\n                    msg.sender,\\n                    fee.baseTokenAmount);\\n        } else {\\n            exchanges[exchangeId].btBalance = (exchanges[exchangeId].btBalance)\\n                .sub(baseTokenAmountWithFees);\\n            IERC20(exchanges[exchangeId].baseToken).safeTransfer(\\n                msg.sender,\\n                fee.baseTokenAmount\\n            );\\n        }\\n        if(consumeMarketAddress!= address(0) && fee.consumeMarketFeeAmount>0){\\n            IERC20(exchanges[exchangeId].baseToken).safeTransfer(consumeMarketAddress, fee.consumeMarketFeeAmount);    \\n             emit ConsumeMarketFee(\\n                exchangeId,\\n                consumeMarketAddress,\\n                exchanges[exchangeId].baseToken,\\n                fee.consumeMarketFeeAmount);\\n        }\\n        emit Swapped(\\n            exchangeId,\\n            msg.sender,\\n            fee.baseTokenAmount,\\n            datatokenAmount,\\n            exchanges[exchangeId].baseToken,\\n            fee.publishMarketFeeAmount,\\n            fee.oceanFeeAmount,\\n            fee.consumeMarketFeeAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev collectBT\\n     *      Collects and send basetokens.\\n     *      This function can be called by anyone, because fees are being sent to ERC20.getPaymentCollector\\n     */\\n    function collectBT(bytes32 exchangeId, uint256 amount) public\\n        nonReentrant\\n    {\\n        _collectBT(exchangeId, amount);\\n    }\\n\\n    function _collectBT(bytes32 exchangeId, uint256 amount) internal{\\n        require(amount <= exchanges[exchangeId].btBalance, \\\"Amount too high\\\");\\n        address destination = IERC20Template(exchanges[exchangeId].datatoken).getPaymentCollector();\\n        exchanges[exchangeId].btBalance = exchanges[exchangeId].btBalance.sub(amount);\\n        emit TokenCollected(\\n            exchangeId,\\n            destination,\\n            exchanges[exchangeId].baseToken,\\n            amount\\n        );\\n        IERC20(exchanges[exchangeId].baseToken).safeTransfer(\\n            destination,\\n            amount\\n        );\\n    }\\n    /**\\n     * @dev collectDT\\n     *      Collects and send datatokens.\\n     *      This function can be called by anyone, because fees are being sent to ERC20.getPaymentCollector\\n     */\\n    function collectDT(bytes32 exchangeId, uint256 amount) public\\n        nonReentrant\\n    {\\n        _collectDT(exchangeId, amount);\\n    }\\n    function _collectDT(bytes32 exchangeId, uint256 amount) internal {\\n        require(amount <= exchanges[exchangeId].dtBalance, \\\"Amount too high\\\");\\n        address destination = IERC20Template(exchanges[exchangeId].datatoken).getPaymentCollector();\\n        exchanges[exchangeId].dtBalance = exchanges[exchangeId].dtBalance.sub(amount);\\n        emit TokenCollected(\\n            exchangeId,\\n            destination,\\n            exchanges[exchangeId].datatoken,\\n            amount\\n        );\\n        IERC20(exchanges[exchangeId].datatoken).safeTransfer(\\n            destination,\\n            amount\\n        );\\n    }\\n\\n    /**\\n     * @dev collectMarketFee\\n     *      Collects and send publishingMarketFee.\\n     *      This function can be called by anyone, because fees are being sent to exchanges.marketFeeCollector\\n     */\\n    function collectMarketFee(bytes32 exchangeId) public nonReentrant {\\n        // anyone call call this function, because funds are sent to the correct address\\n        _collectMarketFee(exchangeId);\\n    }\\n\\n    function _collectMarketFee(bytes32 exchangeId) internal {\\n        uint256 amount = exchanges[exchangeId].marketFeeAvailable;\\n        exchanges[exchangeId].marketFeeAvailable = 0;\\n        emit MarketFeeCollected(\\n            exchangeId,\\n            exchanges[exchangeId].baseToken,\\n            amount\\n        );\\n        IERC20(exchanges[exchangeId].baseToken).safeTransfer(\\n            exchanges[exchangeId].marketFeeCollector,\\n            amount\\n        );\\n        \\n    }\\n\\n    /**\\n     * @dev collectOceanFee\\n     *      Collects and send OP Community fees.\\n     *      This function can be called by anyone, because fees are being sent to opcCollector\\n     */\\n    function collectOceanFee(bytes32 exchangeId) public nonReentrant {\\n        // anyone call call this function, because funds are sent to the correct address\\n        _collectOceanFee(exchangeId);\\n        \\n    }\\n    function _collectOceanFee(bytes32 exchangeId) internal {\\n        uint256 amount = exchanges[exchangeId].oceanFeeAvailable;\\n        exchanges[exchangeId].oceanFeeAvailable = 0;\\n        IERC20(exchanges[exchangeId].baseToken).safeTransfer(\\n            IFactoryRouter(router).getOPCCollector(),\\n            amount\\n        );\\n        emit OceanFeeCollected(\\n            exchangeId,\\n            exchanges[exchangeId].baseToken,\\n            amount\\n        );\\n    }\\n\\n     /**\\n     * @dev updateMarketFeeCollector\\n     *      Set _newMarketCollector as _publishMarketCollector\\n     * @param _newMarketCollector new _publishMarketCollector\\n     */\\n    function updateMarketFeeCollector(\\n        bytes32 exchangeId,\\n        address _newMarketCollector\\n    ) external {\\n        require(\\n            msg.sender == exchanges[exchangeId].marketFeeCollector,\\n            \\\"not marketFeeCollector\\\"\\n        );\\n        exchanges[exchangeId].marketFeeCollector = _newMarketCollector;\\n        emit PublishMarketFeeChanged(exchangeId, msg.sender, _newMarketCollector, exchanges[exchangeId].marketFee);\\n    }\\n\\n    function updateMarketFee(\\n        bytes32 exchangeId,\\n        uint256 _newMarketFee\\n    ) external {\\n        require(\\n            msg.sender == exchanges[exchangeId].marketFeeCollector,\\n            \\\"not marketFeeCollector\\\"\\n        );\\n        require(_newMarketFee ==0 || _newMarketFee >= MIN_FEE,'SwapFee too low');\\n        require(_newMarketFee <= MAX_FEE,'SwapFee too high');\\n        exchanges[exchangeId].marketFee = _newMarketFee;\\n        emit PublishMarketFeeChanged(exchangeId, msg.sender, exchanges[exchangeId].marketFeeCollector, _newMarketFee);\\n    }\\n\\n    function getMarketFee(bytes32 exchangeId) view public returns(uint256){\\n        return(exchanges[exchangeId].marketFee);\\n    }\\n\\n    /**\\n     * @dev getNumberOfExchanges\\n     *      gets the total number of registered exchanges\\n     * @return total number of registered exchange IDs\\n     */\\n    function getNumberOfExchanges() external view returns (uint256) {\\n        return exchangeIds.length;\\n    }\\n\\n    /**\\n     * @dev setRate\\n     *      changes the fixed rate for an exchange with a new rate\\n     * @param exchangeId a unique exchange idnetifier\\n     * @param newRate new fixed rate value\\n     */\\n    function setRate(bytes32 exchangeId, uint256 newRate)\\n        external\\n        onlyExchangeOwner(exchangeId)\\n    {\\n        require(\\n            newRate >= MIN_RATE,\\n            \\\"FixedRateExchange: Invalid exchange rate value\\\"\\n        );\\n        exchanges[exchangeId].fixedRate = newRate;\\n        emit ExchangeRateChanged(exchangeId, msg.sender, newRate);\\n    }\\n\\n    /**\\n     * @dev toggleMintState\\n     *      toggle withMint state\\n     * @param exchangeId a unique exchange idnetifier\\n     * @param withMint new value\\n     */\\n    function toggleMintState(bytes32 exchangeId, bool withMint)\\n        external\\n        onlyExchangeOwner(exchangeId)\\n    {\\n        // check if owner still has role, maybe he was an ERC20Deployer when fixedrate was created, but not anymore\\n        exchanges[exchangeId].withMint = \\n            _checkAllowedWithMint(exchanges[exchangeId].exchangeOwner, exchanges[exchangeId].datatoken,withMint);\\n        emit ExchangeMintStateChanged(exchangeId, msg.sender, withMint);\\n    }\\n\\n    /**\\n     * @dev checkAllowedWithMint\\n     *      internal function which establishes if a withMint flag can be set.  \\n     *      It does this by checking if the owner has rights for that datatoken\\n     * @param owner exchange owner\\n     * @param datatoken datatoken address\\n     * @param withMint desired flag, might get overwritten if owner has no roles\\n     */\\n    function _checkAllowedWithMint(address owner, address datatoken, bool withMint) internal view returns(bool){\\n            //if owner does not want withMint, return false\\n            if(withMint == false) return false;\\n            IERC721Template nft = IERC721Template(IERC20Template(datatoken).getERC721Address());\\n            IERC721Template.Roles memory roles = nft.getPermissions(owner);\\n            if(roles.manager == true || roles.deployERC20 == true || nft.ownerOf(1) == owner)\\n                return true;\\n            else\\n                return false;\\n    }\\n\\n    /**\\n     * @dev toggleExchangeState\\n     *      toggles the active state of an existing exchange\\n     * @param exchangeId a unique exchange identifier\\n     */\\n    function toggleExchangeState(bytes32 exchangeId)\\n        external\\n        onlyExchangeOwner(exchangeId)\\n    {\\n        if (exchanges[exchangeId].active) {\\n            exchanges[exchangeId].active = false;\\n            emit ExchangeDeactivated(exchangeId, msg.sender);\\n        } else {\\n            exchanges[exchangeId].active = true;\\n            emit ExchangeActivated(exchangeId, msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @dev setAllowedSwapper\\n     *      Sets a new allowedSwapper\\n     * @param exchangeId a unique exchange identifier\\n     * @param newAllowedSwapper refers to the new allowedSwapper\\n     */\\n    function setAllowedSwapper(bytes32 exchangeId, address newAllowedSwapper) external\\n    onlyExchangeOwner(exchangeId)\\n    {\\n        exchanges[exchangeId].allowedSwapper = newAllowedSwapper;\\n        emit ExchangeAllowedSwapperChanged(exchangeId, newAllowedSwapper);\\n    }\\n    /**\\n     * @dev getRate\\n     *      gets the current fixed rate for an exchange\\n     * @param exchangeId a unique exchange idnetifier\\n     * @return fixed rate value\\n     */\\n    function getRate(bytes32 exchangeId) external view returns (uint256) {\\n        return exchanges[exchangeId].fixedRate;\\n    }\\n\\n    /**\\n     * @dev getSupply\\n     *      gets the current supply of datatokens in an fixed\\n     *      rate exchagne\\n     * @param  exchangeId the exchange ID\\n     * @return supply\\n     */\\n    function getDTSupply(bytes32 exchangeId)\\n        public\\n        view\\n        returns (uint256 supply)\\n    {\\n        if (exchanges[exchangeId].active == false) supply = 0;\\n        else if (exchanges[exchangeId].withMint\\n        && IERC20Template(exchanges[exchangeId].datatoken).isMinter(address(this))){\\n            supply = IERC20Template(exchanges[exchangeId].datatoken).cap() \\n            - IERC20Template(exchanges[exchangeId].datatoken).totalSupply();\\n        }\\n        else {\\n            uint256 balance = IERC20Template(exchanges[exchangeId].datatoken)\\n                .balanceOf(exchanges[exchangeId].exchangeOwner);\\n            uint256 allowance = IERC20Template(exchanges[exchangeId].datatoken)\\n                .allowance(exchanges[exchangeId].exchangeOwner, address(this));\\n            if (balance < allowance)\\n                supply = balance.add(exchanges[exchangeId].dtBalance);\\n            else supply = allowance.add(exchanges[exchangeId].dtBalance);\\n        }\\n    }\\n\\n    /**\\n     * @dev getSupply\\n     *      gets the current supply of datatokens in an fixed\\n     *      rate exchagne\\n     * @param  exchangeId the exchange ID\\n     * @return supply\\n     */\\n    function getBTSupply(bytes32 exchangeId)\\n        public\\n        view\\n        returns (uint256 supply)\\n    {\\n        if (exchanges[exchangeId].active == false) supply = 0;\\n        else {\\n            uint256 balance = IERC20Template(exchanges[exchangeId].baseToken)\\n                .balanceOf(exchanges[exchangeId].exchangeOwner);\\n            uint256 allowance = IERC20Template(exchanges[exchangeId].baseToken)\\n                .allowance(exchanges[exchangeId].exchangeOwner, address(this));\\n            if (balance < allowance)\\n                supply = balance.add(exchanges[exchangeId].btBalance);\\n            else supply = allowance.add(exchanges[exchangeId].btBalance);\\n        }\\n    }\\n\\n    // /**\\n    //  * @dev getExchange\\n    //  *      gets all the exchange details\\n    //  * @param exchangeId a unique exchange idnetifier\\n    //  * @return all the exchange details including  the exchange Owner\\n    //  *         the datatoken contract address, the base token address, the\\n    //  *         fixed rate, whether the exchange is active and the supply or the\\n    //  *         the current datatoken liquidity.\\n    //  */\\n    function getExchange(bytes32 exchangeId)\\n        external\\n        view\\n        returns (\\n            address exchangeOwner,\\n            address datatoken,\\n            uint256 dtDecimals,\\n            address baseToken,\\n            uint256 btDecimals,\\n            uint256 fixedRate,\\n            bool active,\\n            uint256 dtSupply,\\n            uint256 btSupply,\\n            uint256 dtBalance,\\n            uint256 btBalance,\\n            bool withMint\\n           // address allowedSwapper\\n        )\\n    {\\n        exchangeOwner = exchanges[exchangeId].exchangeOwner;\\n        datatoken = exchanges[exchangeId].datatoken;\\n        dtDecimals = exchanges[exchangeId].dtDecimals;\\n        baseToken = exchanges[exchangeId].baseToken;\\n        btDecimals = exchanges[exchangeId].btDecimals;\\n        fixedRate = exchanges[exchangeId].fixedRate;\\n        active = exchanges[exchangeId].active;\\n        dtSupply = getDTSupply(exchangeId);\\n        btSupply = getBTSupply(exchangeId);\\n        dtBalance = exchanges[exchangeId].dtBalance;\\n        btBalance = exchanges[exchangeId].btBalance;\\n        withMint = exchanges[exchangeId].withMint;\\n        // allowedSwapper = exchange.allowedSwapper;\\n    }\\n\\n    // /**\\n    //  * @dev getAllowedSwapper\\n    //  *      gets allowedSwapper\\n    //  * @param exchangeId a unique exchange idnetifier\\n    //  * @return address of allowedSwapper \\n    //  */\\n    function getAllowedSwapper(bytes32 exchangeId)\\n        external\\n        view\\n        returns (\\n            address allowedSwapper\\n        )\\n    {\\n        Exchange memory exchange = exchanges[exchangeId];\\n        allowedSwapper = exchange.allowedSwapper;\\n    }\\n\\n    function getFeesInfo(bytes32 exchangeId)\\n        external\\n        view\\n        returns (\\n            uint256 marketFee,\\n            address marketFeeCollector,\\n            uint256 opcFee,\\n            uint256 marketFeeAvailable,\\n            uint256 oceanFeeAvailable\\n        )\\n    {\\n        Exchange memory exchange = exchanges[exchangeId];\\n        marketFee = exchange.marketFee;\\n        marketFeeCollector = exchange.marketFeeCollector;\\n        opcFee = getOPCFee(exchanges[exchangeId].baseToken);\\n        marketFeeAvailable = exchange.marketFeeAvailable;\\n        oceanFeeAvailable = exchange.oceanFeeAvailable;\\n    }\\n\\n    /**\\n     * @dev getExchanges\\n     *      gets all the exchanges list\\n     * @return a list of all registered exchange Ids\\n     */\\n    function getExchanges() external view returns (bytes32[] memory) {\\n        return exchangeIds;\\n    }\\n\\n    /**\\n     * @dev isActive\\n     *      checks whether exchange is active\\n     * @param exchangeId a unique exchange idnetifier\\n     * @return true if exchange is true, otherwise returns false\\n     */\\n    function isActive(bytes32 exchangeId) external view returns (bool) {\\n        return exchanges[exchangeId].active;\\n    }\\n\\n    function _pullUnderlying(\\n        address erc20,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        uint256 balanceBefore = IERC20(erc20).balanceOf(to);\\n        IERC20(erc20).safeTransferFrom(from, to, amount);\\n        require(IERC20(erc20).balanceOf(to) >= balanceBefore.add(amount),\\n                    \\\"Transfer amount is too low\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IFixedRateExchange.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IFixedRateExchange {\\n    function createWithDecimals(\\n        address datatoken,\\n        address[] calldata addresses, // [baseToken,owner,marketFeeCollector]\\n        uint256[] calldata uints // [baseTokenDecimals,datatokenDecimals, fixedRate, marketFee]\\n    ) external returns (bytes32 exchangeId);\\n\\n    function buyDT(bytes32 exchangeId, uint256 datatokenAmount,\\n        uint256 maxBaseTokenAmount, address consumeMarketAddress, uint256 consumeMarketSwapFeeAmount) external;\\n    function sellDT(bytes32 exchangeId, uint256 datatokenAmount,\\n        uint256 minBaseTokenAmount, address consumeMarketAddress, uint256 consumeMarketSwapFeeAmount) external;\\n\\n    function getAllowedSwapper(bytes32 exchangeId) external view returns (address allowedSwapper);\\n    function getExchange(bytes32 exchangeId)\\n        external\\n        view\\n        returns (\\n            address exchangeOwner,\\n            address datatoken,\\n            uint256 dtDecimals,\\n            address baseToken,\\n            uint256 btDecimals,\\n            uint256 fixedRate,\\n            bool active,\\n            uint256 dtSupply,\\n            uint256 btSupply,\\n            uint256 dtBalance,\\n            uint256 btBalance,\\n            bool withMint\\n            //address allowedSwapper\\n        );\\n\\n    function getFeesInfo(bytes32 exchangeId)\\n        external\\n        view\\n        returns (\\n            uint256 marketFee,\\n            address marketFeeCollector,\\n            uint256 opcFee,\\n            uint256 marketFeeAvailable,\\n            uint256 oceanFeeAvailable\\n        );\\n\\n    function isActive(bytes32 exchangeId) external view returns (bool);\\n\\n    function calcBaseInGivenOutDT(bytes32 exchangeId, uint256 datatokenAmount, uint256 consumeMarketSwapFeeAmount)\\n        external\\n        view\\n        returns (\\n            uint256 baseTokenAmount,\\n            uint256 oceanFeeAmount,\\n            uint256 publishMarketFeeAmount,\\n            uint256 consumeMarketFeeAmount\\n        );\\n    function calcBaseOutGivenInDT(bytes32 exchangeId, uint256 datatokenAmount, uint256 consumeMarketSwapFeeAmount)\\n        external\\n        view\\n        returns (\\n            uint256 baseTokenAmount,\\n            uint256 oceanFeeAmount,\\n            uint256 publishMarketFeeAmount,\\n            uint256 consumeMarketFeeAmount\\n        );\\n    function updateMarketFee(bytes32 exchangeId, uint256 _newMarketFee) external;\\n    function updateMarketFeeCollector(bytes32 exchangeId, address _newMarketCollector) external;\\n    function setAllowedSwapper(bytes32 exchangeId, address newAllowedSwapper) external;\\n    function getId() pure external returns (uint8);\\n    function collectBT(bytes32 exchangeId, uint256 amount) external;\\n    function collectDT(bytes32 exchangeId, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Template.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IERC20Template {\\n    struct RolesERC20 {\\n        bool minter;\\n        bool feeManager;\\n    }\\n    struct providerFee{\\n        address providerFeeAddress;\\n        address providerFeeToken; // address of the token marketplace wants to add fee on top\\n        uint256 providerFeeAmount; // amount to be transfered to marketFeeCollector\\n        uint8 v; // v of provider signed message\\n        bytes32 r; // r of provider signed message\\n        bytes32 s; // s of provider signed message\\n        uint256 validUntil; //validity expresses in unix timestamp\\n        bytes providerData; //data encoded by provider\\n    }\\n    struct consumeMarketFee{\\n        address consumeMarketFeeAddress;\\n        address consumeMarketFeeToken; // address of the token marketplace wants to add fee on top\\n        uint256 consumeMarketFeeAmount; // amount to be transfered to marketFeeCollector\\n    }\\n    function initialize(\\n        string[] calldata strings_,\\n        address[] calldata addresses_,\\n        address[] calldata factoryAddresses_,\\n        uint256[] calldata uints_,\\n        bytes[] calldata bytes_\\n    ) external returns (bool);\\n    \\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function cap() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function mint(address account, uint256 value) external;\\n    \\n    function isMinter(address account) external view returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permissions(address user)\\n        external\\n        view\\n        returns (RolesERC20 memory);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function cleanFrom721() external;\\n\\n    function deployPool(\\n        uint256[] memory ssParams,\\n        uint256[] memory swapFees,\\n        address[] memory addresses \\n    ) external returns (address);\\n\\n    function createFixedRate(\\n        address fixedPriceAddress,\\n        address[] memory addresses,\\n        uint[] memory uints\\n    ) external returns (bytes32);\\n    function createDispenser(\\n        address _dispenser,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        bool withMint,\\n        address allowedSwapper) external;\\n        \\n    function getPublishingMarketFee() external view returns (address , address, uint256);\\n    function setPublishingMarketFee(\\n        address _publishMarketFeeAddress, address _publishMarketFeeToken, uint256 _publishMarketFeeAmount\\n    ) external;\\n\\n     function startOrder(\\n        address consumer,\\n        uint256 serviceIndex,\\n        providerFee calldata _providerFee,\\n        consumeMarketFee calldata _consumeMarketFee\\n     ) external;\\n\\n     function reuseOrder(\\n        bytes32 orderTxId,\\n        providerFee calldata _providerFee\\n    ) external;\\n  \\n    function burn(uint256 amount) external;\\n    function burnFrom(address account, uint256 amount) external;\\n    function getERC721Address() external view returns (address);\\n    function isERC20Deployer(address user) external view returns(bool);\\n    function getPools() external view returns(address[] memory);\\n    struct fixedRate{\\n        address contractAddress;\\n        bytes32 id;\\n    }\\n    function getFixedRates() external view returns(fixedRate[] memory);\\n    function getDispensers() external view returns(address[] memory);\\n    function getId() pure external returns (uint8);\\n    function getPaymentCollector() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Template.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\n\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Template {\\n    \\n    enum RolesType {\\n        Manager,\\n        DeployERC20,\\n        UpdateMetadata,\\n        Store\\n    }\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n    event MetadataCreated(\\n        address indexed createdBy,\\n        uint8 state,\\n        string decryptorUrl,\\n        bytes flags,\\n        bytes data,\\n        string metaDataDecryptorAddress,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n    event MetadataUpdated(\\n        address indexed updatedBy,\\n        uint8 state,\\n        string decryptorUrl,\\n        bytes flags,\\n        bytes data,\\n        string metaDataDecryptorAddress,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function isERC20Deployer(address acount) external view returns (bool);\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, \\n     * it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, \\n     * it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, \\n     * it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    // function safeTransferFrom(\\n    //     address from,\\n    //     address to,\\n    //     uint256 tokenId,\\n    //     bytes calldata data\\n    // ) external;\\n    function transferFrom(address from, address to) external;\\n\\n    function initialize(\\n        address admin,\\n        string calldata name,\\n        string calldata symbol,\\n        address erc20Factory,\\n        address additionalERC20Deployer,\\n        address additionalMetaDataUpdater,\\n        string calldata tokenURI,\\n        bool transferable\\n    ) external returns (bool);\\n\\n     struct Roles {\\n        bool manager;\\n        bool deployERC20;\\n        bool updateMetadata;\\n        bool store;\\n    }\\n\\n    struct metaDataProof {\\n        address validatorAddress;\\n        uint8 v; // v of validator signed message\\n        bytes32 r; // r of validator signed message\\n        bytes32 s; // s of validator signed message\\n    }\\n    function getPermissions(address user) external view returns (Roles memory);\\n\\n    function setDataERC20(bytes32 _key, bytes calldata _value) external;\\n    function setMetaData(uint8 _metaDataState, string calldata _metaDataDecryptorUrl\\n        , string calldata _metaDataDecryptorAddress, bytes calldata flags, \\n        bytes calldata data,bytes32 _metaDataHash, metaDataProof[] memory _metadataProofs) external;\\n    function getMetaData() external view returns (string memory, string memory, uint8, bool);\\n\\n    function createERC20(\\n        uint256 _templateIndex,\\n        string[] calldata strings,\\n        address[] calldata addresses,\\n        uint256[] calldata uints,\\n        bytes[] calldata bytess\\n    ) external returns (address);\\n\\n\\n    function removeFromCreateERC20List(address _allowedAddress) external;\\n    function addToCreateERC20List(address _allowedAddress) external;\\n    function addToMetadataList(address _allowedAddress) external;\\n    function removeFromMetadataList(address _allowedAddress) external;\\n    function getId() pure external returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactoryRouter.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IFactoryRouter {\\n    function deployPool(\\n        address[2] calldata tokens, // [datatokenAddress, baseTokenAddress]\\n        uint256[] calldata ssParams,\\n        uint256[] calldata swapFees,\\n        address[] calldata addresses\\n    ) external returns (address);\\n\\n    function deployFixedRate(\\n        address fixedPriceAddress,\\n        address[] calldata addresses,\\n        uint256[] calldata uints\\n    ) external returns (bytes32 exchangeId);\\n\\n    function getOPCFee(address baseToken) external view returns (uint256);\\n    function getOPCFees() external view returns (uint256,uint256);\\n    function getOPCConsumeFee() external view returns (uint256);\\n    function getOPCProviderFee() external view returns (uint256);\\n\\n    function getMinVestingPeriod() external view returns (uint256);\\n    function deployDispenser(\\n        address _dispenser,\\n        address datatoken,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        address owner,\\n        address allowedSwapper\\n    ) external;\\n\\n    function isApprovedToken(address) external view returns(bool);\\n    function getApprovedTokens() external view returns(address[] memory);\\n    function isSSContract(address) external view returns(bool);\\n    function getSSContracts() external view returns(address[] memory);\\n    function isFixedRateContract(address) external view returns(bool);\\n    function getFixedRatesContracts() external view returns(address[] memory);\\n    function isDispenserContract(address) external view returns(bool);\\n    function getDispensersContracts() external view returns(address[] memory);\\n    function isPoolTemplate(address) external view returns(bool);\\n    function getPoolTemplates() external view returns(address[] memory);\\n\\n    struct Stakes {\\n        address poolAddress;\\n        uint256 tokenAmountIn;\\n        uint256 minPoolAmountOut;\\n    }\\n    function stakeBatch(Stakes[] calldata) external;\\n\\n    enum operationType {\\n        SwapExactIn,\\n        SwapExactOut,\\n        FixedRate,\\n        Dispenser\\n    }\\n\\n    struct Operations {\\n        bytes32 exchangeIds; // used for fixedRate or dispenser\\n        address source; // pool, dispenser or fixed rate address\\n        operationType operation; // type of operation: enum operationType\\n        address tokenIn; // token in address, only for pools\\n        uint256 amountsIn; // ExactAmount In for swapExactIn operation, maxAmount In for swapExactOut\\n        address tokenOut; // token out address, only for pools\\n        uint256 amountsOut; // minAmountOut for swapExactIn or exactAmountOut for swapExactOut\\n        uint256 maxPrice; // maxPrice, only for pools\\n        uint256 swapMarketFee;\\n        address marketFeeAddress;\\n    }\\n    function buyDTBatch(Operations[] calldata) external;\\n    function updateOPCCollector(address _opcCollector) external;\\n    function getOPCCollector() view external returns (address);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"./ERC721/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ERC721/Address.sol\": {\r\n      \"content\": \"\\npragma solidity 0.8.12;\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n\\n}\\n\\n\\n// File @openzeppelin/contracts/utils/Context.sol@v4.0.0\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConsumeMarketFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchangeOwner\",\"type\":\"address\"}],\"name\":\"ExchangeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"allowedSwapper\",\"type\":\"address\"}],\"name\":\"ExchangeAllowedSwapperChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"datatoken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fixedRate\",\"type\":\"uint256\"}],\"name\":\"ExchangeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchangeOwner\",\"type\":\"address\"}],\"name\":\"ExchangeDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchangeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withMint\",\"type\":\"bool\"}],\"name\":\"ExchangeMintStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"exchangeOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"ExchangeRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"MarketFeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"OceanFeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMarketCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"PublishMarketFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oceanFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"consumeMarketFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenFeeAddress\",\"type\":\"address\"}],\"name\":\"SWAP_FEES\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseTokenSwappedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"datatokenSwappedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOutAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oceanFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"consumeMarketFeeAmount\",\"type\":\"uint256\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenCollected\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"datatokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBaseTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"consumeMarketAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketSwapFeeAmount\",\"type\":\"uint256\"}],\"name\":\"buyDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"datatokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketSwapFeeAmount\",\"type\":\"uint256\"}],\"name\":\"calcBaseInGivenOutDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oceanFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishMarketFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"datatokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketSwapFeeAmount\",\"type\":\"uint256\"}],\"name\":\"calcBaseOutGivenInDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oceanFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publishMarketFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketFeeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"collectBT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"collectDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"collectMarketFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"collectOceanFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"datatoken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"uints\",\"type\":\"uint256[]\"}],\"name\":\"createWithDecimals\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"datatoken\",\"type\":\"address\"}],\"name\":\"generateExchangeId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"getAllowedSwapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"allowedSwapper\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"getBTSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"getDTSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"getExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"exchangeOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"datatoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dtDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"btDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixedRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"dtSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"btSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dtBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"btBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withMint\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExchanges\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"getFeesInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketFeeCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"opcFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketFeeAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oceanFeeAvailable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"getMarketFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfExchanges\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseTokenAddress\",\"type\":\"address\"}],\"name\":\"getOPCFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"datatokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"consumeMarketAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketSwapFeeAmount\",\"type\":\"uint256\"}],\"name\":\"sellDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newAllowedSwapper\",\"type\":\"address\"}],\"name\":\"setAllowedSwapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"name\":\"toggleExchangeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"withMint\",\"type\":\"bool\"}],\"name\":\"toggleMintState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_newMarketFee\",\"type\":\"uint256\"}],\"name\":\"updateMarketFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_newMarketCollector\",\"type\":\"address\"}],\"name\":\"updateMarketFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FixedRateExchange", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008c98ea273ba22327f896aa1a1a46e1bff56e9b1d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}