{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GameControl.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nimport \\\"./interfaces/IStarShip.sol\\\";\\nimport \\\"./interfaces/IUserStorage.sol\\\";\\nimport \\\"./interfaces/IPoolPlan.sol\\\";\\nimport \\\"./interfaces/IPMCSwap.sol\\\";\\n\\ninterface IDividendPool{\\n    function checkIsUserInFirstPool(address _addr) external view returns (bool);\\n    function checkIsUserInSecondPool(address _addr) external view returns (bool);\\n    function dividendBonusFromFeat(uint _poolId, address _addr) external;\\n    function salaryDividend() external;\\n}\\n\\ncontract GameControl is Ownable {\\n    using SafeMath for uint256;\\n\\n    uint[] private carTypes;\\n    mapping(uint => uint) private carTypePrice;\\n    mapping(uint => uint) private currentDayPoolIndex;\\n\\n    uint public immutable aDay = 1 days; // prod 1 days\\n    uint public immutable startTime = 1694131200;// prod\\n    uint public recordDay;\\n\\n    uint public runDay = 100;\\n\\n    IStarShip private starShip;\\n    IUserStorage private userStorage;\\n    IPoolPlan private poolPlan;\\n    IPMCSwap private pmcSwap;\\n    address private dividendTechPool;\\n    IDividendPool private dividendPool;\\n    address private swapCollection;\\n    address private txFeeAddress;\\n\\n    mapping(uint => uint) private _dayRecordMintPool;\\n    mapping(uint => uint) private _dayWeightTotal;\\n    mapping(uint => mapping(address => uint)) private _dayUserWeightTotal;\\n\\n    mapping(uint => bool) private _userJoinedMark;\\n\\n    uint[] private daoFeats = [500000e18, 1000000e18]; //dao\\n\\n    constructor() {\\n    }\\n    \\n    receive() external payable {}\\n\\n    mapping(address => bool) private isCaller;// gameplan poolplan\\n\\n    modifier onlyCaller {      \\n        require(isCaller[msg.sender] || msg.sender == owner(), \\\"GC: Not caller\\\");     \\n        _;\\n    }\\n\\n    function setStarShip(address _addr) external onlyOwner {\\n        starShip = IStarShip(_addr);\\n        isCaller[_addr] = true;\\n    }\\n\\n    function setStorage(address _addr) external onlyOwner {\\n        userStorage = IUserStorage(_addr);\\n        isCaller[_addr] = true;\\n    }\\n\\n    function setPoolPlan(address _addr) external onlyOwner {\\n        poolPlan = IPoolPlan(_addr);\\n        isCaller[_addr] = true;\\n    }\\n\\n    function setPMCSwap(address _addr) external onlyOwner {\\n        pmcSwap = IPMCSwap(_addr);\\n        isCaller[_addr] = true;\\n    }\\n\\n    function setDividendTechPool(address _addr) external onlyOwner {\\n        dividendTechPool = _addr;\\n    }\\n\\n    function setDividendPool(address _addr) external onlyOwner {\\n        dividendPool = IDividendPool(_addr);\\n    }\\n\\n    function setDaoFeats(uint[] memory _feats) external onlyOwner {\\n        daoFeats = _feats;\\n    }\\n\\n    function setSwapCollection(address _addr) external onlyOwner {\\n        swapCollection = _addr;\\n    }\\n\\n    function setTxFeeAddress(address _addr) external onlyOwner {\\n        txFeeAddress = _addr;\\n    }\\n\\n    function addCaller(address _caller) external onlyOwner {\\n        isCaller[_caller] = true;\\n    }\\n\\n    function removeCaller(address _caller) external onlyOwner {\\n        isCaller[_caller] = false;\\n    }\\n\\n    modifier recordDayModifier() {\\n        if (getDay() > recordDay){\\n            recordDay = getDay();\\n        }\\n        _;\\n    }\\n\\n    /**\\n        prepare check pool stock\\n     */\\n    function preparePoolStock(uint _poolId) internal {\\n        if (!poolPlan.stockReset(_poolId, recordDay) && poolPlan.poolSupply(_poolId) >= 0) {\\n            poolPlan.setDayPoolStock(_poolId, recordDay, poolPlan.poolSupply(_poolId));\\n        }\\n    }\\n\\n    function getDay() public view returns (uint) {\\n        if (block.timestamp > startTime){\\n            return (block.timestamp - startTime) / aDay;\\n        }else{\\n            return 0;\\n        }\\n    }\\n\\n    function setRunDay(uint _runDay) external onlyOwner {\\n        runDay = _runDay;\\n    }\\n\\n    function setCarTypePrice(uint _type, uint _price) public onlyOwner {\\n        carTypePrice[_type] = _price;\\n    }\\n\\n    function setCarTypes(uint _type, uint _price) external onlyOwner {\\n        carTypes.push(_type);\\n        setCarTypePrice(_type, _price);\\n    }\\n\\n    function carTypeCount() public virtual view returns (uint) {\\n        return carTypes.length;\\n    }\\n\\n    function carTypeByIndex(uint _index) public virtual view returns (uint) {\\n        return carTypes[_index];\\n    }\\n\\n    function getCarPriceByType(uint _type) public virtual view returns (uint){\\n        return carTypePrice[_type];\\n    }\\n\\n    function userJoinedMark(address _addr) public virtual view returns (bool) {\\n        return _userJoinedMark[userStorage.userId(_addr)];\\n    }\\n\\n    event MintCarEvent(address indexed addr, uint indexed uid, uint indexed car);\\n\\n    function msgUid(address _who) public view returns (uint) {\\n        return userStorage.userId(_who);\\n    }\\n\\n    function dayRecordMintPool(uint _day) external view returns (uint) {\\n        return _dayRecordMintPool[_day];\\n    }\\n\\n    function dayWeightTotal(uint _day) external view returns (uint) {\\n        return _dayWeightTotal[_day];\\n    }\\n\\n    function dayUserWeightTotal(uint _day, address _user) external view returns (uint) {\\n        return _dayUserWeightTotal[_day][_user];\\n    }\\n\\n    function poolStockCheck(uint poolId) public view returns(uint) {\\n        if (poolPlan.stockReset(poolId, recordDay)) {\\n            return poolPlan.poolStock(poolId, recordDay);\\n        } else {\\n            return poolPlan.poolSupply(poolId);\\n        }\\n    }\\n\\n    function allPoolStock() public view returns(uint totalStock) {\\n        uint[] memory ids = poolPlan.getPools();\\n        for (uint i = 0; i < ids.length; i++) {\\n            unchecked {\\n                totalStock += poolStockCheck(ids[i]);\\n            }\\n        }\\n    }\\n\\n    /**\\n        is enough stock by record pool id index\\n     */\\n    function isEnoughStockByIndex(uint _index, uint _amount) public view returns (bool) {\\n        uint _poolId = poolPlan.poolIdByIndex(_index);\\n        uint releaseStock = poolStockCheck(_poolId);\\n        return releaseStock >= _amount;\\n    }\\n    /**\\n        current pool plan index\\n     */\\n    function currentPoolIndex(uint _amount) public view returns (uint) {\\n        uint _len = poolPlan.lenPool();\\n        require(_len > 0, \\\"GC: Pool plan not set\\\");\\n        uint currentIndex = currentDayPoolIndex[recordDay];\\n        bool isEnough = isEnoughStockByIndex(currentIndex, _amount);\\n        if (isEnough) {\\n            return currentIndex;\\n        }\\n        for (uint i = currentIndex + 1; i < 5; i++) {\\n            if (isEnoughStockByIndex(i, _amount)){\\n                return i;\\n            }\\n        }\\n        return 5; // 5 is insufficient stock\\n    }\\n\\n    /**\\n        Choose pool by amount\\n     */\\n    function switchPoolId(uint _amount) internal returns (uint) {\\n        uint _poolIdIndex = currentPoolIndex(_amount);\\n        require(_poolIdIndex < 5, \\\"GC: Stock insufficient\\\");\\n        // record now record pool index\\n        if (_poolIdIndex != currentDayPoolIndex[recordDay]) {\\n            currentDayPoolIndex[recordDay] = _poolIdIndex;\\n        }\\n        return poolPlan.poolIdByIndex(_poolIdIndex);\\n    }\\n\\n    /**\\n        record weight\\n     */\\n    function recordMintWeight(uint _uid, uint _weight) external onlyCaller {\\n        unchecked {\\n            _dayWeightTotal[recordDay] += _weight;\\n            _dayUserWeightTotal[recordDay][userStorage.userOfId(_uid)] += _weight;\\n        }\\n    }\\n\\n    function poolReleaseAmount(uint _poolId) public view returns (uint) {\\n        return poolPlan.poolAsset(_poolId);\\n    }\\n\\n    function comparePoolAmount(uint _amount, uint _poolId) public view returns (uint) {\\n        uint _releaseAmount = poolPlan.poolAsset(_poolId);\\n        return _releaseAmount >= _amount ? _amount : _releaseAmount;\\n    }\\n\\n    function compareBackPoolAmount(uint _amount) public view returns (uint) {\\n         uint _releaseAmount = poolPlan.backPool();\\n         return _releaseAmount >= _amount ? _amount : _releaseAmount;\\n    }\\n    \\n    function _send(address _user, uint _amount) internal {\\n        (bool success, ) = payable(_user).call{value: _amount}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    /**\\n        Pool transfer to user\\n     */\\n    function poolOutcome(uint _uid, uint _poolId, uint _bonus) external onlyCaller returns (uint) {\\n        uint releaseAmount = comparePoolAmount(_bonus, _poolId);\\n        if (releaseAmount > 0 && address(this).balance >= releaseAmount) {\\n            address tAddr = userStorage.userOfId(_uid);\\n            _send(tAddr, releaseAmount);\\n            userStorage.addTeamBonus(_uid, releaseAmount);\\n            poolPlan.subPoolAsset(_poolId, releaseAmount);\\n            return releaseAmount;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n        Pool transfer to swap mint\\n     */\\n    function poolOutmint(uint _poolId, uint _amount) external onlyCaller {\\n        if (_poolId == 0) {\\n            _amount = compareBackPoolAmount(_amount);\\n        } else {\\n            _amount = comparePoolAmount(_amount, _poolId);\\n        }\\n        if (address(this).balance >= _amount){\\n            if (_poolId == 0){\\n                poolPlan.subBackPool(_amount);\\n            } else {\\n                poolPlan.subPoolAsset(_poolId, _amount);\\n            }\\n            if (swapCollection != address(0)){\\n                _send(address(swapCollection), _amount);\\n            } else {\\n                _send(address(pmcSwap), _amount);\\n            }\\n            unchecked {\\n                _dayRecordMintPool[recordDay] += _amount;\\n            }\\n        }\\n    }\\n\\n    /**\\n        pool out tx fee\\n     */\\n    function poolOutTxFee(uint _poolId, uint _amount) external onlyCaller {\\n        if (_poolId == 0) {\\n            _amount = compareBackPoolAmount(_amount);\\n        } else {\\n            _amount = comparePoolAmount(_amount, _poolId);\\n        }\\n        if (address(this).balance >= _amount) {\\n            if (_poolId == 0){\\n                poolPlan.subBackPool(_amount);\\n                _send(address(dividendTechPool), _amount);\\n            } else if (address(dividendPool) != address(0)){\\n                poolPlan.subPoolAsset(_poolId, _amount);\\n                uint _techFee = _amount / 2;\\n                _send(address(dividendTechPool), _techFee);\\n                _send(address(dividendPool), _amount - _techFee);\\n            }\\n        }\\n    }\\n\\n    function carRunning(uint _uid, uint _type) public view returns (bool) {\\n        (,uint _start,,,) = starShip.userCar(_uid, _type);\\n        return _start == 0 || starShip.getDiffDay(_start) > runDay;\\n    }\\n\\n    function checkDividendUserFeats(uint _uid) public view returns (uint) {\\n        (,uint _feat,,) = userStorage.userTeamsData(_uid);\\n        if (_feat >= daoFeats[0] && _feat < daoFeats[1]){\\n            return 1;\\n        } else if (_feat >= daoFeats[1]){\\n            return 2;\\n        }\\n        return 0;\\n    }\\n\\n    function calcFeatDividenPool(uint _uid) internal {\\n        uint daoPoolId = checkDividendUserFeats(_uid);\\n        if (daoPoolId > 0 ) {\\n            address _user = userStorage.userOfId(_uid);\\n            bool inDividendPool = false;\\n            if (daoPoolId == 1 && !dividendPool.checkIsUserInFirstPool(_user)) {\\n                inDividendPool = true;\\n            } else if (daoPoolId == 2 && !dividendPool.checkIsUserInSecondPool(_user)){\\n                inDividendPool = true;\\n            }\\n            if (inDividendPool) {\\n                dividendPool.dividendBonusFromFeat(daoPoolId, _user);\\n            }\\n        }\\n        dividendPool.salaryDividend();\\n    }\\n\\n    function commonMintCar(uint _uid, uint _type, uint _amount) internal {\\n        require(userStorage.isValidId(_uid), \\\"GC: Invalid regist user\\\");\\n        (,uint _start,,,) = starShip.userCar(_uid, _type);\\n        require(_start == 0 || starShip.getDiffDay(_start) > runDay, \\\"GC: Car type is minted\\\");\\n        // choose pool\\n        uint _poolId = switchPoolId(_amount);\\n        // set stock of the recordDay\\n        preparePoolStock(_poolId);\\n        // dividend assets to diff pool\\n        poolPlan.dividendPool(_poolId, _amount);\\n        // start mint car\\n        starShip.mintCar(_uid, _amount, _type, _poolId);\\n        if (poolPlan.poolSupply(_poolId) > 0) {\\n            poolPlan.subStock(_poolId, recordDay, _amount);\\n        }\\n        // add v feat\\n        userStorage.addBatchVFeat(_uid, _amount);\\n        (uint rfid,,,) = userStorage.userBasicData(_uid);\\n        if (userStorage.isValidId(rfid) && !_userJoinedMark[_uid]){\\n            userStorage.addDirect(rfid);\\n            _userJoinedMark[_uid] = true;\\n        }\\n        emit MintCarEvent(userStorage.userOfId(_uid), _uid, _type);\\n    }\\n\\n    /**\\n        Entrance\\n     */\\n    function mintCar(uint _type) public payable recordDayModifier {\\n        require(carTypePrice[_type] > 0, \\\"GC: No type set\\\");\\n        require(msg.value >= carTypePrice[_type], \\\"GC: Pay amount error\\\");\\n        uint _uid = msgUid(msg.sender);\\n        commonMintCar(_uid, _type, carTypePrice[_type]);\\n        // calc feat dividend\\n        calcFeatDividenPool(_uid);\\n        pmcSwap.collectUserBal(msg.sender);\\n    }\\n\\n    function startEngine() external recordDayModifier {\\n        uint _uid = msgUid(msg.sender);\\n        require(userStorage.isValidId(_uid), \\\"GC: Invalid regist user\\\");\\n        require(carTypes.length > 0, \\\"GC: No types\\\");\\n        for (uint i = 0; i < carTypes.length; i++) {\\n            uint _type = carTypes[i];\\n            starShip.engine(_uid, _type);\\n        }\\n        // calc feat dividend\\n        calcFeatDividenPool(_uid);\\n        pmcSwap.collectUserBal(msg.sender);\\n    }\\n\\n    function startEngineByType(uint _type) external recordDayModifier {\\n        uint _uid = msgUid(msg.sender);\\n        require(userStorage.isValidId(_uid), \\\"GC: Invalid regist user\\\");\\n        require(carTypePrice[_type] > 0, \\\"GC: Engine type not config\\\");\\n        starShip.engine(_uid, _type);\\n        // calc feat dividend\\n        calcFeatDividenPool(_uid);\\n        pmcSwap.collectUserBal(msg.sender);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPMCSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IPMCSwap {\\n    function getDay() external view returns (uint);\\n    function recordDay() external view returns (uint);\\n    function dayRecordMintPool(uint _theDay) external view returns (uint);\\n\\n    function balanceOfPool() external view returns (uint);\\n\\n    function collectUserBal(address _user) external;\\n\\n    /**\\n        Only coin call\\n     */\\n    function setDayMintTotal(uint _day, uint _acutal) external;\\n    function addRecordPoolAmount(uint _bal) external;\\n    function updateRecordDay(uint _day) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPoolPlan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IPoolPlan {\\n    function getPools() external view returns (uint[] calldata);\\n    function lenPool() external view returns (uint);\\n    function poolIdByIndex(uint _index) external view returns (uint);\\n    function rateById(uint _pid) external view returns (uint);\\n    function weightById(uint _pid) external view returns (uint);\\n\\n    function poolSupply(uint) external view returns (uint);\\n    function poolStock(uint, uint) external view returns (uint);\\n    function subStock(uint _id, uint _day, uint _amount) external;\\n\\n    function stockReset(uint, uint) external view returns (bool);\\n    function backWeight() external view returns (uint);\\n    function backPool() external view returns (uint);\\n    function poolAsset(uint) external view returns (uint);\\n\\n    function setDayPoolStock(uint _id, uint _day, uint _amount) external;\\n\\n    function isGoToBackPool(uint _id) external view returns (bool);\\n    function checkCarNoIntoBackPool(uint _id) external view returns (uint);\\n    /**\\n        only gamer\\n     */\\n    function addBackPool(uint _amount) external;\\n    function subBackPool(uint _amount) external;\\n    function addPoolAsset(uint _poolId, uint _amount) external;\\n    function subPoolAsset(uint _poolId, uint _amount) external;\\n\\n    function dividendPool(uint _poolId, uint _amount) external;\\n\\n    /**\\n        only game plan\\n     */\\n    function txFee(uint _poolId, uint _amount) external;\\n    function dividendMintPool(uint _poolId, uint _amount) external;\\n    function recordPoolCarNoOfBackPool(uint _id, uint _carNo) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStarShip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IStarShip {\\n    function getDiffDay(uint _time) external view returns (uint);\\n    function userCar(uint _uid, uint _type) external view returns (uint, uint, uint, uint, uint);\\n    function currentCarNo() external view returns (uint);\\n    \\n    function mintCar(uint _uid, uint _amount, uint _type, uint _poolId) external;\\n    function engine(uint _uid, uint _type) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUserStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IUserStorageRead.sol\\\";\\n\\ninterface IUserStorage is IUserStorageRead{\\n    /**\\n        control data functions\\n     */\\n    function setUser(address _addr, uint _uid) external;\\n    function setUserOfID(address _addr, uint _uid) external;\\n    function setRefer(uint _uid, uint _rfid) external;\\n    function setVId(uint _uid, uint _v, uint _nowVId) external;\\n    function setOldVId(uint _uid, uint _v, uint _oldVId) external;\\n    function copyTargetUidVID(uint _uid, uint _targetUid) external;\\n    function bindNewVID(uint _uid, uint _v) external;\\n    function addTeamVCount(uint _uid, uint _v) external;\\n    function setLevel(uint _uid, uint _level) external;\\n    function setRegTime(uint _uid, uint _time) external;\\n    function setIDRegisted(uint _uid, bool _flag) external;\\n    function setTeamBonusIgnoreCondition(uint _uid, bool _flag) external;\\n\\n    function increaseUID() external;\\n\\n    function addDirect(uint _uid) external;\\n    function subDirect(uint _uid) external;\\n    function addFeat(uint _uid, uint _amount) external;\\n    function subFeat(uint _uid, uint _amount) external;\\n    function addTeamBonus(uint _uid, uint _amount) external;\\n    function addBatchVFeat(uint _uid, uint _featAmount) external;\\n\\n    // trige by invest first\\n    function recordDirect(uint _uid) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUserStorageRead.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IUserStorageRead {\\n    /**\\n        User address by UID\\n     */\\n    function userOfId(uint _uid) external view returns (address);\\n\\n    /**\\n        User's UID\\n     */\\n    function userId(address _addr) external view returns (uint);\\n\\n    /**\\n        UID check valid\\n     */\\n    function isValidId(uint _uid) external view returns (bool);\\n\\n    /**\\n        Check user is V\\n     */\\n    function isVUser(uint _uid) external view returns (bool);\\n    /**\\n        User V UID by user\\n     */\\n    function userVId(uint _uid, uint _v) external view returns (uint);\\n\\n    /**\\n        User V ids by num\\n     */\\n    function userVIds(uint _uid, uint _vs) external view returns (uint[] calldata);\\n\\n    /**\\n        User V Old by user\\n     */\\n    function userOldVId(uint _uid, uint _v) external view returns (uint);\\n\\n    /**\\n        User V Old by num\\n     */\\n    function userOldVIds(uint _uid, uint _vs) external view returns (uint[] calldata);\\n    /**\\n        User basic by id\\n     */\\n    function userBasicData(uint _uid) external view returns (uint _refId, uint _regTime, uint _level, bool _isValid);\\n\\n    /**\\n        Current ID\\n     */\\n    function currentId() external view returns (uint);\\n\\n    /**\\n        User team data by id\\n     */\\n    function userTeamsData(uint _uid) external view returns (uint _direct, uint _feat, uint _bonus, bool _ignore);\\n\\n    /**\\n        User team v count\\n     */\\n    function teamVCount(uint _uid, uint _v) external view returns (uint _count);\\n\\n    /**\\n        User team V counts by num\\n     */\\n    function teamVCounts(uint _uid, uint _vs) external view returns (uint[] calldata);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"car\",\"type\":\"uint256\"}],\"name\":\"MintCarEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"addCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPoolStock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_uid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"carRunning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"carTypeByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"carTypeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_uid\",\"type\":\"uint256\"}],\"name\":\"checkDividendUserFeats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"compareBackPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"comparePoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"currentPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"dayRecordMintPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"dayUserWeightTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"dayWeightTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"getCarPriceByType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"isEnoughStockByIndex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"mintCar\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"msgUid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"poolOutTxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_uid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"poolOutcome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"poolOutmint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"poolReleaseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"poolStockCheck\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recordDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_uid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"recordMintWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"removeCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"runDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setCarTypePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setCarTypes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_feats\",\"type\":\"uint256[]\"}],\"name\":\"setDaoFeats\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setDividendPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setDividendTechPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPMCSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPoolPlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_runDay\",\"type\":\"uint256\"}],\"name\":\"setRunDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setStarShip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setSwapCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTxFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startEngine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"startEngineByType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userJoinedMark\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GameControl", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}