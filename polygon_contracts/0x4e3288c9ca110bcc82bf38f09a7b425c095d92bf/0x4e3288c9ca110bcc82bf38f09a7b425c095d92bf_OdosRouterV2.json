{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.8;\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// https://github.com/Uniswap/permit2\r\n\r\n/// @title SignatureTransfer\r\n/// @notice Handles ERC20 token transfers through signature based actions\r\n/// @dev Requires user's token approval on the Permit2 contract\r\ninterface ISignatureTransfer {\r\n\r\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\r\n    struct TokenPermissions {\r\n        // ERC20 token address\r\n        address token;\r\n        // the maximum amount that can be spent\r\n        uint256 amount;\r\n    }\r\n\r\n    /// @notice The signed permit message for a single token transfer\r\n    struct PermitTransferFrom {\r\n        TokenPermissions permitted;\r\n        // a unique value for every token owner's signature to prevent signature replays\r\n        uint256 nonce;\r\n        // deadline on the permit signature\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Specifies the recipient address and amount for batched transfers.\r\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\r\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\r\n    struct SignatureTransferDetails {\r\n        // recipient address\r\n        address to;\r\n        // spender requested amount\r\n        uint256 requestedAmount;\r\n    }\r\n\r\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\r\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\r\n    /// @dev Note that a user still signs over a spender address\r\n    struct PermitBatchTransferFrom {\r\n        // the tokens and corresponding amounts permitted for a transfer\r\n        TokenPermissions[] permitted;\r\n        // a unique value for every token owner's signature to prevent signature replays\r\n        uint256 nonce;\r\n        // deadline on the permit signature\r\n        uint256 deadline;\r\n    }\r\n    /// @notice Transfers a token using a signed permit message\r\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\r\n    /// @param permit The permit data signed over by the owner\r\n    /// @param owner The owner of the tokens to transfer\r\n    /// @param transferDetails The spender's requested transfer details for the permitted token\r\n    /// @param signature The signature to verify\r\n    function permitTransferFrom(\r\n        PermitTransferFrom memory permit,\r\n        SignatureTransferDetails calldata transferDetails,\r\n        address owner,\r\n        bytes calldata signature\r\n    ) external;\r\n\r\n    /// @notice Transfers multiple tokens using a signed permit message\r\n    /// @param permit The permit data signed over by the owner\r\n    /// @param owner The owner of the tokens to transfer\r\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\r\n    /// @param signature The signature to verify\r\n    function permitTransferFrom(\r\n        PermitBatchTransferFrom memory permit,\r\n        SignatureTransferDetails[] calldata transferDetails,\r\n        address owner,\r\n        bytes calldata signature\r\n    ) external;\r\n}\r\n\r\n// @dev interface for interacting with an Odos executor\r\ninterface IOdosExecutor {\r\n  function executePath (\r\n    bytes calldata bytecode,\r\n    uint256[] memory inputAmount,\r\n    address msgSender\r\n  ) external payable;\r\n}\r\n\r\n/// @title Routing contract for Odos SOR\r\n/// @author Semiotic AI\r\n/// @notice Wrapper with security gaurentees around execution of arbitrary operations on user tokens\r\ncontract OdosRouterV2 is Ownable {\r\n  using SafeERC20 for IERC20;\r\n\r\n  /// @dev The zero address is uniquely used to represent eth since it is already\r\n  /// recognized as an invalid ERC20, and due to its gas efficiency\r\n  address constant _ETH = address(0);\r\n\r\n  /// @dev Address list where addresses can be cached for use when reading from storage is cheaper\r\n  // than reading from calldata. addressListStart is the storage slot of the first dynamic array element\r\n  uint256 private constant addressListStart = \r\n    80084422859880547211683076133703299733277748156566366325829078699459944778998;\r\n  address[] public addressList;\r\n\r\n  // @dev constants for managing referrals and fees\r\n  uint256 public constant REFERRAL_WITH_FEE_THRESHOLD = 1 << 31;\r\n  uint256 public constant FEE_DENOM = 1e18;\r\n\r\n  // @dev fee taken on multi-input and multi-output swaps instead of positive slippage\r\n  uint256 public swapMultiFee;\r\n\r\n  /// @dev Contains all information needed to describe the input and output for a swap\r\n  struct permit2Info {\r\n    address contractAddress;\r\n    uint256 nonce;\r\n    uint256 deadline;\r\n    bytes signature;\r\n  }\r\n  /// @dev Contains all information needed to describe the input and output for a swap\r\n  struct swapTokenInfo {\r\n    address inputToken;\r\n    uint256 inputAmount;\r\n    address inputReceiver;\r\n    address outputToken;\r\n    uint256 outputQuote;\r\n    uint256 outputMin;\r\n    address outputReceiver;\r\n  }\r\n  /// @dev Contains all information needed to describe an intput token for swapMulti\r\n  struct inputTokenInfo {\r\n    address tokenAddress;\r\n    uint256 amountIn;\r\n    address receiver;\r\n  }\r\n  /// @dev Contains all information needed to describe an output token for swapMulti\r\n  struct outputTokenInfo {\r\n    address tokenAddress;\r\n    uint256 relativeValue;\r\n    address receiver;\r\n  }\r\n  // @dev event for swapping one token for another\r\n  event Swap(\r\n    address sender,\r\n    uint256 inputAmount,\r\n    address inputToken,\r\n    uint256 amountOut,\r\n    address outputToken,\r\n    int256 slippage,\r\n    uint32 referralCode\r\n  );\r\n  /// @dev event for swapping multiple input and/or output tokens\r\n  event SwapMulti(\r\n    address sender,\r\n    uint256[] amountsIn,\r\n    address[] tokensIn,\r\n    uint256[] amountsOut,\r\n    address[] tokensOut,\r\n    uint32 referralCode\r\n  );\r\n  /// @dev Holds all information for a given referral\r\n  struct referralInfo {\r\n    uint64 referralFee;\r\n    address beneficiary;\r\n    bool registered;\r\n  }\r\n  /// @dev Register referral fee and information\r\n  mapping(uint32 => referralInfo) public referralLookup;\r\n\r\n  /// @dev Set the null referralCode as \"Unregistered\" with no additional fee\r\n  constructor() {\r\n    referralLookup[0].referralFee = 0;\r\n    referralLookup[0].beneficiary = address(0);\r\n    referralLookup[0].registered = true;\r\n\r\n    swapMultiFee = 5e14;\r\n  }\r\n  /// @dev Must exist in order for contract to receive eth\r\n  receive() external payable { }\r\n\r\n  /// @notice Custom decoder to swap with compact calldata for efficient execution on L2s\r\n  function swapCompact() \r\n    external\r\n    payable\r\n    returns (uint256)\r\n  {\r\n    swapTokenInfo memory tokenInfo;\r\n\r\n    address executor;\r\n    uint32 referralCode;\r\n    bytes calldata pathDefinition;\r\n    {\r\n      address msgSender = msg.sender;\r\n\r\n      assembly {\r\n        // Define function to load in token address, either from calldata or from storage\r\n        function getAddress(currPos) -> result, newPos {\r\n          let inputPos := shr(240, calldataload(currPos))\r\n\r\n          switch inputPos\r\n          // Reserve the null address as a special case that can be specified with 2 null bytes\r\n          case 0x0000 {\r\n            newPos := add(currPos, 2)\r\n          }\r\n          // This case means that the address is encoded in the calldata directly following the code\r\n          case 0x0001 {\r\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            newPos := add(currPos, 22)\r\n          }\r\n          // Otherwise we use the case to load in from the cached address list\r\n          default {\r\n            result := sload(add(addressListStart, sub(inputPos, 2)))\r\n            newPos := add(currPos, 2)\r\n          }\r\n        }\r\n        let result := 0\r\n        let pos := 4\r\n\r\n        // Load in the input and output token addresses\r\n        result, pos := getAddress(pos)\r\n        mstore(tokenInfo, result)\r\n\r\n        result, pos := getAddress(pos)\r\n        mstore(add(tokenInfo, 0x60), result)\r\n\r\n        // Load in the input amount - a 0 byte means the full balance is to be used\r\n        let inputAmountLength := shr(248, calldataload(pos))\r\n        pos := add(pos, 1)\r\n\r\n        if inputAmountLength {\r\n          mstore(add(tokenInfo, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\r\n          pos := add(pos, inputAmountLength)\r\n        }\r\n\r\n        // Load in the quoted output amount\r\n        let quoteAmountLength := shr(248, calldataload(pos))\r\n        pos := add(pos, 1)\r\n\r\n        let outputQuote := shr(mul(sub(32, quoteAmountLength), 8), calldataload(pos))\r\n        mstore(add(tokenInfo, 0x80), outputQuote)\r\n        pos := add(pos, quoteAmountLength)\r\n\r\n        // Load the slippage tolerance and use to get the minimum output amount\r\n        {\r\n          let slippageTolerance := shr(232, calldataload(pos))\r\n          mstore(add(tokenInfo, 0xA0), div(mul(outputQuote, sub(0xFFFFFF, slippageTolerance)), 0xFFFFFF))\r\n        }\r\n        pos := add(pos, 3)\r\n\r\n        // Load in the executor address\r\n        executor, pos := getAddress(pos)\r\n\r\n        // Load in the destination to send the input to - Zero denotes the executor\r\n        result, pos := getAddress(pos)\r\n        if eq(result, 0) { result := executor }\r\n        mstore(add(tokenInfo, 0x40), result)\r\n\r\n        // Load in the destination to send the output to - Zero denotes msg.sender\r\n        result, pos := getAddress(pos)\r\n        if eq(result, 0) { result := msgSender }\r\n        mstore(add(tokenInfo, 0xC0), result)\r\n\r\n        // Load in the referralCode\r\n        referralCode := shr(224, calldataload(pos))\r\n        pos := add(pos, 4)\r\n\r\n        // Set the offset and size for the pathDefinition portion of the msg.data\r\n        pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\r\n        pathDefinition.offset := add(pos, 1)\r\n      }\r\n    }\r\n    return _swapApproval(\r\n      tokenInfo,\r\n      pathDefinition,\r\n      executor,\r\n      referralCode\r\n    );\r\n  }\r\n  /// @notice Externally facing interface for swapping two tokens\r\n  /// @param tokenInfo All information about the tokens being swapped\r\n  /// @param pathDefinition Encoded path definition for executor\r\n  /// @param executor Address of contract that will execute the path\r\n  /// @param referralCode referral code to specify the source of the swap\r\n  function swap(\r\n    swapTokenInfo memory tokenInfo,\r\n    bytes calldata pathDefinition,\r\n    address executor,\r\n    uint32 referralCode\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256 amountOut)\r\n  {\r\n    return _swapApproval(\r\n      tokenInfo,\r\n      pathDefinition,\r\n      executor,\r\n      referralCode\r\n    );\r\n  }\r\n\r\n  /// @notice Internal function for initiating approval transfers\r\n  /// @param tokenInfo All information about the tokens being swapped\r\n  /// @param pathDefinition Encoded path definition for executor\r\n  /// @param executor Address of contract that will execute the path\r\n  /// @param referralCode referral code to specify the source of the swap\r\n  function _swapApproval(\r\n    swapTokenInfo memory tokenInfo,\r\n    bytes calldata pathDefinition,\r\n    address executor,\r\n    uint32 referralCode\r\n  )\r\n    internal\r\n    returns (uint256 amountOut)\r\n  {\r\n    if (tokenInfo.inputToken == _ETH) {\r\n      // Support rebasing tokens by allowing the user to trade the entire balance\r\n      if (tokenInfo.inputAmount == 0) {\r\n        tokenInfo.inputAmount = msg.value;\r\n      } else {\r\n        require(msg.value == tokenInfo.inputAmount, \"Wrong msg.value\");\r\n      }\r\n    }\r\n    else {\r\n      // Support rebasing tokens by allowing the user to trade the entire balance\r\n      if (tokenInfo.inputAmount == 0) {\r\n        tokenInfo.inputAmount = IERC20(tokenInfo.inputToken).balanceOf(msg.sender);\r\n      }\r\n      IERC20(tokenInfo.inputToken).safeTransferFrom(\r\n        msg.sender,\r\n        tokenInfo.inputReceiver,\r\n        tokenInfo.inputAmount\r\n      );\r\n    }\r\n    return _swap(\r\n      tokenInfo,\r\n      pathDefinition,\r\n      executor,\r\n      referralCode\r\n    );\r\n  }\r\n\r\n  /// @notice Externally facing interface for swapping two tokens\r\n  /// @param permit2 All additional info for Permit2 transfers\r\n  /// @param tokenInfo All information about the tokens being swapped\r\n  /// @param pathDefinition Encoded path definition for executor\r\n  /// @param executor Address of contract that will execute the path\r\n  /// @param referralCode referral code to specify the source of the swap\r\n  function swapPermit2(\r\n    permit2Info memory permit2,\r\n    swapTokenInfo memory tokenInfo,\r\n    bytes calldata pathDefinition,\r\n    address executor,\r\n    uint32 referralCode\r\n  )\r\n    external\r\n    returns (uint256 amountOut)\r\n  {\r\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\r\n      ISignatureTransfer.PermitTransferFrom(\r\n        ISignatureTransfer.TokenPermissions(\r\n          tokenInfo.inputToken,\r\n          tokenInfo.inputAmount\r\n        ),\r\n        permit2.nonce,\r\n        permit2.deadline\r\n      ),\r\n      ISignatureTransfer.SignatureTransferDetails(\r\n        tokenInfo.inputReceiver,\r\n        tokenInfo.inputAmount\r\n      ),\r\n      msg.sender,\r\n      permit2.signature\r\n    );\r\n    return _swap(\r\n      tokenInfo,\r\n      pathDefinition,\r\n      executor,\r\n      referralCode\r\n    );\r\n  }\r\n\r\n  /// @notice contains the main logic for swapping one token for another\r\n  /// Assumes input tokens have already been sent to their destinations and\r\n  /// that msg.value is set to expected ETH input value, or 0 for ERC20 input\r\n  /// @param tokenInfo All information about the tokens being swapped\r\n  /// @param pathDefinition Encoded path definition for executor\r\n  /// @param executor Address of contract that will execute the path\r\n  /// @param referralCode referral code to specify the source of the swap\r\n  function _swap(\r\n    swapTokenInfo memory tokenInfo,\r\n    bytes calldata pathDefinition,\r\n    address executor,\r\n    uint32 referralCode\r\n  )\r\n    internal\r\n    returns (uint256 amountOut)\r\n  {\r\n    // Check for valid output specifications\r\n    require(tokenInfo.outputMin <= tokenInfo.outputQuote, \"Minimum greater than quote\");\r\n    require(tokenInfo.outputMin > 0, \"Slippage limit too low\");\r\n    require(tokenInfo.inputToken != tokenInfo.outputToken, \"Arbitrage not supported\");\r\n\r\n    uint256 balanceBefore = _universalBalance(tokenInfo.outputToken);\r\n\r\n    // Delegate the execution of the path to the specified Odos Executor\r\n    uint256[] memory amountsIn = new uint256[](1);\r\n    amountsIn[0] = tokenInfo.inputAmount;\r\n\r\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\r\n\r\n    amountOut = _universalBalance(tokenInfo.outputToken) - balanceBefore;\r\n\r\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\r\n      referralInfo memory thisReferralInfo = referralLookup[referralCode];\r\n\r\n      _universalTransfer(\r\n        tokenInfo.outputToken,\r\n        thisReferralInfo.beneficiary,\r\n        amountOut * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\r\n      );\r\n      amountOut = amountOut * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\r\n    }\r\n    int256 slippage = int256(amountOut) - int256(tokenInfo.outputQuote);\r\n    if (slippage > 0) {\r\n      amountOut = tokenInfo.outputQuote;\r\n    }\r\n    require(amountOut >= tokenInfo.outputMin, \"Slippage Limit Exceeded\");\r\n\r\n    // Transfer out the final output to the end user\r\n    _universalTransfer(tokenInfo.outputToken, tokenInfo.outputReceiver, amountOut);\r\n\r\n    emit Swap(\r\n      msg.sender,\r\n      tokenInfo.inputAmount,\r\n      tokenInfo.inputToken,\r\n      amountOut,\r\n      tokenInfo.outputToken,\r\n      slippage,\r\n      referralCode\r\n    );\r\n  }\r\n\r\n  /// @notice Custom decoder to swapMulti with compact calldata for efficient execution on L2s\r\n  function swapMultiCompact() \r\n    external\r\n    payable\r\n    returns (uint256[] memory amountsOut)\r\n  {\r\n    address executor;\r\n    uint256 valueOutMin;\r\n\r\n    inputTokenInfo[] memory inputs;\r\n    outputTokenInfo[] memory outputs;\r\n\r\n    uint256 pos = 6;\r\n    {\r\n      address msgSender = msg.sender;\r\n\r\n      uint256 numInputs;\r\n      uint256 numOutputs;\r\n\r\n      assembly {\r\n        numInputs := shr(248, calldataload(4))\r\n        numOutputs := shr(248, calldataload(5))\r\n      }\r\n      inputs = new inputTokenInfo[](numInputs);\r\n      outputs = new outputTokenInfo[](numOutputs);\r\n\r\n      assembly {\r\n        // Define function to load in token address, either from calldata or from storage\r\n        function getAddress(currPos) -> result, newPos {\r\n          let inputPos := shr(240, calldataload(currPos))\r\n\r\n          switch inputPos\r\n          // Reserve the null address as a special case that can be specified with 2 null bytes\r\n          case 0x0000 {\r\n            newPos := add(currPos, 2)\r\n          }\r\n          // This case means that the address is encoded in the calldata directly following the code\r\n          case 0x0001 {\r\n            result := and(shr(80, calldataload(currPos)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n            newPos := add(currPos, 22)\r\n          }\r\n          // Otherwise we use the case to load in from the cached address list\r\n          default {\r\n            result := sload(add(addressListStart, sub(inputPos, 2)))\r\n            newPos := add(currPos, 2)\r\n          }\r\n        }\r\n        executor, pos := getAddress(pos)\r\n\r\n        // Load in the quoted output amount\r\n        let outputMinAmountLength := shr(248, calldataload(pos))\r\n        pos := add(pos, 1)\r\n\r\n        valueOutMin := shr(mul(sub(32, outputMinAmountLength), 8), calldataload(pos))\r\n        pos := add(pos, outputMinAmountLength)\r\n\r\n        let result := 0\r\n        let memPos := 0\r\n\r\n        for { let element := 0 } lt(element, numInputs) { element := add(element, 1) }\r\n        {\r\n          memPos := mload(add(inputs, add(mul(element, 0x20), 0x20)))\r\n\r\n          // Load in the token address\r\n          result, pos := getAddress(pos)\r\n          mstore(memPos, result)\r\n\r\n          // Load in the input amount - a 0 byte means the full balance is to be used\r\n          let inputAmountLength := shr(248, calldataload(pos))\r\n          pos := add(pos, 1)\r\n\r\n          if inputAmountLength {\r\n             mstore(add(memPos, 0x20), shr(mul(sub(32, inputAmountLength), 8), calldataload(pos)))\r\n            pos := add(pos, inputAmountLength)\r\n          }\r\n          result, pos := getAddress(pos)\r\n          if eq(result, 0) { result := executor }\r\n\r\n          mstore(add(memPos, 0x40), result)\r\n        }\r\n        for { let element := 0 } lt(element, numOutputs) { element := add(element, 1) }\r\n        {\r\n          memPos := mload(add(outputs, add(mul(element, 0x20), 0x20)))\r\n\r\n          // Load in the token address\r\n          result, pos := getAddress(pos)\r\n          mstore(memPos, result)\r\n\r\n          // Load in the quoted output amount\r\n          let outputAmountLength := shr(248, calldataload(pos))\r\n          pos := add(pos, 1)\r\n\r\n          mstore(add(memPos, 0x20), shr(mul(sub(32, outputAmountLength), 8), calldataload(pos)))\r\n          pos := add(pos, outputAmountLength)\r\n\r\n          result, pos := getAddress(pos)\r\n          if eq(result, 0) { result := msgSender }\r\n\r\n          mstore(add(memPos, 0x40), result)\r\n        }\r\n      }\r\n    }\r\n    uint32 referralCode;\r\n    bytes calldata pathDefinition;\r\n\r\n    assembly {\r\n      // Load in the referralCode\r\n      referralCode := shr(224, calldataload(pos))\r\n      pos := add(pos, 4)\r\n\r\n      // Set the offset and size for the pathDefinition portion of the msg.data\r\n      pathDefinition.length := mul(shr(248, calldataload(pos)), 32)\r\n      pathDefinition.offset := add(pos, 1)\r\n    }\r\n    return _swapMultiApproval(\r\n      inputs,\r\n      outputs,\r\n      valueOutMin,\r\n      pathDefinition,\r\n      executor,\r\n      referralCode\r\n    );\r\n  }\r\n\r\n  /// @notice Externally facing interface for swapping between two sets of tokens\r\n  /// @param inputs list of input token structs for the path being executed\r\n  /// @param outputs list of output token structs for the path being executed\r\n  /// @param valueOutMin minimum amount of value out the user will accept\r\n  /// @param pathDefinition Encoded path definition for executor\r\n  /// @param executor Address of contract that will execute the path\r\n  /// @param referralCode referral code to specify the source of the swap\r\n  function swapMulti(\r\n    inputTokenInfo[] memory inputs,\r\n    outputTokenInfo[] memory outputs,\r\n    uint256 valueOutMin,\r\n    bytes calldata pathDefinition,\r\n    address executor,\r\n    uint32 referralCode\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256[] memory amountsOut)\r\n  {\r\n    return _swapMultiApproval(\r\n      inputs,\r\n      outputs,\r\n      valueOutMin,\r\n      pathDefinition,\r\n      executor,\r\n      referralCode\r\n    );\r\n  }\r\n\r\n  /// @notice Internal logic for swapping between two sets of tokens with approvals\r\n  /// @param inputs list of input token structs for the path being executed\r\n  /// @param outputs list of output token structs for the path being executed\r\n  /// @param valueOutMin minimum amount of value out the user will accept\r\n  /// @param pathDefinition Encoded path definition for executor\r\n  /// @param executor Address of contract that will execute the path\r\n  /// @param referralCode referral code to specify the source of the swap\r\n  function _swapMultiApproval(\r\n    inputTokenInfo[] memory inputs,\r\n    outputTokenInfo[] memory outputs,\r\n    uint256 valueOutMin,\r\n    bytes calldata pathDefinition,\r\n    address executor,\r\n    uint32 referralCode\r\n  )\r\n    internal\r\n    returns (uint256[] memory amountsOut)\r\n  {\r\n    // If input amount is still 0 then that means the maximum possible input is to be used\r\n    uint256 expected_msg_value = 0;\r\n\r\n    for (uint256 i = 0; i < inputs.length; i++) {\r\n      if (inputs[i].tokenAddress == _ETH) {\r\n        if (inputs[i].amountIn == 0) {\r\n          inputs[i].amountIn = msg.value;\r\n        }\r\n        expected_msg_value = inputs[i].amountIn;\r\n      } \r\n      else {\r\n        if (inputs[i].amountIn == 0) {\r\n          inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\r\n        }\r\n        IERC20(inputs[i].tokenAddress).safeTransferFrom(\r\n          msg.sender,\r\n          inputs[i].receiver,\r\n          inputs[i].amountIn\r\n        );\r\n      }\r\n    }\r\n    require(msg.value == expected_msg_value, \"Wrong msg.value\");\r\n\r\n    return _swapMulti(\r\n      inputs,\r\n      outputs,\r\n      valueOutMin,\r\n      pathDefinition,\r\n      executor,\r\n      referralCode\r\n    );\r\n  }\r\n\r\n  /// @notice Externally facing interface for swapping between two sets of tokens with Permit2\r\n  /// @param permit2 All additional info for Permit2 transfers\r\n  /// @param inputs list of input token structs for the path being executed\r\n  /// @param outputs list of output token structs for the path being executed\r\n  /// @param valueOutMin minimum amount of value out the user will accept\r\n  /// @param pathDefinition Encoded path definition for executor\r\n  /// @param executor Address of contract that will execute the path\r\n  /// @param referralCode referral code to specify the source of the swap\r\n  function swapMultiPermit2(\r\n    permit2Info memory permit2,\r\n    inputTokenInfo[] memory inputs,\r\n    outputTokenInfo[] memory outputs,\r\n    uint256 valueOutMin,\r\n    bytes calldata pathDefinition,\r\n    address executor,\r\n    uint32 referralCode\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256[] memory amountsOut)\r\n  {\r\n    ISignatureTransfer.PermitBatchTransferFrom memory permit;\r\n    ISignatureTransfer.SignatureTransferDetails[] memory transferDetails;\r\n    {\r\n      uint256 permit_length = msg.value > 0 ? inputs.length - 1 : inputs.length;\r\n\r\n      permit = ISignatureTransfer.PermitBatchTransferFrom(\r\n        new ISignatureTransfer.TokenPermissions[](permit_length),\r\n        permit2.nonce,\r\n        permit2.deadline\r\n      );\r\n      transferDetails = \r\n        new ISignatureTransfer.SignatureTransferDetails[](permit_length);\r\n    }\r\n    {\r\n      uint256 expected_msg_value = 0;\r\n      for (uint256 i = 0; i < inputs.length; i++) {\r\n\r\n        if (inputs[i].tokenAddress == _ETH) {\r\n          if (inputs[i].amountIn == 0) {\r\n            inputs[i].amountIn = msg.value;\r\n          }\r\n          expected_msg_value = inputs[i].amountIn;\r\n        }\r\n        else {\r\n          if (inputs[i].amountIn == 0) {\r\n            inputs[i].amountIn = IERC20(inputs[i].tokenAddress).balanceOf(msg.sender);\r\n          }\r\n          uint256 permit_index = expected_msg_value == 0 ? i : i - 1;\r\n\r\n          permit.permitted[permit_index].token = inputs[i].tokenAddress;\r\n          permit.permitted[permit_index].amount = inputs[i].amountIn;\r\n\r\n          transferDetails[permit_index].to = inputs[i].receiver;\r\n          transferDetails[permit_index].requestedAmount = inputs[i].amountIn;\r\n        }\r\n      }\r\n      require(msg.value == expected_msg_value, \"Wrong msg.value\");\r\n    }\r\n    ISignatureTransfer(permit2.contractAddress).permitTransferFrom(\r\n      permit,\r\n      transferDetails,\r\n      msg.sender,\r\n      permit2.signature\r\n    );\r\n    return _swapMulti(\r\n      inputs,\r\n      outputs,\r\n      valueOutMin,\r\n      pathDefinition,\r\n      executor,\r\n      referralCode\r\n    );\r\n  }\r\n\r\n  /// @notice contains the main logic for swapping between two sets of tokens\r\n  /// assumes that inputs have already been sent to the right location and msg.value\r\n  /// is set correctly to be 0 for no native input and match native inpuit otherwise\r\n  /// @param inputs list of input token structs for the path being executed\r\n  /// @param outputs list of output token structs for the path being executed\r\n  /// @param valueOutMin minimum amount of value out the user will accept\r\n  /// @param pathDefinition Encoded path definition for executor\r\n  /// @param executor Address of contract that will execute the path\r\n  /// @param referralCode referral code to specify the source of the swap\r\n  function _swapMulti(\r\n    inputTokenInfo[] memory inputs,\r\n    outputTokenInfo[] memory outputs,\r\n    uint256 valueOutMin,\r\n    bytes calldata pathDefinition,\r\n    address executor,\r\n    uint32 referralCode\r\n  )\r\n    internal\r\n    returns (uint256[] memory amountsOut)\r\n  {\r\n    // Check for valid output specifications\r\n    require(valueOutMin > 0, \"Slippage limit too low\");\r\n\r\n    // Extract arrays of input amount values and tokens from the inputs struct list\r\n    uint256[] memory amountsIn = new uint256[](inputs.length);\r\n    address[] memory tokensIn = new address[](inputs.length);\r\n\r\n    // Check input specification validity and transfer input tokens to executor\r\n    {\r\n      for (uint256 i = 0; i < inputs.length; i++) {\r\n\r\n        amountsIn[i] = inputs[i].amountIn;\r\n        tokensIn[i] = inputs[i].tokenAddress;\r\n\r\n        for (uint256 j = 0; j < i; j++) {\r\n          require(\r\n            inputs[i].tokenAddress != inputs[j].tokenAddress,\r\n            \"Duplicate source tokens\"\r\n          );\r\n        }\r\n        for (uint256 j = 0; j < outputs.length; j++) {\r\n          require(\r\n            inputs[i].tokenAddress != outputs[j].tokenAddress,\r\n            \"Arbitrage not supported\"\r\n          );\r\n        }\r\n      }\r\n    }\r\n    // Check outputs for duplicates and record balances before swap\r\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\r\n    for (uint256 i = 0; i < outputs.length; i++) {\r\n      for (uint256 j = 0; j < i; j++) {\r\n        require(\r\n          outputs[i].tokenAddress != outputs[j].tokenAddress,\r\n          \"Duplicate destination tokens\"\r\n        );\r\n      }\r\n      balancesBefore[i] = _universalBalance(outputs[i].tokenAddress);\r\n    }\r\n    // Delegate the execution of the path to the specified Odos Executor\r\n    IOdosExecutor(executor).executePath{value: msg.value}(pathDefinition, amountsIn, msg.sender);\r\n\r\n    referralInfo memory thisReferralInfo;\r\n    if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\r\n      thisReferralInfo = referralLookup[referralCode];\r\n    }\r\n\r\n    {\r\n      uint256 valueOut;\r\n      uint256 _swapMultiFee = swapMultiFee;\r\n      amountsOut = new uint256[](outputs.length);\r\n\r\n      for (uint256 i = 0; i < outputs.length; i++) {\r\n        // Record the destination token balance before the path is executed\r\n        amountsOut[i] = _universalBalance(outputs[i].tokenAddress) - balancesBefore[i];\r\n\r\n        // Remove the swapMulti Fee (taken instead of positive slippage)\r\n        amountsOut[i] = amountsOut[i] * (FEE_DENOM - _swapMultiFee) / FEE_DENOM;\r\n\r\n        if (referralCode > REFERRAL_WITH_FEE_THRESHOLD) {\r\n          _universalTransfer(\r\n            outputs[i].tokenAddress,\r\n            thisReferralInfo.beneficiary,\r\n            amountsOut[i] * thisReferralInfo.referralFee * 8 / (FEE_DENOM * 10)\r\n          );\r\n          amountsOut[i] = amountsOut[i] * (FEE_DENOM - thisReferralInfo.referralFee) / FEE_DENOM;\r\n        }\r\n        _universalTransfer(\r\n          outputs[i].tokenAddress,\r\n          outputs[i].receiver,\r\n          amountsOut[i]\r\n        );\r\n        // Add the amount out sent to the user to the total value of output\r\n        valueOut += amountsOut[i] * outputs[i].relativeValue;\r\n      }\r\n      require(valueOut >= valueOutMin, \"Slippage Limit Exceeded\");\r\n    }\r\n    address[] memory tokensOut = new address[](outputs.length);\r\n    for (uint256 i = 0; i < outputs.length; i++) {\r\n        tokensOut[i] = outputs[i].tokenAddress;\r\n    }\r\n    emit SwapMulti(\r\n      msg.sender,\r\n      amountsIn,\r\n      tokensIn,\r\n      amountsOut,\r\n      tokensOut,\r\n      referralCode\r\n    );\r\n  }\r\n\r\n  /// @notice Register a new referrer, optionally with an additional swap fee\r\n  /// @param _referralCode the referral code to use for the new referral\r\n  /// @param _referralFee the additional fee to add to each swap using this code\r\n  /// @param _beneficiary the address to send the referral's share of fees to\r\n  function registerReferralCode(\r\n    uint32 _referralCode,\r\n    uint64 _referralFee,\r\n    address _beneficiary\r\n  )\r\n    external\r\n  {\r\n    // Do not allow for any overwriting of referral codes\r\n    require(!referralLookup[_referralCode].registered, \"Code in use\");\r\n\r\n    // Maximum additional fee a referral can set is 2%\r\n    require(_referralFee <= FEE_DENOM / 50, \"Fee too high\");\r\n\r\n    // Reserve the lower half of referral codes to be informative only\r\n    if (_referralCode <= REFERRAL_WITH_FEE_THRESHOLD) {\r\n      require(_referralFee == 0, \"Invalid fee for code\");\r\n    } else {\r\n      require(_referralFee > 0, \"Invalid fee for code\");\r\n\r\n      // Make sure the beneficiary is not the null address if there is a fee\r\n      require(_beneficiary != address(0), \"Null beneficiary\");\r\n    }\r\n    referralLookup[_referralCode].referralFee = _referralFee;\r\n    referralLookup[_referralCode].beneficiary = _beneficiary;\r\n    referralLookup[_referralCode].registered = true;\r\n  }\r\n\r\n  /// @notice Set the fee used for swapMulti\r\n  /// @param _swapMultiFee the new fee for swapMulti\r\n  function setSwapMultiFee(\r\n    uint256 _swapMultiFee\r\n  ) \r\n    external\r\n    onlyOwner\r\n  {\r\n    // Maximum swapMultiFee that can be set is 0.5%\r\n    require(_swapMultiFee <= FEE_DENOM / 200, \"Fee too high\");\r\n    swapMultiFee = _swapMultiFee;\r\n  }\r\n\r\n  /// @notice Push new addresses to the cached address list for when storage is cheaper than calldata\r\n  /// @param addresses list of addresses to be added to the cached address list\r\n  function writeAddressList(\r\n    address[] calldata addresses\r\n  ) \r\n    external\r\n    onlyOwner\r\n  {\r\n    for (uint256 i = 0; i < addresses.length; i++) {\r\n      addressList.push(addresses[i]);\r\n    }\r\n  }\r\n\r\n  /// @notice Allows the owner to transfer funds held by the router contract\r\n  /// @param tokens List of token address to be transferred\r\n  /// @param amounts List of amounts of each token to be transferred\r\n  /// @param dest Address to which the funds should be sent\r\n  function transferRouterFunds(\r\n    address[] calldata tokens,\r\n    uint256[] calldata amounts,\r\n    address dest\r\n  )\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(tokens.length == amounts.length, \"Invalid funds transfer\");\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      _universalTransfer(\r\n        tokens[i], \r\n        dest, \r\n        amounts[i] == 0 ? _universalBalance(tokens[i]) : amounts[i]\r\n      );\r\n    }\r\n  }\r\n  /// @notice Directly swap funds held in router \r\n  /// @param inputs list of input token structs for the path being executed\r\n  /// @param outputs list of output token structs for the path being executed\r\n  /// @param valueOutMin minimum amount of value out the user will accept\r\n  /// @param pathDefinition Encoded path definition for executor\r\n  /// @param executor Address of contract that will execute the path\r\n  function swapRouterFunds(\r\n    inputTokenInfo[] memory inputs,\r\n    outputTokenInfo[] memory outputs,\r\n    uint256 valueOutMin,\r\n    bytes calldata pathDefinition,\r\n    address executor\r\n  )\r\n    external\r\n    onlyOwner\r\n    returns (uint256[] memory amountsOut)\r\n  {\r\n    uint256[] memory amountsIn = new uint256[](inputs.length);\r\n    address[] memory tokensIn = new address[](inputs.length);\r\n\r\n    for (uint256 i = 0; i < inputs.length; i++) {\r\n      tokensIn[i] = inputs[i].tokenAddress;\r\n\r\n      amountsIn[i] = inputs[i].amountIn == 0 ? \r\n        _universalBalance(tokensIn[i]) : inputs[i].amountIn;\r\n\r\n      _universalTransfer(\r\n        tokensIn[i],\r\n        inputs[i].receiver,\r\n        amountsIn[i]\r\n      );\r\n    }\r\n    // Check outputs for duplicates and record balances before swap\r\n    uint256[] memory balancesBefore = new uint256[](outputs.length);\r\n    address[] memory tokensOut = new address[](outputs.length);\r\n    for (uint256 i = 0; i < outputs.length; i++) {\r\n      tokensOut[i] = outputs[i].tokenAddress;\r\n      balancesBefore[i] = _universalBalance(tokensOut[i]);\r\n    }\r\n    // Delegate the execution of the path to the specified Odos Executor\r\n    IOdosExecutor(executor).executePath{value: 0}(pathDefinition, amountsIn, msg.sender);\r\n\r\n    uint256 valueOut;\r\n    amountsOut = new uint256[](outputs.length);\r\n    for (uint256 i = 0; i < outputs.length; i++) {\r\n\r\n      // Record the destination token balance before the path is executed\r\n      amountsOut[i] = _universalBalance(tokensOut[i]) - balancesBefore[i];\r\n\r\n      _universalTransfer(\r\n        outputs[i].tokenAddress,\r\n        outputs[i].receiver,\r\n        amountsOut[i]\r\n      );\r\n      // Add the amount out sent to the user to the total value of output\r\n      valueOut += amountsOut[i] * outputs[i].relativeValue;\r\n    }\r\n    require(valueOut >= valueOutMin, \"Slippage Limit Exceeded\");\r\n\r\n    emit SwapMulti(\r\n      msg.sender,\r\n      amountsIn,\r\n      tokensIn,\r\n      amountsOut,\r\n      tokensOut,\r\n      0\r\n    );\r\n  }\r\n  /// @notice helper function to get balance of ERC20 or native coin for this contract\r\n  /// @param token address of the token to check, null for native coin\r\n  /// @return balance of specified coin or token\r\n  function _universalBalance(address token) private view returns(uint256) {\r\n    if (token == _ETH) {\r\n      return address(this).balance;\r\n    } else {\r\n      return IERC20(token).balanceOf(address(this));\r\n    }\r\n  }\r\n  /// @notice helper function to transfer ERC20 or native coin\r\n  /// @param token address of the token being transferred, null for native coin\r\n  /// @param to address to transfer to\r\n  /// @param amount to transfer\r\n  function _universalTransfer(address token, address to, uint256 amount) private {\r\n    if (token == _ETH) {\r\n      (bool success,) = payable(to).call{value: amount}(\"\");\r\n      require(success, \"ETH transfer failed\");\r\n    } else {\r\n      IERC20(token).safeTransfer(to, amount);\r\n    }\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"slippage\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"referralCode\",\"type\":\"uint32\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokensIn\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokensOut\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"referralCode\",\"type\":\"uint32\"}],\"name\":\"SwapMulti\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DENOM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL_WITH_FEE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"referralLookup\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"referralFee\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_referralCode\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"_referralFee\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"registerReferralCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapMultiFee\",\"type\":\"uint256\"}],\"name\":\"setSwapMultiFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inputReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputQuote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outputReceiver\",\"type\":\"address\"}],\"internalType\":\"struct OdosRouterV2.swapTokenInfo\",\"name\":\"tokenInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"pathDefinition\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"referralCode\",\"type\":\"uint32\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapCompact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"internalType\":\"struct OdosRouterV2.inputTokenInfo[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relativeValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"internalType\":\"struct OdosRouterV2.outputTokenInfo[]\",\"name\":\"outputs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"valueOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"pathDefinition\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"referralCode\",\"type\":\"uint32\"}],\"name\":\"swapMulti\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapMultiCompact\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapMultiFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct OdosRouterV2.permit2Info\",\"name\":\"permit2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"internalType\":\"struct OdosRouterV2.inputTokenInfo[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relativeValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"internalType\":\"struct OdosRouterV2.outputTokenInfo[]\",\"name\":\"outputs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"valueOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"pathDefinition\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"referralCode\",\"type\":\"uint32\"}],\"name\":\"swapMultiPermit2\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct OdosRouterV2.permit2Info\",\"name\":\"permit2\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inputReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputQuote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outputReceiver\",\"type\":\"address\"}],\"internalType\":\"struct OdosRouterV2.swapTokenInfo\",\"name\":\"tokenInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"pathDefinition\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"referralCode\",\"type\":\"uint32\"}],\"name\":\"swapPermit2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"internalType\":\"struct OdosRouterV2.inputTokenInfo[]\",\"name\":\"inputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relativeValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"internalType\":\"struct OdosRouterV2.outputTokenInfo[]\",\"name\":\"outputs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"valueOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"pathDefinition\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"swapRouterFunds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"}],\"name\":\"transferRouterFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"writeAddressList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OdosRouterV2", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f7eba796625aab166cbc2f47818bfb461215dfacdf5852a17be46345c52fdc12"}