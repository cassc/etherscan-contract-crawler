{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v1/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/v1/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nabstract contract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"only owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/LinearReleaser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../v1/utils/Ownable.sol\\\";\\nimport \\\"../v1/interfaces/IERC20.sol\\\";\\nimport \\\"../v1/libraries/TransferHelper.sol\\\";\\n\\ncontract LinearReleaser is Ownable {\\n    event LockingInfoAdded(address indexed recipient, uint256 totalAmount, uint256 startTime, uint256 endTime, uint256 updateTime);\\n    event Claimed(address indexed recipient, uint256 amount, uint256 updateTime);\\n\\n    struct LockingInfo {\\n        uint256 totalAmount;\\n        uint256 claimedAmount;\\n        uint256 startTime;\\n        uint256 endTime;\\n        uint256 updateTime;\\n    }\\n\\n    address public token;\\n    mapping(address => LockingInfo) private lockingInfoMap;\\n\\n    constructor(address token_) {\\n        token = token_;\\n    }\\n\\n    function withdraw(address recipient, uint256 amount) external onlyOwner {\\n        require(recipient != address(0), \\\"zero address\\\");\\n        require(amount > 0, \\\"zero amount\\\");\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        require(amount <= balance, \\\"not enough balance\\\");\\n        TransferHelper.safeTransfer(token, recipient, amount);\\n    }\\n\\n    function getLockingInfo(address recipient) public view returns (\\n        uint256 totalAmount, \\n        uint256 claimedAmount,\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256 updateTime\\n    ) {\\n        LockingInfo memory lockingInfo = lockingInfoMap[recipient];\\n        totalAmount = lockingInfo.totalAmount;\\n        claimedAmount = lockingInfo.claimedAmount;\\n        startTime = lockingInfo.startTime;\\n        endTime = lockingInfo.endTime;\\n        updateTime = lockingInfo.updateTime;\\n    }\\n\\n    function addLockingInfo(\\n        address recipient,\\n        uint256 totalAmount,\\n        uint256 startTime,\\n        uint256 duration\\n    ) external onlyOwner {\\n        require(lockingInfoMap[recipient].totalAmount == 0, \\\"already added\\\");\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        require(balance >= totalAmount, \\\"not enough balance\\\");\\n        LockingInfo memory lockingInfo = LockingInfo({\\n            totalAmount: totalAmount,\\n            claimedAmount: 0,\\n            startTime: startTime,\\n            endTime: startTime + duration,\\n            updateTime: block.timestamp\\n        });\\n        lockingInfoMap[recipient] = lockingInfo;\\n        emit LockingInfoAdded(recipient, totalAmount, startTime, lockingInfo.endTime, lockingInfo.updateTime);\\n    }\\n\\n    function claimSingle(address recipient) public returns (uint256 amount) {\\n        (\\n            uint256 totalAmount, \\n            uint256 claimedAmount,\\n            uint256 startTime,\\n            uint256 endTime,\\n        ) = getLockingInfo(recipient);\\n        if (claimedAmount >= totalAmount) return amount;\\n\\n        uint256 currentTime = block.timestamp;\\n        uint256 pastTime = currentTime - startTime;\\n        if (currentTime >= endTime) {\\n            pastTime = endTime - startTime;\\n        }\\n        amount = pastTime * totalAmount / (endTime - startTime) - claimedAmount;\\n        lockingInfoMap[recipient].claimedAmount += amount;\\n        lockingInfoMap[recipient].updateTime = block.timestamp;\\n        TransferHelper.safeTransfer(token, recipient, amount);\\n        emit Claimed(recipient, amount, block.timestamp);\\n    }\\n\\n    function claimSingleWithAmount(address recipient, uint256 claimAmount) public returns (uint256 amount) {\\n        (\\n            uint256 totalAmount, \\n            uint256 claimedAmount,\\n            uint256 startTime,\\n            uint256 endTime,\\n        ) = getLockingInfo(recipient);\\n        if (claimedAmount >= totalAmount) return amount;\\n\\n        uint256 currentTime = block.timestamp;\\n        uint256 pastTime = currentTime - startTime;\\n        if (currentTime >= endTime) {\\n            pastTime = endTime - startTime;\\n        }\\n        uint256 claimable = pastTime * totalAmount / (endTime - startTime) - claimedAmount;\\n        require(claimable >= claimAmount, \\\"claimAmount over claimable\\\");\\n        amount = claimAmount;\\n\\n        lockingInfoMap[recipient].claimedAmount += amount;\\n        lockingInfoMap[recipient].updateTime = block.timestamp;\\n        TransferHelper.safeTransfer(token, recipient, amount);\\n        emit Claimed(recipient, amount, block.timestamp);\\n    }\\n\\n    function batchClaim(address[] memory recipients) external returns (uint256[] memory amounts) {\\n        uint256 length = recipients.length;\\n        amounts = new uint256[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            amounts[i] = claimSingle(recipients[i]);\\n        }\\n    }\\n\\n    function batchClaimWithAmounts(address[] memory recipients, uint256[] memory claimAmounts) external returns (uint256[] memory amounts) {\\n        require(recipients.length == claimAmounts.length, \\\"length not the same\\\");\\n        uint256 length = recipients.length;\\n        amounts = new uint256[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            amounts[i] = claimSingleWithAmount(recipients[i], claimAmounts[i]);\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"name\":\"LockingInfoAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"addLockingInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"}],\"name\":\"batchClaim\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"claimAmounts\",\"type\":\"uint256[]\"}],\"name\":\"batchClaimWithAmounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"claimSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"claimSingleWithAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"getLockingInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LinearReleaser", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "0000000000000000000000008803972ab1acd3fc7c8cca3fdefab0b8af373533", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}