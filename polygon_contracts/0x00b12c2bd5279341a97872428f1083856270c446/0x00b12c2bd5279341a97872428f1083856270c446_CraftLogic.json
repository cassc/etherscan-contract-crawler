{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/CraftLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n//                 ____    ____\\n//                /\\\\___\\\\  /\\\\___\\\\\\n//       ________/ /   /_ \\\\/___/\\n//      /\\\\_______\\\\/   /__\\\\___\\\\\\n//     / /       /       /   /\\n//    / /   /   /   /   /   /\\n//   / /   /___/___/___/___/\\n//  / /   /\\n//  \\\\/___/\\n\\npragma solidity 0.8.19;\\n\\nimport { ERC2771Context } from \\\"@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\\\";\\n\\nimport { BaseCraftLogic } from \\\"./utils/BaseCraftLogic.sol\\\";\\n\\n/// @title CraftLogic\\n/// @dev The CraftLogic smart contract enables the creation, update, and execution of crafting recipes in PHI\\n// It also supports actions performed on behalf of users by a trusted relay service.\\ncontract CraftLogic is BaseCraftLogic {\\n    /* -------------------------------------------------------------------------- */\\n    /*                               INITIALIZATION                               */\\n    /* -------------------------------------------------------------------------- */\\n    constructor(address trustedForwarder, address _gelatoRelay) ERC2771Context(trustedForwarder) {\\n        if (_gelatoRelay == address(0)) revert InvalidAddress(\\\"gelatoRelay address can't be 0\\\");\\n\\n        gelatoRelay = _gelatoRelay;\\n    }\\n\\n    /**\\n     * @dev This function creates a new recipe. It checks if the recipe already exists,\\n     * ensures that the materials and artifacts arrays have at least one element,\\n     * and emits a RecipeCreated event.\\n     *\\n     * Requirements:\\n     * - The caller must be the owner.\\n     * - The materials and artifacts arrays must not be empty.\\n     *\\n     * @param materials the materials required for the recipe\\n     * @param artifacts the artifacts produced by the recipe\\n     * @param catalyst the catalyst required for the recipe\\n     */\\n    function createRecipe(\\n        Material[] calldata materials,\\n        Artifacts[] calldata artifacts,\\n        Catalyst calldata catalyst\\n    )\\n        external\\n        override\\n        onlyOwner\\n    {\\n        uint256 id = getRecipeNumber() + 1;\\n        _createOrUpdateRecipe(id, materials, artifacts, catalyst, true, false);\\n        ++recipeCount;\\n    }\\n\\n    /**\\n     * @dev This function updates an existing recipe. It checks if the recipe exists,\\n     * ensures that the materials and artifacts arrays have at least one element,\\n     * and emits a RecipeUpdated event.\\n     *\\n     * Requirements:\\n     * - The caller must be the owner.\\n     * - The materials and artifacts arrays must not be empty.\\n     *\\n     * @param recipeId the ID of the recipe to update\\n     * @param materials the materials required for the recipe\\n     * @param artifacts the artifacts produced by the recipe\\n     * @param catalyst the catalyst required for the recipe\\n     * @param active the status of the recipe\\n     */\\n    function updateRecipe(\\n        uint256 recipeId,\\n        Material[] memory materials,\\n        Artifacts[] memory artifacts,\\n        Catalyst calldata catalyst,\\n        bool active\\n    )\\n        external\\n        override\\n        onlyOwner\\n    {\\n        _createOrUpdateRecipe(recipeId, materials, artifacts, catalyst, active, true);\\n    }\\n\\n    /**\\n     * @dev This function changes the status of an existing recipe. It checks if the recipe exists,\\n     * and emits a ChangeRecipeStatus event.\\n     *\\n     * Requirements:\\n     * - The caller must be the owner.\\n     *\\n     * @param recipeId the ID of the recipe to update\\n     * @param active the new status of the recipe\\n     */\\n    function changeRecipeStatus(uint256 recipeId, bool active) external override onlyOwner {\\n        // Check if the recipe already exists\\n        if (recipes[recipeId].id != recipeId) revert NonExistentRecipe(recipeId);\\n\\n        // Update\\n        Recipe storage recipe = recipes[recipeId];\\n        recipe.active = active;\\n        // Emit the ChangeRecipeStatus event\\n        emit ChangeRecipeStatus(recipeId, active, _msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\n// based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\\nabstract contract ERC2771Context {\\n    address private immutable _trustedForwarder;\\n\\n    constructor(address trustedForwarder) {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder)\\n        public\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/BaseCraftLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n//                 ____    ____\\n//                /\\\\___\\\\  /\\\\___\\\\\\n//       ________/ /   /_ \\\\/___/\\n//      /\\\\_______\\\\/   /__\\\\___\\\\\\n//     / /       /       /   /\\n//    / /   /   /   /   /   /\\n//   / /   /___/___/___/___/\\n//  / /   /\\n//  \\\\/___/\\n\\npragma solidity 0.8.19;\\n\\nimport { ERC2771Context } from \\\"@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\\\";\\nimport { MultiOwner } from \\\"../utils/MultiOwner.sol\\\";\\nimport { ReentrancyGuard } from \\\"@openzeppelin/security/ReentrancyGuard.sol\\\";\\n\\nimport { ITokenBurner } from \\\"../interfaces/ITokenBurner.sol\\\";\\nimport { ICatalyst } from \\\"../interfaces/ICatalyst.sol\\\";\\nimport { ITokenCrafter } from \\\"../interfaces/ITokenCrafter.sol\\\";\\nimport { IUGCCraftableObjectFactory } from \\\"../interfaces/IUGCCraftableObjectFactory.sol\\\";\\n\\nabstract contract BaseCraftLogic is ReentrancyGuard, MultiOwner, ERC2771Context {\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   CONFIG                                   */\\n    /* -------------------------------------------------------------------------- */\\n    // The address used for Gelato Relay.\\n    address public gelatoRelay;\\n    // The address used for UGCCraftableObjectFactory.\\n    address public ugcFactory;\\n\\n    // Whitelist for material objects and artifacts that can be used in recipes\\n    mapping(address => bool) private _whitelist;\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   STORAGE                                  */\\n    /* -------------------------------------------------------------------------- */\\n    uint256 public recipeCount;\\n\\n    // Define an array to store the recipes\\n    mapping(uint256 => Recipe) internal recipes;\\n\\n    struct Material {\\n        address tokenAddress; // The address of the ERC1155 contract for this material\\n        uint256 tokenId; // The ID of the token in the ERC1155 contract\\n        uint256 amount; // The amount of the token required\\n    }\\n\\n    struct Artifacts {\\n        address tokenAddress; // The address of the ERC1155 contract for this Artifacts\\n        uint256 tokenId; // The ID of the token in the ERC1155 contract\\n        uint256 amount; // The amount of the token required\\n    }\\n\\n    struct Catalyst {\\n        address tokenAddress; // The address of the ERC20/ERC721/ERC1155 contract for this catalyst\\n        uint256 tokenId; // The ID of the token in the contract : ERC20 => 0\\n        uint256 amount; // The required balance of the token\\n        TokenType tokenType; // Type of the token: 0 = ERC20, 1 = ERC721, 2 = ERC1155\\n    }\\n\\n    struct Recipe {\\n        uint256 id;\\n        Material[] materials;\\n        Artifacts[] artifacts;\\n        Catalyst catalyst; // ERC20/ERC721/ERC1155\\n        address creator;\\n        bool active;\\n    }\\n\\n    enum TokenType {\\n        ERC20,\\n        ERC721,\\n        ERC1155\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   EVENTS                                   */\\n    /* -------------------------------------------------------------------------- */\\n    // Event emitted when a new artifact is crafte\\n    event Crafted(address indexed crafter, uint256 recipeId);\\n    // Event emitted when a new recipe is created\\n    event RecipeCreated(uint256 indexed recipeId, address indexed owner);\\n    // Event emitted when a new recipe is created\\n    event RecipeUpdated(uint256 indexed recipeId, address indexed owner);\\n    // Event emitted when the GelatoRelay address is set.\\n    event SetGelatoRelay(address indexed oldGelatoRelay, address indexed newGelatoRelay);\\n    // Event emitted when the UGCFactory address is set.\\n    event SetUgcFactory(address indexed oldUgcFactory, address indexed ugcFactory);\\n    // Event emitted when a craft is performed by a relayer\\n    event CraftedByRelayer(uint256 indexed recipeId, address indexed relayer);\\n    // Event emitted when a new recipe is created\\n    event ChangeRecipeStatus(uint256 indexed recipeId, bool active, address indexed owner);\\n    // Event emitted when an address is added to the whitelist.\\n    event AddedToWhitelist(address indexed sender, address indexed whitelistedAddress);\\n    // Event emitted when an address is removed from the whitelist.\\n    event RemovedFromWhitelist(address indexed sender, address indexed unwhitelistedAddress);\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   ERRORS                                   */\\n    /* -------------------------------------------------------------------------- */\\n    // Error thrown when an invalid address is provided. The reason for invalidity is provided as a parameter.\\n    error InvalidAddress(string reason);\\n    // Error thrown when the caller is not the creator of the recipe.\\n    error NotRecipeCreator(uint256 recipeId);\\n    // Error thrown when the required condition for a catalyst is not satisfied during crafting.\\n    error CatalystConditionNotSatisfied();\\n    // Error to throw if the function call is not made by an GelatoRelay.\\n    error OnlyGelatoRelay();\\n    // Error thrown when trying to craft using an inactive recipe.\\n    error RecipeInactive(uint256 recipeId);\\n    // Error thrown when trying to create a recipe that already exists.\\n    error ExistentCraft(uint256 id);\\n    // Error thrown when trying to update a recipe that doesn't exist.\\n    error NonExistentRecipe(uint256 id);\\n    // Error thrown when trying to create or update a recipe without any materials.\\n    error EmptyMaterialsArray();\\n    // Error thrown when trying to create or update a recipe without any artifacts.\\n    error EmptyArtifactsArray();\\n    // Error thrown if not a smart contract but an EOA\\n    error MustBeAContract();\\n    // Error thrown if an address is not whitelisted or created by UGCCraftableObjectFactory\\n    error MustBeWhitelistedOrCreatedByUGCFactory();\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                  Utility                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    function _checkSize(address addr) private view returns (uint256 extSize) {\\n        assembly {\\n            extSize := extcodesize(addr) // returns 0 if EOA, >0 if smart contract\\n        }\\n    }\\n\\n    function _validateCraftContract(address addr) internal view {\\n        if (_checkSize(addr) == 0) {\\n            revert MustBeAContract();\\n        }\\n\\n        if (!_whitelist[addr] && !IUGCCraftableObjectFactory(ugcFactory).checkUGCAddress(addr)) {\\n            revert MustBeWhitelistedOrCreatedByUGCFactory();\\n        }\\n    }\\n\\n    function addToWhitelist(address addr) external onlyOwner {\\n        _whitelist[addr] = true;\\n        emit AddedToWhitelist(msg.sender, addr);\\n    }\\n\\n    function removeFromWhitelist(address addr) external onlyOwner {\\n        _whitelist[addr] = false;\\n        emit RemovedFromWhitelist(msg.sender, addr);\\n    }\\n\\n    /// @dev Set an UGCCraftableObjectFactory contract\\n    function setUgcFactory(address _ugcFactory) external onlyOwner {\\n        if (_ugcFactory == address(0)) {\\n            revert InvalidAddress({ reason: \\\"cant set address(0)\\\" });\\n        }\\n        if (_checkSize(_ugcFactory) == 0) revert MustBeAContract();\\n\\n        address oldUgcFactory = ugcFactory;\\n        ugcFactory = _ugcFactory;\\n        emit SetUgcFactory(oldUgcFactory, ugcFactory);\\n    }\\n    /* -------------------------------------------------------------------------- */\\n    /*                                  MODIFIERS                                 */\\n    /* -------------------------------------------------------------------------- */\\n\\n    modifier onlyRecipeCreator(uint256 recipeId) {\\n        if (_msgSender() != recipes[recipeId].creator) revert NotRecipeCreator(recipeId);\\n        _;\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                    Craft                                   */\\n    /* -------------------------------------------------------------------------- */\\n    // 0:ERC20, 1:ERC721, 2:ERC1155\\n    function _checkCatalystCondition(Catalyst memory catalyst) internal view {\\n        if (catalyst.tokenType == TokenType.ERC20 && !_enoughERC20Balance(catalyst)) {\\n            revert CatalystConditionNotSatisfied();\\n        } else if (catalyst.tokenType == TokenType.ERC721 && !_correctERC721Owner(catalyst)) {\\n            revert CatalystConditionNotSatisfied();\\n        } else if (catalyst.tokenType == TokenType.ERC1155 && !_enoughERC1155Balance(catalyst)) {\\n            revert CatalystConditionNotSatisfied();\\n        }\\n    }\\n\\n    function _enoughERC20Balance(Catalyst memory catalyst) internal view returns (bool) {\\n        return ICatalyst(catalyst.tokenAddress).balanceOf(_msgSender()) >= catalyst.amount;\\n    }\\n\\n    function _correctERC721Owner(Catalyst memory catalyst) internal view returns (bool) {\\n        return ICatalyst(catalyst.tokenAddress).balanceOf(_msgSender()) >= catalyst.amount;\\n    }\\n\\n    function _enoughERC1155Balance(Catalyst memory catalyst) internal view returns (bool) {\\n        return ICatalyst(catalyst.tokenAddress).balanceOf(_msgSender(), catalyst.tokenId) >= catalyst.amount;\\n    }\\n\\n    /**\\n     * @dev This function allows users to craft an artifact with a given recipeId.\\n     * The function first checks if the recipe is active and satisfies the catalyst condition,\\n     * then it burns the required materials and mints the new artifact.\\n     *\\n     * @param recipeId ID of the recipe to be used for crafting.\\n     */\\n    function craft(uint256 recipeId) external virtual nonReentrant {\\n        _craft(recipeId);\\n    }\\n\\n    function _craft(uint256 recipeId) private {\\n        // Retrieve the recipe\\n        Recipe storage recipe = recipes[recipeId];\\n\\n        // Ensure the recipe is active\\n        if (!recipe.active) revert RecipeInactive(recipeId);\\n\\n        // Check catalyst condition\\n        Catalyst memory catalyst = recipe.catalyst;\\n        if (catalyst.tokenAddress != address(0)) {\\n            _checkCatalystCondition(catalyst);\\n        }\\n\\n        // Burn the required materials\\n        uint256 materialsLength = recipe.materials.length;\\n        for (uint256 i; i < materialsLength;) {\\n            Material memory material = recipe.materials[i];\\n            ITokenBurner(material.tokenAddress).burnObject(_msgSender(), material.tokenId, material.amount);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Mint the artifacts\\n        uint256 artifactsLength = recipe.artifacts.length;\\n        for (uint256 i; i < artifactsLength;) {\\n            Artifacts memory artifact = recipe.artifacts[i];\\n            ITokenCrafter(artifact.tokenAddress).craftObject(_msgSender(), recipeId, artifact.tokenId, artifact.amount);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        // Emit the Crafted event\\n        emit Crafted(_msgSender(), recipeId);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                               Recipe Utility                               */\\n    /* -------------------------------------------------------------------------- */\\n    /**\\n     * @dev This function returns the Recipe structure for a given recipeId.\\n     *\\n     * @param recipeId ID of the recipe to be retrieved.\\n     */\\n    function getRecipe(uint256 recipeId) external view virtual returns (Recipe memory) {\\n        return recipes[recipeId];\\n    }\\n\\n    // These methods need to be implemented by subclasses\\n    function getRecipeNumber() public view virtual returns (uint256) {\\n        return recipeCount;\\n    }\\n\\n    function createRecipe(\\n        Material[] calldata materials,\\n        Artifacts[] calldata artifacts,\\n        Catalyst calldata catalyst\\n    )\\n        external\\n        virtual;\\n\\n    function updateRecipe(\\n        uint256 recipeId,\\n        Material[] memory materials,\\n        Artifacts[] memory artifacts,\\n        Catalyst calldata catalyst,\\n        bool active\\n    )\\n        external\\n        virtual;\\n\\n    function changeRecipeStatus(uint256 recipeId, bool active) external virtual;\\n\\n    function _createOrUpdateRecipe(\\n        uint256 recipeId,\\n        Material[] memory materials,\\n        Artifacts[] memory artifacts,\\n        Catalyst calldata catalyst,\\n        bool active,\\n        bool isUpdate // true:= update, false:= create\\n    )\\n        internal\\n    {\\n        // Check if the recipe already exists\\n        if (recipes[recipeId].id == recipeId && !isUpdate) revert ExistentCraft(recipeId);\\n        if (recipes[recipeId].id != recipeId && isUpdate) revert NonExistentRecipe(recipeId);\\n\\n        uint256 materialsLength = materials.length;\\n        uint256 artifactsLength = artifacts.length;\\n        // Check that materials and artifacts arrays have at least one element\\n        if (materialsLength == 0) revert EmptyMaterialsArray();\\n        if (artifactsLength == 0) revert EmptyArtifactsArray();\\n\\n        if (catalyst.tokenAddress != address(0)) {\\n            if (_checkSize(catalyst.tokenAddress) == 0) revert MustBeAContract();\\n        }\\n        // Update or Create a new recipe\\n        Recipe storage recipe = recipes[recipeId];\\n        recipe.id = recipeId;\\n        recipe.creator = _msgSender();\\n        recipe.active = active;\\n        recipe.catalyst = catalyst;\\n\\n        // Update the materials array\\n        delete recipe.materials;\\n        for (uint256 i; i < materialsLength;) {\\n            _validateCraftContract(materials[i].tokenAddress);\\n            recipe.materials.push(materials[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Update the artifacts array\\n        delete recipe.artifacts;\\n        for (uint256 i; i < artifactsLength;) {\\n            _validateCraftContract(artifacts[i].tokenAddress);\\n            recipe.artifacts.push(artifacts[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        // Emit the RecipeCreated event\\n        if (isUpdate) {\\n            emit RecipeUpdated(recipeId, _msgSender());\\n        } else {\\n            emit RecipeCreated(recipeId, _msgSender());\\n        }\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                               RelayCraft                                  */\\n    /* -------------------------------------------------------------------------- */\\n    /// @dev Set a new GelatoRelay address\\n    function setGelatoRelay(address _gelatoRelay) external onlyOwner {\\n        if (_gelatoRelay == address(0)) {\\n            revert InvalidAddress({ reason: \\\"cant set address(0)\\\" });\\n        }\\n        if (_checkSize(_gelatoRelay) == 0) revert MustBeAContract();\\n\\n        address oldGelatoRelay = gelatoRelay;\\n        gelatoRelay = _gelatoRelay;\\n        emit SetGelatoRelay(oldGelatoRelay, gelatoRelay);\\n    }\\n\\n    modifier onlyGelatoRelay() {\\n        if (!_isGelatoRelay(msg.sender)) revert OnlyGelatoRelay();\\n        _;\\n    }\\n\\n    function _isGelatoRelay(address _forwarder) internal view returns (bool) {\\n        return _forwarder == gelatoRelay;\\n    }\\n\\n    // Function to craft object by relayer.\\n    function craftByRelayer(uint256 recipeId) external nonReentrant onlyGelatoRelay {\\n        _craft(recipeId);\\n        // Emit an event indicating that this function was called by a relayer\\n        emit CraftedByRelayer(recipeId, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/MultiOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n//                 ____    ____\\n//                /\\\\___\\\\  /\\\\___\\\\\\n//       ________/ /   /_ \\\\/___/\\n//      /\\\\_______\\\\/   /__\\\\___\\\\\\n//     / /       /       /   /\\n//    / /   /   /   /   /   /\\n//   / /   /___/___/___/___/\\n//  / /   /\\n//  \\\\/___/\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev Contracts to manage multiple owners.\\n */\\nabstract contract MultiOwner {\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   STORAGE                                  */\\n    /* -------------------------------------------------------------------------- */\\n    mapping(address => bool) private _owners;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   EVENTS                                   */\\n    /* -------------------------------------------------------------------------- */\\n    event OwnershipGranted(address indexed operator, address indexed target);\\n    event OwnershipRemoved(address indexed operator, address indexed target);\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   ERRORS                                   */\\n    /* -------------------------------------------------------------------------- */\\n    error InvalidOwner();\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                               INITIALIZATION                               */\\n    /* -------------------------------------------------------------------------- */\\n    /**\\n     * @dev Initializes the contract setting and set the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _owners[msg.sender] = true;\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                  MODIFIERS                                 */\\n    /* -------------------------------------------------------------------------- */\\n    /**\\n     * @dev Throws an error if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (!_owners[msg.sender]) revert InvalidOwner();\\n        _;\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   PUBLIC                                   */\\n    /* -------------------------------------------------------------------------- */\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function ownerCheck(address targetAddress) external view virtual returns (bool) {\\n        return _owners[targetAddress];\\n    }\\n\\n    /**\\n     * @dev Sets the address of the owner.\\n     */\\n    function setOwner(address newOwner) external virtual onlyOwner {\\n        _owners[newOwner] = true;\\n        emit OwnershipGranted(msg.sender, newOwner);\\n    }\\n\\n    /**\\n     * @dev Removes the address from the owner list.\\n     */\\n    function removeOwner(address oldOwner) external virtual onlyOwner {\\n        _owners[oldOwner] = false;\\n        emit OwnershipRemoved(msg.sender, oldOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITokenBurner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n//                 ____    ____\\n//                /\\\\___\\\\  /\\\\___\\\\\\n//       ________/ /   /_ \\\\/___/\\n//      /\\\\_______\\\\/   /__\\\\___\\\\\\n//     / /       /       /   /\\n//    / /   /   /   /   /   /\\n//   / /   /___/___/___/___/\\n//  / /   /\\n//  \\\\/___/\\n\\npragma solidity 0.8.19;\\n\\ninterface ITokenBurner {\\n    function burnObject(address from, uint256 tokenId, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICatalyst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n//                 ____    ____\\n//                /\\\\___\\\\  /\\\\___\\\\\\n//       ________/ /   /_ \\\\/___/\\n//      /\\\\_______\\\\/   /__\\\\___\\\\\\n//     / /       /       /   /\\n//    / /   /   /   /   /   /\\n//   / /   /___/___/___/___/\\n//  / /   /\\n//  \\\\/___/\\n\\npragma solidity 0.8.19;\\n\\ninterface ICatalyst {\\n    function balanceOf(address account) external view returns (uint256);\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITokenCrafter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n//                 ____    ____\\n//                /\\\\___\\\\  /\\\\___\\\\\\n//       ________/ /   /_ \\\\/___/\\n//      /\\\\_______\\\\/   /__\\\\___\\\\\\n//     / /       /       /   /\\n//    / /   /   /   /   /   /\\n//   / /   /___/___/___/___/\\n//  / /   /\\n//  \\\\/___/\\n\\npragma solidity 0.8.19;\\n\\ninterface ITokenCrafter {\\n    function craftObject(address to, uint256 recipeId, uint256 tokenId, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUGCCraftableObjectFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n//                 ____    ____\\n//                /\\\\___\\\\  /\\\\___\\\\\\n//       ________/ /   /_ \\\\/___/\\n//      /\\\\_______\\\\/   /__\\\\___\\\\\\n//     / /       /       /   /\\n//    / /   /   /   /   /   /\\n//   / /   /___/___/___/___/\\n//  / /   /\\n//  \\\\/___/\\n\\npragma solidity 0.8.19;\\n\\ninterface IUGCCraftableObjectFactory {\\n    function checkUGCAddress(address _address) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@gelatonetwork/=node_modules/@gelatonetwork/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"prb-test/=lib/prb-test/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gelatoRelay\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CatalystConditionNotSatisfied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyArtifactsArray\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyMaterialsArray\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ExistentCraft\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustBeAContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustBeWhitelistedOrCreatedByUGCFactory\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"NonExistentRecipe\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"}],\"name\":\"NotRecipeCreator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGelatoRelay\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"}],\"name\":\"RecipeInactive\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistedAddress\",\"type\":\"address\"}],\"name\":\"AddedToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ChangeRecipeStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"crafter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"}],\"name\":\"Crafted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"CraftedByRelayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"OwnershipGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"OwnershipRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RecipeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"RecipeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"unwhitelistedAddress\",\"type\":\"address\"}],\"name\":\"RemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldGelatoRelay\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGelatoRelay\",\"type\":\"address\"}],\"name\":\"SetGelatoRelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldUgcFactory\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ugcFactory\",\"type\":\"address\"}],\"name\":\"SetUgcFactory\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"changeRecipeStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"}],\"name\":\"craft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"}],\"name\":\"craftByRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseCraftLogic.Material[]\",\"name\":\"materials\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseCraftLogic.Artifacts[]\",\"name\":\"artifacts\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum BaseCraftLogic.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"}],\"internalType\":\"struct BaseCraftLogic.Catalyst\",\"name\":\"catalyst\",\"type\":\"tuple\"}],\"name\":\"createRecipe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gelatoRelay\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"}],\"name\":\"getRecipe\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseCraftLogic.Material[]\",\"name\":\"materials\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseCraftLogic.Artifacts[]\",\"name\":\"artifacts\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum BaseCraftLogic.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"}],\"internalType\":\"struct BaseCraftLogic.Catalyst\",\"name\":\"catalyst\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct BaseCraftLogic.Recipe\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRecipeNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"name\":\"ownerCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gelatoRelay\",\"type\":\"address\"}],\"name\":\"setGelatoRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ugcFactory\",\"type\":\"address\"}],\"name\":\"setUgcFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ugcFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"recipeId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseCraftLogic.Material[]\",\"name\":\"materials\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseCraftLogic.Artifacts[]\",\"name\":\"artifacts\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum BaseCraftLogic.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"}],\"internalType\":\"struct BaseCraftLogic.Catalyst\",\"name\":\"catalyst\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"updateRecipe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CraftLogic", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000d8253782c45a12053594b9deb72d8e8ab2fca54c000000000000000000000000d8253782c45a12053594b9deb72d8e8ab2fca54c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}