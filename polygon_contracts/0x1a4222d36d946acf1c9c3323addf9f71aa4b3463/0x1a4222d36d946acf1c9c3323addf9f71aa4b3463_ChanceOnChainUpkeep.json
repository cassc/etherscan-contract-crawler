{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AutomationCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\\n */\\npragma solidity ^0.8.0;\\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \\\"./AutomationCompatibleInterface.sol\\\";\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ChanceOnChainUpkeep.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\";\\n\\nimport \\\"./interfaces/IChanceOnChain.sol\\\";\\nimport \\\"./interfaces/IAdminController.sol\\\";\\nimport \\\"./interfaces/ILuckyRefunder.sol\\\";\\nimport \\\"./Entities.sol\\\";\\nimport \\\"./Errors.sol\\\";\\n\\ncontract ChanceOnChainUpkeep is VRFConsumerBaseV2, KeeperCompatibleInterface {\\n  enum UpkeepAction {\\n    OPEN_SCHEDULED_RAFFLES,\\n    HAPPEN_OPENED_RAFFLES,\\n    CLOSE_HAPPENING_RAFFLES,\\n    REFUND_OPENED_RAFFLES,\\n    AUTO_END_CLOSED_RAFFLES,\\n    AUTO_END_REFUND_RAFFLES,\\n    SELECT_LUCKY_REFUND_USERS,\\n    REROLL_WINNERS\\n  }\\n\\n  uint32 constant MAX_USERS_IN_BATCH = 80;\\n  uint32 constant MAX_RAFFLES_IN_BATCH = 50;\\n\\n  VRFCoordinatorV2Interface immutable COORDINATOR;\\n  uint32 constant CALLBACK_GAS_LIMIT = 2500000;\\n  uint64 immutable subscriptionId;\\n  bytes32 immutable keyHash;\\n\\n  address public keeperRegistryAddress;\\n  mapping(address => bool) public operators;\\n\\n  IChanceOnChain public chanceOnChain;\\n  IAdminController private immutable adminController;\\n  ILuckyRefunder private immutable luckyRefunder;\\n\\n  mapping(uint256 => uint256) internal requestIdToRaffleId;\\n  mapping(uint256 => uint256) internal raffleIdToRandomNumber;\\n\\n  event SetOperator(address indexed operator, bool allowed);\\n\\n  // Modifiers\\n  modifier onlyOwner() {\\n    if (adminController.owner() != msg.sender) {\\n      revert NotAllowed();\\n    }\\n    _;\\n  }\\n\\n  modifier onlyOwnerOrOperator() {\\n    if (adminController.owner() != msg.sender && !operators[msg.sender]) {\\n      revert OnlyOperator();\\n    }\\n    _;\\n  }\\n\\n  constructor(\\n    address _chanceOnChain,\\n    address _adminController,\\n    address _luckyRefunder,\\n    address _vrfCoordinator,\\n    uint64 _subscriptionId,\\n    bytes32 _keyHash\\n  ) VRFConsumerBaseV2(_vrfCoordinator) {\\n    chanceOnChain = IChanceOnChain(_chanceOnChain);\\n    adminController = IAdminController(_adminController);\\n    luckyRefunder = ILuckyRefunder(_luckyRefunder);\\n    COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\\n    subscriptionId = _subscriptionId;\\n    keyHash = _keyHash;\\n    operators[msg.sender] = true;\\n\\n    luckyRefunder.setUpkeeper(address(this));\\n  }\\n\\n  function setOperator(address _operator, bool _allowed) public onlyOwner {\\n    operators[_operator] = _allowed;\\n    emit SetOperator(_operator, _allowed);\\n  }\\n\\n  function setChanceOnChain(IChanceOnChain _chanceOnChain) public onlyOwner {\\n    chanceOnChain = _chanceOnChain;\\n  }\\n\\n  function checkUpkeep(bytes calldata checkData) external view override returns (bool upkeepNeeded, bytes memory performData) {\\n    UpkeepAction action = abi.decode(checkData, (UpkeepAction));\\n\\n    if (action == UpkeepAction.OPEN_SCHEDULED_RAFFLES) {\\n      uint256[] memory ids = _getScheduledRafflesToOpen();\\n      upkeepNeeded = ids.length > 0;\\n      if (upkeepNeeded) {\\n        performData = abi.encode(action, abi.encode(ids));\\n      }\\n      return (upkeepNeeded, performData);\\n    } else if (action == UpkeepAction.HAPPEN_OPENED_RAFFLES) {\\n      uint256[] memory ids = _getOpenedRafflesToHappen();\\n      upkeepNeeded = ids.length > 0;\\n      if (upkeepNeeded) {\\n        performData = abi.encode(action, abi.encode(ids));\\n      }\\n      return (upkeepNeeded, performData);\\n    } else if (action == UpkeepAction.CLOSE_HAPPENING_RAFFLES) {\\n      uint256[] memory ids = _getHappeningRafflesToClose();\\n      upkeepNeeded = ids.length > 0;\\n      if (upkeepNeeded) {\\n        performData = abi.encode(action, abi.encode(ids));\\n      }\\n      return (upkeepNeeded, performData);\\n    } else if (action == UpkeepAction.REFUND_OPENED_RAFFLES) {\\n      uint256[] memory ids = _getOpenedRafflesToRefund();\\n      upkeepNeeded = ids.length > 0;\\n      if (upkeepNeeded) {\\n        performData = abi.encode(action, abi.encode(ids));\\n      }\\n      return (upkeepNeeded, performData);\\n    } else if (action == UpkeepAction.AUTO_END_CLOSED_RAFFLES) {\\n      uint256[] memory ids = _getClosedRafflesToAutoEnd();\\n      upkeepNeeded = ids.length > 0;\\n      if (upkeepNeeded) {\\n        performData = abi.encode(action, abi.encode(ids));\\n      }\\n      return (upkeepNeeded, performData);\\n    } else if (action == UpkeepAction.AUTO_END_REFUND_RAFFLES) {\\n      uint256[] memory ids = _getRefundRafflesToAutoEnd();\\n      upkeepNeeded = ids.length > 0;\\n      if (upkeepNeeded) {\\n        performData = abi.encode(action, abi.encode(ids));\\n      }\\n      return (upkeepNeeded, performData);\\n    } else if (action == UpkeepAction.SELECT_LUCKY_REFUND_USERS) {\\n      (uint256 raffleId, uint256 refundAmount, uint32[] memory refundees, uint256[] memory amounts) = _getLuckyRefundUsers();\\n      upkeepNeeded = refundees.length > 0;\\n      if (upkeepNeeded) {\\n        performData = abi.encode(action, abi.encode(raffleId, refundAmount, refundees, amounts));\\n      }\\n      return (upkeepNeeded, performData);\\n    } else if (action == UpkeepAction.REROLL_WINNERS) {\\n      uint256[] memory ids = _getRerollWinnerRaffles();\\n      upkeepNeeded = ids.length > 0;\\n      if (upkeepNeeded) {\\n        performData = abi.encode(action, abi.encode(ids));\\n      }\\n      return (upkeepNeeded, performData);\\n    }\\n\\n    return (false, bytes(\\\"\\\"));\\n  }\\n\\n  function _getScheduledRafflesToOpen() internal view returns (uint256[] memory ids) {\\n    uint256[] memory allIds = chanceOnChain.rafflesByStatusIds(RaffleStatus.SCHEDULED);\\n    ids = new uint256[](allIds.length);\\n    uint256 count = 0;\\n\\n    for (uint256 i = 0; i < allIds.length; i++) {\\n      uint256 id = allIds[i];\\n      if (chanceOnChain.getRaffle(id).startTime <= block.timestamp) {\\n        ids[count] = id;\\n        count++;\\n      }\\n      if (count == MAX_RAFFLES_IN_BATCH) {\\n        break;\\n      }\\n    }\\n\\n    if (count < allIds.length) {\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        mstore(ids, count)\\n      }\\n    }\\n  }\\n\\n  function _getOpenedRafflesToHappen() internal view returns (uint256[] memory ids) {\\n    uint256[] memory allIds = chanceOnChain.rafflesByStatusIds(RaffleStatus.OPENED);\\n    ids = new uint256[](allIds.length);\\n    uint256 count = 0;\\n\\n    for (uint256 i = 0; i < allIds.length; i++) {\\n      uint256 id = allIds[i];\\n      if (chanceOnChain.getRaffle(id).ticketsSold >= chanceOnChain.getRaffle(id).minTickets) {\\n        ids[count] = id;\\n        count++;\\n      }\\n      if (count == MAX_RAFFLES_IN_BATCH) {\\n        break;\\n      }\\n    }\\n\\n    if (count < allIds.length) {\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        mstore(ids, count)\\n      }\\n    }\\n  }\\n\\n  function _getHappeningRafflesToClose() internal view returns (uint256[] memory ids) {\\n    uint256[] memory allIds = chanceOnChain.rafflesByStatusIds(RaffleStatus.HAPPENING);\\n    ids = new uint256[](allIds.length);\\n    uint256 count = 0;\\n\\n    for (uint256 i = 0; i < allIds.length; i++) {\\n      uint256 id = allIds[i];\\n      if (\\n        chanceOnChain.getRaffle(id).ticketsSold == chanceOnChain.getRaffle(id).maxTickets ||\\n        (chanceOnChain.getRaffle(id).ticketsSold >= chanceOnChain.getRaffle(id).minTickets && chanceOnChain.getRaffle(id).endTime <= block.timestamp)\\n      ) {\\n        ids[count] = id;\\n        count++;\\n      }\\n      if (count == MAX_RAFFLES_IN_BATCH) {\\n        break;\\n      }\\n    }\\n\\n    if (count < allIds.length) {\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        mstore(ids, count)\\n      }\\n    }\\n  }\\n\\n  function _getOpenedRafflesToRefund() internal view returns (uint256[] memory ids) {\\n    uint256[] memory allIds = chanceOnChain.rafflesByStatusIds(RaffleStatus.OPENED);\\n    ids = new uint256[](allIds.length);\\n    uint256 count = 0;\\n\\n    for (uint256 i = 0; i < allIds.length; i++) {\\n      uint256 id = allIds[i];\\n      if (\\n        chanceOnChain.getRaffle(id).ticketsSold < chanceOnChain.getRaffle(id).minTickets && chanceOnChain.getRaffle(id).endTime <= block.timestamp\\n      ) {\\n        ids[count] = id;\\n        count++;\\n      }\\n      if (count == MAX_RAFFLES_IN_BATCH) {\\n        break;\\n      }\\n    }\\n\\n    if (count < allIds.length) {\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        mstore(ids, count)\\n      }\\n    }\\n  }\\n\\n  function _getClosedRafflesToAutoEnd() internal view returns (uint256[] memory ids) {\\n    uint256[] memory allIds = chanceOnChain.rafflesByStatusIds(RaffleStatus.CLOSED);\\n    ids = new uint256[](allIds.length);\\n    uint256 count = 0;\\n\\n    for (uint256 i = 0; i < allIds.length; i++) {\\n      uint256 id = allIds[i];\\n      if (chanceOnChain.getRaffle(id).closedTime + chanceOnChain.getRaffle(id).claimRewardDuration <= block.timestamp) {\\n        ids[count] = id;\\n        count++;\\n      }\\n      if (count == MAX_RAFFLES_IN_BATCH) {\\n        break;\\n      }\\n    }\\n\\n    if (count < allIds.length) {\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        mstore(ids, count)\\n      }\\n    }\\n  }\\n\\n  function _getRefundRafflesToAutoEnd() internal view returns (uint256[] memory ids) {\\n    uint256[] memory allIds = chanceOnChain.rafflesByStatusIds(RaffleStatus.REFUND);\\n    ids = new uint256[](allIds.length);\\n    uint256 count = 0;\\n\\n    for (uint256 i = 0; i < allIds.length; i++) {\\n      uint256 id = allIds[i];\\n      if (chanceOnChain.getRaffle(id).refundStartTime + chanceOnChain.getRaffle(id).claimRefundDuration <= block.timestamp) {\\n        ids[count] = id;\\n        count++;\\n      }\\n      if (count == MAX_RAFFLES_IN_BATCH) {\\n        break;\\n      }\\n    }\\n\\n    if (count < allIds.length) {\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        mstore(ids, count)\\n      }\\n    }\\n  }\\n\\n  function _getRerollWinnerRaffles() internal view returns (uint256[] memory ids) {\\n    uint256[] memory allIds = chanceOnChain.rafflesRerollWinnerIds();\\n    ids = new uint256[](allIds.length);\\n    uint256 count = 0;\\n\\n    for (uint256 i = 0; i < allIds.length; i++) {\\n      ids[count] = allIds[i];\\n      count++;\\n      if (count == MAX_RAFFLES_IN_BATCH) {\\n        break;\\n      }\\n    }\\n\\n    if (count < allIds.length) {\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        mstore(ids, count)\\n      }\\n    }\\n  }\\n\\n  function _getLuckyRefundUsers()\\n    internal\\n    view\\n    returns (uint256 raffleId, uint256 refundAmount, uint32[] memory refundees, uint256[] memory amounts)\\n  {\\n    uint256[] memory ids = luckyRefunder.rafflesSelectUsersIds();\\n    if (ids.length == 0) {\\n      return (raffleId, refundAmount, refundees, amounts);\\n    }\\n    raffleId = ids[0];\\n\\n    uint256 remainingAmount = luckyRefunder.raffleAmount(raffleId) - luckyRefunder.raffleAssignedAmount(raffleId);\\n\\n    // Select lucky refund winners\\n    uint256 participantsLength = chanceOnChain.raffleParticipantsLength(raffleId);\\n    bool[] memory selected = new bool[](participantsLength);\\n    refundees = new uint32[](MAX_USERS_IN_BATCH);\\n    amounts = new uint256[](MAX_USERS_IN_BATCH);\\n    uint count = 0;\\n    uint randomResult = raffleIdToRandomNumber[raffleId];\\n    while (refundAmount < remainingAmount && count < participantsLength && count != MAX_USERS_IN_BATCH) {\\n      randomResult = uint(keccak256(abi.encode(randomResult, block.timestamp)));\\n      uint32 index = uint32(randomResult % participantsLength);\\n\\n      // To avoid refunding the same person twice\\n      if (selected[index] || luckyRefunder.isSelectedUser(raffleId, index)) {\\n        continue;\\n      }\\n\\n      Participant memory participant = chanceOnChain.raffleParticipantByIndex(raffleId, index);\\n      uint256 amountToRefund;\\n      if (participant.amount > remainingAmount - refundAmount) {\\n        amountToRefund = remainingAmount - refundAmount;\\n      } else {\\n        amountToRefund = participant.amount;\\n      }\\n      if (amountToRefund == 0) {\\n        break;\\n      }\\n      refundAmount += amountToRefund;\\n\\n      selected[index] = true;\\n      refundees[count] = index;\\n      amounts[count] = amountToRefund;\\n      count++;\\n    }\\n\\n    if (count < MAX_USERS_IN_BATCH) {\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        mstore(refundees, count)\\n        mstore(amounts, count)\\n      }\\n    }\\n\\n    return (raffleId, refundAmount, refundees, amounts);\\n  }\\n\\n  function performUpkeep(bytes calldata performData) external override onlyOwnerOrOperator {\\n    (UpkeepAction action, bytes memory data) = abi.decode(performData, (UpkeepAction, bytes));\\n\\n    if (action == UpkeepAction.OPEN_SCHEDULED_RAFFLES) {\\n      _performOpenScheduledRaffles(data);\\n    } else if (action == UpkeepAction.HAPPEN_OPENED_RAFFLES) {\\n      _performHappenOpenedRaffles(data);\\n    } else if (action == UpkeepAction.CLOSE_HAPPENING_RAFFLES) {\\n      _performCloseHappeningRaffles(data);\\n    } else if (action == UpkeepAction.REFUND_OPENED_RAFFLES) {\\n      _performRefundOpenedRaffles(data);\\n    } else if (action == UpkeepAction.AUTO_END_CLOSED_RAFFLES) {\\n      _performAutoEndClosedRaffles(data);\\n    } else if (action == UpkeepAction.AUTO_END_REFUND_RAFFLES) {\\n      _performAutoEndRefundRaffles(data);\\n    } else if (action == UpkeepAction.SELECT_LUCKY_REFUND_USERS) {\\n      _performLuckyRefundUsersUpkeep(data);\\n    } else if (action == UpkeepAction.REROLL_WINNERS) {\\n      _performRerollWinnerRaffles(data);\\n    }\\n  }\\n\\n  // OPEN raffles in SCHEDULE state\\n  function _performOpenScheduledRaffles(bytes memory performData) internal {\\n    uint256[] memory ids = abi.decode(performData, (uint256[]));\\n\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      Raffle memory raffle = chanceOnChain.getRaffle(ids[i]);\\n      if (raffle.status == RaffleStatus.SCHEDULED && raffle.startTime <= block.timestamp) {\\n        chanceOnChain.switchRaffleStatus(ids[i], RaffleStatus.SCHEDULED, RaffleStatus.OPENED);\\n      }\\n    }\\n  }\\n\\n  // HAPPENING raffles in OPEN state\\n  function _performHappenOpenedRaffles(bytes memory performData) internal {\\n    uint256[] memory ids = abi.decode(performData, (uint256[]));\\n\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      Raffle memory raffle = chanceOnChain.getRaffle(ids[i]);\\n      if (raffle.status == RaffleStatus.OPENED && raffle.ticketsSold >= raffle.minTickets) {\\n        chanceOnChain.switchRaffleStatus(ids[i], RaffleStatus.OPENED, RaffleStatus.HAPPENING);\\n      }\\n    }\\n  }\\n\\n  // CLOSE raffles in HAPPENING state with minTickets sold\\n  function _performCloseHappeningRaffles(bytes memory performData) internal {\\n    uint256[] memory ids = abi.decode(performData, (uint256[]));\\n\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      Raffle memory raffle = chanceOnChain.getRaffle(ids[i]);\\n      if (\\n        raffle.status == RaffleStatus.HAPPENING &&\\n        (raffle.ticketsSold == raffle.maxTickets || (raffle.ticketsSold >= raffle.minTickets && raffle.endTime <= block.timestamp))\\n      ) {\\n        chanceOnChain.switchRaffleStatus(ids[i], RaffleStatus.HAPPENING, RaffleStatus.CLOSED);\\n        _requestRandomness(ids[i]);\\n      }\\n    }\\n  }\\n\\n  // REFUND raffles in OPEN state\\n  function _performRefundOpenedRaffles(bytes memory performData) internal {\\n    uint256[] memory ids = abi.decode(performData, (uint256[]));\\n\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      Raffle memory raffle = chanceOnChain.getRaffle(ids[i]);\\n      if (raffle.status == RaffleStatus.OPENED && raffle.ticketsSold < raffle.minTickets && raffle.endTime <= block.timestamp) {\\n        chanceOnChain.switchRaffleStatus(ids[i], RaffleStatus.OPENED, raffle.ticketsSold == 0 ? RaffleStatus.AUTO_ENDED : RaffleStatus.REFUND);\\n      }\\n    }\\n  }\\n\\n  // AUTO_END raffles in CLOSE state\\n  function _performAutoEndClosedRaffles(bytes memory performData) internal {\\n    uint256[] memory ids = abi.decode(performData, (uint256[]));\\n\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      Raffle memory raffle = chanceOnChain.getRaffle(ids[i]);\\n      if (raffle.status == RaffleStatus.CLOSED && raffle.closedTime + raffle.claimRewardDuration <= block.timestamp) {\\n        chanceOnChain.switchRaffleStatus(ids[i], RaffleStatus.CLOSED, RaffleStatus.AUTO_ENDED);\\n      }\\n    }\\n  }\\n\\n  // AUTO_END raffles in REFUND state\\n  function _performAutoEndRefundRaffles(bytes memory performData) internal {\\n    uint256[] memory ids = abi.decode(performData, (uint256[]));\\n\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      Raffle memory raffle = chanceOnChain.getRaffle(ids[i]);\\n      if (raffle.status == RaffleStatus.REFUND && raffle.refundStartTime + raffle.claimRefundDuration <= block.timestamp) {\\n        chanceOnChain.switchRaffleStatus(ids[i], RaffleStatus.REFUND, RaffleStatus.AUTO_ENDED);\\n      }\\n    }\\n  }\\n\\n  function _performRerollWinnerRaffles(bytes memory performData) internal {\\n    uint256[] memory ids = abi.decode(performData, (uint256[]));\\n\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      if (!chanceOnChain.isRerollWinnerRaffle(ids[i])) {\\n        continue;\\n      }\\n      _requestRandomness(ids[i]);\\n    }\\n  }\\n\\n  function _performLuckyRefundUsersUpkeep(bytes memory performData) internal {\\n    (uint256 raffleId, uint256 refundAmount, uint32[] memory refundees, uint256[] memory amounts) = abi.decode(\\n      performData,\\n      (uint256, uint256, uint32[], uint256[])\\n    );\\n\\n    if (\\n      luckyRefunder.raffleAmount(raffleId) == luckyRefunder.raffleAssignedAmount(raffleId) ||\\n      refundees.length != amounts.length ||\\n      refundees.length == 0\\n    ) {\\n      return;\\n    }\\n\\n    luckyRefunder.addUsers(raffleId, refundAmount, refundees, amounts);\\n  }\\n\\n  function _requestRandomness(uint256 _raffleId) internal {\\n    uint256 requestId = COORDINATOR.requestRandomWords(keyHash, subscriptionId, 10, CALLBACK_GAS_LIMIT, 1);\\n    requestIdToRaffleId[requestId] = _raffleId;\\n  }\\n\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n    uint256 randomness = randomWords[0];\\n    uint256 raffleId = requestIdToRaffleId[requestId];\\n\\n    raffleIdToRandomNumber[raffleId] = randomness;\\n\\n    chanceOnChain.selectWinner(raffleId, randomness);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Entities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nenum DurationUnit {\\n  MINUTES,\\n  HOURS,\\n  DAYS\\n}\\n\\nstruct Settings {\\n  DurationUnit claimRewardDurationUnit;\\n  DurationUnit claimRefundDurationUnit;\\n  DurationUnit claimLuckyRefundDurationUnit;\\n  address treasuryWallet;\\n  address charityWallet;\\n  address expenseWallet;\\n  address serviceFeeWallet;\\n  uint256 claimRewardDuration;\\n  uint256 claimRefundDuration;\\n  uint256 claimLuckyRefundDuration;\\n  uint256 winnerAllocationBP; // Percentage towards winner in BP\\n  uint256 treasuryAllocationBP; // Percentage towards Treasury wallet in BP\\n  uint256 charityAllocationBP; // Percentage towards Charity wallet in BP\\n  uint256 luckyRefundAllocationBP; // Percentage towards Lucky refund in BP\\n  uint256 maxMarginBP; // Max margin in BP\\n  uint256 serviceFeeBP; // Percentage taken from treasury wallet amount as service fee in BP\\n  uint256 maxRerollAttempts;\\n}\\n\\n// Enum for the category of the raffle\\nenum RaffleCategory {\\n  PHYSICAL,\\n  DIGITAL,\\n  EXPERIENCE,\\n  MONEY\\n}\\n\\n// Enum for the status of the raffle\\nenum RaffleStatus {\\n  SCHEDULED,\\n  OPENED,\\n  PAUSED,\\n  HAPPENING,\\n  CLOSED,\\n  CANCELED,\\n  REFUND,\\n  ENDED,\\n  AUTO_ENDED\\n}\\n\\n// Participant data\\nstruct Participant {\\n  bool winner;\\n  bool skillTestFailed;\\n  bool cashAlternativeClaimed;\\n  bool refundClaimed;\\n  address addr;\\n  uint256 ticketCount;\\n  uint256 amount;\\n}\\n\\nstruct Entry {\\n  address user;\\n  uint cumulativeCount;\\n}\\n\\nstruct RaffleData {\\n  uint256 prizeValue;\\n  uint256 ticketPrice;\\n  uint256 startTime;\\n  uint256 duration;\\n  string prizeName;\\n  RaffleCategory category;\\n  DurationUnit durationUnit;\\n}\\n\\n// Struct for the details of the raffle\\nstruct Raffle {\\n  address winner;\\n  address treasuryWallet;\\n  address charityWallet;\\n  address expenseWallet;\\n  bool cashAlternativeAvailable;\\n  bool isDescendant;\\n  bool prizeClaimed;\\n  bool recurrent;\\n  RaffleCategory category;\\n  RaffleStatus status;\\n  DurationUnit durationUnit;\\n  uint256 id;\\n  uint256 prizeValue;\\n  uint256 ticketPrice;\\n  uint256 minTickets;\\n  uint256 maxTickets;\\n  uint256 startTime;\\n  uint256 duration;\\n  uint256 endTime;\\n  uint256 endedTime;\\n  uint256 closedTime;\\n  uint256 refundStartTime;\\n  uint256 ticketsSold;\\n  uint256 prizeCashAmount;\\n  uint256 claimedRefundAmount;\\n  uint256 treasuryAllocationBP;\\n  uint256 charityAllocationBP;\\n  uint256 luckyRefundAllocationBP;\\n  uint256 winnerAllocationBP;\\n  uint256 maxMarginBP;\\n  uint256 claimRewardDuration;\\n  uint256 claimLuckyRefundDuration;\\n  uint256 claimRefundDuration;\\n  uint256 originId;\\n  string prizeName;\\n  string entityName;\\n}\\n\"\r\n    },\r\n    \"contracts/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nerror MinTicketsTooBig();\\nerror ValueTooHigh();\\nerror InvalidStartTime();\\nerror AlreadyClaimed();\\nerror CannotBeZero();\\nerror InvalidAddress();\\nerror InvalidAmount();\\nerror OnlyParticipant();\\nerror RaffleNotOpen();\\nerror RaffleNotClosed();\\nerror RaffleEnded();\\nerror RaffleNotClaimable();\\nerror RaffleNotRefundable();\\nerror ClaimTimeIsOver();\\nerror NotEnoughTicketsLeft();\\nerror NotWinner();\\nerror WinnerAlreadySelected();\\nerror OnlyUpkeeper();\\nerror OnlyOperator();\\nerror NotAllowed();\\n\"\r\n    },\r\n    \"contracts/interfaces/IAdminController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\ninterface IAdminController {\\n  function owner() external returns (address);\\n\\n  function getAdmins() external returns (address[] memory);\\n\\n  function isAdmin(address _user) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChanceOnChain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nimport \\\"../Entities.sol\\\";\\n\\ninterface IChanceOnChain {\\n  function getRaffle(uint256 _raffleId) external view returns (Raffle memory);\\n\\n  function updateRaffle(Raffle memory raffle) external;\\n\\n  function calcTickets(uint256 _prizeValue, uint256 _ticketPrice, uint256 _margin, uint256 _maxMargin) external pure returns (uint256, uint256);\\n\\n  function rafflesLength() external view returns (uint256);\\n\\n  function raffleParticipants(uint256 _raffleId) external view returns (Participant[] memory);\\n\\n  function raffleParticipantsLength(uint256 _raffleId) external view returns (uint256);\\n\\n  function raffleParticipant(uint256 _raffleId, address _participant) external view returns (Participant memory);\\n\\n  function raffleParticipantByIndex(uint256 _raffleId, uint256 _index) external view returns (Participant memory);\\n\\n  function rafflesByStatusLength(RaffleStatus _status) external view returns (uint256);\\n\\n  function rafflesByStatusIds(RaffleStatus _status) external view returns (uint256[] memory);\\n\\n  function rafflesRerollWinnerIds() external view returns (uint256[] memory);\\n\\n  function isRerollWinnerRaffle(uint256 id) external view returns (bool);\\n\\n  function switchRaffleStatus(uint256 _raffleId, RaffleStatus _oldStatus, RaffleStatus _newStatus) external;\\n\\n  function selectWinner(uint256 raffleId, uint256 randomness) external;\\n\\n  function onClaimLuckyRefund(uint256 _raffleId, address _user) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILuckyRefunder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\ninterface ILuckyRefunder {\\n  function raffleAmount(uint256 _raffleId) external view returns (uint256);\\n\\n  function raffleAssignedAmount(uint256 _raffleId) external view returns (uint256);\\n\\n  function raffleClaimedAmount(uint256 _raffleId) external view returns (uint256);\\n\\n  function raffleUserAmount(uint256 raffleId, address user) external view returns (uint256);\\n\\n  function isExcludedUser(uint256 raffleId, address user) external view returns (bool);\\n\\n  function isSelectedUser(uint256 _raffleId, uint32 _index) external view returns (bool);\\n\\n  function rafflesSelectUsersIds() external view returns (uint256[] memory);\\n\\n  function paticipantDetails(uint256 _raffleId, address _user) external view returns (bool, uint256);\\n\\n  function setChanceOnChain(address _chanceOnChain) external;\\n\\n  function setUpkeeper(address _upkeeper) external;\\n\\n  function excludeUser(uint256 _raffleId, address _user) external;\\n\\n  function onSelectWinner(uint256 _raffleId) external returns (uint256);\\n\\n  function addUsers(uint256 _raffleId, uint256 _refundAmount, uint32[] memory _refundees, uint256[] memory _amounts) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chanceOnChain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminController\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_luckyRefunder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOperator\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"SetOperator\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"chanceOnChain\",\"outputs\":[{\"internalType\":\"contract IChanceOnChain\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeperRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IChanceOnChain\",\"name\":\"_chanceOnChain\",\"type\":\"address\"}],\"name\":\"setChanceOnChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ChanceOnChainUpkeep", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d707bddfe9d5d9c3a2ccdf7a29e48f7f95b1fc7b00000000000000000000000096d6fe34d08f460894744ad77a7571bf37eb4ba0000000000000000000000000d134f600c25a4b251e92e19598ce99569ad21a76000000000000000000000000ae975071be8f8ee67addbc1a82488f1c2485806700000000000000000000000000000000000000000000000000000000000003dfcc294a196eeeb44da2888d17c0625cc88d70d9760a69d58d853ba6581a9ab0cd", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}