{"SourceCode": "{\"MainContract.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\n\\npragma solidity ^0.8.0;\\n\\n\\n\\nimport \\\"./plan2.sol\\\";\\n\\n\\n\\n\\ncontract MaticWin is MaticWin2{\\n   \\n\\n\\n    function Check_Profit_income( address _upline) public view returns(uint256 [] memory Amount,uint256 [] memory PoolA,uint256 PoolB,uint256  [] memory perdayAmount)\\n    {\\n        return (User[_upline].depositAmount,User[_upline].amount_Pool_A ,User[_upline].amount_Pool_B,User[_upline].PerdayReward);\\n    }\\n//..................................................................sponsor..................................................................\\n\\n          function Check_Profit_income2( address _upline) public view returns(uint40 [] memory Time)\\n    {\\n        return (User[_upline].deposit_time);\\n    }\\n       function Check_Profit_income_Sponsor( address _upline) public view returns(address [] memory Sponsor,uint256 [] memory PoolA,uint256 PoolB,uint256  [] memory perdayAmount)\\n    {\\n        return (sponsorIncome[_upline].SponsorId,sponsorIncome[_upline].Amount ,User[_upline].amount_Pool_B,sponsorIncome[_upline].dailyReward);\\n    }\\n\\n    function CheckDetails(address add,uint256 index) public view returns(uint256 Amount,uint256 depositTime,uint256 dailyReward,uint256 WithdrawReward)\\n    {\\n        return(User[add].depositAmount[index], User[add].deposit_time[index],User[add].PerdayReward[index],User[add].withdrawReward[index]);\\n    }\\n\\n\\n    function CheckDetailsSponsor(address add,uint256 index) public view returns(uint256 WithdrawReward)\\n    {\\n        return(sponsorIncome[add].withdrawReward[index]);\\n    }\\n\\n\\n    function checkrefList() public view returns(address[] memory Silver,address[] memory Gold,address[] memory platinum,address[] memory diamond)\\n    {\\n        return (Silver_UserAddress,Gold_UserAddress,platinum_UserAddress,diamond_UserAddress);\\n    }\\n\\n\\n\\n\\n\\n    function CheckStatus(address add) public view returns(string memory _Status)\\n    {\\n        if(diamond_IsUpline(add) == true)\\n        {\\n            _Status = \\\"diamond\\\";\\n        }\\n        else if(platinum_IsUpline(add) == true)\\n        {\\n           _Status = \\\"platinum\\\"; \\n        }\\n        else if(Gold_IsUpline(add) == true)\\n        {\\n           _Status = \\\"Gold\\\"; \\n        }\\n        else if(silver_IsUpline(add) == true)\\n        {\\n           _Status = \\\"Silver\\\"; \\n        }   \\n        return _Status;   \\n    }\\n\\n\\n\\n    \\n\\n}\"},\"plan2.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n\\n\\npragma solidity ^0.8.0;\\n\\n\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\n\\n\\ncontract AddressChecker \\n{\\n    function isContract(address _address) internal view returns (bool) {\\n        uint256 size;\\n        assembly { size := extcodesize(_address) }\\n        return size \\u003e 0;\\n    }\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\\n\\n\\n\\ncontract MaticWin2 is   AddressChecker ,Context,ReentrancyGuard{\\n   \\n\\n    using SafeMath for uint256;\\n    address payable public owner;\\n\\n\\n\\n    constructor() \\n    {\\n        owner = payable(_msgSender());\\n        Silver_UserAddress.push(owner);\\n        silver_Referral[owner].upline = owner;       \\n\\n        Gold_UserAddress.push(owner);\\n        Gold_Referral[owner].upline = owner;  \\n\\n        platinum_UserAddress.push(owner);\\n        platinum_Referral[owner].upline = owner;  \\n\\n\\n        diamond_UserAddress.push(owner);\\n        diamond_Referral[owner].upline = owner;   \\n        \\n        Global_Referral[owner].upline = owner;\\n              \\n    }\\n\\n\\n    modifier onlyOwner() \\n    {\\n        require(_msgSender()==owner, \\\"Only Call by Owner\\\");\\n        _;\\n    }\\n\\n\\n    struct upline \\n    {\\n        address  upline;\\n        uint256  referrals;\\n        uint40   deposittime;\\n        uint256  direct;\\n        uint256 poolIncome;\\n        uint256 LevelIncome;\\n        uint256 TeamIncome;\\n        uint256 Userincome;\\n        uint256 RewardIncome;\\n        uint256 Three_directincome;\\n        uint256 Nine_directincome;\\n        uint256 twenty_seven_directincome;\\n        uint256 eighty_one;\\n    }\\n        struct UplineIncome \\n    {\\n        uint40  [] Deposittime;\\n        uint256 [] Amount;\\n        uint256 [] dailyReward;\\n        uint256 totalWithdrawReward;\\n        uint256 [] withdrawReward;\\n        address [] SponsorId;\\n    }\\n\\n    struct data \\n    {\\n        bool ActiveID;\\n        address  upline;\\n        uint40  [] deposit_time;\\n        uint256 [] amount_Pool_A;\\n        uint256 amount_Pool_B;\\n        uint256 [] depositAmount;\\n        uint256 [] PerdayReward;\\n        uint256 [] withdrawReward;\\n        uint256 totalWithdrawReward;\\n        string  Status;\\n        uint256 walletwithdrawal;\\n    }\\n\\n    struct user \\n    {\\n        address L1;\\n        address L2;\\n        address L3;\\n        address L4;\\n        address L5;\\n        address L6;\\n        address L7;\\n    }\\n     struct User_team\\n     {\\n        address L8;\\n        address L9;\\n        address L10;\\n        address L11;\\n        address L12;\\n        address L13;\\n        address L14;\\n        address L15;\\n     }\\n     struct Status_\\n     {\\n         bool round1;\\n         bool round2;\\n         bool round3;\\n         bool round4;\\n         bool round5;\\n         bool round6;\\n         bool round7;\\n         bool round8;\\n         bool round9;\\n         bool round10;\\n         \\n         \\n     }\\n\\n    mapping(address =\\u003e upline) public silver_Referral;\\n    mapping(address =\\u003e upline) public Gold_Referral;\\n    mapping(address =\\u003e upline) public platinum_Referral;\\n    mapping(address =\\u003e upline) public diamond_Referral;\\n    mapping(address =\\u003e upline) public Global_Referral;\\n    mapping(address =\\u003e data) public User;\\n    mapping(address =\\u003e user) public Pool_User;\\n    mapping(address =\\u003e User_team) public Pool_User_team;\\n    mapping(address =\\u003e UplineIncome) public sponsorIncome;\\n    mapping(address =\\u003e address[]) public check_Silver_address;\\n    mapping(address =\\u003e address[]) public check_Gold_address;\\n    mapping(address =\\u003e address[]) public check_platinum_address;\\n    mapping(address =\\u003e address[]) public check_diamond_address;\\n    mapping(address =\\u003e uint256) public Wallet;\\n    mapping(address =\\u003e Status_) public RewardIncome;\\n    \\n    \\n    address [] internal Silver_UserAddress;\\n    address [] internal Gold_UserAddress;\\n    address [] internal platinum_UserAddress;\\n    address [] internal diamond_UserAddress;\\n    uint256 internal Silver_ActiveID = 0;\\n    uint256 internal Gold_ActiveID = 0;\\n    uint256 internal platinum_ActiveID = 0;\\n    uint256 internal diamond_ActiveID = 0;\\n    uint256 internal withdrawTime = 1 days;\\n    uint256 internal Upline_totaldays = 400 ;\\n    uint256 internal selfincome_totaldays = 200 ;\\n\\n\\n\\n\\n//...............................................................................................Gernal pool......................\\n  function Global_setUpline(address _addr, address payable _upline) private {\\n        if(Global_Referral[_addr].upline == address(0) \\u0026\\u0026 _upline != _addr \\u0026\\u0026 _addr != owner \\u0026\\u0026 (Global_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) {\\n            Global_Referral[_addr].upline = _upline;\\n            Global_Referral[_upline].referrals++;\\n        }\\n    }\\n      function Global_IsUpline( address _upline) public view returns(bool status)\\n    {\\n        if(Global_Referral[msg.sender].upline == address(0) \\u0026\\u0026 _upline != msg.sender \\u0026\\u0026 msg.sender != owner \\u0026\\u0026 (Global_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) \\n        {\\n            status = true;  \\n        }\\n        return status;\\n    }\\n      function Global_ChakUpline( address _upline) public view returns(address add)\\n    {\\n        return Global_Referral[_upline].upline;\\n    }\\n\\n\\n\\n//...............................................................................................1st of tree.................................................\\n    function silver_setUpline(address _addr, address payable _upline) private {\\n        if(silver_Referral[_addr].upline == address(0) \\u0026\\u0026 _upline != _addr \\u0026\\u0026 _addr != owner \\u0026\\u0026 (silver_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) {\\n            silver_Referral[_addr].upline = _upline;\\n            silver_Referral[_upline].referrals++;\\n        }\\n    }\\n\\n      function silver_IsUpline( address _upline) public view returns(bool status)\\n    {\\n        if(silver_Referral[msg.sender].upline == address(0) \\u0026\\u0026 _upline != msg.sender \\u0026\\u0026 msg.sender != owner \\u0026\\u0026 (silver_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) \\n        {\\n            status = true;  \\n        }\\n        return status;\\n    }\\n\\n\\n\\n\\n//..................................................................................................second pool.....................................\\n\\n\\n\\n  function Gold_setUpline(address _addr, address payable _upline) private {\\n        if(Gold_Referral[_addr].upline == address(0) \\u0026\\u0026 _upline != _addr \\u0026\\u0026 _addr != owner \\u0026\\u0026 (Gold_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) {\\n            Gold_Referral[_addr].upline = _upline;\\n            Gold_Referral[_upline].referrals++;\\n        }\\n    }\\n      function Gold_IsUpline( address _upline) internal view returns(bool status)\\n    {\\n        if(Gold_Referral[msg.sender].upline == address(0) \\u0026\\u0026 _upline != msg.sender \\u0026\\u0026 msg.sender != owner \\u0026\\u0026 (Gold_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) \\n        {\\n            status = true;  \\n        }\\n        return status;\\n    }\\n\\n    function pool2(address add) private \\n    {\\n            address getaddress = Gold_UserAddress[Gold_ActiveID];\\n        if(Gold_Referral[getaddress].direct \\u003c  9)\\n            {\\n                Gold_setUpline(add, payable(getaddress));\\n                Gold_Referral[getaddress].direct += 1;\\n                Gold_UserAddress.push(add);\\n                check_Gold_address[getaddress].push(add);\\n            }\\n        else\\n            {\\n                Gold_Referral[getaddress].Nine_directincome += 40 ether;\\n                Wallet[getaddress] += 40 ether;\\n                pool3(getaddress); \\n                Gold_ActiveID++;\\n                getaddress = Gold_UserAddress[Gold_ActiveID];\\n                Gold_setUpline(add, payable(getaddress));\\n                Gold_Referral[getaddress].direct = 1;\\n                Gold_UserAddress.push(add);   \\n                check_Gold_address[getaddress].push(add);          \\n            }\\n             Gold_Referral[add].deposittime = uint40(block.timestamp);   \\n    }\\n\\n\\n\\n\\n//.............................................................................................third pool ........................................................................\\n\\n\\n    function platinum_setUpline(address _addr, address payable _upline) private {\\n        if(platinum_Referral[_addr].upline == address(0) \\u0026\\u0026 _upline != _addr \\u0026\\u0026 _addr != owner \\u0026\\u0026 (platinum_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) {\\n            platinum_Referral[_addr].upline = _upline;\\n            platinum_Referral[_upline].referrals++;\\n        }\\n    }\\n      function platinum_IsUpline( address _upline) internal view returns(bool status)\\n    {\\n        if(platinum_Referral[msg.sender].upline == address(0) \\u0026\\u0026 _upline != msg.sender \\u0026\\u0026 msg.sender != owner \\u0026\\u0026 (platinum_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) \\n        {\\n            status = true;  \\n        }\\n        return status;\\n    }\\n\\n    function pool3(address add) private \\n    {\\n            address getaddress = platinum_UserAddress[platinum_ActiveID];\\n        if(platinum_Referral[getaddress].direct \\u003c  27)\\n            {\\n                platinum_setUpline(add, payable(getaddress));\\n                platinum_Referral[getaddress].direct += 1;\\n                platinum_UserAddress.push(add);\\n                check_platinum_address[getaddress].push(add);\\n            }\\n        else\\n            {\\n                platinum_Referral[getaddress].twenty_seven_directincome += 350 ether;\\n                Wallet[getaddress] += 350 ether;\\n                pool5(getaddress); \\n                platinum_ActiveID++;\\n                getaddress = platinum_UserAddress[platinum_ActiveID];\\n                platinum_setUpline(add, payable(getaddress));\\n                platinum_Referral[getaddress].direct = 1;\\n                platinum_UserAddress.push(add);   \\n                check_platinum_address[getaddress].push(add);          \\n            }\\n             platinum_Referral[add].deposittime = uint40(block.timestamp);   \\n    }\\n\\n\\n//.....................................................................................................pool five...............................................................\\n    function diamond_setUpline(address _addr, address payable _upline) private {\\n        if(diamond_Referral[_addr].upline == address(0) \\u0026\\u0026 _upline != _addr \\u0026\\u0026 _addr != owner \\u0026\\u0026 (diamond_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) {\\n            diamond_Referral[_addr].upline = _upline;\\n            diamond_Referral[_upline].referrals++;\\n        }\\n    }\\n      function diamond_IsUpline( address _upline) internal view returns(bool status)\\n    {\\n        if(diamond_Referral[msg.sender].upline == address(0) \\u0026\\u0026 _upline != msg.sender \\u0026\\u0026 msg.sender != owner \\u0026\\u0026 (diamond_Referral[_upline].deposittime \\u003e 0 || _upline == owner)) \\n        {\\n            status = true;  \\n        }\\n        return status;\\n    }\\n\\n    function pool5(address add) private \\n    {\\n            address getaddress = diamond_UserAddress[diamond_ActiveID];\\n        if(diamond_Referral[getaddress].direct \\u003c  81)\\n            {\\n                diamond_setUpline(add, payable(getaddress));\\n                diamond_Referral[getaddress].direct += 1;\\n                diamond_UserAddress.push(add);\\n                check_diamond_address[getaddress].push(add);\\n            }\\n        else\\n            {\\n                diamond_Referral[getaddress].eighty_one += 81000 ether;\\n                Wallet[getaddress] += 81000 ether;\\n                diamond_ActiveID++;\\n                getaddress = diamond_UserAddress[diamond_ActiveID];\\n                diamond_setUpline(add, payable(getaddress));\\n                diamond_Referral[getaddress].direct = 1;\\n                diamond_UserAddress.push(add);   \\n                check_diamond_address[getaddress].push(add);          \\n            }\\n             diamond_Referral[add].deposittime = uint40(block.timestamp);   \\n    }\\n\\n\\n\\n\\n\\n\\n\\n\\n    function Register(address _upline) payable  external nonReentrant\\n    {\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\n        uint256 _payableamount = msg.value;\\n        uint256 o = _payableamount*10/100;\\n        payable(owner).transfer(o);\\n\\n         require(_payableamount % 25 ether == 0 , \\\"Invalid amount\\\");\\n         require(silver_IsUpline(_upline) == true , \\\"upline not found\\\");\\n         require(Global_IsUpline(_upline) == true , \\\"upline not found\\\");\\n         require(User[msg.sender].ActiveID == false , \\\"you are registered\\\");\\n\\n         Global_Referral[_upline].direct += 1;\\n         Global_setUpline(msg.sender,payable(_upline));\\n         Global_Referral[msg.sender].deposittime = uint40(block.timestamp);\\n\\n//......................................................................................Sponsor.........................................................\\n        silver_Referral[_upline].TeamIncome += _payableamount;\\n        silver_Referral[msg.sender].Userincome += _payableamount;\\n\\n        dictribure(_payableamount,msg.sender);\\n\\n\\n//......................................................................................uplineIncome..............................................\\n         sponsorIncome[_upline].Deposittime.push( uint40(block.timestamp));\\n         sponsorIncome[_upline].Amount.push(_payableamount*100/100);\\n         sponsorIncome[_upline].dailyReward.push(_payableamount.div(Upline_totaldays));\\n         sponsorIncome[_upline].withdrawReward.push(0);\\n         sponsorIncome[_upline].SponsorId.push(msg.sender);\\n\\n//................................................................................................user Data.............................................\\n         User[_msgSender()].ActiveID = true;\\n         User[msg.sender].upline = _upline;\\n//.................................................................................................self income....................................................\\n         \\n         User[_msgSender()].amount_Pool_A.push(_payableamount*200/100);\\n         User[_msgSender()].depositAmount.push(_payableamount);\\n         User[_msgSender()].amount_Pool_B += _payableamount*300/100;\\n         User[_msgSender()].PerdayReward.push((_payableamount*200/100)/selfincome_totaldays);\\n         User[_msgSender()].deposit_time.push(uint40(block.timestamp));\\n         User[_msgSender()].withdrawReward.push(0);\\n\\n\\n\\n\\n        // ........................................................................................Sponsor Income.....................................................................\\n        Pool_User[msg.sender].L1 = Global_ChakUpline(msg.sender);\\n        if(Pool_User[msg.sender].L2 != owner)\\n        {\\n            Pool_User[msg.sender].L2 = Global_ChakUpline(Pool_User[msg.sender].L1);\\n        }\\n        else{\\n            Pool_User[msg.sender].L2 = owner;\\n        }\\n        if(Pool_User[msg.sender].L2 != owner)\\n        {\\n            Pool_User[msg.sender].L3 = Global_ChakUpline(Pool_User[msg.sender].L2);\\n        }\\n        else{\\n            Pool_User[msg.sender].L3 = owner;\\n        }\\n        if(Pool_User[msg.sender].L3 != owner)\\n        {\\n            Pool_User[msg.sender].L4 = Global_ChakUpline(Pool_User[msg.sender].L3);\\n        }\\n        else{\\n            Pool_User[msg.sender].L4 = owner;\\n        }        \\n        if(Pool_User[msg.sender].L4 != owner)\\n        {\\n            Pool_User[msg.sender].L5 = Global_ChakUpline(Pool_User[msg.sender].L4);\\n        }\\n        else{\\n            Pool_User[msg.sender].L5 = owner;\\n        } \\n        if(Pool_User[msg.sender].L5 != owner)\\n        {\\n            Pool_User[msg.sender].L6 = Global_ChakUpline(Pool_User[msg.sender].L5);\\n        }\\n        else{\\n            Pool_User[msg.sender].L6 = owner;\\n        } \\n        if(Pool_User[msg.sender].L6 != owner)\\n        {\\n            Pool_User[msg.sender].L7 = Global_ChakUpline(Pool_User[msg.sender].L6);\\n        }\\n        else{\\n            Pool_User[msg.sender].L7 = owner;\\n        }\\n        if(Pool_User[msg.sender].L7 != owner)\\n        {\\n            Pool_User_team[msg.sender].L8 = Global_ChakUpline(Pool_User[msg.sender].L7);\\n        }\\n        else{\\n            Pool_User_team[msg.sender].L8 = owner;\\n        }\\n        if(Pool_User_team[msg.sender].L8 != owner)\\n        {\\n            Pool_User_team[msg.sender].L9 = Global_ChakUpline(Pool_User_team[msg.sender].L8);\\n        }\\n        else{\\n            Pool_User_team[msg.sender].L9 = owner;\\n        }\\n        if(Pool_User_team[msg.sender].L9 != owner)\\n        {\\n            Pool_User_team[msg.sender].L10 = Global_ChakUpline(Pool_User_team[msg.sender].L9);\\n        }\\n        else{\\n            Pool_User_team[msg.sender].L10 = owner;\\n        }\\n        if(Pool_User_team[msg.sender].L11 != owner)\\n        {\\n            Pool_User_team[msg.sender].L11 = Global_ChakUpline(Pool_User_team[msg.sender].L10);\\n        }\\n        else{\\n            Pool_User_team[msg.sender].L11 = owner;\\n        }\\n        if(Pool_User_team[msg.sender].L12 != owner)\\n        {\\n            Pool_User_team[msg.sender].L12 = Global_ChakUpline(Pool_User_team[msg.sender].L11);\\n        }\\n        else{\\n            Pool_User_team[msg.sender].L12 = owner;\\n        }\\n        if(Pool_User_team[msg.sender].L13 != owner)\\n        {\\n            Pool_User_team[msg.sender].L13 = Global_ChakUpline(Pool_User_team[msg.sender].L12);\\n        }\\n        else{\\n            Pool_User_team[msg.sender].L13 = owner;\\n        }   \\n        if(Pool_User_team[msg.sender].L14 != owner)\\n        {\\n            Pool_User_team[msg.sender].L14 = Global_ChakUpline(Pool_User_team[msg.sender].L13);\\n        }\\n        else{\\n            Pool_User_team[msg.sender].L14 = owner;\\n        }\\n        if(Pool_User_team[msg.sender].L15 != owner)\\n        {\\n            Pool_User_team[msg.sender].L15 = Global_ChakUpline(Pool_User_team[msg.sender].L14);\\n        }\\n        else{\\n            Pool_User_team[msg.sender].L15 = owner;\\n        }                  \\n        \\n//.....................................................................................Reward Income.......................................\\n          rewardIncome(msg.sender);\\n       \\n    } \\n\\n\\n    function rewardIncome(address add) private\\n    {\\n         if(silver_Referral[add].TeamIncome \\u003e= 2500000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 50000  \\u0026\\u0026 RewardIncome[_msgSender()].round10 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 100000 ether;\\n            Wallet[add] += 100000 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(100000 ether);\\n            RewardIncome[_msgSender()].round10 = true;\\n        }\\n        else if (silver_Referral[add].TeamIncome \\u003e= 1000000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 25000  \\u0026\\u0026 RewardIncome[_msgSender()].round9 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 50000 ether;\\n            Wallet[add] += 50000 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(50000 ether);\\n            RewardIncome[_msgSender()].round9 = true;\\n        }\\n        else if (silver_Referral[add].TeamIncome \\u003e= 500000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 20000  \\u0026\\u0026 RewardIncome[_msgSender()].round8 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 25000 ether;\\n            Wallet[add] += 25000 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(25000 ether);\\n            RewardIncome[_msgSender()].round8 = true;\\n        }        \\n        else if (silver_Referral[add].TeamIncome \\u003e= 250000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 10000  \\u0026\\u0026 RewardIncome[_msgSender()].round7 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 12500 ether;\\n            Wallet[add] += 12500 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(12500 ether);\\n            RewardIncome[_msgSender()].round7 = true;\\n        }  \\n        else if (silver_Referral[add].TeamIncome \\u003e= 150000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 7500  \\u0026\\u0026 RewardIncome[_msgSender()].round6 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 7500 ether;\\n            Wallet[add] += 7500 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(7500 ether);\\n            RewardIncome[_msgSender()].round6 = true;\\n        }\\n        else if (silver_Referral[add].TeamIncome \\u003e= 100000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 5000  \\u0026\\u0026 RewardIncome[_msgSender()].round5 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 5000 ether;\\n            Wallet[add] += 5000 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(5000 ether);\\n            RewardIncome[_msgSender()].round5 = true;\\n        }\\n        else if (silver_Referral[add].TeamIncome \\u003e= 75000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 3500 \\u0026\\u0026 RewardIncome[_msgSender()].round4 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 3500 ether;\\n            Wallet[add] += 3500 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(3500 ether);\\n            RewardIncome[_msgSender()].round4 = true;\\n        }\\n        else if (silver_Referral[add].TeamIncome \\u003e= 50000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 2500  \\u0026\\u0026 RewardIncome[_msgSender()].round3 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 2500 ether;\\n            Wallet[add] += 2500 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(2500 ether);\\n            RewardIncome[_msgSender()].round3 = true;\\n        }\\n        else if (silver_Referral[add].TeamIncome \\u003e= 20000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 1000  \\u0026\\u0026 RewardIncome[_msgSender()].round2 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 1000 ether;\\n            Wallet[add] += 1000 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(1000 ether);\\n            RewardIncome[_msgSender()].round2 = true;\\n        }\\n        else if (silver_Referral[add].TeamIncome \\u003e= 5000 ether \\u0026\\u0026 silver_Referral[add].Userincome \\u003e= 250 \\u0026\\u0026 RewardIncome[_msgSender()].round1 == false)\\n        {\\n            silver_Referral[add].RewardIncome += 250 ether;\\n            Wallet[add] += 250 ether;\\n            User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(250 ether);\\n            RewardIncome[_msgSender()].round1 = true;\\n        }\\n    }\\n\\n    function dictribure(uint256 _payableamount,address add) private\\n    {\\n        uint256 pkgNo = _payableamount/25 ether;\\n\\n        for(uint256 i=0; i\\u003cpkgNo;i++)\\n        {\\n        address getaddress = Silver_UserAddress[Silver_ActiveID];\\n        if(silver_Referral[getaddress].direct \\u003c  3)\\n            {\\n                silver_setUpline(add, payable(getaddress));\\n                silver_Referral[getaddress].direct += 1;\\n                Silver_UserAddress.push(add);\\n                check_Silver_address[getaddress].push(add);\\n            }\\n        else\\n            {\\n                silver_Referral[getaddress].Three_directincome += 5 ether;\\n                Wallet[getaddress] += 5 ether;\\n                pool2(getaddress); \\n                Silver_ActiveID++;\\n                getaddress = Silver_UserAddress[Silver_ActiveID];\\n                silver_setUpline(add, payable(getaddress));\\n                silver_Referral[getaddress].direct = 1;\\n                Silver_UserAddress.push(add);   \\n                check_Silver_address[getaddress].push(add);          \\n            }\\n             silver_Referral[add].deposittime = uint40(block.timestamp);\\n        }\\n    }\\n\\n\\n    function invest() payable  external nonReentrant\\n    {\\n        uint256 _payableamount = msg.value;\\n        uint256 o = _payableamount*10/100;\\n        payable(owner).transfer(o);\\n\\n\\n         require(User[_msgSender()].ActiveID == true , \\\"you are not register\\\");\\n         require( _payableamount % 25 ether ==0 , \\\"Invalid amount\\\");\\n\\n         User[_msgSender()].amount_Pool_A.push(_payableamount*200/100);\\n         User[_msgSender()].amount_Pool_B += _payableamount*300/100;\\n         User[_msgSender()].deposit_time.push(uint40(block.timestamp));\\n         User[_msgSender()].depositAmount.push(_payableamount);\\n         User[_msgSender()].PerdayReward.push((_payableamount*200/100)/selfincome_totaldays);\\n         silver_Referral[User[msg.sender].upline].TeamIncome += _payableamount;\\n         silver_Referral[msg.sender].Userincome += _payableamount;\\n         User[_msgSender()].withdrawReward.push(0);\\n\\n\\n        dictribure(_payableamount,msg.sender);\\n//.....................................................................................Reward Income..........................................\\n        rewardIncome(msg.sender);\\n    } \\n\\n\\n\\n\\n    function WithdrawSelfAmount() external nonReentrant\\n    {\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\n        uint256 x =User[_msgSender()].withdrawReward.length;\\n        for(uint256 _index ; x\\u003e _index; _index++)\\n        {\\n        uint256 R = checkReward(msg.sender,_index);\\n        payable(msg.sender).transfer(R);\\n        User[msg.sender].totalWithdrawReward +=R;\\n        User[_msgSender()].amount_Pool_B =  User[_msgSender()].amount_Pool_B.sub(R);\\n        User[_msgSender()].withdrawReward[_index] += R;\\n        \\n\\n        if(Global_Referral[Pool_User[msg.sender].L1].direct \\u003e= 1)\\n        {\\n          silver_Referral[Pool_User[msg.sender].L1].LevelIncome+= R*15/100;\\n          Wallet[Pool_User[msg.sender].L1] += R*15/100;\\n        }\\n        if(Global_Referral[Pool_User[msg.sender].L2].direct \\u003e= 2)\\n        {\\n          silver_Referral[Pool_User[msg.sender].L2].LevelIncome+= R*10/100;\\n          Wallet[Pool_User[msg.sender].L2] += R*10/100;\\n        }\\n        if(Global_Referral[Pool_User[msg.sender].L3].direct \\u003e= 3)\\n        {\\n          silver_Referral[Pool_User[msg.sender].L3].LevelIncome+= R*8/100;\\n          Wallet[Pool_User[msg.sender].L3] += R*8/100;\\n        }\\n        if(Global_Referral[Pool_User[msg.sender].L4].direct \\u003e= 4)\\n        {\\n          silver_Referral[Pool_User[msg.sender].L4].LevelIncome+= R*8/100;\\n          Wallet[Pool_User[msg.sender].L4] += R*8/100;\\n        }\\n        if(Global_Referral[Pool_User[msg.sender].L5].direct \\u003e= 5)\\n        {\\n          silver_Referral[Pool_User[msg.sender].L5].LevelIncome+= R*8/100;\\n          Wallet[Pool_User[msg.sender].L5] += R*8/100;\\n        }\\n        if(Global_Referral[Pool_User[msg.sender].L6].direct \\u003e= 6)\\n        {\\n          silver_Referral[Pool_User[msg.sender].L6].LevelIncome+= R*7/100;\\n          Wallet[Pool_User[msg.sender].L6] += R*7/100;\\n        }                        \\n        if(Global_Referral[Pool_User[msg.sender].L7].direct \\u003e= 7)\\n        {\\n          silver_Referral[Pool_User[msg.sender].L7].LevelIncome+= R*7/100;\\n          Wallet[Pool_User[msg.sender].L7] += R*7/100;\\n        }\\n        if(Global_Referral[Pool_User_team[msg.sender].L8].direct \\u003e= 8)\\n        {\\n          silver_Referral[Pool_User_team[msg.sender].L8].LevelIncome+= R*7/100;\\n          Wallet[Pool_User_team[msg.sender].L8] += R*7/100;\\n        }\\n        if(Global_Referral[Pool_User_team[msg.sender].L9].direct \\u003e= 9)\\n        {\\n          silver_Referral[Pool_User_team[msg.sender].L9].LevelIncome+= R*7/100;\\n          Wallet[Pool_User_team[msg.sender].L9] += R*7/100;\\n        }\\n        if(Global_Referral[Pool_User_team[msg.sender].L10].direct \\u003e= 10)\\n        {\\n          silver_Referral[Pool_User_team[msg.sender].L10].LevelIncome+= R*10/100;\\n          Wallet[Pool_User_team[msg.sender].L10] += R*10/100;\\n        }\\n        if(Global_Referral[Pool_User_team[msg.sender].L11].direct \\u003e= 11)\\n        {\\n          silver_Referral[Pool_User_team[msg.sender].L11].LevelIncome+= R*10/100;\\n          Wallet[Pool_User_team[msg.sender].L11] += R*10/100;\\n        }\\n        if(Global_Referral[Pool_User_team[msg.sender].L12].direct \\u003e= 12)\\n        {\\n          silver_Referral[Pool_User_team[msg.sender].L12].LevelIncome+= R*10/100;\\n          Wallet[Pool_User_team[msg.sender].L12] += R*10/100;\\n        }\\n        if(Global_Referral[Pool_User_team[msg.sender].L13].direct \\u003e= 13)\\n        {\\n          silver_Referral[Pool_User_team[msg.sender].L13].LevelIncome+= R*10/100;\\n          Wallet[Pool_User_team[msg.sender].L13] += R*10/100;\\n        }\\n        if(Global_Referral[Pool_User_team[msg.sender].L14].direct \\u003e= 14)\\n        {\\n          silver_Referral[Pool_User_team[msg.sender].L14].LevelIncome+= R*10/100;\\n          Wallet[Pool_User_team[msg.sender].L14] += R*10/100;\\n        }\\n        if(Global_Referral[Pool_User_team[msg.sender].L15].direct \\u003e= 15)\\n        {\\n          silver_Referral[Pool_User_team[msg.sender].L15].LevelIncome+= R*10/100;\\n          Wallet[Pool_User_team[msg.sender].L15] += R*10/100;\\n        }\\n    }\\n        \\n    }\\n\\n\\n\\n\\n//............................................................................................Sponsor used..................................\\n    function withdraw_Wallet_Amount(uint256 _amount) external nonReentrant\\n    {\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\n        require(silver_Referral[msg.sender].direct \\u003e= 3,\\\"3 Direct not found\\\");\\n        require(Wallet[msg.sender] \\u003e= _amount,\\\"3 Direct not found\\\");\\n        require(_amount \\u003e= 10 ether,\\\"balance low\\\");\\n        payable(msg.sender).transfer(_amount);\\n        User[msg.sender].walletwithdrawal += _amount;\\n        Wallet[msg.sender] = Wallet[msg.sender].sub(_amount); \\n        User[_msgSender()].amount_Pool_B =  User[_msgSender()].amount_Pool_B.sub(_amount);\\n    }\\n\\n\\n\\n    function withdrawSponsor() external nonReentrant\\n    {\\n        require(isContract(msg.sender) == false ,\\\"this is contract\\\");\\n        uint256 z =sponsorIncome[_msgSender()].withdrawReward.length;\\n        for(uint256 _index ; z\\u003e _index; _index++){\\n        uint256 R = SponsorReward(msg.sender,_index);\\n        payable(msg.sender).transfer(R);\\n        sponsorIncome[msg.sender].totalWithdrawReward +=R; \\n        User[_msgSender()].amount_Pool_B = User[_msgSender()].amount_Pool_B.sub(R);\\n        sponsorIncome[_msgSender()].withdrawReward[_index] +=  R;\\n        }\\n    }\\n\\n\\n    function SponsorReward(address add,uint256 index) public view returns(uint256 reward)\\n    {\\n        uint256 timeofdeposit;\\n        timeofdeposit = (uint256(block.timestamp).sub(sponsorIncome[add].Deposittime[index])).div(withdrawTime);\\n        if(timeofdeposit \\u003c selfincome_totaldays)\\n        {\\n            reward = (timeofdeposit.mul(sponsorIncome[add].dailyReward[index])).sub(sponsorIncome[add].withdrawReward[index]);\\n        }\\n        else\\n        {\\n            reward = (selfincome_totaldays.mul(sponsorIncome[add].dailyReward[index])).sub(sponsorIncome[add].withdrawReward[index]);\\n        }\\n        return (reward);\\n    }\\n    function checkReward(address add,uint256 index) public view returns(uint256 reward)\\n    {\\n        \\n       uint256 depositTime = (uint256(block.timestamp).sub(User[add].deposit_time[index])).div(withdrawTime);\\n        if(depositTime \\u003c selfincome_totaldays)\\n        {\\n            reward += ((depositTime.mul(User[add].PerdayReward[index])).sub(User[add].withdrawReward[index]));\\n        }\\n        else\\n        {\\n            reward += (selfincome_totaldays.mul(User[add].PerdayReward[index])).sub(User[add].withdrawReward[index]);\\n        }\\n        return (reward);\\n    }\\n\\n    \\n    \\n\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"CheckDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"WithdrawReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"CheckDetailsSponsor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"WithdrawReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"CheckStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_Status\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"Check_Profit_income\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"Amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"PoolA\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"PoolB\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"perdayAmount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"Check_Profit_income2\",\"outputs\":[{\"internalType\":\"uint40[]\",\"name\":\"Time\",\"type\":\"uint40[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"Check_Profit_income_Sponsor\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"Sponsor\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"PoolA\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"PoolB\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"perdayAmount\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"Global_ChakUpline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"Global_IsUpline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Global_Referral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deposittime\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"direct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LevelIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Userincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RewardIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Three_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Nine_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twenty_seven_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eighty_one\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Gold_Referral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deposittime\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"direct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LevelIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Userincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RewardIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Three_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Nine_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twenty_seven_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eighty_one\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Pool_User\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"L1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L3\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L4\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L5\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L6\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L7\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Pool_User_team\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"L8\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L9\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L10\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L11\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L12\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L13\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L14\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"L15\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"Register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RewardIncome\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"round1\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"round2\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"round3\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"round4\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"round5\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"round6\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"round7\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"round8\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"round9\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"round10\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"SponsorReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"User\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ActiveID\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_Pool_B\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawReward\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Status\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"walletwithdrawal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Wallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawSelfAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"checkReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"check_Gold_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"check_Silver_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"check_diamond_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"check_platinum_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkrefList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"Silver\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"Gold\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"platinum\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"diamond\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"diamond_Referral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deposittime\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"direct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LevelIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Userincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RewardIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Three_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Nine_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twenty_seven_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eighty_one\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"platinum_Referral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deposittime\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"direct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LevelIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Userincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RewardIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Three_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Nine_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twenty_seven_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eighty_one\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"silver_IsUpline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"silver_Referral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"deposittime\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"direct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LevelIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Userincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RewardIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Three_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Nine_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twenty_seven_directincome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eighty_one\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sponsorIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalWithdrawReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawSponsor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw_Wallet_Amount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MaticWin", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://09b4b1df6a23de2749b7760f02a1e6efa36df55c17ca96b7ae6c751965b29d9a"}