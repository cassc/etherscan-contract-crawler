{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IDAO} from \\\"./interface/IDAO.sol\\\";\\n\\n// this contract provides multisig functions that can be implemented when needed\\ncontract Multisig is Ownable {\\n    struct VoterRequest {\\n        bool status;\\n        address candidate;\\n        bool include;\\n    }\\n\\n    // mapping voter id => voter address\\n    mapping(uint256 => address) private votersIds;\\n    // mapping is address has vote ability\\n    mapping(address => bool) private voters;\\n    // how much voters(approved and deprecated)\\n    uint256 private votersCounter;\\n    // how much voters are approved\\n    uint256 private activeVoters;\\n\\n    // voter requests should be used when someone wants to add new voter or deprecate active voter\\n    mapping(uint256 => VoterRequest) private voterRequests;\\n    // mapping of signs of active voters to some voter request\\n    mapping(uint256 => mapping(address => bool))\\n        private voterRequsestsSignatures;\\n    uint256 private voterRequestCounter;\\n\\n    event NewVotersRequest(uint256[] id);\\n\\n    // constructor() {\\n    //     // owner is the first voter\\n    //     _setVoter(msg.sender);\\n    // }\\n\\n    // is voter active\\n    modifier onlyVoter() {\\n        require(voters[msg.sender], \\\"not voter\\\");\\n        _;\\n    }\\n\\n    // get information about one voter by id\\n    function getVoterById(uint256 id) public view returns (address) {\\n        return votersIds[id];\\n    }\\n\\n    // get voter's status by address\\n    function getVoterStatusByAddress(\\n        address someAddress\\n    ) public view returns (bool) {\\n        return voters[someAddress];\\n    }\\n\\n    // get active voters count\\n    function getActiveVoters() public view returns (uint256) {\\n        return activeVoters;\\n    }\\n\\n    // get all voters count\\n    function getVotersCounter() internal view returns (uint256) {\\n        return votersCounter;\\n    }\\n\\n    // create new voter after approval\\n    function setVoter(address newVoter) internal {\\n        require(newVoter != address(0), \\\"zero address\\\");\\n        require(!voters[newVoter], \\\"already voter\\\");\\n        voters[newVoter] = true;\\n        activeVoters++;\\n        votersIds[votersCounter++] = newVoter;\\n    }\\n\\n    // deprecate some voter\\n    function unsetVoter(address oldVoter) internal {\\n        require(oldVoter != address(0), \\\"zero address\\\");\\n        require(voters[oldVoter], \\\"not voter\\\");\\n        voters[oldVoter] = false;\\n        activeVoters--;\\n    }\\n\\n    // create request to add new voter to voters list\\n    function newVotersRequest(address[] memory newVoters) external onlyVoter {\\n        uint256[] memory newVotersRequestID = new uint256[](newVoters.length);\\n        for (uint256 i = 0; i < newVoters.length; i++) {\\n            require(!voters[newVoters[i]], \\\"already voter\\\");\\n            voterRequestCounter = voterRequestCounter + 1;\\n            // create request to some candidate to be a voter\\n            voterRequests[voterRequestCounter] = VoterRequest({\\n                status: false,\\n                candidate: newVoters[i],\\n                include: true\\n            });\\n            // sign request\\n            voterRequsestsSignatures[voterRequestCounter][msg.sender] = true;\\n            newVotersRequestID[i] = voterRequestCounter;\\n        }\\n\\n        emit NewVotersRequest(newVotersRequestID);\\n    }\\n\\n    //request to delete voter\\n    function deleteVotersRequest(\\n        address[] memory newVoters\\n    ) external onlyVoter {\\n        uint256[] memory newVotersRequestID = new uint256[](newVoters.length);\\n        for (uint256 i = 0; i < newVoters.length; i++) {\\n            require(voters[newVoters[i]], \\\"no such voter\\\");\\n            voterRequestCounter = voterRequestCounter + 1;\\n            // create request to some candidate to be a voter\\n            voterRequests[voterRequestCounter] = VoterRequest({\\n                status: false,\\n                candidate: newVoters[i],\\n                include: false\\n            });\\n            // sign request\\n            voterRequsestsSignatures[voterRequestCounter][msg.sender] = true;\\n            newVotersRequestID[i] = voterRequestCounter;\\n        }\\n\\n        emit NewVotersRequest(newVotersRequestID);\\n    }\\n\\n    // vote for one of voter requests list\\n    function voteForVoterRequest(uint256 id) external onlyVoter {\\n        require(!voterRequests[id].status, \\\"already approved\\\");\\n        voterRequsestsSignatures[id][msg.sender] = true;\\n    }\\n\\n    // create new voter after approval\\n    function setInitialVoter() external onlyOwner {\\n        require(activeVoters == 0, \\\"AV not empty\\\");\\n        voters[msg.sender] = true;\\n        activeVoters++;\\n        votersIds[votersCounter++] = msg.sender;\\n    }\\n\\n    // check voters request to be completed\\n    function checkVotersRequest(uint256 id) external {\\n        require(!voterRequests[id].status, \\\"already approved\\\");\\n        uint256 consensus = (activeVoters * 100) / 2;\\n        uint256 trueVotesCount = 0;\\n        for (uint256 i = 0; i < votersCounter; i++) {\\n            // signed and he voter now\\n            if (\\n                voterRequsestsSignatures[id][votersIds[i]] &&\\n                voters[votersIds[i]]\\n            ) {\\n                trueVotesCount++;\\n            }\\n        }\\n        // check is there is enough votes to complete request\\n        require(trueVotesCount * 100 > consensus, \\\"not enough\\\");\\n        if (voterRequests[id].include) {\\n            // if it's request to add new voter and there is enough votes, let's add such voter\\n            setVoter(voterRequests[id].candidate);\\n        } else {\\n            // if it's request to deprecate some voter and there is enough votes, let's deprecate such voter\\n            unsetVoter(voterRequests[id].candidate);\\n        }\\n        // set voter request as completed\\n        voterRequests[id].status = true;\\n    }\\n}\\n\\n/*\\nDAO for Bets:\\n- new voter request\\n- vote for some new voter request\\n- delete voter\\n- vote for some delete voter request\\n- new transfer(withdrawal) request\\n- vote for some transfer(withdrawal) request\\n- new owner transfer request\\n- vote for some owner transfer request\\n*/\\ncontract DAO is Multisig, IDAO {\\n    // if one of voters wants to make some transfer, he adds new transfer request and waits for signs from other voters\\n    struct TransferRequest {\\n        address recepient;\\n        address token;\\n        uint256 value;\\n        bool status;\\n    }\\n    // if one of voters wants to change owner, he adds new OwnerChangeRequest and waits for signs from other voters\\n    struct OwnerChangeRequest {\\n        address newOwner;\\n        bool status;\\n    }\\n\\n    struct DAOChangeRequest {\\n        address newDAO;\\n        bool status;\\n    }\\n    // mapping of transfer requests\\n    mapping(uint256 => TransferRequest) private transferRequests;\\n    // mapping of signs of transfer requests\\n    mapping(uint256 => mapping(address => bool))\\n        private transferRequestsSignatures;\\n    // id for new transfer request\\n    uint256 private transferRequestCounter;\\n\\n    // mapping of owner change requests\\n    mapping(uint256 => OwnerChangeRequest) private ownerChangeRequests;\\n    // mapping of signs of transfer requests\\n    mapping(uint256 => mapping(address => bool))\\n        private ownerChangeRequestsSignatures;\\n    // id for new transfer request\\n    uint256 private ownerChangeRequestCounter;\\n\\n    // mapping of DAO change requests\\n    mapping(uint256 => DAOChangeRequest) private daoChangeRequests;\\n    // mapping of signs of DAO change requests\\n    mapping(uint256 => mapping(address => bool))\\n        private daoChangeRequestsSignatures;\\n    // id for new DAO change request\\n    uint256 private daoChangeRequestCounter;\\n\\n    // bets contract may it interact with DAO results\\n    mapping(address => bool) public whitelistedBC;\\n\\n    event NewTransferRequest(uint256 id);\\n    event NewOwnerChangeRequest(uint256 id);\\n    event NewDAOChangeRequest(uint256 id);\\n\\n    modifier onlyWhitelistBC() {\\n        require(whitelistedBC[msg.sender], \\\"not bets SC\\\");\\n        _;\\n    }\\n\\n    // any admin can whitelist new bets contract\\n    function whitelistBC(address contractAddress) external onlyOwner {\\n        whitelistedBC[contractAddress] = true;\\n    }\\n\\n    // any admin can unwhitelist bets contract\\n    function unwhitelistBC(address contractAddress) external onlyOwner {\\n        require(whitelistedBC[contractAddress], \\\"W\\\");\\n        delete whitelistedBC[contractAddress];\\n    }\\n\\n    /*\\n    TRANSFER REQUESTS\\n    */\\n\\n    // if votes count for some request is enough to provide request, let's do it\\n    function isTransferAvailable(\\n        uint256 id\\n    ) external view override returns (uint256, address, address) {\\n        require(transferRequests[id].recepient != address(0), \\\"no such\\\");\\n        require(!transferRequests[id].status, \\\"already approved\\\");\\n        uint256 consensus = (getActiveVoters() * 100) / 2;\\n        uint256 trueVotesCount = 0;\\n        for (uint256 i = 0; i <= getVotersCounter(); i++) {\\n            // signed and he voter now\\n            if (\\n                transferRequestsSignatures[id][getVoterById(i)] &&\\n                getVoterStatusByAddress(getVoterById(i))\\n            ) {\\n                trueVotesCount++;\\n            }\\n        }\\n        require(trueVotesCount * 100 > consensus, \\\"not enough\\\");\\n        return (\\n            transferRequests[id].value,\\n            transferRequests[id].recepient,\\n            transferRequests[id].token\\n        );\\n    }\\n\\n    // bets contract approve that request finished\\n    function confirmTransfer(\\n        uint256 id\\n    ) external override onlyWhitelistBC returns (bool) {\\n        require(!transferRequests[id].status, \\\"already approved\\\");\\n        transferRequests[id].status = true;\\n        return true;\\n    }\\n\\n    // vote for one of transfer requests\\n    function voteForTransferRequest(uint256 id) external onlyVoter {\\n        require(!transferRequests[id].status, \\\"already approved\\\");\\n        transferRequestsSignatures[id][msg.sender] = true;\\n    }\\n\\n    // any approved active voter can create request to transfer some amount of tokens from contract to any recepient\\n    function newTransferRequest(\\n        address recipient,\\n        address token,\\n        uint256 amount\\n    ) external onlyVoter returns (uint256) {\\n        require(recipient != address(0), \\\"0x0 addr\\\");\\n        transferRequestCounter = transferRequestCounter + 1;\\n        transferRequests[transferRequestCounter] = TransferRequest({\\n            recepient: recipient,\\n            value: amount,\\n            status: false,\\n            token: token\\n        });\\n        // sign request\\n        transferRequestsSignatures[transferRequestCounter][msg.sender] = true;\\n        emit NewTransferRequest(transferRequestCounter);\\n        return transferRequestCounter;\\n    }\\n\\n    /*\\n    OWNER CHANGE\\n    */\\n    // if votes count for some request is enough to provide request, let's do it\\n    function isOwnerChangeAvailable(\\n        uint256 id\\n    ) external view override returns (address) {\\n        require(ownerChangeRequests[id].newOwner != address(0), \\\"no such\\\");\\n        require(!ownerChangeRequests[id].status, \\\"already approved\\\");\\n        uint256 consensus = (getActiveVoters() * 100) / 2;\\n        uint256 trueVotesCount = 0;\\n        for (uint256 i = 0; i <= getVotersCounter(); i++) {\\n            // signed and he voter now\\n            if (\\n                ownerChangeRequestsSignatures[id][getVoterById(i)] &&\\n                getVoterStatusByAddress(getVoterById(i))\\n            ) {\\n                trueVotesCount++;\\n            }\\n        }\\n        require(trueVotesCount * 100 > consensus, \\\"not enough\\\");\\n        return ownerChangeRequests[id].newOwner;\\n    }\\n\\n    // bets contract approve that request finished\\n    function confirmOwnerChange(\\n        uint256 id\\n    ) external override onlyWhitelistBC returns (bool) {\\n        require(!ownerChangeRequests[id].status, \\\"already approved\\\");\\n        ownerChangeRequests[id].status = true;\\n        return true;\\n    }\\n\\n    // vote for one of voter requests list\\n    function voteForOwnerChangeRequest(uint256 id) external onlyVoter {\\n        require(!ownerChangeRequests[id].status, \\\"already approved\\\");\\n        ownerChangeRequestsSignatures[id][msg.sender] = true;\\n    }\\n\\n    // any approved active voter can create request to change owner\\n    function newOwnerChangeRequest(\\n        address newOwner\\n    ) external onlyVoter returns (uint256) {\\n        require(newOwner != address(0), \\\"0x0 addr\\\");\\n        ownerChangeRequestCounter = ownerChangeRequestCounter + 1;\\n        ownerChangeRequests[ownerChangeRequestCounter] = OwnerChangeRequest({\\n            newOwner: newOwner,\\n            status: false\\n        });\\n        // sign request\\n        ownerChangeRequestsSignatures[ownerChangeRequestCounter][\\n            msg.sender\\n        ] = true;\\n        emit NewOwnerChangeRequest(ownerChangeRequestCounter);\\n        return ownerChangeRequestCounter;\\n    }\\n\\n    /*\\n    DAO CHANGE\\n    */\\n    // if votes count for some request is enough to provide request, let's do it\\n    function isDAOChangeAvailable(\\n        uint256 id\\n    ) external view override returns (address) {\\n        require(daoChangeRequests[id].newDAO != address(0), \\\"no such\\\");\\n        require(!daoChangeRequests[id].status, \\\"already approved\\\");\\n        uint256 consensus = (getActiveVoters() * 100) / 2;\\n        uint256 trueVotesCount = 0;\\n        for (uint256 i = 0; i <= getVotersCounter(); i++) {\\n            // signed and he voter now\\n            if (\\n                daoChangeRequestsSignatures[id][getVoterById(i)] &&\\n                getVoterStatusByAddress(getVoterById(i))\\n            ) {\\n                trueVotesCount++;\\n            }\\n        }\\n        require(trueVotesCount * 100 > consensus, \\\"not enough\\\");\\n        return daoChangeRequests[id].newDAO;\\n    }\\n\\n    // bets contract approve that request finished\\n    function confirmDAOChange(\\n        uint256 id\\n    ) external override onlyWhitelistBC returns (bool) {\\n        require(!daoChangeRequests[id].status, \\\"already approved\\\");\\n        daoChangeRequests[id].status = true;\\n        return true;\\n    }\\n\\n    // vote for one of voter requests list\\n    function voteForDAOChangeRequest(uint256 id) external onlyVoter {\\n        require(!daoChangeRequests[id].status, \\\"already approved\\\");\\n        daoChangeRequestsSignatures[id][msg.sender] = true;\\n    }\\n\\n    // any approved active voter can create request to change owner\\n    function newDAOChangeRequest(\\n        address newDAO\\n    ) external onlyVoter returns (uint256) {\\n        require(newDAO != address(0), \\\"0x0 addr\\\");\\n        daoChangeRequestCounter = daoChangeRequestCounter + 1;\\n        daoChangeRequests[daoChangeRequestCounter] = DAOChangeRequest({\\n            newDAO: newDAO,\\n            status: false\\n        });\\n        // sign request\\n        daoChangeRequestsSignatures[daoChangeRequestCounter][msg.sender] = true;\\n        emit NewDAOChangeRequest(daoChangeRequestCounter);\\n        return daoChangeRequestCounter;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IDAO {\\n    function isTransferAvailable(\\n        uint256 id\\n    ) external view returns (uint256, address, address);\\n\\n    function confirmTransfer(uint256 id) external returns (bool);\\n\\n    function isOwnerChangeAvailable(uint256 id) external view returns (address);\\n\\n    function confirmOwnerChange(uint256 id) external returns (bool);\\n\\n    function isDAOChangeAvailable(uint256 id) external view returns (address);\\n\\n    function confirmDAOChange(uint256 id) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"NewDAOChangeRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"NewOwnerChangeRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"NewTransferRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"id\",\"type\":\"uint256[]\"}],\"name\":\"NewVotersRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"checkVotersRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"confirmDAOChange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"confirmOwnerChange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"confirmTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newVoters\",\"type\":\"address[]\"}],\"name\":\"deleteVotersRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveVoters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getVoterById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"someAddress\",\"type\":\"address\"}],\"name\":\"getVoterStatusByAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isDAOChangeAvailable\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isOwnerChangeAvailable\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isTransferAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"newDAOChangeRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"newOwnerChangeRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"newTransferRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newVoters\",\"type\":\"address[]\"}],\"name\":\"newVotersRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setInitialVoter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"unwhitelistBC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"voteForDAOChangeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"voteForOwnerChangeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"voteForTransferRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"voteForVoterRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"whitelistBC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedBC\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DAO", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}