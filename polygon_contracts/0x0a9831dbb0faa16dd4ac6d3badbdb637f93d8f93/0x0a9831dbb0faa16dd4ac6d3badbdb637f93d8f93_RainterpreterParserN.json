{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/concrete/RainterpreterParserNPE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport {IERC165, ERC165} from \\\"openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\\\";\\n\\nimport {LibParse} from \\\"../lib/parse/LibParse.sol\\\";\\nimport {IParserV1} from \\\"../interface/IParserV1.sol\\\";\\n\\nbytes32 constant PARSER_BYTECODE_HASH = bytes32(0xde02760d93dec05e1553b1a54de69bdd1c64ffcef6ebb20a4a6109df2ec5732c);\\n\\nbytes constant PARSE_META =\\n    hex\\\"017a080114205002002c00848000416d2042008ed20000000464021001001004e8110a007c002d28002d2b341b001a21c91a004cb6051400d9d29616004abb9c0110addc6812003d955420001bfdef23007d4cd81c30fb30cd0e0060ca202700a4141c07009dee3e1e40349ac22400558f3d13000220b61500ba9a911700a6ced42e10a955a21d402ce6e10010c470af2a009f3d741f00494def220017715c090045b05a2d10ae8adc26003493031800f4d5982b00ae2be00420f74b9a0c008800380d0096ac190320456e6421008a324c052063d1bc08006e3d3a2c00e6a9900200f2bd181110ef0a8229002e7f58190012180a06203cde9c0f00bf79181010d998ae0b00bcdfd8250044e506\\\";\\n\\nuint8 constant PARSE_META_BUILD_DEPTH = 2;\\n\\ncontract RainterpreterParserNPE2 is IParserV1, ERC165 {\\n    /// @inheritdoc ERC165\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return interfaceId == type(IParserV1).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc IParserV1\\n    function parse(bytes memory data) external pure virtual override returns (bytes memory, uint256[] memory) {\\n        // The return is used by returning it, so this is a false positive.\\n        //slither-disable-next-line unused-return\\n        return LibParse.parse(data, parseMeta());\\n    }\\n\\n    /// Virtual function to return the parse meta.\\n    function parseMeta() internal pure virtual returns (bytes memory) {\\n        return PARSE_META;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/parse/LibParse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport {LibPointer, Pointer} from \\\"rain.solmem/lib/LibPointer.sol\\\";\\nimport {LibMemCpy} from \\\"rain.solmem/lib/LibMemCpy.sol\\\";\\nimport {\\n    CMASK_COMMENT_HEAD,\\n    CMASK_EOS,\\n    CMASK_EOL,\\n    CMASK_LITERAL_HEAD,\\n    CMASK_WHITESPACE,\\n    CMASK_RIGHT_PAREN,\\n    CMASK_LEFT_PAREN,\\n    CMASK_RHS_WORD_TAIL,\\n    CMASK_RHS_WORD_HEAD,\\n    CMASK_LHS_RHS_DELIMITER,\\n    CMASK_LHS_STACK_TAIL,\\n    CMASK_LHS_STACK_HEAD,\\n    COMMENT_START_SEQUENCE,\\n    COMMENT_END_SEQUENCE,\\n    CMASK_IDENTIFIER_HEAD\\n} from \\\"./LibParseCMask.sol\\\";\\nimport {LibCtPop} from \\\"../bitwise/LibCtPop.sol\\\";\\nimport {LibParseMeta} from \\\"./LibParseMeta.sol\\\";\\nimport {LibParseLiteral} from \\\"./LibParseLiteral.sol\\\";\\nimport {LibParseOperand} from \\\"./LibParseOperand.sol\\\";\\nimport {Operand} from \\\"../../interface/unstable/IInterpreterV2.sol\\\";\\nimport {LibParseStackName} from \\\"./LibParseStackName.sol\\\";\\n\\n/// The expression does not finish with a semicolon (EOF).\\nerror MissingFinalSemi(uint256 offset);\\n\\n/// Enountered an unexpected character on the LHS.\\nerror UnexpectedLHSChar(uint256 offset);\\n\\n/// Encountered an unexpected character on the RHS.\\nerror UnexpectedRHSChar(uint256 offset);\\n\\n/// More specific version of UnexpectedRHSChar where we specifically expected\\n/// a left paren but got some other char.\\nerror ExpectedLeftParen(uint256 offset);\\n\\n/// Encountered a right paren without a matching left paren.\\nerror UnexpectedRightParen(uint256 offset);\\n\\n/// Encountered an unclosed left paren.\\nerror UnclosedLeftParen(uint256 offset);\\n\\n/// Encountered a comment outside the interstitial space between lines.\\nerror UnexpectedComment(uint256 offset);\\n\\n/// Encountered a comment start sequence that is malformed.\\nerror MalformedCommentStart(uint256 offset);\\n\\n/// @dev Thrown when a stack name is duplicated. Shadowing in all forms is\\n/// disallowed in Rainlang.\\nerror DuplicateLHSItem(uint256 errorOffset);\\n\\n/// Encountered too many LHS items.\\nerror ExcessLHSItems(uint256 offset);\\n\\n/// Encountered inputs where they can't be handled.\\nerror NotAcceptingInputs(uint256 offset);\\n\\n/// Encountered too many RHS items.\\nerror ExcessRHSItems(uint256 offset);\\n\\n/// Encountered a word that is longer than 32 bytes.\\nerror WordSize(string word);\\n\\n/// Parsed a word that is not in the meta.\\nerror UnknownWord(uint256 offset);\\n\\n/// The parser exceeded the maximum number of sources that it can build.\\nerror MaxSources();\\n\\n/// The parser encountered a dangling source. This is a bug in the parser.\\nerror DanglingSource();\\n\\n/// The parser moved past the end of the data.\\nerror ParserOutOfBounds();\\n\\n/// The parser encountered a stack deeper than it can process in the memory\\n/// region allocated for stack names.\\nerror StackOverflow();\\n\\n/// The parser encountered a stack underflow.\\nerror StackUnderflow();\\n\\n/// The parser encountered a paren group deeper than it can process in the\\n/// memory region allocated for paren tracking.\\nerror ParenOverflow();\\n\\nuint256 constant NOT_LOW_16_BIT_MASK = ~uint256(0xFFFF);\\nuint256 constant ACTIVE_SOURCE_MASK = NOT_LOW_16_BIT_MASK;\\n\\nuint256 constant FSM_RHS_MASK = 1;\\nuint256 constant FSM_YANG_MASK = 1 << 1;\\nuint256 constant FSM_WORD_END_MASK = 1 << 2;\\nuint256 constant FSM_ACCEPTING_INPUTS_MASK = 1 << 3;\\n\\n/// @dev The space between lines where comments and whitespace is allowed.\\n/// The first LHS item breaks us out of the interstitial.\\nuint256 constant FSM_INTERSTITIAL_MASK = 1 << 4;\\n\\n/// @dev If a source is active we cannot finish parsing without a semi to trigger\\n/// finalisation.\\nuint256 constant FSM_ACTIVE_SOURCE_MASK = 1 << 5;\\n\\n/// @dev fsm default state is:\\n/// - LHS\\n/// - yin\\n/// - not word end\\n/// - accepting inputs\\n/// - interstitial\\nuint256 constant FSM_DEFAULT = FSM_ACCEPTING_INPUTS_MASK | FSM_INTERSTITIAL_MASK;\\n\\nuint256 constant EMPTY_ACTIVE_SOURCE = 0x20;\\n\\n/// @dev The opcode that will be used in the source to represent a stack copy\\n/// implied by named LHS stack items.\\n/// @dev @todo support the meta defining the opcode.\\nuint256 constant OPCODE_STACK = 0;\\n\\n/// @dev The opcode that will be used in the source to read a constant.\\n/// @dev @todo support the meta defining the opcode.\\nuint256 constant OPCODE_CONSTANT = 1;\\n\\ntype StackTracker is uint256;\\n\\n/// The parser is stateful. This struct keeps track of the entire state.\\n/// @param activeSourcePtr The pointer to the current source being built.\\n/// The active source being pointed to is:\\n/// - low 16 bits: bitwise offset into the source for the next word to be\\n///   written. Starts at 0x20. Once a source is no longer the active source, i.e.\\n///   it is full and a member of the LL tail, the offset is replaced with a\\n///   pointer to the next source (towards the head) to build a doubly linked\\n///   list.\\n/// - mid 16 bits: pointer to the previous active source (towards the tail). This\\n///   is a linked list of sources that are built RTL and then reversed to LTR to\\n///   eval.\\n/// - high bits: 4 byte opcodes and operand pairs.\\n/// @param sourcesBuilder A builder for the sources array. This is a 256 bit\\n/// integer where each 16 bits is a literal memory pointer to a source.\\n/// @param fsm The finite state machine representation of the parser.\\n/// - bit 0: LHS/RHS => 0 = LHS, 1 = RHS\\n/// - bit 1: yang/yin => 0 = yin, 1 = yang\\n/// - bit 2: word end => 0 = not end, 1 = end\\n/// - bit 3: accepting inputs => 0 = not accepting, 1 = accepting\\n/// - bit 4: interstitial => 0 = not interstitial, 1 = interstitial\\n/// @param topLevel0 Memory region for stack word counters. The first byte is a\\n/// counter/offset into the region, which increments for every top level item\\n/// parsed on the RHS. The remaining 31 bytes are the word counters for each\\n/// stack item, which are incremented for every op pushed to the source. This is\\n/// reset to 0 for every new source.\\n/// @param topLevel1 31 additional bytes of stack words, allowing for 62 top\\n/// level stack items total per source. The final byte is used to count the\\n/// stack height according to the LHS for the current source. This is reset to 0\\n/// for every new source.\\n/// @param parenTracker0 Memory region for tracking pointers to words in the\\n/// source, and counters for the number of words in each paren group. The first\\n/// byte is a counter/offset into the region. The second byte is a phantom\\n/// counter for the root level, the remaining 30 bytes are the paren group words.\\n/// @param parenTracker1 32 additional bytes of paren group words.\\n/// @param lineTracker A 32 byte memory region for tracking the current line.\\n/// Will be partially reset for each line when `balanceLine` is called. Fully\\n/// reset when a new source is started.\\n/// Bytes from low to high:\\n/// - byte 0: Lowest byte is the number of LHS items parsed. This is the low\\n/// byte so that a simple ++ is a valid operation on the line tracker while\\n/// parsing the LHS. This is reset to 0 for each new line.\\n/// - byte 1: A snapshot of the first high byte of `topLevel0`, i.e. the offset\\n/// of top level items as at the beginning of the line. This is reset to the high\\n/// byte of `topLevel0` on each new line.\\n/// - bytes 2+: A sequence of 2 byte pointers to before the start of each top\\n/// level item, which is implictly after the end of the previous top level item.\\n/// Allows us to quickly find the start of the RHS source for each top level\\n/// item.\\n/// @param stackNames A linked list of stack names. As the parser encounters\\n/// named stack items it pushes them onto this linked list. The linked list is\\n/// in FILO order, so the first item on the stack is the last item in the list.\\n/// This makes it more efficient to reference more recent stack names on the RHS.\\n/// @param literalBloom A bloom filter of all the literals that have been\\n/// encountered so far. This is used to quickly dedupe literals.\\n/// @param constantsBuilder A builder for the constants array.\\n/// @param literalParsers A 256 bit integer where each 16 bits is a function\\n/// pointer to a literal parser.\\nstruct ParseState {\\n    /// @dev START things that are referenced directly in assembly by hardcoded\\n    /// offsets. E.g.\\n    /// - `pushOpToSource`\\n    /// - `snapshotSourceHeadToLineTracker`\\n    /// - `newSource`\\n    uint256 activeSourcePtr;\\n    uint256 topLevel0;\\n    uint256 topLevel1;\\n    uint256 parenTracker0;\\n    uint256 parenTracker1;\\n    uint256 lineTracker;\\n    /// @dev END things that are referenced directly in assembly by hardcoded\\n    /// offsets.\\n    uint256 sourcesBuilder;\\n    uint256 fsm;\\n    uint256 stackNames;\\n    uint256 stackNameBloom;\\n    uint256 literalBloom;\\n    uint256 constantsBuilder;\\n    uint256 literalParsers;\\n    uint256 operandParsers;\\n    StackTracker stackTracker;\\n}\\n\\nlibrary LibStackTracker {\\n    using LibStackTracker for StackTracker;\\n\\n    /// Pushing inputs requires special handling as the inputs need to be tallied\\n    /// separately and in addition to the regular stack pushes.\\n    function pushInputs(StackTracker tracker, uint256 n) internal pure returns (StackTracker) {\\n        unchecked {\\n            tracker = tracker.push(n);\\n            uint256 inputs = (StackTracker.unwrap(tracker) >> 8) & 0xFF;\\n            inputs += n;\\n            return StackTracker.wrap((StackTracker.unwrap(tracker) & ~uint256(0xFF00)) | (inputs << 8));\\n        }\\n    }\\n\\n    function push(StackTracker tracker, uint256 n) internal pure returns (StackTracker) {\\n        unchecked {\\n            uint256 current = StackTracker.unwrap(tracker) & 0xFF;\\n            uint256 inputs = (StackTracker.unwrap(tracker) >> 8) & 0xFF;\\n            uint256 max = StackTracker.unwrap(tracker) >> 0x10;\\n            current += n;\\n            if (current > max) {\\n                max = current;\\n            }\\n            return StackTracker.wrap(current | (inputs << 8) | (max << 0x10));\\n        }\\n    }\\n\\n    function pop(StackTracker tracker, uint256 n) internal pure returns (StackTracker) {\\n        unchecked {\\n            uint256 current = StackTracker.unwrap(tracker) & 0xFF;\\n            if (current < n) {\\n                revert StackUnderflow();\\n            }\\n            return StackTracker.wrap(StackTracker.unwrap(tracker) - n);\\n        }\\n    }\\n}\\n\\nlibrary LibParseState {\\n    using LibParseState for ParseState;\\n    using LibStackTracker for StackTracker;\\n\\n    function resetSource(ParseState memory state) internal pure {\\n        uint256 activeSourcePtr;\\n        uint256 emptyActiveSource = EMPTY_ACTIVE_SOURCE;\\n        assembly (\\\"memory-safe\\\") {\\n            activeSourcePtr := mload(0x40)\\n            mstore(activeSourcePtr, emptyActiveSource)\\n            mstore(0x40, add(activeSourcePtr, 0x20))\\n        }\\n        state.activeSourcePtr = activeSourcePtr;\\n        state.topLevel0 = 0;\\n        state.topLevel1 = 0;\\n        state.parenTracker0 = 0;\\n        state.parenTracker1 = 0;\\n        state.lineTracker = 0;\\n        state.stackNames = 0;\\n        state.stackNameBloom = 0;\\n        state.stackTracker = StackTracker.wrap(0);\\n    }\\n\\n    function newState() internal pure returns (ParseState memory) {\\n        ParseState memory state = ParseState(\\n            // activeSource\\n            // (will be built in `newActiveSource`)\\n            0,\\n            // topLevel0\\n            0,\\n            // topLevel1\\n            0,\\n            // parenTracker0\\n            0,\\n            // parenTracker1\\n            0,\\n            // lineTracker\\n            // (will be built in `newActiveSource`)\\n            0,\\n            // sourcesBuilder\\n            0,\\n            // fsm\\n            FSM_DEFAULT,\\n            // stackNames\\n            0,\\n            // stackNameBloom\\n            0,\\n            // literalBloom\\n            0,\\n            // constantsBuilder\\n            0,\\n            // literalParsers\\n            LibParseLiteral.buildLiteralParsers(),\\n            // operandParsers\\n            LibParseOperand.buildOperandParsers(),\\n            // stackTracker\\n            StackTracker.wrap(0)\\n        );\\n        state.resetSource();\\n        return state;\\n    }\\n\\n    // Find the pointer to the first opcode in the source LL. Put it in the line\\n    // tracker at the appropriate offset.\\n    function snapshotSourceHeadToLineTracker(ParseState memory state) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            let topLevel0Pointer := add(state, 0x20)\\n            let totalRHSTopLevel := byte(0, mload(topLevel0Pointer))\\n            // Only do stuff if the current word counter is zero.\\n            if iszero(byte(0, mload(add(topLevel0Pointer, add(totalRHSTopLevel, 1))))) {\\n                let sourceHead := mload(state)\\n                let byteOffset := div(and(mload(sourceHead), 0xFFFF), 8)\\n                sourceHead := add(sourceHead, sub(0x20, byteOffset))\\n\\n                let lineTracker := mload(add(state, 0xa0))\\n                let lineRHSTopLevel := sub(totalRHSTopLevel, byte(30, lineTracker))\\n                let offset := mul(0x10, add(lineRHSTopLevel, 1))\\n                lineTracker := or(lineTracker, shl(offset, sourceHead))\\n                mstore(add(state, 0xa0), lineTracker)\\n            }\\n        }\\n    }\\n\\n    function endLine(ParseState memory state, bytes memory data, uint256 cursor) internal pure {\\n        unchecked {\\n            {\\n                uint256 parenOffset;\\n                assembly (\\\"memory-safe\\\") {\\n                    parenOffset := byte(0, mload(add(state, 0x60)))\\n                }\\n                if (parenOffset > 0) {\\n                    revert UnclosedLeftParen(LibParse.parseErrorOffset(data, cursor));\\n                }\\n            }\\n\\n            // This will snapshot the current head of the source, which will be\\n            // the start of where we want to read for the final line RHS item,\\n            // if it exists.\\n            state.snapshotSourceHeadToLineTracker();\\n\\n            // Preserve the accepting inputs flag but set\\n            // everything else back to defaults. Also set that\\n            // there is an active source.\\n            state.fsm = (FSM_DEFAULT & ~FSM_ACCEPTING_INPUTS_MASK) | (state.fsm & FSM_ACCEPTING_INPUTS_MASK)\\n                | FSM_ACTIVE_SOURCE_MASK;\\n\\n            uint256 lineLHSItems = state.lineTracker & 0xFF;\\n            // Total number of RHS at top level is the top byte of topLevel0.\\n            uint256 totalRHSTopLevel = state.topLevel0 >> 0xf8;\\n            // Snapshot for RHS from start of line is second low byte of\\n            // lineTracker.\\n            uint256 lineRHSTopLevel = totalRHSTopLevel - ((state.lineTracker >> 8) & 0xFF);\\n\\n            // If:\\n            // - we are accepting inputs\\n            // - the RHS on this line is empty\\n            // Then we treat the LHS items as inputs to the source. This means that\\n            // we need to move the RHS offset to the end of the LHS items. There MAY\\n            // be 0 LHS items, e.g. if the entire source is empty. This can only\\n            // happen at the start of the source, as any RHS item immediately flips\\n            // the FSM to not accepting inputs.\\n            if (lineRHSTopLevel == 0) {\\n                if (state.fsm & FSM_ACCEPTING_INPUTS_MASK == 0) {\\n                    revert NotAcceptingInputs(LibParse.parseErrorOffset(data, cursor));\\n                } else {\\n                    // As there are no RHS opcodes yet we can simply set topLevel0 directly.\\n                    // This is the only case where we defer to the LHS to tell\\n                    // us how many top level items there are.\\n                    totalRHSTopLevel += lineLHSItems;\\n                    state.topLevel0 = totalRHSTopLevel << 0xf8;\\n\\n                    // Push the inputs onto the stack tracker.\\n                    state.stackTracker = state.stackTracker.pushInputs(lineLHSItems);\\n                }\\n            }\\n            // If:\\n            // - there are multiple RHS items on this line\\n            // Then there must be the same number of LHS items. Multi or zero output\\n            // RHS top level items are NOT supported unless they are the only RHS\\n            // item on that line.\\n            else if (lineRHSTopLevel > 1) {\\n                if (lineLHSItems < lineRHSTopLevel) {\\n                    revert ExcessRHSItems(LibParse.parseErrorOffset(data, cursor));\\n                } else if (lineLHSItems > lineRHSTopLevel) {\\n                    revert ExcessLHSItems(LibParse.parseErrorOffset(data, cursor));\\n                }\\n            }\\n\\n            // Follow pointers to the start of the RHS item.\\n            uint256 topLevelOffset = 1 + totalRHSTopLevel - lineRHSTopLevel;\\n            uint256 end = (0x10 * lineRHSTopLevel) + 0x20;\\n            for (uint256 offset = 0x20; offset < end; offset += 0x10) {\\n                uint256 itemSourceHead = (state.lineTracker >> offset) & 0xFFFF;\\n                uint256 opsDepth;\\n                assembly (\\\"memory-safe\\\") {\\n                    opsDepth := byte(0, mload(add(state, add(0x20, topLevelOffset))))\\n                }\\n                for (uint256 i = 1; i <= opsDepth; i++) {\\n                    {\\n                        // We've hit the end of a LL item so have to jump towards the\\n                        // tail to keep going.\\n                        if (itemSourceHead % 0x20 == 0x1c) {\\n                            assembly (\\\"memory-safe\\\") {\\n                                itemSourceHead := shr(0xf0, mload(itemSourceHead))\\n                            }\\n                        }\\n                        uint256 opInputs;\\n                        assembly (\\\"memory-safe\\\") {\\n                            opInputs := byte(1, mload(itemSourceHead))\\n                        }\\n                        state.stackTracker = state.stackTracker.pop(opInputs);\\n                        // Nested multi or zero output RHS items are NOT\\n                        // supported. If the top level RHS item is the ONLY RHS\\n                        // item on the line then it MAY have multiple or zero\\n                        // outputs. In this case we defer to the LHS to tell us\\n                        // how many outputs there are. If the LHS is wrong then\\n                        // later integrity checks will need to flag it.\\n                        state.stackTracker =\\n                            state.stackTracker.push(i == opsDepth && lineRHSTopLevel == 1 ? lineLHSItems : 1);\\n                    }\\n                    itemSourceHead += 4;\\n                }\\n                topLevelOffset++;\\n            }\\n\\n            state.lineTracker = totalRHSTopLevel << 8;\\n        }\\n    }\\n\\n    /// We potentially just closed out some group of arbitrarily nested parens\\n    /// OR a lone literal value at the top level. IF we are at the top level we\\n    /// move the immutable stack highwater mark forward 1 item, which moves the\\n    /// RHS offset forward 1 byte to start a new word counter.\\n    function highwater(ParseState memory state) internal pure {\\n        uint256 parenOffset;\\n        assembly (\\\"memory-safe\\\") {\\n            parenOffset := byte(0, mload(add(state, 0x60)))\\n        }\\n        if (parenOffset == 0) {\\n            uint256 newStackRHSOffset;\\n            assembly (\\\"memory-safe\\\") {\\n                let stackRHSOffsetPtr := add(state, 0x20)\\n                newStackRHSOffset := add(byte(0, mload(stackRHSOffsetPtr)), 1)\\n                mstore8(stackRHSOffsetPtr, newStackRHSOffset)\\n            }\\n            if (newStackRHSOffset == 0x3f) {\\n                revert StackOverflow();\\n            }\\n        }\\n    }\\n\\n    function pushLiteral(ParseState memory state, bytes memory data, uint256 cursor) internal pure returns (uint256) {\\n        unchecked {\\n            (\\n                function(bytes memory, uint256, uint256) pure returns (uint256) parser,\\n                uint256 innerStart,\\n                uint256 innerEnd,\\n                uint256 outerEnd\\n            ) = LibParseLiteral.boundLiteral(state.literalParsers, data, cursor);\\n            uint256 fingerprint;\\n            uint256 fingerprintBloom;\\n            assembly (\\\"memory-safe\\\") {\\n                fingerprint := and(keccak256(cursor, sub(outerEnd, cursor)), not(0xFFFF))\\n                //slither-disable-next-line incorrect-shift\\n                fingerprintBloom := shl(byte(0, fingerprint), 1)\\n            }\\n\\n            // Whether the literal is a duplicate.\\n            bool exists = false;\\n\\n            // The index of the literal in the linked list of literals. This is\\n            // starting from the top of the linked list, so the final index is\\n            // the height of the linked list minus this value.\\n            uint256 t = 1;\\n\\n            // If the literal is in the bloom filter, then it MAY be a duplicate.\\n            // Try to find the literal in the linked list of literals using the\\n            // full fingerprint for better collision resistance than the bloom.\\n            //\\n            // If the literal is NOT in the bloom filter, then it is definitely\\n            // NOT a duplicate, so avoid traversing the linked list.\\n            //\\n            // Worst case is a false positive in the bloom filter, which means\\n            // we traverse the linked list and find no match. This is O(1) for\\n            // the bloom filter and O(n) for the linked list traversal, then\\n            // O(m) for the per-char literal parsing. The bloom filter is\\n            // 256 bits, so the chance of there being at least one false positive\\n            // over 10 literals is ~15% due to the birthday paradox.\\n            if (state.literalBloom & fingerprintBloom != 0) {\\n                uint256 tailPtr = state.constantsBuilder >> 0x10;\\n                while (tailPtr != 0) {\\n                    uint256 tailKey;\\n                    assembly (\\\"memory-safe\\\") {\\n                        tailKey := mload(tailPtr)\\n                    }\\n                    // If the fingerprint  matches, then the literal IS a duplicate,\\n                    // with 240 bits of collision resistance. The value sits alongside\\n                    // the key in memory.\\n                    if (fingerprint == (tailKey & ~uint256(0xFFFF))) {\\n                        exists = true;\\n                        break;\\n                    }\\n\\n                    assembly (\\\"memory-safe\\\") {\\n                        // Tail pointer is the low 16 bits of the key.\\n                        tailPtr := and(mload(tailPtr), 0xFFFF)\\n                    }\\n                    t++;\\n                }\\n            }\\n\\n            // Push the literal opcode to the source.\\n            // The index is either the height of the constants, if the literal\\n            // is NOT a duplicate, or the height minus the index of the\\n            // duplicate. This is because the final constants array is built\\n            // 0 indexed from the bottom of the linked list to the top.\\n            {\\n                uint256 constantsHeight = state.constantsBuilder & 0xFFFF;\\n                state.pushOpToSource(OPCODE_CONSTANT, Operand.wrap(exists ? constantsHeight - t : constantsHeight));\\n            }\\n\\n            // If the literal is not a duplicate, then we need to add it to the\\n            // linked list of literals so that `t` can point to it, and we can\\n            // build the constants array from the values in the linked list\\n            // later.\\n            if (!exists) {\\n                uint256 ptr;\\n                assembly (\\\"memory-safe\\\") {\\n                    // Allocate two words.\\n                    ptr := mload(0x40)\\n                    mstore(0x40, add(ptr, 0x40))\\n                }\\n                // First word is the key.\\n                {\\n                    // tail key is the fingerprint with the low 16 bits set to\\n                    // the pointer to the next item in the linked list. If there\\n                    // is no next item then the pointer is 0.\\n                    uint256 tailKey = state.constantsBuilder >> 0x10 | fingerprint;\\n                    assembly (\\\"memory-safe\\\") {\\n                        mstore(ptr, tailKey)\\n                    }\\n                }\\n                // Second word is the value.\\n                {\\n                    uint256 tailValue = parser(data, innerStart, innerEnd);\\n\\n                    assembly (\\\"memory-safe\\\") {\\n                        // Second word is the value\\n                        mstore(add(ptr, 0x20), tailValue)\\n                    }\\n                }\\n\\n                state.constantsBuilder = ((state.constantsBuilder & 0xFFFF) + 1) | (ptr << 0x10);\\n                state.literalBloom |= fingerprintBloom;\\n            }\\n\\n            return outerEnd;\\n        }\\n    }\\n\\n    function pushOpToSource(ParseState memory state, uint256 opcode, Operand operand) internal pure {\\n        unchecked {\\n            // This might be a top level item so try to snapshot its pointer to\\n            // the line tracker before writing the stack counter.\\n            state.snapshotSourceHeadToLineTracker();\\n\\n            // As soon as we push an op to source we can no longer accept inputs.\\n            state.fsm &= ~FSM_ACCEPTING_INPUTS_MASK;\\n            // We also have an active source;\\n            state.fsm |= FSM_ACTIVE_SOURCE_MASK;\\n\\n            // Increment the top level stack counter for the current top level\\n            // word. MAY be setting 0 to 1 if this is the top level.\\n            assembly (\\\"memory-safe\\\") {\\n                // Hardcoded offset into the state struct.\\n                let counterOffset := add(state, 0x20)\\n                let counterPointer := add(counterOffset, add(byte(0, mload(counterOffset)), 1))\\n                // Increment the counter.\\n                mstore8(counterPointer, add(byte(0, mload(counterPointer)), 1))\\n            }\\n\\n            uint256 activeSource;\\n            uint256 offset;\\n            assembly (\\\"memory-safe\\\") {\\n                let activeSourcePointer := mload(state)\\n                activeSource := mload(activeSourcePointer)\\n                // The low 16 bits of the active source is the current offset.\\n                offset := and(activeSource, 0xFFFF)\\n\\n                // The offset is in bits so for a byte pointer we need to divide\\n                // by 8, then add 4 to move to the operand low byte.\\n                let inputsBytePointer := sub(add(activeSourcePointer, 0x20), add(div(offset, 8), 4))\\n\\n                // Increment the paren input counter. The input counter is for the paren\\n                // group that is currently being built. This means the counter is for\\n                // the paren group that is one level above the current paren offset.\\n                // Assumes that every word has exactly 1 output, therefore the input\\n                // counter always increases by 1.\\n                // Hardcoded offset into the state struct.\\n                let inputCounterPos := add(state, 0x60)\\n                inputCounterPos :=\\n                    add(\\n                        add(\\n                            inputCounterPos,\\n                            // the offset\\n                            byte(0, mload(inputCounterPos))\\n                        ),\\n                        // +2 for the reserved bytes -1 to move back to the counter\\n                        // for the previous paren group.\\n                        1\\n                    )\\n                // Increment the parent counter.\\n                mstore8(inputCounterPos, add(byte(0, mload(inputCounterPos)), 1))\\n                // Zero out the current counter.\\n                mstore8(add(inputCounterPos, 3), 0)\\n\\n                // Write the operand low byte pointer into the paren tracker.\\n                // Move 3 bytes after the input counter pos, then shift down 32\\n                // bytes to accomodate the full mload.\\n                let parenTrackerPointer := sub(inputCounterPos, 29)\\n                mstore(parenTrackerPointer, or(and(mload(parenTrackerPointer), not(0xFFFF)), inputsBytePointer))\\n            }\\n\\n            // We write sources RTL so they can run LTR.\\n            activeSource =\\n            // increment offset. We have 16 bits allocated to the offset and stop\\n            // processing at 0x100 so this never overflows into the actual source\\n            // data.\\n            activeSource + 0x20\\n            // include the operand. The operand is assumed to be 16 bits, so we shift\\n            // it into the correct position.\\n            | Operand.unwrap(operand) << offset\\n            // include new op. The opcode is assumed to be 8 bits, so we shift it\\n            // into the correct position, beyond the operand.\\n            | opcode << (offset + 0x18);\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(mload(state), activeSource)\\n            }\\n\\n            // We have filled the current source slot. Need to create a new active\\n            // source and fulfill the doubly linked list.\\n            if (offset == 0xe0) {\\n                // Pointer to a newly allocated active source.\\n                uint256 newTailPtr;\\n                // Pointer to the old head of the LL tail.\\n                uint256 oldTailPtr;\\n                uint256 emptyActiveSource = EMPTY_ACTIVE_SOURCE;\\n                assembly (\\\"memory-safe\\\") {\\n                    oldTailPtr := mload(state)\\n\\n                    // Build the new tail head.\\n                    newTailPtr := mload(0x40)\\n                    mstore(state, newTailPtr)\\n                    mstore(newTailPtr, or(emptyActiveSource, shl(0x10, oldTailPtr)))\\n                    mstore(0x40, add(newTailPtr, 0x20))\\n\\n                    // The old tail head must now point back to the new tail head.\\n                    mstore(oldTailPtr, or(and(mload(oldTailPtr), not(0xFFFF)), newTailPtr))\\n                }\\n            }\\n        }\\n    }\\n\\n    function endSource(ParseState memory state) internal pure {\\n        uint256 sourcesBuilder = state.sourcesBuilder;\\n        uint256 offset = sourcesBuilder >> 0xf0;\\n\\n        // End is the number of top level words in the source, which is the\\n        // byte offset index + 1.\\n        uint256 end;\\n        assembly (\\\"memory-safe\\\") {\\n            end := add(byte(0, mload(add(state, 0x20))), 1)\\n        }\\n\\n        if (offset == 0xf0) {\\n            revert MaxSources();\\n        }\\n        // Follow the word counters to build the source with the correct\\n        // combination of LTR and RTL words. The stack needs to be built\\n        // LTR at the top level, so that as the evaluation proceeds LTR it\\n        // can reference previous items in subsequent items. However, the\\n        // stack is built RTL within each item, so that nested parens are\\n        // evaluated correctly similar to reverse polish notation.\\n        else {\\n            uint256 source;\\n            StackTracker stackTracker = state.stackTracker;\\n            assembly (\\\"memory-safe\\\") {\\n                // find the end of the LL tail.\\n                let cursor := mload(state)\\n\\n                let tailPointer := and(shr(0x10, mload(cursor)), 0xFFFF)\\n                for {} iszero(iszero(tailPointer)) {} {\\n                    cursor := tailPointer\\n                    tailPointer := and(shr(0x10, mload(cursor)), 0xFFFF)\\n                }\\n\\n                // Move cursor to the end of the end of the LL tail item.\\n                // This is 4 bytes from the end of the EVM word, to compensate\\n                // for the offset and pointer positions.\\n                tailPointer := cursor\\n                cursor := add(cursor, 0x1C)\\n                // leave space for the source prefix in the bytecode output.\\n                let length := 4\\n                source := mload(0x40)\\n                // Move over the source 32 byte length and the 4 byte prefix.\\n                let writeCursor := add(source, 0x20)\\n                writeCursor := add(writeCursor, 4)\\n\\n                let counterCursor := add(state, 0x21)\\n                for {\\n                    let i := 0\\n                    let wordsTotal := byte(0, mload(counterCursor))\\n                    let wordsRemaining := wordsTotal\\n                } lt(i, end) {\\n                    i := add(i, 1)\\n                    counterCursor := add(counterCursor, 1)\\n                    wordsTotal := byte(0, mload(counterCursor))\\n                    wordsRemaining := wordsTotal\\n                } {\\n                    length := add(length, mul(wordsTotal, 4))\\n                    {\\n                        // 4 bytes per source word.\\n                        let tailItemWordsRemaining := div(sub(cursor, tailPointer), 4)\\n                        // loop to the tail item that contains the start of the words\\n                        // that we need to copy.\\n                        for {} gt(wordsRemaining, tailItemWordsRemaining) {} {\\n                            wordsRemaining := sub(wordsRemaining, tailItemWordsRemaining)\\n                            tailPointer := and(mload(tailPointer), 0xFFFF)\\n                            tailItemWordsRemaining := 7\\n                            cursor := add(tailPointer, 0x1C)\\n                        }\\n                    }\\n\\n                    // Now the words remaining is lte the words remaining in the\\n                    // tail item. Move the cursor back to the start of the words\\n                    // and copy the passed over bytes to the write cursor.\\n                    {\\n                        let forwardTailPointer := tailPointer\\n                        let size := mul(wordsRemaining, 4)\\n                        cursor := sub(cursor, size)\\n                        mstore(writeCursor, mload(cursor))\\n                        writeCursor := add(writeCursor, size)\\n\\n                        // Redefine wordsRemaining to be the number of words\\n                        // left to copy.\\n                        wordsRemaining := sub(wordsTotal, wordsRemaining)\\n                        // Move over whole tail items.\\n                        for {} gt(wordsRemaining, 7) {} {\\n                            wordsRemaining := sub(wordsRemaining, 7)\\n                            // Follow the forward tail pointer.\\n                            forwardTailPointer := and(shr(0x10, mload(forwardTailPointer)), 0xFFFF)\\n                            mstore(writeCursor, mload(forwardTailPointer))\\n                            writeCursor := add(writeCursor, 0x1c)\\n                        }\\n                        // Move over the remaining words in the tail item.\\n                        if gt(wordsRemaining, 0) {\\n                            forwardTailPointer := and(shr(0x10, mload(forwardTailPointer)), 0xFFFF)\\n                            mstore(writeCursor, mload(forwardTailPointer))\\n                            writeCursor := add(writeCursor, mul(wordsRemaining, 4))\\n                        }\\n                    }\\n                }\\n                // Store the bytes length in the source.\\n                mstore(source, length)\\n                // Store the opcodes length and stack tracker in the source\\n                // prefix.\\n                let prefixWritePointer := add(source, 4)\\n                mstore(\\n                    prefixWritePointer,\\n                    or(\\n                        and(mload(prefixWritePointer), not(0xFFFFFFFF)),\\n                        or(shl(0x18, sub(div(length, 4), 1)), stackTracker)\\n                    )\\n                )\\n\\n                // Round up to the nearest 32 bytes to realign memory.\\n                mstore(0x40, and(add(writeCursor, 0x1f), not(0x1f)))\\n            }\\n\\n            //slither-disable-next-line incorrect-shift\\n            state.sourcesBuilder =\\n                ((offset + 0x10) << 0xf0) | (source << offset) | (sourcesBuilder & ((1 << offset) - 1));\\n\\n            // Reset source as we're done with this one.\\n            state.fsm &= ~FSM_ACTIVE_SOURCE_MASK;\\n            state.resetSource();\\n        }\\n    }\\n\\n    function buildBytecode(ParseState memory state) internal pure returns (bytes memory bytecode) {\\n        unchecked {\\n            uint256 sourcesBuilder = state.sourcesBuilder;\\n            uint256 offsetEnd = (sourcesBuilder >> 0xf0);\\n\\n            // Somehow the parser state for the active source was not reset\\n            // correctly, or the finalised offset is dangling. This implies that\\n            // we are building the overall sources array while still trying to\\n            // build one of the individual sources. This is a bug in the parser.\\n            uint256 activeSource;\\n            assembly (\\\"memory-safe\\\") {\\n                activeSource := mload(mload(state))\\n            }\\n            if (activeSource != EMPTY_ACTIVE_SOURCE) {\\n                revert DanglingSource();\\n            }\\n\\n            uint256 cursor;\\n            uint256 sourcesCount;\\n            uint256 sourcesStart;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor := mload(0x40)\\n                bytecode := cursor\\n                // Move past the bytecode length, we will write this at the end.\\n                cursor := add(cursor, 0x20)\\n\\n                // First byte is the number of sources.\\n                sourcesCount := div(offsetEnd, 0x10)\\n                mstore8(cursor, sourcesCount)\\n                cursor := add(cursor, 1)\\n\\n                let pointersCursor := cursor\\n\\n                // Skip past the pointer space. We'll back fill it.\\n                // Divide offsetEnd to convert from a bit to a byte shift.\\n                cursor := add(cursor, div(offsetEnd, 8))\\n                sourcesStart := cursor\\n\\n                // Write total bytes length into bytecode. We do ths and handle\\n                // the allocation in this same assembly block for memory safety\\n                // for the compiler optimiser.\\n                let sourcesLength := 0\\n                let sourcePointers := 0\\n                for { let offset := 0 } lt(offset, offsetEnd) { offset := add(offset, 0x10) } {\\n                    let currentSourcePointer := and(shr(offset, sourcesBuilder), 0xFFFF)\\n                    // add 4 byte prefix to the length of the sources, all as\\n                    // bytes.\\n                    sourcePointers := or(sourcePointers, shl(sub(0xf0, offset), sourcesLength))\\n                    let currentSourceLength := mload(currentSourcePointer)\\n\\n                    // Put the reference source pointer and length into the\\n                    // prefix so that we can use them to copy the actual data\\n                    // into the bytecode.\\n                    let tmpPrefix := shl(0xe0, or(shl(0x10, currentSourcePointer), currentSourceLength))\\n                    mstore(add(sourcesStart, sourcesLength), tmpPrefix)\\n                    sourcesLength := add(sourcesLength, currentSourceLength)\\n                }\\n                mstore(pointersCursor, or(mload(pointersCursor), sourcePointers))\\n                mstore(bytecode, add(sourcesLength, sub(sub(sourcesStart, 0x20), bytecode)))\\n\\n                // Round up to the nearest 32 bytes past cursor to realign and\\n                // allocate memory.\\n                mstore(0x40, and(add(add(add(0x20, mload(bytecode)), bytecode), 0x1f), not(0x1f)))\\n            }\\n\\n            // Loop over the sources and write them into the bytecode. Perhaps\\n            // there is a more efficient way to do this in the future that won't\\n            // cause each source to be written twice in memory.\\n            for (uint256 i = 0; i < sourcesCount; i++) {\\n                Pointer sourcePointer;\\n                uint256 length;\\n                Pointer targetPointer;\\n                assembly (\\\"memory-safe\\\") {\\n                    let relativePointer := and(mload(add(bytecode, add(3, mul(i, 2)))), 0xFFFF)\\n                    targetPointer := add(sourcesStart, relativePointer)\\n                    let tmpPrefix := mload(targetPointer)\\n                    sourcePointer := add(0x20, shr(0xf0, tmpPrefix))\\n                    length := and(shr(0xe0, tmpPrefix), 0xFFFF)\\n                }\\n                LibMemCpy.unsafeCopyBytesTo(sourcePointer, targetPointer, length);\\n            }\\n        }\\n    }\\n\\n    function buildConstants(ParseState memory state) internal pure returns (uint256[] memory constants) {\\n        uint256 constantsHeight = state.constantsBuilder & 0xFFFF;\\n        uint256 tailPtr = state.constantsBuilder >> 0x10;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let cursor := mload(0x40)\\n            constants := cursor\\n            mstore(cursor, constantsHeight)\\n            let end := cursor\\n            // Move the cursor to the end of the array. Write in reverse order\\n            // of the linked list traversal so that the constants are built\\n            // according to the stable indexes in the source from the linked\\n            // list base.\\n            cursor := add(cursor, mul(constantsHeight, 0x20))\\n            // Allocate one word past the cursor. This will be just after the\\n            // length if the constants array is empty. Otherwise it will be\\n            // just after the last constant.\\n            mstore(0x40, add(cursor, 0x20))\\n            // It MUST be equivalent to say that the cursor is above the end,\\n            // and that we are following tail pointers until they point to 0,\\n            // and that the cursor is moving as far as the constants height.\\n            // This is ensured by the fact that the constants height is only\\n            // incremented when a new constant is added to the linked list.\\n            for {} gt(cursor, end) {\\n                // Next item in the linked list.\\n                cursor := sub(cursor, 0x20)\\n                // tail pointer in tail keys is the low 16 bits under the\\n                // fingerprint, which is different from the tail pointer in\\n                // the constants builder, where it sits above the constants\\n                // height.\\n                tailPtr := and(mload(tailPtr), 0xFFFF)\\n            } {\\n                // Store the values not the keys.\\n                mstore(cursor, mload(add(tailPtr, 0x20)))\\n            }\\n        }\\n    }\\n}\\n\\nlibrary LibParse {\\n    using LibPointer for Pointer;\\n    using LibParseState for ParseState;\\n    using LibParseStackName for ParseState;\\n\\n    function parseErrorOffset(bytes memory data, uint256 cursor) internal pure returns (uint256 offset) {\\n        assembly (\\\"memory-safe\\\") {\\n            offset := sub(cursor, add(data, 0x20))\\n        }\\n    }\\n\\n    function parseWord(uint256 cursor, uint256 mask) internal pure returns (uint256, bytes32) {\\n        bytes32 word;\\n        uint256 i = 1;\\n        assembly (\\\"memory-safe\\\") {\\n            // word is head + tail\\n            word := mload(cursor)\\n            // loop over the tail\\n            //slither-disable-next-line incorrect-shift\\n            for {} and(lt(i, 0x20), iszero(and(shl(byte(i, word), 1), not(mask)))) { i := add(i, 1) } {}\\n            let scrub := mul(sub(0x20, i), 8)\\n            word := shl(scrub, shr(scrub, word))\\n            cursor := add(cursor, i)\\n        }\\n        if (i == 0x20) {\\n            revert WordSize(string(abi.encodePacked(word)));\\n        }\\n        return (cursor, word);\\n    }\\n\\n    /// Skip an unlimited number of chars until we find one that is not in the\\n    /// mask.\\n    function skipMask(uint256 cursor, uint256 end, uint256 mask) internal pure returns (uint256) {\\n        assembly (\\\"memory-safe\\\") {\\n            //slither-disable-next-line incorrect-shift\\n            for {} and(lt(cursor, end), gt(and(shl(byte(0, mload(cursor)), 1), mask), 0)) { cursor := add(cursor, 1) } {}\\n        }\\n        return cursor;\\n    }\\n\\n    /// The cursor currently points at the head of a comment. We need to skip\\n    /// over all data until we find the end of the comment. This MAY REVERT if\\n    /// the comment is malformed, e.g. if the comment doesn't start with `/*`.\\n    /// @param data The source data.\\n    /// @param cursor The current cursor position.\\n    /// @return The new cursor position.\\n    function skipComment(bytes memory data, uint256 cursor) internal pure returns (uint256) {\\n        // First check the comment opening sequence is not malformed.\\n        uint256 startSequence;\\n        assembly (\\\"memory-safe\\\") {\\n            startSequence := shr(0xf0, mload(cursor))\\n        }\\n        if (startSequence != COMMENT_START_SEQUENCE) {\\n            revert MalformedCommentStart(parseErrorOffset(data, cursor));\\n        }\\n        uint256 commentEndSequenceStart = COMMENT_END_SEQUENCE >> 8;\\n        uint256 commentEndSequenceEnd = COMMENT_END_SEQUENCE & 0xFF;\\n        uint256 max;\\n        assembly (\\\"memory-safe\\\") {\\n            // Move past the start sequence.\\n            cursor := add(cursor, 2)\\n            max := add(data, add(mload(data), 0x20))\\n\\n            // Loop until we find the end sequence.\\n            let done := 0\\n            for {} iszero(done) {} {\\n                for {} and(iszero(eq(byte(0, mload(cursor)), commentEndSequenceStart)), lt(cursor, max)) {} {\\n                    cursor := add(cursor, 1)\\n                }\\n                // We have found the start of the end sequence. Now check the\\n                // end sequence is correct.\\n                cursor := add(cursor, 1)\\n                // Only exit the loop if the end sequence is correct. We don't\\n                // move the cursor forward unless we haven exact match on the\\n                // end byte. E.g. consider the sequence `/** comment **/`.\\n                if or(eq(byte(0, mload(cursor)), commentEndSequenceEnd), iszero(lt(cursor, max))) {\\n                    done := 1\\n                    cursor := add(cursor, 1)\\n                }\\n            }\\n        }\\n        // If the cursor is past the max we either never even started an end\\n        // sequence, or we started parsing an end sequence but couldn't complete\\n        // it. Either way, the comment is malformed, and the parser is OOB.\\n        if (cursor > max) {\\n            revert ParserOutOfBounds();\\n        }\\n        return cursor;\\n    }\\n\\n    //slither-disable-next-line cyclomatic-complexity\\n    function parse(bytes memory data, bytes memory meta)\\n        internal\\n        pure\\n        returns (bytes memory bytecode, uint256[] memory)\\n    {\\n        unchecked {\\n            ParseState memory state = LibParseState.newState();\\n            if (data.length > 0) {\\n                bytes32 word;\\n                uint256 cursor;\\n                uint256 end;\\n                uint256 char;\\n                assembly (\\\"memory-safe\\\") {\\n                    cursor := add(data, 0x20)\\n                    end := add(cursor, mload(data))\\n                }\\n                while (cursor < end) {\\n                    assembly (\\\"memory-safe\\\") {\\n                        //slither-disable-next-line incorrect-shift\\n                        char := shl(byte(0, mload(cursor)), 1)\\n                    }\\n\\n                    // LHS\\n                    if (state.fsm & FSM_RHS_MASK == 0) {\\n                        if (char & CMASK_LHS_STACK_HEAD > 0) {\\n                            // if yang we can't start new stack item\\n                            if (state.fsm & FSM_YANG_MASK > 0) {\\n                                revert UnexpectedLHSChar(parseErrorOffset(data, cursor));\\n                            }\\n\\n                            // Named stack item.\\n                            if (char & CMASK_IDENTIFIER_HEAD > 0) {\\n                                (cursor, word) = parseWord(cursor, CMASK_LHS_STACK_TAIL);\\n                                (bool exists, uint256 index) = state.pushStackName(word);\\n                                (index);\\n                                // If the stack name already exists, then we\\n                                // revert as shadowing is not allowed.\\n                                if (exists) {\\n                                    revert DuplicateLHSItem(parseErrorOffset(data, cursor));\\n                                }\\n                            }\\n                            // Anon stack item.\\n                            else {\\n                                cursor = skipMask(cursor + 1, end, CMASK_LHS_STACK_TAIL);\\n                            }\\n                            // Bump the index regardless of whether the stack\\n                            // item is named or not.\\n                            state.topLevel1++;\\n                            state.lineTracker++;\\n\\n                            // Set yang as we are now building a stack item.\\n                            // We are also no longer interstitial\\n                            state.fsm = (state.fsm | FSM_YANG_MASK | FSM_ACTIVE_SOURCE_MASK) & ~FSM_INTERSTITIAL_MASK;\\n                        } else if (char & CMASK_WHITESPACE != 0) {\\n                            cursor = skipMask(cursor + 1, end, CMASK_WHITESPACE);\\n                            // Set ying as we now open to possibilities.\\n                            state.fsm &= ~FSM_YANG_MASK;\\n                        } else if (char & CMASK_LHS_RHS_DELIMITER != 0) {\\n                            // Set RHS and yin. Move out of the interstitial if\\n                            // we haven't already.\\n                            state.fsm = (state.fsm | FSM_RHS_MASK | FSM_ACTIVE_SOURCE_MASK)\\n                                & ~(FSM_YANG_MASK | FSM_INTERSTITIAL_MASK);\\n                            cursor++;\\n                        } else if (char & CMASK_COMMENT_HEAD != 0) {\\n                            if (state.fsm & FSM_INTERSTITIAL_MASK == 0) {\\n                                revert UnexpectedComment(parseErrorOffset(data, cursor));\\n                            }\\n                            cursor = skipComment(data, cursor);\\n                            // Set yang for comments to force a little breathing\\n                            // room between comments and the next item.\\n                            state.fsm |= FSM_YANG_MASK;\\n                        } else {\\n                            revert UnexpectedLHSChar(parseErrorOffset(data, cursor));\\n                        }\\n                    }\\n                    // RHS\\n                    else {\\n                        if (char & CMASK_RHS_WORD_HEAD > 0) {\\n                            // If yang we can't start a new word.\\n                            if (state.fsm & FSM_YANG_MASK > 0) {\\n                                revert UnexpectedRHSChar(parseErrorOffset(data, cursor));\\n                            }\\n\\n                            (cursor, word) = parseWord(cursor, CMASK_RHS_WORD_TAIL);\\n\\n                            // First check if this word is in meta.\\n                            (\\n                                bool exists,\\n                                uint256 opcodeIndex,\\n                                function(uint256, bytes memory, uint256) pure returns (uint256, Operand) operandParser\\n                            ) = LibParseMeta.lookupWord(meta, state.operandParsers, word);\\n                            if (exists) {\\n                                Operand operand;\\n                                (cursor, operand) = operandParser(state.literalParsers, data, cursor);\\n                                state.pushOpToSource(opcodeIndex, operand);\\n                                // This is a real word so we expect to see parens\\n                                // after it.\\n                                state.fsm |= FSM_WORD_END_MASK;\\n                            }\\n                            // Fallback to LHS items.\\n                            else {\\n                                (exists, opcodeIndex) = LibParseStackName.stackNameIndex(state, word);\\n                                if (exists) {\\n                                    state.pushOpToSource(OPCODE_STACK, Operand.wrap(opcodeIndex));\\n                                    // Need to process highwater here because we\\n                                    // don't have any parens to open or close.\\n                                    state.highwater();\\n                                } else {\\n                                    revert UnknownWord(parseErrorOffset(data, cursor));\\n                                }\\n                            }\\n\\n                            state.fsm |= FSM_YANG_MASK;\\n                        }\\n                        // If this is the end of a word we MUST start a paren.\\n                        else if (state.fsm & FSM_WORD_END_MASK > 0) {\\n                            if (char & CMASK_LEFT_PAREN == 0) {\\n                                revert ExpectedLeftParen(parseErrorOffset(data, cursor));\\n                            }\\n                            // Increase the paren depth by 1.\\n                            // i.e. move the byte offset by 3\\n                            // There MAY be garbage at this new offset due to\\n                            // a previous paren group being deallocated. The\\n                            // deallocation process writes the input counter\\n                            // to zero but leaves a garbage word in place, with\\n                            // the expectation that it will be overwritten by\\n                            // the next paren group.\\n                            uint256 newParenOffset;\\n                            assembly (\\\"memory-safe\\\") {\\n                                newParenOffset := add(byte(0, mload(add(state, 0x60))), 3)\\n                                mstore8(add(state, 0x60), newParenOffset)\\n                            }\\n                            // first 2 bytes are reserved, then remaining 62\\n                            // bytes are for paren groups, so the offset MUST NOT\\n                            // imply writing to the 63rd byte.\\n                            if (newParenOffset > 59) {\\n                                revert ParenOverflow();\\n                            }\\n                            cursor++;\\n\\n                            // We've moved past the paren, so we are no longer at\\n                            // the end of a word and are yin.\\n                            state.fsm &= ~(FSM_WORD_END_MASK | FSM_YANG_MASK);\\n                        } else if (char & CMASK_RIGHT_PAREN > 0) {\\n                            uint256 parenOffset;\\n                            assembly (\\\"memory-safe\\\") {\\n                                parenOffset := byte(0, mload(add(state, 0x60)))\\n                            }\\n                            if (parenOffset == 0) {\\n                                revert UnexpectedRightParen(parseErrorOffset(data, cursor));\\n                            }\\n                            // Decrease the paren depth by 1.\\n                            // i.e. move the byte offset by -3.\\n                            // This effectively deallocates the paren group, so\\n                            // write the input counter out to the operand pointed\\n                            // to by the pointer we deallocated.\\n                            assembly (\\\"memory-safe\\\") {\\n                                // State field offset.\\n                                let stateOffset := add(state, 0x60)\\n                                parenOffset := sub(parenOffset, 3)\\n                                mstore8(stateOffset, parenOffset)\\n                                mstore8(\\n                                    // Add 2 for the reserved bytes to the offset\\n                                    // then read top 16 bits from the pointer.\\n                                    // Add 1 to sandwitch the inputs byte between\\n                                    // the opcode index byte and the operand low\\n                                    // bytes.\\n                                    add(1, shr(0xf0, mload(add(add(stateOffset, 2), parenOffset)))),\\n                                    // Store the input counter, which is 2 bytes\\n                                    // after the operand write pointer.\\n                                    byte(0, mload(add(add(stateOffset, 4), parenOffset)))\\n                                )\\n                            }\\n                            state.highwater();\\n                            cursor++;\\n                        } else if (char & CMASK_WHITESPACE > 0) {\\n                            cursor = skipMask(cursor + 1, end, CMASK_WHITESPACE);\\n                            // Set yin as we now open to possibilities.\\n                            state.fsm &= ~FSM_YANG_MASK;\\n                        }\\n                        // Handle all literals.\\n                        else if (char & CMASK_LITERAL_HEAD > 0) {\\n                            cursor = state.pushLiteral(data, cursor);\\n                            state.highwater();\\n                            // We are yang now. Need the next char to release to\\n                            // yin.\\n                            state.fsm |= FSM_YANG_MASK;\\n                        } else if (char & CMASK_EOL > 0) {\\n                            state.endLine(data, cursor);\\n                            cursor++;\\n                        }\\n                        // End of source.\\n                        else if (char & CMASK_EOS > 0) {\\n                            state.endLine(data, cursor);\\n                            state.endSource();\\n                            cursor++;\\n\\n                            state.fsm = FSM_DEFAULT;\\n                        }\\n                        // Comments aren't allowed in the RHS but we can give a\\n                        // nicer error message than the default.\\n                        else if (char & CMASK_COMMENT_HEAD != 0) {\\n                            revert UnexpectedComment(parseErrorOffset(data, cursor));\\n                        } else {\\n                            revert UnexpectedRHSChar(parseErrorOffset(data, cursor));\\n                        }\\n                    }\\n                }\\n                if (cursor != end) {\\n                    revert ParserOutOfBounds();\\n                }\\n                if (state.fsm & FSM_ACTIVE_SOURCE_MASK != 0) {\\n                    revert MissingFinalSemi(parseErrorOffset(data, cursor));\\n                }\\n            }\\n            return (state.buildBytecode(), state.buildConstants());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/IParserV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\ninterface IParserV1 {\\n    /// Parses a Rainlang string into an evaluable expression. MUST be\\n    /// deterministic and MUST NOT have side effects. The only inputs are the\\n    /// Rainlang string and the parse meta. MAY revert if the Rainlang string\\n    /// is invalid. This function takes `bytes` instead of `string` to allow\\n    /// for definitions of \\\"string\\\" other than UTF-8.\\n    /// @param data The Rainlang bytes to parse.\\n    /// @return bytecode The expressions that can be evaluated.\\n    /// @return constants The constants that can be referenced by sources.\\n    function parse(bytes calldata data) external pure returns (bytes calldata bytecode, uint256[] calldata constants);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/rain.solmem/src/lib/LibPointer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// A pointer to a location in memory. This is a `uint256` to save gas on low\\n/// level operations on the evm stack. These same low level operations typically\\n/// WILL NOT check for overflow or underflow, so all pointer logic MUST ensure\\n/// that reads, writes and movements are not out of bounds.\\ntype Pointer is uint256;\\n\\n/// @title LibPointer\\n/// Ergonomic wrappers around common pointer movements, reading and writing. As\\n/// wrappers on such low level operations often introduce too much jump gas\\n/// overhead, these functions MAY find themselves used in reference\\n/// implementations that more optimised code can be fuzzed against. MAY also be\\n/// situationally useful on cooler performance paths.\\nlibrary LibPointer {\\n    /// Cast a `Pointer` to `bytes` without modification or any safety checks.\\n    /// The caller MUST ensure the pointer is to a valid region of memory for\\n    /// some `bytes`.\\n    /// @param pointer The pointer to cast to `bytes`.\\n    /// @return data The cast `bytes`.\\n    function unsafeAsBytes(Pointer pointer) internal pure returns (bytes memory data) {\\n        assembly (\\\"memory-safe\\\") {\\n            data := pointer\\n        }\\n    }\\n\\n    /// Increase some pointer by a number of bytes.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// Note that moving a pointer by some bytes offset is likely to unalign it\\n    /// with the 32 byte increments of the Solidity allocator.\\n    ///\\n    /// @param pointer The pointer to increase by `length`.\\n    /// @param length The number of bytes to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddBytes(Pointer pointer, uint256 length) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, length)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase by a single word.\\n    /// @return The increased pointer.\\n    function unsafeAddWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase.\\n    /// @param words The number of words to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease by a single word.\\n    /// @return The decreased pointer.\\n    function unsafeSubWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease.\\n    /// @param words The number of words to decrease the pointer by.\\n    /// @return The decreased pointer.\\n    function unsafeSubWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Read the word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can read outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to read the word at.\\n    /// @return word The word read from the pointer.\\n    function unsafeReadWord(Pointer pointer) internal pure returns (uint256 word) {\\n        assembly (\\\"memory-safe\\\") {\\n            word := mload(pointer)\\n        }\\n    }\\n\\n    /// Write a word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can write outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to write the word at.\\n    /// @param word The word to write.\\n    function unsafeWriteWord(Pointer pointer, uint256 word) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(pointer, word)\\n        }\\n    }\\n\\n    /// Get the pointer to the end of all allocated memory.\\n    /// As per Solidity docs, there is no guarantee that the region of memory\\n    /// beyond this pointer is zeroed out, as assembly MAY write beyond allocated\\n    /// memory for temporary use if the scratch space is insufficient.\\n    /// @return pointer The pointer to the end of all allocated memory.\\n    function allocatedMemoryPointer() internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := mload(0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.solmem/src/lib/LibMemCpy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibPointer.sol\\\";\\n\\nlibrary LibMemCpy {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param sourceCursor The starting pointer to read from.\\n    /// @param targetCursor The starting pointer to write to.\\n    /// @param length The number of bytes to read/write.\\n    function unsafeCopyBytesTo(Pointer sourceCursor, Pointer targetCursor, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            // Precalculating the end here, rather than tracking the remaining\\n            // length each iteration uses relatively more gas for less data, but\\n            // scales better for more data. Copying 1-2 words is ~30 gas more\\n            // expensive but copying 3+ words favours a precalculated end point\\n            // increasingly for more data.\\n            let m := mod(length, 0x20)\\n            let end := add(sourceCursor, sub(length, m))\\n            for {} lt(sourceCursor, end) {\\n                sourceCursor := add(sourceCursor, 0x20)\\n                targetCursor := add(targetCursor, 0x20)\\n            } { mstore(targetCursor, mload(sourceCursor)) }\\n\\n            if iszero(iszero(m)) {\\n                //slither-disable-next-line incorrect-shift\\n                let mask_ := shr(mul(m, 8), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                // preserve existing bytes\\n                mstore(\\n                    targetCursor,\\n                    or(\\n                        // input\\n                        and(mload(sourceCursor), not(mask_)),\\n                        and(mload(targetCursor), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    /// Copies `length` `uint256` values starting from `source` to `target`\\n    /// with NO attempt to check that this is safe to do so. The caller MUST\\n    /// ensure that there exists allocated memory at `target` in which it is\\n    /// safe and appropriate to copy `length * 32` bytes to. Anything that was\\n    /// already written to memory at `[target:target+(length * 32 bytes)]`\\n    /// will be overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param source The starting position in memory that data will be copied\\n    /// from.\\n    /// @param target The starting position in memory that data will be copied\\n    /// to.\\n    /// @param length The number of 32 byte (i.e. `uint256`) words that will\\n    /// be copied.\\n    function unsafeCopyWordsTo(Pointer source, Pointer target, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for { let end_ := add(source, mul(0x20, length)) } lt(source, end_) {\\n                source := add(source, 0x20)\\n                target := add(target, 0x20)\\n            } { mstore(target, mload(source)) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/parse/LibParseCMask.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @dev ASCII null\\nuint128 constant CMASK_NULL = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x00\\\")));\\n\\n/// @dev ASCII start of heading\\nuint128 constant CMASK_START_OF_HEADING = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x01\\\")));\\n\\n/// @dev ASCII start of text\\nuint128 constant CMASK_START_OF_TEXT = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x02\\\")));\\n\\n/// @dev ASCII end of text\\nuint128 constant CMASK_END_OF_TEXT = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x03\\\")));\\n\\n/// @dev ASCII end of transmission\\nuint128 constant CMASK_END_OF_TRANSMISSION = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x04\\\")));\\n\\n/// @dev ASCII enquiry\\nuint128 constant CMASK_ENQUIRY = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x05\\\")));\\n\\n/// @dev ASCII acknowledge\\nuint128 constant CMASK_ACKNOWLEDGE = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x06\\\")));\\n\\n/// @dev ASCII bell\\nuint128 constant CMASK_BELL = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x07\\\")));\\n\\n/// @dev ASCII backspace\\nuint128 constant CMASK_BACKSPACE = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x08\\\")));\\n\\n/// @dev ASCII horizontal tab\\nuint128 constant CMASK_HORIZONTAL_TAB = uint128(1) << uint128(uint8(bytes1(\\\"\\\\t\\\")));\\n\\n/// @dev ASCII line feed\\nuint128 constant CMASK_LINE_FEED = uint128(1) << uint128(uint8(bytes1(\\\"\\\\n\\\")));\\n\\n/// @dev ASCII vertical tab\\nuint128 constant CMASK_VERTICAL_TAB = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x0B\\\")));\\n\\n/// @dev ASCII form feed\\nuint128 constant CMASK_FORM_FEED = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x0C\\\")));\\n\\n/// @dev ASCII carriage return\\nuint128 constant CMASK_CARRIAGE_RETURN = uint128(1) << uint128(uint8(bytes1(\\\"\\\\r\\\")));\\n\\n/// @dev ASCII shift out\\nuint128 constant CMASK_SHIFT_OUT = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x0E\\\")));\\n\\n/// @dev ASCII shift in\\nuint128 constant CMASK_SHIFT_IN = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x0F\\\")));\\n\\n/// @dev ASCII data link escape\\nuint128 constant CMASK_DATA_LINK_ESCAPE = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x10\\\")));\\n\\n/// @dev ASCII device control 1\\nuint128 constant CMASK_DEVICE_CONTROL_1 = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x11\\\")));\\n\\n/// @dev ASCII device control 2\\nuint128 constant CMASK_DEVICE_CONTROL_2 = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x12\\\")));\\n\\n/// @dev ASCII device control 3\\nuint128 constant CMASK_DEVICE_CONTROL_3 = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x13\\\")));\\n\\n/// @dev ASCII device control 4\\nuint128 constant CMASK_DEVICE_CONTROL_4 = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x14\\\")));\\n\\n/// @dev ASCII negative acknowledge\\nuint128 constant CMASK_NEGATIVE_ACKNOWLEDGE = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x15\\\")));\\n\\n/// @dev ASCII synchronous idle\\nuint128 constant CMASK_SYNCHRONOUS_IDLE = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x16\\\")));\\n\\n/// @dev ASCII end of transmission block\\nuint128 constant CMASK_END_OF_TRANSMISSION_BLOCK = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x17\\\")));\\n\\n/// @dev ASCII cancel\\nuint128 constant CMASK_CANCEL = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x18\\\")));\\n\\n/// @dev ASCII end of medium\\nuint128 constant CMASK_END_OF_MEDIUM = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x19\\\")));\\n\\n/// @dev ASCII substitute\\nuint128 constant CMASK_SUBSTITUTE = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x1A\\\")));\\n\\n/// @dev ASCII escape\\nuint128 constant CMASK_ESCAPE = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x1B\\\")));\\n\\n/// @dev ASCII file separator\\nuint128 constant CMASK_FILE_SEPARATOR = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x1C\\\")));\\n\\n/// @dev ASCII group separator\\nuint128 constant CMASK_GROUP_SEPARATOR = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x1D\\\")));\\n\\n/// @dev ASCII record separator\\nuint128 constant CMASK_RECORD_SEPARATOR = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x1E\\\")));\\n\\n/// @dev ASCII unit separator\\nuint128 constant CMASK_UNIT_SEPARATOR = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x1F\\\")));\\n\\n/// @dev ASCII space\\nuint128 constant CMASK_SPACE = uint128(1) << uint128(uint8(bytes1(\\\" \\\")));\\n\\n/// @dev ASCII !\\nuint128 constant CMASK_EXCLAMATION_MARK = uint128(1) << uint128(uint8(bytes1(\\\"!\\\")));\\n\\n/// @dev ASCII \\\"\\nuint128 constant CMASK_QUOTATION_MARK = uint128(1) << uint128(uint8(bytes1(\\\"\\\\\\\"\\\")));\\n\\n/// @dev ASCII #\\nuint128 constant CMASK_NUMBER_SIGN = uint128(1) << uint128(uint8(bytes1(\\\"#\\\")));\\n\\n/// @dev ASCII $\\nuint128 constant CMASK_DOLLAR_SIGN = uint128(1) << uint128(uint8(bytes1(\\\"$\\\")));\\n\\n/// @dev ASCII %\\nuint128 constant CMASK_PERCENT_SIGN = uint128(1) << uint128(uint8(bytes1(\\\"%\\\")));\\n\\n/// @dev ASCII &\\nuint128 constant CMASK_AMPERSAND = uint128(1) << uint128(uint8(bytes1(\\\"&\\\")));\\n\\n/// @dev ASCII '\\nuint128 constant CMASK_APOSTROPHE = uint128(1) << uint128(uint8(bytes1(\\\"'\\\")));\\n\\n/// @dev ASCII (\\nuint128 constant CMASK_LEFT_PAREN = uint128(1) << uint128(uint8(bytes1(\\\"(\\\")));\\n\\n/// @dev ASCII )\\nuint128 constant CMASK_RIGHT_PAREN = uint128(1) << uint128(uint8(bytes1(\\\")\\\")));\\n\\n/// @dev ASCII *\\nuint128 constant CMASK_ASTERISK = uint128(1) << uint128(uint8(bytes1(\\\"*\\\")));\\n\\n/// @dev ASCII +\\nuint128 constant CMASK_PLUS_SIGN = uint128(1) << uint128(uint8(bytes1(\\\"+\\\")));\\n\\n/// @dev ASCII ,\\nuint128 constant CMASK_COMMA = uint128(1) << uint128(uint8(bytes1(\\\",\\\")));\\n\\n/// @dev ASCII -\\nuint128 constant CMASK_DASH = uint128(1) << uint128(uint8(bytes1(\\\"-\\\")));\\n\\n/// @dev ASCII .\\nuint128 constant CMASK_FULL_STOP = uint128(1) << uint128(uint8(bytes1(\\\".\\\")));\\n\\n/// @dev ASCII /\\nuint128 constant CMASK_SLASH = uint128(1) << uint128(uint8(bytes1(\\\"/\\\")));\\n\\n/// @dev ASCII 0\\nuint128 constant CMASK_ZERO = uint128(1) << uint128(uint8(bytes1(\\\"0\\\")));\\n\\n/// @dev ASCII 1\\nuint128 constant CMASK_ONE = uint128(1) << uint128(uint8(bytes1(\\\"1\\\")));\\n\\n/// @dev ASCII 2\\nuint128 constant CMASK_TWO = uint128(1) << uint128(uint8(bytes1(\\\"2\\\")));\\n\\n/// @dev ASCII 3\\nuint128 constant CMASK_THREE = uint128(1) << uint128(uint8(bytes1(\\\"3\\\")));\\n\\n/// @dev ASCII 4\\nuint128 constant CMASK_FOUR = uint128(1) << uint128(uint8(bytes1(\\\"4\\\")));\\n\\n/// @dev ASCII 5\\nuint128 constant CMASK_FIVE = uint128(1) << uint128(uint8(bytes1(\\\"5\\\")));\\n\\n/// @dev ASCII 6\\nuint128 constant CMASK_SIX = uint128(1) << uint128(uint8(bytes1(\\\"6\\\")));\\n\\n/// @dev ASCII 7\\nuint128 constant CMASK_SEVEN = uint128(1) << uint128(uint8(bytes1(\\\"7\\\")));\\n\\n/// @dev ASCII 8\\nuint128 constant CMASK_EIGHT = uint128(1) << uint128(uint8(bytes1(\\\"8\\\")));\\n\\n/// @dev ASCII 9\\nuint128 constant CMASK_NINE = uint128(1) << uint128(uint8(bytes1(\\\"9\\\")));\\n\\n/// @dev ASCII :\\nuint128 constant CMASK_COLON = uint128(1) << uint128(uint8(bytes1(\\\":\\\")));\\n\\n/// @dev ASCII ;\\nuint128 constant CMASK_SEMICOLON = uint128(1) << uint128(uint8(bytes1(\\\";\\\")));\\n\\n/// @dev ASCII <\\nuint128 constant CMASK_LESS_THAN_SIGN = uint128(1) << uint128(uint8(bytes1(\\\"<\\\")));\\n\\n/// @dev ASCII =\\nuint128 constant CMASK_EQUALS_SIGN = uint128(1) << uint128(uint8(bytes1(\\\"=\\\")));\\n\\n/// @dev ASCII >\\nuint128 constant CMASK_GREATER_THAN_SIGN = uint128(1) << uint128(uint8(bytes1(\\\">\\\")));\\n\\n/// @dev ASCII ?\\nuint128 constant CMASK_QUESTION_MARK = uint128(1) << uint128(uint8(bytes1(\\\"?\\\")));\\n\\n/// @dev ASCII @\\nuint128 constant CMASK_AT_SIGN = uint128(1) << uint128(uint8(bytes1(\\\"@\\\")));\\n\\n/// @dev ASCII A\\nuint128 constant CMASK_UPPER_A = uint128(1) << uint128(uint8(bytes1(\\\"A\\\")));\\n\\n/// @dev ASCII B\\nuint128 constant CMASK_UPPER_B = uint128(1) << uint128(uint8(bytes1(\\\"B\\\")));\\n\\n/// @dev ASCII C\\nuint128 constant CMASK_UPPER_C = uint128(1) << uint128(uint8(bytes1(\\\"C\\\")));\\n\\n/// @dev ASCII D\\nuint128 constant CMASK_UPPER_D = uint128(1) << uint128(uint8(bytes1(\\\"D\\\")));\\n\\n/// @dev ASCII E\\nuint128 constant CMASK_UPPER_E = uint128(1) << uint128(uint8(bytes1(\\\"E\\\")));\\n\\n/// @dev ASCII F\\nuint128 constant CMASK_UPPER_F = uint128(1) << uint128(uint8(bytes1(\\\"F\\\")));\\n\\n/// @dev ASCII G\\nuint128 constant CMASK_UPPER_G = uint128(1) << uint128(uint8(bytes1(\\\"G\\\")));\\n\\n/// @dev ASCII H\\nuint128 constant CMASK_UPPER_H = uint128(1) << uint128(uint8(bytes1(\\\"H\\\")));\\n\\n/// @dev ASCII I\\nuint128 constant CMASK_UPPER_I = uint128(1) << uint128(uint8(bytes1(\\\"I\\\")));\\n\\n/// @dev ASCII J\\nuint128 constant CMASK_UPPER_J = uint128(1) << uint128(uint8(bytes1(\\\"J\\\")));\\n\\n/// @dev ASCII K\\nuint128 constant CMASK_UPPER_K = uint128(1) << uint128(uint8(bytes1(\\\"K\\\")));\\n\\n/// @dev ASCII L\\nuint128 constant CMASK_UPPER_L = uint128(1) << uint128(uint8(bytes1(\\\"L\\\")));\\n\\n/// @dev ASCII M\\nuint128 constant CMASK_UPPER_M = uint128(1) << uint128(uint8(bytes1(\\\"M\\\")));\\n\\n/// @dev ASCII N\\nuint128 constant CMASK_UPPER_N = uint128(1) << uint128(uint8(bytes1(\\\"N\\\")));\\n\\n/// @dev ASCII O\\nuint128 constant CMASK_UPPER_O = uint128(1) << uint128(uint8(bytes1(\\\"O\\\")));\\n\\n/// @dev ASCII P\\nuint128 constant CMASK_UPPER_P = uint128(1) << uint128(uint8(bytes1(\\\"P\\\")));\\n\\n/// @dev ASCII Q\\nuint128 constant CMASK_UPPER_Q = uint128(1) << uint128(uint8(bytes1(\\\"Q\\\")));\\n\\n/// @dev ASCII R\\nuint128 constant CMASK_UPPER_R = uint128(1) << uint128(uint8(bytes1(\\\"R\\\")));\\n\\n/// @dev ASCII S\\nuint128 constant CMASK_UPPER_S = uint128(1) << uint128(uint8(bytes1(\\\"S\\\")));\\n\\n/// @dev ASCII T\\nuint128 constant CMASK_UPPER_T = uint128(1) << uint128(uint8(bytes1(\\\"T\\\")));\\n\\n/// @dev ASCII U\\nuint128 constant CMASK_UPPER_U = uint128(1) << uint128(uint8(bytes1(\\\"U\\\")));\\n\\n/// @dev ASCII V\\nuint128 constant CMASK_UPPER_V = uint128(1) << uint128(uint8(bytes1(\\\"V\\\")));\\n\\n/// @dev ASCII W\\nuint128 constant CMASK_UPPER_W = uint128(1) << uint128(uint8(bytes1(\\\"W\\\")));\\n\\n/// @dev ASCII X\\nuint128 constant CMASK_UPPER_X = uint128(1) << uint128(uint8(bytes1(\\\"X\\\")));\\n\\n/// @dev ASCII Y\\nuint128 constant CMASK_UPPER_Y = uint128(1) << uint128(uint8(bytes1(\\\"Y\\\")));\\n\\n/// @dev ASCII Z\\nuint128 constant CMASK_UPPER_Z = uint128(1) << uint128(uint8(bytes1(\\\"Z\\\")));\\n\\n/// @dev ASCII [\\nuint128 constant CMASK_LEFT_SQUARE_BRACKET = uint128(1) << uint128(uint8(bytes1(\\\"[\\\")));\\n\\n/// @dev ASCII \\\\\\nuint128 constant CMASK_BACKSLASH = uint128(1) << uint128(uint8(bytes1(\\\"\\\\\\\\\\\")));\\n\\n/// @dev ASCII ]\\nuint128 constant CMASK_RIGHT_SQUARE_BRACKET = uint128(1) << uint128(uint8(bytes1(\\\"]\\\")));\\n\\n/// @dev ASCII ^\\nuint128 constant CMASK_CIRCUMFLEX_ACCENT = uint128(1) << uint128(uint8(bytes1(\\\"^\\\")));\\n\\n/// @dev ASCII _\\nuint128 constant CMASK_UNDERSCORE = uint128(1) << uint128(uint8(bytes1(\\\"_\\\")));\\n\\n/// @dev ASCII `\\nuint128 constant CMASK_GRAVE_ACCENT = uint128(1) << uint128(uint8(bytes1(\\\"`\\\")));\\n\\n/// @dev ASCII a\\nuint128 constant CMASK_LOWER_A = uint128(1) << uint128(uint8(bytes1(\\\"a\\\")));\\n\\n/// @dev ASCII b\\nuint128 constant CMASK_LOWER_B = uint128(1) << uint128(uint8(bytes1(\\\"b\\\")));\\n\\n/// @dev ASCII c\\nuint128 constant CMASK_LOWER_C = uint128(1) << uint128(uint8(bytes1(\\\"c\\\")));\\n\\n/// @dev ASCII d\\nuint128 constant CMASK_LOWER_D = uint128(1) << uint128(uint8(bytes1(\\\"d\\\")));\\n\\n/// @dev ASCII e\\nuint128 constant CMASK_LOWER_E = uint128(1) << uint128(uint8(bytes1(\\\"e\\\")));\\n\\n/// @dev ASCII f\\nuint128 constant CMASK_LOWER_F = uint128(1) << uint128(uint8(bytes1(\\\"f\\\")));\\n\\n/// @dev ASCII g\\nuint128 constant CMASK_LOWER_G = uint128(1) << uint128(uint8(bytes1(\\\"g\\\")));\\n\\n/// @dev ASCII h\\nuint128 constant CMASK_LOWER_H = uint128(1) << uint128(uint8(bytes1(\\\"h\\\")));\\n\\n/// @dev ASCII i\\nuint128 constant CMASK_LOWER_I = uint128(1) << uint128(uint8(bytes1(\\\"i\\\")));\\n\\n/// @dev ASCII j\\nuint128 constant CMASK_LOWER_J = uint128(1) << uint128(uint8(bytes1(\\\"j\\\")));\\n\\n/// @dev ASCII k\\nuint128 constant CMASK_LOWER_K = uint128(1) << uint128(uint8(bytes1(\\\"k\\\")));\\n\\n/// @dev ASCII l\\nuint128 constant CMASK_LOWER_L = uint128(1) << uint128(uint8(bytes1(\\\"l\\\")));\\n\\n/// @dev ASCII m\\nuint128 constant CMASK_LOWER_M = uint128(1) << uint128(uint8(bytes1(\\\"m\\\")));\\n\\n/// @dev ASCII n\\nuint128 constant CMASK_LOWER_N = uint128(1) << uint128(uint8(bytes1(\\\"n\\\")));\\n\\n/// @dev ASCII o\\nuint128 constant CMASK_LOWER_O = uint128(1) << uint128(uint8(bytes1(\\\"o\\\")));\\n\\n/// @dev ASCII p\\nuint128 constant CMASK_LOWER_P = uint128(1) << uint128(uint8(bytes1(\\\"p\\\")));\\n\\n/// @dev ASCII q\\nuint128 constant CMASK_LOWER_Q = uint128(1) << uint128(uint8(bytes1(\\\"q\\\")));\\n\\n/// @dev ASCII r\\nuint128 constant CMASK_LOWER_R = uint128(1) << uint128(uint8(bytes1(\\\"r\\\")));\\n\\n/// @dev ASCII s\\nuint128 constant CMASK_LOWER_S = uint128(1) << uint128(uint8(bytes1(\\\"s\\\")));\\n\\n/// @dev ASCII t\\nuint128 constant CMASK_LOWER_T = uint128(1) << uint128(uint8(bytes1(\\\"t\\\")));\\n\\n/// @dev ASCII u\\nuint128 constant CMASK_LOWER_U = uint128(1) << uint128(uint8(bytes1(\\\"u\\\")));\\n\\n/// @dev ASCII v\\nuint128 constant CMASK_LOWER_V = uint128(1) << uint128(uint8(bytes1(\\\"v\\\")));\\n\\n/// @dev ASCII w\\nuint128 constant CMASK_LOWER_W = uint128(1) << uint128(uint8(bytes1(\\\"w\\\")));\\n\\n/// @dev ASCII x\\nuint128 constant CMASK_LOWER_X = uint128(1) << uint128(uint8(bytes1(\\\"x\\\")));\\n\\n/// @dev ASCII y\\nuint128 constant CMASK_LOWER_Y = uint128(1) << uint128(uint8(bytes1(\\\"y\\\")));\\n\\n/// @dev ASCII z\\nuint128 constant CMASK_LOWER_Z = uint128(1) << uint128(uint8(bytes1(\\\"z\\\")));\\n\\n/// @dev ASCII {\\nuint128 constant CMASK_LEFT_CURLY_BRACKET = uint128(1) << uint128(uint8(bytes1(\\\"{\\\")));\\n\\n/// @dev ASCII |\\nuint128 constant CMASK_VERTICAL_BAR = uint128(1) << uint128(uint8(bytes1(\\\"|\\\")));\\n\\n/// @dev ASCII }\\nuint128 constant CMASK_RIGHT_CURLY_BRACKET = uint128(1) << uint128(uint8(bytes1(\\\"}\\\")));\\n\\n/// @dev ASCII ~\\nuint128 constant CMASK_TILDE = uint128(1) << uint128(uint8(bytes1(\\\"~\\\")));\\n\\n/// @dev ASCII delete\\nuint128 constant CMASK_DELETE = uint128(1) << uint128(uint8(bytes1(\\\"\\\\x7F\\\")));\\n\\n/// @dev numeric 0-9\\nuint128 constant CMASK_NUMERIC_0_9 = CMASK_ZERO | CMASK_ONE | CMASK_TWO | CMASK_THREE | CMASK_FOUR | CMASK_FIVE\\n    | CMASK_SIX | CMASK_SEVEN | CMASK_EIGHT | CMASK_NINE;\\n\\n/// @dev e notation eE\\nuint128 constant CMASK_E_NOTATION = CMASK_LOWER_E | CMASK_UPPER_E;\\n\\n/// @dev lower alpha a-z\\nuint128 constant CMASK_LOWER_ALPHA_A_Z = CMASK_LOWER_A | CMASK_LOWER_B | CMASK_LOWER_C | CMASK_LOWER_D | CMASK_LOWER_E\\n    | CMASK_LOWER_F | CMASK_LOWER_G | CMASK_LOWER_H | CMASK_LOWER_I | CMASK_LOWER_J | CMASK_LOWER_K | CMASK_LOWER_L\\n    | CMASK_LOWER_M | CMASK_LOWER_N | CMASK_LOWER_O | CMASK_LOWER_P | CMASK_LOWER_Q | CMASK_LOWER_R | CMASK_LOWER_S\\n    | CMASK_LOWER_T | CMASK_LOWER_U | CMASK_LOWER_V | CMASK_LOWER_W | CMASK_LOWER_X | CMASK_LOWER_Y | CMASK_LOWER_Z;\\n\\n/// @dev upper alpha A-Z\\nuint128 constant CMASK_UPPER_ALPHA_A_Z = CMASK_UPPER_A | CMASK_UPPER_B | CMASK_UPPER_C | CMASK_UPPER_D | CMASK_UPPER_E\\n    | CMASK_UPPER_F | CMASK_UPPER_G | CMASK_UPPER_H | CMASK_UPPER_I | CMASK_UPPER_J | CMASK_UPPER_K | CMASK_UPPER_L\\n    | CMASK_UPPER_M | CMASK_UPPER_N | CMASK_UPPER_O | CMASK_UPPER_P | CMASK_UPPER_Q | CMASK_UPPER_R | CMASK_UPPER_S\\n    | CMASK_UPPER_T | CMASK_UPPER_U | CMASK_UPPER_V | CMASK_UPPER_W | CMASK_UPPER_X | CMASK_UPPER_Y | CMASK_UPPER_Z;\\n\\n/// @dev lower alpha a-f (hex)\\nuint128 constant CMASK_LOWER_ALPHA_A_F =\\n    CMASK_LOWER_A | CMASK_LOWER_B | CMASK_LOWER_C | CMASK_LOWER_D | CMASK_LOWER_E | CMASK_LOWER_F;\\n\\n/// @dev upper alpha A-F (hex)\\nuint128 constant CMASK_UPPER_ALPHA_A_F =\\n    CMASK_UPPER_A | CMASK_UPPER_B | CMASK_UPPER_C | CMASK_UPPER_D | CMASK_UPPER_E | CMASK_UPPER_F;\\n\\n/// @dev hex 0-9 a-f A-F\\nuint128 constant CMASK_HEX = CMASK_NUMERIC_0_9 | CMASK_LOWER_ALPHA_A_F | CMASK_UPPER_ALPHA_A_F;\\n\\n/// @dev Rainlang end of line is ,\\nuint128 constant CMASK_EOL = CMASK_COMMA;\\n\\n/// @dev Rainlang LHS/RHS delimiter is :\\nuint128 constant CMASK_LHS_RHS_DELIMITER = CMASK_COLON;\\n\\n/// @dev Rainlang end of source is ;\\nuint128 constant CMASK_EOS = CMASK_SEMICOLON;\\n\\n/// @dev Rainlang stack head is lower alpha and underscore a-z _\\nuint128 constant CMASK_LHS_STACK_HEAD = CMASK_LOWER_ALPHA_A_Z | CMASK_UNDERSCORE;\\n\\n/// @dev Rainlang identifier head is lower alpha a-z\\nuint128 constant CMASK_IDENTIFIER_HEAD = CMASK_LOWER_ALPHA_A_Z;\\nuint128 constant CMASK_RHS_WORD_HEAD = CMASK_IDENTIFIER_HEAD;\\n\\n/// @dev Rainlang stack/identifier tail is lower alphanumeric kebab a-z 0-9 -\\nuint128 constant CMASK_IDENTIFIER_TAIL = CMASK_IDENTIFIER_HEAD | CMASK_NUMERIC_0_9 | CMASK_DASH;\\nuint128 constant CMASK_LHS_STACK_TAIL = CMASK_IDENTIFIER_TAIL;\\nuint128 constant CMASK_RHS_WORD_TAIL = CMASK_IDENTIFIER_TAIL;\\n\\n/// @dev Rainlang operand start is <\\nuint128 constant CMASK_OPERAND_START = CMASK_LESS_THAN_SIGN;\\n\\n/// @dev Rainlang operand end is >\\nuint128 constant CMASK_OPERAND_END = CMASK_GREATER_THAN_SIGN;\\n\\n/// @dev NOT lower alphanumeric kebab\\nuint128 constant CMASK_NOT_IDENTIFIER_TAIL = ~CMASK_IDENTIFIER_TAIL;\\n\\n/// @dev Rainlang whitespace is \\\\n \\\\r \\\\t space\\nuint128 constant CMASK_WHITESPACE = CMASK_LINE_FEED | CMASK_CARRIAGE_RETURN | CMASK_HORIZONTAL_TAB | CMASK_SPACE;\\n\\n/// @dev Rainlang stack item delimiter is whitespace\\nuint128 constant CMASK_LHS_STACK_DELIMITER = CMASK_WHITESPACE;\\n\\n/// @dev Rainlang supports numeric literals as anything starting with 0-9\\nuint128 constant CMASK_NUMERIC_LITERAL_HEAD = CMASK_NUMERIC_0_9;\\n\\n/// @dev Rainlang literal head\\nuint128 constant CMASK_LITERAL_HEAD = CMASK_NUMERIC_LITERAL_HEAD;\\n\\n/// @dev Rainlang comment head is /\\nuint128 constant CMASK_COMMENT_HEAD = CMASK_SLASH;\\n\\n/// @dev Rainlang comment starting sequence is /*\\nuint256 constant COMMENT_START_SEQUENCE = uint256(uint16(bytes2(\\\"/*\\\")));\\n\\n/// @dev Rainlang comment ending sequence is */\\nuint256 constant COMMENT_END_SEQUENCE = uint256(uint16(bytes2(\\\"*/\\\")));\\n\\n/// @dev Rainlang literal hexadecimal dispatch is 0x\\n/// We compare the head and dispatch together to avoid a second comparison.\\n/// This is safe because the head is prefiltered to be 0-9 due to the numeric\\n/// literal head, therefore the only possible match is 0x (not x0).\\nuint128 constant CMASK_LITERAL_HEX_DISPATCH = CMASK_ZERO | CMASK_LOWER_X;\\n\"\r\n    },\r\n    \"src/lib/bitwise/LibCtPop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @dev 010101... for ctpop\\nuint256 constant CTPOP_M1 = 0x5555555555555555555555555555555555555555555555555555555555555555;\\n/// @dev 00110011.. for ctpop\\nuint256 constant CTPOP_M2 = 0x3333333333333333333333333333333333333333333333333333333333333333;\\n/// @dev 4 bits alternating for ctpop\\nuint256 constant CTPOP_M4 = 0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F;\\n/// @dev 8 bits alternating for ctpop\\nuint256 constant CTPOP_M8 = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF;\\n/// @dev 16 bits alternating for ctpop\\nuint256 constant CTPOP_M16 = 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF;\\n/// @dev 32 bits alternating for ctpop\\nuint256 constant CTPOP_M32 = 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF;\\n/// @dev 64 bits alternating for ctpop\\nuint256 constant CTPOP_M64 = 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF;\\n/// @dev 128 bits alternating for ctpop\\nuint256 constant CTPOP_M128 = 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n/// @dev 1 bytes for ctpop\\nuint256 constant CTPOP_H01 = 0x0101010101010101010101010101010101010101010101010101010101010101;\\n\\nlibrary LibCtPop {\\n    /// Optimised version of ctpop.\\n    /// https://en.wikipedia.org/wiki/Hamming_weight\\n    function ctpop(uint256 x) internal pure returns (uint256) {\\n        // This edge case is not handled by the algorithm below.\\n        if (x == type(uint256).max) {\\n            return 256;\\n        }\\n        unchecked {\\n            x -= (x >> 1) & CTPOP_M1;\\n            x = (x & CTPOP_M2) + ((x >> 2) & CTPOP_M2);\\n            x = (x + (x >> 4)) & CTPOP_M4;\\n            x = (x * CTPOP_H01) >> 248;\\n        }\\n        return x;\\n    }\\n\\n    /// This is the slowest possible implementation of ctpop. It is used to\\n    /// verify the correctness of the optimized implementation in LibCtPop.\\n    /// It should be obviously correct by visual inspection, referencing the\\n    /// wikipedia article.\\n    /// https://en.wikipedia.org/wiki/Hamming_weight\\n    function ctpopSlow(uint256 x) internal pure returns (uint256) {\\n        unchecked {\\n            x = (x & CTPOP_M1) + ((x >> 1) & CTPOP_M1);\\n            x = (x & CTPOP_M2) + ((x >> 2) & CTPOP_M2);\\n            x = (x & CTPOP_M4) + ((x >> 4) & CTPOP_M4);\\n            x = (x & CTPOP_M8) + ((x >> 8) & CTPOP_M8);\\n            x = (x & CTPOP_M16) + ((x >> 16) & CTPOP_M16);\\n            x = (x & CTPOP_M32) + ((x >> 32) & CTPOP_M32);\\n            x = (x & CTPOP_M64) + ((x >> 64) & CTPOP_M64);\\n            x = (x & CTPOP_M128) + ((x >> 128) & CTPOP_M128);\\n        }\\n        return x;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/parse/LibParseMeta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport {LibCtPop} from \\\"../bitwise/LibCtPop.sol\\\";\\nimport {Operand} from \\\"../../interface/unstable/IInterpreterV2.sol\\\";\\nimport {LibParseOperand} from \\\"./LibParseOperand.sol\\\";\\n\\n/// @dev For metadata builder.\\nerror DuplicateFingerprint();\\n\\n/// @dev Words and io fn pointers aren't the same length.\\nerror WordIOFnPointerMismatch(uint256 wordsLength, uint256 ioFnPointersLength);\\n\\n/// @dev 0xFFFFFF = 3 byte fingerprint\\n/// The fingerprint is 3 bytes because we're targetting the same collision\\n/// resistance on words as solidity functions. As we already use a fully byte to\\n/// map words across the expander, we only need 3 bytes for the fingerprint to\\n/// achieve 4 bytes of collision resistance, which is the same as a solidity\\n/// selector. This assumes that the byte selected to expand is uncorrelated with\\n/// the fingerprint bytes, which is a reasonable assumption as long as we use\\n/// different bytes from a keccak256 hash for each.\\n/// This assumes a single expander, if there are multiple expanders, then the\\n/// collision resistance only improves, so this is still safe.\\nuint256 constant FINGERPRINT_MASK = 0xFFFFFF;\\n/// @dev 4 = 1 byte opcode index + 1 byte operand parser offset + 3 byte fingerprint\\nuint256 constant META_ITEM_SIZE = 5;\\nuint256 constant META_ITEM_MASK = (1 << META_ITEM_SIZE) - 1;\\n/// @dev 33 = 32 bytes for expansion + 1 byte for seed\\nuint256 constant META_EXPANSION_SIZE = 0x21;\\n/// @dev 1 = 1 byte for depth\\nuint256 constant META_PREFIX_SIZE = 1;\\n\\nstruct AuthoringMeta {\\n    // `word` is referenced directly in assembly so don't move the field.\\n    bytes32 word;\\n    uint8 operandParserOffset;\\n    string description;\\n}\\n\\nlibrary LibParseMeta {\\n    function wordBitmapped(uint256 seed, bytes32 word) internal pure returns (uint256 bitmap, uint256 hashed) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, word)\\n            mstore8(0x20, seed)\\n            hashed := keccak256(0, 0x21)\\n            // We have to be careful here to avoid using the same byte for both\\n            // the expansion and the fingerprint. This is because we are relying\\n            // on the combined effect of both for collision resistance. We do\\n            // this by using the high byte of the hash for the bitmap, and the\\n            // low 3 bytes for the fingerprint.\\n            //slither-disable-next-line incorrect-shift\\n            bitmap := shl(byte(0, hashed), 1)\\n        }\\n    }\\n\\n    function copyWordsFromAuthoringMeta(AuthoringMeta[] memory authoringMeta)\\n        internal\\n        pure\\n        returns (bytes32[] memory)\\n    {\\n        bytes32[] memory words = new bytes32[](authoringMeta.length);\\n        for (uint256 i = 0; i < authoringMeta.length; i++) {\\n            words[i] = authoringMeta[i].word;\\n        }\\n        return words;\\n    }\\n\\n    function findBestExpander(AuthoringMeta[] memory metas)\\n        internal\\n        pure\\n        returns (uint8 bestSeed, uint256 bestExpansion, AuthoringMeta[] memory remaining)\\n    {\\n        unchecked {\\n            {\\n                uint256 bestCt = 0;\\n                for (uint256 seed = 0; seed < type(uint8).max; seed++) {\\n                    uint256 expansion = 0;\\n                    for (uint256 i = 0; i < metas.length; i++) {\\n                        (uint256 shifted, uint256 hashed) = wordBitmapped(seed, metas[i].word);\\n                        (hashed);\\n                        expansion = shifted | expansion;\\n                    }\\n                    uint256 ct = LibCtPop.ctpop(expansion);\\n                    if (ct > bestCt) {\\n                        bestCt = ct;\\n                        bestSeed = uint8(seed);\\n                        bestExpansion = expansion;\\n                    }\\n                    // perfect expansion.\\n                    if (ct == metas.length) {\\n                        break;\\n                    }\\n                }\\n\\n                uint256 remainingLength = metas.length - bestCt;\\n                assembly (\\\"memory-safe\\\") {\\n                    remaining := mload(0x40)\\n                    mstore(remaining, remainingLength)\\n                    mstore(0x40, add(remaining, mul(0x20, add(1, remainingLength))))\\n                }\\n            }\\n            uint256 usedExpansion = 0;\\n            uint256 j = 0;\\n            for (uint256 i = 0; i < metas.length; i++) {\\n                (uint256 shifted, uint256 hashed) = wordBitmapped(bestSeed, metas[i].word);\\n                (hashed);\\n                if ((shifted & usedExpansion) == 0) {\\n                    usedExpansion = shifted | usedExpansion;\\n                } else {\\n                    remaining[j] = metas[i];\\n                    j++;\\n                }\\n            }\\n        }\\n    }\\n\\n    function buildParseMeta(AuthoringMeta[] memory authoringMeta, uint8 maxDepth)\\n        internal\\n        pure\\n        returns (bytes memory parseMeta)\\n    {\\n        unchecked {\\n            // Write out expansions.\\n            uint8[] memory seeds;\\n            uint256[] memory expansions;\\n            uint256 dataStart;\\n            {\\n                uint256 depth = 0;\\n                seeds = new uint8[](maxDepth);\\n                expansions = new uint256[](maxDepth);\\n                {\\n                    AuthoringMeta[] memory remainingAuthoringMeta = authoringMeta;\\n                    while (remainingAuthoringMeta.length > 0) {\\n                        uint8 seed;\\n                        uint256 expansion;\\n                        (seed, expansion, remainingAuthoringMeta) = findBestExpander(remainingAuthoringMeta);\\n                        seeds[depth] = seed;\\n                        expansions[depth] = expansion;\\n                        depth++;\\n                    }\\n                }\\n\\n                uint256 parseMetaLength =\\n                    META_PREFIX_SIZE + depth * META_EXPANSION_SIZE + authoringMeta.length * META_ITEM_SIZE;\\n                parseMeta = new bytes(parseMetaLength);\\n                assembly (\\\"memory-safe\\\") {\\n                    mstore8(add(parseMeta, 0x20), depth)\\n                }\\n                for (uint256 j = 0; j < depth; j++) {\\n                    assembly (\\\"memory-safe\\\") {\\n                        // Write each seed immediately before its expansion.\\n                        let seedWriteAt := add(add(parseMeta, 0x21), mul(0x21, j))\\n                        mstore8(seedWriteAt, mload(add(seeds, add(0x20, mul(0x20, j)))))\\n                        mstore(add(seedWriteAt, 1), mload(add(expansions, add(0x20, mul(0x20, j)))))\\n                    }\\n                }\\n\\n                {\\n                    uint256 dataOffset = META_PREFIX_SIZE + META_ITEM_SIZE + depth * META_EXPANSION_SIZE;\\n                    assembly (\\\"memory-safe\\\") {\\n                        dataStart := add(parseMeta, dataOffset)\\n                    }\\n                }\\n            }\\n\\n            // Write words.\\n            for (uint256 k = 0; k < authoringMeta.length; k++) {\\n                uint256 s = 0;\\n                uint256 cumulativePos = 0;\\n                while (true) {\\n                    uint256 toWrite;\\n                    uint256 writeAt;\\n\\n                    // Need some careful scoping here to avoid stack too deep.\\n                    {\\n                        uint256 expansion = expansions[s];\\n\\n                        uint256 hashed;\\n                        {\\n                            uint256 shifted;\\n                            (shifted, hashed) = wordBitmapped(seeds[s], authoringMeta[k].word);\\n\\n                            uint256 metaItemSize = META_ITEM_SIZE;\\n                            uint256 pos = LibCtPop.ctpop(expansion & (shifted - 1)) + cumulativePos;\\n                            assembly (\\\"memory-safe\\\") {\\n                                writeAt := add(dataStart, mul(pos, metaItemSize))\\n                            }\\n                        }\\n\\n                        {\\n                            uint256 wordFingerprint = hashed & FINGERPRINT_MASK;\\n                            uint256 posFingerprint;\\n                            assembly (\\\"memory-safe\\\") {\\n                                posFingerprint := mload(writeAt)\\n                            }\\n                            posFingerprint &= FINGERPRINT_MASK;\\n                            if (posFingerprint != 0) {\\n                                if (posFingerprint == wordFingerprint) {\\n                                    revert DuplicateFingerprint();\\n                                }\\n                                // Collision, try next expansion.\\n                                s++;\\n                                cumulativePos = cumulativePos + LibCtPop.ctpop(expansion);\\n                                continue;\\n                            }\\n                            // Not collision, start preparing the write with the\\n                            // fingerprint.\\n                            toWrite = wordFingerprint;\\n                        }\\n                    }\\n\\n                    // Write the io fn pointer and index offset.\\n                    toWrite |= (k << 0x20) | (uint256(authoringMeta[k].operandParserOffset) << 0x18);\\n\\n                    uint256 mask = ~META_ITEM_MASK;\\n                    assembly (\\\"memory-safe\\\") {\\n                        mstore(writeAt, or(and(mload(writeAt), mask), toWrite))\\n                    }\\n                    // We're done with this word.\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Given the parse meta and a word, return the index and io fn pointer for\\n    /// the word. If the word is not found, then `exists` will be false. The\\n    /// caller MUST check `exists` before using the other return values.\\n    /// @param meta The parse meta.\\n    /// @param word The word to lookup.\\n    /// @return True if the word exists in the parse meta.\\n    /// @return The index of the word in the parse meta.\\n    function lookupWord(bytes memory meta, uint256 operandParsers, bytes32 word)\\n        internal\\n        pure\\n        returns (bool, uint256, function(uint256, bytes memory, uint256) pure returns (uint256, Operand))\\n    {\\n        unchecked {\\n            uint256 dataStart;\\n            uint256 cursor;\\n            uint256 end;\\n            {\\n                uint256 metaExpansionSize = META_EXPANSION_SIZE;\\n                uint256 metaItemSize = META_ITEM_SIZE;\\n                assembly (\\\"memory-safe\\\") {\\n                    // Read depth from first meta byte.\\n                    cursor := add(meta, 1)\\n                    let depth := and(mload(cursor), 0xFF)\\n                    // 33 bytes per depth\\n                    end := add(cursor, mul(depth, metaExpansionSize))\\n                    dataStart := add(end, metaItemSize)\\n                }\\n            }\\n\\n            uint256 cumulativeCt = 0;\\n            while (cursor < end) {\\n                uint256 expansion;\\n                uint256 posData;\\n                uint256 wordFingerprint;\\n                // Lookup the data at pos.\\n                {\\n                    uint256 seed;\\n                    assembly (\\\"memory-safe\\\") {\\n                        cursor := add(cursor, 1)\\n                        seed := and(mload(cursor), 0xFF)\\n                        cursor := add(cursor, 0x20)\\n                        expansion := mload(cursor)\\n                    }\\n\\n                    (uint256 shifted, uint256 hashed) = wordBitmapped(seed, word);\\n                    uint256 pos = LibCtPop.ctpop(expansion & (shifted - 1)) + cumulativeCt;\\n                    wordFingerprint = hashed & FINGERPRINT_MASK;\\n                    uint256 metaItemSize = META_ITEM_SIZE;\\n                    assembly (\\\"memory-safe\\\") {\\n                        posData := mload(add(dataStart, mul(pos, metaItemSize)))\\n                    }\\n                }\\n\\n                // Match\\n                if (wordFingerprint == posData & FINGERPRINT_MASK) {\\n                    uint256 index;\\n                    function(uint256, bytes memory, uint256) pure returns (uint256, Operand) operandParser;\\n                    assembly (\\\"memory-safe\\\") {\\n                        index := byte(27, posData)\\n                        operandParser := and(shr(byte(28, posData), operandParsers), 0xFFFF)\\n                    }\\n                    return (true, index, operandParser);\\n                } else {\\n                    cumulativeCt += LibCtPop.ctpop(expansion);\\n                }\\n            }\\n            // The caller MUST NOT use this operand parser as `exists` is false.\\n            function(uint256, bytes memory, uint256) pure returns (uint256, Operand) operandParserZero;\\n            assembly (\\\"memory-safe\\\") {\\n                operandParserZero := 0\\n            }\\n            return (false, 0, operandParserZero);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/parse/LibParseLiteral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibParseCMask.sol\\\";\\nimport \\\"./LibParse.sol\\\";\\n\\n/// The parser tried to bound an unsupported literal that we have no type for.\\nerror UnsupportedLiteralType(uint256 offset);\\n\\n/// Encountered a literal that is larger than supported.\\nerror HexLiteralOverflow(uint256 offset);\\n\\n/// Encountered a zero length hex literal.\\nerror ZeroLengthHexLiteral(uint256 offset);\\n\\n/// Encountered an odd sized hex literal.\\nerror OddLengthHexLiteral(uint256 offset);\\n\\n/// Encountered a hex literal with an invalid character.\\nerror MalformedHexLiteral(uint256 offset);\\n\\n/// Encountered a decimal literal that is larger than supported.\\nerror DecimalLiteralOverflow(uint256 offset);\\n\\n/// Encountered a decimal literal with an exponent that has too many or no\\n/// digits.\\nerror MalformedExponentDigits(uint256 offset);\\n\\n/// Encountered a zero length decimal literal.\\nerror ZeroLengthDecimal(uint256 offset);\\n\\n/// @dev The type of a literal is both a unique value and a literal offset used\\n/// to index into the literal parser array as a uint256.\\nuint256 constant LITERAL_TYPE_INTEGER_HEX = 0;\\n/// @dev The type of a literal is both a unique value and a literal offset used\\n/// to index into the literal parser array as a uint256.\\nuint256 constant LITERAL_TYPE_INTEGER_DECIMAL = 0x10;\\n\\nlibrary LibParseLiteral {\\n    function buildLiteralParsers() internal pure returns (uint256 literalParsers) {\\n        // Register all the literal parsers in the parse state. Each is a 16 bit\\n        // function pointer so we can have up to 16 literal types. This needs to\\n        // be done at runtime because the library code doesn't know the bytecode\\n        // offsets of the literal parsers until it is compiled into a contract.\\n        {\\n            function(bytes memory, uint256, uint256) pure returns (uint256) literalParserHex =\\n                LibParseLiteral.parseLiteralHex;\\n            uint256 parseLiteralHexOffset = LITERAL_TYPE_INTEGER_HEX;\\n            function(bytes memory, uint256, uint256) pure returns (uint256) literalParserDecimal =\\n                LibParseLiteral.parseLiteralDecimal;\\n            uint256 parseLiteralDecimalOffset = LITERAL_TYPE_INTEGER_DECIMAL;\\n\\n            assembly (\\\"memory-safe\\\") {\\n                literalParsers :=\\n                    or(shl(parseLiteralHexOffset, literalParserHex), shl(parseLiteralDecimalOffset, literalParserDecimal))\\n            }\\n        }\\n    }\\n\\n    /// Find the bounds for some literal at the cursor. The caller is responsible\\n    /// for checking that the cursor is at the start of a literal. As each\\n    /// literal type has a different format, this function returns the bounds\\n    /// for the literal and the type of the literal. The bounds are:\\n    /// - innerStart: the start of the literal, e.g. after the 0x in 0x1234\\n    /// - innerEnd: the end of the literal, e.g. after the 1234 in 0x1234\\n    /// - outerEnd: the end of the literal including any suffixes, MAY be the\\n    ///   same as innerEnd if there is no suffix.\\n    /// The outerStart is the cursor, so it is not returned.\\n    /// @param cursor The start of the literal.\\n    /// @return The literal parser. This function can be called to convert the\\n    /// bounds into a uint256 value.\\n    /// @return The inner start.\\n    /// @return The inner end.\\n    /// @return The outer end.\\n    function boundLiteral(uint256 literalParsers, bytes memory data, uint256 cursor)\\n        internal\\n        pure\\n        returns (function(bytes memory, uint256, uint256) pure returns (uint256), uint256, uint256, uint256)\\n    {\\n        unchecked {\\n            uint256 word;\\n            uint256 head;\\n            assembly (\\\"memory-safe\\\") {\\n                word := mload(cursor)\\n                //slither-disable-next-line incorrect-shift\\n                head := shl(byte(0, word), 1)\\n            }\\n\\n            // numeric literal head is 0-9\\n            if (head & CMASK_NUMERIC_LITERAL_HEAD != 0) {\\n                uint256 dispatch;\\n                assembly (\\\"memory-safe\\\") {\\n                    //slither-disable-next-line incorrect-shift\\n                    dispatch := shl(byte(1, word), 1)\\n                }\\n\\n                // hexadecimal literal dispatch is 0x\\n                if ((head | dispatch) == CMASK_LITERAL_HEX_DISPATCH) {\\n                    uint256 innerStart = cursor + 2;\\n                    uint256 innerEnd = innerStart;\\n                    {\\n                        uint256 hexCharMask = CMASK_HEX;\\n                        assembly (\\\"memory-safe\\\") {\\n                            //slither-disable-next-line incorrect-shift\\n                            for {} iszero(iszero(and(shl(byte(0, mload(innerEnd)), 1), hexCharMask))) {\\n                                innerEnd := add(innerEnd, 1)\\n                            } {}\\n                        }\\n                    }\\n\\n                    function(bytes memory, uint256, uint256) pure returns (uint256) parser;\\n                    {\\n                        uint256 p = (literalParsers >> LITERAL_TYPE_INTEGER_HEX) & 0xFFFF;\\n                        assembly (\\\"memory-safe\\\") {\\n                            parser := p\\n                        }\\n                    }\\n                    {\\n                        uint256 endHex;\\n                        assembly (\\\"memory-safe\\\") {\\n                            endHex := add(data, add(mload(data), 0x20))\\n                        }\\n                        if (innerEnd > endHex) {\\n                            revert ParserOutOfBounds();\\n                        }\\n                    }\\n                    return (parser, innerStart, innerEnd, innerEnd);\\n                }\\n                // decimal is the fallback as continuous numeric digits 0-9.\\n                else {\\n                    uint256 innerStart = cursor;\\n                    // We know the head is a numeric so we can move past it.\\n                    uint256 innerEnd = innerStart + 1;\\n                    uint256 ePosition = 0;\\n\\n                    {\\n                        uint256 decimalCharMask = CMASK_NUMERIC_0_9;\\n                        uint256 eMask = CMASK_E_NOTATION;\\n                        assembly (\\\"memory-safe\\\") {\\n                            //slither-disable-next-line incorrect-shift\\n                            for {} iszero(iszero(and(shl(byte(0, mload(innerEnd)), 1), decimalCharMask))) {\\n                                innerEnd := add(innerEnd, 1)\\n                            } {}\\n\\n                            // If we're now pointing at an e notation, then we need\\n                            // to move past it. Negative exponents are not supported.\\n                            //slither-disable-next-line incorrect-shift\\n                            if iszero(iszero(and(shl(byte(0, mload(innerEnd)), 1), eMask))) {\\n                                ePosition := innerEnd\\n                                innerEnd := add(innerEnd, 1)\\n\\n                                // Move past the exponent digits.\\n                                //slither-disable-next-line incorrect-shift\\n                                for {} iszero(iszero(and(shl(byte(0, mload(innerEnd)), 1), decimalCharMask))) {\\n                                    innerEnd := add(innerEnd, 1)\\n                                } {}\\n                            }\\n                        }\\n                    }\\n                    if (ePosition != 0 && (innerEnd > ePosition + 3 || innerEnd == ePosition + 1)) {\\n                        revert MalformedExponentDigits(LibParse.parseErrorOffset(data, ePosition));\\n                    }\\n\\n                    function(bytes memory, uint256, uint256) pure returns (uint256) parser;\\n                    {\\n                        uint256 p = (literalParsers >> LITERAL_TYPE_INTEGER_DECIMAL) & 0xFFFF;\\n                        assembly (\\\"memory-safe\\\") {\\n                            parser := p\\n                        }\\n                    }\\n                    {\\n                        uint256 endDecimal;\\n                        assembly (\\\"memory-safe\\\") {\\n                            endDecimal := add(data, add(mload(data), 0x20))\\n                        }\\n                        if (innerEnd > endDecimal) {\\n                            revert ParserOutOfBounds();\\n                        }\\n                    }\\n                    return (parser, innerStart, innerEnd, innerEnd);\\n                }\\n            }\\n\\n            uint256 endUnknown;\\n            assembly (\\\"memory-safe\\\") {\\n                endUnknown := add(data, add(mload(data), 0x20))\\n            }\\n            if (cursor >= endUnknown) {\\n                revert ParserOutOfBounds();\\n            } else {\\n                revert UnsupportedLiteralType(LibParse.parseErrorOffset(data, cursor));\\n            }\\n        }\\n    }\\n\\n    /// Algorithm for parsing hexadecimal literals:\\n    /// - start at the end of the literal\\n    /// - for each character:\\n    ///   - convert the character to a nybble\\n    ///   - shift the nybble into the total at the correct position\\n    ///     (4 bits per nybble)\\n    /// - return the total\\n    function parseLiteralHex(bytes memory data, uint256 start, uint256 end) internal pure returns (uint256 value) {\\n        unchecked {\\n            uint256 length = end - start;\\n            if (length > 0x40) {\\n                revert HexLiteralOverflow(LibParse.parseErrorOffset(data, start));\\n            } else if (length == 0) {\\n                revert ZeroLengthHexLiteral(LibParse.parseErrorOffset(data, start));\\n            } else if (length % 2 == 1) {\\n                revert OddLengthHexLiteral(LibParse.parseErrorOffset(data, start));\\n            } else {\\n                uint256 cursor = end - 1;\\n                uint256 valueOffset = 0;\\n                while (cursor >= start) {\\n                    uint256 hexCharByte;\\n                    assembly (\\\"memory-safe\\\") {\\n                        hexCharByte := byte(0, mload(cursor))\\n                    }\\n                    //slither-disable-next-line incorrect-shift\\n                    uint256 hexChar = 1 << hexCharByte;\\n\\n                    uint256 nybble;\\n                    // 0-9\\n                    if (hexChar & CMASK_NUMERIC_0_9 != 0) {\\n                        nybble = hexCharByte - uint256(uint8(bytes1(\\\"0\\\")));\\n                    }\\n                    // a-f\\n                    else if (hexChar & CMASK_LOWER_ALPHA_A_F != 0) {\\n                        nybble = hexCharByte - uint256(uint8(bytes1(\\\"a\\\"))) + 10;\\n                    }\\n                    // A-F\\n                    else if (hexChar & CMASK_UPPER_ALPHA_A_F != 0) {\\n                        nybble = hexCharByte - uint256(uint8(bytes1(\\\"A\\\"))) + 10;\\n                    } else {\\n                        revert MalformedHexLiteral(LibParse.parseErrorOffset(data, cursor));\\n                    }\\n\\n                    value |= nybble << valueOffset;\\n                    valueOffset += 4;\\n                    cursor--;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Algorithm for parsing decimal literals:\\n    /// - start at the end of the literal\\n    /// - for each digit:\\n    ///   - multiply the digit by 10^digit position\\n    ///   - add the result to the total\\n    /// - return the total\\n    ///\\n    /// This algorithm is ONLY safe if the caller has already checked that the\\n    /// start/end span a non-zero length of valid decimal chars. The caller\\n    /// can most easily do this by using the `boundLiteral` function.\\n    ///\\n    /// Unsafe behavior is undefined and can easily result in out of bounds\\n    /// reads as there are no checks that start/end are within `data`.\\n    function parseLiteralDecimal(bytes memory data, uint256 start, uint256 end) internal pure returns (uint256 value) {\\n        unchecked {\\n            // Tracks which digit we're on.\\n            uint256 cursor;\\n            // The ASCII byte can be translated to a numeric digit by subtracting\\n            // the digit offset.\\n            uint256 digitOffset = uint256(uint8(bytes1(\\\"0\\\")));\\n            // Tracks the exponent of the current digit. Can start above 0 if\\n            // the literal is in e notation.\\n            uint256 exponent;\\n            {\\n                uint256 word;\\n                //slither-disable-next-line similar-names\\n                uint256 decimalCharByte;\\n                uint256 length = end - start;\\n                assembly (\\\"memory-safe\\\") {\\n                    word := mload(sub(end, 3))\\n                    decimalCharByte := byte(0, word)\\n                }\\n                // If the last 3 bytes are e notation, then we need to parse\\n                // the exponent as a 2 digit number.\\n                //slither-disable-next-line incorrect-shift\\n                if (length > 3 && ((1 << decimalCharByte) & CMASK_E_NOTATION) != 0) {\\n                    cursor = end - 4;\\n                    assembly (\\\"memory-safe\\\") {\\n                        exponent := add(sub(byte(2, word), digitOffset), mul(sub(byte(1, word), digitOffset), 10))\\n                    }\\n                } else {\\n                    assembly (\\\"memory-safe\\\") {\\n                        decimalCharByte := byte(1, word)\\n                    }\\n                    // If the last 2 bytes are e notation, then we need to parse\\n                    // the exponent as a 1 digit number.\\n                    //slither-disable-next-line incorrect-shift\\n                    if (length > 2 && ((1 << decimalCharByte) & CMASK_E_NOTATION) != 0) {\\n                        cursor = end - 3;\\n                        assembly (\\\"memory-safe\\\") {\\n                            exponent := sub(byte(2, word), digitOffset)\\n                        }\\n                    }\\n                    // Otherwise, we're not in e notation and we can start at the\\n                    // end of the literal with 0 starting exponent.\\n                    else if (length > 0) {\\n                        cursor = end - 1;\\n                        exponent = 0;\\n                    } else {\\n                        revert ZeroLengthDecimal(LibParse.parseErrorOffset(data, start));\\n                    }\\n                }\\n            }\\n\\n            // Anything under 10^77 is safe to raise to its power of 10 without\\n            // overflowing a uint256.\\n            while (cursor >= start && exponent < 77) {\\n                // We don't need to check the bounds of the byte because\\n                // we know it is a decimal literal as long as the bounds\\n                // are correct (calculated in `boundLiteral`).\\n                assembly (\\\"memory-safe\\\") {\\n                    value := add(value, mul(sub(byte(0, mload(cursor)), digitOffset), exp(10, exponent)))\\n                }\\n                exponent++;\\n                cursor--;\\n            }\\n\\n            // If we didn't consume the entire literal, then we have\\n            // to check if the remaining digit is safe to multiply\\n            // by 10 without overflowing a uint256.\\n            if (cursor >= start) {\\n                {\\n                    uint256 digit;\\n                    assembly (\\\"memory-safe\\\") {\\n                        digit := sub(byte(0, mload(cursor)), digitOffset)\\n                    }\\n                    // If the digit is greater than 1, then we know that\\n                    // multiplying it by 10^77 will overflow a uint256.\\n                    if (digit > 1) {\\n                        revert DecimalLiteralOverflow(LibParse.parseErrorOffset(data, cursor));\\n                    } else {\\n                        uint256 scaled = digit * (10 ** exponent);\\n                        if (value + scaled < value) {\\n                            revert DecimalLiteralOverflow(LibParse.parseErrorOffset(data, cursor));\\n                        }\\n                        value += scaled;\\n                    }\\n                    cursor--;\\n                }\\n\\n                {\\n                    // If we didn't consume the entire literal, then only\\n                    // leading zeros are allowed.\\n                    while (cursor >= start) {\\n                        //slither-disable-next-line similar-names\\n                        uint256 decimalCharByte;\\n                        assembly (\\\"memory-safe\\\") {\\n                            decimalCharByte := byte(0, mload(cursor))\\n                        }\\n                        if (decimalCharByte != uint256(uint8(bytes1(\\\"0\\\")))) {\\n                            revert DecimalLiteralOverflow(LibParse.parseErrorOffset(data, cursor));\\n                        }\\n                        cursor--;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/parse/LibParseOperand.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport {Operand} from \\\"../../interface/unstable/IInterpreterV2.sol\\\";\\nimport {LibParse} from \\\"./LibParse.sol\\\";\\nimport {LibParseLiteral} from \\\"./LibParseLiteral.sol\\\";\\nimport {CMASK_OPERAND_END, CMASK_WHITESPACE, CMASK_OPERAND_START} from \\\"./LibParseCMask.sol\\\";\\n\\nuint8 constant OPERAND_PARSER_OFFSET_DISALLOWED = 0;\\nuint8 constant OPERAND_PARSER_OFFSET_SINGLE_FULL = 0x10;\\nuint8 constant OPERAND_PARSER_OFFSET_DOUBLE_PERBYTE_NO_DEFAULT = 0x20;\\nuint8 constant OPERAND_PARSER_OFFSET_M1_M1 = 0x30;\\nuint8 constant OPERAND_PARSER_OFFSET_8_M1_M1 = 0x40;\\n\\nerror UnexpectedOperand(uint256 offset);\\n\\nerror ExpectedOperand(uint256 offset);\\n\\nerror OperandOverflow(uint256 offset);\\n\\nerror UnclosedOperand(uint256 offset);\\n\\nlibrary LibParseOperand {\\n    function buildOperandParsers() internal pure returns (uint256 operandParsers) {\\n        function(uint256, bytes memory, uint256) pure returns (uint256, Operand) operandParserDisallowed =\\n            LibParseOperand.parseOperandDisallowed;\\n        uint256 parseOperandDisallowedOffset = OPERAND_PARSER_OFFSET_DISALLOWED;\\n        assembly (\\\"memory-safe\\\") {\\n            operandParsers := or(operandParsers, shl(parseOperandDisallowedOffset, operandParserDisallowed))\\n        }\\n        function(uint256, bytes memory, uint256) pure returns (uint256, Operand) operandParserSingleFull =\\n            LibParseOperand.parseOperandSingleFull;\\n        uint256 parseOperandSingleFullOffset = OPERAND_PARSER_OFFSET_SINGLE_FULL;\\n        assembly (\\\"memory-safe\\\") {\\n            operandParsers := or(operandParsers, shl(parseOperandSingleFullOffset, operandParserSingleFull))\\n        }\\n        function(uint256, bytes memory, uint256) pure returns (uint256, Operand) operandParserDoublePerByteNoDefault =\\n            LibParseOperand.parseOperandDoublePerByteNoDefault;\\n        uint256 parseOperandDoublePerByteNoDefaultOffset = OPERAND_PARSER_OFFSET_DOUBLE_PERBYTE_NO_DEFAULT;\\n        assembly (\\\"memory-safe\\\") {\\n            operandParsers :=\\n                or(operandParsers, shl(parseOperandDoublePerByteNoDefaultOffset, operandParserDoublePerByteNoDefault))\\n        }\\n        function(uint256, bytes memory, uint256) pure returns (uint256, Operand) operandParser_m1_m1 =\\n            LibParseOperand.parseOperandM1M1;\\n        uint256 parseOperand_m1_m1Offset = OPERAND_PARSER_OFFSET_M1_M1;\\n        assembly (\\\"memory-safe\\\") {\\n            operandParsers := or(operandParsers, shl(parseOperand_m1_m1Offset, operandParser_m1_m1))\\n        }\\n        function(uint256, bytes memory, uint256) pure returns (uint256, Operand) operandParser_8_m1_m1 =\\n            LibParseOperand.parseOperand8M1M1;\\n        uint256 parseOperand_8_m1_m1Offset = OPERAND_PARSER_OFFSET_8_M1_M1;\\n        assembly (\\\"memory-safe\\\") {\\n            operandParsers := or(operandParsers, shl(parseOperand_8_m1_m1Offset, operandParser_8_m1_m1))\\n        }\\n    }\\n\\n    /// Parse a literal for an operand.\\n    function parseOperandLiteral(uint256 literalParsers, bytes memory data, uint256 max, uint256 cursor)\\n        internal\\n        pure\\n        returns (uint256, uint256)\\n    {\\n        uint256 char;\\n        assembly (\\\"memory-safe\\\") {\\n            //slither-disable-next-line incorrect-shift\\n            char := shl(byte(0, mload(cursor)), 1)\\n        }\\n        if (char == CMASK_OPERAND_END) {\\n            revert ExpectedOperand(LibParse.parseErrorOffset(data, cursor));\\n        }\\n        (\\n            function(bytes memory, uint256, uint256) pure returns (uint256) literalParser,\\n            uint256 innerStart,\\n            uint256 innerEnd,\\n            uint256 outerEnd\\n        ) = LibParseLiteral.boundLiteral(literalParsers, data, cursor);\\n        uint256 value = literalParser(data, innerStart, innerEnd);\\n        if (value > max) {\\n            revert OperandOverflow(LibParse.parseErrorOffset(data, cursor));\\n        }\\n        cursor = outerEnd;\\n        return (cursor, value);\\n    }\\n\\n    /// Operand is disallowed for this word.\\n    function parseOperandDisallowed(uint256, bytes memory data, uint256 cursor)\\n        internal\\n        pure\\n        returns (uint256, Operand)\\n    {\\n        uint256 char;\\n        assembly (\\\"memory-safe\\\") {\\n            //slither-disable-next-line incorrect-shift\\n            char := shl(byte(0, mload(cursor)), 1)\\n        }\\n        if (char == CMASK_OPERAND_START) {\\n            revert UnexpectedOperand(LibParse.parseErrorOffset(data, cursor));\\n        }\\n        // Don't move the cursor. This is a no-op.\\n        return (cursor, Operand.wrap(0));\\n    }\\n\\n    /// Operand is a 16-bit unsigned integer.\\n    function parseOperandSingleFull(uint256 literalParsers, bytes memory data, uint256 cursor)\\n        internal\\n        pure\\n        returns (uint256, Operand)\\n    {\\n        unchecked {\\n            uint256 char;\\n            uint256 end;\\n            assembly (\\\"memory-safe\\\") {\\n                end := add(data, add(mload(data), 0x20))\\n                //slither-disable-next-line incorrect-shift\\n                char := shl(byte(0, mload(cursor)), 1)\\n            }\\n            if (char == CMASK_OPERAND_START) {\\n                cursor = LibParse.skipMask(cursor + 1, end, CMASK_WHITESPACE);\\n\\n                uint256 value;\\n                (cursor, value) = parseOperandLiteral(literalParsers, data, type(uint16).max, cursor);\\n\\n                cursor = LibParse.skipMask(cursor, end, CMASK_WHITESPACE);\\n                assembly (\\\"memory-safe\\\") {\\n                    //slither-disable-next-line incorrect-shift\\n                    char := shl(byte(0, mload(cursor)), 1)\\n                }\\n                if (char != CMASK_OPERAND_END) {\\n                    revert UnclosedOperand(LibParse.parseErrorOffset(data, cursor));\\n                }\\n                return (cursor + 1, Operand.wrap(value));\\n            }\\n            // Default is 0.\\n            else {\\n                return (cursor, Operand.wrap(0));\\n            }\\n        }\\n    }\\n\\n    /// Operand is two bytes.\\n    function parseOperandDoublePerByteNoDefault(uint256 literalParsers, bytes memory data, uint256 cursor)\\n        internal\\n        pure\\n        returns (uint256, Operand)\\n    {\\n        unchecked {\\n            uint256 char;\\n            uint256 end;\\n            assembly (\\\"memory-safe\\\") {\\n                end := add(data, add(mload(data), 0x20))\\n                //slither-disable-next-line incorrect-shift\\n                char := shl(byte(0, mload(cursor)), 1)\\n            }\\n            if (char == CMASK_OPERAND_START) {\\n                cursor = LibParse.skipMask(cursor + 1, end, CMASK_WHITESPACE);\\n\\n                uint256 a;\\n                (cursor, a) = parseOperandLiteral(literalParsers, data, type(uint8).max, cursor);\\n                Operand operand = Operand.wrap(a);\\n\\n                cursor = LibParse.skipMask(cursor, end, CMASK_WHITESPACE);\\n\\n                uint256 b;\\n                (cursor, b) = parseOperandLiteral(literalParsers, data, type(uint8).max, cursor);\\n                operand = Operand.wrap(Operand.unwrap(operand) | (b << 8));\\n\\n                cursor = LibParse.skipMask(cursor, end, CMASK_WHITESPACE);\\n\\n                assembly (\\\"memory-safe\\\") {\\n                    //slither-disable-next-line incorrect-shift\\n                    char := shl(byte(0, mload(cursor)), 1)\\n                }\\n                if (char != CMASK_OPERAND_END) {\\n                    revert UnclosedOperand(LibParse.parseErrorOffset(data, cursor));\\n                }\\n                return (cursor + 1, operand);\\n            }\\n            // There is no default fallback value.\\n            else {\\n                revert ExpectedOperand(LibParse.parseErrorOffset(data, cursor));\\n            }\\n        }\\n    }\\n\\n    /// 8 bit value, maybe 1 bit flag, maybe 1 big flag.\\n    function parseOperand8M1M1(uint256 literalParsers, bytes memory data, uint256 cursor)\\n        internal\\n        pure\\n        returns (uint256, Operand)\\n    {\\n        unchecked {\\n            uint256 char;\\n            uint256 end;\\n            assembly (\\\"memory-safe\\\") {\\n                end := add(data, add(mload(data), 0x20))\\n                //slither-disable-next-line incorrect-shift\\n                char := shl(byte(0, mload(cursor)), 1)\\n            }\\n            if (char == CMASK_OPERAND_START) {\\n                cursor = LibParse.skipMask(cursor + 1, end, CMASK_WHITESPACE);\\n\\n                // 8 bit value. Required.\\n                uint256 a;\\n                (cursor, a) = parseOperandLiteral(literalParsers, data, type(uint8).max, cursor);\\n                cursor = LibParse.skipMask(cursor, end, CMASK_WHITESPACE);\\n\\n                // Maybe 1 bit flag.\\n                uint256 b;\\n                assembly (\\\"memory-safe\\\") {\\n                    //slither-disable-next-line incorrect-shift\\n                    char := shl(byte(0, mload(cursor)), 1)\\n                }\\n                if (char == CMASK_OPERAND_END) {\\n                    b = 0;\\n                } else {\\n                    (cursor, b) = parseOperandLiteral(literalParsers, data, 1, cursor);\\n                    cursor = LibParse.skipMask(cursor, end, CMASK_WHITESPACE);\\n                }\\n\\n                // Maybe 1 bit flag.\\n                uint256 c;\\n                assembly (\\\"memory-safe\\\") {\\n                    //slither-disable-next-line incorrect-shift\\n                    char := shl(byte(0, mload(cursor)), 1)\\n                }\\n                if (char == CMASK_OPERAND_END) {\\n                    c = 0;\\n                } else {\\n                    (cursor, c) = parseOperandLiteral(literalParsers, data, 1, cursor);\\n                    cursor = LibParse.skipMask(cursor, end, CMASK_WHITESPACE);\\n                }\\n\\n                Operand operand = Operand.wrap(a | (b << 8) | (c << 9));\\n\\n                assembly (\\\"memory-safe\\\") {\\n                    //slither-disable-next-line incorrect-shift\\n                    char := shl(byte(0, mload(cursor)), 1)\\n                }\\n                if (char != CMASK_OPERAND_END) {\\n                    revert UnclosedOperand(LibParse.parseErrorOffset(data, cursor));\\n                }\\n                return (cursor + 1, operand);\\n            }\\n            // There is no default fallback value. The first 8 bits are\\n            // required.\\n            else {\\n                revert ExpectedOperand(LibParse.parseErrorOffset(data, cursor));\\n            }\\n        }\\n    }\\n\\n    /// 2x maybe 1 bit flags.\\n    function parseOperandM1M1(uint256 literalParsers, bytes memory data, uint256 cursor)\\n        internal\\n        pure\\n        returns (uint256, Operand)\\n    {\\n        unchecked {\\n            uint256 char;\\n            uint256 end;\\n            assembly (\\\"memory-safe\\\") {\\n                end := add(data, add(mload(data), 0x20))\\n                //slither-disable-next-line incorrect-shift\\n                char := shl(byte(0, mload(cursor)), 1)\\n            }\\n            if (char == CMASK_OPERAND_START) {\\n                cursor = LibParse.skipMask(cursor + 1, end, CMASK_WHITESPACE);\\n\\n                uint256 a;\\n                assembly (\\\"memory-safe\\\") {\\n                    //slither-disable-next-line incorrect-shift\\n                    char := shl(byte(0, mload(cursor)), 1)\\n                }\\n                if (char == CMASK_OPERAND_END) {\\n                    a = 0;\\n                } else {\\n                    (cursor, a) = parseOperandLiteral(literalParsers, data, 1, cursor);\\n                    cursor = LibParse.skipMask(cursor, end, CMASK_WHITESPACE);\\n                }\\n\\n                uint256 b;\\n                assembly (\\\"memory-safe\\\") {\\n                    //slither-disable-next-line incorrect-shift\\n                    char := shl(byte(0, mload(cursor)), 1)\\n                }\\n                if (char == CMASK_OPERAND_END) {\\n                    b = 0;\\n                } else {\\n                    (cursor, b) = parseOperandLiteral(literalParsers, data, 1, cursor);\\n                    cursor = LibParse.skipMask(cursor, end, CMASK_WHITESPACE);\\n                }\\n\\n                Operand operand = Operand.wrap(a | (b << 1));\\n\\n                assembly (\\\"memory-safe\\\") {\\n                    //slither-disable-next-line incorrect-shift\\n                    char := shl(byte(0, mload(cursor)), 1)\\n                }\\n                if (char != CMASK_OPERAND_END) {\\n                    revert UnclosedOperand(LibParse.parseErrorOffset(data, cursor));\\n                }\\n                return (cursor + 1, operand);\\n            }\\n            // Default is 0.\\n            else {\\n                return (cursor, Operand.wrap(0));\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/unstable/IInterpreterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport {EncodedDispatch, StateNamespace, Operand, DEFAULT_STATE_NAMESPACE} from \\\"../deprecated/IInterpreterV1.sol\\\";\\nimport {FullyQualifiedNamespace, IInterpreterStoreV1} from \\\"../IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV2`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndexV2 is uint256;\\n\\n/// @title IInterpreterV2\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produced by an\\n/// `eval2` and passed to the `IInterpreterStoreV1` returned by the eval, as-is\\n/// by the caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval2` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows evaluation to be read-only which\\n/// provides security guarantees for the caller such as no stateful reentrancy,\\n/// either from the interpreter or some contract interface used by some word,\\n/// while still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV2 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV3` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV3` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes calldata);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    ///\\n    /// There are two key differences between `eval` and `eval2`:\\n    /// - `eval` was ambiguous about whether the top value of the final stack is\\n    /// the first or last item of the array. `eval2` is unambiguous in that the\\n    /// top of the stack MUST be the first item in the array.\\n    /// - `eval2` allows the caller to specify inputs to the entrypoint stack of\\n    /// the expression. This allows the `eval` and `offchainDebugEval` functions\\n    /// to be merged into a single function that can be used for both onchain and\\n    /// offchain evaluation. For example, the caller can simulate \\\"internal\\\"\\n    /// calls by specifying the inputs to the entrypoint stack of the expression\\n    /// as the outputs of some other expression. Legacy behaviour can be achieved\\n    /// by passing an empty array for `inputs`.\\n    ///\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// @param inputs The inputs to the entrypoint stack of the expression. MAY\\n    /// be empty if the caller prefers to specify all inputs via. context.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable. MUST be ordered such that the top of the stack is the FIRST\\n    /// item in the array.\\n    /// @return writes A list of values to be processed by a store. Most likely\\n    /// will be pairwise key/value items but this is not strictly required if\\n    /// some store expects some other format.\\n    function eval2(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context,\\n        uint256[] calldata inputs\\n    ) external view returns (uint256[] calldata stack, uint256[] calldata writes);\\n}\\n\"\r\n    },\r\n    \"src/lib/parse/LibParseStackName.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibParse.sol\\\";\\n\\nlibrary LibParseStackName {\\n    /// Push a word onto the stack name stack.\\n    /// @return exists Whether the word already existed.\\n    /// @return index The new index after the word was pushed. Will be unchanged\\n    /// if the word already existed.\\n    function pushStackName(ParseState memory state, bytes32 word) internal pure returns (bool exists, uint256 index) {\\n        unchecked {\\n            (exists, index) = stackNameIndex(state, word);\\n            if (!exists) {\\n                uint256 fingerprint;\\n                uint256 ptr;\\n                uint256 oldStackNames = state.stackNames;\\n                assembly (\\\"memory-safe\\\") {\\n                    ptr := mload(0x40)\\n                    mstore(ptr, word)\\n                    fingerprint := and(keccak256(ptr, 0x20), not(0xFFFFFFFF))\\n                    mstore(ptr, oldStackNames)\\n                    mstore(0x40, add(ptr, 0x20))\\n                }\\n                // Add the start of line height to the LHS line parse count.\\n                uint256 stackLHSIndex = state.topLevel1 & 0xFF;\\n                state.stackNames = fingerprint | (stackLHSIndex << 0x10) | ptr;\\n                index = stackLHSIndex + 1;\\n            }\\n        }\\n    }\\n\\n    /// Retrieve the index of a previously pushed stack name.\\n    function stackNameIndex(ParseState memory state, bytes32 word) internal pure returns (bool exists, uint256 index) {\\n        uint256 fingerprint;\\n        uint256 stackNames = state.stackNames;\\n        uint256 stackNameBloom = state.stackNameBloom;\\n        uint256 bloom;\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, word)\\n            fingerprint := shr(0x20, keccak256(0, 0x20))\\n            //slither-disable-next-line incorrect-shift\\n            bloom := shl(and(fingerprint, 0xFF), 1)\\n\\n            // If the bloom matches then maybe the stack name is in the stack.\\n            if and(bloom, stackNameBloom) {\\n                for { let ptr := and(stackNames, 0xFFFF) } iszero(iszero(ptr)) {\\n                    stackNames := mload(ptr)\\n                    ptr := and(stackNames, 0xFFFF)\\n                } {\\n                    if eq(fingerprint, shr(0x20, stackNames)) {\\n                        exists := true\\n                        index := and(shr(0x10, stackNames), 0xFFFF)\\n                        break\\n                    }\\n                }\\n            }\\n        }\\n        state.stackNameBloom = bloom | stackNameBloom;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/deprecated/IInterpreterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport {IInterpreterStoreV1} from \\\"../IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\"\r\n    },\r\n    \"src/interface/IInterpreterStoreV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport {StateNamespace} from \\\"./deprecated/IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-math/lib/prb-test/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"prb-math/=lib/prb-math/src/\",\r\n      \"prb-test/=lib/prb-math/lib/prb-test/src/\",\r\n      \"rain.chainlink/=lib/rain.chainlink/src/\",\r\n      \"rain.datacontract/=lib/rain.datacontract/src/\",\r\n      \"rain.erc1820/=lib/rain.erc1820/src/\",\r\n      \"rain.lib.hash/=lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\r\n      \"rain.lib.memkv/=lib/rain.lib.memkv/src/\",\r\n      \"rain.lib.typecast/=lib/rain.lib.typecast/src/\",\r\n      \"rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\r\n      \"rain.math.saturating/=lib/rain.math.fixedpoint/lib/rain.math.saturating/src/\",\r\n      \"rain.metadata/=lib/rain.metadata/src/\",\r\n      \"rain.solmem/=lib/rain.solmem/src/\",\r\n      \"sol.lib.binmaskflag/=lib/sol.lib.binmaskflag/src/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"DanglingSource\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"DecimalLiteralOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"errorOffset\",\"type\":\"uint256\"}],\"name\":\"DuplicateLHSItem\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"ExcessLHSItems\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"ExcessRHSItems\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"ExpectedLeftParen\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"ExpectedOperand\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"HexLiteralOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"MalformedCommentStart\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"MalformedExponentDigits\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"MalformedHexLiteral\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSources\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"MissingFinalSemi\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"NotAcceptingInputs\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"OddLengthHexLiteral\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"OperandOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParenOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParserOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StackOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StackUnderflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"UnclosedLeftParen\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"UnclosedOperand\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"UnexpectedComment\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"UnexpectedLHSChar\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"UnexpectedOperand\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"UnexpectedRHSChar\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"UnexpectedRightParen\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"UnknownWord\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"UnsupportedLiteralType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"word\",\"type\":\"string\"}],\"name\":\"WordSize\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"ZeroLengthDecimal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"ZeroLengthHexLiteral\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"parse\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RainterpreterParserNPE2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}