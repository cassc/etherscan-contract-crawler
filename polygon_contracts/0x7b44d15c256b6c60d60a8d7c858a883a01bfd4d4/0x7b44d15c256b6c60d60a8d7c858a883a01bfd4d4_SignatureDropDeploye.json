{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.13;\\n\\ninterface IOwnableEvents {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\\ninterface IOwnable {\\n    function transferOwnership(address nextOwner_) external;\\n\\n    function cancelOwnershipTransfer() external;\\n\\n    function acceptOwnership() external;\\n\\n    function renounceOwnership() external;\\n\\n    function isOwner() external view returns (bool);\\n\\n    function isNextOwner() external view returns (bool);\\n}\\n\\ncontract Ownable is IOwnable, IOwnableEvents {\\n    address public owner;\\n    address private nextOwner;\\n\\n    /// > [[[[[[[[[[[ Modifiers ]]]]]]]]]]]\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /// @notice Initialize contract by setting the initial owner.\\n    constructor(address owner_) {\\n        _setInitialOwner(owner_);\\n    }\\n\\n    /// @notice Initiate ownership transfer by setting nextOwner.\\n    function transferOwnership(address nextOwner_) external override onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /// @notice Cancel ownership transfer by deleting nextOwner.\\n    function cancelOwnershipTransfer() external override onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /// @notice Accepts ownership transfer by setting owner.\\n    function acceptOwnership() external override onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /// @notice Renounce ownership by setting owner to zero address.\\n    function renounceOwnership() external override onlyOwner {\\n        _renounceOwnership();\\n    }\\n\\n    /// @notice Returns true if the caller is the current owner.\\n    function isOwner() public view override returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /// @notice Returns true if the caller is the next owner.\\n    function isNextOwner() public view override returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n\\n    /// > [[[[[[[[[[[ Internal Functions ]]]]]]]]]]]\\n\\n    function _setOwner(address previousOwner, address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnershipTransferred(previousOwner, owner);\\n    }\\n\\n    function _setInitialOwner(address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnershipTransferred(address(0), newOwner);\\n    }\\n\\n    function _renounceOwnership() internal {\\n        emit OwnershipTransferred(owner, address(0));\\n\\n        owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/SignatureDropDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport \\\"openzeppelin-contracts/contracts/proxy/Clones.sol\\\";\\n\\nimport \\\"./Ownable.sol\\\";\\n\\ninterface ITWFactory {\\n    function deployProxyByImplementation(\\n        address _implementation,\\n        bytes memory _data,\\n        bytes32 _salt\\n    ) external returns (address);\\n}\\n\\ninterface ITWTokenERC1155 {\\n    function initialize(\\n        address _defaultAdmin,\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _contractURI,\\n        address[] memory _trustedForwarders,\\n        address _primarySaleRecipient,\\n        address _royaltyRecipient,\\n        uint128 _royaltyBps,\\n        uint128 _platformFeeBps,\\n        address _platformFeeRecipient\\n    ) external;\\n\\n    function mintTo(\\n        address to,\\n        uint256 tokenId,\\n        string calldata uri,\\n        uint256 amount\\n    ) external;\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function setOwner(address _newOwner) external;\\n\\n    function setFlatPlatformFeeInfo(\\n        address _platformFeeRecipient,\\n        uint256 _flatFee\\n    ) external;\\n\\n    enum PlatformFeeType {\\n        Bps,\\n        FLAT\\n    }\\n\\n    function setPlatformFeeType(PlatformFeeType _feeType) external;\\n}\\n\\ninterface ISignatureDropDeployer {\\n    event ProxyDeployed(\\n        address indexed proxyAddress,\\n        address indexed admin,\\n        bytes32 salt\\n    );\\n\\n    event NewMinter(address indexed oldMinter, address indexed newMinter);\\n\\n    struct DeployParams {\\n        address admin;\\n        string _name;\\n        string _symbol;\\n        string _contractURI;\\n        string _uri;\\n        address[] _trustedForwarders;\\n        address _primarySaleRecipient;\\n        address _royaltyRecipient;\\n        uint128 _royaltyBps;\\n        uint256 _platformFee;\\n        address _platformFeeRecipient;\\n        bytes32 salt;\\n    }\\n\\n    function setMinter(address _newMinter) external;\\n\\n    function deploy(DeployParams memory params) external returns (address);\\n\\n    function predictDeterministicAddress(bytes32 _salt)\\n        external\\n        view\\n        returns (address);\\n}\\n\\ncontract SignatureDropDeployer is ISignatureDropDeployer, Ownable {\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    bytes32 public constant TRANSFER_ROLE = keccak256(\\\"TRANSFER_ROLE\\\");\\n\\n    address public immutable TWFactoryAddress;\\n\\n    address public immutable TWEditionImplementationAddress;\\n\\n    address public minter;\\n\\n    constructor(\\n        address _owner,\\n        address _minter,\\n        address _factory,\\n        address _implementation\\n    ) Ownable(_owner) {\\n        _setMinter(_minter);\\n\\n        TWFactoryAddress = _factory;\\n        TWEditionImplementationAddress = _implementation;\\n    }\\n\\n    function setMinter(address _newMinter) public override onlyOwner {\\n        _setMinter(_newMinter);\\n    }\\n\\n    function deploy(DeployParams memory params)\\n        public\\n        override\\n        returns (address)\\n    {\\n        bytes memory callData = abi.encodeWithSelector(\\n            ITWTokenERC1155.initialize.selector,\\n            address(this),\\n            params._name,\\n            params._symbol,\\n            params._contractURI,\\n            params._trustedForwarders,\\n            params._primarySaleRecipient,\\n            params._royaltyRecipient,\\n            params._royaltyBps,\\n            0, // no bps fee for platform\\n            params._platformFeeRecipient\\n        );\\n\\n        // Deploy proxy.\\n        address proxyAddress = _deployProxy(callData, params.salt);\\n\\n        // Mint token to admin.\\n        ITWTokenERC1155(proxyAddress).mintTo(\\n            params.admin,\\n            type(uint256).max,\\n            params._uri,\\n            0\\n        );\\n\\n        // Set fees.\\n        _setFees(\\n            proxyAddress,\\n            params._platformFeeRecipient,\\n            params._platformFee\\n        );\\n\\n        // Set roles.\\n        _setRoles(proxyAddress, params.admin);\\n\\n        emit ProxyDeployed(proxyAddress, params.admin, params.salt);\\n\\n        return proxyAddress;\\n    }\\n\\n    function predictDeterministicAddress(bytes32 _salt)\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        return\\n            Clones.predictDeterministicAddress(\\n                TWEditionImplementationAddress,\\n                keccak256(abi.encodePacked(address(this), _salt)),\\n                TWFactoryAddress\\n            );\\n    }\\n\\n    function _setMinter(address _newMinter) internal {\\n        emit NewMinter(minter, _newMinter);\\n\\n        minter = _newMinter;\\n    }\\n\\n    function _deployProxy(bytes memory callData, bytes32 salt)\\n        internal\\n        returns (address)\\n    {\\n        return\\n            ITWFactory(TWFactoryAddress).deployProxyByImplementation(\\n                TWEditionImplementationAddress,\\n                callData,\\n                salt\\n            );\\n    }\\n\\n    function _setFees(\\n        address proxyAddress,\\n        address _platformFeeRecipient,\\n        uint256 _platformFee\\n    ) internal {\\n        ITWTokenERC1155(proxyAddress).setFlatPlatformFeeInfo(\\n            _platformFeeRecipient,\\n            _platformFee\\n        );\\n        ITWTokenERC1155(proxyAddress).setPlatformFeeType(\\n            ITWTokenERC1155.PlatformFeeType.FLAT\\n        );\\n    }\\n\\n    function _setRoles(address proxyAddress, address admin) internal {\\n        // Grant minter role to Mirror wallet.\\n        ITWTokenERC1155(proxyAddress).grantRole(MINTER_ROLE, minter);\\n\\n        // Set roles for admin.\\n        ITWTokenERC1155(proxyAddress).grantRole(DEFAULT_ADMIN_ROLE, admin);\\n        ITWTokenERC1155(proxyAddress).grantRole(MINTER_ROLE, admin);\\n        ITWTokenERC1155(proxyAddress).grantRole(TRANSFER_ROLE, admin);\\n\\n        // Remove roles for deployer.\\n        ITWTokenERC1155(proxyAddress).revokeRole(MINTER_ROLE, address(this));\\n        ITWTokenERC1155(proxyAddress).revokeRole(TRANSFER_ROLE, address(this));\\n\\n        // Transfer ownership to admin.\\n        ITWTokenERC1155(proxyAddress).setOwner(admin);\\n\\n        ITWTokenERC1155(proxyAddress).revokeRole(\\n            DEFAULT_ADMIN_ROLE,\\n            address(this)\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMinter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"NewMinter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxyAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"ProxyDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TWEditionImplementationAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TWFactoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_contractURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"_trustedForwarders\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_primarySaleRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_royaltyRecipient\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_royaltyBps\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"_platformFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_platformFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"internalType\":\"struct ISignatureDropDeployer.DeployParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"predictDeterministicAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMinter\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SignatureDropDeployer", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d31b7e69a2c2f03d36dc2f5f625647053a180b8b0000000000000000000000005be12d4b22eaa4354b3d6f636df047ab7a2a0af80000000000000000000000005dbc7b840baa9dabcbe9d2492e45d7244b54a2a00000000000000000000000007689577821457845fac43c4181c647897d01b936", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}