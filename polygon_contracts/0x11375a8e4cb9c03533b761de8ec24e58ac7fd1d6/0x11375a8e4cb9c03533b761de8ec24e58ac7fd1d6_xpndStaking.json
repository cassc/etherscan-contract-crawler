{"SourceCode": "// Sources flattened with hardhat v2.7.1 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.4.2\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/access/IAccessControl.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    event RoleAdminChanged(\r\n        bytes32 indexed role,\r\n        bytes32 indexed previousAdminRole,\r\n        bytes32 indexed newAdminRole\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(\r\n        bytes32 indexed role,\r\n        address indexed account,\r\n        address indexed sender\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(\r\n        bytes32 indexed role,\r\n        address indexed account,\r\n        address indexed sender\r\n    );\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/access/AccessControl.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with a standardized message including the required role.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role, _msgSender());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IAccessControl).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `account` is missing `role`.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(uint160(account), 20),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account)\r\n        public\r\n        virtual\r\n        override\r\n        onlyRole(getRoleAdmin(role))\r\n    {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account)\r\n        public\r\n        virtual\r\n        override\r\n        onlyRole(getRoleAdmin(role))\r\n    {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(\r\n            account == _msgSender(),\r\n            \"AccessControl: can only renounce roles for self\"\r\n        );\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     *\r\n     * NOTE: This function is deprecated in favor of {_grantRole}.\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(\r\n                oldAllowance >= value,\r\n                \"SafeERC20: decreased allowance below zero\"\r\n            );\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(\r\n                token,\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    newAllowance\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File contracts/xpndStaking.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\ncontract xpndStaking is Ownable, ReentrancyGuard, AccessControl {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // addReward will add to default reward buckets 0, 1, 2 and 3\r\n    // this is required when a pool is not active\r\n    uint256[4] public defaultRewardBuckets;\r\n\r\n    struct PoolConfig {\r\n        uint32 periodStaking; // staking period in days\r\n        uint256 proportionalRewardShare; // pool reward proportion from all pools\r\n    }\r\n\r\n    // This will be updated in addPool when createPools\r\n    // is called 4 times with values for different pools\r\n    PoolConfig[] public poolTypes;\r\n\r\n    // Info of each pool instance when a new pool is created.\r\n    struct PoolInfo {\r\n        uint8 poolType;\r\n        uint16 poolInstance; // pool id for this instance of the pool type\r\n        uint32 endOfPool; // time when pool ended\r\n        uint32 timeAccepting; // days to accept deposit, defaults to pool duration\r\n        uint32 startOfDeposit; // timestamp when pool started\r\n        uint256 totalStaked; // total tokens staked by all users\r\n        uint256 poolReward; // total rewards collected in the pool.\r\n        mapping(address => uint16[]) poolStakeByAddress; // map user address to stake id array\r\n    }\r\n\r\n    // map pool id to poolInfo.\r\n    mapping(uint16 => PoolInfo) poolById;\r\n    // map stake id to stake info.\r\n    mapping(uint16 => StakeInfo) stakeById;\r\n\r\n    // these lists will store poolInstance Ids for the 4 pool types\r\n    mapping(uint8 => uint16[]) listOfAllPoolIds;\r\n\r\n    // Whenever manager starts a new pool counter will increase\r\n    uint16 public poolInstanceCounter;\r\n    // Whenever a new stake is created counter will increase\r\n    uint16 public stakeIdCounter;\r\n\r\n    // total weightage of all reward pools\r\n    uint256 public totalRewardPercent;\r\n\r\n    //state of staking to confirm it is paused or being\r\n    bool public paused;\r\n\r\n    // Info of each stake\r\n    struct StakeInfo {\r\n        bool settled; // withdraw status, true if stake was withdrawen\r\n        uint16 poolInstance; // pool id where deposit was made\r\n        uint32 depositTime; // time deposit was staked\r\n        uint256 stakeAmount; // amount of tokens staked\r\n    }\r\n\r\n    // Status of pool\r\n    enum PoolStatus {\r\n        NOTSTARTED,\r\n        OPEN,\r\n        CLOSED\r\n    }\r\n\r\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\r\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n\r\n    // value for minutes in a day\r\n    uint32 private MINUTES_IN_DAY;\r\n\r\n    IERC20 public token;\r\n\r\n    mapping(uint16 => uint16[]) stakeIdsByPoolInstance;\r\n    mapping(address => uint16[]) poolInstancesByOwnerAddress;\r\n    mapping(address => uint16[]) stakesIdsByOwnerAddress;\r\n    mapping(string => bytes32) internal Roles;\r\n\r\n    event Stake(\r\n        address indexed user,\r\n        uint256 indexed poolInstance,\r\n        uint256 amount\r\n    );\r\n\r\n    event WithdrawAll(address indexed user, uint256 amount);\r\n\r\n    event PoolStarted(\r\n        uint16 indexed poolInstance,\r\n        uint8 poolType,\r\n        uint32 startOfDeposit\r\n    );\r\n\r\n    event PoolUpdated(uint16 indexed poolInstance, uint32 startOfDeposit);\r\n\r\n    constructor(IERC20 _token) {\r\n        token = _token;\r\n        paused = false;\r\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        _grantRole(MANAGER_ROLE, msg.sender);\r\n        _grantRole(PAUSER_ROLE, msg.sender);\r\n\r\n        MINUTES_IN_DAY = 1440; // 24 * 60 for mainnet, 1 for testnet\r\n\r\n        createPools();\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(paused == false);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Set staking state paused or not\r\n     * @dev Set staking pause state to true or false\r\n     */\r\n    function setPauseState(bool pausedState)\r\n        public\r\n        onlyRole(PAUSER_ROLE)\r\n        returns (bool)\r\n    {\r\n        paused = pausedState;\r\n        return paused;\r\n    }\r\n\r\n    /**\r\n     * @notice Notice if staking is paused or not\r\n     * @dev Create pool instance of specified type\r\n     * @return current state of staking: true or false\r\n     */\r\n    function getStakingPausedState() public view returns (bool) {\r\n        return paused;\r\n    }\r\n\r\n    /**\r\n     * @notice Start staking specific pool\r\n     * @dev Create pool instance of specified type\r\n     * @param _poolType Type of pool, 0, 1, 2, 3\r\n     * @param _timeAccepting Period of time that use can deposit. 0: accept throughout pull duration time\r\n     * @param _startTime Start time of staking\r\n     * @param _initialReward Initial Reward when start staking\r\n     */\r\n    function _startStaking(\r\n        uint8 _poolType,\r\n        uint32 _timeAccepting,\r\n        uint32 _startTime,\r\n        uint256 _initialReward\r\n    ) internal onlyRole(MANAGER_ROLE) notPaused {\r\n        require(_poolType < poolTypes.length, \"Invalid poolInstance\");\r\n\r\n        require(\r\n            _startTime >= block.timestamp,\r\n            \"Staking cannot start before now\"\r\n        );\r\n\r\n        require(\r\n            _startTime <= block.timestamp + 180 * MINUTES_IN_DAY * 60,\r\n            \"Staking cannot start after more than 6 months\"\r\n        );\r\n\r\n        if (_timeAccepting == 0) {\r\n            _timeAccepting = poolTypes[_poolType].periodStaking;\r\n        }\r\n        uint256 poolIDLength = listOfAllPoolIds[_poolType].length;\r\n\r\n        if (_initialReward > 0) {\r\n            token.safeTransferFrom(msg.sender, address(this), _initialReward);\r\n        }\r\n\r\n        if (poolIDLength == 0) {\r\n            createPoolInstance(\r\n                _poolType,\r\n                _timeAccepting,\r\n                _startTime,\r\n                _initialReward\r\n            );\r\n        } else {\r\n            uint16 latestPoolId = listOfAllPoolIds[_poolType][poolIDLength - 1];\r\n            PoolInfo storage latestPool = poolById[latestPoolId];\r\n            // create new pool only if latest pool has not closed\r\n            if (\r\n                (latestPool.startOfDeposit +\r\n                    poolTypes[_poolType].periodStaking *\r\n                    MINUTES_IN_DAY *\r\n                    60) < _startTime\r\n            ) {\r\n                uint256 latestPoolReward = latestPool.poolReward;\r\n\r\n                uint16[] memory stakeIdArray = stakeIdsByPoolInstance[\r\n                    latestPoolId\r\n                ];\r\n                uint256 totalRewardsToTransfer = 0;\r\n                for (uint256 i = 0; i < stakeIdArray.length; i++) {\r\n                    totalRewardsToTransfer += computeRewards(stakeIdArray[i]);\r\n                }\r\n\r\n                uint256 residualRewards = latestPoolReward -\r\n                    totalRewardsToTransfer;\r\n\r\n                createPoolInstance(\r\n                    _poolType,\r\n                    _timeAccepting,\r\n                    _startTime,\r\n                    _initialReward + residualRewards\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Start staking specific pool\r\n     * @dev Create pool instance of specified type\r\n     * @param _poolType Type of pool, 0, 1, 2, 3\r\n     * @param _timeAccepting Period of time that use can deposit. 0: accept throughout pull duration time\r\n     */\r\n    function startStaking(uint8 _poolType, uint32 _timeAccepting)\r\n        public\r\n        onlyRole(MANAGER_ROLE)\r\n        notPaused\r\n    {\r\n        _startStaking(_poolType, _timeAccepting, uint32(block.timestamp), 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Start staking specific pool later\r\n     * @dev Create pool instance of specified type\r\n     * @param _poolType Type of pool, 0, 1, 2, 3\r\n     * @param _startTime Start time of staking\r\n     */\r\n    function startStakingLater(uint8 _poolType, uint32 _startTime)\r\n        public\r\n        onlyRole(MANAGER_ROLE)\r\n        notPaused\r\n    {\r\n        if (_startTime == 0) {\r\n            _startTime = uint32(block.timestamp);\r\n        }\r\n\r\n        require(\r\n            _startTime >= block.timestamp,\r\n            \"Staking cannot start before now\"\r\n        );\r\n        _startStaking(_poolType, 0, _startTime, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Start staking specific pool later with initial reward\r\n     * @dev Create pool instance of specified type\r\n     * @param _poolType Type of pool, 0, 1, 2, 3\r\n     * @param _startTime Start time of staking\r\n     * @param _initialReward Initial Reward when start staking\r\n     */\r\n    function startStakingWithReward(\r\n        uint8 _poolType,\r\n        uint32 _startTime,\r\n        uint256 _initialReward\r\n    ) public onlyRole(MANAGER_ROLE) notPaused {\r\n        if (_startTime == 0) {\r\n            _startTime = uint32(block.timestamp);\r\n        }\r\n        require(_initialReward > 0, \"Initial Reward should not be zero\");\r\n        _startStaking(_poolType, 0, _startTime, _initialReward);\r\n    }\r\n\r\n    /**\r\n     * @notice Start staking all pools(0,1,2 and 3)\r\n     * @dev Create pool a instance for all pool types\r\n     */\r\n    function startStakingAllPools() external onlyRole(MANAGER_ROLE) notPaused {\r\n        for (uint8 poolType = 0; poolType < poolTypes.length; poolType++) {\r\n            _startStaking(poolType, 0, uint32(block.timestamp), 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Start staking list of pools(e.g. 0 and 3)\r\n     * @dev Create pool a instance for all pool types\r\n     */\r\n    function startStakingPools(\r\n        uint8[] memory poolTypeList,\r\n        uint256[] memory initialRewardList\r\n    ) external onlyRole(MANAGER_ROLE) notPaused {\r\n        require(poolTypeList.length <= 4, \"Length of Pool List is invalid.\");\r\n        require(\r\n            poolTypeList.length == initialRewardList.length,\r\n            \"Length of Pool List and Initial Reward List is invalid.\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < poolTypeList.length; i++) {\r\n            uint8 poolType = poolTypeList[i];\r\n            _startStaking(\r\n                poolType,\r\n                0,\r\n                uint32(block.timestamp),\r\n                initialRewardList[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Add reward amount\r\n     * @dev Add reward amount, reward is distributed to all pool types based on reward percent in pool config\r\n     * @param _amount Amount to add reward\r\n     */\r\n    function addRewards(uint256 _amount) external nonReentrant notPaused {\r\n        require(_amount > 0, \"err _amount=0\");\r\n\r\n        token.safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n        for (uint8 poolType = 0; poolType < poolTypes.length; ++poolType) {\r\n            uint256 poolInstanceLength = listOfAllPoolIds[poolType].length;\r\n            if (poolInstanceLength == 0) {\r\n                defaultRewardBuckets[poolType] +=\r\n                    (_amount * poolTypes[poolType].proportionalRewardShare) /\r\n                    totalRewardPercent;\r\n            } else {\r\n                uint16 currentPoolId = listOfAllPoolIds[poolType][\r\n                    poolInstanceLength - 1\r\n                ];\r\n                // check if pool has ended\r\n                if (\r\n                    poolTypes[poolType].periodStaking *\r\n                        MINUTES_IN_DAY *\r\n                        60 +\r\n                        poolById[currentPoolId].startOfDeposit >\r\n                    block.timestamp\r\n                ) {\r\n                    // pool has not ended, reward should be added to current pool\r\n                    poolById[currentPoolId].poolReward +=\r\n                        (_amount *\r\n                            poolTypes[poolType].proportionalRewardShare) /\r\n                        totalRewardPercent;\r\n                } else {\r\n                    // latest poolType pool has ended, reward should be collected in\r\n                    // default bucket and added to the new instance of poolType when it starts\r\n                    defaultRewardBuckets[poolType] +=\r\n                        (_amount *\r\n                            poolTypes[poolType].proportionalRewardShare) /\r\n                        totalRewardPercent;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit tokens to stake in _poolType\r\n     * @dev Create stakeInfo in latest pool instance of the specified pool type\r\n     * @param _poolType Type of pool to stake in(0, 1, 2 or 3)\r\n     * @param _amount Amount to stake\r\n     */\r\n    function stake(uint8 _poolType, uint256 _amount)\r\n        external\r\n        nonReentrant\r\n        notPaused\r\n    {\r\n        require(_poolType < poolTypes.length, \"err _poolType is invalid\");\r\n        require(_amount > 0, \"err _amount=0\");\r\n\r\n        uint16[] memory poolInstances = listOfAllPoolIds[_poolType];\r\n        require(poolInstances.length > 0, \"err no active pool of _poolType\");\r\n\r\n        uint16 latestPoolId = poolInstances[poolInstances.length - 1];\r\n        PoolInfo storage poolInfo = poolById[latestPoolId];\r\n\r\n        require(\r\n            poolInfo.startOfDeposit < block.timestamp,\r\n            \"pool has not started accepting deposit.\"\r\n        );\r\n        require(\r\n            poolInfo.startOfDeposit +\r\n                poolInfo.timeAccepting *\r\n                MINUTES_IN_DAY *\r\n                60 >\r\n                block.timestamp,\r\n            \"pool staking has ended.\"\r\n        );\r\n\r\n        token.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n\r\n        poolInfo.totalStaked += _amount;\r\n\r\n        uint16[] storage stakeIdArray = poolInfo.poolStakeByAddress[msg.sender];\r\n\r\n        stakeIdCounter++;\r\n\r\n        StakeInfo memory stakeInfo = StakeInfo({\r\n            depositTime: uint32(block.timestamp),\r\n            poolInstance: latestPoolId,\r\n            stakeAmount: _amount,\r\n            settled: false\r\n        });\r\n\r\n        // TODO:: Some of these may be redundant after requirements and UI\r\n        // are finalised\r\n        stakeIdArray.push(stakeIdCounter);\r\n        stakeById[stakeIdCounter] = stakeInfo;\r\n        stakeIdsByPoolInstance[latestPoolId].push(stakeIdCounter);\r\n        stakesIdsByOwnerAddress[msg.sender].push(stakeIdCounter);\r\n        poolInstancesByOwnerAddress[msg.sender].push(latestPoolId);\r\n\r\n        emit Stake(msg.sender, _poolType, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all stakes for a user\r\n     * @dev Withdraw all stakes for a user from all pool instances of all pool types\r\n     */\r\n    function withdrawAll() external nonReentrant notPaused {\r\n        uint16[] memory poolInstanceArray = poolInstancesByOwnerAddress[\r\n            msg.sender\r\n        ];\r\n        require(0 < poolInstanceArray.length, \"User never staked.\");\r\n\r\n        uint256 totalToWithdraw = 0;\r\n\r\n        for (uint256 index = 0; index < poolInstanceArray.length; index++) {\r\n            uint16 poolInstance = poolInstanceArray[index];\r\n\r\n            PoolInfo storage poolInfo = poolById[poolInstance];\r\n            PoolConfig memory poolConfig = poolTypes[poolInfo.poolType];\r\n\r\n            if (\r\n                poolInfo.startOfDeposit +\r\n                    poolConfig.periodStaking *\r\n                    MINUTES_IN_DAY *\r\n                    60 >\r\n                block.timestamp\r\n            ) continue;\r\n\r\n            uint16[] storage stakeIdArray = poolInfo.poolStakeByAddress[\r\n                msg.sender\r\n            ];\r\n\r\n            for (uint256 i = 0; i < stakeIdArray.length; i++) {\r\n                uint16 stakeId = stakeIdArray[i];\r\n                totalToWithdraw += computeSettlement(stakeId);\r\n            }\r\n        }\r\n\r\n        token.safeTransfer(msg.sender, totalToWithdraw);\r\n\r\n        emit WithdrawAll(msg.sender, totalToWithdraw);\r\n    }\r\n\r\n    // -- Internal Functions --\r\n\r\n    /**\r\n     * @notice Create 4 types of pool\r\n     * @dev Create 4 types of pool, function is called in contructor.\r\n     */\r\n    function createPools() internal {\r\n        addPool(180, 250);\r\n        addPool(360, 1000);\r\n        addPool(720, 2250);\r\n        addPool(1440, 6500);\r\n    }\r\n\r\n    /**\r\n     * @notice Add pool with staking period and reward percent\r\n     * @dev Add pool config.\r\n     * @param _periodStaking staking period of pool\r\n     * @param _rewardPercent Reward percent of pool\r\n     */\r\n    function addPool(uint32 _periodStaking, uint256 _rewardPercent) internal {\r\n        require(\r\n            _periodStaking <= 1440,\r\n            \"periodStaking must be less than 4 years\"\r\n        );\r\n\r\n        totalRewardPercent = totalRewardPercent + _rewardPercent;\r\n        poolTypes.push(\r\n            PoolConfig({\r\n                periodStaking: _periodStaking,\r\n                proportionalRewardShare: _rewardPercent\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice This will be called by startStaking method after validation\r\n     * @dev Add pool instance info\r\n     * @param _poolType Pool type to add pool instance\r\n     * @param _timeAccepting Accepting time that user can deposit 0 indicates accept throughout pool duration\r\n     * @param _initialReward Initial Reward when start staking\r\n     */\r\n    function createPoolInstance(\r\n        uint8 _poolType,\r\n        uint32 _timeAccepting,\r\n        uint32 _startTime,\r\n        uint256 _initialReward\r\n    ) internal {\r\n        poolInstanceCounter++;\r\n        listOfAllPoolIds[_poolType].push(poolInstanceCounter);\r\n\r\n        // Add all the pool information to pool by Id mapping\r\n        poolById[poolInstanceCounter].poolType = _poolType;\r\n        poolById[poolInstanceCounter].poolInstance = poolInstanceCounter;\r\n        poolById[poolInstanceCounter].startOfDeposit = _startTime;\r\n        poolById[poolInstanceCounter].timeAccepting = _timeAccepting;\r\n        poolById[poolInstanceCounter].totalStaked = 0;\r\n        poolById[poolInstanceCounter].poolReward =\r\n            defaultRewardBuckets[_poolType] +\r\n            _initialReward;\r\n\r\n        poolById[poolInstanceCounter].endOfPool =\r\n            _startTime +\r\n            uint32(poolTypes[_poolType].periodStaking * MINUTES_IN_DAY * 60);\r\n\r\n        emit PoolStarted(poolInstanceCounter, _poolType, _startTime);\r\n    }\r\n\r\n    /**\r\n     * @notice This will be called by startStaking method after validation\r\n     * @dev Add pool instance info\r\n     * @param _poolInstance pool instance\r\n     * @param _startTime Start time of pool\r\n     */\r\n    function updatePoolInstance(uint16 _poolInstance, uint32 _startTime)\r\n        external\r\n        onlyRole(MANAGER_ROLE)\r\n    {\r\n        require(_poolInstance <= poolInstanceCounter, \"Invalid pool instance\");\r\n\r\n        poolById[_poolInstance].startOfDeposit = _startTime;\r\n        poolById[_poolInstance].endOfPool =\r\n            _startTime +\r\n            uint32(\r\n                poolTypes[poolById[_poolInstance].poolType].periodStaking *\r\n                    MINUTES_IN_DAY *\r\n                    60\r\n            );\r\n\r\n        emit PoolUpdated(_poolInstance, _startTime);\r\n    }\r\n\r\n    // -- Informational Functions --\r\n\r\n    /**\r\n     * @notice Get rewards which have not been claimed by stake id\r\n     * @dev Return based on stake info\r\n     * @param _stakeId Stake ID to calculate\r\n     * @return Amount of reward\r\n     */\r\n    function getPendingRewards(uint16 _stakeId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_stakeId <= stakeIdCounter, \"Invalid stakeID\");\r\n        StakeInfo memory stakeInfo = stakeById[_stakeId];\r\n        uint256 rewards;\r\n        if (stakeInfo.settled) {\r\n            rewards = 0;\r\n        } else {\r\n            rewards = computeRewards(_stakeId);\r\n        }\r\n        return rewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Get rewards by stake id\r\n     * @dev Return based on stake info\r\n     * @param _stakeId Stake ID to calculate\r\n     * @return Amount of reward\r\n     */\r\n    function getRewards(uint16 _stakeId) external view returns (uint256) {\r\n        uint256 rewards;\r\n        rewards = computeRewards(_stakeId);\r\n        return rewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Get rewards by stake id\r\n     * @dev Return based on stake info\r\n     * @param _stakeId Stake ID to calculate\r\n     * @return rewards of reward\r\n     */\r\n    function computeRewards(uint16 _stakeId) internal view returns (uint256) {\r\n        require(_stakeId <= stakeIdCounter, \"Invalid stakeID\");\r\n\r\n        StakeInfo memory stakeInfo = stakeById[_stakeId];\r\n        PoolInfo storage poolInfo = poolById[stakeInfo.poolInstance];\r\n        PoolConfig memory poolConfig = poolTypes[poolInfo.poolType];\r\n        uint256 rewards;\r\n\r\n        if (poolInfo.endOfPool == stakeInfo.depositTime) {\r\n            rewards = 0;\r\n        } else {\r\n            rewards =\r\n                (((poolInfo.poolReward * stakeInfo.stakeAmount) /\r\n                    poolInfo.totalStaked) *\r\n                    (poolInfo.endOfPool - stakeInfo.depositTime)) /\r\n                (MINUTES_IN_DAY * 60 * poolConfig.periodStaking);\r\n        }\r\n        return rewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Compute the total amount of tokens the user needs to withdraw\r\n     * @dev Returns withdraw amount. interal function\r\n     * @param stakeId Stake index\r\n     * @return withdrawAmount Total amount of tokens the user needs to withdraw\r\n     */\r\n    function computeSettlement(uint16 stakeId)\r\n        internal\r\n        returns (uint256 withdrawAmount)\r\n    {\r\n        StakeInfo storage stakeInfo = stakeById[stakeId];\r\n        if (stakeInfo.settled) {\r\n            withdrawAmount = 0;\r\n        } else {\r\n            withdrawAmount += stakeInfo.stakeAmount;\r\n            withdrawAmount += computeRewards(stakeId);\r\n            stakeInfo.settled = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get pool instances\r\n     * @dev Returns pool instance ids in a pool\r\n     * @param _poolType Pool type to get pool instances\r\n     * @return Pool Instances in a pool\r\n     */\r\n    function getPoolInstances(uint8 _poolType)\r\n        external\r\n        view\r\n        returns (uint16[] memory)\r\n    {\r\n        require(_poolType < poolTypes.length, \"Invalid pool Type\");\r\n        return listOfAllPoolIds[_poolType];\r\n    }\r\n\r\n    function getPoolInfo(uint16 poolInstance)\r\n        external\r\n        view\r\n        returns (\r\n            uint8 poolType,\r\n            uint256 startOfDeposit,\r\n            uint256 totalStaked,\r\n            uint256 poolReward,\r\n            uint256 endOfDeposit,\r\n            PoolStatus poolStatus\r\n        )\r\n    {\r\n        poolType = poolById[poolInstance].poolType;\r\n        startOfDeposit = poolById[poolInstance].startOfDeposit;\r\n        totalStaked = poolById[poolInstance].totalStaked;\r\n        poolReward = poolById[poolInstance].poolReward;\r\n        endOfDeposit = poolById[poolInstance].endOfPool;\r\n\r\n        poolStatus = block.timestamp < startOfDeposit\r\n            ? PoolStatus.NOTSTARTED\r\n            : block.timestamp < endOfDeposit\r\n            ? PoolStatus.OPEN\r\n            : PoolStatus.CLOSED;\r\n    }\r\n\r\n    /**\r\n     * @notice Get latest pool instances for pool type\r\n     * @dev Returns latest pool instance id for all pool types\r\n     * @return Array of pool instance ids\r\n     */\r\n    function getCurrentPools() external view returns (uint16[] memory) {\r\n        uint16[] memory poolIDs = new uint16[](poolTypes.length);\r\n\r\n        for (uint8 index = 0; index < (uint8)(poolTypes.length); index++) {\r\n            uint256 poolIDLength = listOfAllPoolIds[index].length;\r\n            if (poolIDLength == 0) continue;\r\n            uint16 latestPoolId = listOfAllPoolIds[index][poolIDLength - 1];\r\n            poolIDs[index] = latestPoolId;\r\n        }\r\n\r\n        return poolIDs;\r\n    }\r\n\r\n    /**\r\n     * @notice Get pool config\r\n     * @dev Returns pool config\r\n     * @param _poolType Pool type to get config\r\n     * @return Pool config\r\n     */\r\n    function getPoolConfig(uint8 _poolType)\r\n        external\r\n        view\r\n        returns (PoolConfig memory)\r\n    {\r\n        return poolTypes[_poolType];\r\n    }\r\n\r\n    /**\r\n     * @notice Get stake ids\r\n     * @dev Returns all stake ids for a user\r\n     * @param _owner User address to get stake ids\r\n     * @return Array of stake ids\r\n     */\r\n    function getMyStakes(address _owner)\r\n        external\r\n        view\r\n        returns (uint16[] memory)\r\n    {\r\n        return stakesIdsByOwnerAddress[_owner];\r\n    }\r\n\r\n    /**\r\n     * @notice Get stake information\r\n     * @dev Returns stake info based for stakeById\r\n     * @param _stakeId Stake Id to get stake information\r\n     * @return Stake Info\r\n     */\r\n    function getStakeInfo(uint16 _stakeId)\r\n        external\r\n        view\r\n        returns (StakeInfo memory)\r\n    {\r\n        require(_stakeId <= stakeIdCounter, \"Invalid stake id\");\r\n\r\n        return stakeById[_stakeId];\r\n    }\r\n\r\n    /**\r\n     * @notice Get pool instances\r\n     * @dev Returns pool instances base on listOfAllPoolIds\r\n     * @param _poolType Pool type to get pool instances\r\n     * @return Array of pool instance\r\n     */\r\n    function getAllPoolInstance(uint8 _poolType)\r\n        external\r\n        view\r\n        returns (uint16[] memory)\r\n    {\r\n        require(_poolType < poolTypes.length, \"Invalid pool type\");\r\n\r\n        return listOfAllPoolIds[_poolType];\r\n    }\r\n\r\n    /**\r\n     * @notice Get all stakes in pool instance\r\n     * @dev Returns all stake ids in pool instance refering stakeIdsByPoolInstance\r\n     * @param _poolInstance Pool instance to get stake Ids\r\n     * @return Array of stake ids\r\n     */\r\n    function getAllStakesByPoolInstance(uint16 _poolInstance)\r\n        external\r\n        view\r\n        returns (uint16[] memory)\r\n    {\r\n        require(_poolInstance <= poolInstanceCounter, \"Invalid pool instance\");\r\n\r\n        return stakeIdsByPoolInstance[_poolInstance];\r\n    }\r\n\r\n    /**\r\n     * @notice Get pool length\r\n     * @dev Returns length of pool types\r\n     * @return Pool length\r\n     */\r\n    function poolLength() external view returns (uint256) {\r\n        return poolTypes.length;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"poolInstance\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"poolType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startOfDeposit\",\"type\":\"uint32\"}],\"name\":\"PoolStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"poolInstance\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startOfDeposit\",\"type\":\"uint32\"}],\"name\":\"PoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolInstance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawAll\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"defaultRewardBuckets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_poolType\",\"type\":\"uint8\"}],\"name\":\"getAllPoolInstance\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_poolInstance\",\"type\":\"uint16\"}],\"name\":\"getAllStakesByPoolInstance\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPools\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getMyStakes\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_stakeId\",\"type\":\"uint16\"}],\"name\":\"getPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_poolType\",\"type\":\"uint8\"}],\"name\":\"getPoolConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"periodStaking\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proportionalRewardShare\",\"type\":\"uint256\"}],\"internalType\":\"struct xpndStaking.PoolConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"poolInstance\",\"type\":\"uint16\"}],\"name\":\"getPoolInfo\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"poolType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startOfDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endOfDeposit\",\"type\":\"uint256\"},{\"internalType\":\"enum xpndStaking.PoolStatus\",\"name\":\"poolStatus\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_poolType\",\"type\":\"uint8\"}],\"name\":\"getPoolInstances\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_stakeId\",\"type\":\"uint16\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_stakeId\",\"type\":\"uint16\"}],\"name\":\"getStakeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"settled\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"poolInstance\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"depositTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct xpndStaking.StakeInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakingPausedState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInstanceCounter\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolTypes\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"periodStaking\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proportionalRewardShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"pausedState\",\"type\":\"bool\"}],\"name\":\"setPauseState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_poolType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeIdCounter\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_poolType\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_timeAccepting\",\"type\":\"uint32\"}],\"name\":\"startStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startStakingAllPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_poolType\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_startTime\",\"type\":\"uint32\"}],\"name\":\"startStakingLater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"poolTypeList\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"initialRewardList\",\"type\":\"uint256[]\"}],\"name\":\"startStakingPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_poolType\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"_startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_initialReward\",\"type\":\"uint256\"}],\"name\":\"startStakingWithReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_poolInstance\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"_startTime\",\"type\":\"uint32\"}],\"name\":\"updatePoolInstance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "xpndStaking", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000003f61137bfb86be07394f0fd07a33984020f96d8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://51dd63ae8f0ffc2e4b30a22f08df7abfb315e6ce58138e0cf2adf3363ffb51af"}