{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !Address.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Snapshot.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Arrays.sol\\\";\\nimport \\\"../../../utils/Counters.sol\\\";\\n\\n/**\\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\\n * total supply at the time are recorded for later access.\\n *\\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\\n * In naive implementations it's possible to perform a \\\"double spend\\\" attack by reusing the same balance from different\\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\\n * used to create an efficient ERC20 forking mechanism.\\n *\\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\\n * and the account address.\\n *\\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\\n *\\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\\n * alternative consider {ERC20Votes}.\\n *\\n * ==== Gas Costs\\n *\\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\\n *\\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\\n * transfers will have normal cost until the next snapshot, and so on.\\n */\\n\\nabstract contract ERC20Snapshot is ERC20 {\\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\n\\n    using Arrays for uint256[];\\n    using Counters for Counters.Counter;\\n\\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\\n    // Snapshot struct, but that would impede usage of functions that work on an array.\\n    struct Snapshots {\\n        uint256[] ids;\\n        uint256[] values;\\n    }\\n\\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\\n    Snapshots private _totalSupplySnapshots;\\n\\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\\n    Counters.Counter private _currentSnapshotId;\\n\\n    /**\\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\\n     */\\n    event Snapshot(uint256 id);\\n\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\\n     *\\n     * [WARNING]\\n     * ====\\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\\n     * you must consider that it can potentially be used by attackers in two ways.\\n     *\\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\\n     * section above.\\n     *\\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\\n     * ====\\n     */\\n    function _snapshot() internal virtual returns (uint256) {\\n        _currentSnapshotId.increment();\\n\\n        uint256 currentId = _getCurrentSnapshotId();\\n        emit Snapshot(currentId);\\n        return currentId;\\n    }\\n\\n    /**\\n     * @dev Get the current snapshotId\\n     */\\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\\n        return _currentSnapshotId.current();\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\\n     */\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n        return snapshotted ? value : balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\\n     */\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n        return snapshotted ? value : totalSupply();\\n    }\\n\\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (from == address(0)) {\\n            // mint\\n            _updateAccountSnapshot(to);\\n            _updateTotalSupplySnapshot();\\n        } else if (to == address(0)) {\\n            // burn\\n            _updateAccountSnapshot(from);\\n            _updateTotalSupplySnapshot();\\n        } else {\\n            // transfer\\n            _updateAccountSnapshot(from);\\n            _updateAccountSnapshot(to);\\n        }\\n    }\\n\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\\n        require(snapshotId > 0, \\\"ERC20Snapshot: id is 0\\\");\\n        require(snapshotId <= _getCurrentSnapshotId(), \\\"ERC20Snapshot: nonexistent id\\\");\\n\\n        // When a valid snapshot is queried, there are three possibilities:\\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\\n        //  to this id is the current one.\\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\\n        //  requested id, and its value is the one to return.\\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\\n        //  larger than the requested one.\\n        //\\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\\n        // exactly this.\\n\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n        if (index == snapshots.ids.length) {\\n            return (false, 0);\\n        } else {\\n            return (true, snapshots.values[index]);\\n        }\\n    }\\n\\n    function _updateAccountSnapshot(address account) private {\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n    }\\n\\n    function _updateTotalSupplySnapshot() private {\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n    }\\n\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\n        uint256 currentId = _getCurrentSnapshotId();\\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\\n            snapshots.ids.push(currentId);\\n            snapshots.values.push(currentValue);\\n        }\\n    }\\n\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\n        if (ids.length == 0) {\\n            return 0;\\n        } else {\\n            return ids[ids.length - 1];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/AssetTreasury.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\r\\nimport \\\"./BruPool.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Asset Treasury contract\\r\\n * @author Bru-finance team\\r\\n * @dev This contract is used to mint the Assets as NFT.\\r\\n */\\r\\ncontract AssetTreasury is ERC1155 {\\r\\n    uint256 internal tokenId;\\r\\n    address internal poolAddress;\\r\\n    address internal adminAddress;\\r\\n    /**\\r\\n     * @notice mint wallet address which only has access to mint nfts\\r\\n     */\\r\\n    address public mintWalletAddress;\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted after changeMintWalletAddress function executed successfully\\r\\n     * @param _newAddress The new mint wallet address\\r\\n     */\\r\\n    event MintWalletChanged(address _newAddress);\\r\\n\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == adminAddress, \\\"Can be used only by admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev functions marked with this modifier can only be called by mint wallet address\\r\\n     */\\r\\n    modifier onlyMintWalletAddress() {\\r\\n        require(msg.sender == mintWalletAddress, \\\"Can be used only by mint wallet address\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the poolAddress, mintWalletAddress and adminAddress\\r\\n     * @param _poolAddress The address of the pool\\r\\n     * @param _mintWalletAddress The address which is allowed to mint NFTs in the contract\\r\\n     * @param _adminAddress The address of the admin\\r\\n     */\\r\\n    constructor(address _poolAddress, address _mintWalletAddress, address _adminAddress) ERC1155(\\\"\\\") {\\r\\n        require(\\r\\n            _poolAddress != address(0) && _mintWalletAddress != address(0) && _adminAddress != address(0),\\r\\n            \\\"zero address not allowed\\\"\\r\\n        );\\r\\n        adminAddress = _adminAddress;\\r\\n        poolAddress = _poolAddress;\\r\\n        mintWalletAddress = _mintWalletAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add a commodities as NFT on the blockchain.\\r\\n     * @dev Mint the nft and stores the data's in the BruPool nft mapping.\\r\\n     * @param _userAddress The account address of the a commodity owner.\\r\\n     * @param _nftId The unique Id of the particular NFT\\r\\n     * @param _commodityId The Id of the commodity.\\r\\n     * @param _quantity The amount of the commodity\\r\\n     * @param _value The value of the commodity.\\r\\n     * @param _dataHash The hash encrypted by sha256 which has all the data of nft.\\r\\n     * @param _data The original data of nft which combines its price and quantity and other details.\\r\\n     */\\r\\n    // function mintNft(\\r\\n    //     address _userAddress,\\r\\n    //     string memory _nftId,\\r\\n    //     string memory _commodityId,\\r\\n    //     uint256 _quantity,\\r\\n    //     uint256 _value,\\r\\n    //     string memory _dataHash,\\r\\n    //     string memory _data\\r\\n    // ) external onlyMintWalletAddress {\\r\\n    //     tokenId++;\\r\\n    //     _mint(_userAddress, tokenId, _quantity, bytes(_data));\\r\\n    //     BruPool(poolAddress).mintNft(tokenId, _nftId, _commodityId, _quantity, _value, _dataHash, _data);\\r\\n    // }\\r\\n    function mintNft(\\r\\n        address _userAddress,\\r\\n        string memory _nftId,\\r\\n        string memory _commodityId,\\r\\n        uint256 _quantity,\\r\\n        uint256 _value,\\r\\n        string memory _dataHash,\\r\\n        string memory _data\\r\\n    ) external onlyMintWalletAddress {\\r\\n        tokenId++;\\r\\n        _mint(_userAddress, tokenId, _quantity, bytes(_data));\\r\\n        BruPool(poolAddress).mintNft(tokenId, _nftId, _commodityId, _quantity, _value, _dataHash, _data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Changes The mintWallet address\\r\\n     * @param _newAddress The new address of mintWallet\\r\\n     *\\r\\n     */\\r\\n    function changeMintWalletAddress(address _newAddress) external onlyAdmin {\\r\\n        require(_newAddress != address(0), \\\"invalid address\\\");\\r\\n        mintWalletAddress = _newAddress;\\r\\n        emit MintWalletChanged(_newAddress);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BruAdmin.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"./../vesting/Token.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title BruAdmin contract\\r\\n * @author Bru-finance team\\r\\n * @dev This contract is used to access admin level functionalities in the pool.\\r\\n */\\r\\ncontract BruAdmin {\\r\\n    //value of pool Rewards APY\\r\\n    uint256 internal poolRewardAPY;\\r\\n\\r\\n    // determines the lending rate\\r\\n    uint256 public spread;\\r\\n\\r\\n    uint256 public lockPeriod; // lock period for deposited funds\\r\\n\\r\\n    uint256 internal maxFeeRate; // Maxium fees charged by platform\\r\\n\\r\\n    uint256 public maxAllowedTokenAddresses; // maximum number of allowed tokens\\r\\n    /**\\r\\n     * @notice Admin address\\r\\n     */\\r\\n    address public admin;\\r\\n    /**\\r\\n     * @notice owner address which can trigger owner only functions\\r\\n     */\\r\\n    address internal owner;\\r\\n\\r\\n    //address of bruRewards Contract\\r\\n    address internal bruRewardsAddress;\\r\\n\\r\\n    //address of bruPrice Contract\\r\\n    address internal bruPriceAddress;\\r\\n\\r\\n    // address of router contract;\\r\\n    address internal routerAddress;\\r\\n\\r\\n    //address of treasury Contract\\r\\n    address internal treasuryAddress;\\r\\n\\r\\n    //indicates if asset/NFT is available for borrowing\\r\\n    mapping(string => bool) public assetLocked;\\r\\n\\r\\n    /**\\r\\n     * @notice Array of tokens which can be used in this pool\\r\\n     */\\r\\n    address[] public tokenAddresses;\\r\\n    bool public corePause; // it is used for pause functionality in the pool contracts\\r\\n\\r\\n    Rates public rates; // interest rates for borrow and lend for the pool.\\r\\n\\r\\n    PlatformFees public platformFees; // platform fees for borrow and lend functionality\\r\\n    //Pool Limits\\r\\n    struct Rates {\\r\\n        uint256 borrow;\\r\\n        uint256 lend;\\r\\n    }\\r\\n\\r\\n    //Platform Fees\\r\\n    struct PlatformFees {\\r\\n        uint256 borrow;\\r\\n        uint256 lend;\\r\\n    }\\r\\n\\r\\n    /// @notice Mapping for maintaing addresses of stablecoins allowed by the admin\\r\\n    mapping(address => bool) public allowedTokenAddresses;\\r\\n\\r\\n    /// @notice a mapping that stores the index of the _tokenAddress in tokenAddresses array\\r\\n    mapping(address => uint256) internal tokenAddressIndex;\\r\\n\\r\\n    /**\\r\\n     * @notice emitted during spread change action.\\r\\n     * @param _spread the new spread value in the pool\\r\\n     */\\r\\n    event SpreadChanged(uint256 _spread);\\r\\n\\r\\n    /**\\r\\n     * @notice emitted during change lock period action in the pool.\\r\\n     * @param _lockPeriod the new lock period for deposits in the pool\\r\\n     */\\r\\n    event LockPeriodChanged(uint256 _lockPeriod);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when new token address added to the pool\\r\\n     * @param _tokenAddress The address of the newly added token\\r\\n     */\\r\\n    event TokenAddressAllowed(address _tokenAddress);\\r\\n\\r\\n    /**\\r\\n     * @notice Emited when allowed token address removed from the contract\\r\\n     * @param _tokenAddress The address of the removed token\\r\\n     */\\r\\n    event TokenAddressDisabled(address _tokenAddress);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when pool borrow interest rate changed_\\r\\n     * @param _rate The number of newly changed_ pool borrow interest rate\\r\\n     */\\r\\n    event BorrowRateChanged(uint256 _rate);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when borrow platform fee changed_\\r\\n     * @param _fee The number of newly changed platform fee\\r\\n     */\\r\\n    event BorrowPlatformFeeChanged(uint256 _fee);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when max allowed addresses changed_\\r\\n     * @param _maxAllowedAddresses The number of max addresses allowed\\r\\n     */\\r\\n    event MaxAddressesAllowedChanged(uint256 _maxAllowedAddresses);\\r\\n    /**\\r\\n     * @notice Emitted when lending platform fee changed\\r\\n     * @param _fee The number of newly changed platform fee\\r\\n     */\\r\\n    event LendPlatformFeeChanged(uint256 _fee);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when rewardAPY increased\\r\\n     * @param _apy The amount of the increased APY\\r\\n     */\\r\\n    event PoolRewardsStarted(uint256 _apy);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted after pool reward stopped\\r\\n     */\\r\\n    event PoolRewardsStopped();\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when the status of the pool changed\\r\\n     * @param _status the newly changed status\\r\\n     */\\r\\n    event CoreFunctionalityAvailabilityStatus(bool _status);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when NFT is locked\\r\\n     * @param _nftId the ID of the NFT\\r\\n     */\\r\\n    event AssetLocked(string _nftId);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when NFT is unlocked\\r\\n     * @param _nftId the ID of the NFT\\r\\n     */\\r\\n    event AssetUnlocked(string _nftId);\\r\\n\\r\\n    /**\\r\\n     * @dev Checks the availability of the core functionality in the pool\\r\\n     */\\r\\n    modifier checkCorePauseStatus() {\\r\\n        require(!corePause, \\\"Core functionalities disabled\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Only Asset treasury contract can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyAssetTreasury() {\\r\\n        require(treasuryAddress == msg.sender, \\\"only treasury allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to check the accessibility and only allows the admin to access the functions.\\r\\n     */\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        _onlyAdmin();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to check the accessibility and only allows the router to access the functions.\\r\\n     */\\r\\n    modifier onlyRouter() {\\r\\n        _onlyRouter();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to check the new fee value is less than a max value.\\r\\n     * @param _fee new fee value\\r\\n     */\\r\\n    modifier checkFeeValue(uint256 _fee) {\\r\\n        _checkFeeValue(_fee);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to check the accessibility and only allows the owner to access the functions.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"only owner is authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gives a list of token addresses which are supported by the pool\\r\\n     * @return array of addresses with list of token addresses supported by the pool\\r\\n     */\\r\\n    function getAllowedTokenAddressesArray() public view virtual returns (address[] memory) {\\r\\n        return tokenAddresses;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to add a new token address which can be used in the pool\\r\\n     * @param _tokenAddress the new token address which can be used in the pool\\r\\n     */\\r\\n    function allowTokenAddress(address _tokenAddress) external virtual onlyAdmin {\\r\\n        require(_tokenAddress != address(0), \\\"Invalid Address\\\");\\r\\n        require(tokenAddresses.length + 1 < maxAllowedTokenAddresses, \\\"Max limit reached\\\");\\r\\n        require(!allowedTokenAddresses[_tokenAddress], \\\"Already allowed by admin\\\");\\r\\n        allowedTokenAddresses[_tokenAddress] = true;\\r\\n        tokenAddresses.push(_tokenAddress);\\r\\n        tokenAddressIndex[_tokenAddress] = tokenAddresses.length;\\r\\n        emit TokenAddressAllowed(_tokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Disables specified token for use in the pool.\\r\\n     * @param _tokenAddress the new token address which is removed from the pool\\r\\n     */\\r\\n    function removeTokenAddress(address _tokenAddress) external virtual onlyAdmin {\\r\\n        require(allowedTokenAddresses[_tokenAddress], \\\"Not allowed by the admin\\\");\\r\\n        allowedTokenAddresses[_tokenAddress] = false;\\r\\n\\r\\n        uint256 index = tokenAddressIndex[_tokenAddress];\\r\\n        tokenAddresses[index - 1] = tokenAddresses[tokenAddresses.length - 1];\\r\\n        tokenAddressIndex[tokenAddresses[tokenAddresses.length - 1]] = index;\\r\\n        delete tokenAddressIndex[_tokenAddress];\\r\\n        tokenAddresses.pop();\\r\\n        emit TokenAddressDisabled(_tokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice changes the borrow interest rate in the pool\\r\\n     * @param _interestRate the new borrow interest rate\\r\\n     */\\r\\n    function changeBorrowInterestRate(uint256 _interestRate) external virtual onlyAdmin checkFeeValue(_interestRate) {\\r\\n        rates.borrow = (_interestRate * (10**18)) / (10000);\\r\\n        emit BorrowRateChanged(_interestRate);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice changes the borrowing platform fees in the pool\\r\\n     * @param _fee the new borrowing platform fees\\r\\n     */\\r\\n    function changeBorrowPlatformFee(uint256 _fee) external virtual onlyAdmin checkFeeValue(_fee) {\\r\\n        platformFees.borrow = (_fee * (10**18)) / (10000);\\r\\n        emit BorrowPlatformFeeChanged(_fee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice changes the max allowed addresses for a pool\\r\\n     * @param _maxValue new max value allowed address\\r\\n     */\\r\\n    function changeMaxAddresses(uint256 _maxValue) external virtual onlyAdmin {\\r\\n        maxAllowedTokenAddresses = _maxValue;\\r\\n        emit MaxAddressesAllowedChanged(_maxValue);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice changes the lending platform fees in the pool\\r\\n     * @param _fee the new lending platform fees\\r\\n     */\\r\\n    function changeLendPlatformFee(uint256 _fee) external virtual onlyAdmin checkFeeValue(_fee) {\\r\\n        platformFees.lend = _fee * 10000;\\r\\n        emit LendPlatformFeeChanged(_fee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice changes the time for which the deposits in the pool are locked\\r\\n     * @param _time the time for which deposits are locked\\r\\n     */\\r\\n    function changeLockPeriod(uint256 _time) external virtual onlyAdmin {\\r\\n        require(_time > 0, \\\"time should be greater than zero\\\");\\r\\n        lockPeriod = _time;\\r\\n        emit LockPeriodChanged(_time);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice changes the spread which affects the lending rates in the pool\\r\\n     * @param _spread the value which affects the lending rate in the pool\\r\\n     */\\r\\n\\r\\n    function changeSpread(uint256 _spread) external virtual onlyAdmin {\\r\\n        spread = _spread;\\r\\n        rates.lend = rates.borrow - spread;\\r\\n        emit SpreadChanged(spread);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice used to enable / disable core functionalities like borrow ,repay , deposit , withdraw\\r\\n     */\\r\\n    function changeCoreFunctionalityStatus() external virtual onlyAdmin {\\r\\n        corePause = !corePause;\\r\\n        emit CoreFunctionalityAvailabilityStatus(corePause);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice used by rewards contract to increase rates during rewards period\\r\\n     * @param _rewardAPY The of value of new rewardAPY that increases the rates in the pool by this variable\\r\\n     */\\r\\n    function startRewards(uint256 _rewardAPY) external virtual {\\r\\n        checkRewardsAddress();\\r\\n        rates.lend += _rewardAPY;\\r\\n        rates.borrow -= _rewardAPY;\\r\\n        poolRewardAPY = _rewardAPY;\\r\\n        emit PoolRewardsStarted(_rewardAPY);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice used by rewards contract to reset pool rates after rewards period is completed\\r\\n     */\\r\\n    function stopRewards() external virtual {\\r\\n        checkRewardsAddress();\\r\\n        rates.lend -= poolRewardAPY;\\r\\n        rates.borrow += poolRewardAPY;\\r\\n        poolRewardAPY = 0;\\r\\n        emit PoolRewardsStopped();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to check the that the given call is done by admin.\\r\\n     */\\r\\n    function _onlyAdmin() internal view virtual {\\r\\n        require(msg.sender == admin, \\\"Can be used only by admin\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to check the that the given call is done by router.\\r\\n     */\\r\\n    function _onlyRouter() internal view {\\r\\n        require(routerAddress == msg.sender, \\\"only router contract can accesss this\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to check the new fee value is less than max_fee_rates.\\r\\n     * @param _fee new fee value\\r\\n     */\\r\\n    function _checkFeeValue(uint256 _fee) internal view {\\r\\n        require(_fee <= maxFeeRate, \\\"fee should be less than max fees\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to check the accessibility and only allows the Bru rewards contract to access the functions\\r\\n     */\\r\\n    function checkRewardsAddress() internal view virtual {\\r\\n        require(bruRewardsAddress == msg.sender, \\\"only rewards contract can access\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BruFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\r\\n\\r\\nstruct PoolDetails {\\r\\n    string poolName;\\r\\n    address poolTokenAddress;\\r\\n    address interestTokenAddress;\\r\\n    address proxyPoolAddress;\\r\\n    address implementationPoolAddress;\\r\\n    address treasuryAddress;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Bru Factory contract\\r\\n * @author Bru-finance team\\r\\n * @notice Used for storage and retrieval of addresses of Brufinance pools.\\r\\n **/\\r\\ncontract BruFactory is Initializable, UUPSUpgradeable {\\r\\n    // @dev the address of bru token.\\r\\n    address public bruTokenAddress;\\r\\n    address internal admin; //The address of multisig wallet\\r\\n    PoolDetails[] internal poolDetails; //the array which contains the details of pools in the Bru Ecosystem\\r\\n    uint256 public maxPool; //maximum number of allowed pools\\r\\n    /**\\r\\n     * @notice Emitted when the pool is successfully deployed.\\r\\n     * @param _poolName The name of the pool\\r\\n     * @param _poolTokenAddress The address of the pool token\\r\\n     * @param _interestTokenAddress The address of the interest token\\r\\n     * @param _proxyPoolAddress The address of proxy pool\\r\\n     * @param _implementationAddress The address of the pool implementation contract\\r\\n     * @param _treasuryAddress The address of treasury contract\\r\\n     */\\r\\n    event PoolDeployed(\\r\\n        string _poolName,\\r\\n        address _poolTokenAddress,\\r\\n        address _interestTokenAddress,\\r\\n        address _proxyPoolAddress,\\r\\n        address _implementationAddress,\\r\\n        address _treasuryAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when max pool changed_\\r\\n     * @param  _maxPool The number of max pool allowed\\r\\n     */\\r\\n    event MaxPoolChanged(uint256 _maxPool);\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"Can be used only by admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the required addresses needed for the functioning of this contract\\r\\n     * @param _multiSigAddress The address of multisig wallet\\r\\n     * @param _bruTokenAddress Address of the Bru token\\r\\n     **/\\r\\n    function initialize(address _multiSigAddress, address _bruTokenAddress) external virtual initializer {\\r\\n        require(_multiSigAddress != address(0) && _bruTokenAddress != address(0), \\\"zero address not allowed\\\");\\r\\n        admin = _multiSigAddress;\\r\\n        bruTokenAddress = _bruTokenAddress;\\r\\n        maxPool = 99;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Stores addreses related to the pool in the  poolDetails array\\r\\n     * @dev only called by the admin\\r\\n     * @param _poolName The name of the pool\\r\\n     * @param _proxyPoolAddress The address of proxy pool\\r\\n     * @param _implementationAddress TThe address of the pool implementation contract\\r\\n     * @param _poolTokenAddress The address of the pool token\\r\\n     * @param _interestTokenAddress The address of the interest token\\r\\n     * @param _treasuryAddress The address of treasury contract\\r\\n     */\\r\\n    function addPoolDetails(\\r\\n        string memory _poolName,\\r\\n        address _proxyPoolAddress,\\r\\n        address _implementationAddress,\\r\\n        address _poolTokenAddress,\\r\\n        address _interestTokenAddress,\\r\\n        address _treasuryAddress\\r\\n    ) external onlyAdmin {\\r\\n        require(\\r\\n            _proxyPoolAddress != address(0) &&\\r\\n                _implementationAddress != address(0) &&\\r\\n                _poolTokenAddress != address(0) &&\\r\\n                _interestTokenAddress != address(0) &&\\r\\n                _treasuryAddress != address(0),\\r\\n            \\\"incorrect address\\\"\\r\\n        );\\r\\n        require(poolDetails.length + 1 < maxPool, \\\"Max pool limit reached\\\");\\r\\n        poolDetails.push(\\r\\n            PoolDetails(\\r\\n                _poolName,\\r\\n                _poolTokenAddress,\\r\\n                _interestTokenAddress,\\r\\n                _proxyPoolAddress,\\r\\n                _implementationAddress,\\r\\n                _treasuryAddress\\r\\n            )\\r\\n        );\\r\\n        emit PoolDeployed(\\r\\n            _poolName,\\r\\n            _poolTokenAddress,\\r\\n            _interestTokenAddress,\\r\\n            _proxyPoolAddress,\\r\\n            _implementationAddress,\\r\\n            _treasuryAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice changes the max allowed addresses for a pool\\r\\n     * @param _maxValue new max value of allowed pools\\r\\n     */\\r\\n    function changeMaxPool(uint256 _maxValue) external virtual onlyAdmin {\\r\\n        maxPool = _maxValue;\\r\\n        emit MaxPoolChanged(_maxValue);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to get the pool address by using poolIndex as a param\\r\\n     * @param _poolIndex the index of the pool\\r\\n     * @return The address of pool assocatied with pool index\\r\\n     */\\r\\n    function getPoolAddress(uint256 _poolIndex) external view virtual returns (address) {\\r\\n        require(_poolIndex <= poolDetails.length - 1, \\\"Pool does not exist\\\");\\r\\n        return poolDetails[_poolIndex].proxyPoolAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to get pool details by using poolIndex as param\\r\\n     * @param _poolIndex the index of the pool\\r\\n     * @return The details of a pool associated with the pool index.\\r\\n     */\\r\\n    function getPoolDetails(uint256 _poolIndex) external view virtual returns (PoolDetails memory) {\\r\\n        return poolDetails[_poolIndex];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to get all pools related addresses\\r\\n     * @return Array of all pools related addresses\\r\\n     */\\r\\n    function getAllPoolDetails() external view virtual returns (PoolDetails[] memory) {\\r\\n        return poolDetails;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks the wallet address which initiates the upgrade transaction for BruFactory contract\\r\\n     * @param _newImplementation Address of the new implementation contract which is used for upgradation.\\r\\n     */\\r\\n    function _authorizeUpgrade(address _newImplementation) internal view override onlyAdmin {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BruOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Bru Oracle contract\\r\\n * @author Bru-finance team\\r\\n * @notice This is used to get price of Bru Token\\r\\n **/\\r\\ncontract BruOracle is Initializable, UUPSUpgradeable {\\r\\n    address internal adminAddress; // The address of multisig wallet\\r\\n    uint256 internal bruTokenPrice; // The price of Bru token\\r\\n\\r\\n    /**\\r\\n     * @notice Mapping that store pricefeed address for tokens\\r\\n     */\\r\\n    mapping(address => address) public priceFeeds;\\r\\n    /**\\r\\n     * @notice Emitted during set rewardAPY action\\r\\n     * @param _bruTokenPrice The updated bru token price\\r\\n     **/\\r\\n    event BruTokenPriceChanged(uint256 _bruTokenPrice);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when pricefeed set for a token\\r\\n     * @param _tokenAddress The address of token address to fetch price from oracle\\r\\n     * @param _oracleAddress The address of oracle contract for given token address\\r\\n     **/\\r\\n    event TokenOracleChanged(address _tokenAddress, address _oracleAddress);\\r\\n\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     **/\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == adminAddress, \\\"Can be used only by admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the required addresses needed for the functioning of this contract\\r\\n     * @param _adminAddress The address of multisig wallet\\r\\n     **/\\r\\n    function initialize(address _adminAddress) external initializer {\\r\\n        require(_adminAddress != address(0), \\\"zero address not allowed\\\");\\r\\n        adminAddress = _adminAddress;\\r\\n        bruTokenPrice = 1000000000000000000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice function to set the oracle contaract for particular token\\r\\n     * @param _tokenAddress The address of token address to fetch price from oracle\\r\\n     * @param _priceFeed The address of oracle contract for given token address\\r\\n     **/\\r\\n    function setPriceFeedForToken(address _tokenAddress, address _priceFeed) external virtual onlyAdmin {\\r\\n        priceFeeds[_tokenAddress] = _priceFeed;\\r\\n        emit TokenOracleChanged(_tokenAddress, _priceFeed);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice function to get the value of given token address in USD\\r\\n     * @param _tokenAddress The address of token address to fetch price from oracle\\r\\n     * @return returns price of Token/USD\\r\\n     **/\\r\\n    function getLatestPriceOfTokenInUSD(address _tokenAddress) public view returns (uint256) {\\r\\n        int256 answer;\\r\\n        (, answer, , , ) = AggregatorV2V3Interface(priceFeeds[_tokenAddress]).latestRoundData();\\r\\n        return uint256(answer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice function to get the decimal point of price feed for given token address\\r\\n     * @param _tokenAddress The address of token address to fetch decimal of price feed from oracle\\r\\n     * @return returns decimal of price feed\\r\\n     **/\\r\\n    function getPriceFeedDecimal(address _tokenAddress) public view returns (uint256) {\\r\\n        uint8 decimals = AggregatorV2V3Interface(priceFeeds[_tokenAddress]).decimals();\\r\\n        return uint256(decimals);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the price of the Bru token\\r\\n     * @dev Only called by the admin\\r\\n     * @param _bruTokenPrice The bru token price value\\r\\n     **/\\r\\n    function setBruTokenPrice(uint256 _bruTokenPrice) external virtual onlyAdmin {\\r\\n        bruTokenPrice = _bruTokenPrice;\\r\\n        emit BruTokenPriceChanged(bruTokenPrice);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to get the price of the Bru token\\r\\n     * @return The current price of the Bru token\\r\\n     **/\\r\\n    function getBruTokenPrice() external view virtual returns (uint256) {\\r\\n        return bruTokenPrice;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks the wallet address which initiates the upgrade transaction for the BruOracle contract\\r\\n     * @param _newImplementation Address of the new implementation contract which is used for upgradation.\\r\\n     **/\\r\\n    function _authorizeUpgrade(address _newImplementation) internal view override onlyAdmin {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BruPool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"../tokens/PoolToken.sol\\\";\\r\\nimport \\\"../tokens/InterestToken.sol\\\";\\r\\nimport \\\"../wallets/NIIMargin.sol\\\";\\r\\nimport \\\"./BruAdmin.sol\\\";\\r\\nimport \\\"./BruRewards.sol\\\";\\r\\nimport \\\"./AssetTreasury.sol\\\";\\r\\nimport \\\"./BruPrice.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Bru Pool contract\\r\\n * @author Bru-finance team\\r\\n * @notice Is a contract that is responsible for the main functionality of the platform\\r\\n */\\r\\ncontract BruPool is BruAdmin, Initializable, ReentrancyGuard, UUPSUpgradeable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    /**\\r\\n     * @notice name of the pool\\r\\n     */\\r\\n    string public name;\\r\\n\\r\\n    uint256 internal poolIndex;\\r\\n\\r\\n    //for handling ID of btoken and nft\\r\\n    //important addresses\\r\\n    address internal poolTokenAddress; // The address of pool token\\r\\n    address internal interestTokenAddress; // The address of interest token\\r\\n    address internal interestWalletAddress; // The address of NIImargin contract\\r\\n\\r\\n    address internal factory; // The address of BruFactory contract\\r\\n\\r\\n    struct BondDetails {\\r\\n        address tokenAddress;\\r\\n        uint256 bondTimestamp;\\r\\n        uint256 interest;\\r\\n        uint256 bondAmount;\\r\\n        uint256 lockTimePeriod;\\r\\n        uint256 claimedDay;\\r\\n        bool withdrawn;\\r\\n    }\\r\\n\\r\\n    //Struct used for storing NFT Data\\r\\n    struct NFT {\\r\\n        uint256 tokenId;\\r\\n        string commodityId;\\r\\n        uint256 quantity;\\r\\n        uint256 value;\\r\\n        bool borrowed;\\r\\n        string dataHash;\\r\\n        string data;\\r\\n    }\\r\\n\\r\\n    //Struct for other expenses\\r\\n    struct BorrowDetails {\\r\\n        uint256 borrowedAmount;\\r\\n        uint256 time;\\r\\n        address tokenBorrowedAddress;\\r\\n    }\\r\\n\\r\\n    struct Expenses {\\r\\n        uint256 otherexpenses;\\r\\n        uint256 interest;\\r\\n    }\\r\\n    /**\\r\\n     * @notice Mapping which stores nft data\\r\\n     */\\r\\n    mapping(string => NFT) public nft;\\r\\n\\r\\n    /**\\r\\n     * @notice Mapping for storing borrow details of NFT\\r\\n     */\\r\\n    mapping(string => BorrowDetails) public borrowedNft;\\r\\n\\r\\n    /**\\r\\n     * @notice Mapping for storing expenses\\r\\n     */\\r\\n    mapping(string => Expenses) public totalExpense;\\r\\n\\r\\n    mapping(address => uint256) public userBondIds;\\r\\n    mapping(address => mapping(uint256 => BondDetails)) public userBonds;\\r\\n    mapping(address => mapping(uint256 => bool)) public bondInterestClaimed;\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a user deposits funds into the pool\\r\\n     * @param _userAddress The address of the usersbr\\r\\n     * @param _bondId The ID of the newly created bond\\r\\n     * @param _timestamp The time at which the deposit function was executed\\r\\n     * @param _tokenAddress The address of the token deposited in the pool by te user.\\r\\n     * @param _tokenAmount the amount of token deposited by the user\\r\\n     */\\r\\n    event BondCreated(\\r\\n        address indexed _userAddress,\\r\\n        uint256 _bondId,\\r\\n        uint256 indexed _timestamp,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenAmount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a bond which has matured has been withdrawn by the user.\\r\\n     * @param _userAddress The address of the user\\r\\n     * @param _bondId The matured bond which is withdrawn by the user\\r\\n     * @param _timestamp The time at which the bond was withdrawn by the user\\r\\n     */\\r\\n    event BondWithdrawn(\\r\\n        address indexed _userAddress,\\r\\n        uint256 _bondId,\\r\\n        uint256 indexed _timestamp,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenAmount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when the interest on a bond is claimed by the user.\\r\\n     * @param _userAddress The address of the user\\r\\n     * @param _bondId The matured bond which is withdrawn by the user\\r\\n     * @param _timestamp The time at which the bond was withdrawn by the user\\r\\n     * @param _tokenAmount Amount of interest claimed on the bond\\r\\n     */\\r\\n    event BondInterestClaimed(address indexed _userAddress, uint256 _bondId, uint256 _timestamp, uint256 _tokenAmount);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted after user repays\\r\\n     * @param _amount amount repaid\\r\\n     * @param _nftId Id of the NFT\\r\\n     * @param _userAddress address of the user who repaid\\r\\n     * @param _tokenAddress address of token used to pay\\r\\n     */\\r\\n    event Repaid(\\r\\n        uint256 _amount,\\r\\n        string _nftId,\\r\\n        uint256 indexed _timestamp,\\r\\n        address indexed _userAddress,\\r\\n        address _tokenAddress\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted after user borrows\\r\\n     * @param _amount amount repaid\\r\\n     * @param _nftId Id of the NFT\\r\\n     * @param _userAddress address of the user who repaid\\r\\n     * @param _tokenAddress address of token used to pay\\r\\n     */\\r\\n    event Borrowed(\\r\\n        uint256 _amount,\\r\\n        string _nftId,\\r\\n        uint256 indexed _timestamp,\\r\\n        address indexed _userAddress,\\r\\n        address _tokenAddress\\r\\n    );\\r\\n    /**\\r\\n     * @notice Emitted an nft is minted\\r\\n     * @param _tokenId  Token ID of the SFT minted in asset treasury for the user\\r\\n     * @param _nftId NftID from the data of the nft\\r\\n     * @param _commodityId The Id of the commodity\\r\\n     * @param _quantity The amount of the commodity\\r\\n     * @param _value The total valuation of the commodity deposited\\r\\n     * @param _dataHash The hash encrypted by sha256 which has all the data of nft\\r\\n     * @param _data The original data of nft which combines its price and quantity and other details\\r\\n     */\\r\\n    event NFTMinted(\\r\\n        uint256 _tokenId,\\r\\n        string _nftId,\\r\\n        string _commodityId,\\r\\n        uint256 _quantity,\\r\\n        uint256 _value,\\r\\n        string _dataHash,\\r\\n        string _data\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes necessary contract addresses\\r\\n     * @param _multiSigAddress The address of multi sign wallet\\r\\n     * @param _factoryAddress The address of factory contract\\r\\n     * @param _poolTokenAddress The address of pool token\\r\\n     * @param _interestTokenAddress The address of interest token\\r\\n     * @param _treasuryAddress The address of asset treasury contract\\r\\n     * @param _poolName The name of the pool\\r\\n     * @param _interestWalletAddress The address of NIImargin contract\\r\\n     * @param _bruRewardsAddress The address of bruReward contract\\r\\n     * @param _bruPriceAddress The address of BruPrice contract\\r\\n     */\\r\\n    function initialize(\\r\\n        uint256 _poolIndex,\\r\\n        address _routerAddress,\\r\\n        address _multiSigAddress,\\r\\n        address _factoryAddress,\\r\\n        address _poolTokenAddress,\\r\\n        address _interestTokenAddress,\\r\\n        address _treasuryAddress,\\r\\n        string memory _poolName,\\r\\n        address _interestWalletAddress,\\r\\n        address _bruRewardsAddress,\\r\\n        address _bruPriceAddress\\r\\n    ) external virtual initializer {\\r\\n        require(\\r\\n            _routerAddress != address(0) &&\\r\\n                _multiSigAddress != address(0) &&\\r\\n                _factoryAddress != address(0) &&\\r\\n                _poolTokenAddress != address(0) &&\\r\\n                _interestTokenAddress != address(0) &&\\r\\n                _treasuryAddress != address(0) &&\\r\\n                _interestWalletAddress != address(0) &&\\r\\n                _bruRewardsAddress != address(0) &&\\r\\n                _bruPriceAddress != address(0),\\r\\n            \\\"Invalid Address\\\"\\r\\n        );\\r\\n\\r\\n        poolIndex = _poolIndex;\\r\\n        routerAddress = _routerAddress;\\r\\n        admin = _multiSigAddress;\\r\\n        owner = msg.sender;\\r\\n        factory = _factoryAddress;\\r\\n        name = _poolName;\\r\\n        maxFeeRate = 10000;\\r\\n        maxAllowedTokenAddresses = 99;\\r\\n        rates.borrow = (uint256(1000) * (10 ** 18)) / (maxFeeRate);\\r\\n        platformFees.borrow = (uint256(1) * (10 ** 18)) / (maxFeeRate);\\r\\n        platformFees.lend = (uint256(1) * (10 ** 18)) / (maxFeeRate);\\r\\n        spread = (uint256(200) * (10 ** 18)) / (maxFeeRate);\\r\\n        rates.lend = rates.borrow - spread;\\r\\n        poolTokenAddress = _poolTokenAddress;\\r\\n        interestTokenAddress = _interestTokenAddress;\\r\\n        interestWalletAddress = _interestWalletAddress;\\r\\n        treasuryAddress = _treasuryAddress;\\r\\n        bruRewardsAddress = _bruRewardsAddress;\\r\\n        bruPriceAddress = _bruPriceAddress;\\r\\n        lockPeriod = 180 days;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Store's NFT's detailed information in the nft mapping by using nftID\\r\\n     * @param _tokenId  Token ID of the SFT minted in asset treasury for the user\\r\\n     * @param _nftId NftID from the data of the nft\\r\\n     * @param _commodityId The Id of the commodity\\r\\n     * @param _quantity The amount of the commodity\\r\\n     * @param _value The total valuation of the commodity deposited\\r\\n     * @param _dataHash The hash encrypted by sha256 which has all the data of nft\\r\\n     * @param _data The original data of nft which combines its price and quantity and other details\\r\\n     */\\r\\n    function mintNft(\\r\\n        uint256 _tokenId,\\r\\n        string memory _nftId,\\r\\n        string memory _commodityId,\\r\\n        uint256 _quantity,\\r\\n        uint256 _value,\\r\\n        string memory _dataHash,\\r\\n        string memory _data\\r\\n    ) external virtual onlyAssetTreasury {\\r\\n        require(nft[_nftId].quantity == 0, \\\"minted already\\\");\\r\\n        nft[_nftId] = NFT(_tokenId, _commodityId, _quantity, _value, false, _dataHash, _data);\\r\\n        emit NFTMinted(_tokenId, _nftId, _commodityId, _quantity, _value, _dataHash, _data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to borrow tokens / stablecoins from the contract\\r\\n     * @dev tranfers allowed tokens from contract to the user accounts.\\r\\n     * @param _userAddress The address of the borrower\\r\\n     * @param _nftId The Id of the nft borrower can used as collateral\\r\\n     * @param _tokenAddress the address of the token borrower can borrow\\r\\n     * @param _tokenAmount the amount of token borrower wants to borrow\\r\\n     */\\r\\n    function borrow(\\r\\n        address _userAddress,\\r\\n        string memory _nftId,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenAmount\\r\\n    ) external virtual checkCorePauseStatus onlyRouter {\\r\\n        require(AssetTreasury(treasuryAddress).balanceOf(_userAddress, nft[_nftId].tokenId) > 0, \\\"NFT does not exist\\\");\\r\\n        require(!assetLocked[_nftId] && !nft[_nftId].borrowed, \\\"Already borrowed on this NFT\\\");\\r\\n        require(allowedTokenAddresses[_tokenAddress], \\\"Token Address not allowed\\\");\\r\\n        require(IERC20(_tokenAddress).balanceOf(address(this)) > _tokenAmount, \\\"Pool does not have enough liquidity\\\");\\r\\n        uint256 totalAssetValue;\\r\\n        uint256 assetValuePerKG = BruPrice(bruPriceAddress).asset(nft[_nftId].commodityId);\\r\\n        if (assetValuePerKG > 0) {\\r\\n            totalAssetValue = nft[_nftId].quantity * assetValuePerKG;\\r\\n        } else {\\r\\n            totalAssetValue = nft[_nftId].value;\\r\\n        }\\r\\n        require(_tokenAmount <= (totalAssetValue * 7) / 10, \\\"Collateral provided is less for specified token amount\\\");\\r\\n        nft[_nftId].borrowed = true;\\r\\n        assetLocked[_nftId] = true;\\r\\n        borrowedNft[_nftId] = BorrowDetails(_tokenAmount, block.timestamp, _tokenAddress);\\r\\n        if (BruRewards(bruRewardsAddress).getRewardStatusForPool(poolIndex)) {\\r\\n            BruRewards(bruRewardsAddress).updateBorrowAmountInRewardsInterval(poolIndex, _userAddress, _tokenAmount);\\r\\n        }\\r\\n        IERC20(_tokenAddress).safeTransfer(_userAddress, _tokenAmount);\\r\\n        emit Borrowed(_tokenAmount, _nftId, block.timestamp, _userAddress, _tokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to repay the borrowed amount\\r\\n     * @param _userAddress The address of the borrower\\r\\n     * @param _nftId The Id of the nft borrower used as collateral\\r\\n     * @param _tokenAmount the amount of token borrower want to repay\\r\\n     * @param _tokenAddress the address of the token borrower has borrowed\\r\\n     */\\r\\n    function repay(\\r\\n        address _userAddress,\\r\\n        string memory _nftId,\\r\\n        uint256 _tokenAmount,\\r\\n        address _tokenAddress\\r\\n    ) external virtual nonReentrant checkCorePauseStatus onlyRouter {\\r\\n        uint256 interestCollected = 0;\\r\\n        require(AssetTreasury(treasuryAddress).balanceOf(_userAddress, nft[_nftId].tokenId) > 0, \\\"NFT does not exist\\\");\\r\\n        require(nft[_nftId].borrowed, \\\"This NFT is not borrowed\\\");\\r\\n        require(_tokenAddress == borrowedNft[_nftId].tokenBorrowedAddress, \\\"token does not match the token borrowed\\\");\\r\\n        borrowInterest(_nftId);\\r\\n        uint256 amount = (_tokenAmount * (10 ** 18)) / ((10 ** 18) + platformFees.borrow);\\r\\n\\r\\n        uint256 totalPayablePrice = borrowedNft[_nftId].borrowedAmount + totalExpense[_nftId].interest;\\r\\n\\r\\n        require(totalPayablePrice >= amount, \\\"amount greater than borrowed\\\");\\r\\n\\r\\n        if (amount >= totalExpense[_nftId].interest) {\\r\\n            interestCollected += totalExpense[_nftId].interest;\\r\\n\\r\\n            totalExpense[_nftId].interest = 0;\\r\\n\\r\\n            borrowedNft[_nftId].borrowedAmount -= amount - interestCollected;\\r\\n        } else {\\r\\n            totalExpense[_nftId].interest -= amount;\\r\\n            interestCollected += amount;\\r\\n        }\\r\\n        borrowedNft[_nftId].time = block.timestamp;\\r\\n\\r\\n        if (borrowedNft[_nftId].borrowedAmount <= 1) {\\r\\n            nft[_nftId].borrowed = false;\\r\\n            assetLocked[_nftId] = false;\\r\\n            borrowedNft[_nftId] = BorrowDetails(0, 0, address(0));\\r\\n        }\\r\\n\\r\\n        IERC20(_tokenAddress).safeTransferFrom(_userAddress, address(this), _tokenAmount);\\r\\n\\r\\n        IERC20(_tokenAddress).safeTransfer(interestWalletAddress, interestCollected + _tokenAmount - amount);\\r\\n        emit Repaid(_tokenAmount, _nftId, block.timestamp, _userAddress, _tokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Deposits user's tokens in the pool contract\\r\\n     * @param _userAddress The address of the user who deposits his tokens\\r\\n     * @param _tokenAddress The address of the token user wants to deposit\\r\\n     * @param _tokenAmount The amount of token user wants to deposit\\r\\n     */\\r\\n    function deposit(\\r\\n        address _userAddress,\\r\\n        address _tokenAddress,\\r\\n        uint256 _tokenAmount\\r\\n    ) external virtual nonReentrant checkCorePauseStatus onlyRouter {\\r\\n        require(allowedTokenAddresses[_tokenAddress], \\\"Token Address not allowed\\\");\\r\\n        require(_tokenAmount > 0, \\\"Token Amount less than one\\\");\\r\\n        require(IERC20(_tokenAddress).balanceOf(_userAddress) >= _tokenAmount, \\\"Insufficient Token Amount\\\");\\r\\n        uint256 amount = (_tokenAmount * (10 ** 18)) / ((10 ** 18) + platformFees.lend);\\r\\n\\r\\n        uint256 bondId = userBondIds[_userAddress];\\r\\n        userBonds[_userAddress][bondId] = BondDetails(\\r\\n            _tokenAddress,\\r\\n            block.timestamp,\\r\\n            rates.lend,\\r\\n            amount,\\r\\n            lockPeriod,\\r\\n            0,\\r\\n            false\\r\\n        );\\r\\n        userBondIds[_userAddress]++;\\r\\n        IERC20(_tokenAddress).safeTransferFrom(_userAddress, address(this), _tokenAmount);\\r\\n        IERC20(_tokenAddress).safeTransfer(interestWalletAddress, _tokenAmount - amount);\\r\\n\\r\\n        if (BruRewards(bruRewardsAddress).getRewardStatusForPool(poolIndex)) {\\r\\n            BruRewards(bruRewardsAddress).updateLendAmountInRewardsInterval(poolIndex, _userAddress, _tokenAmount);\\r\\n        }\\r\\n        PoolToken(poolTokenAddress).mint(_userAddress, amount);\\r\\n        emit BondCreated(_userAddress, bondId, block.timestamp, _tokenAddress, _tokenAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Withdraws user's withdrawable balance from pool and transfers it to a user's wallet address\\r\\n     * @param _userAddress The account address of the user\\r\\n     * @param _bondId The ID of the bond which is to be withdrawn\\r\\n     */\\r\\n    function withdraw(\\r\\n        address _userAddress,\\r\\n        uint256 _bondId\\r\\n    ) external virtual nonReentrant checkCorePauseStatus onlyRouter {\\r\\n        BondDetails memory userBond = userBonds[_userAddress][_bondId];\\r\\n        require(userBond.bondTimestamp > 0, \\\"Bond does not exist\\\");\\r\\n        require(!userBond.withdrawn, \\\"Bond already withdrawn\\\");\\r\\n        require(withdrawable(userBond.bondTimestamp, userBond.lockTimePeriod), \\\"Bond has not matured yet\\\");\\r\\n        userBonds[_userAddress][_bondId].withdrawn = true;\\r\\n        PoolToken(poolTokenAddress).burn(_userAddress, userBond.bondAmount);\\r\\n        IERC20(userBond.tokenAddress).safeTransfer(_userAddress, userBond.bondAmount);\\r\\n        emit BondWithdrawn(_userAddress, _bondId, block.timestamp, userBond.tokenAddress, userBond.bondAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to exchange interest token with tokens / stablecoins supported by the pool\\r\\n     * @param _requiredTokenAddress The address of token to be redeem\\r\\n     * @param _tokenAmount The amount of token to redeem\\r\\n     */\\r\\n    function redeemInterestToken(address _requiredTokenAddress, uint256 _tokenAmount) external virtual {\\r\\n        address userAddress = msg.sender;\\r\\n        require(allowedTokenAddresses[_requiredTokenAddress], \\\"Token address not allowed for redeeming\\\");\\r\\n        require(\\r\\n            IERC20(interestTokenAddress).balanceOf(userAddress) >= _tokenAmount && _tokenAmount > 0,\\r\\n            \\\"Insufficient interest tokens to redeem\\\"\\r\\n        );\\r\\n        InterestToken(interestTokenAddress).burn(userAddress, _tokenAmount);\\r\\n        NIIMargin(interestWalletAddress).sendAmount(_tokenAmount, _requiredTokenAddress, userAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the accumulated interest\\r\\n     * @param _nftId the Id of the NFT\\r\\n     * @return _interest the total accumulated interest\\r\\n     */\\r\\n    function borrowInterest(string memory _nftId) internal returns (uint256) {\\r\\n        totalExpense[_nftId].interest += calculateBorrowInterest(_nftId);\\r\\n\\r\\n        return totalExpense[_nftId].interest;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice It is used to claim the interest amount on a bond based on the time the bond was created / the last time the interest was claimed on the bond\\r\\n     * @param _bondId The ID of bond which the user wants to claim the interest for.\\r\\n     */\\r\\n    function claimInterestOnBond(uint256 _bondId) external {\\r\\n        BondDetails memory userBond = userBonds[msg.sender][_bondId];\\r\\n        require(userBond.bondTimestamp > 0, \\\"Bond does not exist\\\");\\r\\n        require(!bondInterestClaimed[msg.sender][_bondId], \\\"Bond interest already claimed\\\");\\r\\n        uint256 currentTime;\\r\\n        uint256 depositedTimeInSeconds;\\r\\n        uint256 bondMaturityPeriod = userBond.bondTimestamp + userBond.lockTimePeriod;\\r\\n        if (block.timestamp >= bondMaturityPeriod) {\\r\\n            bondInterestClaimed[msg.sender][_bondId] = true;\\r\\n        }\\r\\n        if (bondMaturityPeriod < block.timestamp) {\\r\\n            currentTime = bondMaturityPeriod;\\r\\n        } else {\\r\\n            currentTime = block.timestamp;\\r\\n        }\\r\\n        if (userBond.claimedDay == 0) {\\r\\n            depositedTimeInSeconds = ((currentTime - userBond.bondTimestamp));\\r\\n        } else {\\r\\n            depositedTimeInSeconds = ((currentTime - userBond.claimedDay));\\r\\n        }\\r\\n        uint256 interestTokenAmount = (userBond.bondAmount * userBond.interest * depositedTimeInSeconds) /\\r\\n            (31536000 * (10 ** 18));\\r\\n        userBonds[msg.sender][_bondId].claimedDay = block.timestamp;\\r\\n        InterestToken(interestTokenAddress).mint(msg.sender, interestTokenAmount);\\r\\n        emit BondInterestClaimed(msg.sender, _bondId, block.timestamp, interestTokenAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Locks the NFT and prevents user from borrowing on it\\r\\n     * @param _userAddress The account address of the user\\r\\n     * @param _nftId the ID of the NFT\\r\\n     */\\r\\n    function lockAsset(address _userAddress, string calldata _nftId) external onlyOwner {\\r\\n        require(AssetTreasury(treasuryAddress).balanceOf(_userAddress, nft[_nftId].tokenId) > 0, \\\"NFT does not exist\\\");\\r\\n        assetLocked[_nftId] = true;\\r\\n        emit AssetLocked(_nftId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Unlocks the NFT and allows the user to borrow on the NFT\\r\\n     * @param _userAddress The account address of the user\\r\\n     * @param _nftId the ID of the NFT\\r\\n     */\\r\\n    function unlockAsset(address _userAddress, string calldata _nftId) external onlyOwner {\\r\\n        require(AssetTreasury(treasuryAddress).balanceOf(_userAddress, nft[_nftId].tokenId) > 0, \\\"NFT does not exist\\\");\\r\\n        assetLocked[_nftId] = false;\\r\\n        emit AssetUnlocked(_nftId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice It helps to get the amount for complete repayment for an NFT\\r\\n     * @param _nftId the ID of the NFT\\r\\n     */\\r\\n    function getRepaymentAmount(string memory _nftId) external view returns (uint256) {\\r\\n        uint256 interestAmountAccumulated = calculateBorrowInterest(_nftId);\\r\\n        uint256 totalPayablePrice = borrowedNft[_nftId].borrowedAmount +\\r\\n            totalExpense[_nftId].interest +\\r\\n            interestAmountAccumulated;\\r\\n        totalPayablePrice += (platformFees.borrow * totalPayablePrice) / 10 ** 18;\\r\\n        return totalPayablePrice;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice It calculates the interest amount for the NFT\\r\\n     * @param _nftId the ID of the NFT\\r\\n     */\\r\\n    function calculateBorrowInterest(string memory _nftId) internal view returns (uint256) {\\r\\n        uint256 borrowedDays = (block.timestamp - borrowedNft[_nftId].time) / 86400;\\r\\n        uint256 interestAmountAccumulated = (borrowedNft[_nftId].borrowedAmount * rates.borrow * borrowedDays) /\\r\\n            (365 * (10 ** 18));\\r\\n        return interestAmountAccumulated;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks whether the bond is withdrawable or not\\r\\n     * @param _bondCreationTime The timestamp at which bond is created\\r\\n     * @param _bondLockPeriod The duration of the lock-in period\\r\\n     */\\r\\n    function withdrawable(uint256 _bondCreationTime, uint256 _bondLockPeriod) internal view returns (bool) {\\r\\n        uint256 currentTime = block.timestamp;\\r\\n        uint256 timePassedFromDeposit = currentTime - _bondCreationTime;\\r\\n        return timePassedFromDeposit >= _bondLockPeriod;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks the wallet address which initiates the upgrade transaction for BruPool contract\\r\\n     * @param _newImplementation Address of the new implementation contract which is used for upgradation.\\r\\n     */\\r\\n    function _authorizeUpgrade(address _newImplementation) internal view override {\\r\\n        require(msg.sender == admin, \\\"Only called by admin\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BruPrice.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Bru Price contract\\r\\n * @author Bru-finance team\\r\\n * @notice Contract that is used to get assets prices which is used in BruPool contract\\r\\n */\\r\\ncontract BruPrice is Initializable, UUPSUpgradeable {\\r\\n    address internal adminAddress; // The address of Multisig wallet\\r\\n    address internal owner; // The address of deployer.\\r\\n    /**\\r\\n     * @notice a mapping that stores assets name with respect to price\\r\\n     */\\r\\n    mapping(string => uint256) public asset;\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when commodity price updated\\r\\n     * @param _id The id of the asset\\r\\n     * @param _value The newly updated price\\r\\n     */\\r\\n    event CommodityPriceUpdated(string _id, uint256 _value);\\r\\n\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"Only owner address is allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes admin address\\r\\n     * @param _adminAddress The address of Multisig wallet\\r\\n     */\\r\\n    function initialize(address _adminAddress) external virtual initializer {\\r\\n        require(_adminAddress != address(0), \\\"incorrect address\\\");\\r\\n        adminAddress = _adminAddress;\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the Price of the asset\\r\\n     * @param _id The Id of the asset\\r\\n     * @param _price The price of the asset\\r\\n     */\\r\\n    function updatePrice(string memory _id, uint256 _price) external virtual onlyOwner {\\r\\n        asset[_id] = _price;\\r\\n        emit CommodityPriceUpdated(_id, _price);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks the wallet address which initiates the upgrade transaction for BruPrice contract\\r\\n     * @param _newImplementation Address of the new implementation contract which is used for upgradation.\\r\\n     */\\r\\n    function _authorizeUpgrade(address _newImplementation) internal view override {\\r\\n        require(msg.sender == adminAddress, \\\"Only admin allowed\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/BruRewards.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"./BruPool.sol\\\";\\r\\nimport \\\"./BruFactory.sol\\\";\\r\\nimport \\\"./BruOracle.sol\\\";\\r\\nimport \\\"../vesting/TokenVestingBru.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title BruRewards contract\\r\\n * @author Bru-finance team\\r\\n * @dev This contract is used to contains rewards logic\\r\\n */\\r\\ncontract BruRewards is Initializable, UUPSUpgradeable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    uint256 public emission; // number of tokens emitted per interval\\r\\n    uint256 internal secondsPerYear; // seconds in a year\\r\\n\\r\\n    address internal adminAddress; // address of Multisig wallet\\r\\n    address internal factoryAddress; // address of BruFactory contract\\r\\n    address internal bruToken; // address of Bru token\\r\\n    address internal bruOracleAddress; // address of BruOracle contract\\r\\n    address internal tokenVestingAddress; // address of TokenVestingBru contract\\r\\n    //struct which is used to store reward details per interval\\r\\n    struct RewardDetails {\\r\\n        uint256 rewardTokens;\\r\\n        uint256 startTime;\\r\\n        uint256 endTime;\\r\\n        uint256 totalLendAmount;\\r\\n        uint256 totalBorrowedAmount;\\r\\n        bool isActive;\\r\\n    }\\r\\n    // struct which is used to store the balance of user per interval\\r\\n    struct UserBalance {\\r\\n        uint256 lendAmount;\\r\\n        uint256 borrowedAmount;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 => uint256) internal rewardIntervalIds; // used to store reward interval id for pool\\r\\n    mapping(uint256 => mapping(uint256 => RewardDetails)) internal rewardDetails; //used to store reward details for pool\\r\\n    mapping(uint256 => mapping(uint256 => mapping(address => UserBalance))) internal userBalance; // used to store user balance\\r\\n    mapping(uint256 => mapping(uint256 => mapping(address => bool))) internal userClaims; // to check if the reward is claimed by user for an interval\\r\\n    /**\\r\\n     * @notice emitted during emission change action in the contract\\r\\n     * @param _emission the new emission value in the contract\\r\\n     */\\r\\n    event EmissionChanged(uint256 _emission);\\r\\n    /**\\r\\n     * @notice emitted during reward interval started\\r\\n     * @param _poolIndex the pool index for which the reward interval is started\\r\\n     * @param _rewardAPY The number of reward APY\\r\\n     */\\r\\n    event PoolRewardsStarted(uint256 _poolIndex, uint256 _rewardAPY);\\r\\n    /**\\r\\n     * @notice emitted when pool reward stopped\\r\\n     * @param _poolIndex the pool index for which the reward interval is stopped\\r\\n     */\\r\\n    event PoolRewardsStopped(uint256 _poolIndex);\\r\\n    /**\\r\\n     * @notice emitted when user lent amount updated during reward interval\\r\\n     * @param _poolIndex The pool index for which the amount added\\r\\n     * @param _userAddress The user address for which the lend amount updated\\r\\n     * @param _amount The amount of tokens deposited during a reward interval\\r\\n     */\\r\\n    event LendAmountUpdated(uint256 _poolIndex, address _userAddress, uint256 _amount);\\r\\n    /**\\r\\n     * @notice emitted when user borrow amount updated during reward interval\\r\\n     * @param _poolIndex The pool index for which the amount updated\\r\\n     * @param _userAddress The user address for which the borrow amount updated\\r\\n     * @param _amount The amount of tokens borrowed during a reward interval\\r\\n     */\\r\\n    event BorrowAmountUpdated(uint256 _poolIndex, address _userAddress, uint256 _amount);\\r\\n\\r\\n    /**\\r\\n     * @notice emitted when user claims reward tokens for a particulat interval of a pool\\r\\n     * @param _rewardIntervalId The pool index for which the amount updated\\r\\n     * @param _poolIndex The user address for which the borrow amount updated\\r\\n     * @param _userAddress The amount of tokens borrowed during a reward interval\\r\\n     */\\r\\n    event RewardsClaimed(uint256 _rewardIntervalId, uint256 _poolIndex, address _userAddress);\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == adminAddress, \\\"Can be used only by admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Only pool can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyPool(uint256 _poolIndex) {\\r\\n        PoolDetails memory poolDetails = BruFactory(factoryAddress).getPoolDetails(_poolIndex);\\r\\n        require(poolDetails.proxyPoolAddress == msg.sender, \\\"Only pools can access\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes necessary contract addresses\\r\\n     * @param _adminAddress The address of multisig wallet\\r\\n     * @param _factoryAddress The address of factory contract\\r\\n     * @param _bruToken address of bru token\\r\\n     * @param _tokenVestingAddress The address of token vesting contract\\r\\n     * @param _bruOracleAddress The address of bru oracle contract\\r\\n     */\\r\\n    function initialize(\\r\\n        address _adminAddress,\\r\\n        address _factoryAddress,\\r\\n        address _bruToken,\\r\\n        address _tokenVestingAddress,\\r\\n        address _bruOracleAddress\\r\\n    ) external virtual initializer {\\r\\n        require(\\r\\n            _adminAddress != address(0) &&\\r\\n                _factoryAddress != address(0) &&\\r\\n                _bruToken != address(0) &&\\r\\n                _tokenVestingAddress != address(0) &&\\r\\n                _bruOracleAddress != address(0),\\r\\n            \\\"Invalid Address\\\"\\r\\n        );\\r\\n        adminAddress = _adminAddress;\\r\\n        factoryAddress = _factoryAddress;\\r\\n        bruToken = _bruToken;\\r\\n        tokenVestingAddress = _tokenVestingAddress;\\r\\n        bruOracleAddress = _bruOracleAddress;\\r\\n        emission = 1000000000000000000000;\\r\\n        secondsPerYear = 31536000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice gets latest reward interval for a pool index\\r\\n     * @param _poolIndex the pool index for which the status of the reward interval is to checked\\r\\n     */\\r\\n    function getLatestRewardIntervalForPool(uint256 _poolIndex) public view virtual returns (RewardDetails memory) {\\r\\n        return rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice used to calculate rewardAPY which is used while rewards distribution\\r\\n     */\\r\\n    function getRewardAPY() public view virtual returns (uint256) {\\r\\n        uint256 tokenPrice = BruOracle(bruOracleAddress).getBruTokenPrice();\\r\\n        uint256 numerator = emission * tokenPrice * secondsPerYear;\\r\\n        uint256 tokenSupply = Token(BruFactory(factoryAddress).bruTokenAddress()).initialTokenSupply();\\r\\n        uint256 denominator = tokenSupply * 1440 * 10;\\r\\n        uint256 rewardAPY = numerator / denominator;\\r\\n        return rewardAPY;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice used to changes the amount of emitted tokens during reward interval\\r\\n     * @param _emission the new emission value in the contract\\r\\n     */\\r\\n    function changeEmission(uint256 _emission) external virtual onlyAdmin {\\r\\n        emission = _emission;\\r\\n        emit EmissionChanged(emission);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice starts rewards interval for pool\\r\\n     * @param _poolIndex the pool index for which the reward interval is to be started\\r\\n     * @param _durationInDays The duration for which the reward interval will be active\\r\\n     */\\r\\n    function startRewardsForPool(uint256 _poolIndex, uint256 _durationInDays) external virtual onlyAdmin {\\r\\n        require(!rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]].isActive, \\\"An interval is already active\\\");\\r\\n        rewardIntervalIds[_poolIndex] += 1;\\r\\n        uint256 startTime = block.timestamp;\\r\\n        uint256 endTime = startTime + _durationInDays * 86400;\\r\\n        PoolDetails[] memory allPoolDetails = BruFactory(factoryAddress).getAllPoolDetails();\\r\\n        uint256 poolTokenAmount = emission / allPoolDetails.length;\\r\\n        rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]] = RewardDetails(\\r\\n            poolTokenAmount,\\r\\n            block.timestamp,\\r\\n            endTime,\\r\\n            0,\\r\\n            0,\\r\\n            true\\r\\n        );\\r\\n        PoolDetails memory poolDetails = BruFactory(factoryAddress).getPoolDetails(_poolIndex);\\r\\n        uint256 rewardAPY = getRewardAPY();\\r\\n        BruPool(poolDetails.proxyPoolAddress).startRewards(rewardAPY);\\r\\n        TokenVestingBru(tokenVestingAddress).distributeRewards(emission);\\r\\n        emit PoolRewardsStarted(_poolIndex, rewardAPY);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice stops rewards interval for pool\\r\\n     * @param _poolIndex the pool index for which the reward interval is to be stopped\\r\\n     */\\r\\n    function stopRewardsForPool(uint256 _poolIndex) external virtual onlyAdmin {\\r\\n        require(rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]].isActive, \\\"rewards should be active\\\");\\r\\n        require(\\r\\n            block.timestamp > rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]].endTime,\\r\\n            \\\"Rewards duration not completed\\\"\\r\\n        );\\r\\n        rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]].isActive = false;\\r\\n        PoolDetails memory poolDetails = BruFactory(factoryAddress).getPoolDetails(_poolIndex);\\r\\n        BruPool(poolDetails.proxyPoolAddress).stopRewards();\\r\\n        emit PoolRewardsStopped(_poolIndex);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice checks if reward interval is active for a pool index\\r\\n     * @param _poolIndex the pool index for which the status of the reward interval is to checked\\r\\n     */\\r\\n    function getRewardStatusForPool(uint256 _poolIndex) external view virtual returns (bool) {\\r\\n        return\\r\\n            rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]].isActive &&\\r\\n            (rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]].endTime >= block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice updates user's lent amount when a reward interval is active for a particular pool\\r\\n     * @param _poolIndex the pool index for which the amount is to be added\\r\\n     * @param _userAddress The user address for which the lend amount is to be updated\\r\\n     * @param _amount The amount of tokens deposited during a reward interval\\r\\n     */\\r\\n    function updateLendAmountInRewardsInterval(\\r\\n        uint256 _poolIndex,\\r\\n        address _userAddress,\\r\\n        uint256 _amount\\r\\n    ) external virtual onlyPool(_poolIndex) {\\r\\n        uint256 id = rewardIntervalIds[_poolIndex];\\r\\n        userBalance[_poolIndex][id][_userAddress].lendAmount += _amount;\\r\\n        rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]].totalLendAmount += _amount;\\r\\n        emit LendAmountUpdated(_poolIndex, _userAddress, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice updates user's borrowed amount when a reward interval is active for a particular pool\\r\\n     * @param _poolIndex the pool index for which the amount is to be added\\r\\n     * @param _userAddress The user address for which the borrowed amount is to be updated\\r\\n     * @param _amount The amount of tokens borrowed by user during a reward interval\\r\\n     */\\r\\n    function updateBorrowAmountInRewardsInterval(\\r\\n        uint256 _poolIndex,\\r\\n        address _userAddress,\\r\\n        uint256 _amount\\r\\n    ) external virtual onlyPool(_poolIndex) {\\r\\n        uint256 id = rewardIntervalIds[_poolIndex];\\r\\n        userBalance[_poolIndex][id][_userAddress].borrowedAmount += _amount;\\r\\n        rewardDetails[_poolIndex][rewardIntervalIds[_poolIndex]].totalBorrowedAmount += _amount;\\r\\n        emit BorrowAmountUpdated(_poolIndex, _userAddress, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice It is used by users to claim their reward bru tokens from the reward contracts.\\r\\n     * @param _poolIndex the pool index for which the users want to claim tokens\\r\\n     * @param _rewardIntervalId The reward interval from which the users want to claim tokens.\\r\\n     */\\r\\n\\r\\n    function claimRewards(uint256 _poolIndex, uint256 _rewardIntervalId) external virtual {\\r\\n        require(rewardDetails[_poolIndex][_rewardIntervalId].startTime > 0, \\\"Rewards interval does not exist\\\");\\r\\n\\r\\n        require(!userClaims[_poolIndex][_rewardIntervalId][msg.sender], \\\"Rewards has already been claimed\\\");\\r\\n        RewardDetails memory rewardDetailsForPool = rewardDetails[_poolIndex][_rewardIntervalId];\\r\\n\\r\\n        require(\\r\\n            block.timestamp > rewardDetails[_poolIndex][_rewardIntervalId].endTime,\\r\\n            \\\"Rewards duration not completed\\\"\\r\\n        );\\r\\n        uint256 bruTokenAmountForLend;\\r\\n        uint256 bruTokenAmountForBorrow;\\r\\n\\r\\n        if (rewardDetailsForPool.totalLendAmount > 0) {\\r\\n            uint256 userPercentageInLend = ((userBalance[_poolIndex][_rewardIntervalId][msg.sender].lendAmount) *\\r\\n                10**18) / (rewardDetailsForPool.totalLendAmount);\\r\\n\\r\\n            bruTokenAmountForLend = (userPercentageInLend * (rewardDetailsForPool.rewardTokens / 2)) / 10**18;\\r\\n        }\\r\\n\\r\\n        if (rewardDetailsForPool.totalBorrowedAmount > 0) {\\r\\n            uint256 userPercentageInBorrow = (userBalance[_poolIndex][_rewardIntervalId][msg.sender].borrowedAmount *\\r\\n                10**18) / (rewardDetailsForPool.totalBorrowedAmount);\\r\\n            bruTokenAmountForBorrow = (userPercentageInBorrow * (rewardDetailsForPool.rewardTokens / 2)) / 10**18;\\r\\n        }\\r\\n\\r\\n        uint256 totalAmount = bruTokenAmountForBorrow + bruTokenAmountForLend;\\r\\n\\r\\n        userClaims[_poolIndex][_rewardIntervalId][msg.sender] = true;\\r\\n        IERC20(bruToken).safeTransfer(msg.sender, totalAmount);\\r\\n        emit RewardsClaimed(_rewardIntervalId, _poolIndex, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks the wallet address which initiates the upgrade transaction for BruRewards contract\\r\\n     * @param _newImplementation Address of the new implementation contract which is used for upgradation.\\r\\n     */\\r\\n    function _authorizeUpgrade(address _newImplementation) internal view override {\\r\\n        require(msg.sender == adminAddress, \\\"Only admin allowed\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/tokens/InterestToken.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Interest token contract\\r\\n * @author Bru-finance team\\r\\n * @notice It is an ERC20 token used to show users how much interest they have accured which can be redeemed later.\\r\\n */\\r\\ncontract InterestToken is ERC20 {\\r\\n    address internal poolAddress; //address of the pool\\r\\n    address internal admin; // address of Multisig wallet\\r\\n    string private tokenName; // name of token\\r\\n    /**\\r\\n     * @notice Emmitted after changeName function executed successfully\\r\\n     * @param _newName The new changed name\\r\\n     * @param _by The account address of the user who changed the name\\r\\n     */\\r\\n    event TokenNameChanged(string _newName, address _by);\\r\\n    /**\\r\\n     * @notice Emmitted after setPoolAddress function executed successfully\\r\\n     * @param _poolAddress The address of the pool\\r\\n     */\\r\\n    event PoolAddressUpdated(address _poolAddress);\\r\\n\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"Only admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Only pool can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyPool() {\\r\\n        require(msg.sender == poolAddress, \\\"Only Pool\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice a constructor used to initailize the necessary variables\\r\\n     * @param _tokenName The name of the token\\r\\n     * @param _symbol  The symbol of the token\\r\\n     * @param _adminAddress address of Multisig wallet\\r\\n     */\\r\\n    constructor(\\r\\n        string memory _tokenName,\\r\\n        string memory _symbol,\\r\\n        address _adminAddress\\r\\n    ) ERC20(_tokenName, _symbol) {\\r\\n        require(_adminAddress != address(0), \\\"Invalid address\\\");\\r\\n        tokenName = _tokenName;\\r\\n        admin = _adminAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to get the name of the token\\r\\n     * @return The name of the token\\r\\n     */\\r\\n    function name() public view override returns (string memory) {\\r\\n        return tokenName;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Changes the name of the token\\r\\n     * @dev only called by the admin\\r\\n     * @param _tokenName The new name of the token\\r\\n     */\\r\\n    function changeName(string memory _tokenName) external onlyAdmin {\\r\\n        tokenName = _tokenName;\\r\\n        emit TokenNameChanged(_tokenName, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mints specified amount of tokens\\r\\n     * @dev only called from the Pool contract\\r\\n     * @param _userAddress The address of the user\\r\\n     * @param _mintAmount The amount of token to mint\\r\\n     */\\r\\n    function mint(address _userAddress, uint256 _mintAmount) external onlyPool {\\r\\n        _mint(_userAddress, _mintAmount);\\r\\n    }\\r\\n\\r\\n    /**_\\r\\n     * @notice Sets the pool address\\r\\n     * @dev only called by the admin\\r\\n     * @param _poolAddress The address of the pool contract\\r\\n     */\\r\\n    function setPoolAddress(address _poolAddress) external onlyAdmin {\\r\\n        require(_poolAddress != address(0), \\\"Invalid address\\\");\\r\\n        poolAddress = _poolAddress;\\r\\n        emit PoolAddressUpdated(poolAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns specified amount of tokens\\r\\n     * @dev only called from the pool contract\\r\\n     * @param _userAddress The address of the user\\r\\n     * @param _burnAmount The amount of token to be burned\\r\\n     */\\r\\n    function burn(address _userAddress, uint256 _burnAmount) external onlyPool {\\r\\n        _burn(_userAddress, _burnAmount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/tokens/PoolToken.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Pool Token contract\\r\\n * @author Bru-finance team\\r\\n * @notice This contract is ERC20 standard token contract that are given for liquidity providers in the pool.\\r\\n *            This token act as receipt, allowing user to claim their original stake and interest earned.\\r\\n */\\r\\ncontract PoolToken is ERC20 {\\r\\n    address internal poolAddress; // address of pool address\\r\\n    address internal admin; // address of Multisig wallet\\r\\n    string private name_; // name of token\\r\\n\\r\\n    /**\\r\\n     * @notice Emmitted after changeName function executed successfully\\r\\n     * @param _newName The new changed name\\r\\n     * @param _by The account address of the user who changed the name\\r\\n     */\\r\\n    event NameChanged(string _newName, address _by);\\r\\n    /**\\r\\n     * @notice Emmitted after setPoolAddress function executed successfully\\r\\n     * @param _poolAddress The address of the pool\\r\\n     */\\r\\n    event PoolAddressUpdated(address _poolAddress);\\r\\n\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"Only admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Only pool can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyPool() {\\r\\n        require(msg.sender == poolAddress, \\\"Only Pool\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice a constructor used to initailize the necessary variables in the contract\\r\\n     * @param _tokenName The name of the token\\r\\n     * @param _symbol  The symbol of the token\\r\\n     * @param _adminAddress The address of the admin\\r\\n     */\\r\\n    constructor(\\r\\n        string memory _tokenName,\\r\\n        string memory _symbol,\\r\\n        address _adminAddress\\r\\n    ) ERC20(_tokenName, _symbol) {\\r\\n        require(_adminAddress != address(0), \\\"Invalid address\\\");\\r\\n        admin = _adminAddress;\\r\\n        name_ = _tokenName;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to get the name of the token\\r\\n     * @return The name of the token\\r\\n     */\\r\\n    function name() public view override returns (string memory) {\\r\\n        return name_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Changes the name of the token\\r\\n     * @dev only called by the admin\\r\\n     * @param _tokenName The new name of the token\\r\\n     */\\r\\n    function changeName(string memory _tokenName) external onlyAdmin {\\r\\n        name_ = _tokenName;\\r\\n        emit NameChanged(_tokenName, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mints specified amount of tokens\\r\\n     * @dev only called from the Pool contract\\r\\n     * @param _userAddress The address of the user\\r\\n     * @param _mintAmount The amount of token to mint\\r\\n     */\\r\\n    function mint(address _userAddress, uint256 _mintAmount) external onlyPool {\\r\\n        _mint(_userAddress, _mintAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns specified amount of tokens\\r\\n     * @dev only called from the pool contract\\r\\n     * @param _userAddress The address of the user\\r\\n     * @param _burnAmount The amount of token to be burned\\r\\n     */\\r\\n    function burn(address _userAddress, uint256 _burnAmount) external onlyPool {\\r\\n        _burn(_userAddress, _burnAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the pool address\\r\\n     * @dev only called by the admin\\r\\n     * @param _poolAddress The address of the pool contract\\r\\n     */\\r\\n    function setPoolAddress(address _poolAddress) external onlyAdmin {\\r\\n        require(_poolAddress != address(0), \\\"Invalid address\\\");\\r\\n        poolAddress = _poolAddress;\\r\\n        emit PoolAddressUpdated(poolAddress);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/vesting/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.8.7;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Bru Token contract\\r\\n * @author Bru-finance team\\r\\n * @notice ERC20 standard token\\r\\n */\\r\\ncontract Token is ERC20Snapshot {\\r\\n    uint256 public initialTokenSupply; // initial total supply of the tokens\\r\\n    address internal vestingContractAddress; // contract address (vesting)\\r\\n    address internal NIIWalletAddress; // contract address (NIIwallet)\\r\\n    address internal admin; //address of admin\\r\\n    mapping(address => bool) public enableMint; // mapping of addresses those are allowed to mint\\r\\n    mapping(uint256 => uint256) public snapshotIds; // mapping to store id of the snapshot\\r\\n\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"Can be used only by adminAddress\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Only NIIwallet or admin or vestingContract can call functions marked by this modifier.\\r\\n     */\\r\\n    modifier checkAddress() {\\r\\n        require(\\r\\n            msg.sender == admin || msg.sender == NIIWalletAddress || msg.sender == vestingContractAddress,\\r\\n            \\\"usage restricted\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice It is use to initialize teh required values to the contract\\r\\n     * @param _name name of token\\r\\n     * @param _symbol symbol of token\\r\\n     * @param _initialSupply initial supply of token\\r\\n     * @param _vestingContractAddress address of vesting contract\\r\\n     * @param _multisigAddress address of multisig address\\r\\n     * @param _NIIWalletAddress address of NIIMargin contract\\r\\n     */\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint256 _initialSupply,\\r\\n        address _vestingContractAddress,\\r\\n        address _multisigAddress,\\r\\n        address _NIIWalletAddress\\r\\n    ) ERC20(_name, _symbol) {\\r\\n        require(\\r\\n            _vestingContractAddress != address(0) && _multisigAddress != address(0) && _NIIWalletAddress != address(0),\\r\\n            \\\"Invalid address\\\"\\r\\n        );\\r\\n        initialTokenSupply = _initialSupply;\\r\\n        _mint(_vestingContractAddress, _initialSupply);\\r\\n        vestingContractAddress = _vestingContractAddress;\\r\\n        enableMint[_vestingContractAddress] = true;\\r\\n        NIIWalletAddress = _NIIWalletAddress;\\r\\n        admin = _multisigAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice returns initial supply of tokens\\r\\n     */\\r\\n    function getInitialSupply() external view returns (uint256) {\\r\\n        return initialTokenSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The function is used to mint new tokens to a specific address.\\r\\n     * @param _userAddress Address of the user whom we have to transfer the new minted tokens\\r\\n     * @param _mintamount The amount of new tokens to be minted\\r\\n     */\\r\\n    function mintNew(address _userAddress, uint256 _mintamount) external {\\r\\n        require(enableMint[msg.sender], \\\"not allowed to mint\\\");\\r\\n        _mint(_userAddress, _mintamount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The function is used to burn tokens to a specific address.\\r\\n     * @param _userAddress Address of the user whom we have to transfer the new minted tokens\\r\\n     * @param _burnAmount The amount of tokens to be burned\\r\\n     */\\r\\n    function burn(address _userAddress, uint256 _burnAmount) external {\\r\\n        require(enableMint[msg.sender], \\\"not allowed to burn\\\");\\r\\n        _burn(_userAddress, _burnAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice enables minting for given address\\r\\n     * @param _userAddress Address of the user\\r\\n     */\\r\\n    function enableMinting(address _userAddress) external onlyAdmin {\\r\\n        enableMint[_userAddress] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice disables minting for given address\\r\\n     * @param _userAddress Address of the user\\r\\n     */\\r\\n    function disableMinting(address _userAddress) external onlyAdmin {\\r\\n        enableMint[_userAddress] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice creates snapshot which can be used later to make some decisions\\r\\n     */\\r\\n    function createSnapshot() external checkAddress returns (uint256) {\\r\\n        uint256 currentTime = block.timestamp;\\r\\n        uint256 date = currentTime - (currentTime % 86400);\\r\\n        uint256 snapshotId = _snapshot();\\r\\n        snapshotIds[date] = snapshotId;\\r\\n        return date;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice returns balance of user at given date\\r\\n     * @param _userAddress address of the user\\r\\n     * @param _date date for snapshot mapping key\\r\\n     * @return balance of the user from the snapshot\\r\\n     */\\r\\n    function balanceOfAtDate(address _userAddress, uint256 _date) external view returns (uint256) {\\r\\n        return balanceOfAt(_userAddress, snapshotIds[_date]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice returns total supply at a given date\\r\\n     * @param _date date for snapshot mapping key\\r\\n     * @return total supply from the snapshot\\r\\n     */\\r\\n    function totalSupplyOfAtDate(uint256 _date) external view returns (uint256) {\\r\\n        return totalSupplyAt(snapshotIds[_date]);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/vesting/TokenVestingBru.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"./Token.sol\\\";\\r\\nimport \\\"../core/BruPool.sol\\\";\\r\\nimport \\\"../core/BruFactory.sol\\\";\\r\\nimport \\\"../core/BruOracle.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title TokenVestingBur contract\\r\\n * @author Bru-finance team\\r\\n * @notice Is a contract that locks and distributes purchased tokens within a time frame(vesting period).\\r\\n *\\t\\t   And it delays access to the asset being offered.\\r\\n */\\r\\n\\r\\ncontract TokenVestingBru is Ownable, ReentrancyGuard, Initializable, UUPSUpgradeable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    uint256 private constant QUARTER_TIME = 7889229; // quarter of 3 months in seconds\\r\\n    uint256 private constant MINIMUM_POOL_TVL = 10**8; // minimum TVL amount above which new tokens can be minted\\r\\n    uint256 public maxVestingSchedules; // per address max allowed vesting schedules\\r\\n    uint256 public maxCategories; // max categories\\r\\n\\r\\n    uint256 public totalPercentageUsed; // total % used <=100\\r\\n    uint256 internal lastStarted; // last time the quarter started\\r\\n    uint256 private vestingSchedulesTotalAmount; // total amount vested\\r\\n    uint256 internal categoryId; //category Id counter\\r\\n    uint256 public quarterId; // quarterId counter\\r\\n    address internal adminAddress; //address of admin\\r\\n    address internal NIIWalletAddress; // address of NIIwallet\\r\\n    address internal bruRewardsAddress; // address of Rewards wallet\\r\\n    address internal factoryAddress; // address of factory contract\\r\\n    address internal bruOracleAddress; // address of bruOracle\\r\\n    address internal deployer; // address of the owner who deploys the contract\\r\\n    bool internal pause; // pause boolean for major functionalities\\r\\n    Token public token; // bru token contract\\r\\n    bytes32[] private vestingSchedulesIds; // array of vesting schedule Ids created till time\\r\\n\\r\\n    struct VestingSchedule {\\r\\n        bool initialized;\\r\\n        // beneficiary of tokens after they are released\\r\\n        address beneficiary;\\r\\n        // cliff period in seconds\\r\\n        uint256 cliff;\\r\\n        // start time of the vesting period\\r\\n        uint256 start;\\r\\n        // duration of the vesting period in seconds\\r\\n        uint256 duration;\\r\\n        // duration of a slice period for the vesting in seconds\\r\\n        uint256 slicePeriodSeconds;\\r\\n        // whether or not the vesting is revocable\\r\\n        bool revocable;\\r\\n        // total amount of tokens to be released at the end of the vesting\\r\\n        uint256 amountTotal;\\r\\n        // amount of tokens released\\r\\n        uint256 released;\\r\\n        // whether or not the vesting has been revoked\\r\\n        bool revoked;\\r\\n    }\\r\\n\\r\\n    struct TokenDistribution {\\r\\n        uint256 tokenAmountleft;\\r\\n        uint256 tokenPercentage;\\r\\n    }\\r\\n\\r\\n    struct Records {\\r\\n        uint256 initialQuarterBalance;\\r\\n        uint256 finalQuarterBalance;\\r\\n        uint256 timeStamp;\\r\\n    }\\r\\n\\r\\n    struct Categories {\\r\\n        string categoryName;\\r\\n        address[] memberAddresses;\\r\\n        uint256 cliff;\\r\\n        // duration of the vesting period in seconds\\r\\n        uint256 duration;\\r\\n        // duration of a slice period for the vesting in seconds\\r\\n        uint256 slicePeriodSeconds;\\r\\n        // whether or not the vesting is revocable\\r\\n        bool revocable;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 => uint256) internal tokensBurnedPerQuarter; // amount of token burned in a quarter\\r\\n    mapping(uint256 => Records) public quarterTVLMapping; //mapping for TVL of every quarter\\r\\n    mapping(bytes32 => VestingSchedule) private vestingSchedules; // mapping of vesting schedule Id to the details of the vesting schedule\\r\\n    mapping(address => uint256) private holdersVestingCount; // total vestin count of a given holder\\r\\n    mapping(uint256 => Categories) public categoryMapping; // category Id to description mapping\\r\\n    mapping(uint256 => TokenDistribution) public distributionMapping; // category Id to its token distribution mapping\\r\\n    mapping(uint256 => bool) public existsMapping; // to confirm is cateogry Id mapping exists or not .\\r\\n    mapping(uint256 => uint256) QuarterBalanceForIssuance; // amount issued for 3 categories\\r\\n    mapping(address => uint256[]) internal memberCategoryMapping; // member belonging to a particular category mapping\\r\\n    mapping(bytes32 => uint256) public vestingScheduleCategoryMapping; // vesting schedules to category Mapping\\r\\n    /**\\r\\n     * @notice Emitted after a category is added\\r\\n     * @param _memberAddress address of the new member in category\\r\\n     * @param _categoryID Id oof the category\\r\\n     */\\r\\n    event AddAddressForCategory(address _memberAddress, uint256 _categoryID);\\r\\n    /**\\r\\n     * @notice Emitted after a category is created\\r\\n     * @param _categoryName name of category\\r\\n     * @param _memberAddresses array of member addresses to be added\\r\\n     * @param _cliff of the vesting schedule for category\\r\\n     * @param _duration of vesting schedule for category\\r\\n     * @param _slicePeriodSeconds slice period in seconds\\r\\n     * @param _revocable category vesting schedules revokable or not bool.\\r\\n     * @param _categoryId category Id\\r\\n     */\\r\\n    event CategoryCreated(\\r\\n        string _categoryName,\\r\\n        address[] _memberAddresses,\\r\\n        uint256 _cliff,\\r\\n        uint256 _duration,\\r\\n        uint256 _slicePeriodSeconds,\\r\\n        bool _revocable,\\r\\n        uint256 _categoryId\\r\\n    );\\r\\n    /**\\r\\n     * @notice Emitted after new tokens are issues\\r\\n     * @param _amount number of tokens added\\r\\n     * @param _sentAddress address where the new tokens are added\\r\\n     */\\r\\n    event TokensIssued(uint256 _amount, address _sentAddress);\\r\\n    /**\\r\\n     * @notice Emitted when vesting schedule is created\\r\\n     * @param _vestingSchedule vesting schedule details\\r\\n     * @param _categoryId Id of category\\r\\n     */\\r\\n    event VestingScheduleCreation(VestingSchedule _vestingSchedule, uint256 _categoryId);\\r\\n    /**\\r\\n     * @notice Emitted when vesting schedule is revoked\\r\\n     * @param _vestingSchedule vesting schedule details\\r\\n     * @param _revoked bool\\r\\n     */\\r\\n    event RevokedSchedule(VestingSchedule _vestingSchedule, bool _revoked);\\r\\n    /**\\r\\n     * @notice Emitted when pause status is changed\\r\\n     * @param _status value of new status\\r\\n     */\\r\\n    event PauseStatusChanged(bool _status);\\r\\n    /**\\r\\n     * @notice Emitted when new token distribution is added\\r\\n     * @param _distribution new token distribution\\r\\n     */\\r\\n    event TokenDistributionAdded(TokenDistribution _distribution);\\r\\n    /**\\r\\n     * @notice Emitted TVL is recorded\\r\\n     * @param _quarterId Id of the quarter\\r\\n     * @param _time  when tvl was recorded\\r\\n     * @param _amount tvl amount\\r\\n     */\\r\\n    event RecordedTVL(uint256 _quarterId, uint256 _time, uint256 _amount);\\r\\n    /**\\r\\n     * @notice Emitted when quarter starts\\r\\n     * @param _quarterId Id of the quarter\\r\\n     * @param _timestamp  when quarter started\\r\\n     */\\r\\n    event QuarterStart(uint256 _quarterId, uint256 _timestamp);\\r\\n    /**\\r\\n     * @notice Emitted when max schedules allowed value changed\\r\\n     * @param _maxschedules new value of max schedules\\r\\n     */\\r\\n    event VestingScheduleMaxChanged(uint256 _maxschedules);\\r\\n    /**\\r\\n     * @notice Emitted when max categories allowed value changed\\r\\n     * @param _maxcategories new value of max categories\\r\\n     */\\r\\n    event CategoriesMaxChanged(uint256 _maxcategories);\\r\\n\\r\\n    event Released(uint256 _amount); // event fo amount released\\r\\n    /**\\r\\n     * @notice Emitted a BruRewards contract start a rewards interval for a pool\\r\\n     * @param _emissionAmount new value of max categories\\r\\n     */\\r\\n    event RewardsDistributed(uint256 _emissionAmount);\\r\\n\\r\\n    /**\\r\\n     * @dev Only owner can call functions marked by this modifier.\\r\\n     *\\r\\n     */\\r\\n    modifier onlyDeployer() {\\r\\n        require(msg.sender == deployer, \\\"only deployer allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     *\\r\\n     */\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == adminAddress, \\\"only admin allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev checks the pause condition for functions .\\r\\n     *\\r\\n     */\\r\\n    modifier checkPauseStatus() {\\r\\n        require(!pause, \\\"Core functionalities disabled\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Reverts if the vesting schedule does not exist or has been revoked.\\r\\n     */\\r\\n    modifier onlyIfVestingScheduleNotRevoked(bytes32 _vestingScheduleId) {\\r\\n        require(vestingSchedules[_vestingScheduleId].initialized);\\r\\n        require(!vestingSchedules[_vestingScheduleId].revoked);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the deployed contract with given parameters\\r\\n     * @param _token The address of the token\\r\\n     * @param _adminAddress The address of admin\\r\\n     * @param _NIIWalletAddress The address of NII Wallet contract\\r\\n     * @param _bruRewardsAddress The address of BruReward contract\\r\\n     * @param _factoryAddress The address of Factory contract\\r\\n     * @param _bruOracleAddress The address of BruOracle contract\\r\\n     */\\r\\n    function initialize(\\r\\n        address _token,\\r\\n        address _adminAddress,\\r\\n        address _NIIWalletAddress,\\r\\n        address _bruRewardsAddress,\\r\\n        address _factoryAddress,\\r\\n        address _bruOracleAddress\\r\\n    ) external virtual initializer {\\r\\n        require(\\r\\n            _token != address(0) &&\\r\\n                _adminAddress != address(0) &&\\r\\n                _NIIWalletAddress != address(0) &&\\r\\n                _bruRewardsAddress != address(0) &&\\r\\n                _factoryAddress != address(0) &&\\r\\n                _bruOracleAddress != address(0),\\r\\n            \\\"Invalid Address\\\"\\r\\n        );\\r\\n        token = Token(_token);\\r\\n        adminAddress = _adminAddress;\\r\\n        categoryId = 1;\\r\\n        maxVestingSchedules = 5;\\r\\n        maxCategories = 10;\\r\\n        NIIWalletAddress = _NIIWalletAddress;\\r\\n        bruRewardsAddress = _bruRewardsAddress;\\r\\n        factoryAddress = _factoryAddress;\\r\\n        bruOracleAddress = _bruOracleAddress;\\r\\n        deployer = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Release vested amount of tokens.\\r\\n     * @param _vestingScheduleId the vesting schedule identifier\\r\\n     * @param _amount the amount to release\\r\\n     */\\r\\n    function release(bytes32 _vestingScheduleId, uint256 _amount)\\r\\n        public\\r\\n        onlyIfVestingScheduleNotRevoked(_vestingScheduleId)\\r\\n        checkPauseStatus\\r\\n    {\\r\\n        VestingSchedule storage vestingSchedule = vestingSchedules[_vestingScheduleId];\\r\\n        bool isBeneficiary = msg.sender == vestingSchedule.beneficiary;\\r\\n        bool isOwner = msg.sender == deployer;\\r\\n        require(isBeneficiary || isOwner, \\\"TokenVesting: only beneficiary and owner can release vested tokens\\\");\\r\\n        uint256 vestedAmount = computeReleasableAmount(vestingSchedule);\\r\\n\\r\\n        require(vestedAmount >= _amount, \\\"TokenVesting: cannot release tokens, not enough vested tokens\\\");\\r\\n        vestingSchedule.released = vestingSchedule.released + _amount;\\r\\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - _amount;\\r\\n        IERC20(address(token)).safeTransfer(vestingSchedule.beneficiary, _amount);\\r\\n        emit Released(_amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of vesting schedules managed by this contract.\\r\\n     * @return the number of vesting schedules\\r\\n     */\\r\\n    function getVestingSchedulesCount() public view returns (uint256) {\\r\\n        return vestingSchedulesIds.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the vesting schedule information for a given identifier.\\r\\n     * @return the vesting schedule structure information\\r\\n     */\\r\\n    function getVestingSchedule(bytes32 _vestingScheduleId) public view returns (VestingSchedule memory) {\\r\\n        return vestingSchedules[_vestingScheduleId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Computes the vesting schedule identifier for an address and an index.\\r\\n     * @param _holder address of the holder\\r\\n     * @param _index index in array\\r\\n     * @return vesting schedule Id\\r\\n     */\\r\\n    function computeVestingScheduleIdForAddressAndIndex(address _holder, uint256 _index) public pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(_holder, _index));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of vesting schedules associated to a beneficiary.\\r\\n     * @return the number of vesting schedules\\r\\n     */\\r\\n    function getVestingSchedulesCountByBeneficiary(address _beneficiary) external view returns (uint256) {\\r\\n        return holdersVestingCount[_beneficiary];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the vesting schedule id at the given index.\\r\\n     * @return the vesting id\\r\\n     */\\r\\n    function getVestingIdAtIndex(uint256 _index) external view returns (bytes32) {\\r\\n        require(_index < getVestingSchedulesCount(), \\\"TokenVesting: index out of bounds\\\");\\r\\n        return vestingSchedulesIds[_index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the vesting schedule information for a given holder and index.\\r\\n     * @return the vesting schedule structure information\\r\\n     */\\r\\n    function getVestingScheduleByAddressAndIndex(address _holder, uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (VestingSchedule memory)\\r\\n    {\\r\\n        return getVestingSchedule(computeVestingScheduleIdForAddressAndIndex(_holder, _index));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the vesting schedule total amount noted.\\r\\n     * @return the vesting schedule total amount\\r\\n     */\\r\\n    function getVestingSchedulesTotalAmount() external view returns (uint256) {\\r\\n        return vestingSchedulesTotalAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the token contract address\\r\\n     * @return token contract address of bru token\\r\\n     */\\r\\n    function getToken() external view returns (address) {\\r\\n        return address(token);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice sets the paramters of the category for the given categoryID\\r\\n     * @param _categoryName name of category\\r\\n     * @param _memberAddresses the array of address of the members of category\\r\\n     * @param _cliff Cliff for the category\\r\\n     * @param _duration duration for the category\\r\\n     * @param _slicePeriodSeconds slice period of the category\\r\\n     * @param _revocable property of category\\r\\n     */\\r\\n    function setCategoryParams(\\r\\n        string memory _categoryName,\\r\\n        address[] memory _memberAddresses,\\r\\n        uint256 _cliff,\\r\\n        uint256 _duration,\\r\\n        uint256 _slicePeriodSeconds,\\r\\n        bool _revocable\\r\\n    ) external onlyDeployer {\\r\\n        require(categoryId < maxCategories + 1, \\\"max categories reaches\\\");\\r\\n        categoryMapping[categoryId] = Categories(\\r\\n            _categoryName,\\r\\n            _memberAddresses,\\r\\n            _cliff,\\r\\n            _duration,\\r\\n            _slicePeriodSeconds,\\r\\n            _revocable\\r\\n        );\\r\\n        existsMapping[categoryId] = true;\\r\\n        for (uint256 i = 0; i < _memberAddresses.length; i++) {\\r\\n            memberCategoryMapping[_memberAddresses[i]].push(categoryId);\\r\\n            emit AddAddressForCategory(_memberAddresses[i], categoryId);\\r\\n        }\\r\\n        categoryId++;\\r\\n        emit CategoryCreated(\\r\\n            _categoryName,\\r\\n            _memberAddresses,\\r\\n            _cliff,\\r\\n            _duration,\\r\\n            _slicePeriodSeconds,\\r\\n            _revocable,\\r\\n            categoryId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the category parameters\\r\\n     * @return returns struct of category params\\r\\n     */\\r\\n    function getCategoryParams(uint256 _categoryId) external view returns (Categories memory) {\\r\\n        return categoryMapping[_categoryId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice add member address to a category\\r\\n     * @param _walletAddress address of the member\\r\\n     * @param _categoryId category Id of the category\\r\\n     */\\r\\n\\r\\n    function addAddressToCategory(address _walletAddress, uint256 _categoryId) external onlyDeployer {\\r\\n        require(_walletAddress != address(0), \\\"zero address not allowed\\\");\\r\\n        categoryMapping[_categoryId].memberAddresses.push(_walletAddress);\\r\\n        memberCategoryMapping[_walletAddress].push(categoryId);\\r\\n        emit AddAddressForCategory(_walletAddress, _categoryId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Creates a new vesting schedule for a beneficiary.\\r\\n     * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\\r\\n     * @param _start start time of the vesting\\r\\n     * @param _amount total amount of tokens to be released at the end of the vesting\\r\\n     */\\r\\n    function createVestingScheduleForCategory(\\r\\n        uint256 _amount,\\r\\n        uint256 _start,\\r\\n        address _beneficiary,\\r\\n        uint256 _categoryId\\r\\n    ) external onlyDeployer checkPauseStatus {\\r\\n        bool _temp = false;\\r\\n        for (uint256 j = 0; j < memberCategoryMapping[_beneficiary].length; j++) {\\r\\n            if (memberCategoryMapping[_beneficiary][j] == _categoryId) _temp = true;\\r\\n        }\\r\\n        if (_categoryId != 0 && _temp) {\\r\\n            vestingInternal(\\r\\n                _amount,\\r\\n                categoryMapping[_categoryId].duration,\\r\\n                categoryMapping[_categoryId].slicePeriodSeconds,\\r\\n                _categoryId,\\r\\n                _beneficiary,\\r\\n                categoryMapping[_categoryId].cliff,\\r\\n                _start,\\r\\n                categoryMapping[_categoryId].revocable\\r\\n            );\\r\\n        } else {\\r\\n            revert(\\\"category passed as 0 or beneficiary does not belong to this category\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Creates a new vesting schedule for a beneficiary.\\r\\n     * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\\r\\n     * @param _start start time of the vesting period\\r\\n     * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\\r\\n     * @param _duration duration in seconds of the period in which the tokens will vest\\r\\n     * @param _slicePeriodSeconds duration of a slice period for the vesting in seconds\\r\\n     * @param _revocable whether the vesting is revocable or not\\r\\n     * @param _amount total amount of tokens to be released at the end of the vesting\\r\\n     * @param _categoryId Id of the category to which it belongs\\r\\n     */\\r\\n    function createVestingSchedule(\\r\\n        address _beneficiary,\\r\\n        uint256 _start,\\r\\n        uint256 _cliff,\\r\\n        uint256 _duration,\\r\\n        uint256 _slicePeriodSeconds,\\r\\n        bool _revocable,\\r\\n        uint256 _amount,\\r\\n        uint8 _categoryId\\r\\n    ) external onlyDeployer checkPauseStatus nonReentrant {\\r\\n        categoryMapping[_categoryId].memberAddresses.push(_beneficiary);\\r\\n        memberCategoryMapping[_beneficiary].push(_categoryId);\\r\\n        vestingInternal(_amount, _duration, _slicePeriodSeconds, _categoryId, _beneficiary, _cliff, _start, _revocable);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice changes the max allowed vesting schedules for single address\\r\\n     * @param _newMaxSchedule new value for  max allowed vesting schedules\\r\\n     */\\r\\n    function changeMaxVestingSchedules(uint256 _newMaxSchedule) external virtual onlyAdmin {\\r\\n        maxVestingSchedules = _newMaxSchedule;\\r\\n        emit VestingScheduleMaxChanged(_newMaxSchedule);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice changes the max allowed categories\\r\\n     * @param _newMaxCategories new value for max allowed categories\\r\\n     */\\r\\n    function changeMaxCategories(uint256 _newMaxCategories) external virtual onlyAdmin {\\r\\n        maxCategories = _newMaxCategories;\\r\\n        emit CategoriesMaxChanged(_newMaxCategories);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Revokes the vesting schedule for given identifier.\\r\\n     * @param _vestingScheduleId the vesting schedule identifier\\r\\n     */\\r\\n    function revoke(bytes32 _vestingScheduleId, uint256 _categoryId)\\r\\n        external\\r\\n        onlyDeployer\\r\\n        onlyIfVestingScheduleNotRevoked(_vestingScheduleId)\\r\\n        checkPauseStatus\\r\\n    {\\r\\n        require(\\r\\n            vestingScheduleCategoryMapping[_vestingScheduleId] == _categoryId,\\r\\n            \\\"vesting schedule does not belong to this category\\\"\\r\\n        );\\r\\n        VestingSchedule storage vestingSchedule = vestingSchedules[_vestingScheduleId];\\r\\n        require(vestingSchedule.revocable, \\\"TokenVesting: vesting is not revocable\\\");\\r\\n        uint256 vestedAmount = computeReleasableAmount(vestingSchedule);\\r\\n        if (vestedAmount > 0) {\\r\\n            release(_vestingScheduleId, vestedAmount);\\r\\n        }\\r\\n        uint256 unreleased = vestingSchedule.amountTotal - vestingSchedule.released;\\r\\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - unreleased;\\r\\n\\r\\n        for (uint256 j = 0; j < memberCategoryMapping[vestingSchedule.beneficiary].length; j++) {\\r\\n            distributionMapping[_categoryId].tokenAmountleft += unreleased;\\r\\n        }\\r\\n        vestingSchedule.revoked = true;\\r\\n        emit RevokedSchedule(vestingSchedule, vestingSchedule.revoked);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Withdraw the specified amount if possible.\\r\\n     * @param _amount the amount to withdraw\\r\\n     */\\r\\n    function withdraw(uint256 _amount) external onlyDeployer {\\r\\n        require(this.getWithdrawableAmount() >= _amount, \\\"TokenVesting: not enough withdrawable funds\\\");\\r\\n        IERC20(address(token)).safeTransfer(deployer, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice change the pause status of the contract\\r\\n     */\\r\\n    function changePauseStatus() external onlyAdmin {\\r\\n        pause = !pause;\\r\\n        emit PauseStatusChanged(pause);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice adding the token distribution of a given category.\\r\\n     * @param _categoryId category Id for adding distribution.\\r\\n     * @param _tokenPercentage the token percentage of a given category\\r\\n     */\\r\\n    function addTokenDistribution(uint256 _categoryId, uint256 _tokenPercentage) external onlyAdmin nonReentrant {\\r\\n        require(distributionMapping[_categoryId].tokenPercentage == 0, \\\"distribution already added\\\");\\r\\n        require(totalPercentageUsed + _tokenPercentage <= 100, \\\"percentage not allowed\\\");\\r\\n        distributionMapping[_categoryId] = TokenDistribution(\\r\\n            (token.getInitialSupply() * (_tokenPercentage)) / (100),\\r\\n            _tokenPercentage\\r\\n        );\\r\\n        totalPercentageUsed += _tokenPercentage;\\r\\n        emit TokenDistributionAdded(distributionMapping[_categoryId]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the vested amount of tokens for the given vesting schedule identifier.\\r\\n     * @param _vestingScheduleId schedule Id of the vesting schedule\\r\\n     * @return the vested amount\\r\\n     */\\r\\n    function computeReleasableAmount(bytes32 _vestingScheduleId)\\r\\n        external\\r\\n        view\\r\\n        onlyIfVestingScheduleNotRevoked(_vestingScheduleId)\\r\\n        returns (uint256)\\r\\n    {\\r\\n        VestingSchedule storage vestingSchedule = vestingSchedules[_vestingScheduleId];\\r\\n        return computeReleasableAmount(vestingSchedule);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens that can be withdrawn by the owner.\\r\\n     * @return the amount of tokens\\r\\n     */\\r\\n    function getWithdrawableAmount() external view returns (uint256) {\\r\\n        return token.balanceOf(address(this)) - vestingSchedulesTotalAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Computes the next vesting schedule identifier for a given holder address.\\r\\n     * _holder address of the vesting schedule holder\\r\\n     */\\r\\n    function computeNextVestingScheduleIdForHolder(address _holder) external view returns (bytes32) {\\r\\n        return computeVestingScheduleIdForAddressAndIndex(_holder, holdersVestingCount[_holder]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice records TVL for a given time and quarter\\r\\n     */\\r\\n    function recordTVL() external onlyDeployer {\\r\\n        require(\\r\\n            block.timestamp - quarterTVLMapping[quarterId].timeStamp >= QUARTER_TIME,\\r\\n            \\\"3 months have not passed yet\\\"\\r\\n        );\\r\\n        if (quarterTVLMapping[quarterId].initialQuarterBalance == 0) {\\r\\n            quarterTVLMapping[quarterId].initialQuarterBalance = calculateSum();\\r\\n            emit RecordedTVL(\\r\\n                quarterId,\\r\\n                quarterTVLMapping[quarterId].timeStamp,\\r\\n                quarterTVLMapping[quarterId].initialQuarterBalance\\r\\n            );\\r\\n        } else if (quarterTVLMapping[quarterId].finalQuarterBalance == 0) {\\r\\n            quarterTVLMapping[quarterId].finalQuarterBalance = calculateSum();\\r\\n\\r\\n            if (\\r\\n                quarterTVLMapping[quarterId].initialQuarterBalance > MINIMUM_POOL_TVL &&\\r\\n                quarterTVLMapping[quarterId].finalQuarterBalance > MINIMUM_POOL_TVL &&\\r\\n                quarterTVLMapping[quarterId].finalQuarterBalance > quarterTVLMapping[quarterId].initialQuarterBalance\\r\\n            ) {\\r\\n                uint256 temp = quarterTVLMapping[quarterId].finalQuarterBalance -\\r\\n                    quarterTVLMapping[quarterId].initialQuarterBalance;\\r\\n                uint256 percentage = ((temp) * (10**20)) / (quarterTVLMapping[quarterId].initialQuarterBalance);\\r\\n                issueTokens(percentage);\\r\\n            }\\r\\n            emit RecordedTVL(\\r\\n                quarterId,\\r\\n                quarterTVLMapping[quarterId].timeStamp,\\r\\n                quarterTVLMapping[quarterId].finalQuarterBalance\\r\\n            );\\r\\n        } else {\\r\\n            revert(\\\"TVL already recorded for this quater\\\");\\r\\n        }\\r\\n        quarterTVLMapping[quarterId].timeStamp = block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice starts quarter\\r\\n     */\\r\\n    function startQuarter() external onlyDeployer {\\r\\n        require(block.timestamp - lastStarted >= QUARTER_TIME);\\r\\n        quarterId++;\\r\\n        lastStarted = block.timestamp;\\r\\n        emit QuarterStart(quarterId, lastStarted);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice it is used to transfer token to the BruRewards contract\\r\\n     * @param _emissionAmount the amount of token to be emmited during a reward interval\\r\\n     */\\r\\n    function distributeRewards(uint256 _emissionAmount) external {\\r\\n        require(msg.sender == bruRewardsAddress, \\\"only BruRewards can access this\\\");\\r\\n        distributionMapping[1].tokenAmountleft -= _emissionAmount;\\r\\n        IERC20(address(token)).safeTransfer(bruRewardsAddress, _emissionAmount);\\r\\n        emit RewardsDistributed(_emissionAmount);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n     * @notice issues new token according to last quarter TVL.\\r\\n     * @param _risePercentage percentage growth in last quarter.\\r\\n     */\\r\\n    function issueTokens(uint256 _risePercentage) internal {\\r\\n        uint256 totalAmount;\\r\\n        uint256 toMint;\\r\\n\\r\\n        totalAmount = QuarterBalanceForIssuance[quarterId];\\r\\n\\r\\n        uint256 calculateTVLamount = (totalAmount * (_risePercentage)) / (10**20);\\r\\n        uint256 burntAmount = (tokensBurnedPerQuarter[quarterId] * (995)) / (1000);\\r\\n        if (calculateTVLamount < burntAmount) {\\r\\n            toMint += calculateTVLamount;\\r\\n        } else {\\r\\n            toMint += burntAmount;\\r\\n        }\\r\\n        token.mintNew(address(this), toMint);\\r\\n        emit TokensIssued(toMint, address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Computes the releasable amount of tokens for a vesting schedule.\\r\\n     * @param _vestingSchedule vesting scheudle structure to calculate amount .\\r\\n     * @return the amount of releasable tokens\\r\\n     */\\r\\n    function computeReleasableAmount(VestingSchedule memory _vestingSchedule) internal view returns (uint256) {\\r\\n        uint256 currentTime = block.timestamp;\\r\\n        if ((currentTime < _vestingSchedule.cliff) || _vestingSchedule.revoked) {\\r\\n            return 0;\\r\\n        } else if (currentTime >= _vestingSchedule.start + _vestingSchedule.duration) {\\r\\n            return _vestingSchedule.amountTotal - _vestingSchedule.released;\\r\\n        } else {\\r\\n            uint256 timeFromStart = currentTime - _vestingSchedule.start;\\r\\n            uint256 secondsPerSlice = _vestingSchedule.slicePeriodSeconds;\\r\\n            uint256 vestedSlicePeriods = timeFromStart / (secondsPerSlice);\\r\\n            uint256 vestedSeconds = vestedSlicePeriods * (secondsPerSlice);\\r\\n            uint256 vestedAmount = (_vestingSchedule.amountTotal * (vestedSeconds)) / (_vestingSchedule.duration);\\r\\n            vestedAmount = vestedAmount - _vestingSchedule.released;\\r\\n            return vestedAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice used to create the vesting schedules with the given info\\r\\n     * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\\r\\n     * @param _start start time of the vesting period\\r\\n     * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\\r\\n     * @param _duration duration in seconds of the period in which the tokens will vest\\r\\n     * @param _slicePeriodSeconds duration of a slice period for the vesting in seconds\\r\\n     * @param _revocable whether the vesting is revocable or not\\r\\n     * @param _amount total amount of tokens to be released at the end of the vesting\\r\\n     * @param _categoryId Id of the category to which it belongs\\r\\n     */\\r\\n    function vestingInternal(\\r\\n        uint256 _amount,\\r\\n        uint256 _duration,\\r\\n        uint256 _slicePeriodSeconds,\\r\\n        uint256 _categoryId,\\r\\n        address _beneficiary,\\r\\n        uint256 _cliff,\\r\\n        uint256 _start,\\r\\n        bool _revocable\\r\\n    ) internal {\\r\\n        require(existsMapping[_categoryId] && _beneficiary != address(0), \\\"incorrect category/address\\\");\\r\\n        require(holdersVestingCount[_beneficiary] <= maxVestingSchedules, \\\"max limit for schedules reached\\\");\\r\\n        require(\\r\\n            this.getWithdrawableAmount() >= _amount,\\r\\n            \\\"TokenVesting: cannot create vesting schedule because not sufficient tokens\\\"\\r\\n        );\\r\\n        require(distributionMapping[_categoryId].tokenAmountleft >= _amount, \\\"insufficient balance\\\");\\r\\n        require(_duration > 0, \\\"TokenVesting: duration must be > 0\\\");\\r\\n        require(_amount > 0, \\\"TokenVesting: amount must be > 0\\\");\\r\\n        require(_slicePeriodSeconds >= 1, \\\"TokenVesting: slicePeriodSeconds must be >= 1\\\");\\r\\n        bytes32 _vestingScheduleId = this.computeNextVestingScheduleIdForHolder(_beneficiary);\\r\\n        uint256 cliff = _start + _cliff;\\r\\n        vestingSchedules[_vestingScheduleId] = VestingSchedule(\\r\\n            true,\\r\\n            _beneficiary,\\r\\n            cliff,\\r\\n            _start,\\r\\n            _duration,\\r\\n            _slicePeriodSeconds,\\r\\n            _revocable,\\r\\n            _amount,\\r\\n            0,\\r\\n            false\\r\\n        );\\r\\n        distributionMapping[_categoryId].tokenAmountleft -= _amount;\\r\\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount + _amount;\\r\\n        vestingSchedulesIds.push(_vestingScheduleId);\\r\\n        uint256 currentVestingCount = holdersVestingCount[_beneficiary];\\r\\n        holdersVestingCount[_beneficiary] = currentVestingCount + 1;\\r\\n        vestingScheduleCategoryMapping[_vestingScheduleId] = _categoryId;\\r\\n\\r\\n        if (_categoryId == 2 || _categoryId == 3 || _categoryId == 4) {\\r\\n            QuarterBalanceForIssuance[quarterId] += _amount;\\r\\n        }\\r\\n        emit VestingScheduleCreation(vestingSchedules[_vestingScheduleId], _categoryId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice calculates sum of TVL of all the pools when called .\\r\\n     */\\r\\n    function calculateSum() internal view returns (uint256) {\\r\\n        PoolDetails[] memory tempPoolDetailsArray = BruFactory(factoryAddress).getAllPoolDetails();\\r\\n        uint256 sum = 0;\\r\\n        for (uint32 i = 0; i < tempPoolDetailsArray.length; i++) {\\r\\n            address[] memory tokenAddressArray = BruPool(tempPoolDetailsArray[i].proxyPoolAddress)\\r\\n                .getAllowedTokenAddressesArray();\\r\\n            for (uint8 j = 0; j < tokenAddressArray.length; j++) {\\r\\n                //fetch the conversion value from oracle according to token address\\r\\n\\r\\n                uint256 tokenPriceinUSD = uint256(\\r\\n                    BruOracle(bruOracleAddress).getLatestPriceOfTokenInUSD(tokenAddressArray[j])\\r\\n                );\\r\\n                uint256 priceFeedDecimals = BruOracle(bruOracleAddress).getPriceFeedDecimal(tokenAddressArray[j]);\\r\\n                uint256 temp = IERC20(tokenAddressArray[i]).balanceOf(tempPoolDetailsArray[i].proxyPoolAddress);\\r\\n                uint256 decimal = ERC20(tokenAddressArray[i]).decimals();\\r\\n                if (decimal < 18) {\\r\\n                    temp = temp * 10**(18 - decimal);\\r\\n                } else if (decimal > 18) {\\r\\n                    temp = temp / 10**(decimal - 18);\\r\\n                }\\r\\n                temp = (temp * tokenPriceinUSD) / 10**(priceFeedDecimals);\\r\\n                sum += temp;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return sum / 10**18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks the wallet address which initiates the upgrade transaction for TokenVesting contract\\r\\n     * @param _newImplementation Address of the new implementation contract which is used for upgradation.\\r\\n     */\\r\\n    function _authorizeUpgrade(address _newImplementation) internal view override {\\r\\n        require(msg.sender == adminAddress, \\\"Only admin allowed\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/wallets/NIIMargin.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\nimport \\\"../vesting/Token.sol\\\";\\r\\nimport \\\"./ReserveWallet.sol\\\";\\r\\n\\r\\nstruct CashFlowDetails {\\r\\n    uint256 starttime;\\r\\n    uint256 amountLeft;\\r\\n    uint256 totalAmountToDistribute;\\r\\n    address tokenAddress;\\r\\n    bool status;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title NII margin contract\\r\\n * @author Bru-finance team\\r\\n * @notice Store funds received from fees and interest. The interest expense and other company expenses are given from this wallet\\r\\n */\\r\\ncontract NIIMargin is Initializable, UUPSUpgradeable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    uint256 public claimId = 0; // claim id\\r\\n    // @notice The address of Multisig wallet\\r\\n    address public adminAddress;\\r\\n    address internal reserveWalletAddress; // address of reserve Wallet\\r\\n    address internal poolAddress; // address of oool\\r\\n    address internal owner; // address of owner\\r\\n    address internal burnContractAddress; // address of Vesting burn contract\\r\\n    address internal bruTokenAddress; // address of bru token contract\\r\\n    address internal tokenAddressForCashflow; // address of token in which cashflow will be distributed\\r\\n    address internal unClaimedWalletAddress; // address of unclaimed Wallet\\r\\n    mapping(address => mapping(uint256 => bool)) public cashFlowClaimMapping; // mapping to check if the user has claimed their part for a given claimId\\r\\n    mapping(uint256 => CashFlowDetails) public cashFlowDetailsMapping; // mapping of cashflow details for a given claim Id\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when claim period started\\r\\n     * @param _claimId claim id\\r\\n     * @param _tokenAddress address of the token of which we want to divide the cashflow\\r\\n     */\\r\\n    event ClaimPeriodStarted(uint256 _claimId, address _tokenAddress);\\r\\n    /**\\r\\n     * @notice Emitted when claim period stopped\\r\\n     * @param _claimId claim id\\r\\n     */\\r\\n    event ClaimPeriodStopped(uint256 _claimId);\\r\\n    /**\\r\\n     * @notice Emitted when cashflow details are set for a given claimId\\r\\n     * @param _claimId claim id\\r\\n     * @param _cashFlowDetails Cashflowdetails structure\\r\\n     */\\r\\n    event SetCashflowDetails(uint256 _claimId, CashFlowDetails _cashFlowDetails);\\r\\n    /**\\r\\n     * @notice Emitted when user claims a dividend and mapping is updated\\r\\n     * @param _claimId claim id\\r\\n     * @param _ownerAddress address Of the owner who claims the dividend\\r\\n     * @param _claimed boolean for confirming the user has claimed the dividend for given claimId\\r\\n     */\\r\\n    event SetCashflowClaimed(bool _claimed, address _ownerAddress, uint256 _claimId);\\r\\n    /**\\r\\n     * @dev Only admin can call functions marked by this modifier.\\r\\n     *\\r\\n     */\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == adminAddress, \\\"Can be used only by adminAddress\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Only unClaimedWalletAddress can call functions marked by this modifier.\\r\\n     *\\r\\n     */\\r\\n    modifier onlyUnClaimedWallet() {\\r\\n        require(msg.sender == unClaimedWalletAddress, \\\"Only called by unclaimed wallet address\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Only admin, pool and burn wallet can call functions marked by this modifier.\\r\\n     *\\r\\n     */\\r\\n    modifier onlyPoolOrAdminOrBurnContract() {\\r\\n        require(\\r\\n            msg.sender == adminAddress || msg.sender == poolAddress || msg.sender == burnContractAddress,\\r\\n            \\\"Only allowed by admin or pool or burn contract\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the neccessary variables for the contract\\r\\n     * @param _reserveWalletAddress The address of ReserveWallet contract\\r\\n     * @param _adminAddress The address of Multisig wallet\\r\\n     * @param _poolAddress The address of the pool\\r\\n     * @param _burnContractAddress The address of burnWallet contract address\\r\\n     * @param _bruTokenAddress The address of the bru token\\r\\n     * @param _tokenAddressForCashflow The address of the token in which cashflow is distributed\\r\\n     * @param _unClaimedWalletAddress The address of the unclaimed wallet contract\\r\\n     */\\r\\n    function initialize(\\r\\n        address _reserveWalletAddress,\\r\\n        address _adminAddress,\\r\\n        address _poolAddress,\\r\\n        address _burnContractAddress,\\r\\n        address _bruTokenAddress,\\r\\n        address _tokenAddressForCashflow,\\r\\n        address _unClaimedWalletAddress\\r\\n    ) external initializer {\\r\\n        require(\\r\\n            _reserveWalletAddress != address(0) &&\\r\\n                _adminAddress != address(0) &&\\r\\n                _poolAddress != address(0) &&\\r\\n                _burnContractAddress != address(0) &&\\r\\n                _bruTokenAddress != address(0) &&\\r\\n                _tokenAddressForCashflow != address(0) &&\\r\\n                _unClaimedWalletAddress != address(0),\\r\\n            \\\"Invalid Address\\\"\\r\\n        );\\r\\n\\r\\n        adminAddress = _adminAddress;\\r\\n        reserveWalletAddress = _reserveWalletAddress;\\r\\n        poolAddress = _poolAddress;\\r\\n        burnContractAddress = _burnContractAddress;\\r\\n        owner = msg.sender;\\r\\n        bruTokenAddress = _bruTokenAddress;\\r\\n        tokenAddressForCashflow = _tokenAddressForCashflow;\\r\\n        unClaimedWalletAddress = _unClaimedWalletAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice To pay expenses or other parts from this wallet.\\r\\n     * @dev Only called by admin or pool or Burn contract\\r\\n     * @param _amount The amount of token to safeTransfer\\r\\n     * @param _tokenAddress The address of the token\\r\\n     * @param _receiverAddress The address of the receiver\\r\\n     */\\r\\n    function sendAmount(\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        address _receiverAddress\\r\\n    ) public onlyPoolOrAdminOrBurnContract {\\r\\n        if (\\r\\n            IERC20(_tokenAddress).balanceOf(address(this)) + IERC20(_tokenAddress).balanceOf(reserveWalletAddress) >=\\r\\n            _amount\\r\\n        ) {\\r\\n            if (_amount > IERC20(_tokenAddress).balanceOf(address(this))) {\\r\\n                _amount -= IERC20(_tokenAddress).balanceOf(address(this));\\r\\n                IERC20(_tokenAddress).safeTransfer(_receiverAddress, IERC20(_tokenAddress).balanceOf(address(this)));\\r\\n                transferFromReserve(_amount, _tokenAddress, _receiverAddress);\\r\\n            } else {\\r\\n                IERC20(_tokenAddress).safeTransfer(_receiverAddress, _amount);\\r\\n            }\\r\\n        } else {\\r\\n            revert(\\\"currently we do not have enough balance\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This function is get cashflow details of a given claimId\\r\\n     * @param  _claimId claim Id\\r\\n     * @return CashFlowDetails object of a given claim Id\\r\\n     */\\r\\n    function getCashFlowDetailsOfClaimId(uint256 _claimId) public view returns (CashFlowDetails memory) {\\r\\n        return cashFlowDetailsMapping[_claimId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to get the available wallet balance\\r\\n     * @param _tokenAddress The address of the token\\r\\n     * @return Returns amount of balance available\\r\\n     */\\r\\n    function getBalance(address _tokenAddress) external view returns (uint256) {\\r\\n        IERC20 tokenContract = IERC20(_tokenAddress);\\r\\n        return tokenContract.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This function allows the user to claim the dividend for current claimId.\\r\\n     */\\r\\n    function claimDividend() external {\\r\\n        require(cashFlowDetailsMapping[claimId].status, \\\"claim period ended try from different place\\\");\\r\\n        if (!cashFlowClaimMapping[msg.sender][claimId]) {\\r\\n            uint256 balance = Token(bruTokenAddress).balanceOfAtDate(\\r\\n                msg.sender,\\r\\n                cashFlowDetailsMapping[claimId].starttime\\r\\n            );\\r\\n            uint256 amountTotransfer = (balance * (cashFlowDetailsMapping[claimId].totalAmountToDistribute)) /\\r\\n                (Token(bruTokenAddress).totalSupplyOfAtDate(cashFlowDetailsMapping[claimId].starttime));\\r\\n            if (amountTotransfer > 0 && cashFlowDetailsMapping[claimId].amountLeft > amountTotransfer) {\\r\\n                cashFlowDetailsMapping[claimId].amountLeft -= amountTotransfer;\\r\\n                cashFlowClaimMapping[msg.sender][claimId] = true;\\r\\n                IERC20(tokenAddressForCashflow).safeTransfer(msg.sender, amountTotransfer);\\r\\n            }\\r\\n        } else {\\r\\n            revert(\\\"already claimed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This function is used to start claim Period\\r\\n     * @param _tokenAddress address of the token of which we want to divide the cashflow although for now this tokenAddress is not used as currently we are giving the cashflow in a fixed token\\r\\n     */\\r\\n    function startClaimPeriod(address _tokenAddress) external onlyAdmin {\\r\\n        uint256 amount = (IERC20(_tokenAddress).balanceOf(address(this)) * (16)) / (100);\\r\\n        uint256 time = Token(bruTokenAddress).createSnapshot();\\r\\n        cashFlowDetailsMapping[claimId] = CashFlowDetails(time, amount, amount, _tokenAddress, true);\\r\\n        emit ClaimPeriodStarted(claimId, _tokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice This function is used to stop claim Period\\r\\n     */\\r\\n    function stopClaimPeriod() external onlyAdmin {\\r\\n        cashFlowDetailsMapping[claimId].status = false;\\r\\n        claimId++;\\r\\n        IERC20(tokenAddressForCashflow).transfer(\\r\\n            unClaimedWalletAddress,\\r\\n            cashFlowDetailsMapping[claimId - 1].amountLeft\\r\\n        );\\r\\n        emit ClaimPeriodStopped(claimId - 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to set cashflow details of a given claimId\\r\\n     * @param  _cashflowDetails details to update\\r\\n     * @param _claimId claim Id\\r\\n     */\\r\\n    function setCashFlowDetailsOfClaimId(CashFlowDetails memory _cashflowDetails, uint256 _claimId)\\r\\n        external\\r\\n        onlyUnClaimedWallet\\r\\n    {\\r\\n        cashFlowDetailsMapping[_claimId] = _cashflowDetails;\\r\\n        emit SetCashflowDetails(_claimId, _cashflowDetails);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to set cashflow claimed mapping of a given claimId for a given owner\\r\\n     * @param  _claimId claim Id\\r\\n     * @param _owner address of the user to update the claimed bool\\r\\n     * @param _result value to update\\r\\n     */\\r\\n    function setCashFlowClaimedMapping(\\r\\n        uint256 _claimId,\\r\\n        address _owner,\\r\\n        bool _result\\r\\n    ) external onlyUnClaimedWallet {\\r\\n        cashFlowClaimMapping[_owner][_claimId] = _result;\\r\\n        emit SetCashflowClaimed(_result, _owner, _claimId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer tokens from the reserve in case the contract has insufficient balance\\r\\n     * @dev Only called if reserver wallet is set\\r\\n     * @param _amount The amount of token to be transferred\\r\\n     * @param _tokenAddress The address of the token\\r\\n     * @param _receiverAddress The address of token receiver\\r\\n     */\\r\\n    function transferFromReserve(\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        address _receiverAddress\\r\\n    ) internal {\\r\\n        ReserveWallet(reserveWalletAddress).transferTo(_receiverAddress, _amount, _tokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @dev Checks if the wallet initiating the upgrade transaction for a pool is the admin or not\\r\\n     *  @param _newImplementation Address of the new implementation contract for upgradation.\\r\\n     */\\r\\n    function _authorizeUpgrade(address _newImplementation) internal view override {\\r\\n        require(msg.sender == adminAddress, \\\"Only admin allowed\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/wallets/ReserveWallet.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Reserve Wallet contract\\r\\n * @author Bru-finance team\\r\\n * @notice Stores some amount as reserve incase expense is greater than the balance of NIImargin wallet\\r\\n */\\r\\ncontract ReserveWallet is Initializable, UUPSUpgradeable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    /// @notice The address of the admin\\r\\n    address public adminAddress; // The address of Multisig wallet\\r\\n    address internal NIIWalletAddress;\\r\\n\\r\\n    /**\\r\\n     * @dev Only NII wallet and admin address can call functions marked by this modifier\\r\\n     */\\r\\n    modifier onlyNIIWalletOrAdmin() {\\r\\n        require(msg.sender == NIIWalletAddress || msg.sender == adminAddress, \\\"Can be used only by NIIwallet\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the neccessary variables for the contract\\r\\n     * @param _adminAddress The address of Multisig wallet\\r\\n     * @param _NIIWalletAddress The address the NIIWallet contract\\r\\n     */\\r\\n    function initialize(address _adminAddress, address _NIIWalletAddress) external initializer {\\r\\n        require(_adminAddress != address(0) && _NIIWalletAddress != address(0), \\\"Invalid Address\\\");\\r\\n        adminAddress = _adminAddress;\\r\\n        NIIWalletAddress = _NIIWalletAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to get wallet's available balance\\r\\n     * @param _tokenAddress The address of the token\\r\\n     * @return Returns caller's balance\\r\\n     */\\r\\n    function getBalance(address _tokenAddress) external view returns (uint256) {\\r\\n        IERC20 tokenContract = IERC20(_tokenAddress);\\r\\n        return tokenContract.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer funds from reserve wallet to NII wallet.\\r\\n     * @dev Only called by NIIWallet address or admin\\r\\n     * @param _receiverAddress The address of token receiver\\r\\n     * @param _amount The amount of token to be transferred\\r\\n     * @param _tokenAddress The address of the token\\r\\n     */\\r\\n    function transferTo(\\r\\n        address _receiverAddress,\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress\\r\\n    ) external onlyNIIWalletOrAdmin {\\r\\n        require(IERC20(_tokenAddress).balanceOf(address(this)) >= _amount, \\\"reserve does not have enough liquidity\\\");\\r\\n        IERC20(_tokenAddress).safeTransfer(_receiverAddress, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks the wallet address which initiates the upgrade transaction for ReserveWallet contract\\r\\n     * @param _newImplementation Address of the new implementation contract which is used for upgradation.\\r\\n     */\\r\\n    function _authorizeUpgrade(address _newImplementation) internal view override {\\r\\n        require(msg.sender == adminAddress, \\\"Only admin allowed\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mintWalletAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"MintWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeMintWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_nftId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_commodityId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_dataHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_data\",\"type\":\"string\"}],\"name\":\"mintNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintWalletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AssetTreasury", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c345e8f86e7efbcb2cc4302b2de116e4ebb727ba000000000000000000000000eb4752dc86b72d1b81dedfec83d6082303e39c5c0000000000000000000000003b8935b7a6c0053599b50fd932ada6bad985942c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}