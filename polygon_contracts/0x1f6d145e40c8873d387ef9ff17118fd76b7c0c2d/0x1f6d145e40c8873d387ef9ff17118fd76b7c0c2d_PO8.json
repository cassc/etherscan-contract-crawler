{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function quote(\r\n        uint amountA,\r\n        uint reserveA,\r\n        uint reserveB\r\n    ) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set & change owner\r\n */\r\ncontract Ownable {\r\n    address private owner;\r\n\r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n\r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address\r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ninterface IFlashLoanReceiver {\r\n    function executeOperation(\r\n        address _token,\r\n        uint256 _amount,\r\n        uint256 _fee,\r\n        bytes calldata _params\r\n    ) external returns (bool);\r\n}\r\n\r\n/**\r\n *  Contract: Piece Of Eight - Powered by XUSD\r\n *  Appreciating Stable Coin Inheriting The IP Of XUSD by xSurge\r\n *  Visit xsurge.net to learn more about appreciating stable coins\r\n */\r\ncontract PO8 is IERC20, Ownable, ReentrancyGuard {\r\n\r\n    // token data\r\n    string private constant _name = \"Piece of Eight\";\r\n    string private constant _symbol = \"PO8\";\r\n    uint8 private constant _decimals = 6;\r\n    uint256 private constant precision = 10**18;\r\n\r\n    // 0 initial supply\r\n    uint256 private _totalSupply;\r\n\r\n    // balances\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    // address -> Fee Exemption\r\n    mapping(address => bool) public isTransferFeeExempt;\r\n\r\n    // Token Activation\r\n    bool public tokenActivated;\r\n\r\n    // PCS Router\r\n    IUniswapV2Router02 public router;\r\n\r\n    // Underlying Asset Is Underlying\r\n    IERC20 public immutable underlying;\r\n\r\n    // Swap Path From MATIC -> Underlying\r\n    address[] private path;\r\n\r\n    // Fees\r\n    uint256 public mintFee = 98000; // 2% mint fee\r\n    uint256 public sellFee = 98000; // 2% redeem fee\r\n    uint256 public transferFee = 100000; // 0% transfer fee\r\n    uint256 private constant feeDenominator = 10 ** 5;\r\n\r\n    // Flash Loan Provider\r\n    uint256 public flashLoanFee = 15;\r\n\r\n    // Fee Recipient\r\n    address public feeTo;\r\n\r\n    // Price Data Tracking\r\n    uint256[] public allPrices;\r\n    uint256[] public allPriceTimestamps;\r\n\r\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address public constant ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    // initialize some stuff\r\n    constructor(address underlying_, address router_, address feeTo_) {\r\n        require(goodAddress(feeTo_) == true, \"Invalid Address!\");\r\n        require(goodAddress(router_) == true, \"Invalid Address!\");\r\n        require(goodAddress(underlying_) == true, \"Invalid Address!\");\r\n\r\n        // set underlying\r\n        underlying = IERC20(underlying_);\r\n\r\n        // set router\r\n        router = IUniswapV2Router02(router_);\r\n\r\n        // set swap path\r\n        path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = underlying_;\r\n\r\n        // set fee recipient setter\r\n        feeTo = feeTo_;\r\n\r\n        // exempt deployer and fee setter\r\n        isTransferFeeExempt[msg.sender] = true;\r\n        isTransferFeeExempt[feeTo_] = true;\r\n\r\n        // let token show on etherscan\r\n        emit Transfer(address(0), msg.sender, 0);\r\n    }\r\n\r\n    /** Returns the total number of tokens in existence */\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /** Returns the number of tokens owned by `account` */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /** Returns the number of tokens `spender` can transfer from `holder` */\r\n    function allowance(\r\n        address holder,\r\n        address spender\r\n    ) external view override returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    /** Token Name */\r\n    function name() public pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /** Token Ticker Symbol */\r\n    function symbol() public pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /** Tokens decimals */\r\n    function decimals() public pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /** Approves `spender` to transfer `amount` tokens from caller */\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /** Transfer Function */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override nonReentrant returns (bool) {\r\n        if (recipient == msg.sender) {\r\n            _sell(amount, msg.sender);\r\n            return true;\r\n        } else {\r\n            return _transferFrom(msg.sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    /** Transfer Function */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override nonReentrant returns (bool) {\r\n        _allowances[sender][msg.sender] -= amount;\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    /** Internal Transfer */\r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        // make standard checks\r\n        require(\r\n            recipient != address(0) && sender != address(0),\r\n            \"Transfer To Zero\"\r\n        );\r\n        require(amount > 0, \"Transfer Amt Zero\");\r\n\r\n        // track price change\r\n        uint256 oldPrice = _calculatePrice();\r\n\r\n        // amount to give recipient\r\n        uint256 tAmount = (isTransferFeeExempt[sender] ||\r\n            isTransferFeeExempt[recipient])\r\n            ? amount\r\n            : amount * transferFee / feeDenominator;\r\n\r\n        // tax taken from transfer\r\n        uint256 tax = amount - tAmount;\r\n\r\n        // subtract from sender\r\n        _balances[sender] -= amount;\r\n\r\n        // give reduced amount to receiver\r\n        _balances[recipient] += tAmount;\r\n\r\n        // burn the tax\r\n        if (tax > 0 && _totalSupply > 0) {\r\n            // Take Fee\r\n            _takeFee(tax);\r\n            _totalSupply -= tax;\r\n            emit Transfer(sender, address(0), tax);\r\n        }\r\n\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n\r\n        // Transfer Event\r\n        emit Transfer(sender, recipient, tAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        Mint WhiteLabel Tokens With The Native Token ( Smart Chain MATIC )\r\n        This will purchase underlying with MATIC received\r\n        It will then mint tokens to `recipient` based on the number of stable coins received\r\n        `minOut` should be set to avoid the Transaction being front runned\r\n\r\n        @param recipient Account to receive minted WhiteLabel Tokens\r\n        @param minOut minimum amount out from MATIC -> underlying - prevents front run attacks\r\n        @return received number of WhiteLabel tokens received\r\n     */\r\n    function mintWithNative(\r\n        address recipient,\r\n        uint256 minOut\r\n    ) external payable returns (uint256) {\r\n        _checkGarbageCollector();\r\n        return _mintWithNative(recipient, minOut);\r\n    }\r\n\r\n    /** \r\n        Mint WhiteLabel Tokens For `recipient` By Depositing `underlying` Into The Contract\r\n            Requirements:\r\n                Approval from the `underlying` token prior to purchase\r\n        \r\n        @param numTokens number of underlying tokens to mint WhiteLabel with\r\n        @param recipient Account to receive minted WhiteLabel tokens\r\n        @return tokensMinted number of WhiteLabel tokens minted\r\n    */\r\n    function mintWithBacking(\r\n        uint256 numTokens,\r\n        address recipient\r\n    ) external nonReentrant returns (uint256) {\r\n        _checkGarbageCollector();\r\n        return _mintWithBacking(numTokens, recipient);\r\n    }\r\n\r\n    /** \r\n        Burns Sender's WhiteLabel Tokens and redeems their value in underlying\r\n        @param tokenAmount Number of WhiteLabel Tokens To Redeem, Must be greater than 0\r\n    */\r\n    function sell(uint256 tokenAmount) external nonReentrant returns (uint256) {\r\n        return _sell(tokenAmount, msg.sender);\r\n    }\r\n\r\n    /** \r\n        Burns Sender's WhiteLabel Tokens and redeems their value in `underlying` for `recipient`\r\n        @param tokenAmount Number of WhiteLabel Tokens To Redeem, Must be greater than 0\r\n        @param recipient Recipient Of underlying token transfer, Must not be address(0)\r\n    */\r\n    function sell(\r\n        uint256 tokenAmount,\r\n        address recipient\r\n    ) external nonReentrant returns (uint256) {\r\n        return _sell(tokenAmount, recipient);\r\n    }\r\n\r\n    /** \r\n        Allows A User To Erase Their Holdings From Supply \r\n        DOES NOT REDEEM UNDERLYING ASSET FOR USER\r\n        @param amount Number of WhiteLabel Tokens To Burn\r\n    */\r\n    function burn(uint256 amount) external nonReentrant {\r\n        // get balance of caller\r\n        uint256 bal = _balances[msg.sender];\r\n        require(bal >= amount && bal > 0, \"Zero Holdings\");\r\n        // Track Change In Price\r\n        uint256 oldPrice = _calculatePrice();\r\n        // take fee\r\n        _takeFee(amount);\r\n        // burn tokens from sender + supply\r\n        _burn(msg.sender, amount);\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n        // Emit Call\r\n        emit Burn(msg.sender, amount);\r\n    }\r\n\r\n    // Flashloan function\r\n    function flashLoan(\r\n        address _receiver,\r\n        uint256 _amount,\r\n        bytes calldata _params\r\n    ) external nonReentrant {\r\n        // Ensure the receiver is a contract.\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_receiver)\r\n        }\r\n        require(size > 0, \"Receiver must be a contract\");\r\n\r\n        // Pre-requisites\r\n        uint256 initialBalance = underlying.balanceOf(address(this));\r\n        require(_amount <= initialBalance, \"Not enough liquidity\");\r\n\r\n        // Price before loan\r\n        uint256 oldPrice = _calculatePrice();\r\n\r\n        uint256 fee = ( _amount * flashLoanFee ) / 10000;\r\n\r\n        require(underlying.transfer(_receiver, _amount), \"Transfer failed\");\r\n\r\n        require(\r\n            IFlashLoanReceiver(_receiver).executeOperation(\r\n                address(underlying),\r\n                _amount,\r\n                fee,\r\n                _params\r\n            ),\r\n            \"Callback failed\"\r\n        );\r\n\r\n        require(\r\n            underlying.balanceOf(address(this)) >= initialBalance + fee,\r\n            \"Insufficient repayment\"\r\n        );\r\n\r\n        // Require price rises\r\n        _requirePriceRises(oldPrice);\r\n\r\n        emit FlashLoan(_receiver, address(underlying), _amount, fee);\r\n    }\r\n\r\n    function setFlashLoanFee(uint256 newFeeAmount) external onlyOwner {\r\n        require(newFeeAmount <= 2500, \"Fee must not exceed 25%\");\r\n        flashLoanFee = newFeeAmount;\r\n        emit FlashLoanFeeSet(newFeeAmount);\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    //////  INTERNAL FUNCTIONS  ///////\r\n    ///////////////////////////////////\r\n\r\n    /** Purchases WhiteLabel Token and Deposits Them in Recipient's Address */\r\n    function _mintWithNative(\r\n        address recipient,\r\n        uint256 minOut\r\n    ) internal nonReentrant returns (uint256) {\r\n        require(msg.value > 0, \"Zero Value\");\r\n        require(recipient != address(0), \"Zero Address\");\r\n        require(\r\n            tokenActivated || msg.sender == this.getOwner(),\r\n            \"Token Not Activated\"\r\n        );\r\n\r\n        // calculate price change\r\n        uint256 oldPrice = _calculatePrice();\r\n\r\n        // previous backing\r\n        uint256 previousBacking = underlying.balanceOf(address(this));\r\n\r\n        // swap MATIC for stable\r\n        uint256 received = _purchaseUnderlying(minOut);\r\n\r\n        // if this is the first purchase, use new amount\r\n        uint256 relevantBacking = previousBacking == 0\r\n            ? underlying.balanceOf(address(this))\r\n            : previousBacking;\r\n\r\n        // mint to recipient\r\n        return _mintTo(recipient, received, relevantBacking, oldPrice);\r\n    }\r\n\r\n    /** Stake Tokens and Deposits WhiteLabel in Sender's Address, Must Have Prior Approval For Underlying */\r\n    function _mintWithBacking(\r\n        uint256 numUnderlying,\r\n        address recipient\r\n    ) internal returns (uint256) {\r\n        require(\r\n            tokenActivated || msg.sender == this.getOwner(),\r\n            \"Token Not Activated\"\r\n        );\r\n        // users token balance\r\n        uint256 userTokenBalance = underlying.balanceOf(msg.sender);\r\n\r\n        // ensure user has enough to send\r\n        require(\r\n            userTokenBalance > 0 && numUnderlying <= userTokenBalance,\r\n            \"Insufficient Balance\"\r\n        );\r\n\r\n        // calculate price change\r\n        uint256 oldPrice = _calculatePrice();\r\n\r\n        // previous backing\r\n        uint256 previousBacking = underlying.balanceOf(address(this));\r\n\r\n        // transfer in token\r\n        uint256 received = _transferIn(address(underlying), numUnderlying);\r\n\r\n        // if this is the first purchase, use new amount\r\n        uint256 relevantBacking = previousBacking == 0\r\n            ? underlying.balanceOf(address(this))\r\n            : previousBacking;\r\n\r\n        // Handle Minting\r\n        return _mintTo(recipient, received, relevantBacking, oldPrice);\r\n    }\r\n\r\n    /** Burns WhiteLabel Tokens And Deposits Underlying Tokens into Recipients's Address */\r\n    function _sell(\r\n        uint256 tokenAmount,\r\n        address recipient\r\n    ) internal returns (uint256) {\r\n        // seller of tokens\r\n        address seller = msg.sender;\r\n\r\n        require(\r\n            tokenAmount > 0 && _balances[seller] >= tokenAmount,\r\n            \"Insufficient Balance\"\r\n        );\r\n        require(recipient != address(0), \"Invalid Recipient\");\r\n\r\n        // calculate price change\r\n        uint256 oldPrice = _calculatePrice();\r\n\r\n        // tokens post fee to swap for underlying asset\r\n        uint256 tokensToSwap = isTransferFeeExempt[seller]\r\n            ? tokenAmount - 10\r\n            : ( tokenAmount * sellFee ) / feeDenominator;\r\n\r\n        // value of taxed tokens\r\n        uint256 amountUnderlyingAsset = amountOut(tokensToSwap);\r\n\r\n        // Take Fee\r\n        if (!isTransferFeeExempt[msg.sender]) {\r\n            uint fee = tokenAmount - tokensToSwap;\r\n            _takeFee(fee);\r\n        }\r\n\r\n        // burn from sender + supply\r\n        _burn(seller, tokenAmount);\r\n\r\n        // send Tokens to Seller\r\n        require(\r\n            underlying.transfer(recipient, amountUnderlyingAsset),\r\n            \"Underlying Transfer Failure\"\r\n        );\r\n\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n\r\n        // Differentiate Sell\r\n        emit Redeemed(seller, tokenAmount, amountUnderlyingAsset);\r\n\r\n        // return token redeemed and amount underlying\r\n        return amountUnderlyingAsset;\r\n    }\r\n\r\n    /** Handles Minting Logic To Create New WhiteLabel */\r\n    function _mintTo(\r\n        address recipient,\r\n        uint256 received,\r\n        uint256 totalBacking,\r\n        uint256 oldPrice\r\n    ) internal returns (uint256) {\r\n        // tokens to mint with no tax\r\n        uint256 nTokensToMint = tokensToMint(received, totalBacking);\r\n\r\n        // whether fee was applied or not\r\n        bool hasFee = !isTransferFeeExempt[msg.sender] && _totalSupply > 0;\r\n\r\n        // ensure there are tokens to mint\r\n        require(nTokensToMint > 0, \"Zero Amount To Mint\");\r\n\r\n        // mint to Buyer\r\n        _mint(recipient, nTokensToMint);\r\n\r\n        // apply fee to tax taken\r\n        if (hasFee) {\r\n            uint256 nTokensToMintNoTax = nTokensToMint * feeDenominator / mintFee;\r\n            _takeFee(nTokensToMintNoTax - nTokensToMint);\r\n        }\r\n\r\n        // require price rises\r\n        _requirePriceRises(oldPrice);\r\n\r\n        // differentiate purchase\r\n        emit Minted(recipient, nTokensToMint);\r\n        return nTokensToMint;\r\n    }\r\n\r\n    /** Takes Fee */\r\n    function _takeFee(uint mFee) internal {\r\n        // send percentage to fee recipient\r\n        uint256 fee = mFee / 5;\r\n\r\n        if (fee > 0) {\r\n            unchecked {\r\n                _balances[feeTo] += fee;\r\n                _totalSupply += fee;\r\n            }\r\n            emit Transfer(address(0), feeTo, fee);\r\n        }\r\n    }\r\n\r\n    /** Swaps to underlying, must get at least `minOut` back from swap to be successful */\r\n    function _purchaseUnderlying(uint256 minOut) internal returns (uint256) {\r\n        // previous amount of Tokens before we received any\r\n        uint256 prevTokenAmount = underlying.balanceOf(address(this));\r\n\r\n        // swap MATIC For stable of choice\r\n        router.swapExactETHForTokens{value: address(this).balance}(\r\n            minOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp + 300\r\n        );\r\n\r\n        // amount after swap\r\n        uint256 currentTokenAmount = underlying.balanceOf(address(this));\r\n        require(\r\n            currentTokenAmount > prevTokenAmount,\r\n            \"Zero Underlying Received\"\r\n        );\r\n        return currentTokenAmount - prevTokenAmount;\r\n    }\r\n\r\n    /** Requires The Price Of WhiteLabel To Rise For The Transaction To Conclude */\r\n    function _requirePriceRises(uint256 oldPrice) internal {\r\n        // Calculate Price After Transaction\r\n        uint256 newPrice = _calculatePrice();\r\n        // Require Current Price >= Last Price\r\n        require(newPrice >= oldPrice, \"Price Cannot Fall\");\r\n        // Emit The Price Change\r\n        emit PriceChange(oldPrice, newPrice, _totalSupply);\r\n        // Log The New Price\r\n        allPrices.push(newPrice);\r\n        // Log The Time Of The New Price\r\n        allPriceTimestamps.push(block.timestamp);\r\n    }\r\n\r\n    /** \r\n        Transfers `amount` of `token` in, verifies the transaction success, returns the amount received\r\n        Also accounts for potential tx fees as it notes the contract balance before and after swap \r\n    */\r\n    function _transferIn(\r\n        address _token,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        require(\r\n            IERC20(_token).balanceOf(msg.sender) >= amount,\r\n            \"Insufficient Balance\"\r\n        );\r\n        require(\r\n            IERC20(_token).allowance(msg.sender, address(this)) >= amount,\r\n            \"Insufficient Allowance\"\r\n        );\r\n        uint before = IERC20(_token).balanceOf(address(this));\r\n        IERC20(_token).transferFrom(msg.sender, address(this), amount);\r\n        uint After = IERC20(_token).balanceOf(address(this));\r\n        require(After > before, \"Error On Transfer From\");\r\n        return After - before;\r\n    }\r\n\r\n    /** Mints Tokens to the Receivers Address */\r\n    function _mint(address receiver, uint amount) internal {\r\n        _balances[receiver] += amount;\r\n        _totalSupply += amount;\r\n        emit Transfer(address(0), receiver, amount);\r\n    }\r\n\r\n    /** Burns `amount` of tokens from `account` */\r\n    function _burn(address account, uint amount) internal {\r\n        _balances[account] -= amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /** Make Sure there's no PO8 Tokens in contract */\r\n    function _checkGarbageCollector() internal {\r\n        uint256 bal = _balances[address(this)];\r\n        if (bal > 100) {\r\n            // Track Change In Price\r\n            uint256 oldPrice = _calculatePrice();\r\n            // take fee\r\n            _takeFee(bal);\r\n            // burn amount\r\n            _burn(address(this), bal);\r\n            // Emit Collection\r\n            emit GarbageCollected(bal);\r\n            // Require price rises\r\n            _requirePriceRises(oldPrice);\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    //////    READ FUNCTIONS    ///////\r\n    ///////////////////////////////////\r\n\r\n    /** Price Of WhiteLabel in Underlying With 6 Points Of Precision */\r\n    function calculatePrice() external view returns (uint256) {\r\n        return _calculatePrice();\r\n    }\r\n\r\n    /** Returns the Current Price of 1 Token */\r\n    function _calculatePrice() internal view returns (uint256) {\r\n        if (_totalSupply == 0) {\r\n            return precision;\r\n        }\r\n        uint256 backingValue = underlying.balanceOf(address(this));\r\n        return ( ( backingValue * precision ) / _totalSupply );\r\n    }\r\n\r\n    /** Number Of Tokens To Mint */\r\n    function tokensToMint(\r\n        uint256 received,\r\n        uint256 totalBacking\r\n    ) public view returns (uint256) {\r\n        return\r\n            _totalSupply == 0\r\n                ? received // puts launch price at 1 `underlying`\r\n                : isTransferFeeExempt[msg.sender]\r\n                ? ( ( _totalSupply * received ) / totalBacking ) - 100 // sub 100 to avoid any round off error\r\n                : ( ( ( _totalSupply * received ) / ( totalBacking + mintFeeTaken(received) ) ) * mintFee ) / feeDenominator;\r\n    }\r\n\r\n    function mintFeeTaken(uint256 amount) public view returns (uint256) {\r\n        uint fee = (amount * mintFee) / feeDenominator;\r\n        return amount - fee;\r\n    }\r\n\r\n    /**\r\n        Amount Of Underlying To Receive For `numTokens` of WhiteLabel\r\n     */\r\n    function amountOut(uint256 numTokens) public view returns (uint256) {\r\n        return ( _calculatePrice() * numTokens ) / precision;\r\n    }\r\n\r\n    /** Returns the value of `holder`'s holdings */\r\n    function getValueOfHoldings(address holder) public view returns (uint256) {\r\n        return amountOut(_balances[holder]);\r\n    }\r\n\r\n    function viewAllPriceChanges() external view returns (uint256[] memory) {\r\n        return allPrices;\r\n    }\r\n\r\n    function numPricePoints() external view returns (uint256) {\r\n        return allPrices.length;\r\n    }\r\n\r\n    function viewAllPriceChangeTimestamps() external view returns (uint256[] memory) {\r\n        return allPriceTimestamps;\r\n    }\r\n\r\n    function numPricePointTimestamps() external view returns (uint256) {\r\n        return allPriceTimestamps.length;\r\n    }\r\n\r\n    function viewPricePoints(\r\n        uint startIndex,\r\n        uint endIndex\r\n    ) external view returns (uint256[] memory pricePoints) {\r\n        pricePoints = new uint256[](endIndex - startIndex);\r\n        uint count = 0;\r\n        for (uint i = startIndex; i < endIndex; ) {\r\n            pricePoints[count] = allPrices[i];\r\n            unchecked {\r\n                ++count;\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function viewSelectPricePoints(\r\n        uint256[] calldata indexes\r\n    ) external view returns (uint256[] memory pricePoints) {\r\n        uint len = indexes.length;\r\n        pricePoints = new uint256[](len);\r\n        for (uint i = 0; i < len; ) {\r\n            pricePoints[i] = allPrices[indexes[i]];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function viewPricePointTimestamps(\r\n        uint startIndex,\r\n        uint endIndex\r\n    ) external view returns (uint256[] memory pricePointTimestamps) {\r\n        pricePointTimestamps = new uint256[](endIndex - startIndex);\r\n        uint count = 0;\r\n        for (uint i = startIndex; i < endIndex; ) {\r\n            pricePointTimestamps[count] = allPriceTimestamps[i];\r\n            unchecked {\r\n                ++count;\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function viewSelectPricePointTimestamps(\r\n        uint256[] calldata indexes\r\n    ) external view returns (uint256[] memory pricePointTimestamps) {\r\n        uint len = indexes.length;\r\n        pricePointTimestamps = new uint256[](len);\r\n        for (uint i = 0; i < len; ) {\r\n            pricePointTimestamps[i] = allPriceTimestamps[indexes[i]];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    //////   OWNER FUNCTIONS    ///////\r\n    ///////////////////////////////////\r\n\r\n    /** Activates Token, Enabling Trading For All */\r\n    function activateToken() external onlyOwner {\r\n        tokenActivated = true;\r\n        emit TokenActivated(block.number);\r\n    }\r\n\r\n    /** Pauses Token Activation */\r\n    function deActivateToken() external onlyOwner {\r\n        tokenActivated = false;\r\n        emit TokenDeActivated(block.number);\r\n    }\r\n\r\n    /** Updates The Address Of The Router To Purchase Underlying */\r\n    function upgradeRouter(address newRouter) external onlyOwner {\r\n        require(newRouter != address(0));\r\n        router = IUniswapV2Router02(newRouter);\r\n        emit SetRouter(newRouter);\r\n    }\r\n\r\n    /** Withdraws Tokens Incorrectly Sent To WhiteLabel */\r\n    function withdrawNonStableToken(IERC20 token) external onlyOwner {\r\n        require(\r\n            address(token) != address(underlying),\r\n            \"Cannot Withdraw Underlying Asset\"\r\n        );\r\n        require(address(token) != address(0), \"Zero Address\");\r\n        token.transfer(msg.sender, token.balanceOf(address(this)));\r\n    }\r\n\r\n    /** \r\n        Sets Mint, Transfer, Sell Fee\r\n        Must Be Within Bounds ( Between 0% - 10% ) \r\n    */\r\n    function setFees(\r\n        uint256 _mintFee,\r\n        uint256 _transferFee,\r\n        uint256 _sellFee\r\n    ) external onlyOwner {\r\n        require(_mintFee >= 90000); // capped at 10% fee\r\n        require(_transferFee >= 90000); // capped at 10% fee\r\n        require(_sellFee >= 90000); // capped at 10% fee\r\n\r\n        mintFee = _mintFee;\r\n        transferFee = _transferFee;\r\n        sellFee = _sellFee;\r\n        emit SetFees(_mintFee, _transferFee, _sellFee);\r\n    }\r\n\r\n    /** Excludes Contract From Transfer Fees */\r\n    function setPermissions(\r\n        address Contract,\r\n        bool transferFeeExempt\r\n    ) external onlyOwner {\r\n        require(Contract != address(0), \"Zero Address\");\r\n        isTransferFeeExempt[Contract] = transferFeeExempt;\r\n        emit SetPermissions(Contract, transferFeeExempt);\r\n    }\r\n\r\n    function setFeeTo(address newFeeTo) external {\r\n        require(msg.sender == feeTo, \"Only FeeTo\");\r\n        require(newFeeTo != address(0), \"Zero Address\");\r\n        feeTo = newFeeTo;\r\n        isTransferFeeExempt[newFeeTo] = true;\r\n    }\r\n\r\n    /** Mint Tokens to Buyer */\r\n    receive() external payable {\r\n        _mintWithNative(msg.sender, 0);\r\n        _checkGarbageCollector();\r\n    }\r\n\r\n    function goodAddress(address _target) internal pure returns (bool) {\r\n        if (_target == DEAD || _target == ZERO) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////////\r\n    //////        EVENTS        ///////\r\n    ///////////////////////////////////\r\n\r\n    // Data Tracking\r\n    event PriceChange(\r\n        uint256 previousPrice,\r\n        uint256 currentPrice,\r\n        uint256 totalSupply\r\n    );\r\n    event TokenActivated(uint blockNo);\r\n    event TokenDeActivated(uint blockNo);\r\n\r\n    // Balance Tracking\r\n    event Burn(address from, uint256 amountTokensErased);\r\n    event GarbageCollected(uint256 amountTokensErased);\r\n    event Redeemed(\r\n        address seller,\r\n        uint256 amountWhiteLabel,\r\n        uint256 amountUnderlying\r\n    );\r\n    event Minted(address recipient, uint256 numTokens);\r\n\r\n    // Upgradable Contract Tracking\r\n    event SetMaxHoldings(uint256 maxHoldings);\r\n    event SetRouter(address newRouter);\r\n\r\n    // Governance Tracking\r\n    event SetPermissions(address Contract, bool feeExempt);\r\n    event SetMaxHoldingsExempt(address account, bool isExempt);\r\n    event SetFees(uint mintFee, uint transferFee, uint sellFee);\r\n\r\n    // FlashLoans\r\n    event FlashLoan(address target, address token, uint256 amount, uint256 fee);\r\n    event FlashLoanFeeSet(uint256 newFeeAmount);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeTo_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokensErased\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeeAmount\",\"type\":\"uint256\"}],\"name\":\"FlashLoanFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokensErased\",\"type\":\"uint256\"}],\"name\":\"GarbageCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"PriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWhiteLabel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountUnderlying\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellFee\",\"type\":\"uint256\"}],\"name\":\"SetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxHoldings\",\"type\":\"uint256\"}],\"name\":\"SetMaxHoldings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExempt\",\"type\":\"bool\"}],\"name\":\"SetMaxHoldingsExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"feeExempt\",\"type\":\"bool\"}],\"name\":\"SetPermissions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"SetRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNo\",\"type\":\"uint256\"}],\"name\":\"TokenActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNo\",\"type\":\"uint256\"}],\"name\":\"TokenDeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPriceTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"amountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculatePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deActivateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashLoanFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getValueOfHoldings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTransferFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintFeeTaken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintWithBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"mintWithNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPricePointTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPricePoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transferFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFeeAmount\",\"type\":\"uint256\"}],\"name\":\"setFlashLoanFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"transferFeeExempt\",\"type\":\"bool\"}],\"name\":\"setPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBacking\",\"type\":\"uint256\"}],\"name\":\"tokensToMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"upgradeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewAllPriceChangeTimestamps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewAllPriceChanges\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"viewPricePointTimestamps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pricePointTimestamps\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"viewPricePoints\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pricePoints\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"name\":\"viewSelectPricePointTimestamps\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pricePointTimestamps\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"}],\"name\":\"viewSelectPricePoints\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pricePoints\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawNonStableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PO8", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff000000000000000000000000fbffc7dbb9cd4252d92564fb499158ad0a29c0bb", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e16e55d1e5e5060602df5b6d9640aa6d1e3d0b14b4d9a779795d4aaf2f32485c"}