{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@thirdweb-dev/contracts/eip/interface/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * [EIP](https://eips.ethereum.org/EIPS/eip-165).\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/eip/interface/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache 2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/ContractMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\nimport \\\"./interface/IContractMetadata.sol\\\";\\n\\n/**\\n *  @title   Contract Metadata\\n *  @notice  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\\n *           for you contract.\\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\\n */\\n\\nabstract contract ContractMetadata is IContractMetadata {\\n    /// @notice Returns the contract metadata URI.\\n    string public override contractURI;\\n\\n    /**\\n     *  @notice         Lets a contract admin set the URI for contract-level metadata.\\n     *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\\n     *                  See {_canSetContractURI}.\\n     *                  Emits {ContractURIUpdated Event}.\\n     *\\n     *  @param _uri     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     */\\n    function setContractURI(string memory _uri) external override {\\n        if (!_canSetContractURI()) {\\n            revert(\\\"Not authorized\\\");\\n        }\\n\\n        _setupContractURI(_uri);\\n    }\\n\\n    /// @dev Lets a contract admin set the URI for contract-level metadata.\\n    function _setupContractURI(string memory _uri) internal {\\n        string memory prevURI = contractURI;\\n        contractURI = _uri;\\n\\n        emit ContractURIUpdated(prevURI, _uri);\\n    }\\n\\n    /// @dev Returns whether contract metadata can be set in the given execution context.\\n    function _canSetContractURI() internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/interface/IContractMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\n/**\\n *  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\\n *  for you contract.\\n *\\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\\n */\\n\\ninterface IContractMetadata {\\n    /// @dev Returns the metadata URI of the contract.\\n    function contractURI() external view returns (string memory);\\n\\n    /**\\n     *  @dev Sets contract URI for the storefront-level metadata of the contract.\\n     *       Only module admin can call this function.\\n     */\\n    function setContractURI(string calldata _uri) external;\\n\\n    /// @dev Emitted when the contract URI is updated.\\n    event ContractURIUpdated(string prevURI, string newURI);\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/interface/IRoyalty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\nimport \\\"../../eip/interface/IERC2981.sol\\\";\\n\\n/**\\n *  Thirdweb's `Royalty` is a contract extension to be used with any base contract. It exposes functions for setting and reading\\n *  the recipient of royalty fee and the royalty fee basis points, and lets the inheriting contract perform conditional logic\\n *  that uses information about royalty fees, if desired.\\n *\\n *  The `Royalty` contract is ERC2981 compliant.\\n */\\n\\ninterface IRoyalty is IERC2981 {\\n    struct RoyaltyInfo {\\n        address recipient;\\n        uint256 bps;\\n    }\\n\\n    /// @dev Returns the royalty recipient and fee bps.\\n    function getDefaultRoyaltyInfo() external view returns (address, uint16);\\n\\n    /// @dev Lets a module admin update the royalty bps and recipient.\\n    function setDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) external;\\n\\n    /// @dev Lets a module admin set the royalty recipient for a particular token Id.\\n    function setRoyaltyInfoForToken(\\n        uint256 tokenId,\\n        address recipient,\\n        uint256 bps\\n    ) external;\\n\\n    /// @dev Returns the royalty recipient for a particular token Id.\\n    function getRoyaltyInfoForToken(uint256 tokenId) external view returns (address, uint16);\\n\\n    /// @dev Emitted when royalty info is updated.\\n    event DefaultRoyalty(address indexed newRoyaltyRecipient, uint256 newRoyaltyBps);\\n\\n    /// @dev Emitted when royalty recipient for tokenId is set\\n    event RoyaltyForToken(uint256 indexed tokenId, address indexed royaltyRecipient, uint256 royaltyBps);\\n}\\n\"\r\n    },\r\n    \"@thirdweb-dev/contracts/extension/Royalty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\nimport \\\"./interface/IRoyalty.sol\\\";\\n\\n/**\\n *  @title   Royalty\\n *  @notice  Thirdweb's `Royalty` is a contract extension to be used with any base contract. It exposes functions for setting and reading\\n *           the recipient of royalty fee and the royalty fee basis points, and lets the inheriting contract perform conditional logic\\n *           that uses information about royalty fees, if desired.\\n *\\n *  @dev     The `Royalty` contract is ERC2981 compliant.\\n */\\n\\nabstract contract Royalty is IRoyalty {\\n    /// @dev The (default) address that receives all royalty value.\\n    address private royaltyRecipient;\\n\\n    /// @dev The (default) % of a sale to take as royalty (in basis points).\\n    uint16 private royaltyBps;\\n\\n    /// @dev Token ID => royalty recipient and bps for token\\n    mapping(uint256 => RoyaltyInfo) private royaltyInfoForToken;\\n\\n    /**\\n     *  @notice   View royalty info for a given token and sale price.\\n     *  @dev      Returns royalty amount and recipient for `tokenId` and `salePrice`.\\n     *  @param tokenId          The tokenID of the NFT for which to query royalty info.\\n     *  @param salePrice        Sale price of the token.\\n     *\\n     *  @return receiver        Address of royalty recipient account.\\n     *  @return royaltyAmount   Royalty amount calculated at current royaltyBps value.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        (address recipient, uint256 bps) = getRoyaltyInfoForToken(tokenId);\\n        receiver = recipient;\\n        royaltyAmount = (salePrice * bps) / 10_000;\\n    }\\n\\n    /**\\n     *  @notice          View royalty info for a given token.\\n     *  @dev             Returns royalty recipient and bps for `_tokenId`.\\n     *  @param _tokenId  The tokenID of the NFT for which to query royalty info.\\n     */\\n    function getRoyaltyInfoForToken(uint256 _tokenId) public view override returns (address, uint16) {\\n        RoyaltyInfo memory royaltyForToken = royaltyInfoForToken[_tokenId];\\n\\n        return\\n            royaltyForToken.recipient == address(0)\\n                ? (royaltyRecipient, uint16(royaltyBps))\\n                : (royaltyForToken.recipient, uint16(royaltyForToken.bps));\\n    }\\n\\n    /**\\n     *  @notice Returns the defualt royalty recipient and BPS for this contract's NFTs.\\n     */\\n    function getDefaultRoyaltyInfo() external view override returns (address, uint16) {\\n        return (royaltyRecipient, uint16(royaltyBps));\\n    }\\n\\n    /**\\n     *  @notice         Updates default royalty recipient and bps.\\n     *  @dev            Caller should be authorized to set royalty info.\\n     *                  See {_canSetRoyaltyInfo}.\\n     *                  Emits {DefaultRoyalty Event}; See {_setupDefaultRoyaltyInfo}.\\n     *\\n     *  @param _royaltyRecipient   Address to be set as default royalty recipient.\\n     *  @param _royaltyBps         Updated royalty bps.\\n     */\\n    function setDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) external override {\\n        if (!_canSetRoyaltyInfo()) {\\n            revert(\\\"Not authorized\\\");\\n        }\\n\\n        _setupDefaultRoyaltyInfo(_royaltyRecipient, _royaltyBps);\\n    }\\n\\n    /// @dev Lets a contract admin update the default royalty recipient and bps.\\n    function _setupDefaultRoyaltyInfo(address _royaltyRecipient, uint256 _royaltyBps) internal {\\n        if (_royaltyBps > 10_000) {\\n            revert(\\\"Exceeds max bps\\\");\\n        }\\n\\n        royaltyRecipient = _royaltyRecipient;\\n        royaltyBps = uint16(_royaltyBps);\\n\\n        emit DefaultRoyalty(_royaltyRecipient, _royaltyBps);\\n    }\\n\\n    /**\\n     *  @notice         Updates default royalty recipient and bps for a particular token.\\n     *  @dev            Sets royalty info for `_tokenId`. Caller should be authorized to set royalty info.\\n     *                  See {_canSetRoyaltyInfo}.\\n     *                  Emits {RoyaltyForToken Event}; See {_setupRoyaltyInfoForToken}.\\n     *\\n     *  @param _recipient   Address to be set as royalty recipient for given token Id.\\n     *  @param _bps         Updated royalty bps for the token Id.\\n     */\\n    function setRoyaltyInfoForToken(\\n        uint256 _tokenId,\\n        address _recipient,\\n        uint256 _bps\\n    ) external override {\\n        if (!_canSetRoyaltyInfo()) {\\n            revert(\\\"Not authorized\\\");\\n        }\\n\\n        _setupRoyaltyInfoForToken(_tokenId, _recipient, _bps);\\n    }\\n\\n    /// @dev Lets a contract admin set the royalty recipient and bps for a particular token Id.\\n    function _setupRoyaltyInfoForToken(\\n        uint256 _tokenId,\\n        address _recipient,\\n        uint256 _bps\\n    ) internal {\\n        if (_bps > 10_000) {\\n            revert(\\\"Exceeds max bps\\\");\\n        }\\n\\n        royaltyInfoForToken[_tokenId] = RoyaltyInfo({ recipient: _recipient, bps: _bps });\\n\\n        emit RoyaltyForToken(_tokenId, _recipient, _bps);\\n    }\\n\\n    /// @dev Returns whether royalty info can be set in the given execution context.\\n    function _canSetRoyaltyInfo() internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/imports/Bank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IBank.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"./Roles.sol\\\";\\n\\nabstract contract Bank is IBank, Roles {\\n\\n    address public paymentReceiver;\\n\\n    constructor(address _paymentReceiver) {\\n        paymentReceiver = _paymentReceiver;\\n    }\\n\\n    function setPaymentReceiver(address _paymentReceiver)\\n        accountIsManager(msg.sender)\\n        override\\n        external\\n    {\\n        paymentReceiver = _paymentReceiver;\\n        emit ReceiverUpdated(_paymentReceiver);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/imports/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC1155.sol\\\";\\nimport \\\"../interfaces/IERC1155TokenReceiver.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\n\\nabstract contract ERC1155 is IERC1155 {\\n    mapping (uint256 => mapping(address => uint256)) internal balances;\\n    mapping (address => mapping(address => bool)) internal operatorApproval;\\n\\n    bytes4 constant private ERC1155_ACCEPTED = 0xf23a6e61;\\n    bytes4 constant private ERC1155_BATCH_ACCEPTED = 0xbc197c81;\\n\\n    modifier ownerOrOperator(address account) {\\n        require(\\n            account == msg.sender ||\\n            operatorApproval[account][msg.sender],\\n            Errors.NOT_OWNER_OR_OPERATOR\\n        );\\n        _;\\n    }\\n\\n    modifier nftNotBlocked(address account, uint256 id, uint256 value) {\\n        require(!_isNftBlockedForUser(account, id, value), Errors.BLOCKED_NFT);\\n        _;\\n    }\\n\\n    modifier canTransfer(address to) {\\n        require(_transfersAllowed() || to == address(0), Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    )\\n        ownerOrOperator(_from)\\n        override\\n        external\\n    {\\n        _transferNFT(_from, _to, _value, _id);\\n\\n        emit TransferSingle(msg.sender, _from, _to, _id, _value);\\n\\n        if (_to.code.length > 0) {\\n            _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, _value, _data);\\n        }\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    )\\n        ownerOrOperator(_from)\\n        override\\n        external\\n    {\\n        require(_ids.length == _values.length, Errors.NOT_MATCHING_SIZES);\\n\\n        for (uint256 i = 0; i < _ids.length; i++) {\\n            _transferNFT(_from, _to, _values[i], _ids[i]);\\n        }\\n\\n        emit TransferBatch(msg.sender, _from, _to, _ids, _values);\\n\\n        if (_to.code.length > 0) {\\n            _doSafeBatchTransferAcceptanceCheck(msg.sender, _from, _to, _ids, _values, _data);\\n        }\\n    }\\n\\n    function balanceOf(address _owner, uint256 _id)\\n        override\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return balances[_id][_owner];\\n    }\\n\\n    function balanceOfBatch(\\n        address[] calldata _owners,\\n        uint256[] calldata _ids\\n    )\\n        override\\n        external\\n        view\\n        returns (uint256[] memory)\\n    {\\n\\n        require(_owners.length == _ids.length);\\n\\n        uint256[] memory balances_ = new uint256[](_owners.length);\\n\\n        for (uint256 i = 0; i < _owners.length; ++i) {\\n            balances_[i] = balances[_ids[i]][_owners[i]];\\n        }\\n\\n        return balances_;\\n    }\\n\\n    function setApprovalForAll(address _operator, bool _approved)\\n        override\\n        external\\n    {\\n        operatorApproval[msg.sender][_operator] = _approved;\\n        emit ApprovalForAll(msg.sender, _operator, _approved);\\n    }\\n\\n    function isApprovedForAll(address _owner, address _operator)\\n        override\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return operatorApproval[_owner][_operator];\\n    }\\n\\n\\n    function _transferNFT(address _from, address _to, uint256 _value, uint256 _id)\\n        nftNotBlocked(_from, _id, _value)\\n        canTransfer(_to)\\n        private\\n    {\\n        balances[_id][_from] = balances[_id][_from] - _value;\\n        balances[_id][_to]   = _value + balances[_id][_to];\\n    }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address _operator,\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes memory _data\\n    )\\n        private\\n    {\\n        require(\\n            IERC1155TokenReceiver(_to).onERC1155Received(\\n                _operator,\\n                _from,\\n                _id,\\n                _value,\\n                _data\\n            ) == ERC1155_ACCEPTED,\\n            Errors.UNKNOWN_VALUE\\n        );\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address _operator,\\n        address _from,\\n        address _to,\\n        uint256[] memory _ids,\\n        uint256[] memory _values,\\n        bytes memory _data\\n    )\\n        private\\n    {\\n        require(\\n            IERC1155TokenReceiver(_to).onERC1155BatchReceived(\\n                _operator,\\n                _from,\\n                _ids,\\n                _values,\\n                _data\\n            ) == ERC1155_BATCH_ACCEPTED,\\n            Errors.UNKNOWN_VALUE\\n        );\\n    }\\n\\n    function _isNftBlockedForUser(address account, uint256 id, uint256 value)\\n        internal\\n        virtual\\n        returns(bool);\\n\\n    function _transfersAllowed()\\n        internal\\n        virtual\\n        returns(bool);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/imports/ERC1155Metadata_URI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC1155Metadata_URI.sol\\\";\\n\\ncontract ERC1155Metadata_URI is IERC1155Metadata_URI {\\n    mapping(uint256 => string) internal idToUri;\\n\\n    function uri(uint256 id)\\n        override\\n        external\\n        view\\n        returns (string memory)\\n    {\\n        return idToUri[id];\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/imports/Membership.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IMembership.sol\\\";\\nimport \\\"./ERC1155Metadata_URI.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\nimport \\\"./Roles.sol\\\";\\nimport \\\"./ERC1155.sol\\\";\\n\\nabstract contract Membership is IMembership, ERC1155, ERC1155Metadata_URI, Roles {\\n    uint256 public currentEdition;\\n    mapping(address=>MembershipInfo) internal accountToMembership;\\n    uint8 public categories;\\n\\n    constructor(uint8 _categories) {\\n        categories = _categories;\\n    }\\n\\n    modifier isValidCategory(uint8 category) {\\n        require(category >= 0 && category < categories, Errors.CATEGORY_NOT_VALID);\\n        _;\\n    }\\n\\n    modifier keyOwner(address account) {\\n        require(_isKeyOwner(account), Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    modifier canRenewMembership(address account, uint256 edition) {\\n        require(!_isKeyOwner(account) && balances[edition][account] > 0);\\n        _;\\n    }\\n\\n    function launchNewEdition(string memory _uri)\\n        accountIsManager(msg.sender)\\n        override\\n        external\\n    {\\n        currentEdition++;\\n        idToUri[currentEdition] = _uri;\\n        emit NewEdition(currentEdition, _uri);\\n    }\\n\\n    function hasValidKey(address account)\\n        override\\n        external\\n        view\\n        returns(bool)\\n    {\\n        return _hasValidKey(account);\\n    }\\n\\n    function isKeyOwner(address account)\\n        override\\n        external\\n        view\\n        returns(bool)\\n    {\\n        return _isKeyOwner(account);\\n    }\\n\\n    function _isKeyOwner(address account)\\n        internal\\n        view\\n        returns(bool)\\n    {\\n        return accountToMembership[account].expirationTimestamp > block.timestamp;\\n    }\\n\\n    function getMembershipInfo(address account)\\n        override\\n        external\\n        view\\n        returns(MembershipInfo memory)\\n    {\\n        return accountToMembership[account];\\n    }\\n\\n    function grantKey(\\n        address recipient,\\n        uint8 category,\\n        uint256 expirationTimestamp\\n    )\\n        accountIsAdmin(msg.sender)\\n        override\\n        external\\n    {\\n        _grantKey(recipient, expirationTimestamp, category, currentEdition, false);\\n    }\\n\\n    function airdrop(\\n        address[] calldata recipients,\\n        uint8[] calldata _categories,\\n        uint256[] calldata _expires\\n    )\\n        external\\n        override\\n        accountIsAdmin(msg.sender)\\n    {\\n        for (uint256 i = 0; i < recipients.length; i++) {\\n            _grantKey(recipients[i], _expires[i], _categories[i], currentEdition, false);\\n        }\\n    }\\n\\n    function _isNftBlockedForUser(address account, uint256 id, uint256 value)\\n        override\\n        internal\\n        virtual\\n        returns(bool)\\n    {\\n        return balances[id][account] - value == 0 &&\\n            accountToMembership[account].expirationTimestamp > block.timestamp &&\\n            accountToMembership[account].edition == id;\\n    }\\n\\n    function _grantKey(\\n        address account,\\n        uint256 expire,\\n        uint8 category,\\n        uint256 _edition,\\n        bool isRenew\\n    )\\n        internal\\n        virtual\\n    {\\n        require(accountToMembership[account].expirationTimestamp < block.timestamp, Errors.KEY_OWNER);\\n\\n        accountToMembership[account].expirationTimestamp = expire;\\n        accountToMembership[account].category = category;\\n        accountToMembership[account].edition = _edition;\\n\\n        if (!isRenew) {\\n            balances[_edition][account]++;\\n            emit TransferSingle(msg.sender, address(0), account, _edition, 1);\\n        }\\n\\n        emit MembershipActivation(account, expire, isRenew, _edition);\\n    }\\n\\n    function _hasValidKey(address account)\\n        internal\\n        virtual\\n        view\\n        returns(bool)\\n    {\\n        return accountToMembership[account].expirationTimestamp > block.timestamp;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/imports/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IRoles.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\n\\ncontract Roles is IRoles {\\n    address public manager;\\n    mapping(address => bool) private accountToAdmin;\\n\\n    constructor(address _manager) {\\n        manager = _manager;\\n    }\\n\\n    modifier accountIsManager(address account) {\\n        require(account == manager, Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    modifier accountIsAdmin(address account) {\\n        require(accountToAdmin[account] || account == manager, Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    function setAdmin(address account, bool admin)\\n        accountIsManager(msg.sender)\\n        override\\n        external\\n    {\\n        _setAdmin(account, admin);\\n    }\\n\\n    function renounceAdmin()\\n        override\\n        external\\n    {\\n        _setAdmin(msg.sender, false);\\n    }\\n\\n    function setManager(address account)\\n        accountIsManager(msg.sender)\\n        override\\n        external\\n    {\\n        manager = account;\\n        emit ManagerSet(account);\\n    }\\n\\n    function isAdmin(address account)\\n        override\\n        external\\n        view\\n        returns(bool)\\n    {\\n        return accountToAdmin[account];\\n    }\\n\\n    function _setAdmin(address account, bool state)\\n        private\\n    {\\n        accountToAdmin[account] = state;\\n        emit AdminSet(account, state);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/imports/Sharable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/ISharable.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\nimport \\\"./Membership.sol\\\";\\n\\nabstract contract Sharable is ISharable, Membership {\\n    uint64[] public sharableKeys;\\n\\n    mapping(address=>SharedInfo) private accountToSharedInfo;\\n    mapping(address=>OwnerInfo) private accountToOwnerInfo;\\n\\n    constructor (uint64[] memory _sharableKeys) {\\n        require(_sharableKeys.length == categories, Errors.NOT_MATCHING_SIZES);\\n        sharableKeys = _sharableKeys;\\n    }\\n\\n    modifier canShare(address owner, uint256 toBeShared) {\\n        require(\\n            toBeShared <= accountToSharedInfo[owner].sharableKeys,\\n            Errors.LIMIT_REACHED\\n        );\\n        _;\\n    }\\n\\n    modifier rightSize(uint8 category) {\\n        require(category < sharableKeys.length, Errors.NOT_MATCHING_SIZES);\\n        _;\\n    }\\n\\n    function shareKeyWith(address[] calldata accounts)\\n        keyOwner(msg.sender)\\n        canShare(msg.sender, accounts.length)\\n        override\\n        external\\n    {\\n        for (uint i = 0; i < accounts.length; i++) {\\n            require(accounts[i] != address(0), Errors.NULL_ADDRESS);\\n            require(accountToOwnerInfo[accounts[i]].expire < block.timestamp, Errors.ALREADY_SHARED);\\n            accountToSharedInfo[msg.sender].shared.push(accounts[i]);\\n            accountToOwnerInfo[accounts[i]].expire = accountToMembership[msg.sender].expirationTimestamp;\\n            accountToOwnerInfo[accounts[i]].owner = msg.sender;\\n        }\\n        accountToSharedInfo[msg.sender].sharableKeys -= accounts.length;\\n        emit SharingKeys(msg.sender, accounts, true, accountToMembership[msg.sender].edition);\\n    }\\n\\n    function revokeKeyFrom(address[] calldata accounts)\\n        keyOwner(msg.sender)\\n        override\\n        external\\n    {\\n        for (uint i = 0; i < accounts.length; i++) {\\n            accountToSharedInfo[msg.sender].revoked.push(accounts[i]);\\n            accountToOwnerInfo[accounts[i]].expire = 0;\\n        }\\n        emit SharingKeys(msg.sender, accounts, false, accountToMembership[msg.sender].edition);\\n    }\\n\\n    function updateNumberOfSharableKeys(uint64 limit, uint8 category)\\n        accountIsManager(msg.sender)\\n        rightSize(category)\\n        override\\n        external\\n    {\\n        sharableKeys[category] = limit;\\n    }\\n\\n    function putNewCategory(uint64 limit, uint256 price)\\n        override\\n        external\\n        accountIsManager(msg.sender)\\n    {\\n        _putNewCategory(limit, price);\\n    }\\n\\n    function getNumberOfSharableKeys(uint8 category)\\n        override\\n        external\\n        view\\n        returns(uint64)\\n    {\\n        return sharableKeys[category];\\n    }\\n\\n    function getAccountSharedInfo(address keyOwner)\\n        external\\n        view\\n        override\\n        returns(SharedInfo memory)\\n    {\\n        return accountToSharedInfo[keyOwner];\\n    }\\n\\n    function getAccountOwnerInfo(address account)\\n        external\\n        view\\n        override\\n        returns(OwnerInfo memory)\\n    {\\n        return accountToOwnerInfo[account];\\n    }\\n\\n    function _grantKey(\\n        address account,\\n        uint256 expire,\\n        uint8 category,\\n        uint256 edition,\\n        bool isRenew\\n    )\\n        override\\n        internal\\n    {\\n        address[] memory empty = new address[](0);\\n        accountToSharedInfo[account].shared = empty;\\n        accountToSharedInfo[account].revoked = empty;\\n        accountToSharedInfo[account].sharableKeys = sharableKeys[category];\\n        super._grantKey(account, expire, category, edition, isRenew);\\n    }\\n\\n    function _hasValidKey(address account)\\n        internal\\n        override\\n        view\\n        returns(bool)\\n    {\\n        return super._hasValidKey(account) || accountToOwnerInfo[account].expire > block.timestamp;\\n    }\\n\\n    function _putNewCategory(uint64 limit, uint256)\\n        internal\\n        virtual\\n    {\\n        sharableKeys.push(limit);\\n        categories++;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/imports/Store.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Bank.sol\\\";\\nimport \\\"./ERC1155.sol\\\";\\nimport \\\"../libraries/Utils.sol\\\";\\nimport \\\"../libraries/Errors.sol\\\";\\nimport \\\"./Membership.sol\\\";\\nimport \\\"../interfaces/IStore.sol\\\";\\nimport \\\"./Sharable.sol\\\";\\n\\nabstract contract Store is Bank, IStore, Sharable {\\n    mapping(uint8=>uint256) private categoryToPrice;\\n    mapping(address=>uint256) private accountToNonce;\\n    address public paymentToken;\\n    address public discountSigner;\\n    bool public canBuyWithShare;\\n\\n    constructor(\\n        address _paymentToken,\\n        address _discountSigner,\\n        uint256[] memory prices\\n    ) {\\n        paymentToken = _paymentToken;\\n        discountSigner = _discountSigner;\\n        for (uint8 i = 0; i < prices.length; i++) {\\n            categoryToPrice[i] = prices[i];\\n        }\\n    }\\n\\n    modifier canBuy(uint8 category) {\\n        require(category == 0 || canBuyWithShare, Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    function setDiscountSigner(address account)\\n        external\\n        override\\n        accountIsManager(msg.sender)\\n    {\\n        discountSigner = account;\\n    }\\n\\n    function getNonce(address account)\\n        view\\n        external\\n        override\\n        returns(uint256)\\n    {\\n        return accountToNonce[account];\\n    }\\n\\n    function purchase(\\n        uint8 category,\\n        uint256 price,\\n        bytes calldata data\\n    )\\n        isValidCategory(category)\\n        override\\n        external\\n    {\\n        _buyAndGrantKey(\\n            msg.sender,\\n            block.timestamp + 365 days,\\n            category,\\n            currentEdition,\\n            price,\\n            false,\\n            data\\n        );\\n        emit Purchase(category, price, currentEdition, false);\\n    }\\n\\n    function renewMembership(uint8 category, uint256 edition, uint256 price, bytes calldata data)\\n        canRenewMembership(msg.sender, edition)\\n        override\\n        external\\n    {\\n        _buyAndGrantKey(\\n            msg.sender,\\n            block.timestamp + 365 days,\\n            category,\\n            edition,\\n            price,\\n            true,\\n            data\\n        );\\n        emit Purchase(category, price, edition, true);\\n    }\\n\\n    function _buyAndGrantKey(\\n        address account,\\n        uint256 expire,\\n        uint8 category,\\n        uint256 edition,\\n        uint256 price,\\n        bool isRenew,\\n        bytes calldata data\\n    )\\n        canBuy(category)\\n        private\\n    {\\n        if (data.length > 0) {\\n            require(\\n                Utils.verifySignature(\\n                    account,\\n                    category,\\n                    edition,\\n                    price,\\n                    accountToNonce[account],\\n                    data,\\n                    discountSigner\\n                ),\\n                Errors.INVALID_SIGNATURE\\n            );\\n            accountToNonce[account]++;\\n        } else {\\n            require(price == categoryToPrice[category], Errors.INVALID_PRICE);\\n        }\\n        if (price > 0) {\\n            IERC20(paymentToken).transferFrom(msg.sender, paymentReceiver, price);\\n        }\\n        _grantKey(account, expire, category, edition, isRenew);\\n    }\\n\\n    function _putNewCategory(uint64 limit, uint256 price)\\n        override\\n        internal\\n    {\\n        super._putNewCategory(limit, price);\\n        categoryToPrice[categories-1] = price;\\n    }\\n\\n    function getPrice(uint8 category)\\n        external\\n        view\\n        override\\n        returns(uint256)\\n    {\\n        return categoryToPrice[category];\\n    }\\n\\n    function setPrice(uint8 category, uint256 price)\\n        override\\n        external\\n        accountIsManager(msg.sender)\\n    {\\n        categoryToPrice[category] = price;\\n        emit PriceUpdated(category, price);\\n    }\\n\\n    function setBuyWithShare(bool value)\\n        external\\n        override\\n        accountIsManager(msg.sender)\\n    {\\n        canBuyWithShare = value;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IBank {\\n    /**\\n        @notice Set the new payment recipient.\\n        @dev Can only be called by the contract manager.\\n        @param _paymentReceiver The address of the ERC20 token.\\n     */\\n    function setPaymentReceiver(address _paymentReceiver) external;\\n\\n    /**\\n        @notice Called when the receiver is updated.\\n        @param _paymentReceiver The new recipient.\\n    */\\n    event ReceiverUpdated(address _paymentReceiver);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface IERC1155 {\\n    /**\\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\\n        The `_id` argument MUST be the token type being transferred.\\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\\n    */\\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\\n\\n    /**\\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\\n        The `_ids` argument MUST be the list of tokens being transferred.\\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\\n    */\\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\\n\\n    /**\\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).\\n    */\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    /**\\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \\\"Approval\\\" section of the standard).\\n        MUST revert if `_to` is the zero address.\\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\\n        MUST revert on any other error.\\n        MUST emit the `TransferSingle` event to reflect the balance change (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        @param _from    Source address\\n        @param _to      Target address\\n        @param _id      ID of the token type\\n        @param _value   Transfer amount\\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\\n    */\\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\\n\\n    /**\\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \\\"Approval\\\" section of the standard).\\n        MUST revert if `_to` is the zero address.\\n        MUST revert if length of `_ids` is not the same as length of `_values`.\\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\\n        MUST revert on any other error.\\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        @param _from    Source address\\n        @param _to      Target address\\n        @param _ids     IDs of each token type (order and length must match _values array)\\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\\n    */\\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\\n\\n    /**\\n        @notice Get the balance of an account's tokens.\\n        @param _owner  The address of the token holder\\n        @param _id     ID of the token\\n        @return        The _owner's balance of the token type requested\\n     */\\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\n\\n    /**\\n        @notice Get the balance of multiple account/token pairs\\n        @param _owners The addresses of the token holders\\n        @param _ids    ID of the tokens\\n        @return        The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\\n     */\\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\\n\\n    /**\\n        @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of the caller's tokens.\\n        @dev MUST emit the ApprovalForAll event on success.\\n        @param _operator  Address to add to the set of authorized operators\\n        @param _approved  True if the operator is approved, false to revoke approval\\n    */\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /**\\n        @notice Queries the approval status of an operator for a given owner.\\n        @param _owner     The owner of the tokens\\n        @param _operator  Address of authorized operator\\n        @return           True if the operator is approved, false if not\\n    */\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1155Metadata_URI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface IERC1155Metadata_URI {\\n\\n    /**\\n        @notice A distinct Uniform Resource Identifier (URI) for a given token.\\n        @dev URIs are defined in RFC 3986.\\n                The URI MUST point to a JSON file that conforms to the \\\"ERC-1155 Metadata URI JSON Schema\\\".\\n        @return URI string\\n    */\\n    function uri(uint256 _id) external view returns (string memory);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IERC1155TokenReceiver {\\n\\n    /**\\n        @notice Handle the receipt of a single ERC1155 token type.\\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\\n        This function MUST return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\\n        This function MUST revert if it rejects the transfer.\\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\\n        @param _from      The address which previously owned the token\\n        @param _id        The ID of the token being transferred\\n        @param _value     The amount of tokens being transferred\\n        @param _data      Additional data with no specified format\\n        @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n    */\\n    function onERC1155Received(\\n        address _operator,\\n        address _from,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external returns(bytes4);\\n\\n    /**\\n        @notice Handle the receipt of multiple ERC1155 token types.\\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\\n        This function MUST return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\\n        This function MUST revert if it rejects the transfer(s).\\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\\n        @param _from      The address which previously owned the token\\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\\n        @param _data      Additional data with no specified format\\n        @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n    */\\n    function onERC1155BatchReceived(\\n        address _operator,\\n        address _from,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    ) external returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IMain {\\n\\n    /**\\n        @notice Allow expired membership transfers.\\n        @dev Only contract manager can call this function.\\n    */\\n    function allowTransfers() external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMembership.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\n\\ninterface IMembership {\\n\\n    /**\\n        CATEGORIES\\n        0 -> individual\\n        1 -> startup\\n        2 -> company\\n    */\\n\\n    struct MembershipInfo {\\n        uint8 category;\\n        uint256 expirationTimestamp;\\n        uint256 edition;\\n    }\\n\\n    /**\\n        @notice Create a new edition.\\n        @dev Callable only by admins or higher.\\n        @param _uri The uri for the new edition's metadata.\\n    */\\n    function launchNewEdition(string memory _uri) external;\\n\\n    /**\\n        @notice Check if an account has a valid key.\\n        @param account The account to be checked.\\n        @return The number of available keys that can be shared.\\n     */\\n    function hasValidKey(address account) external view returns(bool);\\n\\n    /**\\n        @notice Get the membership info for a given account.\\n        @param account Target account.\\n        @return The info of the membership, including: category, expiration timestamp, and edition\\n     */\\n    function getMembershipInfo(address account) external view returns(MembershipInfo memory);\\n\\n    /**\\n        @notice Create a free key for the recipient address with given expiration date.\\n        @dev Callable only by admins or higher role. Reset the available sharable keys to the category maximum.\\n             Owner of membership cannot receive new memberships.\\n        @param recipient The receiver of the free key.\\n        @param category The category of the recipient account.\\n        @param expirationTimestamp Expiration date.\\n     */\\n    function grantKey(address recipient, uint8 category, uint256 expirationTimestamp) external;\\n\\n    /**\\n        @notice Grant a key for each address in the list.\\n        @dev Can be called only by admins or manager.\\n        @param recipients The list of recipients.\\n        @param _categories The category assigned to each recipient.\\n        @param _expires The expiration timestamp assigned to each recipient.\\n    */\\n    function airdrop(\\n        address[] calldata recipients,\\n        uint8[] calldata _categories,\\n        uint256[] calldata _expires\\n    ) external;\\n\\n    /**\\n        @notice Returns true if the account owns a key. Notice that if the account has a shared key, this function\\n            returns false.\\n        @param account The target account.\\n        @return True if the target account is a key owner, false otherwise.\\n    */\\n    function isKeyOwner(address account) external view returns(bool);\\n\\n    /**\\n        @notice Emitted when a new key is activated for the first time or renewed.\\n        @param receiver The account for which a key is activated.\\n        @param expire The expire date.\\n        @param isRenew True if the event is emitted after renewing an expired key, False if it is emitted after a\\n            new key is issued.\\n        @param edition The membership edition.\\n    */\\n    event MembershipActivation(\\n        address indexed receiver,\\n        uint256 expire,\\n        bool indexed isRenew,\\n        uint256 edition\\n    );\\n\\n    /*\\n        @notice Emitted when a new edition is launched.\\n        @param edition The new edition.\\n        @param uri The edition's uri.\\n    */\\n    event NewEdition(uint256 indexed edition, string uri);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IRoles {\\n    /**\\n        ROLES\\n        contract manager\\n            - all admin privileges\\n            - give and revoke admin role\\n            - set payment receiver address\\n        admin\\n\\n    */\\n\\n    /**\\n        @notice Assign or revoke admin role to the given account.\\n        @dev Callable only by the contract manager.\\n        @param account The target account.\\n        @param admin True if the role will be assigned, false if revoked.\\n     */\\n    function setAdmin(address account, bool admin) external;\\n\\n    /**\\n        @notice Renounce admin role.\\n     */\\n    function renounceAdmin() external;\\n\\n    /**\\n        @notice Set the manager of the smart contract.\\n        @dev Callable only by manager.\\n        @param account The address of the new smart contract manager.\\n     */\\n    function setManager(address account) external;\\n\\n    /**\\n        @notice Check if an account is admin\\n        @param account The account to be checked.\\n        @return true if the input account is admin, false otherwise.\\n     */\\n    function isAdmin(address account) external view returns(bool);\\n\\n    /**\\n        @notice Called when account is set as admin or its admin role is revoked.\\n        @param account The target account.\\n        @param isAdmin True if the target account is set as admin, false otherwise.\\n    */\\n    event AdminSet(address indexed account, bool isAdmin);\\n\\n    /**\\n        @notice Called when the contract manager is updated.\\n        @param newManager The new contract manager address.\\n    */\\n    event ManagerSet(address indexed newManager);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISharable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface ISharable {\\n    struct SharedInfo {\\n        address[] shared;\\n        address[] revoked;\\n        uint256 sharableKeys;\\n    }\\n\\n    struct OwnerInfo {\\n        address owner;\\n        uint256 expire;\\n    }\\n\\n    /**\\n        @notice It is used by startups and companies to share their key with a list of address.\\n        @dev Callable only by the owner of the key. Check if maximum number of sharable keys is reached.\\n        @param accounts The list of receiver addresses.\\n     */\\n    function shareKeyWith(address[] calldata accounts) external;\\n\\n\\n    /**\\n        @notice Creates a new category with given limit and price.\\n        @dev Callable only by contract manager.\\n        @param limit The limit of sharable keys.\\n        @param price The price.\\n     */\\n    function putNewCategory(uint64 limit, uint256 price) external;\\n\\n    /**\\n        @notice It is used by startups and companies to revoke their key from a list of address.\\n        @dev Callable only by the owner of the key.\\n        @param accounts The list of target addresses.\\n     */\\n    function revokeKeyFrom(address[] calldata accounts) external;\\n\\n    /**\\n        @notice Update the number of sharable keys for given category.\\n        @dev Callable only by contract manager.\\n        @param limit The maximum number of sharable keys for given category.\\n        @param category The given category.\\n     */\\n    function updateNumberOfSharableKeys(uint64 limit, uint8 category) external;\\n\\n    /**\\n        @notice Check if an account has a shared membership.\\n        @param keyOwner The owner of the membership.\\n        @return The list of shared keys and revoked.\\n     */\\n    function getAccountSharedInfo(address keyOwner) external view returns(SharedInfo memory);\\n\\n    /**\\n        @notice Get info if user has shared key.\\n        @param account Target account.\\n        @return The info about shared key for the target account.\\n     */\\n    function getAccountOwnerInfo(address account) external view returns(OwnerInfo memory);\\n\\n    /**\\n        @notice Get the number of sharable keys for given category.\\n        @param category The given category.\\n     */\\n    function getNumberOfSharableKeys(uint8 category)\\n        external\\n        view\\n        returns(uint64);\\n\\n    /**\\n        @notice Emitted when a key is shared or revoked.\\n        @param owner The owner of the key.\\n        @param targets The target addresses to which key is shared or revoked.\\n        @param shared True if the key is shared, false otherwise.\\n        @param edition The edition of the shared key.\\n    */\\n    event SharingKeys(address indexed owner, address[] targets, bool indexed shared, uint256 indexed edition);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IStore {\\n\\n    /**\\n        @notice Purchase a new key.\\n        @param category The category of the new key.\\n        @param price The price of the new key.\\n        @param data Signature to be verified.\\n    */\\n    function purchase(uint8 category, uint256 price, bytes calldata data) external;\\n\\n    /**\\n        @notice Renew an old key.\\n        @param category The category of the new key.\\n        @param edition The edition of the new key.\\n        @param price The price of the new key.\\n        @param data Signature to be verified.\\n    */\\n    function renewMembership(uint8 category, uint256 edition, uint256 price, bytes calldata data) external;\\n\\n    /**\\n        @notice Get the nonce of the target account.\\n        @param account The target account.\\n    */\\n    function getNonce(address account)\\n        view\\n        external\\n        returns(uint256);\\n\\n    /*\\n        @notice Set the account that can sign discounts.\\n        @dev Can be called only by contract managaer.\\n        @param account The new signer.\\n    */\\n    function setDiscountSigner(address account) external;\\n\\n    /*\\n        @notice Get the price for the given category.\\n        @param category The target category.\\n    */\\n    function getPrice(uint8 category)\\n        external\\n        view\\n        returns(uint256);\\n\\n    /*\\n        @notice Set the price for the target category.\\n        @dev Can be called only by the contract manager.\\n        @param category The target category.\\n        @param price The price assigned to the target category.\\n    */\\n    function setPrice(uint8 category, uint256 price) external;\\n\\n    /*\\n        @notice Set the status for allowing to buy keys that can be shared.\\n        @dev Can be called only by the contract manager.\\n        @param value The new status.\\n    */\\n    function setBuyWithShare(bool value) external;\\n\\n    /**\\n        @notice Emitted when the price for a given category is updated.\\n        @param category The target category.\\n        @param price The price assigned to the target category.\\n    */\\n    event PriceUpdated(uint8 category, uint256 price);\\n\\n    /**\\n        @notice Emitted when a purchase is completed.\\n        @param category The category of the new key.\\n        @param price The price of the new key.\\n        @param edition The edition of the new key.\\n        @param isRenew True if the key is renewed, false otherwise.\\n    */\\n    event Purchase(uint8 indexed category, uint256 price, uint256 indexed edition, bool indexed isRenew);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary Errors {\\n    string constant public NOT_OWNER_OR_OPERATOR = \\\"00\\\";\\n    string constant public NOT_MATCHING_SIZES = \\\"01\\\";\\n    string constant public BLOCKED_NFT = \\\"02\\\";\\n    string constant public UNKNOWN_VALUE = \\\"03\\\";\\n    string constant public NOT_KEY_OWNER = \\\"04\\\";\\n    string constant public KEY_OWNER = \\\"05\\\";\\n    string constant public CATEGORY_NOT_VALID = \\\"06\\\";\\n    string constant public NOT_AUTHORIZED = \\\"07\\\";\\n    string constant public LIMIT_REACHED = \\\"08\\\";\\n    string constant public NULL_ADDRESS = \\\"09\\\";\\n    string constant public INVALID_SIGNATURE = \\\"10\\\";\\n    string constant public ALREADY_SHARED = \\\"11\\\";\\n    string constant public INVALID_PRICE = \\\"12\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary Utils {\\n    function verifySignature(\\n        address account,\\n        uint8 category,\\n        uint256 edition,\\n        uint256 price,\\n        uint256 nonce,\\n        bytes calldata data,\\n        address signer\\n    )\\n        public\\n        pure\\n        returns(bool)\\n    {\\n        bytes32 messageHash = getMessageHash(account, category, edition, price, nonce);\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\n        return recoverSigner(ethSignedMessageHash, data) == signer;\\n    }\\n\\n    function recoverSigner(\\n        bytes32 _ethSignedMessageHash,\\n        bytes memory _signature\\n    ) public pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function getMessageHash(\\n        address account,\\n        uint8 category,\\n        uint256 edition,\\n        uint256 price,\\n        uint256 nonce\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(account, category, edition, price, nonce));\\n    }\\n\\n    function getEthSignedMessageHash(\\n        bytes32 _messageHash\\n    ) public pure returns (bytes32) {\\n        return keccak256(\\n            abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _messageHash)\\n        );\\n    }\\n\\n    function splitSignature(\\n        bytes memory sig\\n    ) public pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\n\\n        assembly {\\n        /*\\n        First 32 bytes stores the length of the signature\\n\\n        add(sig, 32) = pointer of sig + 32\\n        effectively, skips first 32 bytes of signature\\n\\n        mload(p) loads next 32 bytes starting at the memory address p into memory\\n        */\\n\\n        // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n        // second 32 bytes\\n            s := mload(add(sig, 64))\\n        // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        // implicitly return (r, s, v)\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Main.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"./imports/Sharable.sol\\\";\\nimport \\\"@thirdweb-dev/contracts/extension/ContractMetadata.sol\\\";\\nimport \\\"@thirdweb-dev/contracts/extension/Royalty.sol\\\";\\nimport \\\"./interfaces/IMain.sol\\\";\\nimport \\\"./imports/Bank.sol\\\";\\nimport \\\"./imports/Membership.sol\\\";\\nimport \\\"./imports/Roles.sol\\\";\\nimport \\\"./imports/Store.sol\\\";\\n\\n\\ncontract Main is ContractMetadata, Royalty, IMain, Store {\\n    bool public transferAllowed;\\n    mapping(bytes4=>bool) private idToIsSupportedInterface;\\n\\n    constructor(\\n        uint64[] memory _sharableKeys,\\n        address _paymentReceiver,\\n        address _contractManager,\\n        address _paymentToken,\\n        address _discountSigner,\\n        uint256[] memory prices\\n    )\\n        Bank(_paymentReceiver)\\n        Store(_paymentToken, _discountSigner, prices)\\n        Membership(uint8(_sharableKeys.length))\\n        Roles(_contractManager)\\n        Sharable(_sharableKeys)\\n    {\\n        idToIsSupportedInterface[0x01ffc9a7] = true; // ERC165\\n        idToIsSupportedInterface[0xd9b67a26] = true; // ERC1155\\n        idToIsSupportedInterface[0x0e89341c] = true; // Metadata\\n        idToIsSupportedInterface[0x2a55205a] = true; // Royalty\\n    }\\n\\n    modifier transfersNotAllowed() {\\n        require(!transferAllowed, Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    function _transfersAllowed()\\n        internal\\n        override\\n        view\\n        returns(bool)\\n    {\\n        return transferAllowed;\\n    }\\n\\n    function allowTransfers()\\n        override\\n        accountIsManager(msg.sender)\\n        transfersNotAllowed()\\n        external\\n    {\\n        transferAllowed = true;\\n    }\\n\\n    function _canSetContractURI()\\n        internal\\n        view\\n        override\\n        returns(bool)\\n    {\\n        return msg.sender == manager;\\n    }\\n\\n    function _canSetRoyaltyInfo()\\n        internal\\n        view\\n        override\\n        returns(bool)\\n    {\\n        return msg.sender == manager;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns(bool)\\n    {\\n        return idToIsSupportedInterface[interfaceID];\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/Utils.sol\": {\r\n        \"Utils\": \"0xa2fbad683a3f3861d9085df41384b62b0c728ef0\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"_sharableKeys\",\"type\":\"uint64[]\"},{\"internalType\":\"address\",\"name\":\"_paymentReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_discountSigner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"AdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"prevURI\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"ContractURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRoyaltyRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRoyaltyBps\",\"type\":\"uint256\"}],\"name\":\"DefaultRoyalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expire\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isRenew\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"edition\",\"type\":\"uint256\"}],\"name\":\"MembershipActivation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"edition\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"NewEdition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"edition\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isRenew\",\"type\":\"bool\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_paymentReceiver\",\"type\":\"address\"}],\"name\":\"ReceiverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyBps\",\"type\":\"uint256\"}],\"name\":\"RoyaltyForToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"shared\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"edition\",\"type\":\"uint256\"}],\"name\":\"SharingKeys\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_categories\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_expires\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canBuyWithShare\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"categories\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEdition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discountSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountOwnerInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expire\",\"type\":\"uint256\"}],\"internalType\":\"struct ISharable.OwnerInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keyOwner\",\"type\":\"address\"}],\"name\":\"getAccountSharedInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"shared\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"revoked\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"sharableKeys\",\"type\":\"uint256\"}],\"internalType\":\"struct ISharable.SharedInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultRoyaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getMembershipInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"edition\",\"type\":\"uint256\"}],\"internalType\":\"struct IMembership.MembershipInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"}],\"name\":\"getNumberOfSharableKeys\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyInfoForToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"grantKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasValidKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isKeyOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"launchNewEdition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"limit\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"putNewCategory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"edition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"renewMembership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"revokeKeyFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"admin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setBuyWithShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_royaltyBps\",\"type\":\"uint256\"}],\"name\":\"setDefaultRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setDiscountSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentReceiver\",\"type\":\"address\"}],\"name\":\"setPaymentReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bps\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyInfoForToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sharableKeys\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"shareKeyWith\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"limit\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"category\",\"type\":\"uint8\"}],\"name\":\"updateNumberOfSharableKeys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Main", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000fb4d14f8887ac60835e872902ec5cc69ff5ffba0000000000000000000000000f40fe06c96fb6be8cf1995dd039bb594086560460000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000001e29d87d77299e5555bac377f741c57f9cb0ba0000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000009d5b34000000000000000000000000000000000000000000000000000000003d77a050000000000000000000000000000000000000000000000000000000003d77a0500", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}