{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\ncontract GeoToken {\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => mapping(address => uint256)) public allowed;\r\n\r\n    string public name = \"GEOINDEX\";\r\n    string public symbol = \"GEO\";\r\n\r\n    address[] public tokenHolders;\r\n\r\n    IERC20 public geoToken;\r\n    uint256 public contractMaticBalance;\r\n    uint256 public maxSwapableGeo = 100 ether;\r\n\r\n    struct Proof {\r\n        uint256 Proof_id;\r\n        string State_id;\r\n        string Thesis;\r\n        string Body;\r\n        string Conclusion;\r\n        string ProofLink;\r\n        string[10] ProofLinks;\r\n    }\r\n\r\n    Proof[] public proofs;\r\n    mapping(uint256 => Proof) public proofsById;\r\n\r\n    uint256 public circulatingSupply;\r\n\r\n    constructor() {\r\n        totalSupply = 10_000_000 ether;\r\n        geoToken = IERC20(address(this));\r\n        circulatingSupply = 0; // Initial circulating supply is 0\r\n    }\r\n\r\n    function transfer(address to, uint256 value) external returns (bool) {\r\n        require(to != address(0));\r\n        require(balances[msg.sender] >= value);\r\n\r\n        if (to != address(this)) {\r\n            tokenHolders.push(to);\r\n        }\r\n\r\n        balances[msg.sender] -= value;\r\n        balances[to] += value;\r\n        return true;\r\n    }\r\n\r\n    function swapMaticForGEO() external payable {\r\n        require(msg.value == 100 ether, \"You can only swap 100 Matic for 100 GEO\");\r\n\r\n        uint256 geoAmount = 100 ether;\r\n        require(geoAmount <= maxSwapableGeo, \"Swap exceeds maximum swapable GEO tokens\");\r\n        require(geoAmount <= 100 * 10**18, \"Swap exceeds maximum 100 GEO tokens per transaction\");\r\n\r\n        balances[msg.sender] += geoAmount;\r\n        contractMaticBalance += msg.value;\r\n        circulatingSupply += geoAmount;\r\n        distributeMaticBalance();\r\n    }\r\n\r\n    receive() external payable {\r\n        if (msg.sender == address(this)) {\r\n            contractMaticBalance += msg.value;\r\n            // Circulating supply increases when Matic is received\r\n            circulatingSupply += msg.value;\r\n            distributeMaticBalance();\r\n        } else {\r\n            require(msg.value > 0, \"Invalid transaction\");\r\n            // Handle GEO token deposit or send GEO tokens back\r\n            if (balances[msg.sender] >= msg.value) {\r\n                // Sending GEO tokens back to the contract to update the circulating supply\r\n                balances[msg.sender] -= msg.value;\r\n                circulatingSupply += msg.value;\r\n                distributeMaticBalance();\r\n            } else {\r\n                // Implement the logic for GEO token deposit here\r\n            }\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        allowed[msg.sender][spender] = amount;\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return balances[account];\r\n    }\r\n\r\n    function createProof(\r\n        uint256 _Proof_id,\r\n        string memory _State_id,\r\n        string memory _Thesis,\r\n        string memory _Body,\r\n        string memory _Conclusion,\r\n        string memory _ProofLink,\r\n        string[10] memory _ProofLinks\r\n    ) external {\r\n        Proof memory newProof = Proof({\r\n            Proof_id: _Proof_id,\r\n            State_id: _State_id,\r\n            Thesis: _Thesis,\r\n            Body: _Body,\r\n            Conclusion: _Conclusion,\r\n            ProofLink: _ProofLink,\r\n            ProofLinks: _ProofLinks\r\n        });\r\n\r\n        proofs.push(newProof);\r\n        proofsById[_Proof_id] = newProof;\r\n        require(geoToken.transfer(msg.sender, 1000 ether), \"Token transfer failed\");\r\n        // Circulating supply increases when proofs are created\r\n        circulatingSupply += 1000 ether;\r\n    }\r\n\r\n    // Burn GEO tokens from circulating supply\r\n    function burnGEO(uint256 amount) external {\r\n        require(balances[msg.sender] >= amount, \"Insufficient balance to burn\");\r\n        balances[msg.sender] -= amount;\r\n        circulatingSupply -= amount;\r\n        distributeMaticBalance();\r\n    }\r\n\r\n    // Distribute Matic balance to token holders\r\n    function distributeMaticBalance() internal {\r\n        uint256 totalRewards = contractMaticBalance;\r\n        for (uint256 i = 0; i < tokenHolders.length; i++) {\r\n            address holder = tokenHolders[i];\r\n            uint256 geoBalance = balances[holder];\r\n            // Distribute Matic based on the circulating supply\r\n            uint256 geoValue = (geoBalance * totalRewards) / circulatingSupply;\r\n            (bool success, ) = holder.call{ value: geoValue }(\"\");\r\n            require(success, \"Matic distribution failed\");\r\n        }\r\n        contractMaticBalance = 0;\r\n    }\r\n\r\n    function getProof(uint256 Proof_id) external view returns (\r\n        uint256 _Proof_id,\r\n        string memory _State_id,\r\n        string memory _Thesis,\r\n        string memory _Body,\r\n        string memory _Conclusion,\r\n        string memory _ProofLink,\r\n        string[10] memory _ProofLinks\r\n    ) {\r\n        Proof memory proof = proofsById[Proof_id];\r\n        return (\r\n            proof.Proof_id,\r\n            proof.State_id,\r\n            proof.Thesis,\r\n            proof.Body,\r\n            proof.Conclusion,\r\n            proof.ProofLink,\r\n            proof.ProofLinks\r\n        );\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnGEO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractMaticBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_Proof_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_State_id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_Thesis\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_Body\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_Conclusion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_ProofLink\",\"type\":\"string\"},{\"internalType\":\"string[10]\",\"name\":\"_ProofLinks\",\"type\":\"string[10]\"}],\"name\":\"createProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"geoToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Proof_id\",\"type\":\"uint256\"}],\"name\":\"getProof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_Proof_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_State_id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_Thesis\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_Body\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_Conclusion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_ProofLink\",\"type\":\"string\"},{\"internalType\":\"string[10]\",\"name\":\"_ProofLinks\",\"type\":\"string[10]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSwapableGeo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proofs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Proof_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"State_id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Thesis\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Body\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Conclusion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ProofLink\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proofsById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Proof_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"State_id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Thesis\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Body\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Conclusion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ProofLink\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapMaticForGEO\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenHolders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GeoToken", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://29f0297823828aa490ce07252fe4dfc744defa9c2420eabbcd00c4eef19ecdbb"}