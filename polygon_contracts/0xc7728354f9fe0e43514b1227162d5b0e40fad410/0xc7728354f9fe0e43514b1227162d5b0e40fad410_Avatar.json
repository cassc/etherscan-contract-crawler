{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Avatar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\n// ReetrancyGuard\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./Bucket.sol\\\";\\n\\ncontract Avatar is ReentrancyGuard, Bucket {\\n    uint256 public constant PRINCIPAL_RATIO = 650000; // 65%\\n    uint256 public constant INVEST_RATIO = 260000; // 26%\\n    uint256 public constant PLATFORM_RATIO = 20000; // 2%\\n    uint256 public constant REFERRER_RATIO = 60000; // 6%\\n    uint256 public constant INCENTIVE_RATIO = 10000; // 1%\\n    uint256 public constant PRICE_PRECISION = 1e6;\\n\\n    uint256 public constant DEFAULT_INVEST_RETURN_RATE = 10000; // 1%\\n    uint256 public constant BOOST_INVEST_RETURN_RATE = 5000; // 0.5%\\n\\n    uint256 public constant MAX_INVEST = 1e21; // 1000\\n    uint256 public constant MIN_INVEST = 1e20; // 100\\n\\n    uint256 public constant TIME_UNIT = 1 days;\\n    uint256[6] public DEFAULT_TARGET_AMOUNTS = [13e22, 25e22, 35e22, 50e22, 75e22, 125e22];\\n\\n    uint256 public constant MAX_SEARCH_DEPTH = 50;\\n    uint256 public constant RANKED_INCENTIVE = 60;\\n\\n    address public platformAddress; // will be paymentsplitter contract address\\n\\n    uint256[6] public currentEpochs;\\n\\n    // ledge type => round epoch => address => position index => position info\\n    mapping(uint256 => mapping(address => PositionInfo[]))[6] public roundLedgers;\\n    //\\n    mapping(uint256 => RoundInfo)[6] public roundInfos;\\n    //\\n    mapping(address => UserRoundInfo[])[6] public userRoundsInfos;\\n\\n    mapping(address => UserGlobalInfo) public userGlobalInfos;\\n\\n    mapping(address => address[]) public children; // used for easily retrieve the referrer tree structure from front-end\\n\\n    // temp admin\\n    address public tempAdmin;\\n    address public operator;\\n    bool public gamePaused;\\n\\n    struct FundTarget {\\n        uint256 lastCheckTime;\\n        uint256 amount;\\n        uint256 achievedAmount;\\n    }\\n\\n    struct UserGlobalInfo {\\n        // referrer chain to record the referrer relationship\\n        address referrer;\\n        // referrer rearward vault\\n        uint256 totalReferrerReward;\\n        uint256 referrerRewardClaimed;\\n        // boost credit\\n        uint256 boostCredit;\\n        // sales record\\n        uint256 maxChildrenSales;\\n        uint256 sales;\\n        uint256 totalPositionAmount;\\n        uint256 reportedSales;\\n        uint8 salesLevel;\\n    }\\n\\n    struct PositionInfo {\\n        uint256 amount;\\n        uint256 openTime;\\n        uint256 expiryTime;\\n        uint256 investReturnRate;\\n        uint256 withdrawnAmount;\\n        uint256 incentiveAmount;\\n        uint256 investReturnAmount;\\n        uint256 index;\\n        bool incentiveClaimable;\\n    }\\n\\n    struct LinkedPosition {\\n        address user;\\n        uint256 userPositionIndex;\\n    }\\n\\n    struct RoundInfo {\\n        FundTarget fundTarget;\\n        uint256 totalPositionAmount; // total amount of all positions\\n        uint256 currentPrincipalAmount; // current principal amount\\n        uint256 currentInvestAmount; // current invest amount\\n        uint256 totalPositionCount; // total count of all positions\\n        uint256 currentPositionCount; // total count of all open positions\\n        uint256 currentIncentiveAmount; // current incentive amount\\n        uint256 incentiveSnapshot; // check total position of last N positions\\n        uint256 head; // head of linked position for last N positions\\n        mapping(uint256 => LinkedPosition) linkedPositions; // used for incentive track\\n        mapping(address => uint256) ledgerRoundToUserRoundIndex; // this round index in userRoundsInfos\\n        bool stopLoss; // default false means the round is running\\n    }\\n\\n    struct UserRoundInfo {\\n        uint256 epoch;\\n        uint256 totalPositionAmount;\\n        uint256 currentPrincipalAmount;\\n        uint256 totalWithdrawnAmount;\\n        uint256 totalIncentiveClaimedAmount;\\n        uint256 totalClosedPositionCount;\\n        uint256 returnRateBoostedAmount;\\n    }\\n\\n    struct ReferrerSearch {\\n        uint256 currentUserSales;\\n        uint256 currentReferrerSales;\\n        address currentReferrer;\\n        uint256 currentReferrerAmount;\\n        uint256 levelDiffAmount;\\n        uint256 leftLevelDiffAmount;\\n        uint256 levelDiffAmountPerLevel;\\n        uint256 levelSearchAmount;\\n        uint256 leftLevelSearchAmount;\\n        uint256 levelSearchAmountPerReferrer;\\n        uint256 levelSearchSales;\\n        uint256 currentReferrerMaxChildSales;\\n        uint256 currentUserTotalPosAmount;\\n        uint256 currentUserReportedSales;\\n        address currentUser;\\n        uint8 depth;\\n        uint8 levelSearchStep;\\n        uint8 currentLevelDiff;\\n        uint8 numLevelSearchCandidate;\\n        uint8 baseSalesLevel;\\n        uint8 currentReferrerLevel;\\n        bool levelDiffDone;\\n        bool levelSearchDone;\\n        bool levelSalesDone;\\n    }\\n\\n    struct OpenPositionParams {\\n        uint256 principalAmount;\\n        uint256 investAmount;\\n        uint256 referrerAmount;\\n        uint256 incentiveAmount;\\n        uint256 investReturnRate;\\n    }\\n\\n    event PositionOpened(\\n        address indexed user,\\n        uint256 indexed ledgeType,\\n        uint256 indexed epoch,\\n        uint256 positionIndex,\\n        uint256 amount\\n    );\\n\\n    event PositionClosed(\\n        address indexed user,\\n        uint256 indexed ledgeType,\\n        uint256 indexed epoch,\\n        uint256 positionIndex,\\n        uint256 amount\\n    );\\n\\n    event NewReferrer(address indexed user, address indexed referrer);\\n    event NewRound(uint256 indexed epoch, uint256 indexed ledgeType);\\n    event ReferrerRewardAdded(address indexed user, uint256 amount, uint256 indexed rewardType); // type 0 for levelDiff, 1 for levelSearch, 2 for levelSearch\\n    event ReferrerRewardClaimed(address indexed user, uint256 amount);\\n    event SalesLevelUpdated(address indexed user, uint8 level);\\n    event IncentiveClaimed(address indexed user, uint256 amount);\\n\\n    modifier notContract() {\\n        require(msg.sender == tx.origin, \\\"Contract not allowed\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @param _platformAddress The address of the platform\\n     * @param _tempAdmin The address of the temp admin\\n     * @param _operator The address of the operator\\n     */\\n    constructor(\\n        address _platformAddress,\\n        address _tempAdmin,\\n        address _operator\\n    ) {\\n        require(\\n            _platformAddress != address(0) && _tempAdmin != address(0) && _operator != address(0),\\n            \\\"Invalid address provided\\\"\\n        );\\n        emit NewRound(0, 0);\\n        emit NewRound(0, 1);\\n        emit NewRound(0, 2);\\n        emit NewRound(0, 3);\\n        emit NewRound(0, 4);\\n        emit NewRound(0, 5);\\n\\n        tempAdmin = _tempAdmin;\\n        operator = _operator;\\n        platformAddress = _platformAddress;\\n        gamePaused = true;\\n    }\\n\\n    /**\\n     * @notice Set the game paused status\\n     * @param _paused: The game paused status\\n     */\\n    function setPause(bool _paused) external {\\n        require(msg.sender == operator, \\\"Only operator\\\");\\n        // make sure the admin has dropped when game is unpaused\\n        if (!_paused) {\\n            require(tempAdmin == address(0), \\\"Temp admin not dropped\\\");\\n        }\\n        gamePaused = _paused;\\n    }\\n\\n    /**\\n     * @notice Transfer operator\\n     */\\n    function transferOperator(address _operator) external {\\n        require(msg.sender == operator, \\\"Only operator\\\");\\n        require(_operator != address(0), \\\"Invalid address\\\");\\n        operator = _operator;\\n    }\\n\\n    /**\\n     * @notice Drop the temp admin privilege\\n     */\\n    function dropTempAdmin() external {\\n        require(msg.sender == tempAdmin, \\\"Only admin\\\");\\n        tempAdmin = address(0);\\n    }\\n\\n    /**\\n     * @notice Batch set referrer information for users\\n     * @param users: The users to set\\n     * @param referrers: The referrers to set\\n     * @param salesLevels: The sales levels to set\\n     */\\n    function batchSetReferrerInfo(\\n        address[] calldata users,\\n        address[] calldata referrers,\\n        uint8[] calldata salesLevels\\n    ) external {\\n        require(msg.sender == tempAdmin, \\\"Only admin\\\");\\n        require(users.length == referrers.length && users.length == salesLevels.length, \\\"Invalid input\\\");\\n        UserGlobalInfo storage userGlobalInfo;\\n        uint256 userLength = users.length;\\n        for (uint256 i = 0; i < userLength; ++i) {\\n            require(users[i] != address(0), \\\"Invalid address provided\\\");\\n            userGlobalInfo = userGlobalInfos[users[i]];\\n            require(userGlobalInfo.referrer == address(0), \\\"Referrer already set\\\");\\n            userGlobalInfo.referrer = referrers[i];\\n            userGlobalInfo.salesLevel = salesLevels[i];\\n            children[referrers[i]].push(users[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Set fixed stock distribution to specific ledger type\\n     * @param ledgerType: The ledger type to set\\n     * @param typeDays: The days to set\\n     * @param stock: The stock to set\\n     */\\n    function setStock(\\n        uint256 ledgerType,\\n        uint8[] calldata typeDays,\\n        uint16[] calldata stock\\n    ) external {\\n        require(ledgerType > 0, \\\"Invalid ledger type\\\");\\n        require(ledgerType < 6, \\\"Invalid ledger type\\\");\\n        require(msg.sender == tempAdmin, \\\"Only admin\\\");\\n        require(stock.length > 0, \\\"Invalid stock array\\\");\\n        require(typeDays.length == stock.length, \\\"Invalid params\\\");\\n\\n        _setStock(ledgerType, typeDays, stock);\\n    }\\n\\n    /**\\n     * @notice Open a new position\\n     * @param ledgerType: The ledger type to open\\n     * @param targetEpoch: The target epoch to open\\n     * @param targetRate: The target ratio to open\\n     * @param referrer: The expected referrer\\n     * @param useBoost: Whether to use boost for this position\\n     */\\n    function openPosition(\\n        uint256 ledgerType,\\n        uint256 targetEpoch,\\n        uint256 targetRate,\\n        address referrer,\\n        bool useBoost\\n    ) external payable notContract nonReentrant {\\n        require(ledgerType < 6, \\\"Invalid ledger type\\\");\\n        require(targetEpoch == currentEpochs[ledgerType], \\\"Invalid epoch\\\");\\n        require(msg.value >= MIN_INVEST, \\\"Too small\\\");\\n        require(msg.value <= MAX_INVEST, \\\"Too large\\\");\\n        require(!gamePaused, \\\"Paused\\\");\\n\\n        // load user global info\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\n        // load global round info\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][targetEpoch];\\n        // placeholder for user round info\\n        UserRoundInfo storage userRoundInfo;\\n\\n        // determine referrer\\n        {\\n            address _referrer = userGlobalInfo.referrer;\\n            // if referrer is already set or msg.sender is the root user whose referrer is address(0)\\n            if (_referrer == address(0) && children[msg.sender].length == 0) {\\n                // if referrer is not set, set it and make sure it is a valid referrer\\n                require(referrer != address(0) && referrer != msg.sender, \\\"Invalid referrer\\\");\\n                // make sure referrer is registered already\\n                require(\\n                    userGlobalInfos[referrer].referrer != address(0) || children[referrer].length > 0,\\n                    \\\"Invalid referrer\\\"\\n                );\\n\\n                // update storage\\n                userGlobalInfo.referrer = referrer;\\n                children[referrer].push(msg.sender);\\n                emit NewReferrer(msg.sender, referrer);\\n            }\\n        }\\n\\n        // calculate each part of the amount\\n        OpenPositionParams memory params = OpenPositionParams({\\n            principalAmount: (msg.value * PRINCIPAL_RATIO) / PRICE_PRECISION,\\n            investAmount: (msg.value * INVEST_RATIO) / PRICE_PRECISION,\\n            referrerAmount: (msg.value * REFERRER_RATIO) / PRICE_PRECISION,\\n            incentiveAmount: (msg.value * INCENTIVE_RATIO) / PRICE_PRECISION,\\n            investReturnRate: _safeProcessFundTargetGetInvestReturnRate(roundInfo, ledgerType)\\n        });\\n\\n        // check target ratio\\n        require(targetRate <= params.investReturnRate, \\\"Invalid ratio\\\");\\n\\n        // update user's current ledger and current round info\\n        uint256 userRoundInfoLength = userRoundsInfos[ledgerType][msg.sender].length;\\n        if (\\n            userRoundInfoLength == 0 ||\\n            userRoundsInfos[ledgerType][msg.sender][userRoundInfoLength - 1].epoch < targetEpoch\\n        ) {\\n            // this is users first position in this round of this ledger type\\n            UserRoundInfo memory _userRoundInfo;\\n            _userRoundInfo = UserRoundInfo({\\n                epoch: targetEpoch,\\n                totalPositionAmount: 0,\\n                currentPrincipalAmount: 0,\\n                totalWithdrawnAmount: 0,\\n                totalIncentiveClaimedAmount: 0,\\n                totalClosedPositionCount: 0,\\n                returnRateBoostedAmount: 0\\n            });\\n            // push roundInfo to storage\\n            userRoundsInfos[ledgerType][msg.sender].push(_userRoundInfo);\\n            roundInfo.ledgerRoundToUserRoundIndex[msg.sender] = userRoundInfoLength;\\n            userRoundInfoLength += 1;\\n        }\\n\\n        // fetch back the roundInfo from storage for further direct modification\\n        userRoundInfo = userRoundsInfos[ledgerType][msg.sender][userRoundInfoLength - 1];\\n        userRoundInfo.totalPositionAmount += msg.value;\\n        userRoundInfo.currentPrincipalAmount += params.principalAmount;\\n\\n        if (useBoost) {\\n            uint256 boostCredit = userGlobalInfo.boostCredit;\\n            require(boostCredit >= msg.value, \\\"Exceed boost credit\\\");\\n            params.investReturnRate += BOOST_INVEST_RETURN_RATE; // + 0.5%\\n            userGlobalInfo.boostCredit -= msg.value;\\n        }\\n\\n        // update ledger round info\\n        roundInfo.totalPositionAmount += msg.value;\\n        roundInfo.currentPrincipalAmount += params.principalAmount;\\n        roundInfo.currentInvestAmount += params.investAmount;\\n        roundInfo.currentPositionCount += 1;\\n        roundInfo.currentIncentiveAmount += params.incentiveAmount;\\n        roundInfo.incentiveSnapshot += msg.value;\\n        roundInfo.totalPositionCount += 1;\\n\\n        uint256 userTotalPositionCount = roundLedgers[ledgerType][targetEpoch][msg.sender].length;\\n        // construct position info\\n        {\\n            uint256 expiryTime = block.timestamp;\\n            if (ledgerType == 0) {\\n                expiryTime += TIME_UNIT;\\n            } else {\\n                expiryTime += _pickDay(ledgerType, roundInfo.totalPositionCount) * TIME_UNIT;\\n            }\\n\\n            PositionInfo memory positionInfo = PositionInfo({\\n                amount: msg.value,\\n                openTime: block.timestamp,\\n                expiryTime: expiryTime,\\n                investReturnRate: params.investReturnRate,\\n                withdrawnAmount: 0,\\n                incentiveAmount: 0,\\n                investReturnAmount: 0,\\n                index: userTotalPositionCount,\\n                incentiveClaimable: true\\n            });\\n\\n            // push position info to round ledgers\\n            roundLedgers[ledgerType][targetEpoch][msg.sender].push(positionInfo);\\n        }\\n\\n        // distribute referrer funds\\n        _distributeReferrerReward(msg.sender, params.referrerAmount);\\n\\n        {\\n            // ranked incentive track\\n            mapping(uint256 => LinkedPosition) storage linkedPositions = roundInfo.linkedPositions;\\n\\n            // update the latest position (which is the current position) node\\n            LinkedPosition storage linkedPosition = linkedPositions[roundInfo.totalPositionCount - 1];\\n            linkedPosition.user = msg.sender;\\n            linkedPosition.userPositionIndex = userTotalPositionCount;\\n\\n            // adjust head in order to keep track last N positions\\n            if (roundInfo.totalPositionCount - roundInfo.head > RANKED_INCENTIVE) {\\n                // fetch current head node\\n                LinkedPosition storage headLinkedPosition = linkedPositions[roundInfo.head];\\n                PositionInfo storage headPositionInfo = roundLedgers[ledgerType][targetEpoch][headLinkedPosition.user][\\n                    headLinkedPosition.userPositionIndex\\n                ];\\n                // previous head position now is not eligible for incentive\\n                headPositionInfo.incentiveClaimable = false;\\n                // subtract head position amount, because we only keep the last RANKED_INCENTIVE positions\\n                roundInfo.incentiveSnapshot -= headPositionInfo.amount;\\n                // shift head to next global position to keep track the last N positions\\n                roundInfo.head += 1;\\n            }\\n        }\\n\\n        // do transfer to platform\\n        {\\n            (bool success, ) = platformAddress.call{\\n                value: msg.value -\\n                    params.principalAmount -\\n                    params.investAmount -\\n                    params.referrerAmount -\\n                    params.incentiveAmount\\n            }(\\\"\\\");\\n            require(success, \\\"Transfer failed.\\\");\\n        }\\n        // emit event\\n        emit PositionOpened(msg.sender, ledgerType, targetEpoch, userTotalPositionCount, msg.value);\\n    }\\n\\n    /**\\n     * @notice Close position\\n     * @param ledgerType: Ledger type\\n     * @param epoch: Epoch of the ledger\\n     * @param positionIndex: Position index of the user\\n     */\\n    function closePosition(\\n        uint256 ledgerType,\\n        uint256 epoch,\\n        uint256 positionIndex\\n    ) external notContract nonReentrant {\\n        require(ledgerType < 6, \\\"Invalid ledger type\\\");\\n        require(epoch <= currentEpochs[ledgerType], \\\"Invalid epoch\\\");\\n\\n        // check index is valid\\n        PositionInfo[] storage positionInfos = roundLedgers[ledgerType][epoch][msg.sender];\\n        require(positionIndex < positionInfos.length, \\\"Invalid position index\\\");\\n\\n        // get position Info\\n        PositionInfo storage positionInfo = positionInfos[positionIndex];\\n\\n        // get roundIno\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][epoch];\\n\\n        // user global info\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\n\\n        _safeClosePosition(ledgerType, epoch, positionIndex, positionInfo, roundInfo, userGlobalInfo);\\n    }\\n\\n    /**\\n     * @notice Close a batch of positions\\n     * @param ledgerType: Ledger type\\n     * @param epoch: Epoch of the ledger\\n     * @param positionIndexes: Position indexes of the user\\n     */\\n    function batchClosePositions(\\n        uint256 ledgerType,\\n        uint256 epoch,\\n        uint256[] calldata positionIndexes\\n    ) external nonReentrant {\\n        require(ledgerType < 6, \\\"Invalid ledger type\\\");\\n        require(epoch <= currentEpochs[ledgerType], \\\"Invalid epoch\\\");\\n        require(positionIndexes.length > 0, \\\"Invalid position indexes\\\");\\n\\n        // check index is valid\\n        PositionInfo[] storage positionInfos = roundLedgers[ledgerType][epoch][msg.sender];\\n\\n        // get roundIno\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][epoch];\\n\\n        // position info placeholder\\n        PositionInfo storage positionInfo;\\n\\n        // user global info\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\n\\n        uint256 positionIndexesLength = positionIndexes.length;\\n        uint256 positionInfosLength = positionInfos.length;\\n        for (uint256 i = 0; i < positionIndexesLength; ++i) {\\n            require(positionIndexes[i] < positionInfosLength, \\\"Invalid position index\\\");\\n            // get position Info\\n            positionInfo = positionInfos[positionIndexes[i]];\\n            _safeClosePosition(ledgerType, epoch, positionIndexes[i], positionInfo, roundInfo, userGlobalInfo);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim a batch of incentive claimable positions\\n     * @param ledgerType: Ledger type\\n     * @param epoch: Epoch of the ledger\\n     * @param positionIndexes: Position indexes of the user\\n     */\\n    function batchClaimPositionIncentiveReward(\\n        uint256 ledgerType,\\n        uint256 epoch,\\n        uint256[] calldata positionIndexes\\n    ) external notContract nonReentrant {\\n        require(ledgerType < 6, \\\"Invalid ledger type\\\");\\n        require(epoch < currentEpochs[ledgerType], \\\"Epoch not finished\\\");\\n\\n        // get position infos\\n        PositionInfo[] storage positionInfos = roundLedgers[ledgerType][epoch][msg.sender];\\n\\n        // get roundInfo\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][epoch];\\n\\n        // get user round info\\n        uint256 userRoundIndex = roundInfo.ledgerRoundToUserRoundIndex[msg.sender];\\n        UserRoundInfo storage userRoundInfo = userRoundsInfos[ledgerType][msg.sender][userRoundIndex];\\n\\n        // position info placeholder\\n        PositionInfo storage positionInfo;\\n\\n        // collect payout\\n        uint256 payoutAmount;\\n        uint256 positionIndex;\\n        uint256 positionIndexesLength = positionIndexes.length;\\n        uint256 positionInfosLength = positionInfos.length;\\n        for (uint256 i = 0; i < positionIndexesLength; ++i) {\\n            positionIndex = positionIndexes[i];\\n            require(positionIndex < positionInfosLength, \\\"Invalid position index\\\");\\n            // get position Info\\n            positionInfo = positionInfos[positionIndex];\\n            require(positionInfo.incentiveClaimable, \\\"Position not eligible\\\");\\n            // update positionInfo\\n            payoutAmount += _safeProcessIncentiveAmount(positionInfo, roundInfo);\\n        }\\n\\n        // transfer\\n        {\\n            (bool success, ) = msg.sender.call{value: payoutAmount}(\\\"\\\");\\n            require(success, \\\"Transfer failed.\\\");\\n        }\\n\\n        // update userRoundInfo\\n        userRoundInfo.totalIncentiveClaimedAmount += payoutAmount;\\n        emit IncentiveClaimed(msg.sender, payoutAmount);\\n    }\\n\\n    /**\\n     * @notice Report a batch users' sales\\n     * @param users: list of users\\n     */\\n    function batchReportSales(address[] calldata users) external {\\n        uint256 usersLength = users.length;\\n        for (uint256 i = 0; i < usersLength; ++i) {\\n            _safeReportSales(users[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim referrer reward\\n     * @param referrer: referrer address\\n     */\\n    function claimReferrerReward(address referrer) external notContract nonReentrant {\\n        require(referrer != address(0), \\\"Invalid referrer address\\\");\\n\\n        // get user global info\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[referrer];\\n\\n        // get claimable amount\\n        uint256 claimableAmount = userGlobalInfo.totalReferrerReward - userGlobalInfo.referrerRewardClaimed;\\n\\n        require(claimableAmount > 0, \\\"No claimable amount\\\");\\n\\n        // update state\\n        userGlobalInfo.referrerRewardClaimed += claimableAmount;\\n\\n        // do transfer\\n        {\\n            (bool success, ) = referrer.call{value: claimableAmount}(\\\"\\\");\\n            require(success, \\\"Transfer failed.\\\");\\n        }\\n\\n        // emit event\\n        emit ReferrerRewardClaimed(referrer, claimableAmount);\\n    }\\n\\n    function getLinkedPositionInfo(\\n        uint256 ledgerType,\\n        uint256 epoch,\\n        uint256 cursor,\\n        uint256 size\\n    ) external view returns (LinkedPosition[] memory, uint256) {\\n        uint256 length = size;\\n        uint256 positionCount = roundInfos[ledgerType][epoch].totalPositionCount;\\n        if (cursor + length > positionCount) {\\n            length = positionCount - cursor;\\n        }\\n        LinkedPosition[] memory linkedPositions = new LinkedPosition[](length);\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][epoch];\\n        for (uint256 i = 0; i < length; ++i) {\\n            linkedPositions[i] = roundInfo.linkedPositions[cursor + i];\\n        }\\n        return (linkedPositions, cursor + length);\\n    }\\n\\n    function getUserRounds(\\n        uint256 ledgerType,\\n        address user,\\n        uint256 cursor,\\n        uint256 size\\n    ) external view returns (UserRoundInfo[] memory, uint256) {\\n        uint256 length = size;\\n        uint256 roundCount = userRoundsInfos[ledgerType][user].length;\\n        if (cursor + length > roundCount) {\\n            length = roundCount - cursor;\\n        }\\n\\n        UserRoundInfo[] memory userRoundInfos = new UserRoundInfo[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            userRoundInfos[i] = userRoundsInfos[ledgerType][user][cursor + i];\\n        }\\n\\n        return (userRoundInfos, cursor + length);\\n    }\\n\\n    function getUserRoundsLength(uint256 ledgerType, address user) external view returns (uint256) {\\n        return userRoundsInfos[ledgerType][user].length;\\n    }\\n\\n    function getUserRoundLedgers(\\n        uint256 ledgerType,\\n        uint256 epoch,\\n        address user,\\n        uint256 cursor,\\n        uint256 size\\n    ) external view returns (PositionInfo[] memory, uint256) {\\n        uint256 length = size;\\n        uint256 positionCount = roundLedgers[ledgerType][epoch][user].length;\\n        if (cursor + length > positionCount) {\\n            length = positionCount - cursor;\\n        }\\n\\n        PositionInfo[] memory positionInfos = new PositionInfo[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            positionInfos[i] = roundLedgers[ledgerType][epoch][user][cursor + i];\\n        }\\n\\n        return (positionInfos, cursor + length);\\n    }\\n\\n    function getUserRoundLedgersLength(\\n        uint256 ledgerType,\\n        uint256 epoch,\\n        address user\\n    ) external view returns (uint256) {\\n        return roundLedgers[ledgerType][epoch][user].length;\\n    }\\n\\n    function getChildren(\\n        address user,\\n        uint256 cursor,\\n        uint256 size\\n    ) external view returns (address[] memory, uint256) {\\n        uint256 length = size;\\n        uint256 childrenCount = children[user].length;\\n        if (cursor + length > childrenCount) {\\n            length = childrenCount - cursor;\\n        }\\n\\n        address[] memory _children = new address[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            _children[i] = children[user][cursor + i];\\n        }\\n\\n        return (_children, cursor + length);\\n    }\\n\\n    function getLedgerRoundToUserRoundIndex(\\n        uint256 ledgerType,\\n        uint256 epoch,\\n        address user\\n    ) external view returns (uint256) {\\n        return roundInfos[ledgerType][epoch].ledgerRoundToUserRoundIndex[user];\\n    }\\n\\n    function getChildrenLength(address user) external view returns (uint256) {\\n        return children[user].length;\\n    }\\n\\n    function getUserDepartSalesAndLevel(address user) external view returns (uint256, uint8) {\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\n        return (userGlobalInfo.sales - userGlobalInfo.maxChildrenSales, userGlobalInfo.salesLevel);\\n    }\\n\\n    /**\\n     * @notice close a given position\\n     * @param ledgerType: ledger type\\n     * @param epoch: epoch of the ledger\\n     * @param positionIndex: position index of the user\\n     * @param positionInfo: storage of the position info\\n     * @param roundInfo: storage of the round info\\n     */\\n    function _safeClosePosition(\\n        uint256 ledgerType,\\n        uint256 epoch,\\n        uint256 positionIndex,\\n        PositionInfo storage positionInfo,\\n        RoundInfo storage roundInfo,\\n        UserGlobalInfo storage userGlobalInfo\\n    ) internal {\\n        require(positionInfo.withdrawnAmount == 0, \\\"Position already claimed\\\");\\n        require(positionInfo.expiryTime <= block.timestamp || roundInfo.stopLoss, \\\"Position not expired\\\");\\n\\n        // get user round info from storage\\n        uint256 targetRoundInfoIndex = roundInfo.ledgerRoundToUserRoundIndex[msg.sender];\\n        UserRoundInfo storage userRoundInfo = userRoundsInfos[ledgerType][msg.sender][targetRoundInfoIndex];\\n\\n        // calculate the amount to withdraw\\n        uint256 payoutAmount;\\n        uint256 principalAmount = (positionInfo.amount * PRINCIPAL_RATIO) / PRICE_PRECISION;\\n\\n        // get back the principal amount\\n        payoutAmount += principalAmount;\\n\\n        // update roundInfo\\n        roundInfo.currentPositionCount -= 1;\\n        roundInfo.currentPrincipalAmount -= principalAmount;\\n\\n        if (!roundInfo.stopLoss) {\\n            // calculate expected invest return amount\\n            // how many days passed\\n            uint256 daysPassed;\\n            if (ledgerType == 0) {\\n                // 1 day\\n                daysPassed = (block.timestamp - positionInfo.openTime);\\n            } else {\\n                daysPassed = (positionInfo.expiryTime - positionInfo.openTime);\\n            }\\n            uint256 expectedInvestReturnAmount = (positionInfo.amount * positionInfo.investReturnRate * daysPassed) /\\n                PRICE_PRECISION /\\n                TIME_UNIT;\\n\\n            // calculate the amount should be paid back from invest pool\\n            // 35% to total amount + expected return amount\\n            uint256 investReturnAmount = positionInfo.amount - principalAmount + expectedInvestReturnAmount;\\n\\n            // compare if current invest pool has enough amount\\n            if (roundInfo.currentInvestAmount < investReturnAmount) {\\n                // not enough, then just pay back the current invest pool amount\\n                investReturnAmount = roundInfo.currentInvestAmount;\\n                roundInfo.currentInvestAmount = 0;\\n            } else {\\n                // update round info\\n                unchecked {\\n                    roundInfo.currentInvestAmount -= investReturnAmount;\\n                }\\n            }\\n\\n            // check round is stop loss\\n            if (roundInfo.currentInvestAmount == 0) {\\n                roundInfo.stopLoss = true;\\n                currentEpochs[ledgerType] += 1;\\n                _refillStock(ledgerType);\\n                emit NewRound(currentEpochs[ledgerType], ledgerType);\\n            }\\n\\n            // update payout amount\\n            payoutAmount += investReturnAmount;\\n\\n            // update positionInfo\\n            positionInfo.investReturnAmount = investReturnAmount;\\n        }\\n\\n        uint256 incentiveAmount = 0;\\n        // calculate incentive amount if eligible\\n        if (roundInfo.stopLoss && positionInfo.incentiveClaimable) {\\n            incentiveAmount = _safeProcessIncentiveAmount(positionInfo, roundInfo);\\n\\n            // update payout amount\\n            payoutAmount += incentiveAmount;\\n\\n            // update incentive info to storage\\n            userRoundInfo.totalIncentiveClaimedAmount += incentiveAmount;\\n\\n            emit IncentiveClaimed(msg.sender, incentiveAmount);\\n        }\\n\\n        // update user round info\\n        userRoundInfo.totalWithdrawnAmount += payoutAmount;\\n        userRoundInfo.currentPrincipalAmount -= principalAmount;\\n\\n        // update positionInfo\\n        positionInfo.withdrawnAmount = payoutAmount;\\n\\n        // accumulate user's boost credit\\n        if (payoutAmount - incentiveAmount < positionInfo.amount) {\\n            userGlobalInfo.boostCredit += positionInfo.amount;\\n        }\\n\\n        // do transfer\\n        {\\n            (bool success, ) = msg.sender.call{value: payoutAmount}(\\\"\\\");\\n            require(success, \\\"Transfer failed.\\\");\\n        }\\n\\n        // emit event\\n        emit PositionClosed(msg.sender, ledgerType, epoch, positionIndex, payoutAmount);\\n    }\\n\\n    /**\\n     * @notice process current round's fund target and return the updated invest return rate\\n     * @param roundInfo: storage of the round info\\n     */\\n    function _safeProcessFundTargetGetInvestReturnRate(RoundInfo storage roundInfo, uint256 ledgerType)\\n        internal\\n        returns (uint256)\\n    {\\n        FundTarget storage fundTarget = roundInfo.fundTarget;\\n        uint256 targetAmount = fundTarget.amount;\\n        uint256 achievedAmount = fundTarget.achievedAmount;\\n        // this is amount of total locked position\\n        uint256 currentTotalAmount_d6 = roundInfo.currentPrincipalAmount * PRICE_PRECISION;\\n\\n        // process target fund\\n        {\\n            // check if this is the first time to process fund target\\n            if (fundTarget.lastCheckTime == 0) {\\n                // first check will use default parameter\\n                targetAmount = DEFAULT_TARGET_AMOUNTS[ledgerType];\\n\\n                // update check time and target amount to storage\\n                fundTarget.lastCheckTime = block.timestamp;\\n                fundTarget.amount = targetAmount;\\n            } else {\\n                // check if over 24 hours since last check\\n                if (block.timestamp - fundTarget.lastCheckTime > TIME_UNIT) {\\n                    // recalculate target amount\\n                    targetAmount =\\n                        (((currentTotalAmount_d6 * 361) / 1000 / PRINCIPAL_RATIO - roundInfo.currentInvestAmount) *\\n                            PRICE_PRECISION) /\\n                        260000;\\n\\n                    // update check time and target amount to storage\\n                    fundTarget.lastCheckTime = block.timestamp;\\n                    fundTarget.amount = targetAmount;\\n                    // reset achieved amount\\n                    fundTarget.achievedAmount = 0;\\n                    // reset achievedAmount in memory as well, because this will be the first position after adjusting the FundTarget\\n                    achievedAmount = 0;\\n                }\\n            }\\n            // update achieved amount in storage\\n            fundTarget.achievedAmount += msg.value;\\n        }\\n\\n        // calculate return rate\\n        // notice: no need to include current invest amount\\n        if (achievedAmount <= targetAmount) {\\n            return DEFAULT_INVEST_RETURN_RATE;\\n        }\\n\\n        // decrease 0.05% per 20% over target amount till 0.3%\\n        uint256 ratioDiff = (achievedAmount * PRICE_PRECISION) / targetAmount - PRICE_PRECISION;\\n        uint256 times = ratioDiff / (200000) + 1;\\n        if (ratioDiff % (200000) == 0) {\\n            times -= 1;\\n        }\\n        if (times > 14) {\\n            times = 14;\\n        }\\n\\n        return DEFAULT_INVEST_RETURN_RATE - (times * 500);\\n    }\\n\\n    /**\\n     * @notice process positionInfo and return incentive amount\\n     * @param positionInfo: storage of the position info\\n     * @param roundInfo: storage of the round info\\n     */\\n    function _safeProcessIncentiveAmount(PositionInfo storage positionInfo, RoundInfo storage roundInfo)\\n        internal\\n        returns (uint256)\\n    {\\n        // calculate incentive amount\\n        uint256 incentiveAmount = (positionInfo.amount * roundInfo.totalPositionAmount * INCENTIVE_RATIO) /\\n            roundInfo.incentiveSnapshot /\\n            PRICE_PRECISION;\\n\\n        // with PRICE_PRECISION is due to the precision of division may result in a few wei left over\\n        if (roundInfo.currentIncentiveAmount < incentiveAmount + PRICE_PRECISION) {\\n            // clean up incentive amount\\n            incentiveAmount = roundInfo.currentIncentiveAmount;\\n            roundInfo.currentIncentiveAmount = 0;\\n        } else {\\n            roundInfo.currentIncentiveAmount -= incentiveAmount;\\n        }\\n\\n        // this position is no longer eligible for incentive\\n        positionInfo.incentiveClaimable = false;\\n\\n        // update positionInfo\\n        positionInfo.incentiveAmount = incentiveAmount;\\n\\n        return incentiveAmount;\\n    }\\n\\n    /**\\n     * @notice process user's level info and return the current level\\n     * @param currentLevel: user current level\\n     * @param user: user address\\n     * @param currentSales: user current sales\\n     * @param userGlobalInfo: storage of the user global info\\n     */\\n    function _safeProcessSalesLevel(\\n        uint8 currentLevel,\\n        address user,\\n        uint256 currentSales,\\n        UserGlobalInfo storage userGlobalInfo\\n    ) internal returns (uint8) {\\n        uint8 newLevel = _getSalesToLevel(currentSales);\\n        if (newLevel > currentLevel) {\\n            userGlobalInfo.salesLevel = newLevel;\\n            emit SalesLevelUpdated(user, newLevel);\\n        } else {\\n            newLevel = currentLevel;\\n        }\\n        return newLevel;\\n    }\\n\\n    /**\\n     * @notice report user's sales and update its referrer sales level\\n     * @param user: user address\\n     */\\n    function _safeReportSales(address user) internal {\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\n        address referrer = userGlobalInfo.referrer;\\n        uint256 userSales = userGlobalInfo.sales;\\n        uint256 userReportedSales = userGlobalInfo.reportedSales;\\n\\n        // get user's un-reported sales\\n        uint256 unreportedSales = userSales - userReportedSales;\\n\\n        if (unreportedSales > 0) {\\n            // get referrer global info from storage\\n            UserGlobalInfo storage referrerGlobalInfo = userGlobalInfos[referrer];\\n            // fill up the sales to the referrer\\n            referrerGlobalInfo.sales += unreportedSales;\\n            // update user's reported sales\\n            userGlobalInfo.reportedSales = userSales;\\n\\n            // all reported sales + user's own contributed position will be current user's final sales\\n            userSales += userGlobalInfo.totalPositionAmount;\\n            // current referrer's max children sales\\n            uint256 maxChildrenSales = referrerGlobalInfo.maxChildrenSales;\\n            // update max children sales if needed\\n            if (userSales > maxChildrenSales) {\\n                // referrer's max children sales is updated\\n                referrerGlobalInfo.maxChildrenSales = userSales;\\n                // update cache of max children sales\\n                maxChildrenSales = userSales;\\n            }\\n            // process referrer's sales level\\n            _safeProcessSalesLevel(\\n                referrerGlobalInfo.salesLevel,\\n                referrer,\\n                referrerGlobalInfo.sales - maxChildrenSales, // sales for level calculation is sales - max children sales\\n                referrerGlobalInfo\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice distribute referrer reward\\n     * @param user: user address\\n     * @param referrerAmount: total amount of referrer reward\\n     */\\n    function _distributeReferrerReward(address user, uint256 referrerAmount) internal virtual {\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\n        UserGlobalInfo storage referrerGlobalInfo;\\n        uint256 positionAmount = msg.value;\\n\\n        // init all local variables as a search struct\\n        ReferrerSearch memory search;\\n        search.baseSalesLevel = 0;\\n        search.currentReferrer = userGlobalInfo.referrer;\\n        search.levelDiffAmount = (referrerAmount * 80) / 100;\\n        search.leftLevelDiffAmount = search.levelDiffAmount;\\n        search.levelDiffAmountPerLevel = search.levelDiffAmount / 12;\\n        search.levelSearchAmount = referrerAmount - search.levelDiffAmount;\\n        search.leftLevelSearchAmount = search.levelSearchAmount;\\n        search.levelSearchAmountPerReferrer = search.levelSearchAmount / 10;\\n        search.currentUserTotalPosAmount = userGlobalInfo.totalPositionAmount + positionAmount;\\n        userGlobalInfo.totalPositionAmount = search.currentUserTotalPosAmount;\\n        search.currentUser = user;\\n\\n        while (search.depth < MAX_SEARCH_DEPTH) {\\n            // stop if current referrer is the root\\n            if (search.currentReferrer == address(0)) {\\n                break;\\n            }\\n\\n            // this position does not counted as reported sales for first user himself\\n            if (search.depth > 0) userGlobalInfo.reportedSales += positionAmount;\\n\\n            // cache current user information\\n            search.currentUserSales = userGlobalInfo.sales;\\n            search.currentUserReportedSales = userGlobalInfo.reportedSales;\\n\\n            // cache current referrer information\\n            referrerGlobalInfo = userGlobalInfos[search.currentReferrer];\\n\\n            // update referrer sales\\n            {\\n                search.currentReferrerSales = referrerGlobalInfo.sales;\\n                // add current sales to current referrer\\n                search.currentReferrerSales += positionAmount;\\n                // check unreported sales\\n                if (search.currentUserReportedSales < search.currentUserSales) {\\n                    // update referrerSales to include unreported sales\\n                    search.currentReferrerSales += search.currentUserSales - search.currentUserReportedSales;\\n                    // update current node storage for reported sales\\n                    userGlobalInfo.reportedSales = search.currentUserSales;\\n                }\\n                // update sales for current referrer\\n                referrerGlobalInfo.sales = search.currentReferrerSales;\\n            }\\n\\n            // update referrer max children sales\\n            {\\n                // add current user's total position amount to current user's sales\\n                search.currentUserSales += search.currentUserTotalPosAmount;\\n                // check referrer's max child sales\\n                search.currentReferrerMaxChildSales = referrerGlobalInfo.maxChildrenSales;\\n                if (search.currentReferrerMaxChildSales < search.currentUserSales) {\\n                    // update max child sales\\n                    referrerGlobalInfo.maxChildrenSales = search.currentUserSales;\\n                    search.currentReferrerMaxChildSales = search.currentUserSales;\\n                }\\n            }\\n\\n            // process referrer's sales level\\n            // @notice: current referrer sales level should ignore its max child sales\\n            search.currentReferrerLevel = _safeProcessSalesLevel(\\n                referrerGlobalInfo.salesLevel,\\n                search.currentReferrer,\\n                search.currentReferrerSales - search.currentReferrerMaxChildSales,\\n                referrerGlobalInfo\\n            );\\n\\n            // start level diff calculation\\n            if (!search.levelDiffDone) {\\n                // compare the current referrer's level with the base sales level\\n                if (search.currentReferrerLevel > search.baseSalesLevel) {\\n                    // level diff\\n                    search.currentLevelDiff = search.currentReferrerLevel - search.baseSalesLevel;\\n\\n                    // update base level\\n                    search.baseSalesLevel = search.currentReferrerLevel;\\n\\n                    // calculate the referrer amount\\n                    search.currentReferrerAmount = search.currentLevelDiff * search.levelDiffAmountPerLevel;\\n\\n                    // check left referrer amount\\n                    if (search.currentReferrerAmount + PRICE_PRECISION > search.leftLevelDiffAmount) {\\n                        search.currentReferrerAmount = search.leftLevelDiffAmount;\\n                    }\\n\\n                    // update referrer's referrer amount\\n                    referrerGlobalInfo.totalReferrerReward += search.currentReferrerAmount;\\n                    emit ReferrerRewardAdded(search.currentReferrer, search.currentReferrerAmount, 0);\\n\\n                    unchecked {\\n                        search.leftLevelDiffAmount -= search.currentReferrerAmount;\\n                    }\\n\\n                    if (search.leftLevelDiffAmount == 0) {\\n                        search.levelDiffDone = true;\\n                    }\\n                }\\n            }\\n            if (!search.levelSearchDone) {\\n                // level search use referrer's real level\\n                search.levelSearchStep = _getLevelToLevelSearchStep(\\n                    _getSalesToLevel(search.currentReferrerSales - search.currentReferrerMaxChildSales)\\n                );\\n\\n                if (search.numLevelSearchCandidate + 1 <= search.levelSearchStep) {\\n                    search.numLevelSearchCandidate += 1;\\n\\n                    // check left referrer amount\\n                    if (search.levelSearchAmountPerReferrer + PRICE_PRECISION > search.leftLevelSearchAmount) {\\n                        search.levelSearchAmountPerReferrer = search.leftLevelSearchAmount;\\n                    }\\n\\n                    // update referrer's referrer amount\\n                    referrerGlobalInfo.totalReferrerReward += search.levelSearchAmountPerReferrer;\\n                    emit ReferrerRewardAdded(search.currentReferrer, search.levelSearchAmountPerReferrer, 1);\\n\\n                    unchecked {\\n                        search.leftLevelSearchAmount -= search.levelSearchAmountPerReferrer;\\n                    }\\n\\n                    if (search.leftLevelSearchAmount == 0) {\\n                        search.levelSearchDone = true;\\n                    }\\n                }\\n            }\\n\\n            search.currentUser = search.currentReferrer;\\n            search.currentReferrer = referrerGlobalInfo.referrer;\\n\\n            userGlobalInfo = referrerGlobalInfo;\\n            search.currentUserTotalPosAmount = userGlobalInfo.totalPositionAmount;\\n\\n            unchecked {\\n                search.depth += 1;\\n            }\\n        }\\n\\n        // check residual referrer amount\\n        if (search.leftLevelDiffAmount > 0) {\\n            userGlobalInfos[user].totalReferrerReward += search.leftLevelDiffAmount;\\n            emit ReferrerRewardAdded(user, search.leftLevelDiffAmount, 0);\\n        }\\n        if (search.leftLevelSearchAmount > 0) {\\n            userGlobalInfos[user].totalReferrerReward += search.leftLevelSearchAmount;\\n            emit ReferrerRewardAdded(user, search.leftLevelSearchAmount, 1);\\n        }\\n    }\\n\\n    /**\\n     * @notice get sales level from sales amount\\n     * @param amount: sales amount\\n     */\\n    function _getSalesToLevel(uint256 amount) internal pure virtual returns (uint8) {\\n        /* istanbul ignore else  */\\n        if (amount < 10000 ether) {\\n            return 0;\\n        } else if (amount < 100000 ether) {\\n            return 1;\\n        } else if (amount < 400000 ether) {\\n            return 2;\\n        } else if (amount < 800000 ether) {\\n            return 3;\\n        } else if (amount < 1500000 ether) {\\n            return 4;\\n        } else if (amount < 3000000 ether) {\\n            return 5;\\n        } else if (amount < 6000000 ether) {\\n            return 6;\\n        } else if (amount < 12000000 ether) {\\n            return 7;\\n        } else if (amount < 30000000 ether) {\\n            return 8;\\n        } else if (amount < 60000000 ether) {\\n            return 9;\\n        } else if (amount < 120000000 ether) {\\n            return 10;\\n        } else if (amount < 240000000 ether) {\\n            return 11;\\n        }\\n        return 12;\\n    }\\n\\n    /**\\n     * @notice level search step from level\\n     * @param level: sales level (0-12)\\n     */\\n    function _getLevelToLevelSearchStep(uint8 level) internal pure returns (uint8) {\\n        unchecked {\\n            if (level < 5) return level * 2;\\n        }\\n        return 10;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Bucket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\ncontract Bucket {\\n    struct BucketStock {\\n        uint8[] typeDays;\\n        uint16[] stockPrefixSum;\\n        uint16 currentBucketStock;\\n        mapping(uint16 => uint16) ledgerStockIndex;\\n        uint256 stockSize;\\n    }\\n\\n    mapping(uint256 => BucketStock) public ledgerBucketStock;\\n\\n    /**\\n     * @dev set an array of stock for the blind box\\n     */\\n    function _setStock(\\n        uint256 ledgerType,\\n        uint8[] calldata typeDays,\\n        uint16[] calldata stock\\n    ) internal {\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\n        uint16 itemCount = 0;\\n        uint16[] storage stockPrefixSum = bucketStock.stockPrefixSum;\\n        uint8[] storage typeDaysStorage = bucketStock.typeDays;\\n        uint256 stockLength = stock.length;\\n        for (uint16 i = 0; i < stockLength; ++i) {\\n            itemCount += stock[i];\\n            stockPrefixSum.push(itemCount);\\n            typeDaysStorage.push(typeDays[i]);\\n        }\\n        bucketStock.currentBucketStock = itemCount;\\n        bucketStock.stockSize = itemCount;\\n        require(stockPrefixSum.length <= 2e16, \\\"stock length too long\\\");\\n    }\\n\\n    /**\\n     * @dev refill the stock of the bucket\\n     * @param ledgerType the type of the ledger\\n     */\\n    function _refillStock(uint256 ledgerType) internal {\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\n        bucketStock.currentBucketStock = uint16(bucketStock.stockSize);\\n    }\\n\\n    /**\\n     * @dev Buy only one box\\n     */\\n    function _pickDay(uint256 ledgerType, uint256 seed) internal returns (uint16) {\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\n        uint16 randIndex = _getRandomIndex(seed, bucketStock.currentBucketStock);\\n        uint16 location = _pickLocation(randIndex, bucketStock);\\n        uint16 category = binarySearch(bucketStock.stockPrefixSum, location);\\n        return bucketStock.typeDays[category];\\n    }\\n\\n    function _pickLocation(uint16 index, BucketStock storage bucketStock) internal returns (uint16) {\\n        uint16 location = bucketStock.ledgerStockIndex[index];\\n        if (location == 0) {\\n            location = index + 1;\\n        }\\n        uint16 lastIndexLocation = bucketStock.ledgerStockIndex[bucketStock.currentBucketStock - 1];\\n\\n        if (lastIndexLocation == 0) {\\n            lastIndexLocation = bucketStock.currentBucketStock;\\n        }\\n        bucketStock.ledgerStockIndex[index] = lastIndexLocation;\\n        bucketStock.currentBucketStock--;\\n        bucketStock.ledgerStockIndex[bucketStock.currentBucketStock] = location;\\n\\n        // refill the bucket\\n        if (bucketStock.currentBucketStock == 0) {\\n            bucketStock.currentBucketStock = uint16(bucketStock.stockSize);\\n        }\\n        return location - 1;\\n    }\\n\\n    function _getRandomIndex(uint256 seed, uint16 size) internal view returns (uint16) {\\n        // NOTICE: We do not to prevent miner from front-running the transaction and the contract.\\n        return\\n            uint16(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            block.difficulty,\\n                            block.timestamp,\\n                            msg.sender,\\n                            blockhash(block.number - 1),\\n                            seed,\\n                            size\\n                        )\\n                    )\\n                ) % size\\n            );\\n    }\\n\\n    function getBucketInfo(uint256 ledgerType) external view returns (uint8[] memory, uint16[] memory) {\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\n        return (bucketStock.typeDays, bucketStock.stockPrefixSum);\\n    }\\n\\n    function binarySearch(uint16[] storage array, uint16 target) internal view returns (uint16) {\\n        uint256 left = 0;\\n        uint256 right = array.length - 1;\\n        uint256 mid;\\n        while (left < right - 1) {\\n            mid = left + (right - left) / 2;\\n            if (array[mid] > target) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        if (target < array[left]) {\\n            return uint16(left);\\n        } else {\\n            return uint16(right);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platformAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tempAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IncentiveClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"NewReferrer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ledgeType\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ledgeType\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PositionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ledgeType\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PositionOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardType\",\"type\":\"uint256\"}],\"name\":\"ReferrerRewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferrerRewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"SalesLevelUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BOOST_INVEST_RETURN_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_INVEST_RETURN_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DEFAULT_TARGET_AMOUNTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INCENTIVE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVEST_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_INVEST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SEARCH_DEPTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_INVEST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRINCIPAL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RANKED_INCENTIVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRER_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"positionIndexes\",\"type\":\"uint256[]\"}],\"name\":\"batchClaimPositionIncentiveReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"positionIndexes\",\"type\":\"uint256[]\"}],\"name\":\"batchClosePositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"batchReportSales\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referrers\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"salesLevels\",\"type\":\"uint8[]\"}],\"name\":\"batchSetReferrerInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"children\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"claimReferrerReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"}],\"name\":\"closePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentEpochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropTempAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"}],\"name\":\"getBucketInfo\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getChildren\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getChildrenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLedgerRoundToUserRoundIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getLinkedPositionInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userPositionIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct Avatar.LinkedPosition[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserDepartSalesAndLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserRoundLedgers\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"incentiveClaimable\",\"type\":\"bool\"}],\"internalType\":\"struct Avatar.PositionInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRoundLedgersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserRounds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalIncentiveClaimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClosedPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnRateBoostedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct Avatar.UserRoundInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRoundsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ledgerBucketStock\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"currentBucketStock\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"stockSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useBoost\",\"type\":\"bool\"}],\"name\":\"openPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastCheckTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"achievedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct Avatar.FundTarget\",\"name\":\"fundTarget\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentInvestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentIncentiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"head\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stopLoss\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundLedgers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"incentiveClaimable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint8[]\",\"name\":\"typeDays\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"stock\",\"type\":\"uint16[]\"}],\"name\":\"setStock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tempAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userGlobalInfos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalReferrerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerRewardClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boostCredit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxChildrenSales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reportedSales\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"salesLevel\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userRoundsInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalIncentiveClaimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClosedPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"returnRateBoostedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Avatar", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000009ca75d0d97f0b86dea852eb0a626f7839673d9d9000000000000000000000000874292bb0d775b03e8ecec3b5dabcd51794eb674000000000000000000000000874292bb0d775b03e8ecec3b5dabcd51794eb674", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}