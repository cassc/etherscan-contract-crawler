{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CrowdLinearDistribution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./BokkyPooBahsDateTimeLibrary.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract CrowdLinearDistribution is Ownable {\\r\\n\\r\\n    event CrowdLinearDistributionCreated(address beneficiary);\\r\\n    event CrowdLinearDistributionInitialized(address from);\\r\\n    event TokensReleased(address beneficiary, uint256 amount);\\r\\n\\r\\n    //0: Team_And_Advisors, 1: Community, 2: Investors, 3: Token_Launch_auction, 4: Liquidity\\r\\n    enum VestingType {\\r\\n        Team_And_Advisors,\\r\\n        Community,\\r\\n        Investors,\\r\\n        Token_Launch_auction,\\r\\n        Liquidity\\r\\n    }\\r\\n\\r\\n    struct BeneficiaryStruct {\\r\\n        uint256 _start;\\r\\n        uint256 _initial;\\r\\n        uint256 _released;\\r\\n        uint256 _balance;\\r\\n        uint256 _vestingType;\\r\\n        bool _exist;\\r\\n        Ruleset[] _ruleset;\\r\\n    }\\r\\n\\r\\n    struct VestingTypeStruct {\\r\\n        uint256 _initial;\\r\\n        uint256 _allocatedInitial;\\r\\n        Ruleset[] _ruleset;\\r\\n    }\\r\\n\\r\\n    struct Ruleset {\\r\\n        uint256 _month;\\r\\n        uint256 _value;//VestingTypeStruct: coefficient, BeneficiaryStruct: amount\\r\\n    }\\r\\n\\r\\n    mapping(address => BeneficiaryStruct) public _beneficiaryIndex;\\r\\n    mapping(VestingType => VestingTypeStruct) public _vestingTypeIndex;\\r\\n    address[] public _beneficiaries;\\r\\n    address public _tokenAddress;\\r\\n\\r\\n    constructor () {\\r\\n\\r\\n        VestingTypeStruct storage teamVestingTypeStruct = _vestingTypeIndex[VestingType.Team_And_Advisors];\\r\\n        teamVestingTypeStruct._initial = 40000000 ether;\\r\\n        teamVestingTypeStruct._ruleset.push(Ruleset(5, 100));\\r\\n        teamVestingTypeStruct._ruleset.push(Ruleset(11, 200));\\r\\n        teamVestingTypeStruct._ruleset.push(Ruleset(17, 325));\\r\\n        teamVestingTypeStruct._ruleset.push(Ruleset(1000, 500));\\r\\n\\r\\n        VestingTypeStruct storage communityVestingTypeStruct = _vestingTypeIndex[VestingType.Community];\\r\\n        communityVestingTypeStruct._initial = 10000000 ether;\\r\\n        communityVestingTypeStruct._ruleset.push(Ruleset(5, 100));\\r\\n        communityVestingTypeStruct._ruleset.push(Ruleset(11, 200));\\r\\n        communityVestingTypeStruct._ruleset.push(Ruleset(17, 325));\\r\\n        communityVestingTypeStruct._ruleset.push(Ruleset(1000, 500));\\r\\n\\r\\n        VestingTypeStruct storage investorsVestingTypeStruct = _vestingTypeIndex[VestingType.Investors];\\r\\n        investorsVestingTypeStruct._initial = 20000000 ether;\\r\\n        investorsVestingTypeStruct._ruleset.push(Ruleset(5, 100));\\r\\n        investorsVestingTypeStruct._ruleset.push(Ruleset(11, 200));\\r\\n        investorsVestingTypeStruct._ruleset.push(Ruleset(17, 325));\\r\\n        investorsVestingTypeStruct._ruleset.push(Ruleset(1000, 500));\\r\\n\\r\\n        VestingTypeStruct storage auctionVestingTypeStruct = _vestingTypeIndex[VestingType.Token_Launch_auction];\\r\\n        auctionVestingTypeStruct._initial = 50000000 ether;\\r\\n        auctionVestingTypeStruct._ruleset.push(Ruleset(9, 100));\\r\\n        auctionVestingTypeStruct._ruleset.push(Ruleset(1000, 200));\\r\\n\\r\\n        VestingTypeStruct storage liquidityVestingTypeStruct = _vestingTypeIndex[VestingType.Liquidity];\\r\\n        liquidityVestingTypeStruct._initial = 100000000 ether;\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(1, 120));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(2, 140));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(3, 160));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(4, 180));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(5, 200));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(6, 220));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(7, 240));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(8, 260));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(9, 280));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(10, 300));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(11, 320));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(12, 340));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(13, 360));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(14, 380));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(15, 400));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(16, 420));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(17, 440));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(18, 460));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(19, 480));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(20, 500));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(21, 520));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(22, 540));\\r\\n        liquidityVestingTypeStruct._ruleset.push(Ruleset(1000, 550));\\r\\n    }\\r\\n\\r\\n    fallback() external {\\r\\n        revert(\\\"ce01\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice initialize contract.\\r\\n     */\\r\\n    function initialize(address tokenAddress) external onlyOwner {\\r\\n        require(tokenAddress != address(0) , \\\"CrowdLinearDistribution: the token address is not valid\\\");\\r\\n        _tokenAddress = tokenAddress;\\r\\n\\r\\n        emit CrowdLinearDistributionInitialized(address(msg.sender));\\r\\n    }\\r\\n    \\r\\n    function create(address beneficiary, uint256 start, uint8 vestingType, uint256 initial) external onlyOwner {\\r\\n        require(_tokenAddress != address(0), \\\"CrowdLinearDistribution: the token address is not valid\\\");\\r\\n        require(!_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary exists\\\");\\r\\n        require(vestingType >= 0 && vestingType < 5, \\\"CrowdLinearDistribution: vestingType is not valid\\\");\\r\\n        require(initial > 0, \\\"CrowdLinearDistribution: initial must be greater than zero\\\");\\r\\n\\r\\n        VestingTypeStruct storage vestingTypeStruct = _vestingTypeIndex[VestingType(vestingType)];\\r\\n        require(initial + vestingTypeStruct._allocatedInitial <= vestingTypeStruct._initial, \\\"CrowdLinearDistribution: Not enough token to distribute\\\");\\r\\n\\r\\n        _beneficiaries.push(beneficiary);\\r\\n        BeneficiaryStruct storage beneficiaryStruct = _beneficiaryIndex[beneficiary];\\r\\n        beneficiaryStruct._start = start;\\r\\n        beneficiaryStruct._initial = initial;\\r\\n        beneficiaryStruct._vestingType = vestingType;\\r\\n        beneficiaryStruct._exist = true;\\r\\n        for(uint i = 0; i < vestingTypeStruct._ruleset.length; i++) {\\r\\n            Ruleset memory ruleset = vestingTypeStruct._ruleset[i];\\r\\n            beneficiaryStruct._ruleset.push(Ruleset(ruleset._month, calculateAmount(ruleset._value, initial)));\\r\\n        }\\r\\n        beneficiaryStruct._balance = beneficiaryStruct._ruleset[vestingTypeStruct._ruleset.length - 1]._value;\\r\\n\\r\\n        vestingTypeStruct._allocatedInitial = vestingTypeStruct._allocatedInitial + initial;\\r\\n\\r\\n        emit CrowdLinearDistributionCreated(beneficiary);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers vested tokens to beneficiary.\\r\\n     */\\r\\n    function release(address beneficiary) external {\\r\\n        require(_tokenAddress != address(0), \\\"CrowdLinearDistribution: token address not valid\\\");\\r\\n        uint256 unreleased = getReleasable(beneficiary);\\r\\n\\r\\n        require(unreleased > 0, \\\"CrowdLinearDistribution: releasable amount is zero\\\");\\r\\n\\r\\n        _beneficiaryIndex[beneficiary]._released = _beneficiaryIndex[beneficiary]._released + unreleased;\\r\\n        _beneficiaryIndex[beneficiary]._balance = _beneficiaryIndex[beneficiary]._balance - unreleased;\\r\\n        \\r\\n        IERC20(_tokenAddress).transfer(beneficiary, unreleased);\\r\\n\\r\\n        emit TokensReleased(beneficiary, unreleased);\\r\\n    }\\r\\n    \\r\\n    function getBeneficiaries(uint256 vestingType) external view returns (address[] memory) {\\r\\n        require(vestingType >= 0 && vestingType < 5, \\\"CrowdLinearDistribution: vestingType is not valid\\\");\\r\\n\\r\\n        uint256 j = 0;\\r\\n        address[] memory beneficiaries = new address[](_beneficiaries.length);\\r\\n\\r\\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\\r\\n            address beneficiary = _beneficiaries[i];\\r\\n            if (_beneficiaryIndex[beneficiary]._vestingType == vestingType) {\\r\\n                beneficiaries[j] = beneficiary;\\r\\n                j++;\\r\\n            }\\r\\n\\r\\n        }\\r\\n        return beneficiaries;\\r\\n    }\\r\\n\\r\\n    function getVestingType(address beneficiary) external view returns (uint256) {\\r\\n        require(_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary does not exist\\\");\\r\\n\\r\\n        return _beneficiaryIndex[beneficiary]._vestingType;\\r\\n    }\\r\\n\\r\\n    function getBeneficiary(address beneficiary) external view returns (BeneficiaryStruct memory) {\\r\\n        require(_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary does not exist\\\");\\r\\n\\r\\n        return _beneficiaryIndex[beneficiary];\\r\\n    }\\r\\n\\r\\n    function getInitial(address beneficiary) external view returns (uint256) {\\r\\n        require(_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary does not exist\\\");\\r\\n\\r\\n        return _beneficiaryIndex[beneficiary]._initial;\\r\\n    }\\r\\n\\r\\n    function getStart(address beneficiary) external view returns (uint256) {\\r\\n        require(_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary does not exist\\\");\\r\\n\\r\\n        return _beneficiaryIndex[beneficiary]._start;\\r\\n    }\\r\\n\\r\\n    function getTotal(address beneficiary) external view returns (uint256) {\\r\\n        require(_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary does not exist\\\");\\r\\n\\r\\n        return _beneficiaryIndex[beneficiary]._balance + _beneficiaryIndex[beneficiary]._released;\\r\\n    }\\r\\n\\r\\n    function getVested(address beneficiary) external view returns (uint256) {\\r\\n        require(_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary does not exist\\\");\\r\\n\\r\\n        return _vestedAmount(beneficiary);\\r\\n    }\\r\\n\\r\\n    function getReleased(address beneficiary) external view returns (uint256) {\\r\\n        require(_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary does not exist\\\");\\r\\n\\r\\n        return _beneficiaryIndex[beneficiary]._released;\\r\\n    }\\r\\n    \\r\\n    function getBalance(address beneficiary) external view returns (uint256) {\\r\\n        require(_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary does not exist\\\");\\r\\n\\r\\n        return uint256(_beneficiaryIndex[beneficiary]._balance);\\r\\n    }\\r\\n\\r\\n    function getVestingTypeStruct(uint256 vestingType) external view returns (VestingTypeStruct memory) {\\r\\n        require(vestingType >= 0 && vestingType < 5, \\\"CrowdLinearDistribution: vestingType is not valid\\\");\\r\\n\\r\\n        return _vestingTypeIndex[VestingType(vestingType)];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the releasable amount of token for the given beneficiary\\r\\n     */\\r\\n    function getReleasable(address beneficiary) public view returns (uint256) {\\r\\n        require(_beneficiaryIndex[beneficiary]._exist, \\\"CrowdLinearDistribution: beneficiary does not exist\\\");\\r\\n\\r\\n        return _vestedAmount(beneficiary) - _beneficiaryIndex[beneficiary]._released;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates the amount that has already vested.\\r\\n     */\\r\\n    function _vestedAmount(address beneficiary) private view returns (uint256) {\\r\\n        BeneficiaryStruct storage tokenVesting = _beneficiaryIndex[beneficiary];\\r\\n        uint256 totalBalance = tokenVesting._balance + tokenVesting._released;\\r\\n\\r\\n        if (block.timestamp < tokenVesting._start)\\r\\n            return 0;\\r\\n\\r\\n        uint256 _months = BokkyPooBahsDateTimeLibrary.diffMonths(tokenVesting._start, block.timestamp);\\r\\n\\r\\n        if (_months < 1)\\r\\n            return tokenVesting._initial;\\r\\n\\r\\n        uint256 result = 0;\\r\\n        for (uint256 i = 0; i < tokenVesting._ruleset.length; i++) {\\r\\n            Ruleset memory ruleset = tokenVesting._ruleset[i];\\r\\n            if (_months <= ruleset._month) {\\r\\n                result = ruleset._value;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return (result >= totalBalance) ? totalBalance : result;\\r\\n    }\\r\\n\\r\\n    function calculateAmount(uint coefficient, uint beneficiaryInitial) private pure returns (uint) {\\r\\n        return (coefficient * beneficiaryInitial) / (10 ** 2);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/BokkyPooBahsDateTimeLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\n// ----------------------------------------------------------------------------\\r\\n// BokkyPooBah's DateTime Library v1.01\\r\\n//\\r\\n// A gas-efficient Solidity date and time library\\r\\n//\\r\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\r\\n//\\r\\n// Tested date range 1970/01/01 to 2345/12/31\\r\\n//\\r\\n// Conventions:\\r\\n// Unit      | Range         | Notes\\r\\n// :-------- |:-------------:|:-----\\r\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\r\\n// year      | 1970 ... 2345 |\\r\\n// month     | 1 ... 12      |\\r\\n// day       | 1 ... 31      |\\r\\n// hour      | 0 ... 23      |\\r\\n// minute    | 0 ... 59      |\\r\\n// second    | 0 ... 59      |\\r\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\r\\n//\\r\\n//\\r\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\r\\n// ----------------------------------------------------------------------------\\r\\n\\r\\nlibrary BokkyPooBahsDateTimeLibrary {\\r\\n\\r\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n    int constant OFFSET19700101 = 2440588;\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\r\\n    // the date conversion algorithm from\\r\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\r\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\r\\n    //\\r\\n    // int L = days + 68569 + offset\\r\\n    // int N = 4 * L / 146097\\r\\n    // L = L - (146097 * N + 3) / 4\\r\\n    // year = 4000 * (L + 1) / 1461001\\r\\n    // L = L - 1461 * year / 4 + 31\\r\\n    // month = 80 * L / 2447\\r\\n    // dd = L - 2447 * month / 80\\r\\n    // L = month / 11\\r\\n    // month = month + 2 - 12 * L\\r\\n    // year = 100 * (N - 49) + year + L\\r\\n    // ------------------------------------------------------------------------\\r\\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\r\\n        int __days = int(_days);\\r\\n\\r\\n        int L = __days + 68569 + OFFSET19700101;\\r\\n        int N = 4 * L / 146097;\\r\\n        L = L - (146097 * N + 3) / 4;\\r\\n        int _year = 4000 * (L + 1) / 1461001;\\r\\n        L = L - 1461 * _year / 4 + 31;\\r\\n        int _month = 80 * L / 2447;\\r\\n        int _day = L - 2447 * _month / 80;\\r\\n        L = _month / 11;\\r\\n        _month = _month + 2 - 12 * L;\\r\\n        _year = 100 * (N - 49) + _year + L;\\r\\n\\r\\n        year = uint(_year);\\r\\n        month = uint(_month);\\r\\n        day = uint(_day);\\r\\n    }\\r\\n\\r\\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\\r\\n        require(fromTimestamp <= toTimestamp, 'BP03');\\r\\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\r\\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\r\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.10;\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n    address private _pendingOwner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n     * account.\\r\\n     */\\r\\n    constructor() {\\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == _owner, \\\"ce30\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the address of the current owner.\\r\\n    */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Returns the address of the pending owner.\\r\\n    */\\r\\n    function pendingOwner() public view returns (address) {\\r\\n        return _pendingOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to set the pendingOwner address.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _pendingOwner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the pendingOwner address to finalize the transfer.\\r\\n     */\\r\\n    function claimOwnership() public {\\r\\n        require(msg.sender == _pendingOwner, \\\"ce31\\\");\\r\\n        _owner = _pendingOwner;\\r\\n        _pendingOwner = address(0);\\r\\n        emit OwnershipTransferred(_owner, _pendingOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"CrowdLinearDistributionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"CrowdLinearDistributionInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensReleased\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_beneficiaries\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_beneficiaryIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initial\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingType\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_exist\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CrowdLinearDistribution.VestingType\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"_vestingTypeIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_initial\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocatedInitial\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"vestingType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"initial\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vestingType\",\"type\":\"uint256\"}],\"name\":\"getBeneficiaries\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getBeneficiary\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initial\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingType\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_exist\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"internalType\":\"struct CrowdLinearDistribution.Ruleset[]\",\"name\":\"_ruleset\",\"type\":\"tuple[]\"}],\"internalType\":\"struct CrowdLinearDistribution.BeneficiaryStruct\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getInitial\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getReleasable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"getVestingType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vestingType\",\"type\":\"uint256\"}],\"name\":\"getVestingTypeStruct\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_initial\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocatedInitial\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"internalType\":\"struct CrowdLinearDistribution.Ruleset[]\",\"name\":\"_ruleset\",\"type\":\"tuple[]\"}],\"internalType\":\"struct CrowdLinearDistribution.VestingTypeStruct\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CrowdLinearDistribution", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}