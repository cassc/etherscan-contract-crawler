{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./lib/EIP712MetaTransaction.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\r\\n\\r\\n\\r\\ncontract TokenTransfer is EIP712MetaTransaction(\\\"TokenTransfer\\\",\\\"1\\\") {\\r\\n    IERC20 _token;\\r\\n\\r\\n    constructor(address token) {\\r\\n        _token = IERC20(token);\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint amount) public {  \\r\\n       require(_token.allowance(msgSender(), address(this)) >= amount, \\\"Token allowance too low\\\");\\r\\n        bool sent = _token.transferFrom(msgSender(), to, amount);\\r\\n        require(sent, \\\"Token transfer failed\\\");\\r\\n    }\\r\\n} \"\r\n    },\r\n    \"contracts/lib/EIP712MetaTransaction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n//Playground branch - uses salt in place of chainId - note msgSender function is different\\r\\n//https://github.com/bcnmy/metatx-standard/blob/playground/src/contracts/EIP712MetaTransaction.sol\\r\\n\\r\\n//Mumbai-demo branch - uses chain id instead of salt - note msgSender function is different\\r\\n//https://github.com/bcnmy/metatx-standard/blob/mumbai-demo/src/contracts/EIP712MetaTransaction.sol\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./EIP712Base.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ncontract EIP712MetaTransaction is EIP712Base {\\r\\n    using SafeMath for uint256;\\r\\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(bytes(\\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"));\\r\\n\\r\\n    event MetaTransactionExecuted(address userAddress, address payable relayerAddress, bytes functionSignature);\\r\\n    mapping(address => uint256) nonces;\\r\\n\\r\\n    /*\\r\\n     * Meta transaction structure.\\r\\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\\r\\n     * He should call the desired function directly in that case.\\r\\n     */\\r\\n    struct MetaTransaction {\\r\\n\\t\\tuint256 nonce;\\r\\n\\t\\taddress from;\\r\\n        bytes functionSignature;\\r\\n\\t}\\r\\n\\r\\n    constructor(string memory name, string memory version) EIP712Base(name, version) {}\\r\\n\\r\\n    function executeMetaTransaction(address userAddress,\\r\\n        bytes memory functionSignature, bytes32 sigR, bytes32 sigS, uint8 sigV) public payable returns(bytes memory) {\\r\\n\\r\\n        MetaTransaction memory metaTx = MetaTransaction({\\r\\n            nonce: nonces[userAddress],\\r\\n            from: userAddress,\\r\\n            functionSignature: functionSignature\\r\\n        });\\r\\n        require(verify(userAddress, metaTx, sigR, sigS, sigV), \\\"Signer and signature do not match\\\");\\r\\n\\tnonces[userAddress] = nonces[userAddress].add(1);\\r\\n        // Append userAddress at the end to extract it from calling context\\r\\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, userAddress, msg.sender));\\r\\n\\r\\n        require(success, \\\"Function call not successfull\\\");\\r\\n        emit MetaTransactionExecuted(userAddress, payable(msg.sender), functionSignature);\\r\\n        return returnData;\\r\\n    }\\r\\n\\r\\n    function hashMetaTransaction(MetaTransaction memory metaTx) internal pure returns (bytes32) {\\r\\n\\t\\treturn keccak256(abi.encode(\\r\\n            META_TRANSACTION_TYPEHASH,\\r\\n            metaTx.nonce,\\r\\n            metaTx.from,\\r\\n            keccak256(metaTx.functionSignature)\\r\\n        ));\\r\\n\\t}\\r\\n\\r\\n    function getNonce(address user) public view returns(uint256 nonce) {\\r\\n        nonce = nonces[user];\\r\\n    }\\r\\n\\r\\n    function verify(address user, MetaTransaction memory metaTx, bytes32 sigR, bytes32 sigS, uint8 sigV) internal view returns (bool) {\\r\\n        address signer = ecrecover(toTypedMessageHash(hashMetaTransaction(metaTx)), sigV, sigR, sigS);\\r\\n        require(signer != address(0), \\\"Invalid signature\\\");\\r\\n\\treturn signer == user;\\r\\n    }\\r\\n\\r\\n  \\r\\n\\r\\n    //*** this msgSender works with chainId in domain type/ domain data */\\r\\n    function msgSender() internal view returns(address sender) {\\r\\n        if(msg.sender == address(this)) {\\r\\n            bytes20 userAddress;\\r\\n            uint256 dataLength = msg.data.length;\\r\\n            assembly {\\r\\n                calldatacopy(0x0, sub(dataLength, 40), sub(dataLength, 20))\\r\\n                userAddress := mload(0x0)\\r\\n            }\\r\\n            sender = address(uint160(userAddress));\\r\\n        } else {\\r\\n            sender = msg.sender;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** this msgSender works with salt in the domain type / domain data */\\r\\n     // function msgSender() internal view returns(address sender) {\\r\\n    //     if(msg.sender == address(this)) {\\r\\n    //         bytes memory array = msg.data;\\r\\n    //         uint256 index = msg.data.length;\\r\\n    //         assembly {\\r\\n    //             // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\r\\n    //             sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\r\\n    //         }\\r\\n    //     } else {\\r\\n    //         sender = msg.sender;\\r\\n    //     }\\r\\n    //     return sender;\\r\\n    // }\\r\\n\\r\\n    // function msgRelayer() internal view returns(address relayer) {\\r\\n    //     if(msg.sender == address(this)) {\\r\\n    //         bytes20 relayerAddress;\\r\\n    //         bytes memory data = msg.data;\\r\\n    //         uint256 dataLength = msg.data.length;\\r\\n    //         assembly {\\r\\n    //             calldatacopy(0x0, sub(dataLength, 20), dataLength)\\r\\n    //             relayerAddress := mload(0x0)\\r\\n    //         }\\r\\n    //         relayer = address(uint160(relayerAddress));\\r\\n    //     }\\r\\n    // }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"contracts/lib/EIP712Base.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\ncontract EIP712Base {\\r\\n\\r\\n    struct EIP712Domain {\\r\\n        string name;\\r\\n        string version;\\r\\n        uint256 chainId;\\r\\n        address verifyingContract;\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"));\\r\\n\\r\\n    bytes32 internal domainSeperator;\\r\\n\\r\\n    constructor(string memory name, string memory version) {\\r\\n        domainSeperator = keccak256(abi.encode(\\r\\n\\t\\t\\tEIP712_DOMAIN_TYPEHASH,\\r\\n\\t\\t\\tkeccak256(bytes(name)),\\r\\n\\t\\t\\tkeccak256(bytes(version)),\\r\\n\\t\\t\\tgetChainID(),\\r\\n\\t\\t\\taddress(this)\\r\\n\\t\\t));\\r\\n    }\\r\\n\\r\\n    function getChainID() internal view returns (uint256 id) {\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\t//id := 80001\\r\\n           id := chainid()\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n    function getDomainSeperator() private view returns(bytes32) {\\r\\n\\t\\treturn domainSeperator;\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n    * Accept message hash and returns hash message in EIP712 compatible form\\r\\n    * So that it can be used to recover signer from signature signed using EIP712 formatted data\\r\\n    * https://eips.ethereum.org/EIPS/eip-712\\r\\n    * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\r\\n    * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\r\\n    */\\r\\n    function toTypedMessageHash(bytes32 messageHash) internal view returns(bytes32) {\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", getDomainSeperator(), messageHash));\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenTransfer", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a2ca40dbe72028d3ac78b5250a8cb8c404e7fb8c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}