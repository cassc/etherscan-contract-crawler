{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TimeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @title TIME Token contract\\n * @notice Smart contract used for main interaction with the TIME tokenomics system\\n **/\\ncontract TimeToken is IERC20 {\\n\\n    using SafeMath for uint256;\\n\\n    event Mining(address indexed miner, uint256 amount, uint256 blockNumber);\\n    event Donation(address indexed donator, uint256 donatedAmount);\\n\\n    bool private _isMintLocked = false;\\n    bool private _isOperationLocked;\\n\\n    uint8 private constant _decimals = 18;\\n\\n    address public constant DEVELOPER_ADDRESS = 0x731591207791A93fB0Ec481186fb086E16A7d6D0;\\n\\n    uint256 private constant FACTOR = 10**18;\\n    uint256 private constant D = 10**_decimals;\\n\\n    uint256 public constant BASE_FEE = 10 ether; // 10 ether; (Polygon) | 0.1 ether; (BSC) | 20 ether; (Fantom) | 0.01 ether; (Ethereum)\\n    uint256 public constant COMISSION_RATE = 2;\\n    uint256 public constant SHARE_RATE = 4;\\n    uint256 public constant TIME_BASE_LIQUIDITY = 200000 * D; // 200000 * D; (Polygon and BSC) | 400000 * D; (Fantom) | 40000 * D; (Ethereum)\\n    uint256 public constant TIME_BASE_FEE = 4800000 * D; // 4800000 * D; (Polygon and BSC) | 9600000 * D; (Fantom) | 960000 * D; (Ethereum)\\n    uint256 public constant TOLERANCE = 10;\\n\\n    uint256 private _totalSupply;\\n    uint256 public dividendPerToken;\\n    uint256 public firstBlock;\\n    uint256 public liquidityFactorNative = 11;\\n    uint256 public liquidityFactorTime = 20;\\n    uint256 public numberOfHolders;\\n    uint256 public numberOfMiners;\\n    uint256 public sharedBalance;\\n    uint256 public poolBalance;\\n    uint256 public totalMinted;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    mapping (address => bool) public isMiningAllowed;\\n    mapping (address => uint256) private _balances;\\n    mapping (address => uint256) private _consumedDividendPerToken;\\n    mapping (address => uint256) private _credits;\\n    mapping (address => uint256) private _lastBalances;\\n    mapping (address => uint256) private _lastBlockMined;\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        firstBlock = block.number;\\n    }\\n\\n    modifier nonReentrant() {\\n\\t    require(!_isOperationLocked, \\\"TIME: This operation is locked for security reasons\\\");\\n\\t\\t_isOperationLocked = true;\\n\\t\\t_;\\n\\t\\t_isOperationLocked = false;\\n\\t}\\n\\n    receive() external payable {\\n        saveTime();\\n    }\\n\\n    fallback() external payable {\\n        require(msg.data.length == 0);\\n        saveTime();\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n      \\treturn _symbol;\\n    }\\n\\n    function decimals() public pure returns (uint8) {\\n      \\treturn _decimals;\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) external override view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function burn(uint256 amount) public {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    function transfer(address to, uint256 amount) external override returns (bool success) {\\n        if (to == address(this))\\n            success = spendTime(amount);\\n        else\\n            success = _transfer(msg.sender, to, amount);\\n\\t\\treturn success;\\n    }\\n\\n    function allowance(address owner, address spender) external override view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n\\t\\t_approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n\\t\\treturn true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external override returns (bool success) {\\n\\t\\tsuccess = _transfer(from, to, amount);\\n\\t\\t_approve(from, msg.sender, _allowances[from][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n\\t\\treturn success;\\n    }\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        if (_balances[to] > 0 && to != address(0) && to != address(this) && _lastBalances[to] != _balances[to] && _lastBalances[to] == 0)\\n            numberOfHolders++;\\n\\n        if (_balances[from] == 0 && from != address(0) && to != address(this) && _lastBalances[from] != _balances[from])\\n            numberOfHolders--;\\n\\n        _lastBalances[from] = _balances[from];\\n        _lastBalances[to] = _balances[to];    \\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        _credit(from);\\n        _credit(to);\\n        _lastBalances[from] = _balances[from];\\n        _lastBalances[to] = _balances[to];\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n\\n        _totalSupply -= amount;\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        totalMinted += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual returns (bool) {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Calculate the amount some address has to claim and credit for it\\n     * @param account The account address\\n     **/\\n    function _credit(address account) private {\\n        _credits[account] += accountShareBalance(account);\\n        _consumedDividendPerToken[account] = dividendPerToken;\\n    }\\n\\n    /**\\n     *  @notice Obtain the aproximate amount of blocks needed to drain the whole internal LP (considering the current TIME mining rate)\\n     **/\\n    function _getAmountOfBlocksToDrainLP(bool isFeeInTime) private view returns (uint256) {\\n        if (averageMiningRate() == 0) {\\n            if (isFeeInTime)\\n                return TIME_BASE_FEE;\\n            else\\n                return TIME_BASE_LIQUIDITY;\\n        } else {\\n            return ((_balances[address(this)] * D) / averageMiningRate());\\n        }\\n    }\\n\\n    /**\\n     * @notice Called when an investor wants to exchange ETH for TIME. A comission in ETH is paid to miner (block.coinbase) and developer\\n     * @param comissionAmount The amount in ETH which will be paid (two times)\\n    **/\\n    function _payComission(uint256 comissionAmount) private {\\n        payable(DEVELOPER_ADDRESS).transfer(comissionAmount);\\n        if (block.coinbase == address(0))\\n            payable(DEVELOPER_ADDRESS).transfer(comissionAmount);\\n        else\\n            payable(block.coinbase).transfer(comissionAmount);\\n\\n        sharedBalance += comissionAmount;\\n        poolBalance += comissionAmount;\\n        dividendPerToken += ((comissionAmount * FACTOR) / (_totalSupply - _balances[address(this)] + 1));\\n    }\\n\\n    /**\\n     * @notice Called when an investor wants to exchange TIME for ETH. A comission in TIME token is paid to miner (block.coinbase) and developer\\n     * @param comissionAmount The amount in TIME tokens which will be paid (two times)\\n     **/\\n    function _payComissionInTime(uint256 comissionAmount) private {\\n        _transfer(msg.sender, DEVELOPER_ADDRESS, comissionAmount);\\n        if (block.coinbase == address(0))\\n            _transfer(msg.sender, DEVELOPER_ADDRESS, comissionAmount);\\n        else\\n            _transfer(msg.sender, block.coinbase, comissionAmount);\\n\\n        _burn(msg.sender, comissionAmount);\\n    }\\n\\n    /**\\n     * @notice Returns the average rate of TIME tokens mined per block (mining rate)\\n     **/\\n    function averageMiningRate() public view returns (uint256) {\\n        if (totalMinted > TIME_BASE_LIQUIDITY) \\n            return ((totalMinted - TIME_BASE_LIQUIDITY) / (block.number - firstBlock));\\n        else\\n            return 0;\\n    }\\n\\n    /**\\n     *  @notice Just verify if the msg.value has any ETH value for donation\\n     **/\\n    function donateEth() public payable nonReentrant {\\n        require(msg.value > 0, \\\"TIME: please specify any amount you would like to donate\\\");\\n        emit Donation(msg.sender, msg.value);\\n        uint256 remaining = msg.value;\\n        uint256 totalComission = (msg.value * COMISSION_RATE) / 100;\\n        uint256 comission = totalComission / SHARE_RATE;\\n        _payComission(comission);\\n        remaining -= totalComission;\\n        sharedBalance += (remaining / 2);\\n        dividendPerToken += (((remaining / 2) * FACTOR) / (_totalSupply - _balances[address(this)] + 1));\\n        remaining /= 2;\\n        poolBalance += remaining;\\n    }\\n\\n    /** \\n     * @notice An address call this function to be able to mine TIME by paying with ETH (native cryptocurrency)\\n     * @dev An additional amount of TIME should be created for the AMM address to provide initial liquidity if the contract does not have any miners enabled\\n    **/\\n    function enableMining() public payable nonReentrant {\\n        uint256 f = fee();\\n        uint256 tolerance;\\n        if (msg.value < f) {\\n            tolerance = (f * TOLERANCE) / 100;\\n            require(msg.value >= (f - tolerance), \\\"TIME: to enable mining for an address you need at least the fee() amount in native currency\\\");\\n        }\\n        require(!isMiningAllowed[msg.sender], \\\"TIME: the address is already enabled\\\");\\n        uint256 remaining = msg.value;\\n        isMiningAllowed[msg.sender] = true;\\n        _lastBlockMined[msg.sender] = block.number;\\n        if (numberOfMiners == 0)\\n            _mint(address(this), TIME_BASE_LIQUIDITY);\\n        \\n        uint256 totalComission = ((remaining * COMISSION_RATE) / 100);\\n        uint256 comission = totalComission / SHARE_RATE;\\n        _payComission(comission);\\n        remaining -= totalComission;\\n        sharedBalance += (remaining / 2);\\n        dividendPerToken += (((remaining / 2) * FACTOR) / (_totalSupply - _balances[address(this)] + 1));\\n        remaining /= 2;\\n        poolBalance += remaining;\\n        if (numberOfMiners == 0) {\\n            poolBalance += sharedBalance;\\n            sharedBalance = 0;\\n            dividendPerToken = 0;\\n        }\\n        numberOfMiners++;\\n    }\\n\\n    /**\\n     * @notice An address call this function to be able to mine TIME with its earned (or bought) TIME tokens\\n     **/\\n    function enableMiningWithTimeToken() public nonReentrant {\\n        uint256 f = feeInTime();\\n        require(_balances[msg.sender] >= f, \\\"TIME: to enable mining for an address you need at least the feeInTime() amount in TIME tokens\\\");\\n        require(!isMiningAllowed[msg.sender], \\\"TIME: the address is already enabled\\\");\\n        _burn(msg.sender, f);\\n        isMiningAllowed[msg.sender] = true;\\n        _lastBlockMined[msg.sender] = block.number;\\n        numberOfMiners++;\\n    }\\n\\n    /**\\n     * @notice Query the fee amount needed, in ETH, to enable an address for mining TIME\\n     * @dev Function has now dynamic fee calculation. Fee should not be so expensive and not cheap at the same time\\n     * @return Fee amount (in native cryptocurrency)\\n     **/\\n    function fee() public view returns (uint256) {\\n        return (((BASE_FEE * TIME_BASE_LIQUIDITY) / _getAmountOfBlocksToDrainLP(false)) / (numberOfMiners + 1));\\n    }\\n\\n    /**\\n     * @notice Query the fee amount needed, in TIME, to enable an address for mining TIME\\n     * @dev Function has now dynamic fee calculation. Fee should not be so expensive and not cheap at the same time\\n     * @return Fee amount (in TIME Tokens)\\n     **/\\n    function feeInTime() public view returns (uint256) {\\n        return ((TIME_BASE_FEE * TIME_BASE_FEE) / _getAmountOfBlocksToDrainLP(true));\\n    }\\n\\n    /**\\n     * @notice An allowed address call this function in order to mint TIME tokens according to the number of blocks which has passed since it has enabled mining\\n     **/\\n    function mining() public nonReentrant {\\n        if (isMiningAllowed[msg.sender]) {\\n            uint256 miningAmount = (block.number - _lastBlockMined[msg.sender]) * D;\\n            _mint(msg.sender, miningAmount);\\n            if (block.coinbase != address(0))\\n                _mint(block.coinbase, (miningAmount / 100));\\n            _lastBlockMined[msg.sender] = block.number;\\n            emit Mining(msg.sender, miningAmount, block.number);\\n        }\\n    }\\n\\n    /**\\n     * @notice Investor send native cryptocurrency in exchange for TIME tokens. Here, he sends some amount and the contract calculates the equivalent amount in TIME units\\n     * @dev msg.value - The amount of TIME in terms of ETH an investor wants to 'save'\\n     **/\\n    function saveTime() public payable nonReentrant returns (bool success) {\\n        if (msg.value > 0) {\\n            uint256 totalComission = ((msg.value * COMISSION_RATE) / 100);\\n            uint256 comission = totalComission / SHARE_RATE;\\n            uint256 nativeAmountTimeValue = (msg.value * swapPriceNative(msg.value)) / FACTOR;\\n            require(nativeAmountTimeValue <= _balances[address(this)], \\\"TIME: the pool does not have a sufficient amount to trade\\\");\\n            _payComission(comission);\\n            success = _transfer(address(this), msg.sender, nativeAmountTimeValue - (((nativeAmountTimeValue * COMISSION_RATE) / 100) / SHARE_RATE));\\n            poolBalance += (msg.value - totalComission);\\n            liquidityFactorNative = liquidityFactorNative < 20 ? liquidityFactorNative + 1 : liquidityFactorNative;\\n            liquidityFactorTime = liquidityFactorTime > 11 ? liquidityFactorTime - 1 : liquidityFactorTime;\\n        }\\n        return success;\\n    }\\n\\n    /**\\n     * @notice Investor send TIME tokens in exchange for native cryptocurrency\\n     * @param timeAmount The amount of TIME tokens for exchange\\n     **/\\n    function spendTime(uint256 timeAmount) public nonReentrant returns (bool success) {\\n        require(_balances[msg.sender] >= timeAmount, \\\"TIME: there is no enough time to spend\\\");\\n        uint256 comission = ((timeAmount * COMISSION_RATE) / 100) / SHARE_RATE;\\n        uint256 timeAmountNativeValue = (timeAmount * swapPriceTimeInverse(timeAmount)) / FACTOR;\\n        require(timeAmountNativeValue <= poolBalance, \\\"TIME: the pool does not have a sufficient amount to trade\\\");\\n        _payComissionInTime(comission);\\n        timeAmount -= comission.mul(3);\\n        success = _transfer(msg.sender, address(this), timeAmount);\\n        poolBalance -= timeAmountNativeValue;\\n        payable(msg.sender).transfer(timeAmountNativeValue - (((timeAmountNativeValue * COMISSION_RATE) / 100) / SHARE_RATE));\\n        liquidityFactorTime = liquidityFactorTime < 20 ? liquidityFactorTime + 1 : liquidityFactorTime;\\n        liquidityFactorNative = liquidityFactorNative > 11 ? liquidityFactorNative - 1 : liquidityFactorNative;\\n        return success;\\n    }\\n\\n    /**\\n     * @notice Query for market price before swap, in TIME/ETH, in terms of native cryptocurrency (ETH)\\n     * @dev Constant Function Market Maker\\n     * @param amountNative The amount of ETH a user wants to exchange\\n     * @return Local market price, in TIME/ETH, given the amount of ETH a user informed\\n     **/\\n    function swapPriceNative(uint256 amountNative) public view returns (uint256) {\\n        if (poolBalance > 0 && _balances[address(this)] > 0) {\\n            uint256 ratio = (poolBalance * FACTOR) / (amountNative + 1);\\n            uint256 deltaSupply = (_balances[address(this)] * amountNative * ratio) / (poolBalance + ((amountNative * liquidityFactorNative) / 10));\\n            return (deltaSupply / poolBalance);\\n        } else {\\n            return 1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Query for market price before swap, in ETH/TIME, in terms of ETH currency\\n     * @param amountTime The amount of TIME a user wants to exchange\\n     * @return Local market price, in ETH/TIME, given the amount of TIME a user informed\\n     **/\\n    function swapPriceTimeInverse(uint256 amountTime) public view returns (uint256) {\\n        if (poolBalance > 0 && _balances[address(this)] > 0) {\\n            uint256 ratio = (_balances[address(this)] * FACTOR) / (amountTime + 1);\\n            uint256 deltaBalance = (poolBalance * amountTime * ratio) / (_balances[address(this)] + ((amountTime * liquidityFactorTime) / 10));\\n            return (deltaBalance / _balances[address(this)]);      \\n        } else {\\n            return 1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Show the amount in ETH an account address can credit to itself\\n     * @param account The address of some account\\n     * @return The claimable amount in ETH\\n     **/\\n    function accountShareBalance(address account) public view returns (uint256) {\\n        return ((_balances[account] * (dividendPerToken - _consumedDividendPerToken[account])) / FACTOR);\\n    }\\n\\n    /**\\n     * @notice Show the amount in ETH an account address can withdraw to itself\\n     * @param account The address of some account\\n     * @return The withdrawable amount in ETH\\n     **/\\n    function withdrawableShareBalance(address account) public view returns (uint256) {\\n        return (accountShareBalance(account) + _credits[account]);\\n    }\\n\\n    /**\\n     * @notice Withdraw the available amount returned by the accountShareBalance(address account) function\\n     **/\\n    function withdrawShare() public nonReentrant {\\n        uint256 withdrawableAmount = accountShareBalance(msg.sender);\\n        withdrawableAmount += _credits[msg.sender];\\n        require(withdrawableAmount > 0, \\\"TIME: you don't have any amount to withdraw\\\");\\n        require(withdrawableAmount <= sharedBalance, \\\"TIME: there is no enough balance to share\\\");\\n        _credits[msg.sender] = 0;\\n        _consumedDividendPerToken[msg.sender] = dividendPerToken;\\n        sharedBalance -= withdrawableAmount;\\n        payable(msg.sender).transfer(withdrawableAmount);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"byzantium\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"donator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"donatedAmount\",\"type\":\"uint256\"}],\"name\":\"Donation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"Mining\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BASE_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COMISSION_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEVELOPER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHARE_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_BASE_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_BASE_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOLERANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accountShareBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"averageMiningRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donateEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableMining\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableMiningWithTimeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeInTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMiningAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFactorNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFactorTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mining\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saveTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sharedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeAmount\",\"type\":\"uint256\"}],\"name\":\"spendTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountNative\",\"type\":\"uint256\"}],\"name\":\"swapPriceNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountTime\",\"type\":\"uint256\"}],\"name\":\"swapPriceTimeInverse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableShareBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TimeToken", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "2000000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000a54494d4520546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000454494d4500000000000000000000000000000000000000000000000000000000", "EVMVersion": "byzantium", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}