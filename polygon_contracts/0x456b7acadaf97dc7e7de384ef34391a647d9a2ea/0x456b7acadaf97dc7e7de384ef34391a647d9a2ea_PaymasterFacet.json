{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/diamondFacets/PaymasterFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\nimport {IPaymasterFacet} from \\\"../interfaces/internal/IPaymasterFacet.sol\\\";\\r\\n\\r\\ncontract PaymasterFacet  is IPaymasterFacet{\\r\\n      bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.Paymaster.diamond.storage\\\");\\r\\n      struct Paymaster{\\r\\n           //paymaster balance\\r\\n           mapping(address=> uint256) walletPaymasterBalance;     \\r\\n           address payer;\\r\\n           mapping(address => uint256) quotaWhiteList;\\r\\n\\r\\n      }\\r\\n      function diamondStorage() internal pure returns (Paymaster storage ds) {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      //-paymaster\\r\\n      function setWalletPaymasterBalance(address _wallet,uint256 _amount,bool _type) external {\\r\\n             Paymaster storage ds=diamondStorage();\\r\\n             if(_type){\\r\\n                ds.walletPaymasterBalance[_wallet]+=_amount;\\r\\n             }else{\\r\\n                require( ds.walletPaymasterBalance[_wallet]>=_amount,\\\"Paymaster:balance not enough\\\");  \\r\\n                ds.walletPaymasterBalance[_wallet]-=_amount;\\r\\n             }     \\r\\n      }\\r\\n      function getWalletPaymasterBalance(address _wallet) external view returns(uint256){\\r\\n             Paymaster storage ds=diamondStorage();\\r\\n             return  ds.walletPaymasterBalance[_wallet];\\r\\n      }\\r\\n\\r\\n      function setPayer(address _payer) external{\\r\\n             Paymaster storage ds=diamondStorage();\\r\\n             ds.payer=_payer;\\r\\n      }\\r\\n      function getPayer() external view returns(address){\\r\\n             Paymaster storage ds=diamondStorage();\\r\\n             return ds.payer;\\r\\n      }\\r\\n\\r\\n      function setQuotaWhiteList(address _target,uint256 _amount,bool _type) external {\\r\\n              Paymaster storage ds=diamondStorage();\\r\\n              if(_type){\\r\\n                ds.quotaWhiteList[_target]+=_amount;\\r\\n              }else{\\r\\n                require( ds.quotaWhiteList[_target]>=_amount,\\\"Paymaster:quota not enough\\\");  \\r\\n                ds.quotaWhiteList[_target]-=_amount;\\r\\n              }     \\r\\n      }\\r\\n\\r\\n      function getQuota(address _target) external view returns(uint256){\\r\\n             Paymaster storage ds=diamondStorage();\\r\\n             return ds.quotaWhiteList[_target];\\r\\n      }\\r\\n\\r\\n}     \"\r\n    },\r\n    \"contracts/interfaces/internal/IPaymasterFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\ninterface IPaymasterFacet{\\r\\n    struct DepositInfo{\\r\\n        address wallet;\\r\\n        string protocol;\\r\\n        uint256 positionType;\\r\\n        address sendAsset; \\r\\n        address receiveAsset;  \\r\\n        uint256 adapterType;  \\r\\n        uint256 amountIn;\\r\\n        uint256 amountLimit;\\r\\n        uint256 approveAmount;\\r\\n        bytes adapterData;  \\r\\n    }\\r\\n    function setWalletPaymasterBalance(address _wallet,uint256 _amount,bool _type) external;\\r\\n    function getWalletPaymasterBalance(address _wallet) external view returns(uint256);\\r\\n    function setPayer(address _payer) external;\\r\\n    function getPayer() external view returns(address);\\r\\n    function setQuotaWhiteList(address _target,uint256 _amount,bool _type) external;\\r\\n    function getQuota(address _target) external view returns(uint256);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"getPayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"getQuota\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getWalletPaymasterBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_payer\",\"type\":\"address\"}],\"name\":\"setPayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_type\",\"type\":\"bool\"}],\"name\":\"setQuotaWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_type\",\"type\":\"bool\"}],\"name\":\"setWalletPaymasterBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PaymasterFacet", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}