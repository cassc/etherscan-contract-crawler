{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC1155 {\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n}\r\n\r\ncontract BadgeChecker {\r\n    IERC1155 public badgeContract;\r\n    uint256 constant CHUNK_SIZE = 20000; // Rozmiar partii do sprawdzania bilansu\r\n\r\n    constructor(address _badgeContractAddress) {\r\n        badgeContract = IERC1155(_badgeContractAddress);\r\n    }\r\n\r\n        function cantorPair(uint256 m, uint256 n) public pure returns (uint256) {\r\n        return (m + n) * (m + n + 1) / 2 + n;\r\n    }\r\n\r\n    function getBadgeID(uint256 category, uint256 position) public pure returns (uint256) {\r\n        // Mapowanie kategorii do warto\u015bci 'm' na podstawie podanego algorytmu\r\n        uint256[] memory categoryMapping = new uint256[](6);\r\n        categoryMapping[1] = 4; // Kategoria 1\r\n        categoryMapping[2] = 8; // Kategoria 2\r\n        categoryMapping[3] = 13; // Kategoria 3\r\n        categoryMapping[4] = 19; // Kategoria 4\r\n        categoryMapping[5] = 26; // Kategoria 5\r\n\r\n        require(category > 0 && category < categoryMapping.length, \"Invalid category\");\r\n        return cantorPair(categoryMapping[category], position);\r\n    }\r\n\r\n    function generateBadgeIDsForCategory(uint256 category, uint256 count) public pure returns (uint256[] memory) {\r\n        uint256[] memory ids = new uint256[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            ids[i] = getBadgeID(category, i + 1); // Zak\u0142adamy, \u017ce pozycje zaczynaj\u0105 si\u0119 od 1\r\n        }\r\n        return ids;\r\n    }\r\n\r\n    function checkBadges(address _user) external view returns (uint256[][] memory) {\r\n        uint256[][] memory badgesPerCategory = new uint256[][](5); // 5 kategorii\r\n\r\n        // Definicja maksymalnej liczby znaczk\u00f3w dla ka\u017cdej kategorii\r\n        uint256[] memory maxBadgesPerCategory = new uint256[](5);\r\n        maxBadgesPerCategory[0] = 100000;\r\n        maxBadgesPerCategory[1] = 50000;\r\n        maxBadgesPerCategory[2] = 20000;\r\n        maxBadgesPerCategory[3] = 5000;\r\n        maxBadgesPerCategory[4] = 1530;\r\n\r\n        for (uint256 category = 1; category <= 5; category++) {\r\n            uint256 badgeCount = maxBadgesPerCategory[category - 1];\r\n            uint256[] memory categoryBadges = generateBadgeIDsForCategory(category, badgeCount);\r\n            uint256[] memory badgeBalances = new uint256[](badgeCount);\r\n\r\n            // Sprawdzanie balans\u00f3w w partiach\r\n            for (uint256 offset = 0; offset < badgeCount; offset += CHUNK_SIZE) {\r\n                uint256 chunkSize = (offset + CHUNK_SIZE > badgeCount) ? badgeCount - offset : CHUNK_SIZE;\r\n                address[] memory userArray = new address[](chunkSize);\r\n                uint256[] memory chunkCategoryBadges = new uint256[](chunkSize);\r\n\r\n                for (uint256 i = 0; i < chunkSize; i++) {\r\n                    userArray[i] = _user;\r\n                    chunkCategoryBadges[i] = categoryBadges[offset + i];\r\n                }\r\n\r\n                uint256[] memory chunkBalances = badgeContract.balanceOfBatch(userArray, chunkCategoryBadges);\r\n                for (uint256 i = 0; i < chunkSize; i++) {\r\n                    badgeBalances[offset + i] = chunkBalances[i];\r\n                }\r\n            }\r\n\r\n            // Dynamicznie tworzymy list\u0119 ID znaczk\u00f3w, kt\u00f3re u\u017cytkownik posiada (saldo wi\u0119ksze od 0)\r\n            uint256[] memory userBadges = new uint256[](badgeCount);\r\n            uint256 foundCount = 0;\r\n            for (uint256 i = 0; i < badgeBalances.length; i++) {\r\n                if (badgeBalances[i] > 0) {\r\n                    userBadges[foundCount] = categoryBadges[i];\r\n                    foundCount++;\r\n                }\r\n            }\r\n\r\n            // Przycinamy tablic\u0119 do znalezionych ID i przypisujemy do odpowiedniej kategorii\r\n            uint256[] memory ownedBadges = new uint256[](foundCount);\r\n            for (uint256 i = 0; i < foundCount; i++) {\r\n                ownedBadges[i] = userBadges[i];\r\n            }\r\n            badgesPerCategory[category - 1] = ownedBadges;\r\n        }\r\n\r\n        return badgesPerCategory;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_badgeContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"badgeContract\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"cantorPair\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkBadges\",\"outputs\":[{\"internalType\":\"uint256[][]\",\"name\":\"\",\"type\":\"uint256[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"generateBadgeIDsForCategory\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"category\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"getBadgeID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "BadgeChecker", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ea10ce27d9f21d3e36100bc98e6cfeb9e71dd26e", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://315f34128a832a61f800e97f0704bd9c8f94746a86957d5a2ca0435d1fafd16f"}