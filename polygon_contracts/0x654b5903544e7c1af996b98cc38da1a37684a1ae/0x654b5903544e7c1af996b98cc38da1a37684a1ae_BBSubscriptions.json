{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BBSubscriptions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport \\\"./utils/DateTimeLibrary.sol\\\";\\r\\nimport \\\"./BBErrorsV01.sol\\\";\\r\\nimport \\\"./interfaces/IBBGasOracle.sol\\\";\\r\\nimport \\\"./interfaces/IBBProfiles.sol\\\";\\r\\nimport \\\"./interfaces/IBBTiers.sol\\\";\\r\\nimport \\\"./interfaces/IBBSubscriptionsFactory.sol\\\";\\r\\nimport \\\"./interfaces/IBBSubscriptions.sol\\\";\\r\\n\\r\\ncontract BBSubscriptions is IBBSubscriptions {   \\r\\n    event Subscribed(\\r\\n        uint256 subscriptionId\\r\\n    );\\r\\n\\r\\n    event Renewed(\\r\\n        uint256 subscriptionId\\r\\n    );\\r\\n\\r\\n    event Unsubscribed (\\r\\n        uint256 subscriptionId\\r\\n    );\\r\\n\\r\\n    struct Subscription {\\r\\n        uint256 profileId;\\r\\n        uint256 tierId;\\r\\n        address subscriber;\\r\\n        uint256 price;\\r\\n        uint256 expiration;\\r\\n        bool cancelled;\\r\\n    }\\r\\n\\r\\n    // Subscription ID => Subscription\\r\\n    mapping (uint256 => Subscription) internal _subscriptions;\\r\\n    uint256 internal _totalSubscriptions;\\r\\n\\r\\n    // Profile ID => Tier ID => Subscriber => Subscription ID + 1\\r\\n    mapping(uint256 => mapping(uint256 => mapping(address => uint256))) internal _subscriptionIndexes;\\r\\n\\r\\n    IBBProfiles internal immutable _bbProfiles;\\r\\n    IBBTiers internal immutable _bbTiers;\\r\\n    IBBSubscriptionsFactory internal immutable _bbSubscriptionsFactory;\\r\\n\\r\\n    IERC20 internal immutable _currency;\\r\\n\\r\\n    constructor(address bbProfiles, address bbTiers, address bbSubscriptionsFactory, address currency) {\\r\\n        _bbProfiles = IBBProfiles(bbProfiles);\\r\\n        _bbTiers = IBBTiers(bbTiers);\\r\\n        _bbSubscriptionsFactory = IBBSubscriptionsFactory(bbSubscriptionsFactory);\\r\\n\\r\\n        _currency = IERC20(currency);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @dev Transfer ERC20 tokens from address to profile receiver and treasury\\r\\n\\r\\n        @param ERC20 token owner\\r\\n        @param ERC20 token receiver\\r\\n        @param ERC20 token amount\\r\\n        @param Treasury contribution percentage\\r\\n\\r\\n        @return True if transfer succeeded, otherwise false\\r\\n    */\\r\\n    function _pay(address owner, address receiver, uint256 amount, uint256 treasuryContribution) internal returns (bool) {\\r\\n        // Check that the contract has enough allowance to process this transfer\\r\\n        if ((_currency.allowance(owner, address(this)) >= amount) && _currency.balanceOf(owner) >= amount) { \\r\\n            _currency.transferFrom(owner, address(this), amount);\\r\\n\\r\\n            uint256 receiverAmount = (amount * (100 - treasuryContribution)) / 100;\\r\\n\\r\\n            if(receiverAmount > 0) {\\r\\n                _currency.transfer(receiver, receiverAmount);\\r\\n            }\\r\\n\\r\\n            // Payment processed\\r\\n            return true;\\r\\n        } \\r\\n\\r\\n        // Insufficient funds\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @notice Renew subscriptions within a range\\r\\n\\r\\n        @param Array of subscription IDs to renew and refund receiver packed into bytes array\\r\\n    */\\r\\n    function performUpkeep(bytes calldata renewalData) external override {\\r\\n        (uint256[] memory renewIndexes, address refundReceiver) = abi.decode(renewalData, (uint256[], address));\\r\\n        \\r\\n        uint256 gasAtStart = gasleft();\\r\\n        uint256 renewCount;\\r\\n\\r\\n        for(uint256 i; i < renewIndexes.length; i++) {\\r\\n            require(renewIndexes[i] < _totalSubscriptions, BBErrorCodesV01.SUBSCRIPTION_NOT_EXIST);\\r\\n\\r\\n            if(_subscriptions[renewIndexes[i]].expiration < block.timestamp && _subscriptions[renewIndexes[i]].cancelled == false) {\\r\\n                (uint256 tierSetId, uint256 contribution) = _bbSubscriptionsFactory.getSubscriptionProfile(_subscriptions[renewIndexes[i]].profileId);\\r\\n\\r\\n                // Check the subscription tier still exists, and the token is still accepted by the creator\\r\\n                if(_subscriptions[renewIndexes[i]].tierId < _bbTiers.totalTiers(_subscriptions[renewIndexes[i]].profileId, tierSetId) && _bbTiers.isCurrencySupported(_subscriptions[renewIndexes[i]].profileId, tierSetId, address(_currency))) {\\r\\n                    (,address profileReceiver,) = _bbProfiles.getProfile(_subscriptions[renewIndexes[i]].profileId);\\r\\n\\r\\n                    bool paid = _pay(\\r\\n                        _subscriptions[renewIndexes[i]].subscriber,\\r\\n                        profileReceiver,\\r\\n                        _subscriptions[renewIndexes[i]].price,\\r\\n                        contribution\\r\\n                    );\\r\\n\\r\\n                    if(paid) {\\r\\n                        // Subscription payment succeeded, so extended expiration timestamp\\r\\n                        _subscriptions[renewIndexes[i]].expiration = block.timestamp + (DateTimeLibrary.getDaysInMonth(block.timestamp) * 1 days);    \\r\\n\\r\\n                        renewCount++;\\r\\n\\r\\n                        emit Renewed(renewIndexes[i]); \\r\\n                        continue;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                // Subscription payment failed, or subscription tier no longer exists, therefore cancel the subscription\\r\\n                _subscriptions[renewIndexes[i]].cancelled = true;\\r\\n\\r\\n                emit Unsubscribed(renewIndexes[i]);\\r\\n\\r\\n                renewCount++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        require(renewCount > 0, BBErrorCodesV01.UPKEEP_FAIL);\\r\\n\\r\\n        // Calculate the gas refund, add 30327 gas for the rest of the function, 26215 for decoding the renewal data, and 423 multiplied by the number of indexes renewed\\r\\n        uint256 gasBudget = _getUpkeepRefund() * renewCount;\\r\\n        uint256 refund = (gasAtStart - gasleft() + (56542 + (423 * renewCount))) * IBBGasOracle(_bbSubscriptionsFactory.getGasOracle()).getGasPrice();\\r\\n        // Invalid ID refund penalty\\r\\n        refund = refund - ((refund / renewIndexes.length) * (renewIndexes.length - renewCount));\\r\\n\\r\\n        // Check the refund isnt greater than the gas budget\\r\\n        if (refund > gasBudget) {\\r\\n            refund = gasBudget;\\r\\n        }\\r\\n\\r\\n        // Check if refund is greater than the balance.\\r\\n        if(address(this).balance < refund) {\\r\\n            refund = address(this).balance;\\r\\n        }\\r\\n\\r\\n        // Transfer gas refund to refund receiver\\r\\n        if(refund > 0) {\\r\\n            refundReceiver.call{value: refund}(\\\"\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @notice Subscribe to a profile\\r\\n\\r\\n        @param Profile ID\\r\\n        @param Tier ID\\r\\n        \\r\\n        @return Subscription ID\\r\\n    */\\r\\n    function subscribe(uint256 profileId, uint256 tierId, uint256 expectedPrice) external payable override returns(uint256 subscriptionId) {\\r\\n        require(msg.value >= _bbSubscriptionsFactory.getSubscriptionFee(address(_currency)), BBErrorCodesV01.INSUFFICIENT_PREPAID_GAS);\\r\\n\\r\\n        if(_bbSubscriptionsFactory.isSubscriptionActive(profileId, tierId, msg.sender) == true) {\\r\\n            (,,,bool cancelled) = IBBSubscriptions(_bbSubscriptionsFactory.getDeployedSubscriptions(_bbSubscriptionsFactory.getSubscriptionCurrency(profileId, tierId, msg.sender))).getSubscriptionFromProfile(profileId, tierId, msg.sender);\\r\\n            require(cancelled == true, BBErrorCodesV01.SUBSCRIPTION_ACTIVE);\\r\\n        }\\r\\n\\r\\n        (uint256 tierSet,) = _bbSubscriptionsFactory.getSubscriptionProfile(profileId);\\r\\n\\r\\n        (,uint256 price, bool deprecated) = _bbTiers.getTier(profileId, tierSet, tierId, address(_currency));\\r\\n        require(price == expectedPrice, BBErrorCodesV01.INVALID_PRICE);\\r\\n\\r\\n        require(deprecated == false, BBErrorCodesV01.TIER_NOT_EXIST);\\r\\n\\r\\n        subscriptionId = _totalSubscriptions;\\r\\n\\r\\n        if(_subscriptionIndexes[profileId][tierId][msg.sender] == 0) {\\r\\n            _subscriptionIndexes[profileId][tierId][msg.sender] = _totalSubscriptions + 1;\\r\\n            _totalSubscriptions++;\\r\\n        }\\r\\n        else {\\r\\n            subscriptionId = _subscriptionIndexes[profileId][tierId][msg.sender] - 1;\\r\\n        }\\r\\n\\r\\n        _subscriptions[subscriptionId] = Subscription(\\r\\n            profileId, \\r\\n            tierId, \\r\\n            msg.sender, \\r\\n            price,\\r\\n            block.timestamp + 30 days, \\r\\n            false\\r\\n        ); \\r\\n\\r\\n        (,address profileReceiver,) = _bbProfiles.getProfile(profileId);\\r\\n        (,uint256 contribution) = _bbSubscriptionsFactory.getSubscriptionProfile(profileId);\\r\\n\\r\\n        require(_pay(msg.sender, profileReceiver, price, contribution), BBErrorCodesV01.INSUFFICIENT_BALANCE);\\r\\n\\r\\n        _bbSubscriptionsFactory.setSubscriptionCurrency(profileId, tierId, msg.sender, address(_currency));\\r\\n\\r\\n        withdrawToTreasury();\\r\\n\\r\\n        emit Subscribed(subscriptionId);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @notice Unsubscribe from a profile\\r\\n\\r\\n        @param Profile ID\\r\\n        @param Tier ID        \\r\\n    */\\r\\n    function unsubscribe(uint256 profileId, uint256 tierId) external override {\\r\\n        uint256 id = _getSubscriptionId(profileId, tierId, msg.sender);\\r\\n        require(_subscriptions[id].subscriber == msg.sender, BBErrorCodesV01.NOT_SUBSCRIPTION_OWNER);\\r\\n        require(_subscriptions[id].cancelled == false, BBErrorCodesV01.SUBSCRIPTION_CANCELLED);\\r\\n\\r\\n        _subscriptions[id].cancelled = true;\\r\\n\\r\\n        emit Unsubscribed(id);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @notice Check if there are subscriptions to renew within a range\\r\\n\\r\\n        @param Lower bound, upper bound, minimum number of IDs to renew, maximum number of IDs to renew, and refund receiver packed into bytes array\\r\\n\\r\\n        @return True if there are subscriptions to renew within the lower and upper bound, otherwise false\\r\\n        @return Array of subscription IDs to renew and refund receiver packed into bytes array\\r\\n    */\\r\\n    function checkUpkeep(bytes calldata checkData) external view override returns (bool, bytes memory) {\\r\\n        (uint256 lowerBound, uint256 upperBound, uint256 minRenews, uint256 maxRenews, address refundReceiver) = abi.decode(checkData, (uint256, uint256, uint256, uint256, address));\\r\\n\\r\\n        // Limit upper bound within total subscriptions\\r\\n        if(upperBound >= _totalSubscriptions) {\\r\\n            upperBound = _totalSubscriptions - 1;\\r\\n        }\\r\\n\\r\\n        // Lower bound must be less than upper bound\\r\\n        require(lowerBound <= upperBound, BBErrorCodesV01.OUT_OF_BOUNDS);\\r\\n\\r\\n        uint256 renewalCount;\\r\\n        uint256 checkLength = (upperBound - lowerBound) + 1;\\r\\n\\r\\n        uint256[] memory maxRenewIndexes = new uint256[](maxRenews);\\r\\n\\r\\n        for(uint256 i; i < checkLength; i++) {\\r\\n            uint256 subscriptionIndex = lowerBound + i;\\r\\n\\r\\n            // If subscription has expired, increment total number of subscriptions to renew\\r\\n            if(_subscriptions[subscriptionIndex].expiration < block.timestamp && _subscriptions[subscriptionIndex].cancelled == false) {               \\r\\n                maxRenewIndexes[renewalCount] = subscriptionIndex;\\r\\n                renewalCount++;\\r\\n\\r\\n                if(renewalCount >= maxRenews) {\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If subscriptions to renew is zero or less than minimum required renewals, return false\\r\\n        if(renewalCount == 0 || renewalCount < minRenews) {\\r\\n            return (false, \\\"\\\");\\r\\n        }\\r\\n\\r\\n        // Return the maximum number of indexes that can be renewed\\r\\n        if(renewalCount == maxRenews) {\\r\\n            return (true, abi.encode(maxRenewIndexes, refundReceiver));\\r\\n        }\\r\\n\\r\\n        // Resize renewal indexes array\\r\\n        uint256[] memory renewIndexes = new uint256[](renewalCount);\\r\\n\\r\\n        for(uint256 i; i < renewalCount; i++) {\\r\\n            renewIndexes[i] = maxRenewIndexes[i];\\r\\n        }\\r\\n\\r\\n        return (true, abi.encode(renewIndexes, refundReceiver));\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @notice Transfers this contracts tokens to the subscription factory treasury\\r\\n    */\\r\\n    function withdrawToTreasury() public {\\r\\n        _currency.transfer(_bbSubscriptionsFactory.getTreasury(), _currency.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @notice Get a subscriptions values\\r\\n\\r\\n        @param Profile ID\\r\\n        @param Tier ID\\r\\n        @param Subscriber\\r\\n\\r\\n        @return Subscription ID\\r\\n        @return Price (monthly)\\r\\n        @return Expiration\\r\\n        @return Subscription cancelled\\r\\n    */\\r\\n    function getSubscriptionFromProfile(uint256 profileId, uint256 tierId, address subscriber) external view returns (uint256, uint256, uint256, bool) {\\r\\n        uint256 id = _getSubscriptionId(profileId, tierId, subscriber);\\r\\n\\r\\n        return (\\r\\n            id,\\r\\n            _subscriptions[id].price,\\r\\n            _subscriptions[id].expiration,\\r\\n            _subscriptions[id].cancelled\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @notice Get a subscriptions values\\r\\n\\r\\n        @param Subscription ID\\r\\n\\r\\n        @return Profile ID\\r\\n        @return Tier ID\\r\\n        @return Subscriber\\r\\n        @return Price (monthly)\\r\\n        @return Expiration\\r\\n        @return Subscription cancelled\\r\\n    */\\r\\n    function getSubscriptionFromId(uint256 subscriptionId) external view returns (uint256, uint256, address, uint256, uint256, bool) {\\r\\n        return (\\r\\n            _subscriptions[subscriptionId].profileId,\\r\\n            _subscriptions[subscriptionId].tierId,\\r\\n            _subscriptions[subscriptionId].subscriber,\\r\\n            _subscriptions[subscriptionId].price,\\r\\n            _subscriptions[subscriptionId].expiration,\\r\\n            _subscriptions[subscriptionId].cancelled\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @dev Get a subscription ID\\r\\n\\r\\n        @param Profile ID\\r\\n        @param Tier ID\\r\\n        @param Subscriber\\r\\n\\r\\n        @return Subscription ID\\r\\n    */\\r\\n    function _getSubscriptionId(uint256 profileId, uint256 tierId, address subscriber) internal view returns (uint256) {\\r\\n        require(_subscriptionIndexes[profileId][tierId][subscriber] > 0, BBErrorCodesV01.SUBSCRIPTION_NOT_EXIST);\\r\\n        return _subscriptionIndexes[profileId][tierId][subscriber] - 1;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        @dev Gets the upkeep gas refund\\r\\n\\r\\n        @return Upkeep gas refund\\r\\n    */\\r\\n    function _getUpkeepRefund() internal view returns (uint256) {\\r\\n        return _bbSubscriptionsFactory.getSubscriptionFee(address(_currency)) / 60;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBBSubscriptions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\\\";\\r\\n\\r\\ninterface IBBSubscriptions is KeeperCompatibleInterface {\\r\\n    function subscribe(uint256 profileId, uint256 tierId, uint256 expectedPrice) external payable returns(uint256 subscriptionId);\\r\\n    function unsubscribe(uint256 profileId, uint256 tierId) external;\\r\\n    \\r\\n    function withdrawToTreasury() external;\\r\\n\\r\\n    function getSubscriptionFromProfile(uint256 profileId, uint256 tierId, address subscriber) external view returns (uint256 subscriptionId, uint256 price, uint256 expiration, bool cancelled);\\r\\n    function getSubscriptionFromId(uint256 subscriptionId) external view returns (uint256 profileId, uint256 tierId, address subscriber, uint256 price, uint256 expiration, bool cancelled);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBBSubscriptionsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface IBBSubscriptionsFactory {\\r\\n    function deploySubscriptions(address currency) external returns(address subscriptions);\\r\\n    function isSubscriptionsDeployed(address currency) external view returns (bool deployed);\\r\\n    function getDeployedSubscriptions(address currency) external view returns (address subscriptions);\\r\\n\\r\\n    function setTreasuryOwner(address account) external;\\r\\n    function setGasOracleOwner(address account) external;\\r\\n    function setSubscriptionFeeOwner(address account) external;\\r\\n\\r\\n    function getTreasuryOwner() external view returns (address treasury);\\r\\n    function getGasOracleOwner() external view returns (address gasPriceOwner);\\r\\n    function getSubscriptionFeeOwner() external view returns (address subscriptionFeeOwner);\\r\\n\\r\\n    function setTreasury(address account) external;\\r\\n    function setGasOracle(address account) external;\\r\\n    function setSubscriptionFee(address currency, uint256 amount) external;\\r\\n\\r\\n    function getTreasury() external view returns (address treasury);\\r\\n    function getGasOracle() external view returns (address oracle);\\r\\n    function getSubscriptionFee(address currency) external view returns (uint256 fee);\\r\\n\\r\\n    function getGracePeriod() external pure returns (uint256 gracePeriod);\\r\\n    function getContributionBounds() external pure returns (uint256 lower, uint256 upper);\\r\\n\\r\\n    function setSubscriptionCurrency(uint256 profileId, uint256 tierId, address account, address currency) external;\\r\\n    function getSubscriptionCurrency(uint256 profileId, uint256 tierId, address account) external view returns (address currency);\\r\\n\\r\\n    function createSubscriptionProfile(uint256 profileId, uint256 tierSetId, uint256 contribution) external;\\r\\n    function setContribution(uint256 profileId, uint256 contribution) external;\\r\\n\\r\\n    function getSubscriptionProfile(uint256 profileId) external view returns (uint256 tierSetId, uint256 contribution);\\r\\n    function isSubscriptionProfileCreated(uint256 profileId) external view returns (bool created);\\r\\n\\r\\n    function isSubscriptionActive(uint256 profileId, uint256 tierId, address account) external view returns (bool active);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBBTiers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface IBBTiers {\\r\\n    function createTiers(uint256 profileId, uint256[] calldata prices, string[] calldata cids, bool[] memory deprecated, address[] calldata supportedCurrencies, uint256[] calldata priceMultipliers) external returns(uint256 tierSetId);\\r\\n    function editTiers(uint256 profileId, uint256 tierSetId, uint256[] calldata prices, string[] calldata cids, bool[] memory deprecated) external;\\r\\n    function setSupportedCurrencies(uint256 profileId, uint256 tierSetId, address[] calldata supportedCurrencies, uint256[] calldata priceMultipliers) external;\\r\\n\\r\\n    function getTier(uint256 profileId, uint256 tierSetId, uint256 tierId, address currency) external view returns (string memory, uint256, bool);\\r\\n    function getTierSet(uint256 profileId, uint256 tierSetId) external view returns (uint256[] memory prices, string[] memory cids, bool[] memory deprecated);\\r\\n\\r\\n    function totalTiers(uint256 profileId, uint256 tierSetId) external view returns (uint256 total);\\r\\n    function totalTierSets(uint256 profileId) external view returns (uint256 total);\\r\\n\\r\\n    function getCurrencyMultiplier(uint256 profileId, uint256 tierSetId, address currency) external view returns (uint256 multiplier);\\r\\n    function isCurrencySupported(uint256 profileId, uint256 tierSetId, address currency) external view returns (bool supported);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBBProfiles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface IBBProfiles {\\r\\n    function createProfile(address owner, address receiver, string calldata cid) external returns(uint256 profileId);\\r\\n    function editProfile(uint256 profileId, address owner, address receiver, string calldata cid) external; \\r\\n\\r\\n    function totalProfiles() external view returns (uint256 total);\\r\\n    function getProfile(uint256 profileId) external view returns (address owner, address receiver, string memory cid);\\r\\n\\r\\n    function getOwnersProfiles(address account) external view returns (uint256[] memory profileIds);\\r\\n    function ownersTotalProfiles(address owner) external view returns (uint256 total);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBBGasOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\ninterface IBBGasOracle {\\r\\n    function getGasPrice() external view returns(uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/BBErrorsV01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nlibrary BBErrorCodesV01 {\\r\\n    string public constant NOT_OWNER = \\\"1\\\";\\r\\n    string public constant OUT_OF_BOUNDS = \\\"2\\\";\\r\\n    string public constant NOT_SUBSCRIPTION_OWNER = \\\"3\\\";\\r\\n    string public constant POST_NOT_EXIST = \\\"4\\\";\\r\\n    string public constant PROFILE_NOT_EXIST = \\\"5\\\";\\r\\n    string public constant TIER_SET_NOT_EXIST = \\\"6\\\";\\r\\n    string public constant TIER_NOT_EXIST = \\\"7\\\";\\r\\n    string public constant SUBSCRIPTION_NOT_EXIST = \\\"8\\\";\\r\\n    string public constant ZERO_ADDRESS = \\\"9\\\";\\r\\n    string public constant SUBSCRIPTION_NOT_EXPIRED = \\\"10\\\";\\r\\n    string public constant SUBSCRIPTION_CANCELLED = \\\"11\\\";\\r\\n    string public constant UPKEEP_FAIL = \\\"12\\\";\\r\\n    string public constant INSUFFICIENT_PREPAID_GAS = \\\"13\\\";\\r\\n    string public constant INSUFFICIENT_ALLOWANCE = \\\"14\\\";\\r\\n    string public constant INSUFFICIENT_BALANCE = \\\"15\\\";\\r\\n    string public constant SUBSCRIPTION_ACTIVE = \\\"16\\\";\\r\\n    string public constant INVALID_LENGTH = \\\"17\\\";\\r\\n    string public constant UNSUPPORTED_CURRENCY = \\\"18\\\";\\r\\n    string public constant SUBSCRIPTION_PROFILE_ALREADY_EXISTS = \\\"19\\\";\\r\\n    string public constant INVALID_PRICE = \\\"20\\\";\\r\\n}\"\r\n    },\r\n    \"contracts/utils/DateTimeLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.0 <0.9.0;\\r\\n\\r\\n// adapted from https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\r\\n\\r\\nlibrary DateTimeLibrary {\\r\\n\\r\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\r\\n    int constant OFFSET19700101 = 2440588;\\r\\n\\r\\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\\r\\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\r\\n        daysInMonth = _getDaysInMonth(year, month);\\r\\n    }\\r\\n    \\r\\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\r\\n        int __days = int(_days);\\r\\n\\r\\n        int L = __days + 68569 + OFFSET19700101;\\r\\n        int N = 4 * L / 146097;\\r\\n        L = L - (146097 * N + 3) / 4;\\r\\n        int _year = 4000 * (L + 1) / 1461001;\\r\\n        L = L - 1461 * _year / 4 + 31;\\r\\n        int _month = 80 * L / 2447;\\r\\n        int _day = L - 2447 * _month / 80;\\r\\n        L = _month / 11;\\r\\n        _month = _month + 2 - 12 * L;\\r\\n        _year = 100 * (N - 49) + _year + L;\\r\\n\\r\\n        year = uint(_year);\\r\\n        month = uint(_month);\\r\\n        day = uint(_day);\\r\\n    }\\r\\n\\r\\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\\r\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\r\\n            daysInMonth = 31;\\r\\n        } else if (month != 2) {\\r\\n            daysInMonth = 30;\\r\\n        } else {\\r\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\\r\\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\\n */\\npragma solidity ^0.8.0;\\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \\\"./AutomationCompatibleInterface.sol\\\";\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AutomationCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bbProfiles\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bbTiers\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bbSubscriptionsFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subscriptionId\",\"type\":\"uint256\"}],\"name\":\"Renewed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subscriptionId\",\"type\":\"uint256\"}],\"name\":\"Subscribed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subscriptionId\",\"type\":\"uint256\"}],\"name\":\"Unsubscribed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"subscriptionId\",\"type\":\"uint256\"}],\"name\":\"getSubscriptionFromId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tierId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"getSubscriptionFromProfile\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"renewalData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tierId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedPrice\",\"type\":\"uint256\"}],\"name\":\"subscribe\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"subscriptionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tierId\",\"type\":\"uint256\"}],\"name\":\"unsubscribe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BBSubscriptions", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000096741579bac68b4044bbb4966d390e51081c7dc000000000000000000000000ffec1c5b14808d56a894916a52da300d8ee779410000000000000000000000005d2a904e7374cc3faa5658ecd462e370aa4637a60000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3a39c5ada5d363311dd5f0304938d785551523b2f8596a48b2dd752dd2be54c0"}