{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ICO/ICO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface ICommissionsAddressRouter {\\n    function getAddress() external view returns (address);\\n}\\n\\ninterface ICommissionsRouter {\\n    function receiveFees(uint256, bytes32) external;\\n}\\n\\nusing Counters for Counters.Counter;\\n\\ncontract ICO is Ownable {\\n    uint256 public initialBRINAmount = 7178000 ether;\\n    uint256 public initialBRINGAmount = 200;\\n    uint256 public initialBRLDAmount = 47000;\\n    IERC20 public BRIN;\\n    IERC20 public BRING;\\n    IERC20 public BRLD;\\n    IERC20 public USDT;\\n    ICommissionsAddressRouter commissionsAddressRouter;\\n    uint256 public brinPrice = 50000;\\n    uint256 public usdtRaised;\\n    uint256 public initialBalance;\\n    address public bringoldWallet;\\n    bool initialized;\\n    mapping(address => uint256) tokensPurchased;\\n\\n    event TokenPurchase(address indexed buyer, uint256 value, uint256 amount);\\n\\n    struct Phase {\\n        uint initialPrice;\\n        uint stepDiff;\\n        uint amountOfToken;\\n        uint currentTokenId;\\n        uint currentTokenPrice;\\n    }\\n\\n    enum TokenType {\\n        BRING,\\n        BRLD\\n    }\\n    TokenType public tokenType;\\n\\n    mapping(uint => mapping(uint => Phase)) phasesByTokenId;\\n\\n    Counters.Counter private bringPhaseNumber;\\n    Counters.Counter private brldPhaseNumber;\\n\\n    uint public brinSold;\\n    uint public bringSold;\\n    uint public brldSold;\\n\\n    constructor(\\n        address _USDT,\\n        address _BRIN,\\n        address _BRING,\\n        address _BRLD,\\n        address _commissionsAddressRouter,\\n        address _bringoldWallet\\n    ) {\\n        USDT = IERC20(_USDT);\\n        BRIN = IERC20(_BRIN);\\n        BRING = IERC20(_BRING);\\n        BRLD = IERC20(_BRLD);\\n        commissionsAddressRouter = ICommissionsAddressRouter(\\n            _commissionsAddressRouter\\n        );\\n        bringoldWallet = _bringoldWallet;\\n        bringPhaseNumber.increment();\\n        brldPhaseNumber.increment();\\n        phasesByTokenId[0][1] = Phase(1000 ether, 10 ether, 50, 1, 1000 ether);\\n        phasesByTokenId[0][2] = Phase(1500 ether, 10 ether, 50, 1, 1500 ether);\\n        phasesByTokenId[0][3] = Phase(2000 ether, 10 ether, 100, 1, 2000 ether);\\n\\n        phasesByTokenId[1][1] = Phase(\\n            20 ether,\\n            500000 gwei,\\n            20000,\\n            1,\\n            20 ether\\n        );\\n        phasesByTokenId[1][2] = Phase(\\n            30 ether,\\n            500000 gwei,\\n            20000,\\n            1,\\n            30 ether\\n        );\\n        phasesByTokenId[1][3] = Phase(40 ether, 500000 gwei, 7000, 1, 40 ether);\\n    }\\n\\n    modifier initializedContract() {\\n        require(initialized == true, \\\"Contract is not initialized\\\");\\n        _;\\n    }\\n\\n    function initialize() public onlyOwner {\\n        require(initialized != true);\\n        require(\\n            BRIN.balanceOf(address(this)) == initialBRINAmount,\\n            \\\"not enough brin balance\\\"\\n        );\\n        require(\\n            BRING.balanceOf(address(this)) == initialBRINGAmount,\\n            \\\"not enough bring balance\\\"\\n        );\\n        require(\\n            BRLD.balanceOf(address(this)) == initialBRLDAmount,\\n            \\\"not enough brld balance\\\"\\n        );\\n        initialized = true;\\n    }\\n\\n    function getBrinTokenBalance() public view returns (uint256) {\\n        return BRIN.balanceOf(address(this));\\n    }\\n\\n    function getBringTokenBalance() public view returns (uint256) {\\n        return BRING.balanceOf(address(this));\\n    }\\n\\n    function getBrldTokenBalance() public view returns (uint256) {\\n        return BRLD.balanceOf(address(this));\\n    }\\n\\n    function getUsdtTokenBalance() public view returns (uint256) {\\n        return USDT.balanceOf(address(this));\\n    }\\n\\n    /**\\n        @dev Returns estimated price for amount of token to be bought\\n        @param amount Amount of brld to be bought\\n        @param token 0=BRING, 1=BRLD\\n    */\\n    function getCostOfNTokenPublic(\\n        uint amount,\\n        TokenType token\\n    ) public view returns (uint256) {\\n        if (amount > 0 && amount <= getTokenBalance(token)) {\\n            uint currentTokenId = getIdOfCurrentToken(token);\\n            uint idOfLastToken = getIdOfLastToken(token);\\n            uint n = amount + currentTokenId - 1;\\n            uint amountCurrentPhase = idOfLastToken - currentTokenId + 1;\\n            if (n <= idOfLastToken) {\\n                uint cost = calculateRealCost(\\n                    n,\\n                    getPriceOfCurrentToken(token),\\n                    n - currentTokenId + 1,\\n                    token\\n                ); //\\n\\n                return cost;\\n            } else if (\\n                getPhaseNumberByToken(token) == 1 &&\\n                amount > amountCurrentPhase + getTotalAmountOfPhase(token, 2)\\n            ) {\\n                uint amountPhaseTwo = getTotalAmountOfPhase(token, 2);\\n\\n                uint currentPhaseCost = calculateRealCost(\\n                    idOfLastToken,\\n                    getPriceOfCurrentToken(token),\\n                    amountCurrentPhase,\\n                    token\\n                );\\n\\n                uint nextPhaseCost = calculateRealCostTransition(\\n                    amountPhaseTwo,\\n                    getInitialPriceOfPhase(token, 2),\\n                    amountPhaseTwo - 1 + 1,\\n                    token,\\n                    2\\n                );\\n\\n                uint lastPhaseN = amount - amountCurrentPhase - amountPhaseTwo;\\n\\n                uint lastPhaseCost = calculateRealCostTransition(\\n                    lastPhaseN,\\n                    getInitialPriceOfPhase(token, 3),\\n                    lastPhaseN - 1 + 1,\\n                    token,\\n                    3\\n                );\\n\\n                return currentPhaseCost + nextPhaseCost + lastPhaseCost;\\n            } else {\\n                uint currentPhaseCost = calculateRealCost(\\n                    idOfLastToken,\\n                    getPriceOfCurrentToken(token),\\n                    amountCurrentPhase,\\n                    token\\n                );\\n\\n                uint nextPhaseN = amount - amountCurrentPhase;\\n                uint nextPhaseCost = calculateRealCostTransition(\\n                    nextPhaseN,\\n                    getInitialPriceOfPhase(\\n                        token,\\n                        getPhaseNumberByToken(token) + 1\\n                    ),\\n                    nextPhaseN,\\n                    token,\\n                    getPhaseNumberByToken(token) + 1\\n                );\\n                return currentPhaseCost + nextPhaseCost;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n        @dev Returns total amount of Brin sold\\n    */\\n    function getBrinSold() external view returns (uint) {\\n        return brinSold;\\n    }\\n\\n    /**\\n        @dev Returns total amount of Bring sold\\n    */\\n    function getBringSold() external view returns (uint) {\\n        return bringSold;\\n    }\\n\\n    /**\\n        @dev Returns total amount of Brld sold\\n    */\\n    function getBrldSold() external view returns (uint) {\\n        return brldSold;\\n    }\\n\\n    /**\\n        @dev Returns availabe amount of Brin\\n    */\\n    function getBrinAvailable() external view returns (uint) {\\n        return initialBRINAmount - brinSold;\\n    }\\n\\n    /**\\n        @dev Returns availabe amount of Bring\\n    */\\n    function getBringAvailable() external view returns (uint) {\\n        return initialBRINGAmount - bringSold;\\n    }\\n\\n    /**\\n        @dev Returns availabe amount of Brld\\n    */\\n    function getBrldAvailable() external view returns (uint) {\\n        return initialBRLDAmount - brldSold;\\n    }\\n\\n    function setBrinPrice(uint price) external onlyOwner {\\n        require(price > 0, \\\"must be gt 0\\\");\\n        brinPrice = price;\\n    }\\n\\n    /**\\n        @dev Buys brin with usdt\\n        @param amount Amount of brins to be bought\\n    */\\n    function buyBrin(uint amount) external initializedContract {\\n        require(amount <= initialBRINAmount - brinSold, \\\"sold out\\\");\\n        uint priceWei = amount * brinPrice;\\n        require(priceWei >= 1 ether, \\\"Invalid amount\\\");\\n        uint price = priceWei / 1 ether;\\n        USDT.transferFrom(msg.sender, bringoldWallet, price);\\n        BRIN.transfer(msg.sender, amount);\\n        brinSold += amount;\\n    }\\n\\n    /**\\n        @dev Buys bring with brin, fails if realCost(amount) > estimatedPrice + slippage \\n        @param amount Amount of brings to be bought\\n        @param slippage Accepted increase in price\\n        @param estimatedPrice estimated total price based on amount of tokens accepted by user\\n    */\\n    function buyBring(\\n        uint amount,\\n        uint slippage,\\n        uint estimatedPrice\\n    ) external initializedContract {\\n        _preValidatePurchase(amount, TokenType.BRING);\\n        uint256 cost = getCostOfNToken(amount, TokenType.BRING);\\n        _validateSlippage(slippage, estimatedPrice, cost);\\n\\n        BRIN.transferFrom(msg.sender, address(this), cost);\\n        BRING.transfer(msg.sender, amount);\\n        transferFees(cost, TokenType.BRING);\\n        bringSold += amount;\\n    }\\n\\n    /**\\n        @dev Buys brld with brin, fails if realCost(amount) > estimatedPrice + slippage \\n        @param amount Amount of brld to be bought\\n        @param slippage Accepted increase in price\\n        @param estimatedPrice estimated total price based on amount of tokens accepted by user\\n    */\\n    function buyBrld(\\n        uint amount,\\n        uint slippage,\\n        uint estimatedPrice\\n    ) external initializedContract {\\n        _preValidatePurchase(amount, TokenType.BRLD);\\n        uint256 cost = getCostOfNToken(amount, TokenType.BRLD);\\n        _validateSlippage(slippage, estimatedPrice, cost);\\n\\n        BRIN.transferFrom(msg.sender, address(this), cost);\\n        BRLD.transfer(msg.sender, amount);\\n        transferFees(cost, TokenType.BRLD);\\n        brldSold += amount;\\n    }\\n\\n    function getPhaseNumberByToken(\\n        TokenType token\\n    ) internal view returns (uint) {\\n        if (token == TokenType.BRING) {\\n            return bringPhaseNumber.current();\\n        }\\n        return brldPhaseNumber.current();\\n    }\\n\\n    function getPriceOfNthToken(\\n        uint n,\\n        TokenType token\\n    ) internal view returns (uint) {\\n        uint initialPrice = phasesByTokenId[uint(token)][\\n            getPhaseNumberByToken(token)\\n        ].initialPrice;\\n        uint stepDiff = phasesByTokenId[uint(token)][\\n            getPhaseNumberByToken(token)\\n        ].stepDiff;\\n        return initialPrice + (n - 1) * stepDiff;\\n    }\\n\\n    function getPriceOfNthTokenTransition(\\n        uint n,\\n        TokenType token,\\n        uint phaseNumber\\n    ) internal view returns (uint) {\\n        uint initialPrice = phasesByTokenId[uint(token)][phaseNumber]\\n            .initialPrice;\\n        uint stepDiff = phasesByTokenId[uint(token)][phaseNumber].stepDiff;\\n        return initialPrice + (n - 1) * stepDiff;\\n    }\\n\\n    function getPriceOfCurrentToken(\\n        TokenType token\\n    ) public view returns (uint) {\\n        return\\n            phasesByTokenId[uint(token)][uint(getPhaseNumberByToken(token))]\\n                .currentTokenPrice;\\n    }\\n\\n    function getInitialPriceOfPhase(\\n        TokenType token,\\n        uint phaseNumber\\n    ) internal view returns (uint) {\\n        return phasesByTokenId[uint(token)][phaseNumber].initialPrice;\\n    }\\n\\n    function getTotalAmountOfPhase(\\n        TokenType token,\\n        uint phaseNumber\\n    ) internal view returns (uint) {\\n        return phasesByTokenId[uint(token)][phaseNumber].amountOfToken;\\n    }\\n\\n    function getIdOfCurrentToken(TokenType token) public view returns (uint) {\\n        return\\n            phasesByTokenId[uint(token)][getPhaseNumberByToken(token)]\\n                .currentTokenId;\\n    }\\n\\n    function getIdOfLastToken(TokenType token) internal view returns (uint) {\\n        return\\n            phasesByTokenId[uint(token)][getPhaseNumberByToken(token)]\\n                .amountOfToken;\\n    }\\n\\n    function calculateRealCost(\\n        uint an,\\n        uint a1,\\n        uint n1,\\n        TokenType token\\n    ) internal view returns (uint) {\\n        return ((getPriceOfNthToken(an, token) + a1) * (n1)) / 2;\\n    }\\n\\n    function calculateRealCostTransition(\\n        uint an,\\n        uint a1,\\n        uint n1,\\n        TokenType token,\\n        uint phaseNumber\\n    ) internal view returns (uint) {\\n        return\\n            ((getPriceOfNthTokenTransition(an, token, phaseNumber) + a1) *\\n                (n1)) / 2;\\n    }\\n\\n    function updateCurrentTokenId(uint setId, TokenType token) internal {\\n        uint phaseNumber = uint(getPhaseNumberByToken(token));\\n        phasesByTokenId[uint(token)][phaseNumber].currentTokenId = setId;\\n        phasesByTokenId[uint(token)][phaseNumber]\\n            .currentTokenPrice = getPriceOfNthTokenTransition(\\n            setId,\\n            token,\\n            phaseNumber\\n        );\\n    }\\n\\n    function incrementPhaseNumber(TokenType token) internal {\\n        if (token == TokenType.BRING) {\\n            bringPhaseNumber.increment();\\n        } else {\\n            brldPhaseNumber.increment();\\n        }\\n    }\\n\\n    function getCostOfNToken(\\n        uint amount,\\n        TokenType token\\n    ) internal returns (uint) {\\n        uint currentTokenId = getIdOfCurrentToken(token);\\n        uint idOfLastToken = getIdOfLastToken(token);\\n        uint n = amount + currentTokenId - 1;\\n        uint amountCurrentPhase = idOfLastToken - currentTokenId + 1;\\n        if (n <= idOfLastToken) {\\n            uint cost = calculateRealCost(\\n                n,\\n                getPriceOfCurrentToken(token),\\n                n - currentTokenId + 1,\\n                token\\n            );\\n            if (n == idOfLastToken) {\\n                incrementPhaseNumber(token);\\n                updateCurrentTokenId(1, token);\\n            } else {\\n                updateCurrentTokenId(n + 1, token);\\n            }\\n\\n            return cost;\\n        } else if (\\n            getPhaseNumberByToken(token) == 1 &&\\n            amount > amountCurrentPhase + getTotalAmountOfPhase(token, 2)\\n        ) {\\n            uint amountPhaseTwo = getTotalAmountOfPhase(token, 2);\\n\\n            uint currentPhaseCost = calculateRealCost(\\n                idOfLastToken,\\n                getPriceOfCurrentToken(token),\\n                amountCurrentPhase,\\n                token\\n            );\\n\\n            uint nextPhaseCost = calculateRealCostTransition(\\n                amountPhaseTwo,\\n                getInitialPriceOfPhase(token, 2),\\n                amountPhaseTwo - 1 + 1,\\n                token,\\n                2\\n            );\\n\\n            uint lastPhaseN = amount - amountCurrentPhase - amountPhaseTwo;\\n\\n            uint lastPhaseCost = calculateRealCostTransition(\\n                lastPhaseN,\\n                getInitialPriceOfPhase(token, 3),\\n                lastPhaseN - 1 + 1,\\n                token,\\n                3\\n            );\\n            incrementPhaseNumber(token);\\n            incrementPhaseNumber(token);\\n            updateCurrentTokenId(lastPhaseN + 1, token);\\n            if (lastPhaseN == getTotalAmountOfPhase(token, 3)) {\\n                incrementPhaseNumber(token);\\n            }\\n\\n            return currentPhaseCost + nextPhaseCost + lastPhaseCost;\\n        } else {\\n            uint currentPhaseCost = calculateRealCost(\\n                idOfLastToken,\\n                getPriceOfCurrentToken(token),\\n                amountCurrentPhase,\\n                token\\n            );\\n\\n            uint nextPhaseN = amount - amountCurrentPhase;\\n            uint nextPhaseCost = calculateRealCostTransition(\\n                nextPhaseN,\\n                getInitialPriceOfPhase(token, getPhaseNumberByToken(token) + 1),\\n                nextPhaseN,\\n                token,\\n                getPhaseNumberByToken(token) + 1\\n            );\\n            incrementPhaseNumber(token);\\n            if (\\n                nextPhaseN ==\\n                getTotalAmountOfPhase(token, getPhaseNumberByToken(token))\\n            ) {\\n                incrementPhaseNumber(token);\\n                updateCurrentTokenId(1, token);\\n            } else {\\n                updateCurrentTokenId(nextPhaseN + 1, token);\\n            }\\n            return currentPhaseCost + nextPhaseCost;\\n        }\\n    }\\n\\n    function getTokenBalance(TokenType token) internal view returns (uint) {\\n        if (token == TokenType.BRING) {\\n            return initialBRINGAmount - bringSold;\\n        } else if (token == TokenType.BRLD) {\\n            return initialBRLDAmount - brldSold;\\n        }\\n        return 0;\\n    }\\n\\n    function _preValidatePurchase(\\n        uint256 amount,\\n        TokenType token\\n    ) internal view {\\n        require(amount > 0, \\\"Amount must be greater than zero\\\");\\n        require(getPhaseNumberByToken(token) <= 3, \\\"sold out\\\");\\n        require(\\n            amount <= getTokenBalance(token),\\n            \\\"amount is greater than available token amount\\\"\\n        );\\n    }\\n\\n    function _validateSlippage(\\n        uint slippage,\\n        uint estimatedPrice,\\n        uint cost\\n    ) internal pure {\\n        require(\\n            cost <= estimatedPrice + slippage,\\n            \\\"Total cost exceeds allowed slippage\\\"\\n        );\\n    }\\n\\n    function transferFees(uint amount, TokenType token) internal {\\n        bytes32 route;\\n        if (token == TokenType.BRING) {\\n            route = bytes32(\\\"TX\\\");\\n        } else {\\n            route = bytes32(\\\"BRLD\\\");\\n        }\\n        address commissionsRouter = commissionsAddressRouter.getAddress();\\n        BRIN.approve(commissionsRouter, amount);\\n        ICommissionsRouter(commissionsRouter).receiveFees(amount, route);\\n    }\\n\\n    function getTokenBalance(uint8 token) external view returns (uint) {\\n        if (token == 0) {\\n            return initialBRINGAmount - bringSold;\\n        } else if (token == 1) {\\n            return initialBRLDAmount - brldSold;\\n        } else if (token == 2) {\\n            return initialBRINAmount - brinSold;\\n        }\\n        return 0;\\n    }\\n\\n    function startBringSecondPhase() external onlyOwner {\\n        require(bringPhaseNumber.current() == 4, \\\"phase1 did not end\\\");\\n        require(bringSold == 200, \\\"not sold out\\\");\\n        require(BRING.balanceOf(address(this)) == 28000, \\\"fund BRING\\\");\\n        initialBRINGAmount = 28000;\\n        bringPhaseNumber.decrement();\\n        bringPhaseNumber.decrement();\\n        bringPhaseNumber.decrement();\\n        bringSold = 0;\\n        phasesByTokenId[0][1] = Phase(\\n            3000 ether,\\n            100 ether,\\n            100,\\n            1,\\n            3000 ether\\n        );\\n        phasesByTokenId[0][2] = Phase(\\n            13000 ether,\\n            10 ether,\\n            13950,\\n            1,\\n            13000 ether\\n        );\\n        phasesByTokenId[0][3] = Phase(\\n            152500 ether,\\n            10 ether,\\n            13950,\\n            1,\\n            152500 ether\\n        );\\n    }\\n\\n    function withDrawAllTokens(address to) external onlyOwner {\\n        BRIN.transfer(to, BRIN.balanceOf(address(this)));\\n        BRING.transfer(to, BRING.balanceOf(address(this)));\\n        BRLD.transfer(to, BRLD.balanceOf(address(this)));\\n        USDT.transfer(to, USDT.balanceOf(address(this)));\\n    }\\n\\n    function withdrawBrin(address to) external onlyOwner {\\n        BRIN.transfer(to, BRIN.balanceOf(address(this)));\\n    }\\n\\n    function withdrawBring(address to) external onlyOwner {\\n        BRING.transfer(to, BRING.balanceOf(address(this)));\\n    }\\n\\n    function withdrawBRLD(address to) external onlyOwner {\\n        BRLD.transfer(to, BRLD.balanceOf(address(this)));\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_USDT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_BRIN\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_BRING\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_BRLD\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_commissionsAddressRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bringoldWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BRIN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BRING\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BRLD\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brinPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brinSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bringSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bringoldWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brldSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyBrin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedPrice\",\"type\":\"uint256\"}],\"name\":\"buyBring\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedPrice\",\"type\":\"uint256\"}],\"name\":\"buyBrld\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBrinAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBrinSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBrinTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBringAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBringSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBringTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBrldAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBrldSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBrldTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum ICO.TokenType\",\"name\":\"token\",\"type\":\"uint8\"}],\"name\":\"getCostOfNTokenPublic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ICO.TokenType\",\"name\":\"token\",\"type\":\"uint8\"}],\"name\":\"getIdOfCurrentToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ICO.TokenType\",\"name\":\"token\",\"type\":\"uint8\"}],\"name\":\"getPriceOfCurrentToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"token\",\"type\":\"uint8\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsdtTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialBRINAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialBRINGAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialBRLDAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setBrinPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBringSecondPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenType\",\"outputs\":[{\"internalType\":\"enum ICO.TokenType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withDrawAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawBRLD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawBrin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawBring\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ICO", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000bc0b7de316f4e57c677370ccd3a36697d6fc5de2000000000000000000000000b67b696a7f55a52723d80f62bb5f8532abdbc67400000000000000000000000009a89f63023ac7ea03c8e8810a95e19ef150e2f200000000000000000000000083e92ce0965ab1b6e4c02fb2746c13daaa1fe69e000000000000000000000000901b903cdbb3a862baa3cbb24855c50900d740a0", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}