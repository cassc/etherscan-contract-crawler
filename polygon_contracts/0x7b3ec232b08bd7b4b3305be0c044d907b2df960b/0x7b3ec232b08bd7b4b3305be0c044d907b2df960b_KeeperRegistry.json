{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.7/AuthorizedForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./interfaces/OperatorInterface.sol\\\";\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\nimport \\\"./AuthorizedReceiver.sol\\\";\\nimport \\\"./vendor/Address.sol\\\";\\n\\ncontract AuthorizedForwarder is ConfirmedOwnerWithProposal, AuthorizedReceiver {\\n  using Address for address;\\n\\n  address public immutable getChainlinkToken;\\n\\n  event OwnershipTransferRequestedWithMessage(address indexed from, address indexed to, bytes message);\\n\\n  constructor(\\n    address link,\\n    address owner,\\n    address recipient,\\n    bytes memory message\\n  ) ConfirmedOwnerWithProposal(owner, recipient) {\\n    getChainlinkToken = link;\\n    if (recipient != address(0)) {\\n      emit OwnershipTransferRequestedWithMessage(owner, recipient, message);\\n    }\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion() external pure virtual returns (string memory) {\\n    return \\\"AuthorizedForwarder 1.0.0\\\";\\n  }\\n\\n  /**\\n   * @notice Forward a call to another contract\\n   * @dev Only callable by an authorized sender\\n   * @param to address\\n   * @param data to forward\\n   */\\n  function forward(address to, bytes calldata data) external validateAuthorizedSender {\\n    require(to != getChainlinkToken, \\\"Cannot forward to Link token\\\");\\n    _forward(to, data);\\n  }\\n\\n  /**\\n   * @notice Forward a call to another contract\\n   * @dev Only callable by the owner\\n   * @param to address\\n   * @param data to forward\\n   */\\n  function ownerForward(address to, bytes calldata data) external onlyOwner {\\n    _forward(to, data);\\n  }\\n\\n  /**\\n   * @notice Transfer ownership with instructions for recipient\\n   * @param to address proposed recipient of ownership\\n   * @param message instructions for recipient upon accepting ownership\\n   */\\n  function transferOwnershipWithMessage(address to, bytes calldata message) external {\\n    transferOwnership(to);\\n    emit OwnershipTransferRequestedWithMessage(msg.sender, to, message);\\n  }\\n\\n  /**\\n   * @notice concrete implementation of AuthorizedReceiver\\n   * @return bool of whether sender is authorized\\n   */\\n  function _canSetAuthorizedSenders() internal view override returns (bool) {\\n    return owner() == msg.sender;\\n  }\\n\\n  /**\\n   * @notice common forwarding functionality and validation\\n   */\\n  function _forward(address to, bytes calldata data) private {\\n    require(to.isContract(), \\\"Must forward to a contract\\\");\\n    (bool status, ) = to.call(data);\\n    require(status, \\\"Forwarded call failed\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/OperatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ChainlinkRequestInterface.sol\\\";\\nimport \\\"./OracleInterface.sol\\\";\\n\\ninterface OperatorInterface is ChainlinkRequestInterface, OracleInterface {\\n  function operatorRequest(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function fulfillOracleRequest2(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes calldata data\\n  ) external returns (bool);\\n\\n  function ownerTransferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/AuthorizedReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./interfaces/AuthorizedReceiverInterface.sol\\\";\\n\\nabstract contract AuthorizedReceiver is AuthorizedReceiverInterface {\\n  mapping(address => bool) private s_authorizedSenders;\\n  address[] private s_authorizedSenderList;\\n\\n  event AuthorizedSendersChanged(address[] senders, address changedBy);\\n\\n  /**\\n   * @notice Sets the fulfillment permission for a given node. Use `true` to allow, `false` to disallow.\\n   * @param senders The addresses of the authorized Chainlink node\\n   */\\n  function setAuthorizedSenders(address[] calldata senders) external override validateAuthorizedSenderSetter {\\n    require(senders.length > 0, \\\"Must have at least 1 authorized sender\\\");\\n    // Set previous authorized senders to false\\n    uint256 authorizedSendersLength = s_authorizedSenderList.length;\\n    for (uint256 i = 0; i < authorizedSendersLength; i++) {\\n      s_authorizedSenders[s_authorizedSenderList[i]] = false;\\n    }\\n    // Set new to true\\n    for (uint256 i = 0; i < senders.length; i++) {\\n      s_authorizedSenders[senders[i]] = true;\\n    }\\n    // Replace list\\n    s_authorizedSenderList = senders;\\n    emit AuthorizedSendersChanged(senders, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Retrieve a list of authorized senders\\n   * @return array of addresses\\n   */\\n  function getAuthorizedSenders() external view override returns (address[] memory) {\\n    return s_authorizedSenderList;\\n  }\\n\\n  /**\\n   * @notice Use this to check if a node is authorized for fulfilling requests\\n   * @param sender The address of the Chainlink node\\n   * @return The authorization status of the node\\n   */\\n  function isAuthorizedSender(address sender) public view override returns (bool) {\\n    return s_authorizedSenders[sender];\\n  }\\n\\n  /**\\n   * @notice customizable guard of who can update the authorized sender list\\n   * @return bool whether sender can update authorized sender list\\n   */\\n  function _canSetAuthorizedSenders() internal virtual returns (bool);\\n\\n  /**\\n   * @notice validates the sender is an authorized sender\\n   */\\n  function _validateIsAuthorizedSender() internal view {\\n    require(isAuthorizedSender(msg.sender), \\\"Not authorized sender\\\");\\n  }\\n\\n  /**\\n   * @notice prevents non-authorized addresses from calling this method\\n   */\\n  modifier validateAuthorizedSender() {\\n    _validateIsAuthorizedSender();\\n    _;\\n  }\\n\\n  /**\\n   * @notice prevents non-authorized addresses from calling this method\\n   */\\n  modifier validateAuthorizedSenderSetter() {\\n    require(_canSetAuthorizedSenders(), \\\"Cannot set authorized senders\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts v3.4.0(fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6)\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain`call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/ChainlinkRequestInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface ChainlinkRequestInterface {\\n  function oracleRequest(\\n    address sender,\\n    uint256 requestPrice,\\n    bytes32 serviceAgreementID,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function cancelOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface OracleInterface {\\n  function fulfillOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes32 data\\n  ) external returns (bool);\\n\\n  function withdraw(address recipient, uint256 amount) external;\\n\\n  function withdrawable() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/AuthorizedReceiverInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface AuthorizedReceiverInterface {\\n  function isAuthorizedSender(address sender) external view returns (bool);\\n\\n  function getAuthorizedSenders() external returns (address[] memory);\\n\\n  function setAuthorizedSenders(address[] calldata senders) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.7/OperatorFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Operator.sol\\\";\\nimport \\\"./AuthorizedForwarder.sol\\\";\\n\\n/**\\n * @title Operator Factory\\n * @notice Creates Operator contracts for node operators\\n */\\ncontract OperatorFactory {\\n  address public immutable getChainlinkToken;\\n  mapping(address => bool) private s_created;\\n\\n  event OperatorCreated(address indexed operator, address indexed owner, address indexed sender);\\n  event AuthorizedForwarderCreated(address indexed forwarder, address indexed owner, address indexed sender);\\n\\n  /**\\n   * @param linkAddress address\\n   */\\n  constructor(address linkAddress) {\\n    getChainlinkToken = linkAddress;\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion() external pure virtual returns (string memory) {\\n    return \\\"OperatorFactory 1.0.0\\\";\\n  }\\n\\n  /**\\n   * @notice creates a new Operator contract with the msg.sender as owner\\n   */\\n  function deployNewOperator() external returns (address) {\\n    Operator operator = new Operator(getChainlinkToken, msg.sender);\\n\\n    s_created[address(operator)] = true;\\n    emit OperatorCreated(address(operator), msg.sender, msg.sender);\\n\\n    return address(operator);\\n  }\\n\\n  /**\\n   * @notice creates a new Operator contract with the msg.sender as owner and a\\n   * new Operator Forwarder with the Operator as the owner\\n   */\\n  function deployNewOperatorAndForwarder() external returns (address, address) {\\n    Operator operator = new Operator(getChainlinkToken, msg.sender);\\n    s_created[address(operator)] = true;\\n    emit OperatorCreated(address(operator), msg.sender, msg.sender);\\n\\n    bytes memory tmp = new bytes(0);\\n    AuthorizedForwarder forwarder = new AuthorizedForwarder(getChainlinkToken, address(this), address(operator), tmp);\\n    s_created[address(forwarder)] = true;\\n    emit AuthorizedForwarderCreated(address(forwarder), address(this), msg.sender);\\n\\n    return (address(operator), address(forwarder));\\n  }\\n\\n  /**\\n   * @notice creates a new Forwarder contract with the msg.sender as owner\\n   */\\n  function deployNewForwarder() external returns (address) {\\n    bytes memory tmp = new bytes(0);\\n    AuthorizedForwarder forwarder = new AuthorizedForwarder(getChainlinkToken, msg.sender, address(0), tmp);\\n\\n    s_created[address(forwarder)] = true;\\n    emit AuthorizedForwarderCreated(address(forwarder), msg.sender, msg.sender);\\n\\n    return address(forwarder);\\n  }\\n\\n  /**\\n   * @notice creates a new Forwarder contract with the msg.sender as owner\\n   */\\n  function deployNewForwarderAndTransferOwnership(address to, bytes calldata message) external returns (address) {\\n    AuthorizedForwarder forwarder = new AuthorizedForwarder(getChainlinkToken, msg.sender, to, message);\\n\\n    s_created[address(forwarder)] = true;\\n    emit AuthorizedForwarderCreated(address(forwarder), msg.sender, msg.sender);\\n\\n    return address(forwarder);\\n  }\\n\\n  /**\\n   * @notice indicates whether this factory deployed an address\\n   */\\n  function created(address query) external view returns (bool) {\\n    return s_created[query];\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/Operator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./AuthorizedReceiver.sol\\\";\\nimport \\\"./LinkTokenReceiver.sol\\\";\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/OperatorInterface.sol\\\";\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\nimport \\\"./interfaces/WithdrawalInterface.sol\\\";\\nimport \\\"./vendor/Address.sol\\\";\\nimport \\\"./vendor/SafeMathChainlink.sol\\\";\\n\\n/**\\n * @title The Chainlink Operator contract\\n * @notice Node operators can deploy this contract to fulfill requests sent to them\\n */\\ncontract Operator is AuthorizedReceiver, ConfirmedOwner, LinkTokenReceiver, OperatorInterface, WithdrawalInterface {\\n  using Address for address;\\n  using SafeMathChainlink for uint256;\\n\\n  struct Commitment {\\n    bytes31 paramsHash;\\n    uint8 dataVersion;\\n  }\\n\\n  uint256 public constant getExpiryTime = 5 minutes;\\n  uint256 private constant MAXIMUM_DATA_VERSION = 256;\\n  uint256 private constant MINIMUM_CONSUMER_GAS_LIMIT = 400000;\\n  uint256 private constant SELECTOR_LENGTH = 4;\\n  uint256 private constant EXPECTED_REQUEST_WORDS = 2;\\n  uint256 private constant MINIMUM_REQUEST_LENGTH = SELECTOR_LENGTH + (32 * EXPECTED_REQUEST_WORDS);\\n  // We initialize fields to 1 instead of 0 so that the first invocation\\n  // does not cost more gas.\\n  uint256 private constant ONE_FOR_CONSISTENT_GAS_COST = 1;\\n  // oracleRequest is intended for version 1, enabling single word responses\\n  bytes4 private constant ORACLE_REQUEST_SELECTOR = this.oracleRequest.selector;\\n  // operatorRequest is intended for version 2, enabling multi-word responses\\n  bytes4 private constant OPERATOR_REQUEST_SELECTOR = this.operatorRequest.selector;\\n\\n  LinkTokenInterface internal immutable linkToken;\\n  mapping(bytes32 => Commitment) private s_commitments;\\n  mapping(address => bool) private s_owned;\\n  // Tokens sent for requests that have not been fulfilled yet\\n  uint256 private s_tokensInEscrow = ONE_FOR_CONSISTENT_GAS_COST;\\n\\n  event OracleRequest(\\n    bytes32 indexed specId,\\n    address requester,\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddr,\\n    bytes4 callbackFunctionId,\\n    uint256 cancelExpiration,\\n    uint256 dataVersion,\\n    bytes data\\n  );\\n\\n  event CancelOracleRequest(bytes32 indexed requestId);\\n\\n  event OracleResponse(bytes32 indexed requestId);\\n\\n  event OwnableContractAccepted(address indexed acceptedContract);\\n\\n  event TargetsUpdatedAuthorizedSenders(address[] targets, address[] senders, address changedBy);\\n\\n  /**\\n   * @notice Deploy with the address of the LINK token\\n   * @dev Sets the LinkToken address for the imported LinkTokenInterface\\n   * @param link The address of the LINK token\\n   * @param owner The address of the owner\\n   */\\n  constructor(address link, address owner) ConfirmedOwner(owner) {\\n    linkToken = LinkTokenInterface(link); // external but already deployed and unalterable\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion() external pure virtual returns (string memory) {\\n    return \\\"Operator 1.0.0\\\";\\n  }\\n\\n  /**\\n   * @notice Creates the Chainlink request. This is a backwards compatible API\\n   * with the Oracle.sol contract, but the behavior changes because\\n   * callbackAddress is assumed to be the same as the request sender.\\n   * @param callbackAddress The consumer of the request\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param specId The Job Specification ID\\n   * @param callbackAddress The address the oracle data will be sent to\\n   * @param callbackFunctionId The callback function ID for the response\\n   * @param nonce The nonce sent by the requester\\n   * @param dataVersion The specified data version\\n   * @param data The extra request parameters\\n   */\\n  function oracleRequest(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external override validateFromLINK {\\n    (bytes32 requestId, uint256 expiration) = _verifyAndProcessOracleRequest(\\n      sender,\\n      payment,\\n      callbackAddress,\\n      callbackFunctionId,\\n      nonce,\\n      dataVersion\\n    );\\n    emit OracleRequest(specId, sender, requestId, payment, sender, callbackFunctionId, expiration, dataVersion, data);\\n  }\\n\\n  /**\\n   * @notice Creates the Chainlink request\\n   * @dev Stores the hash of the params as the on-chain commitment for the request.\\n   * Emits OracleRequest event for the Chainlink node to detect.\\n   * @param sender The sender of the request\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param specId The Job Specification ID\\n   * @param callbackFunctionId The callback function ID for the response\\n   * @param nonce The nonce sent by the requester\\n   * @param dataVersion The specified data version\\n   * @param data The extra request parameters\\n   */\\n  function operatorRequest(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external override validateFromLINK {\\n    (bytes32 requestId, uint256 expiration) = _verifyAndProcessOracleRequest(\\n      sender,\\n      payment,\\n      sender,\\n      callbackFunctionId,\\n      nonce,\\n      dataVersion\\n    );\\n    emit OracleRequest(specId, sender, requestId, payment, sender, callbackFunctionId, expiration, dataVersion, data);\\n  }\\n\\n  /**\\n   * @notice Called by the Chainlink node to fulfill requests\\n   * @dev Given params must hash back to the commitment stored from `oracleRequest`.\\n   * Will call the callback address' callback function without bubbling up error\\n   * checking in a `require` so that the node can get paid.\\n   * @param requestId The fulfillment request ID that must match the requester's\\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\\n   * @param callbackAddress The callback address to call for fulfillment\\n   * @param callbackFunctionId The callback function ID to use for fulfillment\\n   * @param expiration The expiration that the node should respond by before the requester can cancel\\n   * @param data The data to return to the consuming contract\\n   * @return Status if the external call was successful\\n   */\\n  function fulfillOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes32 data\\n  )\\n    external\\n    override\\n    validateAuthorizedSender\\n    validateRequestId(requestId)\\n    validateCallbackAddress(callbackAddress)\\n    returns (bool)\\n  {\\n    _verifyOracleRequestAndProcessPayment(requestId, payment, callbackAddress, callbackFunctionId, expiration, 1);\\n    emit OracleResponse(requestId);\\n    require(gasleft() >= MINIMUM_CONSUMER_GAS_LIMIT, \\\"Must provide consumer enough gas\\\");\\n    // All updates to the oracle's fulfillment should come before calling the\\n    // callback(addr+functionId) as it is untrusted.\\n    // See: https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern\\n    (bool success, ) = callbackAddress.call(abi.encodeWithSelector(callbackFunctionId, requestId, data)); // solhint-disable-line avoid-low-level-calls\\n    return success;\\n  }\\n\\n  /**\\n   * @notice Called by the Chainlink node to fulfill requests with multi-word support\\n   * @dev Given params must hash back to the commitment stored from `oracleRequest`.\\n   * Will call the callback address' callback function without bubbling up error\\n   * checking in a `require` so that the node can get paid.\\n   * @param requestId The fulfillment request ID that must match the requester's\\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\\n   * @param callbackAddress The callback address to call for fulfillment\\n   * @param callbackFunctionId The callback function ID to use for fulfillment\\n   * @param expiration The expiration that the node should respond by before the requester can cancel\\n   * @param data The data to return to the consuming contract\\n   * @return Status if the external call was successful\\n   */\\n  function fulfillOracleRequest2(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes calldata data\\n  )\\n    external\\n    override\\n    validateAuthorizedSender\\n    validateRequestId(requestId)\\n    validateCallbackAddress(callbackAddress)\\n    validateMultiWordResponseId(requestId, data)\\n    returns (bool)\\n  {\\n    _verifyOracleRequestAndProcessPayment(requestId, payment, callbackAddress, callbackFunctionId, expiration, 2);\\n    emit OracleResponse(requestId);\\n    require(gasleft() >= MINIMUM_CONSUMER_GAS_LIMIT, \\\"Must provide consumer enough gas\\\");\\n    // All updates to the oracle's fulfillment should come before calling the\\n    // callback(addr+functionId) as it is untrusted.\\n    // See: https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern\\n    (bool success, ) = callbackAddress.call(abi.encodePacked(callbackFunctionId, data)); // solhint-disable-line avoid-low-level-calls\\n    return success;\\n  }\\n\\n  /**\\n   * @notice Transfer the ownership of ownable contracts. This is primarilly\\n   * intended for Authorized Forwarders but could possibly be extended to work\\n   * with future contracts.\\n   * @param ownable list of addresses to transfer\\n   * @param newOwner address to transfer ownership to\\n   */\\n  function transferOwnableContracts(address[] calldata ownable, address newOwner) external onlyOwner {\\n    for (uint256 i = 0; i < ownable.length; i++) {\\n      s_owned[ownable[i]] = false;\\n      OwnableInterface(ownable[i]).transferOwnership(newOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Accept the ownership of an ownable contract. This is primarilly\\n   * intended for Authorized Forwarders but could possibly be extended to work\\n   * with future contracts.\\n   * @dev Must be the pending owner on the contract\\n   * @param ownable list of addresses of Ownable contracts to accept\\n   */\\n  function acceptOwnableContracts(address[] calldata ownable) public validateAuthorizedSenderSetter {\\n    for (uint256 i = 0; i < ownable.length; i++) {\\n      s_owned[ownable[i]] = true;\\n      emit OwnableContractAccepted(ownable[i]);\\n      OwnableInterface(ownable[i]).acceptOwnership();\\n    }\\n  }\\n\\n  /**\\n   * @notice Sets the fulfillment permission for\\n   * @param targets The addresses to set permissions on\\n   * @param senders The addresses that are allowed to send updates\\n   */\\n  function setAuthorizedSendersOn(address[] calldata targets, address[] calldata senders)\\n    public\\n    validateAuthorizedSenderSetter\\n  {\\n    TargetsUpdatedAuthorizedSenders(targets, senders, msg.sender);\\n\\n    for (uint256 i = 0; i < targets.length; i++) {\\n      AuthorizedReceiverInterface(targets[i]).setAuthorizedSenders(senders);\\n    }\\n  }\\n\\n  /**\\n   * @notice Accepts ownership of ownable contracts and then immediately sets\\n   * the authorized sender list on each of the newly owned contracts. This is\\n   * primarilly intended for Authorized Forwarders but could possibly be\\n   * extended to work with future contracts.\\n   * @param targets The addresses to set permissions on\\n   * @param senders The addresses that are allowed to send updates\\n   */\\n  function acceptAuthorizedReceivers(address[] calldata targets, address[] calldata senders)\\n    external\\n    validateAuthorizedSenderSetter\\n  {\\n    acceptOwnableContracts(targets);\\n    setAuthorizedSendersOn(targets, senders);\\n  }\\n\\n  /**\\n   * @notice Allows the node operator to withdraw earned LINK to a given address\\n   * @dev The owner of the contract can be another wallet and does not have to be a Chainlink node\\n   * @param recipient The address to send the LINK token to\\n   * @param amount The amount to send (specified in wei)\\n   */\\n  function withdraw(address recipient, uint256 amount)\\n    external\\n    override(OracleInterface, WithdrawalInterface)\\n    onlyOwner\\n    validateAvailableFunds(amount)\\n  {\\n    assert(linkToken.transfer(recipient, amount));\\n  }\\n\\n  /**\\n   * @notice Displays the amount of LINK that is available for the node operator to withdraw\\n   * @dev We use `ONE_FOR_CONSISTENT_GAS_COST` in place of 0 in storage\\n   * @return The amount of withdrawable LINK on the contract\\n   */\\n  function withdrawable() external view override(OracleInterface, WithdrawalInterface) returns (uint256) {\\n    return _fundsAvailable();\\n  }\\n\\n  /**\\n   * @notice Forward a call to another contract\\n   * @dev Only callable by the owner\\n   * @param to address\\n   * @param data to forward\\n   */\\n  function ownerForward(address to, bytes calldata data) external onlyOwner validateNotToLINK(to) {\\n    require(to.isContract(), \\\"Must forward to a contract\\\");\\n    (bool status, ) = to.call(data);\\n    require(status, \\\"Forwarded call failed\\\");\\n  }\\n\\n  /**\\n   * @notice Interact with other LinkTokenReceiver contracts by calling transferAndCall\\n   * @param to The address to transfer to.\\n   * @param value The amount to be transferred.\\n   * @param data The extra data to be passed to the receiving contract.\\n   * @return success bool\\n   */\\n  function ownerTransferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external override onlyOwner validateAvailableFunds(value) returns (bool success) {\\n    return linkToken.transferAndCall(to, value, data);\\n  }\\n\\n  /**\\n   * @notice Distribute funds to multiple addresses using ETH send\\n   * to this payable function.\\n   * @dev Array length must be equal, ETH sent must equal the sum of amounts.\\n   * A malicious receiver could cause the distribution to revert, in which case\\n   * it is expected that the address is removed from the list.\\n   * @param receivers list of addresses\\n   * @param amounts list of amounts\\n   */\\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable {\\n    require(receivers.length > 0 && receivers.length == amounts.length, \\\"Invalid array length(s)\\\");\\n    uint256 valueRemaining = msg.value;\\n    for (uint256 i = 0; i < receivers.length; i++) {\\n      uint256 sendAmount = amounts[i];\\n      valueRemaining = valueRemaining.sub(sendAmount);\\n      receivers[i].transfer(sendAmount);\\n    }\\n    require(valueRemaining == 0, \\\"Too much ETH sent\\\");\\n  }\\n\\n  /**\\n   * @notice Allows recipient to cancel requests sent to this oracle contract.\\n   * Will transfer the LINK sent for the request back to the recipient address.\\n   * @dev Given params must hash to a commitment stored on the contract in order\\n   * for the request to be valid. Emits CancelOracleRequest event.\\n   * @param requestId The request ID\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param callbackFunc The requester's specified callback function selector\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  ) external override {\\n    bytes31 paramsHash = _buildParamsHash(payment, msg.sender, callbackFunc, expiration);\\n    require(s_commitments[requestId].paramsHash == paramsHash, \\\"Params do not match request ID\\\");\\n    // solhint-disable-next-line not-rely-on-time\\n    require(expiration <= block.timestamp, \\\"Request is not expired\\\");\\n\\n    delete s_commitments[requestId];\\n    emit CancelOracleRequest(requestId);\\n\\n    linkToken.transfer(msg.sender, payment);\\n  }\\n\\n  /**\\n   * @notice Allows requester to cancel requests sent to this oracle contract.\\n   * Will transfer the LINK sent for the request back to the recipient address.\\n   * @dev Given params must hash to a commitment stored on the contract in order\\n   * for the request to be valid. Emits CancelOracleRequest event.\\n   * @param nonce The nonce used to generate the request ID\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param callbackFunc The requester's specified callback function selector\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelOracleRequestByRequester(\\n    uint256 nonce,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  ) external {\\n    bytes32 requestId = keccak256(abi.encodePacked(msg.sender, nonce));\\n    bytes31 paramsHash = _buildParamsHash(payment, msg.sender, callbackFunc, expiration);\\n    require(s_commitments[requestId].paramsHash == paramsHash, \\\"Params do not match request ID\\\");\\n    // solhint-disable-next-line not-rely-on-time\\n    require(expiration <= block.timestamp, \\\"Request is not expired\\\");\\n\\n    delete s_commitments[requestId];\\n    emit CancelOracleRequest(requestId);\\n\\n    linkToken.transfer(msg.sender, payment);\\n  }\\n\\n  /**\\n   * @notice Returns the address of the LINK token\\n   * @dev This is the public implementation for chainlinkTokenAddress, which is\\n   * an internal method of the ChainlinkClient contract\\n   */\\n  function getChainlinkToken() public view override returns (address) {\\n    return address(linkToken);\\n  }\\n\\n  /**\\n   * @notice Require that the token transfer action is valid\\n   * @dev OPERATOR_REQUEST_SELECTOR = multiword, ORACLE_REQUEST_SELECTOR = singleword\\n   */\\n  function _validateTokenTransferAction(bytes4 funcSelector, bytes memory data) internal pure override {\\n    require(data.length >= MINIMUM_REQUEST_LENGTH, \\\"Invalid request length\\\");\\n    require(\\n      funcSelector == OPERATOR_REQUEST_SELECTOR || funcSelector == ORACLE_REQUEST_SELECTOR,\\n      \\\"Must use whitelisted functions\\\"\\n    );\\n  }\\n\\n  /**\\n   * @notice Verify the Oracle Request and record necessary information\\n   * @param sender The sender of the request\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param callbackAddress The callback address for the response\\n   * @param callbackFunctionId The callback function ID for the response\\n   * @param nonce The nonce sent by the requester\\n   */\\n  function _verifyAndProcessOracleRequest(\\n    address sender,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion\\n  ) private validateNotToLINK(callbackAddress) returns (bytes32 requestId, uint256 expiration) {\\n    requestId = keccak256(abi.encodePacked(sender, nonce));\\n    require(s_commitments[requestId].paramsHash == 0, \\\"Must use a unique ID\\\");\\n    // solhint-disable-next-line not-rely-on-time\\n    expiration = block.timestamp.add(getExpiryTime);\\n    bytes31 paramsHash = _buildParamsHash(payment, callbackAddress, callbackFunctionId, expiration);\\n    s_commitments[requestId] = Commitment(paramsHash, _safeCastToUint8(dataVersion));\\n    s_tokensInEscrow = s_tokensInEscrow.add(payment);\\n    return (requestId, expiration);\\n  }\\n\\n  /**\\n   * @notice Verify the Oracle request and unlock escrowed payment\\n   * @param requestId The fulfillment request ID that must match the requester's\\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\\n   * @param callbackAddress The callback address to call for fulfillment\\n   * @param callbackFunctionId The callback function ID to use for fulfillment\\n   * @param expiration The expiration that the node should respond by before the requester can cancel\\n   */\\n  function _verifyOracleRequestAndProcessPayment(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    uint256 dataVersion\\n  ) internal {\\n    bytes31 paramsHash = _buildParamsHash(payment, callbackAddress, callbackFunctionId, expiration);\\n    require(s_commitments[requestId].paramsHash == paramsHash, \\\"Params do not match request ID\\\");\\n    require(s_commitments[requestId].dataVersion <= _safeCastToUint8(dataVersion), \\\"Data versions must match\\\");\\n    s_tokensInEscrow = s_tokensInEscrow.sub(payment);\\n    delete s_commitments[requestId];\\n  }\\n\\n  /**\\n   * @notice Build the bytes31 hash from the payment, callback and expiration.\\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\\n   * @param callbackAddress The callback address to call for fulfillment\\n   * @param callbackFunctionId The callback function ID to use for fulfillment\\n   * @param expiration The expiration that the node should respond by before the requester can cancel\\n   * @return hash bytes31\\n   */\\n  function _buildParamsHash(\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration\\n  ) internal pure returns (bytes31) {\\n    return bytes31(keccak256(abi.encodePacked(payment, callbackAddress, callbackFunctionId, expiration)));\\n  }\\n\\n  /**\\n   * @notice Safely cast uint256 to uint8\\n   * @param number uint256\\n   * @return uint8 number\\n   */\\n  function _safeCastToUint8(uint256 number) internal pure returns (uint8) {\\n    require(number < MAXIMUM_DATA_VERSION, \\\"number too big to cast\\\");\\n    return uint8(number);\\n  }\\n\\n  /**\\n   * @notice Returns the LINK available in this contract, not locked in escrow\\n   * @return uint256 LINK tokens available\\n   */\\n  function _fundsAvailable() private view returns (uint256) {\\n    uint256 inEscrow = s_tokensInEscrow.sub(ONE_FOR_CONSISTENT_GAS_COST);\\n    return linkToken.balanceOf(address(this)).sub(inEscrow);\\n  }\\n\\n  /**\\n   * @notice concrete implementation of AuthorizedReceiver\\n   * @return bool of whether sender is authorized\\n   */\\n  function _canSetAuthorizedSenders() internal view override returns (bool) {\\n    return isAuthorizedSender(msg.sender) || owner() == msg.sender;\\n  }\\n\\n  // MODIFIERS\\n\\n  /**\\n   * @dev Reverts if the first 32 bytes of the bytes array is not equal to requestId\\n   * @param requestId bytes32\\n   * @param data bytes\\n   */\\n  modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata data) {\\n    require(data.length >= 32, \\\"Response must be > 32 bytes\\\");\\n    bytes32 firstDataWord;\\n    assembly {\\n      // extract the first word from data\\n      // functionSelector = 4\\n      // wordLength = 32\\n      // dataArgumentOffset = 7 * wordLength\\n      // funcSelector + dataArgumentOffset == 0xe4\\n      firstDataWord := calldataload(0xe4)\\n    }\\n    require(requestId == firstDataWord, \\\"First word must be requestId\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if amount requested is greater than withdrawable balance\\n   * @param amount The given amount to compare to `s_withdrawableTokens`\\n   */\\n  modifier validateAvailableFunds(uint256 amount) {\\n    require(_fundsAvailable() >= amount, \\\"Amount requested is greater than withdrawable balance\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if request ID does not exist\\n   * @param requestId The given request ID to check in stored `commitments`\\n   */\\n  modifier validateRequestId(bytes32 requestId) {\\n    require(s_commitments[requestId].paramsHash != 0, \\\"Must have a valid requestId\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the callback address is the LINK token\\n   * @param to The callback address\\n   */\\n  modifier validateNotToLINK(address to) {\\n    require(to != address(linkToken), \\\"Cannot call to LINK\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the target address is owned by the operator\\n   */\\n  modifier validateCallbackAddress(address callbackAddress) {\\n    require(!s_owned[callbackAddress], \\\"Cannot call owned contract\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/LinkTokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nabstract contract LinkTokenReceiver {\\n  /**\\n   * @notice Called when LINK is sent to the contract via `transferAndCall`\\n   * @dev The data payload's first 2 words will be overwritten by the `sender` and `amount`\\n   * values to ensure correctness. Calls oracleRequest.\\n   * @param sender Address of the sender\\n   * @param amount Amount of LINK sent (specified in wei)\\n   * @param data Payload of the transaction\\n   */\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes memory data\\n  ) public validateFromLINK permittedFunctionsForLINK(data) {\\n    assembly {\\n      // solhint-disable-next-line avoid-low-level-calls\\n      mstore(add(data, 36), sender) // ensure correct sender is passed\\n      // solhint-disable-next-line avoid-low-level-calls\\n      mstore(add(data, 68), amount) // ensure correct amount is passed\\n    }\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, ) = address(this).delegatecall(data); // calls oracleRequest\\n    require(success, \\\"Unable to create request\\\");\\n  }\\n\\n  function getChainlinkToken() public view virtual returns (address);\\n\\n  /**\\n   * @notice Validate the function called on token transfer\\n   */\\n  function _validateTokenTransferAction(bytes4 funcSelector, bytes memory data) internal virtual;\\n\\n  /**\\n   * @dev Reverts if not sent from the LINK token\\n   */\\n  modifier validateFromLINK() {\\n    require(msg.sender == getChainlinkToken(), \\\"Must use LINK token\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the given data does not begin with the `oracleRequest` function selector\\n   * @param data The data payload of the request\\n   */\\n  modifier permittedFunctionsForLINK(bytes memory data) {\\n    bytes4 funcSelector;\\n    assembly {\\n      // solhint-disable-next-line avoid-low-level-calls\\n      funcSelector := mload(add(data, 32))\\n    }\\n    _validateTokenTransferAction(funcSelector, data);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/WithdrawalInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface WithdrawalInterface {\\n  /**\\n   * @notice transfer LINK held by the contract belonging to msg.sender to\\n   * another address\\n   * @param recipient is the address to send the LINK to\\n   * @param amount is the amount of LINK to send\\n   */\\n  function withdraw(address recipient, uint256 amount) external;\\n\\n  /**\\n   * @notice query the available amount of LINK to withdraw by msg.sender\\n   */\\n  function withdrawable() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/SafeMathChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathChainlink {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/VRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./vendor/SafeMathChainlink.sol\\\";\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\n\\nimport \\\"./VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n  using SafeMathChainlink for uint256;\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\\n\\n  /**\\n   * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\\n\\n  /**\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n    // the hash of the block containing this request to obtain the seed/input\\n    // which is finally passed to the VRF cryptographic machinery.\\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n    // nonces[_keyHash] must stay in sync with\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n    // This provides protection against the user repeating their input seed,\\n    // which would result in a predictable/duplicate output, if multiple such\\n    // requests appeared in the same block.\\n    nonces[_keyHash] = nonces[_keyHash].add(1);\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface internal immutable LINK;\\n  address private immutable vrfCoordinator;\\n\\n  // Nonces for each VRF key from which randomness has been requested.\\n  //\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\\n    private nonces;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n  constructor(address _vrfCoordinator, address _link) {\\n    vrfCoordinator = _vrfCoordinator;\\n    LINK = LinkTokenInterface(_link);\\n  }\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/VRFRequestIDBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ncontract VRFRequestIDBase {\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  ) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/UpkeepRegistrationRequests.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/KeeperRegistryInterface.sol\\\";\\nimport \\\"./vendor/SafeMath96.sol\\\";\\nimport \\\"./ConfirmedOwner.sol\\\";\\n\\n/**\\n * @notice Contract to accept requests for upkeep registrations\\n * @dev There are 2 registration workflows in this contract\\n * Flow 1. auto approve OFF / manual registration - UI calls `register` function on this contract, this contract owner at a later time then manually\\n *  calls `approve` to register upkeep and emit events to inform UI and others interested.\\n * Flow 2. auto approve ON / real time registration - UI calls `register` function as before, which calls the `registerUpkeep` function directly on\\n *  keeper registry and then emits approved event to finish the flow automatically without manual intervention.\\n * The idea is to have same interface(functions,events) for UI or anyone using this contract irrespective of auto approve being enabled or not.\\n * they can just listen to `RegistrationRequested` & `RegistrationApproved` events and know the status on registrations.\\n */\\ncontract UpkeepRegistrationRequests is ConfirmedOwner {\\n  using SafeMath96 for uint96;\\n\\n  bytes4 private constant REGISTER_REQUEST_SELECTOR = this.register.selector;\\n\\n  uint256 private s_minLINKJuels;\\n  mapping(bytes32 => PendingRequest) private s_pendingRequests;\\n\\n  LinkTokenInterface public immutable LINK;\\n\\n  struct AutoApprovedConfig {\\n    bool enabled;\\n    uint16 allowedPerWindow;\\n    uint32 windowSizeInBlocks;\\n    uint64 windowStart;\\n    uint16 approvedInCurrentWindow;\\n  }\\n\\n  struct PendingRequest {\\n    address admin;\\n    uint96 balance;\\n  }\\n\\n  AutoApprovedConfig private s_config;\\n  KeeperRegistryBaseInterface private s_keeperRegistry;\\n\\n  event RegistrationRequested(\\n    bytes32 indexed hash,\\n    string name,\\n    bytes encryptedEmail,\\n    address indexed upkeepContract,\\n    uint32 gasLimit,\\n    address adminAddress,\\n    bytes checkData,\\n    uint96 amount,\\n    uint8 indexed source\\n  );\\n\\n  event RegistrationApproved(bytes32 indexed hash, string displayName, uint256 indexed upkeepId);\\n\\n  event RegistrationRejected(bytes32 indexed hash);\\n\\n  event ConfigChanged(\\n    bool enabled,\\n    uint32 windowSizeInBlocks,\\n    uint16 allowedPerWindow,\\n    address keeperRegistry,\\n    uint256 minLINKJuels\\n  );\\n\\n  constructor(address LINKAddress, uint256 minimumLINKJuels) ConfirmedOwner(msg.sender) {\\n    LINK = LinkTokenInterface(LINKAddress);\\n    s_minLINKJuels = minimumLINKJuels;\\n  }\\n\\n  //EXTERNAL\\n\\n  /**\\n   * @notice register can only be called through transferAndCall on LINK contract\\n   * @param name string of the upkeep to be registered\\n   * @param encryptedEmail email address of upkeep contact\\n   * @param upkeepContract address to peform upkeep on\\n   * @param gasLimit amount of gas to provide the target contract when performing upkeep\\n   * @param adminAddress address to cancel upkeep and withdraw remaining funds\\n   * @param checkData data passed to the contract when checking for upkeep\\n   * @param amount quantity of LINK upkeep is funded with (specified in Juels)\\n   * @param source application sending this request\\n   */\\n  function register(\\n    string memory name,\\n    bytes calldata encryptedEmail,\\n    address upkeepContract,\\n    uint32 gasLimit,\\n    address adminAddress,\\n    bytes calldata checkData,\\n    uint96 amount,\\n    uint8 source\\n  ) external onlyLINK {\\n    require(adminAddress != address(0), \\\"invalid admin address\\\");\\n    bytes32 hash = keccak256(abi.encode(upkeepContract, gasLimit, adminAddress, checkData));\\n\\n    emit RegistrationRequested(\\n      hash,\\n      name,\\n      encryptedEmail,\\n      upkeepContract,\\n      gasLimit,\\n      adminAddress,\\n      checkData,\\n      amount,\\n      source\\n    );\\n\\n    AutoApprovedConfig memory config = s_config;\\n    if (config.enabled && _underApprovalLimit(config)) {\\n      _incrementApprovedCount(config);\\n\\n      _approve(name, upkeepContract, gasLimit, adminAddress, checkData, amount, hash);\\n    } else {\\n      uint96 newBalance = s_pendingRequests[hash].balance.add(amount);\\n      s_pendingRequests[hash] = PendingRequest({admin: adminAddress, balance: newBalance});\\n    }\\n  }\\n\\n  /**\\n   * @dev register upkeep on KeeperRegistry contract and emit RegistrationApproved event\\n   */\\n  function approve(\\n    string memory name,\\n    address upkeepContract,\\n    uint32 gasLimit,\\n    address adminAddress,\\n    bytes calldata checkData,\\n    bytes32 hash\\n  ) external onlyOwner {\\n    PendingRequest memory request = s_pendingRequests[hash];\\n    require(request.admin != address(0), \\\"request not found\\\");\\n    bytes32 expectedHash = keccak256(abi.encode(upkeepContract, gasLimit, adminAddress, checkData));\\n    require(hash == expectedHash, \\\"hash and payload do not match\\\");\\n    delete s_pendingRequests[hash];\\n    _approve(name, upkeepContract, gasLimit, adminAddress, checkData, request.balance, hash);\\n  }\\n\\n  /**\\n   * @notice cancel will remove a registration request and return the refunds to the msg.sender\\n   * @param hash the request hash\\n   */\\n  function cancel(bytes32 hash) external {\\n    PendingRequest memory request = s_pendingRequests[hash];\\n    require(msg.sender == request.admin || msg.sender == owner(), \\\"only admin / owner can cancel\\\");\\n    require(request.admin != address(0), \\\"request not found\\\");\\n    delete s_pendingRequests[hash];\\n    require(LINK.transfer(msg.sender, request.balance), \\\"LINK token transfer failed\\\");\\n    emit RegistrationRejected(hash);\\n  }\\n\\n  /**\\n   * @notice owner calls this function to set if registration requests should be sent directly to the Keeper Registry\\n   * @param enabled setting for autoapprove registrations\\n   * @param windowSizeInBlocks window size defined in number of blocks\\n   * @param allowedPerWindow number of registrations that can be auto approved in above window\\n   * @param keeperRegistry new keeper registry address\\n   */\\n  function setRegistrationConfig(\\n    bool enabled,\\n    uint32 windowSizeInBlocks,\\n    uint16 allowedPerWindow,\\n    address keeperRegistry,\\n    uint256 minLINKJuels\\n  ) external onlyOwner {\\n    s_config = AutoApprovedConfig({\\n      enabled: enabled,\\n      allowedPerWindow: allowedPerWindow,\\n      windowSizeInBlocks: windowSizeInBlocks,\\n      windowStart: 0,\\n      approvedInCurrentWindow: 0\\n    });\\n    s_minLINKJuels = minLINKJuels;\\n    s_keeperRegistry = KeeperRegistryBaseInterface(keeperRegistry);\\n\\n    emit ConfigChanged(enabled, windowSizeInBlocks, allowedPerWindow, keeperRegistry, minLINKJuels);\\n  }\\n\\n  /**\\n   * @notice read the current registration configuration\\n   */\\n  function getRegistrationConfig()\\n    external\\n    view\\n    returns (\\n      bool enabled,\\n      uint32 windowSizeInBlocks,\\n      uint16 allowedPerWindow,\\n      address keeperRegistry,\\n      uint256 minLINKJuels,\\n      uint64 windowStart,\\n      uint16 approvedInCurrentWindow\\n    )\\n  {\\n    AutoApprovedConfig memory config = s_config;\\n    return (\\n      config.enabled,\\n      config.windowSizeInBlocks,\\n      config.allowedPerWindow,\\n      address(s_keeperRegistry),\\n      s_minLINKJuels,\\n      config.windowStart,\\n      config.approvedInCurrentWindow\\n    );\\n  }\\n\\n  /**\\n   * @notice gets the admin address and the current balance of a registration request\\n   */\\n  function getPendingRequest(bytes32 hash) external view returns (address, uint96) {\\n    PendingRequest memory request = s_pendingRequests[hash];\\n    return (request.admin, request.balance);\\n  }\\n\\n  /**\\n   * @notice Called when LINK is sent to the contract via `transferAndCall`\\n   * @param amount Amount of LINK sent (specified in Juels)\\n   * @param data Payload of the transaction\\n   */\\n  function onTokenTransfer(\\n    address, /* sender */\\n    uint256 amount,\\n    bytes calldata data\\n  ) external onlyLINK permittedFunctionsForLINK(data) isActualAmount(amount, data) {\\n    require(amount >= s_minLINKJuels, \\\"Insufficient payment\\\");\\n    (bool success, ) = address(this).delegatecall(data);\\n    // calls register\\n    require(success, \\\"Unable to create request\\\");\\n  }\\n\\n  //PRIVATE\\n\\n  /**\\n   * @dev reset auto approve window if passed end of current window\\n   */\\n  function _resetWindowIfRequired(AutoApprovedConfig memory config) private {\\n    uint64 blocksPassed = uint64(block.number - config.windowStart);\\n    if (blocksPassed >= config.windowSizeInBlocks) {\\n      config.windowStart = uint64(block.number);\\n      config.approvedInCurrentWindow = 0;\\n      s_config = config;\\n    }\\n  }\\n\\n  /**\\n   * @dev register upkeep on KeeperRegistry contract and emit RegistrationApproved event\\n   */\\n  function _approve(\\n    string memory name,\\n    address upkeepContract,\\n    uint32 gasLimit,\\n    address adminAddress,\\n    bytes calldata checkData,\\n    uint96 amount,\\n    bytes32 hash\\n  ) private {\\n    KeeperRegistryBaseInterface keeperRegistry = s_keeperRegistry;\\n\\n    // register upkeep\\n    uint256 upkeepId = keeperRegistry.registerUpkeep(upkeepContract, gasLimit, adminAddress, checkData);\\n    // fund upkeep\\n    bool success = LINK.transferAndCall(address(keeperRegistry), amount, abi.encode(upkeepId));\\n    require(success, \\\"failed to fund upkeep\\\");\\n\\n    emit RegistrationApproved(hash, name, upkeepId);\\n  }\\n\\n  /**\\n   * @dev determine approval limits and check if in range\\n   */\\n  function _underApprovalLimit(AutoApprovedConfig memory config) private returns (bool) {\\n    _resetWindowIfRequired(config);\\n    if (config.approvedInCurrentWindow < config.allowedPerWindow) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @dev record new latest approved count\\n   */\\n  function _incrementApprovedCount(AutoApprovedConfig memory config) private {\\n    config.approvedInCurrentWindow++;\\n    s_config = config;\\n  }\\n\\n  //MODIFIERS\\n\\n  /**\\n   * @dev Reverts if not sent from the LINK token\\n   */\\n  modifier onlyLINK() {\\n    require(msg.sender == address(LINK), \\\"Must use LINK token\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the given data does not begin with the `register` function selector\\n   * @param _data The data payload of the request\\n   */\\n  modifier permittedFunctionsForLINK(bytes memory _data) {\\n    bytes4 funcSelector;\\n    assembly {\\n      // solhint-disable-next-line avoid-low-level-calls\\n      funcSelector := mload(add(_data, 32))\\n    }\\n    require(funcSelector == REGISTER_REQUEST_SELECTOR, \\\"Must use whitelisted functions\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the actual amount passed does not match the expected amount\\n   * @param expected amount that should match the actual amount\\n   * @param data bytes\\n   */\\n  modifier isActualAmount(uint256 expected, bytes memory data) {\\n    uint256 actual;\\n    assembly {\\n      actual := mload(add(data, 228))\\n    }\\n    require(expected == actual, \\\"Amount mismatch\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/KeeperRegistryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\ninterface KeeperRegistryBaseInterface {\\n  function registerUpkeep(\\n    address target,\\n    uint32 gasLimit,\\n    address admin,\\n    bytes calldata checkData\\n  ) external returns (uint256 id);\\n\\n  function performUpkeep(uint256 id, bytes calldata performData) external returns (bool success);\\n\\n  function cancelUpkeep(uint256 id) external;\\n\\n  function addFunds(uint256 id, uint96 amount) external;\\n\\n  function getUpkeep(uint256 id)\\n    external\\n    view\\n    returns (\\n      address target,\\n      uint32 executeGas,\\n      bytes memory checkData,\\n      uint96 balance,\\n      address lastKeeper,\\n      address admin,\\n      uint64 maxValidBlocknumber\\n    );\\n\\n  function getUpkeepCount() external view returns (uint256);\\n\\n  function getCanceledUpkeepList() external view returns (uint256[] memory);\\n\\n  function getKeeperList() external view returns (address[] memory);\\n\\n  function getKeeperInfo(address query)\\n    external\\n    view\\n    returns (\\n      address payee,\\n      bool active,\\n      uint96 balance\\n    );\\n\\n  function getConfig()\\n    external\\n    view\\n    returns (\\n      uint32 paymentPremiumPPB,\\n      uint24 checkFrequencyBlocks,\\n      uint32 checkGasLimit,\\n      uint24 stalenessSeconds,\\n      uint16 gasCeilingMultiplier,\\n      uint256 fallbackGasPrice,\\n      uint256 fallbackLinkPrice\\n    );\\n}\\n\\n/**\\n * @dev The view methods are not actually marked as view in the implementation\\n * but we want them to be easily queried off-chain. Solidity will not compile\\n * if we actually inherrit from this interface, so we document it here.\\n */\\ninterface KeeperRegistryInterface is KeeperRegistryBaseInterface {\\n  function checkUpkeep(uint256 upkeepId, address from)\\n    external\\n    view\\n    returns (\\n      bytes memory performData,\\n      uint256 maxLinkPayment,\\n      uint256 gasLimit,\\n      int256 gasWei,\\n      int256 linkEth\\n    );\\n}\\n\\ninterface KeeperRegistryExecutableInterface is KeeperRegistryBaseInterface {\\n  function checkUpkeep(uint256 upkeepId, address from)\\n    external\\n    returns (\\n      bytes memory performData,\\n      uint256 maxLinkPayment,\\n      uint256 gasLimit,\\n      uint256 adjustedGasWei,\\n      uint256 linkEth\\n    );\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/SafeMath96.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * This library is a version of Open Zeppelin's SafeMath, modified to support\\n * unsigned 96 bit integers.\\n */\\nlibrary SafeMath96 {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint96 a, uint96 b) internal pure returns (uint96) {\\n    uint96 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint96 a, uint96 b) internal pure returns (uint96) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    uint96 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint96 a, uint96 b) internal pure returns (uint96) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint96 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint96 a, uint96 b) internal pure returns (uint96) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    uint96 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint96 a, uint96 b) internal pure returns (uint96) {\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/tests/ConfirmedOwnerTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ConfirmedOwner.sol\\\";\\n\\ncontract ConfirmedOwnerTestHelper is ConfirmedOwner {\\n  event Here();\\n\\n  constructor() ConfirmedOwner(msg.sender) {}\\n\\n  function modifierOnlyOwner() public onlyOwner {\\n    emit Here();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/KeeperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/KeeperCompatibleInterface.sol\\\";\\nimport \\\"./interfaces/KeeperRegistryInterface.sol\\\";\\nimport \\\"./interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"./vendor/SafeMathChainlink.sol\\\";\\nimport \\\"./vendor/Address.sol\\\";\\nimport \\\"./vendor/Pausable.sol\\\";\\nimport \\\"./vendor/ReentrancyGuard.sol\\\";\\nimport \\\"./vendor/SignedSafeMath.sol\\\";\\nimport \\\"./vendor/SafeMath96.sol\\\";\\nimport \\\"./KeeperBase.sol\\\";\\nimport \\\"./ConfirmedOwner.sol\\\";\\n\\n/**\\n * @notice Registry for adding work for Chainlink Keepers to perform on client\\n * contracts. Clients must support the Upkeep interface.\\n */\\ncontract KeeperRegistry is\\n  TypeAndVersionInterface,\\n  ConfirmedOwner,\\n  KeeperBase,\\n  ReentrancyGuard,\\n  Pausable,\\n  KeeperRegistryExecutableInterface\\n{\\n  using Address for address;\\n  using SafeMathChainlink for uint256;\\n  using SafeMath96 for uint96;\\n  using SignedSafeMath for int256;\\n\\n  address private constant ZERO_ADDRESS = address(0);\\n  address private constant IGNORE_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\\n  bytes4 private constant CHECK_SELECTOR = KeeperCompatibleInterface.checkUpkeep.selector;\\n  bytes4 private constant PERFORM_SELECTOR = KeeperCompatibleInterface.performUpkeep.selector;\\n  uint256 private constant CALL_GAS_MAX = 5_000_000;\\n  uint256 private constant CALL_GAS_MIN = 2_300;\\n  uint256 private constant CANCELATION_DELAY = 50;\\n  uint256 private constant CUSHION = 5_000;\\n  uint256 private constant REGISTRY_GAS_OVERHEAD = 80_000;\\n  uint256 private constant PPB_BASE = 1_000_000_000;\\n  uint64 private constant UINT64_MAX = 2**64 - 1;\\n  uint96 private constant LINK_TOTAL_SUPPLY = 1e27;\\n\\n  uint256 private s_upkeepCount;\\n  uint256[] private s_canceledUpkeepList;\\n  address[] private s_keeperList;\\n  mapping(uint256 => Upkeep) private s_upkeep;\\n  mapping(address => KeeperInfo) private s_keeperInfo;\\n  mapping(address => address) private s_proposedPayee;\\n  mapping(uint256 => bytes) private s_checkData;\\n  Config private s_config;\\n  uint256 private s_fallbackGasPrice; // not in config object for gas savings\\n  uint256 private s_fallbackLinkPrice; // not in config object for gas savings\\n  uint256 private s_expectedLinkBalance;\\n\\n  LinkTokenInterface public immutable LINK;\\n  AggregatorV3Interface public immutable LINK_ETH_FEED;\\n  AggregatorV3Interface public immutable FAST_GAS_FEED;\\n\\n  address private s_registrar;\\n\\n  /**\\n   * @notice versions:\\n   * - KeeperRegistry 1.1.0: added flatFeeMicroLink\\n   * - KeeperRegistry 1.0.0: initial release\\n   */\\n  string public constant override typeAndVersion = \\\"KeeperRegistry 1.1.0\\\";\\n\\n  struct Upkeep {\\n    address target;\\n    uint32 executeGas;\\n    uint96 balance;\\n    address admin;\\n    uint64 maxValidBlocknumber;\\n    address lastKeeper;\\n  }\\n\\n  struct KeeperInfo {\\n    address payee;\\n    uint96 balance;\\n    bool active;\\n  }\\n\\n  struct Config {\\n    uint32 paymentPremiumPPB;\\n    uint32 flatFeeMicroLink; // min 0.000001 LINK, max 4294 LINK\\n    uint24 blockCountPerTurn;\\n    uint32 checkGasLimit;\\n    uint24 stalenessSeconds;\\n    uint16 gasCeilingMultiplier;\\n  }\\n\\n  struct PerformParams {\\n    address from;\\n    uint256 id;\\n    bytes performData;\\n    uint256 maxLinkPayment;\\n    uint256 gasLimit;\\n    uint256 adjustedGasWei;\\n    uint256 linkEth;\\n  }\\n\\n  event UpkeepRegistered(uint256 indexed id, uint32 executeGas, address admin);\\n  event UpkeepPerformed(\\n    uint256 indexed id,\\n    bool indexed success,\\n    address indexed from,\\n    uint96 payment,\\n    bytes performData\\n  );\\n  event UpkeepCanceled(uint256 indexed id, uint64 indexed atBlockHeight);\\n  event FundsAdded(uint256 indexed id, address indexed from, uint96 amount);\\n  event FundsWithdrawn(uint256 indexed id, uint256 amount, address to);\\n  event ConfigSet(\\n    uint32 paymentPremiumPPB,\\n    uint24 blockCountPerTurn,\\n    uint32 checkGasLimit,\\n    uint24 stalenessSeconds,\\n    uint16 gasCeilingMultiplier,\\n    uint256 fallbackGasPrice,\\n    uint256 fallbackLinkPrice\\n  );\\n  event FlatFeeSet(uint32 flatFeeMicroLink);\\n  event KeepersUpdated(address[] keepers, address[] payees);\\n  event PaymentWithdrawn(address indexed keeper, uint256 indexed amount, address indexed to, address payee);\\n  event PayeeshipTransferRequested(address indexed keeper, address indexed from, address indexed to);\\n  event PayeeshipTransferred(address indexed keeper, address indexed from, address indexed to);\\n  event RegistrarChanged(address indexed from, address indexed to);\\n\\n  /**\\n   * @param link address of the LINK Token\\n   * @param linkEthFeed address of the LINK/ETH price feed\\n   * @param fastGasFeed address of the Fast Gas price feed\\n   * @param paymentPremiumPPB payment premium rate oracles receive on top of\\n   * being reimbursed for gas, measured in parts per billion\\n   * @param flatFeeMicroLink flat fee paid to oracles for performing upkeeps,\\n   * priced in MicroLink; can be used in conjunction with or independently of\\n   * paymentPremiumPPB\\n   * @param blockCountPerTurn number of blocks each oracle has during their turn to\\n   * perform upkeep before it will be the next keeper's turn to submit\\n   * @param checkGasLimit gas limit when checking for upkeep\\n   * @param stalenessSeconds number of seconds that is allowed for feed data to\\n   * be stale before switching to the fallback pricing\\n   * @param gasCeilingMultiplier multiplier to apply to the fast gas feed price\\n   * when calculating the payment ceiling for keepers\\n   * @param fallbackGasPrice gas price used if the gas price feed is stale\\n   * @param fallbackLinkPrice LINK price used if the LINK price feed is stale\\n   */\\n  constructor(\\n    address link,\\n    address linkEthFeed,\\n    address fastGasFeed,\\n    uint32 paymentPremiumPPB,\\n    uint32 flatFeeMicroLink,\\n    uint24 blockCountPerTurn,\\n    uint32 checkGasLimit,\\n    uint24 stalenessSeconds,\\n    uint16 gasCeilingMultiplier,\\n    uint256 fallbackGasPrice,\\n    uint256 fallbackLinkPrice\\n  ) ConfirmedOwner(msg.sender) {\\n    LINK = LinkTokenInterface(link);\\n    LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\\n    FAST_GAS_FEED = AggregatorV3Interface(fastGasFeed);\\n\\n    setConfig(\\n      paymentPremiumPPB,\\n      flatFeeMicroLink,\\n      blockCountPerTurn,\\n      checkGasLimit,\\n      stalenessSeconds,\\n      gasCeilingMultiplier,\\n      fallbackGasPrice,\\n      fallbackLinkPrice\\n    );\\n  }\\n\\n  // ACTIONS\\n\\n  /**\\n   * @notice adds a new upkeep\\n   * @param target address to perform upkeep on\\n   * @param gasLimit amount of gas to provide the target contract when\\n   * performing upkeep\\n   * @param admin address to cancel upkeep and withdraw remaining funds\\n   * @param checkData data passed to the contract when checking for upkeep\\n   */\\n  function registerUpkeep(\\n    address target,\\n    uint32 gasLimit,\\n    address admin,\\n    bytes calldata checkData\\n  ) external override onlyOwnerOrRegistrar returns (uint256 id) {\\n    require(target.isContract(), \\\"target is not a contract\\\");\\n    require(gasLimit >= CALL_GAS_MIN, \\\"min gas is 2300\\\");\\n    require(gasLimit <= CALL_GAS_MAX, \\\"max gas is 5000000\\\");\\n\\n    id = s_upkeepCount;\\n    s_upkeep[id] = Upkeep({\\n      target: target,\\n      executeGas: gasLimit,\\n      balance: 0,\\n      admin: admin,\\n      maxValidBlocknumber: UINT64_MAX,\\n      lastKeeper: address(0)\\n    });\\n    s_checkData[id] = checkData;\\n    s_upkeepCount++;\\n\\n    emit UpkeepRegistered(id, gasLimit, admin);\\n\\n    return id;\\n  }\\n\\n  /**\\n   * @notice simulated by keepers via eth_call to see if the upkeep needs to be\\n   * performed. If upkeep is needed, the call then simulates performUpkeep\\n   * to make sure it succeeds. Finally, it returns the success status along with\\n   * payment information and the perform data payload.\\n   * @param id identifier of the upkeep to check\\n   * @param from the address to simulate performing the upkeep from\\n   */\\n  function checkUpkeep(uint256 id, address from)\\n    external\\n    override\\n    whenNotPaused\\n    cannotExecute\\n    returns (\\n      bytes memory performData,\\n      uint256 maxLinkPayment,\\n      uint256 gasLimit,\\n      uint256 adjustedGasWei,\\n      uint256 linkEth\\n    )\\n  {\\n    bytes memory callData = abi.encodeWithSelector(CHECK_SELECTOR, s_checkData[id]);\\n    (bool success, bytes memory result) = s_upkeep[id].target.call{gas: s_config.checkGasLimit}(callData);\\n\\n    if (!success) {\\n      string memory upkeepRevertReason = getRevertMsg(result);\\n      string memory reason = string(abi.encodePacked(\\\"call to check target failed: \\\", upkeepRevertReason));\\n      revert(reason);\\n    }\\n\\n    (success, performData) = abi.decode(result, (bool, bytes));\\n    require(success, \\\"upkeep not needed\\\");\\n\\n    PerformParams memory params = generatePerformParams(from, id, performData, false);\\n    success = performUpkeepWithParams(params);\\n    require(success, \\\"call to perform upkeep failed\\\");\\n\\n    return (performData, params.maxLinkPayment, params.gasLimit, params.adjustedGasWei, params.linkEth);\\n  }\\n\\n  /**\\n   * @notice executes the upkeep with the perform data returned from\\n   * checkUpkeep, validates the keeper's permissions, and pays the keeper.\\n   * @param id identifier of the upkeep to execute the data with.\\n   * @param performData calldata parameter to be passed to the target upkeep.\\n   */\\n  function performUpkeep(uint256 id, bytes calldata performData) external override returns (bool success) {\\n    return performUpkeepWithParams(generatePerformParams(msg.sender, id, performData, true));\\n  }\\n\\n  /**\\n   * @notice prevent an upkeep from being performed in the future\\n   * @param id upkeep to be canceled\\n   */\\n  function cancelUpkeep(uint256 id) external override {\\n    uint64 maxValid = s_upkeep[id].maxValidBlocknumber;\\n    bool notCanceled = maxValid == UINT64_MAX;\\n    bool isOwner = msg.sender == owner();\\n    require(notCanceled || (isOwner && maxValid > block.number), \\\"too late to cancel upkeep\\\");\\n    require(isOwner || msg.sender == s_upkeep[id].admin, \\\"only owner or admin\\\");\\n\\n    uint256 height = block.number;\\n    if (!isOwner) {\\n      height = height.add(CANCELATION_DELAY);\\n    }\\n    s_upkeep[id].maxValidBlocknumber = uint64(height);\\n    if (notCanceled) {\\n      s_canceledUpkeepList.push(id);\\n    }\\n\\n    emit UpkeepCanceled(id, uint64(height));\\n  }\\n\\n  /**\\n   * @notice adds LINK funding for an upkeep by tranferring from the sender's\\n   * LINK balance\\n   * @param id upkeep to fund\\n   * @param amount number of LINK to transfer\\n   */\\n  function addFunds(uint256 id, uint96 amount) external override {\\n    require(s_upkeep[id].maxValidBlocknumber == UINT64_MAX, \\\"upkeep must be active\\\");\\n    s_upkeep[id].balance = s_upkeep[id].balance.add(amount);\\n    s_expectedLinkBalance = s_expectedLinkBalance.add(amount);\\n    LINK.transferFrom(msg.sender, address(this), amount);\\n    emit FundsAdded(id, msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice uses LINK's transferAndCall to LINK and add funding to an upkeep\\n   * @dev safe to cast uint256 to uint96 as total LINK supply is under UINT96MAX\\n   * @param sender the account which transferred the funds\\n   * @param amount number of LINK transfer\\n   */\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external {\\n    require(msg.sender == address(LINK), \\\"only callable through LINK\\\");\\n    require(data.length == 32, \\\"data must be 32 bytes\\\");\\n    uint256 id = abi.decode(data, (uint256));\\n    require(s_upkeep[id].maxValidBlocknumber == UINT64_MAX, \\\"upkeep must be active\\\");\\n\\n    s_upkeep[id].balance = s_upkeep[id].balance.add(uint96(amount));\\n    s_expectedLinkBalance = s_expectedLinkBalance.add(amount);\\n\\n    emit FundsAdded(id, sender, uint96(amount));\\n  }\\n\\n  /**\\n   * @notice removes funding from a canceled upkeep\\n   * @param id upkeep to withdraw funds from\\n   * @param to destination address for sending remaining funds\\n   */\\n  function withdrawFunds(uint256 id, address to) external validateRecipient(to) {\\n    require(s_upkeep[id].admin == msg.sender, \\\"only callable by admin\\\");\\n    require(s_upkeep[id].maxValidBlocknumber <= block.number, \\\"upkeep must be canceled\\\");\\n\\n    uint256 amount = s_upkeep[id].balance;\\n    s_upkeep[id].balance = 0;\\n    s_expectedLinkBalance = s_expectedLinkBalance.sub(amount);\\n    emit FundsWithdrawn(id, amount, to);\\n\\n    LINK.transfer(to, amount);\\n  }\\n\\n  /**\\n   * @notice recovers LINK funds improperly transfered to the registry\\n   * @dev In principle this function\u2019s execution cost could exceed block\\n   * gaslimit. However, in our anticipated deployment, the number of upkeeps and\\n   * keepers will be low enough to avoid this problem.\\n   */\\n  function recoverFunds() external onlyOwner {\\n    uint256 total = LINK.balanceOf(address(this));\\n    LINK.transfer(msg.sender, total.sub(s_expectedLinkBalance));\\n  }\\n\\n  /**\\n   * @notice withdraws a keeper's payment, callable only by the keeper's payee\\n   * @param from keeper address\\n   * @param to address to send the payment to\\n   */\\n  function withdrawPayment(address from, address to) external validateRecipient(to) {\\n    KeeperInfo memory keeper = s_keeperInfo[from];\\n    require(keeper.payee == msg.sender, \\\"only callable by payee\\\");\\n\\n    s_keeperInfo[from].balance = 0;\\n    s_expectedLinkBalance = s_expectedLinkBalance.sub(keeper.balance);\\n    emit PaymentWithdrawn(from, keeper.balance, to, msg.sender);\\n\\n    LINK.transfer(to, keeper.balance);\\n  }\\n\\n  /**\\n   * @notice proposes the safe transfer of a keeper's payee to another address\\n   * @param keeper address of the keeper to transfer payee role\\n   * @param proposed address to nominate for next payeeship\\n   */\\n  function transferPayeeship(address keeper, address proposed) external {\\n    require(s_keeperInfo[keeper].payee == msg.sender, \\\"only callable by payee\\\");\\n    require(proposed != msg.sender, \\\"cannot transfer to self\\\");\\n\\n    if (s_proposedPayee[keeper] != proposed) {\\n      s_proposedPayee[keeper] = proposed;\\n      emit PayeeshipTransferRequested(keeper, msg.sender, proposed);\\n    }\\n  }\\n\\n  /**\\n   * @notice accepts the safe transfer of payee role for a keeper\\n   * @param keeper address to accept the payee role for\\n   */\\n  function acceptPayeeship(address keeper) external {\\n    require(s_proposedPayee[keeper] == msg.sender, \\\"only callable by proposed payee\\\");\\n    address past = s_keeperInfo[keeper].payee;\\n    s_keeperInfo[keeper].payee = msg.sender;\\n    s_proposedPayee[keeper] = ZERO_ADDRESS;\\n\\n    emit PayeeshipTransferred(keeper, past, msg.sender);\\n  }\\n\\n  /**\\n   * @notice signals to keepers that they should not perform upkeeps until the\\n   * contract has been unpaused\\n   */\\n  function pause() external onlyOwner {\\n    _pause();\\n  }\\n\\n  /**\\n   * @notice signals to keepers that they can perform upkeeps once again after\\n   * having been paused\\n   */\\n  function unpause() external onlyOwner {\\n    _unpause();\\n  }\\n\\n  // SETTERS\\n\\n  /**\\n   * @notice updates the configuration of the registry\\n   * @param paymentPremiumPPB payment premium rate oracles receive on top of\\n   * being reimbursed for gas, measured in parts per billion\\n   * @param flatFeeMicroLink flat fee paid to oracles for performing upkeeps\\n   * @param blockCountPerTurn number of blocks an oracle should wait before\\n   * checking for upkeep\\n   * @param checkGasLimit gas limit when checking for upkeep\\n   * @param stalenessSeconds number of seconds that is allowed for feed data to\\n   * be stale before switching to the fallback pricing\\n   * @param fallbackGasPrice gas price used if the gas price feed is stale\\n   * @param fallbackLinkPrice LINK price used if the LINK price feed is stale\\n   */\\n  function setConfig(\\n    uint32 paymentPremiumPPB,\\n    uint32 flatFeeMicroLink,\\n    uint24 blockCountPerTurn,\\n    uint32 checkGasLimit,\\n    uint24 stalenessSeconds,\\n    uint16 gasCeilingMultiplier,\\n    uint256 fallbackGasPrice,\\n    uint256 fallbackLinkPrice\\n  ) public onlyOwner {\\n    s_config = Config({\\n      paymentPremiumPPB: paymentPremiumPPB,\\n      flatFeeMicroLink: flatFeeMicroLink,\\n      blockCountPerTurn: blockCountPerTurn,\\n      checkGasLimit: checkGasLimit,\\n      stalenessSeconds: stalenessSeconds,\\n      gasCeilingMultiplier: gasCeilingMultiplier\\n    });\\n    s_fallbackGasPrice = fallbackGasPrice;\\n    s_fallbackLinkPrice = fallbackLinkPrice;\\n\\n    emit ConfigSet(\\n      paymentPremiumPPB,\\n      blockCountPerTurn,\\n      checkGasLimit,\\n      stalenessSeconds,\\n      gasCeilingMultiplier,\\n      fallbackGasPrice,\\n      fallbackLinkPrice\\n    );\\n    emit FlatFeeSet(flatFeeMicroLink);\\n  }\\n\\n  /**\\n   * @notice update the list of keepers allowed to perform upkeep\\n   * @param keepers list of addresses allowed to perform upkeep\\n   * @param payees addreses corresponding to keepers who are allowed to\\n   * move payments which have been accrued\\n   */\\n  function setKeepers(address[] calldata keepers, address[] calldata payees) external onlyOwner {\\n    require(keepers.length == payees.length, \\\"address lists not the same length\\\");\\n    require(keepers.length >= 2, \\\"not enough keepers\\\");\\n    for (uint256 i = 0; i < s_keeperList.length; i++) {\\n      address keeper = s_keeperList[i];\\n      s_keeperInfo[keeper].active = false;\\n    }\\n    for (uint256 i = 0; i < keepers.length; i++) {\\n      address keeper = keepers[i];\\n      KeeperInfo storage s_keeper = s_keeperInfo[keeper];\\n      address oldPayee = s_keeper.payee;\\n      address newPayee = payees[i];\\n      require(newPayee != address(0), \\\"cannot set payee to the zero address\\\");\\n      require(oldPayee == ZERO_ADDRESS || oldPayee == newPayee || newPayee == IGNORE_ADDRESS, \\\"cannot change payee\\\");\\n      require(!s_keeper.active, \\\"cannot add keeper twice\\\");\\n      s_keeper.active = true;\\n      if (newPayee != IGNORE_ADDRESS) {\\n        s_keeper.payee = newPayee;\\n      }\\n    }\\n    s_keeperList = keepers;\\n    emit KeepersUpdated(keepers, payees);\\n  }\\n\\n  /**\\n   * @notice update registrar\\n   * @param registrar new registrar\\n   */\\n  function setRegistrar(address registrar) external onlyOwnerOrRegistrar {\\n    address previous = s_registrar;\\n    require(registrar != previous, \\\"Same registrar\\\");\\n    s_registrar = registrar;\\n    emit RegistrarChanged(previous, registrar);\\n  }\\n\\n  // GETTERS\\n\\n  /**\\n   * @notice read all of the details about an upkeep\\n   */\\n  function getUpkeep(uint256 id)\\n    external\\n    view\\n    override\\n    returns (\\n      address target,\\n      uint32 executeGas,\\n      bytes memory checkData,\\n      uint96 balance,\\n      address lastKeeper,\\n      address admin,\\n      uint64 maxValidBlocknumber\\n    )\\n  {\\n    Upkeep memory reg = s_upkeep[id];\\n    return (\\n      reg.target,\\n      reg.executeGas,\\n      s_checkData[id],\\n      reg.balance,\\n      reg.lastKeeper,\\n      reg.admin,\\n      reg.maxValidBlocknumber\\n    );\\n  }\\n\\n  /**\\n   * @notice read the total number of upkeep's registered\\n   */\\n  function getUpkeepCount() external view override returns (uint256) {\\n    return s_upkeepCount;\\n  }\\n\\n  /**\\n   * @notice read the current list canceled upkeep IDs\\n   */\\n  function getCanceledUpkeepList() external view override returns (uint256[] memory) {\\n    return s_canceledUpkeepList;\\n  }\\n\\n  /**\\n   * @notice read the current list of addresses allowed to perform upkeep\\n   */\\n  function getKeeperList() external view override returns (address[] memory) {\\n    return s_keeperList;\\n  }\\n\\n  /**\\n   * @notice read the current registrar\\n   */\\n  function getRegistrar() external view returns (address) {\\n    return s_registrar;\\n  }\\n\\n  /**\\n   * @notice read the current info about any keeper address\\n   */\\n  function getKeeperInfo(address query)\\n    external\\n    view\\n    override\\n    returns (\\n      address payee,\\n      bool active,\\n      uint96 balance\\n    )\\n  {\\n    KeeperInfo memory keeper = s_keeperInfo[query];\\n    return (keeper.payee, keeper.active, keeper.balance);\\n  }\\n\\n  /**\\n   * @notice read the current configuration of the registry\\n   */\\n  function getConfig()\\n    external\\n    view\\n    override\\n    returns (\\n      uint32 paymentPremiumPPB,\\n      uint24 blockCountPerTurn,\\n      uint32 checkGasLimit,\\n      uint24 stalenessSeconds,\\n      uint16 gasCeilingMultiplier,\\n      uint256 fallbackGasPrice,\\n      uint256 fallbackLinkPrice\\n    )\\n  {\\n    Config memory config = s_config;\\n    return (\\n      config.paymentPremiumPPB,\\n      config.blockCountPerTurn,\\n      config.checkGasLimit,\\n      config.stalenessSeconds,\\n      config.gasCeilingMultiplier,\\n      s_fallbackGasPrice,\\n      s_fallbackLinkPrice\\n    );\\n  }\\n\\n  /**\\n   * @notice getFlatFee gets the flat rate fee charged to customers when performing upkeep,\\n   * in units of of micro LINK\\n   */\\n  function getFlatFee() external view returns (uint32) {\\n    return s_config.flatFeeMicroLink;\\n  }\\n\\n  /**\\n   * @notice calculates the minimum balance required for an upkeep to remain eligible\\n   */\\n  function getMinBalanceForUpkeep(uint256 id) external view returns (uint96 minBalance) {\\n    return getMaxPaymentForGas(s_upkeep[id].executeGas);\\n  }\\n\\n  /**\\n   * @notice calculates the maximum payment for a given gas limit\\n   */\\n  function getMaxPaymentForGas(uint256 gasLimit) public view returns (uint96 maxPayment) {\\n    (uint256 gasWei, uint256 linkEth) = getFeedData();\\n    uint256 adjustedGasWei = adjustGasPrice(gasWei, false);\\n    return calculatePaymentAmount(gasLimit, adjustedGasWei, linkEth);\\n  }\\n\\n  // PRIVATE\\n\\n  /**\\n   * @dev retrieves feed data for fast gas/eth and link/eth prices. if the feed\\n   * data is stale it uses the configured fallback price. Once a price is picked\\n   * for gas it takes the min of gas price in the transaction or the fast gas\\n   * price in order to reduce costs for the upkeep clients.\\n   */\\n  function getFeedData() private view returns (uint256 gasWei, uint256 linkEth) {\\n    uint32 stalenessSeconds = s_config.stalenessSeconds;\\n    bool staleFallback = stalenessSeconds > 0;\\n    uint256 timestamp;\\n    int256 feedValue;\\n    (, feedValue, , timestamp, ) = FAST_GAS_FEED.latestRoundData();\\n    if ((staleFallback && stalenessSeconds < block.timestamp - timestamp) || feedValue <= 0) {\\n      gasWei = s_fallbackGasPrice;\\n    } else {\\n      gasWei = uint256(feedValue);\\n    }\\n    (, feedValue, , timestamp, ) = LINK_ETH_FEED.latestRoundData();\\n    if ((staleFallback && stalenessSeconds < block.timestamp - timestamp) || feedValue <= 0) {\\n      linkEth = s_fallbackLinkPrice;\\n    } else {\\n      linkEth = uint256(feedValue);\\n    }\\n    return (gasWei, linkEth);\\n  }\\n\\n  /**\\n   * @dev calculates LINK paid for gas spent plus a configure premium percentage\\n   */\\n  function calculatePaymentAmount(\\n    uint256 gasLimit,\\n    uint256 gasWei,\\n    uint256 linkEth\\n  ) private view returns (uint96 payment) {\\n    Config memory config = s_config;\\n    uint256 weiForGas = gasWei.mul(gasLimit.add(REGISTRY_GAS_OVERHEAD));\\n    uint256 premium = PPB_BASE.add(config.paymentPremiumPPB);\\n    uint256 total = weiForGas.mul(1e9).mul(premium).div(linkEth).add(uint256(config.flatFeeMicroLink).mul(1e12));\\n    require(total <= LINK_TOTAL_SUPPLY, \\\"payment greater than all LINK\\\");\\n    return uint96(total); // LINK_TOTAL_SUPPLY < UINT96_MAX\\n  }\\n\\n  /**\\n   * @dev calls target address with exactly gasAmount gas and data as calldata\\n   * or reverts if at least gasAmount gas is not available\\n   */\\n  function callWithExactGas(\\n    uint256 gasAmount,\\n    address target,\\n    bytes memory data\\n  ) private returns (bool success) {\\n    assembly {\\n      let g := gas()\\n      // Compute g -= CUSHION and check for underflow\\n      if lt(g, CUSHION) {\\n        revert(0, 0)\\n      }\\n      g := sub(g, CUSHION)\\n      // if g - g//64 <= gasAmount, revert\\n      // (we subtract g//64 because of EIP-150)\\n      if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\\n        revert(0, 0)\\n      }\\n      // solidity calls check that a contract actually exists at the destination, so we do the same\\n      if iszero(extcodesize(target)) {\\n        revert(0, 0)\\n      }\\n      // call and return whether we succeeded. ignore return data\\n      success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\\n    }\\n    return success;\\n  }\\n\\n  /**\\n   * @dev calls the Upkeep target with the performData param passed in by the\\n   * keeper and the exact gas required by the Upkeep\\n   */\\n  function performUpkeepWithParams(PerformParams memory params)\\n    private\\n    nonReentrant\\n    validUpkeep(params.id)\\n    returns (bool success)\\n  {\\n    require(s_keeperInfo[params.from].active, \\\"only active keepers\\\");\\n    Upkeep memory upkeep = s_upkeep[params.id];\\n    require(upkeep.balance >= params.maxLinkPayment, \\\"insufficient funds\\\");\\n    require(upkeep.lastKeeper != params.from, \\\"keepers must take turns\\\");\\n\\n    uint256 gasUsed = gasleft();\\n    bytes memory callData = abi.encodeWithSelector(PERFORM_SELECTOR, params.performData);\\n    success = callWithExactGas(params.gasLimit, upkeep.target, callData);\\n    gasUsed = gasUsed - gasleft();\\n\\n    uint96 payment = calculatePaymentAmount(gasUsed, params.adjustedGasWei, params.linkEth);\\n    upkeep.balance = upkeep.balance.sub(payment);\\n    upkeep.lastKeeper = params.from;\\n    s_upkeep[params.id] = upkeep;\\n    uint96 newBalance = s_keeperInfo[params.from].balance.add(payment);\\n    s_keeperInfo[params.from].balance = newBalance;\\n\\n    emit UpkeepPerformed(params.id, success, params.from, payment, params.performData);\\n    return success;\\n  }\\n\\n  /**\\n   * @dev ensures a upkeep is valid\\n   */\\n  function validateUpkeep(uint256 id) private view {\\n    require(s_upkeep[id].maxValidBlocknumber > block.number, \\\"invalid upkeep id\\\");\\n  }\\n\\n  /**\\n   * @dev adjusts the gas price to min(ceiling, tx.gasprice) or just uses the ceiling if tx.gasprice is disabled\\n   */\\n  function adjustGasPrice(uint256 gasWei, bool useTxGasPrice) private view returns (uint256 adjustedPrice) {\\n    adjustedPrice = gasWei.mul(s_config.gasCeilingMultiplier);\\n    if (useTxGasPrice && tx.gasprice < adjustedPrice) {\\n      adjustedPrice = tx.gasprice;\\n    }\\n  }\\n\\n  /**\\n   * @dev generates a PerformParams struct for use in performUpkeepWithParams()\\n   */\\n  function generatePerformParams(\\n    address from,\\n    uint256 id,\\n    bytes memory performData,\\n    bool useTxGasPrice\\n  ) private view returns (PerformParams memory) {\\n    uint256 gasLimit = s_upkeep[id].executeGas;\\n    (uint256 gasWei, uint256 linkEth) = getFeedData();\\n    uint256 adjustedGasWei = adjustGasPrice(gasWei, useTxGasPrice);\\n    uint96 maxLinkPayment = calculatePaymentAmount(gasLimit, adjustedGasWei, linkEth);\\n\\n    return\\n      PerformParams({\\n        from: from,\\n        id: id,\\n        performData: performData,\\n        maxLinkPayment: maxLinkPayment,\\n        gasLimit: gasLimit,\\n        adjustedGasWei: adjustedGasWei,\\n        linkEth: linkEth\\n      });\\n  }\\n\\n  /**\\n   * @dev extracts a revert reason from a call result payload\\n   */\\n  function getRevertMsg(bytes memory _payload) private pure returns (string memory) {\\n    if (_payload.length < 68) return \\\"transaction reverted silently\\\";\\n    assembly {\\n      _payload := add(_payload, 0x04)\\n    }\\n    return abi.decode(_payload, (string));\\n  }\\n\\n  // MODIFIERS\\n\\n  /**\\n   * @dev ensures a upkeep is valid\\n   */\\n  modifier validUpkeep(uint256 id) {\\n    validateUpkeep(id);\\n    _;\\n  }\\n\\n  /**\\n   * @dev ensures that burns don't accidentally happen by sending to the zero\\n   * address\\n   */\\n  modifier validateRecipient(address to) {\\n    require(to != address(0), \\\"cannot send to zero address\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if called by anyone other than the contract owner or registrar.\\n   */\\n  modifier onlyOwnerOrRegistrar() {\\n    require(msg.sender == owner() || msg.sender == s_registrar, \\\"Only callable by owner or registrar\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\ninterface KeeperCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easilly be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// github.com/OpenZeppelin/openzeppelin-contracts@fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n  /**\\n   * @dev Emitted when the pause is triggered by `account`.\\n   */\\n  event Paused(address account);\\n\\n  /**\\n   * @dev Emitted when the pause is lifted by `account`.\\n   */\\n  event Unpaused(address account);\\n\\n  bool private _paused;\\n\\n  /**\\n   * @dev Initializes the contract in unpaused state.\\n   */\\n  constructor() {\\n    _paused = false;\\n  }\\n\\n  /**\\n   * @dev Returns true if the contract is paused, and false otherwise.\\n   */\\n  function paused() public view virtual returns (bool) {\\n    return _paused;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused(), \\\"Pausable: paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused(), \\\"Pausable: not paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Triggers stopped state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  function _pause() internal virtual whenNotPaused {\\n    _paused = true;\\n    emit Paused(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Returns to normal state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  function _unpause() internal virtual whenPaused {\\n    _paused = false;\\n    emit Unpaused(_msgSender());\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// github.com/OpenZeppelin/openzeppelin-contracts@fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n  // Booleans are more expensive than uint256 or any type that takes up a full\\n  // word because each write operation emits an extra SLOAD to first read the\\n  // slot's contents, replace the bits taken up by the boolean, and then write\\n  // back. This is the compiler's defense against contract upgrades and\\n  // pointer aliasing, and it cannot be disabled.\\n\\n  // The values being non-zero value makes deployment a bit more expensive,\\n  // but in exchange the refund on every call to nonReentrant will be lower in\\n  // amount. Since refunds are capped to a percentage of the total\\n  // transaction's gas, it is best to keep them low in cases like this one, to\\n  // increase the likelihood of the full refund coming into effect.\\n  uint256 private constant _NOT_ENTERED = 1;\\n  uint256 private constant _ENTERED = 2;\\n\\n  uint256 private _status;\\n\\n  constructor() {\\n    _status = _NOT_ENTERED;\\n  }\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   * Calling a `nonReentrant` function from another `nonReentrant`\\n   * function is not supported. It is possible to prevent this from happening\\n   * by making the `nonReentrant` function external, and make it call a\\n   * `private` function that does the actual work.\\n   */\\n  modifier nonReentrant() {\\n    // On the first call to nonReentrant, _notEntered will be true\\n    require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n    // Any calls to nonReentrant after this point will fail\\n    _status = _ENTERED;\\n\\n    _;\\n\\n    // By storing the original value once again, a refund is triggered (see\\n    // https://eips.ethereum.org/EIPS/eip-2200)\\n    _status = _NOT_ENTERED;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n  int256 private constant _INT256_MIN = -2**255;\\n\\n  /**\\n   * @dev Returns the multiplication of two signed integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(int256 a, int256 b) internal pure returns (int256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n    int256 c = a * b;\\n    require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two signed integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   *\\n   * - The divisor cannot be zero.\\n   */\\n  function div(int256 a, int256 b) internal pure returns (int256) {\\n    require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n    require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n    int256 c = a / b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two signed integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a - b;\\n    require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two signed integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Addition cannot overflow.\\n   */\\n  function add(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a + b;\\n    require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/KeeperBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ncontract KeeperBase {\\n  /**\\n   * @notice method that allows it to be simulated via eth_call by checking that\\n   * the sender is the zero address.\\n   */\\n  function preventExecution() internal view {\\n    require(tx.origin == address(0), \\\"only for simulated backend\\\");\\n  }\\n\\n  /**\\n   * @notice modifier that allows it to be simulated via eth_call by checking\\n   * that the sender is the zero address.\\n   */\\n  modifier cannotExecute() {\\n    preventExecution();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// github.com/OpenZeppelin/openzeppelin-contracts@fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6\\n\\npragma solidity ^0.7.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this;\\n    // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/KeeperCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./KeeperBase.sol\\\";\\nimport \\\"./interfaces/KeeperCompatibleInterface.sol\\\";\\n\\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\\n\"\r\n    },\r\n    \"src/v0.7/tests/UpkeepReverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../KeeperCompatible.sol\\\";\\n\\ncontract UpkeepReverter is KeeperCompatible {\\n  function checkUpkeep(bytes calldata data)\\n    public\\n    view\\n    override\\n    cannotExecute\\n    returns (bool callable, bytes calldata executedata)\\n  {\\n    require(false, \\\"!working\\\");\\n    return (true, data);\\n  }\\n\\n  function performUpkeep(bytes calldata) external pure override {\\n    require(false, \\\"!working\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/tests/UpkeepMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../KeeperCompatible.sol\\\";\\n\\ncontract UpkeepMock is KeeperCompatible {\\n  bool public canCheck;\\n  bool public canPerform;\\n  uint256 public checkGasToBurn;\\n  uint256 public performGasToBurn;\\n\\n  uint256 constant gasBuffer = 1000; // use all but this amount in gas burn loops\\n\\n  event UpkeepPerformedWith(bytes upkeepData);\\n\\n  function setCanCheck(bool value) public {\\n    canCheck = value;\\n  }\\n\\n  function setCanPerform(bool value) public {\\n    canPerform = value;\\n  }\\n\\n  function setCheckGasToBurn(uint256 value) public {\\n    require(value > gasBuffer || value == 0, \\\"checkGasToBurn must be 0 (disabled) or greater than buffer\\\");\\n    checkGasToBurn = value - gasBuffer;\\n  }\\n\\n  function setPerformGasToBurn(uint256 value) public {\\n    require(value > gasBuffer || value == 0, \\\"performGasToBurn must be 0 (disabled) or greater than buffer\\\");\\n    performGasToBurn = value - gasBuffer;\\n  }\\n\\n  function checkUpkeep(bytes calldata data)\\n    external\\n    override\\n    cannotExecute\\n    returns (bool callable, bytes calldata executedata)\\n  {\\n    uint256 startGas = gasleft();\\n    bool couldCheck = canCheck;\\n\\n    setCanCheck(false); // test that state modifcations don't stick\\n\\n    while (startGas - gasleft() < checkGasToBurn) {} // burn gas\\n\\n    return (couldCheck, data);\\n  }\\n\\n  function performUpkeep(bytes calldata data) external override {\\n    uint256 startGas = gasleft();\\n\\n    require(canPerform, \\\"Cannot perform\\\");\\n\\n    setCanPerform(false);\\n\\n    emit UpkeepPerformedWith(data);\\n\\n    while (startGas - gasleft() < performGasToBurn) {} // burn gas\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/dev/StalenessFlaggingValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ConfirmedOwner.sol\\\";\\nimport \\\"../vendor/SafeMathChainlink.sol\\\";\\nimport \\\"../interfaces/FlagsInterface.sol\\\";\\nimport \\\"../interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/KeeperCompatibleInterface.sol\\\";\\n\\ncontract StalenessFlaggingValidator is ConfirmedOwner, KeeperCompatibleInterface {\\n  using SafeMathChainlink for uint256;\\n\\n  FlagsInterface private s_flags;\\n  mapping(address => uint256) private s_thresholdSeconds;\\n\\n  event FlagsAddressUpdated(address indexed previous, address indexed current);\\n  event FlaggingThresholdUpdated(address indexed aggregator, uint256 indexed previous, uint256 indexed current);\\n\\n  /**\\n   * @notice Create a new StalenessFlaggingValidator\\n   * @param flagsAddress Address of the flag contract\\n   * @dev Ensure that this contract has sufficient write permissions\\n   * on the flag contract\\n   */\\n  constructor(address flagsAddress) ConfirmedOwner(msg.sender) {\\n    setFlagsAddress(flagsAddress);\\n  }\\n\\n  /**\\n   * @notice Updates the flagging contract address for raising flags\\n   * @param flagsAddress sets the address of the flags contract\\n   */\\n  function setFlagsAddress(address flagsAddress) public onlyOwner {\\n    address previous = address(s_flags);\\n    if (previous != flagsAddress) {\\n      s_flags = FlagsInterface(flagsAddress);\\n      emit FlagsAddressUpdated(previous, flagsAddress);\\n    }\\n  }\\n\\n  /**\\n   * @notice Set the threshold limits for each aggregator\\n   * @dev parameters must be same length\\n   * @param aggregators address[] memory\\n   * @param flaggingThresholds uint256[] memory\\n   */\\n  function setThresholds(address[] memory aggregators, uint256[] memory flaggingThresholds) public onlyOwner {\\n    require(aggregators.length == flaggingThresholds.length, \\\"Different sized arrays\\\");\\n    for (uint256 i = 0; i < aggregators.length; i++) {\\n      address aggregator = aggregators[i];\\n      uint256 previousThreshold = s_thresholdSeconds[aggregator];\\n      uint256 newThreshold = flaggingThresholds[i];\\n      if (previousThreshold != newThreshold) {\\n        s_thresholdSeconds[aggregator] = newThreshold;\\n        emit FlaggingThresholdUpdated(aggregator, previousThreshold, newThreshold);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Check for staleness in an array of aggregators\\n   * @dev If any of the aggregators are stale, this function will return true,\\n   * otherwise false\\n   * @param aggregators address[] memory\\n   * @return address[] memory stale aggregators\\n   */\\n  function check(address[] memory aggregators) public view returns (address[] memory) {\\n    uint256 currentTimestamp = block.timestamp;\\n    address[] memory staleAggregators = new address[](aggregators.length);\\n    uint256 staleCount = 0;\\n    for (uint256 i = 0; i < aggregators.length; i++) {\\n      address aggregator = aggregators[i];\\n      if (isStale(aggregator, currentTimestamp)) {\\n        staleAggregators[staleCount] = aggregator;\\n        staleCount++;\\n      }\\n    }\\n\\n    if (aggregators.length != staleCount) {\\n      assembly {\\n        mstore(staleAggregators, staleCount)\\n      }\\n    }\\n    return staleAggregators;\\n  }\\n\\n  /**\\n   * @notice Check for staleness in an array of aggregators, raise a flag\\n   * on the flags contract for each aggregator that is stale\\n   * @dev This contract must have write permissions on the flags contract\\n   * @param aggregators address[] memory\\n   * @return address[] memory stale aggregators\\n   */\\n  function update(address[] memory aggregators) public returns (address[] memory) {\\n    address[] memory staleAggregators = check(aggregators);\\n    s_flags.raiseFlags(staleAggregators);\\n    return staleAggregators;\\n  }\\n\\n  /**\\n   * @notice Check for staleness in an array of aggregators\\n   * @dev Overriding KeeperInterface\\n   * @param data bytes encoded address array\\n   * @return needsUpkeep bool indicating whether upkeep needs to be performed\\n   * @return staleAggregators bytes encoded address array of stale aggregator addresses\\n   */\\n  function checkUpkeep(bytes calldata data) external view override returns (bool, bytes memory) {\\n    address[] memory staleAggregators = check(abi.decode(data, (address[])));\\n    bool needsUpkeep = (staleAggregators.length > 0);\\n    return (needsUpkeep, abi.encode(staleAggregators));\\n  }\\n\\n  /**\\n   * @notice Check for staleness in an array of aggregators, raise a flag\\n   * on the flags contract for each aggregator that is stale\\n   * @dev Overriding KeeperInterface\\n   * @param data bytes encoded address array\\n   */\\n  function performUpkeep(bytes calldata data) external override {\\n    update(abi.decode(data, (address[])));\\n  }\\n\\n  /**\\n   * @notice Get the threshold of an aggregator\\n   * @param aggregator address\\n   * @return uint256\\n   */\\n  function threshold(address aggregator) external view returns (uint256) {\\n    return s_thresholdSeconds[aggregator];\\n  }\\n\\n  /**\\n   * @notice Get the flags address\\n   * @return address\\n   */\\n  function flags() external view returns (address) {\\n    return address(s_flags);\\n  }\\n\\n  /**\\n   * @notice Check if an aggregator is stale.\\n   * @dev Staleness is where an aggregator's `updatedAt` field is older\\n   * than the threshold set for it in this contract\\n   * @param aggregator address\\n   * @param currentTimestamp uint256\\n   * @return stale bool\\n   */\\n  function isStale(address aggregator, uint256 currentTimestamp) private view returns (bool stale) {\\n    if (s_thresholdSeconds[aggregator] == 0) {\\n      return false;\\n    }\\n    (, , , uint256 updatedAt, ) = AggregatorV3Interface(aggregator).latestRoundData();\\n    uint256 diff = currentTimestamp.sub(updatedAt);\\n    if (diff > s_thresholdSeconds[aggregator]) {\\n      return true;\\n    }\\n    return false;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n\\n  function raiseFlag(address) external;\\n\\n  function raiseFlags(address[] calldata) external;\\n\\n  function lowerFlags(address[] calldata) external;\\n\\n  function setRaisingAccessController(address) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.7/dev/CompoundPriceFlaggingValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ConfirmedOwner.sol\\\";\\nimport \\\"../vendor/SafeMathChainlink.sol\\\";\\nimport \\\"../interfaces/FlagsInterface.sol\\\";\\nimport \\\"../interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/UniswapAnchoredView.sol\\\";\\nimport \\\"../interfaces/KeeperCompatibleInterface.sol\\\";\\n\\n/**\\n * @notice This validator compares the price of Chainlink aggregators against\\n * their equivalent Compound Open Oracle feeds. For each aggregator, a Compound\\n * feed is configured with its symbol, number of decimals, and deviation threshold.\\n * An aggregator address is flagged when its corresponding Compound feed price deviates\\n * by more than the configured threshold from the aggregator price.\\n */\\ncontract CompoundPriceFlaggingValidator is ConfirmedOwner, KeeperCompatibleInterface {\\n  using SafeMathChainlink for uint256;\\n\\n  struct CompoundFeedDetails {\\n    // Used to call the Compound Open Oracle\\n    string symbol;\\n    // Used to convert price to match aggregator decimals\\n    uint8 decimals;\\n    // The numerator used to determine the threshold percentage\\n    // as parts per billion.\\n    // 1,000,000,000 = 100%\\n    //   500,000,000 = 50%\\n    //   100,000,000 = 10%\\n    //    50,000,000 = 5%\\n    //    10,000,000 = 1%\\n    //     2,000,000 = 0.2%\\n    //                 etc\\n    uint32 deviationThresholdNumerator;\\n  }\\n\\n  uint256 private constant BILLION = 1_000_000_000;\\n\\n  FlagsInterface private s_flags;\\n  UniswapAnchoredView private s_compOpenOracle;\\n  mapping(address => CompoundFeedDetails) private s_feedDetails;\\n\\n  event CompoundOpenOracleAddressUpdated(address indexed from, address indexed to);\\n  event FlagsAddressUpdated(address indexed from, address indexed to);\\n  event FeedDetailsSet(address indexed aggregator, string symbol, uint8 decimals, uint32 deviationThresholdNumerator);\\n\\n  /**\\n   * @notice Create a new CompoundPriceFlaggingValidator\\n   * @dev Use this contract to compare Chainlink aggregator prices\\n   * against the Compound Open Oracle prices\\n   * @param flagsAddress Address of the flag contract\\n   * @param compoundOracleAddress Address of the Compound Open Oracle UniswapAnchoredView contract\\n   */\\n  constructor(address flagsAddress, address compoundOracleAddress) ConfirmedOwner(msg.sender) {\\n    setFlagsAddress(flagsAddress);\\n    setCompoundOpenOracleAddress(compoundOracleAddress);\\n  }\\n\\n  /**\\n   * @notice Set the address of the Compound Open Oracle UniswapAnchoredView contract\\n   * @param oracleAddress Compound Open Oracle UniswapAnchoredView address\\n   */\\n  function setCompoundOpenOracleAddress(address oracleAddress) public onlyOwner {\\n    address previous = address(s_compOpenOracle);\\n    if (previous != oracleAddress) {\\n      s_compOpenOracle = UniswapAnchoredView(oracleAddress);\\n      emit CompoundOpenOracleAddressUpdated(previous, oracleAddress);\\n    }\\n  }\\n\\n  /**\\n   * @notice Updates the flagging contract address for raising flags\\n   * @param flagsAddress sets the address of the flags contract\\n   */\\n  function setFlagsAddress(address flagsAddress) public onlyOwner {\\n    address previous = address(s_flags);\\n    if (previous != flagsAddress) {\\n      s_flags = FlagsInterface(flagsAddress);\\n      emit FlagsAddressUpdated(previous, flagsAddress);\\n    }\\n  }\\n\\n  /**\\n   * @notice Set the threshold details for comparing a Chainlink aggregator\\n   * to a Compound Open Oracle feed.\\n   * @param aggregator The Chainlink aggregator address\\n   * @param compoundSymbol The symbol used by Compound for this feed\\n   * @param compoundDecimals The number of decimals in the Compound feed\\n   * @param compoundDeviationThresholdNumerator The threshold numerator use to determine\\n   * the percentage with which the difference in prices must reside within. Parts per billion.\\n   *   For example:\\n   *     If prices are valid within a 5% threshold, assuming x is the compoundDeviationThresholdNumerator:\\n   *     x / 1,000,000,000 = 0.05\\n   *     x = 50,000,000\\n   */\\n  function setFeedDetails(\\n    address aggregator,\\n    string calldata compoundSymbol,\\n    uint8 compoundDecimals,\\n    uint32 compoundDeviationThresholdNumerator\\n  ) public onlyOwner {\\n    require(\\n      compoundDeviationThresholdNumerator > 0 && compoundDeviationThresholdNumerator <= BILLION,\\n      \\\"Invalid threshold numerator\\\"\\n    );\\n    require(_compoundPriceOf(compoundSymbol) != 0, \\\"Invalid Compound price\\\");\\n    string memory currentSymbol = s_feedDetails[aggregator].symbol;\\n    // If symbol is not set, use the new one\\n    if (bytes(currentSymbol).length == 0) {\\n      s_feedDetails[aggregator] = CompoundFeedDetails({\\n        symbol: compoundSymbol,\\n        decimals: compoundDecimals,\\n        deviationThresholdNumerator: compoundDeviationThresholdNumerator\\n      });\\n      emit FeedDetailsSet(aggregator, compoundSymbol, compoundDecimals, compoundDeviationThresholdNumerator);\\n    }\\n    // If the symbol is already set, don't change it\\n    else {\\n      s_feedDetails[aggregator] = CompoundFeedDetails({\\n        symbol: currentSymbol,\\n        decimals: compoundDecimals,\\n        deviationThresholdNumerator: compoundDeviationThresholdNumerator\\n      });\\n      emit FeedDetailsSet(aggregator, currentSymbol, compoundDecimals, compoundDeviationThresholdNumerator);\\n    }\\n  }\\n\\n  /**\\n   * @notice Check the price deviation of an array of aggregators\\n   * @dev If any of the aggregators provided have an equivalent Compound Oracle feed\\n   * that with a price outside of the configured deviation, this function will return them.\\n   * @param aggregators address[] memory\\n   * @return address[] invalid feeds\\n   */\\n  function check(address[] memory aggregators) public view returns (address[] memory) {\\n    address[] memory invalidAggregators = new address[](aggregators.length);\\n    uint256 invalidCount = 0;\\n    for (uint256 i = 0; i < aggregators.length; i++) {\\n      address aggregator = aggregators[i];\\n      if (_isInvalid(aggregator)) {\\n        invalidAggregators[invalidCount] = aggregator;\\n        invalidCount++;\\n      }\\n    }\\n\\n    if (aggregators.length != invalidCount) {\\n      assembly {\\n        mstore(invalidAggregators, invalidCount)\\n      }\\n    }\\n    return invalidAggregators;\\n  }\\n\\n  /**\\n   * @notice Check and raise flags for any aggregator that has an equivalent Compound\\n   * Open Oracle feed with a price deviation exceeding the configured setting.\\n   * @dev This contract must have write permissions on the Flags contract\\n   * @param aggregators address[] memory\\n   * @return address[] memory invalid aggregators\\n   */\\n  function update(address[] memory aggregators) public returns (address[] memory) {\\n    address[] memory invalidAggregators = check(aggregators);\\n    s_flags.raiseFlags(invalidAggregators);\\n    return invalidAggregators;\\n  }\\n\\n  /**\\n   * @notice Check the price deviation of an array of aggregators\\n   * @dev If any of the aggregators provided have an equivalent Compound Oracle feed\\n   * that with a price outside of the configured deviation, this function will return them.\\n   * @param data bytes encoded address array\\n   * @return needsUpkeep bool indicating whether upkeep needs to be performed\\n   * @return invalid aggregators - bytes encoded address array of invalid aggregator addresses\\n   */\\n  function checkUpkeep(bytes calldata data) external view override returns (bool, bytes memory) {\\n    address[] memory invalidAggregators = check(abi.decode(data, (address[])));\\n    bool needsUpkeep = (invalidAggregators.length > 0);\\n    return (needsUpkeep, abi.encode(invalidAggregators));\\n  }\\n\\n  /**\\n   * @notice Check and raise flags for any aggregator that has an equivalent Compound\\n   * Open Oracle feed with a price deviation exceeding the configured setting.\\n   * @dev This contract must have write permissions on the Flags contract\\n   * @param data bytes encoded address array\\n   */\\n  function performUpkeep(bytes calldata data) external override {\\n    update(abi.decode(data, (address[])));\\n  }\\n\\n  /**\\n   * @notice Get the threshold of an aggregator\\n   * @param aggregator address\\n   * @return string Compound Oracle Symbol\\n   * @return uint8 Compound Oracle Decimals\\n   * @return uint32 Deviation Threshold Numerator\\n   */\\n  function getFeedDetails(address aggregator)\\n    public\\n    view\\n    returns (\\n      string memory,\\n      uint8,\\n      uint32\\n    )\\n  {\\n    CompoundFeedDetails memory compDetails = s_feedDetails[aggregator];\\n    return (compDetails.symbol, compDetails.decimals, compDetails.deviationThresholdNumerator);\\n  }\\n\\n  /**\\n   * @notice Get the flags address\\n   * @return address\\n   */\\n  function flags() external view returns (address) {\\n    return address(s_flags);\\n  }\\n\\n  /**\\n   * @notice Get the Compound Open Oracle address\\n   * @return address\\n   */\\n  function compoundOpenOracle() external view returns (address) {\\n    return address(s_compOpenOracle);\\n  }\\n\\n  /**\\n   * @notice Return the Compound oracle price of an asset using its symbol\\n   * @param symbol string\\n   * @return price uint256\\n   */\\n  function _compoundPriceOf(string memory symbol) private view returns (uint256) {\\n    return s_compOpenOracle.price(symbol);\\n  }\\n\\n  // VALIDATION FUNCTIONS\\n\\n  /**\\n   * @notice Check if an aggregator has an equivalent Compound Oracle feed\\n   * that's price is deviated more than the threshold.\\n   * @param aggregator address of the Chainlink aggregator\\n   * @return invalid bool. True if the deviation exceeds threshold.\\n   */\\n  function _isInvalid(address aggregator) private view returns (bool invalid) {\\n    CompoundFeedDetails memory compDetails = s_feedDetails[aggregator];\\n    if (compDetails.deviationThresholdNumerator == 0) {\\n      return false;\\n    }\\n    // Get both oracle price details\\n    uint256 compPrice = _compoundPriceOf(compDetails.symbol);\\n    (uint256 aggregatorPrice, uint8 aggregatorDecimals) = _aggregatorValues(aggregator);\\n\\n    // Adjust the prices so the number of decimals in each align\\n    (aggregatorPrice, compPrice) = _adjustPriceDecimals(\\n      aggregatorPrice,\\n      aggregatorDecimals,\\n      compPrice,\\n      compDetails.decimals\\n    );\\n\\n    // Check whether the prices deviate beyond the threshold.\\n    return _deviatesBeyondThreshold(aggregatorPrice, compPrice, compDetails.deviationThresholdNumerator);\\n  }\\n\\n  /**\\n   * @notice Retrieve the price and the decimals from an Aggregator\\n   * @param aggregator address\\n   * @return price uint256\\n   * @return decimals uint8\\n   */\\n  function _aggregatorValues(address aggregator) private view returns (uint256 price, uint8 decimals) {\\n    AggregatorV3Interface priceFeed = AggregatorV3Interface(aggregator);\\n    (, int256 signedPrice, , , ) = priceFeed.latestRoundData();\\n    price = uint256(signedPrice);\\n    decimals = priceFeed.decimals();\\n  }\\n\\n  /**\\n   * @notice Adjust the price values of the Aggregator and Compound feeds so that\\n   * their decimal places align. This enables deviation to be calculated.\\n   * @param aggregatorPrice uint256\\n   * @param aggregatorDecimals uint8 - decimal places included in the aggregator price\\n   * @param compoundPrice uint256\\n   * @param compoundDecimals uint8 - decimal places included in the compound price\\n   * @return adjustedAggregatorPrice uint256\\n   * @return adjustedCompoundPrice uint256\\n   */\\n  function _adjustPriceDecimals(\\n    uint256 aggregatorPrice,\\n    uint8 aggregatorDecimals,\\n    uint256 compoundPrice,\\n    uint8 compoundDecimals\\n  ) private pure returns (uint256 adjustedAggregatorPrice, uint256 adjustedCompoundPrice) {\\n    if (aggregatorDecimals > compoundDecimals) {\\n      uint8 diff = aggregatorDecimals - compoundDecimals;\\n      uint256 multiplier = 10**uint256(diff);\\n      compoundPrice = compoundPrice * multiplier;\\n    } else if (aggregatorDecimals < compoundDecimals) {\\n      uint8 diff = compoundDecimals - aggregatorDecimals;\\n      uint256 multiplier = 10**uint256(diff);\\n      aggregatorPrice = aggregatorPrice * multiplier;\\n    }\\n    adjustedAggregatorPrice = aggregatorPrice;\\n    adjustedCompoundPrice = compoundPrice;\\n  }\\n\\n  /**\\n   * @notice Check whether the compound price deviates from the aggregator price\\n   * beyond the given threshold\\n   * @dev Prices must be adjusted to match decimals prior to calling this function\\n   * @param aggregatorPrice uint256\\n   * @param compPrice uint256\\n   * @param deviationThresholdNumerator uint32\\n   * @return beyondThreshold boolean. Returns true if deviation is beyond threshold.\\n   */\\n  function _deviatesBeyondThreshold(\\n    uint256 aggregatorPrice,\\n    uint256 compPrice,\\n    uint32 deviationThresholdNumerator\\n  ) private pure returns (bool beyondThreshold) {\\n    // Deviation amount threshold from the aggregator price\\n    uint256 deviationAmountThreshold = aggregatorPrice.mul(deviationThresholdNumerator).div(BILLION);\\n\\n    // Calculate deviation\\n    uint256 deviation;\\n    if (aggregatorPrice > compPrice) {\\n      deviation = aggregatorPrice.sub(compPrice);\\n    } else if (aggregatorPrice < compPrice) {\\n      deviation = compPrice.sub(aggregatorPrice);\\n    }\\n    beyondThreshold = (deviation >= deviationAmountThreshold);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/UniswapAnchoredView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n// Compound Finance's oracle interface\\ninterface UniswapAnchoredView {\\n  function price(string memory symbol) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/tests/MockCompoundOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../interfaces/UniswapAnchoredView.sol\\\";\\n\\ncontract MockCompoundOracle is UniswapAnchoredView {\\n  struct OracleDetails {\\n    uint256 price;\\n    uint256 decimals;\\n  }\\n\\n  mapping(string => OracleDetails) s_oracleDetails;\\n\\n  function price(string memory symbol) external view override returns (uint256) {\\n    return s_oracleDetails[symbol].price;\\n  }\\n\\n  function setPrice(\\n    string memory symbol,\\n    uint256 newPrice,\\n    uint256 newDecimals\\n  ) public {\\n    OracleDetails memory details = s_oracleDetails[symbol];\\n    details.price = newPrice;\\n    details.decimals = newDecimals;\\n    s_oracleDetails[symbol] = details;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/tests/MockV3Aggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../interfaces/AggregatorV2V3Interface.sol\\\";\\n\\n/**\\n * @title MockV3Aggregator\\n * @notice Based on the FluxAggregator contract\\n * @notice Use this contract when you need to test\\n * other contract's ability to read data from an\\n * aggregator contract, but how the aggregator got\\n * its answer is unimportant\\n */\\ncontract MockV3Aggregator is AggregatorV2V3Interface {\\n  uint256 public constant override version = 0;\\n\\n  uint8 public override decimals;\\n  int256 public override latestAnswer;\\n  uint256 public override latestTimestamp;\\n  uint256 public override latestRound;\\n\\n  mapping(uint256 => int256) public override getAnswer;\\n  mapping(uint256 => uint256) public override getTimestamp;\\n  mapping(uint256 => uint256) private getStartedAt;\\n\\n  constructor(uint8 _decimals, int256 _initialAnswer) {\\n    decimals = _decimals;\\n    updateAnswer(_initialAnswer);\\n  }\\n\\n  function updateAnswer(int256 _answer) public {\\n    latestAnswer = _answer;\\n    latestTimestamp = block.timestamp;\\n    latestRound++;\\n    getAnswer[latestRound] = _answer;\\n    getTimestamp[latestRound] = block.timestamp;\\n    getStartedAt[latestRound] = block.timestamp;\\n  }\\n\\n  function updateRoundData(\\n    uint80 _roundId,\\n    int256 _answer,\\n    uint256 _timestamp,\\n    uint256 _startedAt\\n  ) public {\\n    latestRound = _roundId;\\n    latestAnswer = _answer;\\n    latestTimestamp = _timestamp;\\n    getAnswer[latestRound] = _answer;\\n    getTimestamp[latestRound] = _timestamp;\\n    getStartedAt[latestRound] = _startedAt;\\n  }\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    override\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);\\n  }\\n\\n  function latestRoundData()\\n    external\\n    view\\n    override\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    return (\\n      uint80(latestRound),\\n      getAnswer[latestRound],\\n      getStartedAt[latestRound],\\n      getTimestamp[latestRound],\\n      uint80(latestRound)\\n    );\\n  }\\n\\n  function description() external pure override returns (string memory) {\\n    return \\\"v0.6/tests/MockV3Aggregator.sol\\\";\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/FeedRegistryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./AggregatorV2V3Interface.sol\\\";\\n\\ninterface FeedRegistryInterface {\\n  struct Phase {\\n    uint16 phaseId;\\n    uint80 startingAggregatorRoundId;\\n    uint80 endingAggregatorRoundId;\\n  }\\n\\n  event FeedProposed(\\n    address indexed asset,\\n    address indexed denomination,\\n    address indexed proposedAggregator,\\n    address currentAggregator,\\n    address sender\\n  );\\n  event FeedConfirmed(\\n    address indexed asset,\\n    address indexed denomination,\\n    address indexed latestAggregator,\\n    address previousAggregator,\\n    uint16 nextPhaseId,\\n    address sender\\n  );\\n\\n  // V3 AggregatorV3Interface\\n\\n  function decimals(address base, address quote) external view returns (uint8);\\n\\n  function description(address base, address quote) external view returns (string memory);\\n\\n  function version(address base, address quote) external view returns (uint256);\\n\\n  function latestRoundData(address base, address quote)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function getRoundData(\\n    address base,\\n    address quote,\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  // V2 AggregatorInterface\\n\\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\\n\\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\\n\\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\\n\\n  function getAnswer(\\n    address base,\\n    address quote,\\n    uint256 roundId\\n  ) external view returns (int256 answer);\\n\\n  function getTimestamp(\\n    address base,\\n    address quote,\\n    uint256 roundId\\n  ) external view returns (uint256 timestamp);\\n\\n  // Registry getters\\n\\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\\n\\n  function getPhaseFeed(\\n    address base,\\n    address quote,\\n    uint16 phaseId\\n  ) external view returns (AggregatorV2V3Interface aggregator);\\n\\n  function isFeedEnabled(address aggregator) external view returns (bool);\\n\\n  function getPhase(\\n    address base,\\n    address quote,\\n    uint16 phaseId\\n  ) external view returns (Phase memory phase);\\n\\n  // Round helpers\\n\\n  function getRoundFeed(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  ) external view returns (AggregatorV2V3Interface aggregator);\\n\\n  function getPhaseRange(\\n    address base,\\n    address quote,\\n    uint16 phaseId\\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\\n\\n  function getPreviousRoundId(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  ) external view returns (uint80 previousRoundId);\\n\\n  function getNextRoundId(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  ) external view returns (uint80 nextRoundId);\\n\\n  // Feed management\\n\\n  function proposeFeed(\\n    address base,\\n    address quote,\\n    address aggregator\\n  ) external;\\n\\n  function confirmFeed(\\n    address base,\\n    address quote,\\n    address aggregator\\n  ) external;\\n\\n  // Proposed aggregator\\n\\n  function getProposedFeed(address base, address quote)\\n    external\\n    view\\n    returns (AggregatorV2V3Interface proposedAggregator);\\n\\n  function proposedGetRoundData(\\n    address base,\\n    address quote,\\n    uint80 roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function proposedLatestRoundData(address base, address quote)\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  // Phases\\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/tests/MockV2Aggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../interfaces/AggregatorInterface.sol\\\";\\n\\n/**\\n * @title MockV2Aggregator\\n * @notice Based on the HistoricAggregator contract\\n * @notice Use this contract when you need to test\\n * other contract's ability to read data from an\\n * aggregator contract, but how the aggregator got\\n * its answer is unimportant\\n */\\ncontract MockV2Aggregator is AggregatorInterface {\\n  int256 public override latestAnswer;\\n  uint256 public override latestTimestamp;\\n  uint256 public override latestRound;\\n\\n  mapping(uint256 => int256) public override getAnswer;\\n  mapping(uint256 => uint256) public override getTimestamp;\\n  mapping(uint256 => uint256) private getStartedAt;\\n\\n  constructor(int256 _initialAnswer) public {\\n    updateAnswer(_initialAnswer);\\n  }\\n\\n  function updateAnswer(int256 _answer) public {\\n    latestAnswer = _answer;\\n    latestTimestamp = block.timestamp;\\n    latestRound++;\\n    getAnswer[latestRound] = _answer;\\n    getTimestamp[latestRound] = block.timestamp;\\n  }\\n\\n  function updateRoundData(\\n    uint256 _roundId,\\n    int256 _answer,\\n    uint256 _timestamp,\\n    uint256 _startedAt\\n  ) public {\\n    latestRound = _roundId;\\n    latestAnswer = _answer;\\n    latestTimestamp = _timestamp;\\n    getAnswer[latestRound] = _answer;\\n    getTimestamp[latestRound] = _timestamp;\\n    getStartedAt[latestRound] = _startedAt;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/AggregatorProxyInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./AggregatorV2V3Interface.sol\\\";\\n\\ninterface AggregatorProxyInterface is AggregatorV2V3Interface {\\n  function phaseAggregators(uint16 phaseId) external view returns (address);\\n\\n  function phaseId() external view returns (uint16);\\n\\n  function proposedAggregator() external view returns (address);\\n\\n  function proposedGetRoundData(uint80 roundId)\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function proposedLatestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function aggregator() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/dev/AggregatorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ConfirmedOwner.sol\\\";\\nimport \\\"../interfaces/AggregatorProxyInterface.sol\\\";\\n\\n/**\\n * @title A trusted proxy for updating where current answers are read from\\n * @notice This contract provides a consistent address for the\\n * CurrentAnwerInterface but delegates where it reads from to the owner, who is\\n * trusted to update it.\\n */\\ncontract AggregatorProxy is AggregatorProxyInterface, ConfirmedOwner {\\n  struct Phase {\\n    uint16 id;\\n    AggregatorProxyInterface aggregator;\\n  }\\n  AggregatorProxyInterface private s_proposedAggregator;\\n  mapping(uint16 => AggregatorProxyInterface) private s_phaseAggregators;\\n  Phase private s_currentPhase;\\n\\n  uint256 private constant PHASE_OFFSET = 64;\\n  uint256 private constant PHASE_SIZE = 16;\\n  uint256 private constant MAX_ID = 2**(PHASE_OFFSET + PHASE_SIZE) - 1;\\n\\n  event AggregatorProposed(address indexed current, address indexed proposed);\\n  event AggregatorConfirmed(address indexed previous, address indexed latest);\\n\\n  constructor(address aggregatorAddress) ConfirmedOwner(msg.sender) {\\n    setAggregator(aggregatorAddress);\\n  }\\n\\n  /**\\n   * @notice Reads the current answer from aggregator delegated to.\\n   *\\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestAnswer() public view virtual override returns (int256 answer) {\\n    return s_currentPhase.aggregator.latestAnswer();\\n  }\\n\\n  /**\\n   * @notice Reads the last updated height from aggregator delegated to.\\n   *\\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestTimestamp() public view virtual override returns (uint256 updatedAt) {\\n    return s_currentPhase.aggregator.latestTimestamp();\\n  }\\n\\n  /**\\n   * @notice get past rounds answers\\n   * @param roundId the answer number to retrieve the answer for\\n   *\\n   * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended getRoundData\\n   * instead which includes better verification information.\\n   */\\n  function getAnswer(uint256 roundId) public view virtual override returns (int256 answer) {\\n    if (roundId > MAX_ID) return 0;\\n\\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(roundId);\\n    AggregatorProxyInterface aggregator = s_phaseAggregators[phaseId];\\n    if (address(aggregator) == address(0)) return 0;\\n\\n    return aggregator.getAnswer(aggregatorRoundId);\\n  }\\n\\n  /**\\n   * @notice get block timestamp when an answer was last updated\\n   * @param roundId the answer number to retrieve the updated timestamp for\\n   *\\n   * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended getRoundData\\n   * instead which includes better verification information.\\n   */\\n  function getTimestamp(uint256 roundId) public view virtual override returns (uint256 updatedAt) {\\n    if (roundId > MAX_ID) return 0;\\n\\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(roundId);\\n    AggregatorProxyInterface aggregator = s_phaseAggregators[phaseId];\\n    if (address(aggregator) == address(0)) return 0;\\n\\n    return aggregator.getTimestamp(aggregatorRoundId);\\n  }\\n\\n  /**\\n   * @notice get the latest completed round where the answer was updated. This\\n   * ID includes the proxy's phase, to make sure round IDs increase even when\\n   * switching to a newly deployed aggregator.\\n   *\\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n   * answer has been reached, it will simply return 0. Either wait to point to\\n   * an already answered Aggregator or use the recommended latestRoundData\\n   * instead which includes better verification information.\\n   */\\n  function latestRound() public view virtual override returns (uint256 roundId) {\\n    Phase memory phase = s_currentPhase; // cache storage reads\\n    return addPhase(phase.id, uint64(phase.aggregator.latestRound()));\\n  }\\n\\n  /**\\n   * @notice get data about a round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @param roundId the requested round ID as presented through the proxy, this\\n   * is made up of the aggregator's round ID with the phase ID encoded in the\\n   * two highest order bytes\\n   * @return id is the round ID from the aggregator for which the data was\\n   * retrieved combined with an phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function getRoundData(uint80 roundId)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(roundId);\\n\\n    (id, answer, startedAt, updatedAt, answeredInRound) = s_phaseAggregators[phaseId].getRoundData(aggregatorRoundId);\\n\\n    return addPhaseIds(id, answer, startedAt, updatedAt, answeredInRound, phaseId);\\n  }\\n\\n  /**\\n   * @notice get data about the latest round. Consumers are encouraged to check\\n   * that they're receiving fresh data by inspecting the updatedAt and\\n   * answeredInRound return values.\\n   * Note that different underlying implementations of AggregatorV3Interface\\n   * have slightly different semantics for some of the return values. Consumers\\n   * should determine what implementations they expect to receive\\n   * data from and validate that they can properly handle return data from all\\n   * of them.\\n   * @return id is the round ID from the aggregator for which the data was\\n   * retrieved combined with an phase to ensure that round IDs get larger as\\n   * time moves forward.\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @dev Note that answer and updatedAt may change between queries.\\n   */\\n  function latestRoundData()\\n    public\\n    view\\n    virtual\\n    override\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    Phase memory current = s_currentPhase; // cache storage reads\\n\\n    (id, answer, startedAt, updatedAt, answeredInRound) = current.aggregator.latestRoundData();\\n\\n    return addPhaseIds(id, answer, startedAt, updatedAt, answeredInRound, current.id);\\n  }\\n\\n  /**\\n   * @notice Used if an aggregator contract has been proposed.\\n   * @param roundId the round ID to retrieve the round data for\\n   * @return id is the round ID for which data was retrieved\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   */\\n  function proposedGetRoundData(uint80 roundId)\\n    external\\n    view\\n    virtual\\n    override\\n    hasProposal\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    return s_proposedAggregator.getRoundData(roundId);\\n  }\\n\\n  /**\\n   * @notice Used if an aggregator contract has been proposed.\\n   * @return id is the round ID for which data was retrieved\\n   * @return answer is the answer for the given round\\n   * @return startedAt is the timestamp when the round was started.\\n   * (Only some AggregatorV3Interface implementations return meaningful values)\\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\\n   * answer was last computed)\\n   * @return answeredInRound is the round ID of the round in which the answer\\n   * was computed.\\n   */\\n  function proposedLatestRoundData()\\n    external\\n    view\\n    virtual\\n    override\\n    hasProposal\\n    returns (\\n      uint80 id,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n  {\\n    return s_proposedAggregator.latestRoundData();\\n  }\\n\\n  /**\\n   * @notice returns the current phase's aggregator address.\\n   */\\n  function aggregator() external view override returns (address) {\\n    return address(s_currentPhase.aggregator);\\n  }\\n\\n  /**\\n   * @notice returns the current phase's ID.\\n   */\\n  function phaseId() external view override returns (uint16) {\\n    return s_currentPhase.id;\\n  }\\n\\n  /**\\n   * @notice represents the number of decimals the aggregator responses represent.\\n   */\\n  function decimals() external view override returns (uint8) {\\n    return s_currentPhase.aggregator.decimals();\\n  }\\n\\n  /**\\n   * @notice the version number representing the type of aggregator the proxy\\n   * points to.\\n   */\\n  function version() external view override returns (uint256) {\\n    return s_currentPhase.aggregator.version();\\n  }\\n\\n  /**\\n   * @notice returns the description of the aggregator the proxy points to.\\n   */\\n  function description() external view override returns (string memory) {\\n    return s_currentPhase.aggregator.description();\\n  }\\n\\n  /**\\n   * @notice returns the current proposed aggregator\\n   */\\n  function proposedAggregator() external view override returns (address) {\\n    return address(s_proposedAggregator);\\n  }\\n\\n  /**\\n   * @notice return a phase aggregator using the phaseId\\n   *\\n   * @param phaseId uint16\\n   */\\n  function phaseAggregators(uint16 phaseId) external view override returns (address) {\\n    return address(s_phaseAggregators[phaseId]);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to propose a new address for the aggregator\\n   * @param aggregatorAddress The new address for the aggregator contract\\n   */\\n  function proposeAggregator(address aggregatorAddress) external onlyOwner {\\n    s_proposedAggregator = AggregatorProxyInterface(aggregatorAddress);\\n    emit AggregatorProposed(address(s_currentPhase.aggregator), aggregatorAddress);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to confirm and change the address\\n   * to the proposed aggregator\\n   * @dev Reverts if the given address doesn't match what was previously\\n   * proposed\\n   * @param aggregatorAddress The new address for the aggregator contract\\n   */\\n  function confirmAggregator(address aggregatorAddress) external onlyOwner {\\n    require(aggregatorAddress == address(s_proposedAggregator), \\\"Invalid proposed aggregator\\\");\\n    address previousAggregator = address(s_currentPhase.aggregator);\\n    delete s_proposedAggregator;\\n    setAggregator(aggregatorAddress);\\n    emit AggregatorConfirmed(previousAggregator, aggregatorAddress);\\n  }\\n\\n  /*\\n   * Internal\\n   */\\n\\n  function setAggregator(address aggregatorAddress) internal {\\n    uint16 id = s_currentPhase.id + 1;\\n    s_currentPhase = Phase(id, AggregatorProxyInterface(aggregatorAddress));\\n    s_phaseAggregators[id] = AggregatorProxyInterface(aggregatorAddress);\\n  }\\n\\n  function addPhase(uint16 phase, uint64 originalId) internal pure returns (uint80) {\\n    return uint80((uint256(phase) << PHASE_OFFSET) | originalId);\\n  }\\n\\n  function parseIds(uint256 roundId) internal pure returns (uint16, uint64) {\\n    uint16 phaseId = uint16(roundId >> PHASE_OFFSET);\\n    uint64 aggregatorRoundId = uint64(roundId);\\n\\n    return (phaseId, aggregatorRoundId);\\n  }\\n\\n  function addPhaseIds(\\n    uint80 roundId,\\n    int256 answer,\\n    uint256 startedAt,\\n    uint256 updatedAt,\\n    uint80 answeredInRound,\\n    uint16 phaseId\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint80,\\n      int256,\\n      uint256,\\n      uint256,\\n      uint80\\n    )\\n  {\\n    return (\\n      addPhase(phaseId, uint64(roundId)),\\n      answer,\\n      startedAt,\\n      updatedAt,\\n      addPhase(phaseId, uint64(answeredInRound))\\n    );\\n  }\\n\\n  /*\\n   * Modifiers\\n   */\\n\\n  modifier hasProposal() {\\n    require(address(s_proposedAggregator) != address(0), \\\"No proposed aggregator present\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/ChainlinkClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./Chainlink.sol\\\";\\nimport \\\"./interfaces/ENSInterface.sol\\\";\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"./interfaces/ChainlinkRequestInterface.sol\\\";\\nimport \\\"./interfaces/OperatorInterface.sol\\\";\\nimport \\\"./interfaces/PointerInterface.sol\\\";\\nimport {ENSResolver as ENSResolver_Chainlink} from \\\"./vendor/ENSResolver.sol\\\";\\n\\n/**\\n * @title The ChainlinkClient contract\\n * @notice Contract writers can inherit this contract in order to create requests for the\\n * Chainlink network\\n */\\nabstract contract ChainlinkClient {\\n  using Chainlink for Chainlink.Request;\\n\\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\\n  uint256 private constant AMOUNT_OVERRIDE = 0;\\n  address private constant SENDER_OVERRIDE = address(0);\\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\\\"link\\\");\\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\\\"oracle\\\");\\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\\n\\n  ENSInterface private s_ens;\\n  bytes32 private s_ensNode;\\n  LinkTokenInterface private s_link;\\n  OperatorInterface private s_oracle;\\n  uint256 private s_requestCount = 1;\\n  mapping(bytes32 => address) private s_pendingRequests;\\n\\n  event ChainlinkRequested(bytes32 indexed id);\\n  event ChainlinkFulfilled(bytes32 indexed id);\\n  event ChainlinkCancelled(bytes32 indexed id);\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackAddr address to operate the callback on\\n   * @param callbackFunctionSignature function signature to use for the callback\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildChainlinkRequest(\\n    bytes32 specId,\\n    address callbackAddr,\\n    bytes4 callbackFunctionSignature\\n  ) internal pure returns (Chainlink.Request memory) {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a request that can hold additional parameters\\n   * @param specId The Job Specification ID that the request will be created for\\n   * @param callbackFunctionSignature function signature to use for the callback\\n   * @return A Chainlink Request struct in memory\\n   */\\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\\n    internal\\n    view\\n    returns (Chainlink.Request memory)\\n  {\\n    Chainlink.Request memory req;\\n    return req.initialize(specId, address(this), callbackFunctionSignature);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendChainlinkRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  ) internal returns (bytes32 requestId) {\\n    uint256 nonce = s_requestCount;\\n    s_requestCount = nonce + 1;\\n    bytes memory encodedRequest = abi.encodeWithSelector(\\n      ChainlinkRequestInterface.oracleRequest.selector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      address(this),\\n      req.callbackFunctionId,\\n      nonce,\\n      ORACLE_ARGS_VERSION,\\n      req.buf.buf\\n    );\\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the stored oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\\n  }\\n\\n  /**\\n   * @notice Creates a Chainlink request to the specified oracle address\\n   * @dev This function supports multi-word response\\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\\n   * send LINK which creates a request on the target oracle contract.\\n   * Emits ChainlinkRequested event.\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param req The initialized Chainlink Request\\n   * @param payment The amount of LINK to send for the request\\n   * @return requestId The request ID\\n   */\\n  function sendOperatorRequestTo(\\n    address oracleAddress,\\n    Chainlink.Request memory req,\\n    uint256 payment\\n  ) internal returns (bytes32 requestId) {\\n    uint256 nonce = s_requestCount;\\n    s_requestCount = nonce + 1;\\n    bytes memory encodedRequest = abi.encodeWithSelector(\\n      OperatorInterface.operatorRequest.selector,\\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\\n      req.id,\\n      req.callbackFunctionId,\\n      nonce,\\n      OPERATOR_ARGS_VERSION,\\n      req.buf.buf\\n    );\\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\\n  }\\n\\n  /**\\n   * @notice Make a request to an oracle\\n   * @param oracleAddress The address of the oracle for the request\\n   * @param nonce used to generate the request ID\\n   * @param payment The amount of LINK to send for the request\\n   * @param encodedRequest data encoded for request type specific format\\n   * @return requestId The request ID\\n   */\\n  function _rawRequest(\\n    address oracleAddress,\\n    uint256 nonce,\\n    uint256 payment,\\n    bytes memory encodedRequest\\n  ) private returns (bytes32 requestId) {\\n    requestId = keccak256(abi.encodePacked(this, nonce));\\n    s_pendingRequests[requestId] = oracleAddress;\\n    emit ChainlinkRequested(requestId);\\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \\\"unable to transferAndCall to oracle\\\");\\n  }\\n\\n  /**\\n   * @notice Allows a request to be cancelled if it has not been fulfilled\\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\\n   * Deletes the request from the `pendingRequests` mapping.\\n   * Emits ChainlinkCancelled event.\\n   * @param requestId The request ID\\n   * @param payment The amount of LINK sent for the request\\n   * @param callbackFunc The callback function specified for the request\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelChainlinkRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  ) internal {\\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\\n    delete s_pendingRequests[requestId];\\n    emit ChainlinkCancelled(requestId);\\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\\n  }\\n\\n  /**\\n   * @notice the next request count to be used in generating a nonce\\n   * @dev starts at 1 in order to ensure consistent gas cost\\n   * @return returns the next request count to be used in a nonce\\n   */\\n  function getNextRequestCount() internal view returns (uint256) {\\n    return s_requestCount;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle address\\n   * @param oracleAddress The address of the oracle contract\\n   */\\n  function setChainlinkOracle(address oracleAddress) internal {\\n    s_oracle = OperatorInterface(oracleAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the LINK token address\\n   * @param linkAddress The address of the LINK token contract\\n   */\\n  function setChainlinkToken(address linkAddress) internal {\\n    s_link = LinkTokenInterface(linkAddress);\\n  }\\n\\n  /**\\n   * @notice Sets the Chainlink token address for the public\\n   * network as given by the Pointer contract\\n   */\\n  function setPublicChainlinkToken() internal {\\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the LINK token\\n   * @return The address of the LINK token\\n   */\\n  function chainlinkTokenAddress() internal view returns (address) {\\n    return address(s_link);\\n  }\\n\\n  /**\\n   * @notice Retrieves the stored address of the oracle contract\\n   * @return The address of the oracle contract\\n   */\\n  function chainlinkOracleAddress() internal view returns (address) {\\n    return address(s_oracle);\\n  }\\n\\n  /**\\n   * @notice Allows for a request which was created on another contract to be fulfilled\\n   * on this contract\\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\\n   * @param requestId The request ID used for the response\\n   */\\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\\n    s_pendingRequests[requestId] = oracleAddress;\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\\n   * @dev Accounts for subnodes having different resolvers\\n   * @param ensAddress The address of the ENS contract\\n   * @param node The ENS node hash\\n   */\\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\\n    s_ens = ENSInterface(ensAddress);\\n    s_ensNode = node;\\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\\n    setChainlinkToken(resolver.addr(linkSubnode));\\n    updateChainlinkOracleWithENS();\\n  }\\n\\n  /**\\n   * @notice Sets the stored oracle contract with the address resolved by ENS\\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\\n   */\\n  function updateChainlinkOracleWithENS() internal {\\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\\n    setChainlinkOracle(resolver.addr(oracleSubnode));\\n  }\\n\\n  /**\\n   * @notice Ensures that the fulfillment is valid for this contract\\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\\n   * @param requestId The request ID for fulfillment\\n   */\\n  function validateChainlinkCallback(bytes32 requestId)\\n    internal\\n    recordChainlinkFulfillment(requestId)\\n  // solhint-disable-next-line no-empty-blocks\\n  {\\n\\n  }\\n\\n  /**\\n   * @dev Reverts if the sender is not the oracle of the request.\\n   * Emits ChainlinkFulfilled event.\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\\n    require(msg.sender == s_pendingRequests[requestId], \\\"Source must be the oracle of the request\\\");\\n    delete s_pendingRequests[requestId];\\n    emit ChainlinkFulfilled(requestId);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the request is already pending\\n   * @param requestId The request ID for fulfillment\\n   */\\n  modifier notPendingRequest(bytes32 requestId) {\\n    require(s_pendingRequests[requestId] == address(0), \\\"Request is already pending\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/Chainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport {CBORChainlink} from \\\"./vendor/CBORChainlink.sol\\\";\\nimport {BufferChainlink} from \\\"./vendor/BufferChainlink.sol\\\";\\n\\n/**\\n * @title Library for common Chainlink functions\\n * @dev Uses imported CBOR library for encoding to buffer\\n */\\nlibrary Chainlink {\\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\\n\\n  using CBORChainlink for BufferChainlink.buffer;\\n\\n  struct Request {\\n    bytes32 id;\\n    address callbackAddress;\\n    bytes4 callbackFunctionId;\\n    uint256 nonce;\\n    BufferChainlink.buffer buf;\\n  }\\n\\n  /**\\n   * @notice Initializes a Chainlink request\\n   * @dev Sets the ID, callback address, and callback function signature on the request\\n   * @param self The uninitialized request\\n   * @param jobId The Job Specification ID\\n   * @param callbackAddr The callback address\\n   * @param callbackFunc The callback function signature\\n   * @return The initialized request\\n   */\\n  function initialize(\\n    Request memory self,\\n    bytes32 jobId,\\n    address callbackAddr,\\n    bytes4 callbackFunc\\n  ) internal pure returns (Chainlink.Request memory) {\\n    BufferChainlink.init(self.buf, defaultBufferSize);\\n    self.id = jobId;\\n    self.callbackAddress = callbackAddr;\\n    self.callbackFunctionId = callbackFunc;\\n    return self;\\n  }\\n\\n  /**\\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\\n   * @param self The initialized request\\n   * @param data The CBOR data\\n   */\\n  function setBuffer(Request memory self, bytes memory data) internal pure {\\n    BufferChainlink.init(self.buf, data.length);\\n    BufferChainlink.append(self.buf, data);\\n  }\\n\\n  /**\\n   * @notice Adds a string value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The string value to add\\n   */\\n  function add(\\n    Request memory self,\\n    string memory key,\\n    string memory value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeString(value);\\n  }\\n\\n  /**\\n   * @notice Adds a bytes value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The bytes value to add\\n   */\\n  function addBytes(\\n    Request memory self,\\n    string memory key,\\n    bytes memory value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeBytes(value);\\n  }\\n\\n  /**\\n   * @notice Adds a int256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The int256 value to add\\n   */\\n  function addInt(\\n    Request memory self,\\n    string memory key,\\n    int256 value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds a uint256 value to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param value The uint256 value to add\\n   */\\n  function addUint(\\n    Request memory self,\\n    string memory key,\\n    uint256 value\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.encodeUInt(value);\\n  }\\n\\n  /**\\n   * @notice Adds an array of strings to the request with a given key name\\n   * @param self The initialized request\\n   * @param key The name of the key\\n   * @param values The array of string values to add\\n   */\\n  function addStringArray(\\n    Request memory self,\\n    string memory key,\\n    string[] memory values\\n  ) internal pure {\\n    self.buf.encodeString(key);\\n    self.buf.startArray();\\n    for (uint256 i = 0; i < values.length; i++) {\\n      self.buf.encodeString(values[i]);\\n    }\\n    self.buf.endSequence();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/ENSInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface ENSInterface {\\n  // Logged when the owner of a node assigns a new owner to a subnode.\\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n  // Logged when the owner of a node transfers ownership to a new account.\\n  event Transfer(bytes32 indexed node, address owner);\\n\\n  // Logged when the resolver for a node changes.\\n  event NewResolver(bytes32 indexed node, address resolver);\\n\\n  // Logged when the TTL of a node changes\\n  event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n  function setSubnodeOwner(\\n    bytes32 node,\\n    bytes32 label,\\n    address owner\\n  ) external;\\n\\n  function setResolver(bytes32 node, address resolver) external;\\n\\n  function setOwner(bytes32 node, address owner) external;\\n\\n  function setTTL(bytes32 node, uint64 ttl) external;\\n\\n  function owner(bytes32 node) external view returns (address);\\n\\n  function resolver(bytes32 node) external view returns (address);\\n\\n  function ttl(bytes32 node) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/interfaces/PointerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface PointerInterface {\\n  function getAddress() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/ENSResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nabstract contract ENSResolver {\\n  function addr(bytes32 node) public view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/CBORChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.19;\\n\\nimport {BufferChainlink} from \\\"./BufferChainlink.sol\\\";\\n\\nlibrary CBORChainlink {\\n  using BufferChainlink for BufferChainlink.buffer;\\n\\n  uint8 private constant MAJOR_TYPE_INT = 0;\\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\\n  uint8 private constant MAJOR_TYPE_STRING = 3;\\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n  uint8 private constant MAJOR_TYPE_MAP = 5;\\n  uint8 private constant MAJOR_TYPE_TAG = 6;\\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\\n    if(value <= 23) {\\n      buf.appendUint8(uint8((major << 5) | value));\\n    } else if (value <= 0xFF) {\\n      buf.appendUint8(uint8((major << 5) | 24));\\n      buf.appendInt(value, 1);\\n    } else if (value <= 0xFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 25));\\n      buf.appendInt(value, 2);\\n    } else if (value <= 0xFFFFFFFF) {\\n      buf.appendUint8(uint8((major << 5) | 26));\\n      buf.appendInt(value, 4);\\n    } else {\\n      buf.appendUint8(uint8((major << 5) | 27));\\n      buf.appendInt(value, 8);\\n    }\\n  }\\n\\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\\n    buf.appendUint8(uint8((major << 5) | 31));\\n  }\\n\\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\\n    if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, value);\\n    } else {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\\n    }\\n  }\\n\\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\\n    if(value < -0x10000000000000000) {\\n      encodeSignedBigNum(buf, value);\\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\\n      encodeBigNum(buf, uint(value));\\n    } else if(value >= 0) {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\\n    } else {\\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\\n    }\\n  }\\n\\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\\n    buf.append(value);\\n  }\\n\\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n    encodeBytes(buf, abi.encode(value));\\n  }\\n\\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\\n  }\\n\\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\\n    buf.append(bytes(value));\\n  }\\n\\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n  }\\n\\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n  }\\n\\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/vendor/BufferChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev A library for working with mutable byte buffers in Solidity.\\n *\\n * Byte buffers are mutable and expandable, and provide a variety of primitives\\n * for writing to them. At any time you can fetch a bytes object containing the\\n * current contents of the buffer. The bytes object should not be stored between\\n * operations, as it may change due to resizing of the buffer.\\n */\\nlibrary BufferChainlink {\\n  /**\\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n   *      a capacity. The capacity may be longer than the current value, in\\n   *      which case it can be extended without the need to allocate more memory.\\n   */\\n  struct buffer {\\n    bytes buf;\\n    uint256 capacity;\\n  }\\n\\n  /**\\n   * @dev Initializes a buffer with an initial capacity.\\n   * @param buf The buffer to initialize.\\n   * @param capacity The number of bytes of space to allocate the buffer.\\n   * @return The buffer, for chaining.\\n   */\\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\\n    if (capacity % 32 != 0) {\\n      capacity += 32 - (capacity % 32);\\n    }\\n    // Allocate space for the buffer data\\n    buf.capacity = capacity;\\n    assembly {\\n      let ptr := mload(0x40)\\n      mstore(buf, ptr)\\n      mstore(ptr, 0)\\n      mstore(0x40, add(32, add(ptr, capacity)))\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Initializes a new buffer from an existing bytes object.\\n   *      Changes to the buffer may mutate the original value.\\n   * @param b The bytes object to initialize the buffer with.\\n   * @return A new buffer.\\n   */\\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\\n    buffer memory buf;\\n    buf.buf = b;\\n    buf.capacity = b.length;\\n    return buf;\\n  }\\n\\n  function resize(buffer memory buf, uint256 capacity) private pure {\\n    bytes memory oldbuf = buf.buf;\\n    init(buf, capacity);\\n    append(buf, oldbuf);\\n  }\\n\\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\\n    if (a > b) {\\n      return a;\\n    }\\n    return b;\\n  }\\n\\n  /**\\n   * @dev Sets buffer length to 0.\\n   * @param buf The buffer to truncate.\\n   * @return The original buffer, for chaining..\\n   */\\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n    assembly {\\n      let bufptr := mload(buf)\\n      mstore(bufptr, 0)\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The start offset to write to.\\n   * @param data The data to append.\\n   * @param len The number of bytes to copy.\\n   * @return The original buffer, for chaining.\\n   */\\n  function write(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes memory data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    require(len <= data.length);\\n\\n    if (off + len > buf.capacity) {\\n      resize(buf, max(buf.capacity, len + off) * 2);\\n    }\\n\\n    uint256 dest;\\n    uint256 src;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Start address = buffer address + offset + sizeof(buffer length)\\n      dest := add(add(bufptr, 32), off)\\n      // Update buffer length if we're extending it\\n      if gt(add(len, off), buflen) {\\n        mstore(bufptr, add(len, off))\\n      }\\n      src := add(data, 32)\\n    }\\n\\n    // Copy word-length chunks while possible\\n    for (; len >= 32; len -= 32) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n      dest += 32;\\n      src += 32;\\n    }\\n\\n    // Copy remaining bytes\\n    uint256 mask = 256**(32 - len) - 1;\\n    assembly {\\n      let srcpart := and(mload(src), not(mask))\\n      let destpart := and(mload(dest), mask)\\n      mstore(dest, or(destpart, srcpart))\\n    }\\n\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @param len The number of bytes to copy.\\n   * @return The original buffer, for chaining.\\n   */\\n  function append(\\n    buffer memory buf,\\n    bytes memory data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, len);\\n  }\\n\\n  /**\\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, data.length);\\n  }\\n\\n  /**\\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write the byte at.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeUint8(\\n    buffer memory buf,\\n    uint256 off,\\n    uint8 data\\n  ) internal pure returns (buffer memory) {\\n    if (off >= buf.capacity) {\\n      resize(buf, buf.capacity * 2);\\n    }\\n\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Length of existing buffer data\\n      let buflen := mload(bufptr)\\n      // Address = buffer address + sizeof(buffer length) + off\\n      let dest := add(add(bufptr, off), 32)\\n      mstore8(dest, data)\\n      // Update buffer length if we extended it\\n      if eq(off, buflen) {\\n        mstore(bufptr, add(buflen, 1))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\\n    return writeUint8(buf, buf.buf.length, data);\\n  }\\n\\n  /**\\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n   *      exceed the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @param len The number of bytes to write (left-aligned).\\n   * @return The original buffer, for chaining.\\n   */\\n  function write(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes32 data,\\n    uint256 len\\n  ) private pure returns (buffer memory) {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    uint256 mask = 256**len - 1;\\n    // Right-align data\\n    data = data >> (8 * (32 - len));\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Address = buffer address + sizeof(buffer length) + off + len\\n      let dest := add(add(bufptr, off), len)\\n      mstore(dest, or(and(mload(dest), not(mask)), data))\\n      // Update buffer length if we extended it\\n      if gt(add(off, len), mload(bufptr)) {\\n        mstore(bufptr, add(off, len))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n   *      capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeBytes20(\\n    buffer memory buf,\\n    uint256 off,\\n    bytes20 data\\n  ) internal pure returns (buffer memory) {\\n    return write(buf, off, bytes32(data), 20);\\n  }\\n\\n  /**\\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chhaining.\\n   */\\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, bytes32(data), 20);\\n  }\\n\\n  /**\\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer, for chaining.\\n   */\\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n    return write(buf, buf.buf.length, data, 32);\\n  }\\n\\n  /**\\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n   *      the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param off The offset to write at.\\n   * @param data The data to append.\\n   * @param len The number of bytes to write (right-aligned).\\n   * @return The original buffer, for chaining.\\n   */\\n  function writeInt(\\n    buffer memory buf,\\n    uint256 off,\\n    uint256 data,\\n    uint256 len\\n  ) private pure returns (buffer memory) {\\n    if (len + off > buf.capacity) {\\n      resize(buf, (len + off) * 2);\\n    }\\n\\n    uint256 mask = 256**len - 1;\\n    assembly {\\n      // Memory address of the buffer data\\n      let bufptr := mload(buf)\\n      // Address = buffer address + off + sizeof(buffer length) + len\\n      let dest := add(add(bufptr, off), len)\\n      mstore(dest, or(and(mload(dest), not(mask)), data))\\n      // Update buffer length if we extended it\\n      if gt(add(off, len), mload(bufptr)) {\\n        mstore(bufptr, add(off, len))\\n      }\\n    }\\n    return buf;\\n  }\\n\\n  /**\\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n   * exceed the capacity of the buffer.\\n   * @param buf The buffer to append to.\\n   * @param data The data to append.\\n   * @return The original buffer.\\n   */\\n  function appendInt(\\n    buffer memory buf,\\n    uint256 data,\\n    uint256 len\\n  ) internal pure returns (buffer memory) {\\n    return writeInt(buf, buf.buf.length, data, len);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/tests/MultiWordConsumer.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\nimport \\\"../ChainlinkClient.sol\\\";\\nimport \\\"../Chainlink.sol\\\";\\n\\ncontract MultiWordConsumer is ChainlinkClient {\\n  using Chainlink for Chainlink.Request;\\n\\n  bytes32 internal specId;\\n  bytes public currentPrice;\\n\\n  bytes32 public usd;\\n  bytes32 public eur;\\n  bytes32 public jpy;\\n\\n  uint256 public usdInt;\\n  uint256 public eurInt;\\n  uint256 public jpyInt;\\n\\n  event RequestFulfilled(\\n    bytes32 indexed requestId, // User-defined ID\\n    bytes indexed price\\n  );\\n\\n  event RequestMultipleFulfilled(bytes32 indexed requestId, bytes32 indexed usd, bytes32 indexed eur, bytes32 jpy);\\n\\n  event RequestMultipleFulfilledWithCustomURLs(\\n    bytes32 indexed requestId,\\n    uint256 indexed usd,\\n    uint256 indexed eur,\\n    uint256 jpy\\n  );\\n\\n  constructor(\\n    address _link,\\n    address _oracle,\\n    bytes32 _specId\\n  ) public {\\n    setChainlinkToken(_link);\\n    setChainlinkOracle(_oracle);\\n    specId = _specId;\\n  }\\n\\n  function setSpecID(bytes32 _specId) public {\\n    specId = _specId;\\n  }\\n\\n  function requestEthereumPrice(string memory _currency, uint256 _payment) public {\\n    Chainlink.Request memory req = buildOperatorRequest(specId, this.fulfillBytes.selector);\\n    sendOperatorRequest(req, _payment);\\n  }\\n\\n  function requestMultipleParameters(string memory _currency, uint256 _payment) public {\\n    Chainlink.Request memory req = buildOperatorRequest(specId, this.fulfillMultipleParameters.selector);\\n    sendOperatorRequest(req, _payment);\\n  }\\n\\n  function requestMultipleParametersWithCustomURLs(\\n    string memory _urlUSD,\\n    string memory _pathUSD,\\n    string memory _urlEUR,\\n    string memory _pathEUR,\\n    string memory _urlJPY,\\n    string memory _pathJPY,\\n    uint256 _payment\\n  ) public {\\n    Chainlink.Request memory req = buildOperatorRequest(specId, this.fulfillMultipleParametersWithCustomURLs.selector);\\n    req.add(\\\"urlUSD\\\", _urlUSD);\\n    req.add(\\\"pathUSD\\\", _pathUSD);\\n    req.add(\\\"urlEUR\\\", _urlEUR);\\n    req.add(\\\"pathEUR\\\", _pathEUR);\\n    req.add(\\\"urlJPY\\\", _urlJPY);\\n    req.add(\\\"pathJPY\\\", _pathJPY);\\n    sendOperatorRequest(req, _payment);\\n  }\\n\\n  function cancelRequest(\\n    address _oracle,\\n    bytes32 _requestId,\\n    uint256 _payment,\\n    bytes4 _callbackFunctionId,\\n    uint256 _expiration\\n  ) public {\\n    ChainlinkRequestInterface requested = ChainlinkRequestInterface(_oracle);\\n    requested.cancelOracleRequest(_requestId, _payment, _callbackFunctionId, _expiration);\\n  }\\n\\n  function withdrawLink() public {\\n    LinkTokenInterface _link = LinkTokenInterface(chainlinkTokenAddress());\\n    require(_link.transfer(msg.sender, _link.balanceOf(address(this))), \\\"Unable to transfer\\\");\\n  }\\n\\n  function addExternalRequest(address _oracle, bytes32 _requestId) external {\\n    addChainlinkExternalRequest(_oracle, _requestId);\\n  }\\n\\n  function fulfillMultipleParameters(\\n    bytes32 _requestId,\\n    bytes32 _usd,\\n    bytes32 _eur,\\n    bytes32 _jpy\\n  ) public recordChainlinkFulfillment(_requestId) {\\n    emit RequestMultipleFulfilled(_requestId, _usd, _eur, _jpy);\\n    usd = _usd;\\n    eur = _eur;\\n    jpy = _jpy;\\n  }\\n\\n  function fulfillMultipleParametersWithCustomURLs(\\n    bytes32 _requestId,\\n    uint256 _usd,\\n    uint256 _eur,\\n    uint256 _jpy\\n  ) public recordChainlinkFulfillment(_requestId) {\\n    emit RequestMultipleFulfilledWithCustomURLs(_requestId, _usd, _eur, _jpy);\\n    usdInt = _usd;\\n    eurInt = _eur;\\n    jpyInt = _jpy;\\n  }\\n\\n  function fulfillBytes(bytes32 _requestId, bytes memory _price) public recordChainlinkFulfillment(_requestId) {\\n    emit RequestFulfilled(_requestId, _price);\\n    currentPrice = _price;\\n  }\\n\\n  function publicGetNextRequestCount() external view returns (uint256) {\\n    return getNextRequestCount();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/tests/ChainlinkTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../Chainlink.sol\\\";\\nimport \\\"../vendor/CBORChainlink.sol\\\";\\nimport \\\"../vendor/BufferChainlink.sol\\\";\\n\\ncontract ChainlinkTestHelper {\\n  using Chainlink for Chainlink.Request;\\n  using CBORChainlink for BufferChainlink.buffer;\\n\\n  Chainlink.Request private req;\\n\\n  event RequestData(bytes payload);\\n\\n  function closeEvent() public {\\n    emit RequestData(req.buf.buf);\\n  }\\n\\n  function setBuffer(bytes memory data) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.setBuffer(data);\\n    req = r2;\\n  }\\n\\n  function add(string memory _key, string memory _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.add(_key, _value);\\n    req = r2;\\n  }\\n\\n  function addBytes(string memory _key, bytes memory _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addBytes(_key, _value);\\n    req = r2;\\n  }\\n\\n  function addInt(string memory _key, int256 _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addInt(_key, _value);\\n    req = r2;\\n  }\\n\\n  function addUint(string memory _key, uint256 _value) public {\\n    Chainlink.Request memory r2 = req;\\n    r2.addUint(_key, _value);\\n    req = r2;\\n  }\\n\\n  // Temporarily have method receive bytes32[] memory until experimental\\n  // string[] memory can be invoked from truffle tests.\\n  function addStringArray(string memory _key, bytes32[] memory _values) public {\\n    string[] memory strings = new string[](_values.length);\\n    for (uint256 i = 0; i < _values.length; i++) {\\n      strings[i] = bytes32ToString(_values[i]);\\n    }\\n    Chainlink.Request memory r2 = req;\\n    r2.addStringArray(_key, strings);\\n    req = r2;\\n  }\\n\\n  function bytes32ToString(bytes32 x) private pure returns (string memory) {\\n    bytes memory bytesString = new bytes(32);\\n    uint256 charCount = 0;\\n    for (uint256 j = 0; j < 32; j++) {\\n      bytes1 char = bytes1(bytes32(uint256(x) * 2**(8 * j)));\\n      if (char != 0) {\\n        bytesString[charCount] = char;\\n        charCount++;\\n      }\\n    }\\n    bytes memory bytesStringTrimmed = new bytes(charCount);\\n    for (uint256 j = 0; j < charCount; j++) {\\n      bytesStringTrimmed[j] = bytesString[j];\\n    }\\n    return string(bytesStringTrimmed);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/tests/Consumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ChainlinkClient.sol\\\";\\n\\ncontract Consumer is ChainlinkClient {\\n  using Chainlink for Chainlink.Request;\\n\\n  bytes32 internal specId;\\n  bytes32 public currentPrice;\\n  uint256 public currentPriceInt;\\n\\n  event RequestFulfilled(\\n    bytes32 indexed requestId, // User-defined ID\\n    bytes32 indexed price\\n  );\\n\\n  constructor(\\n    address _link,\\n    address _oracle,\\n    bytes32 _specId\\n  ) public {\\n    setChainlinkToken(_link);\\n    setChainlinkOracle(_oracle);\\n    specId = _specId;\\n  }\\n\\n  function setSpecID(bytes32 _specId) public {\\n    specId = _specId;\\n  }\\n\\n  function requestEthereumPrice(string memory _currency, uint256 _payment) public {\\n    Chainlink.Request memory req = buildOperatorRequest(specId, this.fulfill.selector);\\n    req.add(\\\"get\\\", \\\"https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR,JPY\\\");\\n    string[] memory path = new string[](1);\\n    path[0] = _currency;\\n    req.addStringArray(\\\"path\\\", path);\\n    // version 2\\n    sendChainlinkRequest(req, _payment);\\n  }\\n\\n  function requestMultipleParametersWithCustomURLs(\\n    string memory _urlUSD,\\n    string memory _pathUSD,\\n    uint256 _payment\\n  ) public {\\n    Chainlink.Request memory req = buildOperatorRequest(specId, this.fulfillParametersWithCustomURLs.selector);\\n    req.add(\\\"urlUSD\\\", _urlUSD);\\n    req.add(\\\"pathUSD\\\", _pathUSD);\\n    sendChainlinkRequest(req, _payment);\\n  }\\n\\n  function cancelRequest(\\n    address _oracle,\\n    bytes32 _requestId,\\n    uint256 _payment,\\n    bytes4 _callbackFunctionId,\\n    uint256 _expiration\\n  ) public {\\n    ChainlinkRequestInterface requested = ChainlinkRequestInterface(_oracle);\\n    requested.cancelOracleRequest(_requestId, _payment, _callbackFunctionId, _expiration);\\n  }\\n\\n  function withdrawLink() public {\\n    LinkTokenInterface _link = LinkTokenInterface(chainlinkTokenAddress());\\n    require(_link.transfer(msg.sender, _link.balanceOf(address(this))), \\\"Unable to transfer\\\");\\n  }\\n\\n  function addExternalRequest(address _oracle, bytes32 _requestId) external {\\n    addChainlinkExternalRequest(_oracle, _requestId);\\n  }\\n\\n  function fulfill(bytes32 _requestId, bytes32 _price) public recordChainlinkFulfillment(_requestId) {\\n    emit RequestFulfilled(_requestId, _price);\\n    currentPrice = _price;\\n  }\\n\\n  function fulfillParametersWithCustomURLs(bytes32 _requestId, uint256 _price)\\n    public\\n    recordChainlinkFulfillment(_requestId)\\n  {\\n    emit RequestFulfilled(_requestId, bytes32(_price));\\n    currentPriceInt = _price;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.7/tests/ChainlinkClientTestHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"../ChainlinkClient.sol\\\";\\nimport \\\"../vendor/SafeMathChainlink.sol\\\";\\n\\ncontract ChainlinkClientTestHelper is ChainlinkClient {\\n  using SafeMathChainlink for uint256;\\n\\n  constructor(address _link, address _oracle) {\\n    setChainlinkToken(_link);\\n    setChainlinkOracle(_oracle);\\n  }\\n\\n  event Request(bytes32 id, address callbackAddress, bytes4 callbackfunctionSelector, bytes data);\\n  event LinkAmount(uint256 amount);\\n\\n  function publicNewRequest(\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature\\n  ) public {\\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\\n    emit Request(req.id, req.callbackAddress, req.callbackFunctionId, req.buf.buf);\\n  }\\n\\n  function publicRequest(\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\\n    sendChainlinkRequest(req, _wei);\\n  }\\n\\n  function publicRequestRunTo(\\n    address _oracle,\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory run = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\\n    sendChainlinkRequestTo(_oracle, run, _wei);\\n  }\\n\\n  function publicRequestOracleData(\\n    bytes32 _id,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory req = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\\n    sendOperatorRequest(req, _wei);\\n  }\\n\\n  function publicRequestOracleDataFrom(\\n    address _oracle,\\n    bytes32 _id,\\n    address _address,\\n    bytes memory _fulfillmentSignature,\\n    uint256 _wei\\n  ) public {\\n    Chainlink.Request memory run = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\\n    sendOperatorRequestTo(_oracle, run, _wei);\\n  }\\n\\n  function publicCancelRequest(\\n    bytes32 _requestId,\\n    uint256 _payment,\\n    bytes4 _callbackFunctionId,\\n    uint256 _expiration\\n  ) public {\\n    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);\\n  }\\n\\n  function publicChainlinkToken() public view returns (address) {\\n    return chainlinkTokenAddress();\\n  }\\n\\n  function publicFulfillChainlinkRequest(bytes32 _requestId, bytes32) public {\\n    fulfillRequest(_requestId, bytes32(0));\\n  }\\n\\n  function fulfillRequest(bytes32 _requestId, bytes32) public {\\n    validateChainlinkCallback(_requestId);\\n  }\\n\\n  function publicLINK(uint256 _amount) public {\\n    emit LinkAmount(LINK_DIVISIBILITY.mul(_amount));\\n  }\\n\\n  function publicOracleAddress() public view returns (address) {\\n    return chainlinkOracleAddress();\\n  }\\n\\n  function publicAddExternalRequest(address _oracle, bytes32 _requestId) public {\\n    addChainlinkExternalRequest(_oracle, _requestId);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"link\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkEthFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fastGasFeed\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"paymentPremiumPPB\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFeeMicroLink\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"blockCountPerTurn\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"checkGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"stalenessSeconds\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"gasCeilingMultiplier\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"fallbackGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackLinkPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"paymentPremiumPPB\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"blockCountPerTurn\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"checkGasLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"stalenessSeconds\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"gasCeilingMultiplier\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fallbackGasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fallbackLinkPrice\",\"type\":\"uint256\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"flatFeeMicroLink\",\"type\":\"uint32\"}],\"name\":\"FlatFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"FundsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"keepers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"payees\",\"type\":\"address[]\"}],\"name\":\"KeepersUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PayeeshipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PayeeshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"PaymentWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"RegistrarChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"atBlockHeight\",\"type\":\"uint64\"}],\"name\":\"UpkeepCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"payment\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"UpkeepPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"executeGas\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"UpkeepRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FAST_GAS_FEED\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK\",\"outputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK_ETH_FEED\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"}],\"name\":\"acceptPayeeship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"addFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maxLinkPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adjustedGasWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"linkEth\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCanceledUpkeepList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"paymentPremiumPPB\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"blockCountPerTurn\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"checkGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"stalenessSeconds\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"gasCeilingMultiplier\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"fallbackGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackLinkPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFlatFee\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"query\",\"type\":\"address\"}],\"name\":\"getKeeperInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKeeperList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"getMaxPaymentForGas\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"maxPayment\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getMinBalanceForUpkeep\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"minBalance\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUpkeep\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"executeGas\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"lastKeeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"maxValidBlocknumber\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUpkeepCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"registerUpkeep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"paymentPremiumPPB\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFeeMicroLink\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"blockCountPerTurn\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"checkGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"stalenessSeconds\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"gasCeilingMultiplier\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"fallbackGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fallbackLinkPrice\",\"type\":\"uint256\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"keepers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"payees\",\"type\":\"address[]\"}],\"name\":\"setKeepers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"}],\"name\":\"setRegistrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"transferPayeeship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KeeperRegistry", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000b0897686c545045afc77cf20ec7a532e3120e0f10000000000000000000000005787befdc0ecd210dfa948264631cd53e68f7802000000000000000000000000f824ea79774e8698e6c6d156c60ab054794c9b18000000000000000000000000000000000000000000000000000000000bebc200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000632ea00000000000000000000000000000000000000000000000000000000000015f9000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000002e90edd00000000000000000000000000000000000000000000000000000470de4df820000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}