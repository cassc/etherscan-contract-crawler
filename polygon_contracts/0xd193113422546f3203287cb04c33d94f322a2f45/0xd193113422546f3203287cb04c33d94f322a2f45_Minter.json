{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/minter/Minter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { IMinter } from \\\"./IMinter.sol\\\";\\nimport { FraktionCostBadges } from \\\"./badges/FraktionCostBadges.sol\\\";\\nimport { ContentId } from \\\"../libs/ContentId.sol\\\";\\nimport { FraktionId } from \\\"../libs/FraktionId.sol\\\";\\nimport { FrakRoles } from \\\"../roles/FrakRoles.sol\\\";\\nimport { FraktionTokens } from \\\"../fraktions/FraktionTokens.sol\\\";\\nimport { IFrakToken } from \\\"../tokens/IFrakToken.sol\\\";\\nimport { FrakAccessControlUpgradeable } from \\\"../roles/FrakAccessControlUpgradeable.sol\\\";\\nimport { InvalidAddress } from \\\"../utils/FrakErrors.sol\\\";\\nimport { Multicallable } from \\\"solady/utils/Multicallable.sol\\\";\\nimport { SafeTransferLib } from \\\"solady/utils/SafeTransferLib.sol\\\";\\n\\n/// @author @KONFeature\\n/// @title Minter\\n/// @notice This contract will mint new content on the ecosytem, and mint fraktions for the user\\n/// @custom:security-contact contact@frak.id\\ncontract Minter is IMinter, FrakAccessControlUpgradeable, FraktionCostBadges, Multicallable {\\n    using SafeTransferLib for address;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Errors                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev 'bytes4(keccak256(bytes(\\\"InvalidAddress()\\\")))'\\n    uint256 private constant _INVALID_ADDRESS_SELECTOR = 0xe6c4247b;\\n\\n    /// @dev 'bytes4(keccak256(bytes(\\\"InvalidSupply()\\\")))'\\n    uint256 private constant _INVALID_SUPPLY_SELECTOR = 0x15ae6727;\\n\\n    /// @dev 'bytes4(keccak256(bytes(\\\"ExpectingOnlyFreeFraktion()\\\")))'\\n    uint256 private constant _EXPECTING_ONLY_FREE_FRAKTION_SELECTOR = 0x121becbf;\\n\\n    /// @dev 'bytes4(keccak256(\\\"TooManyFraktion()\\\"))'\\n    uint256 private constant _TOO_MANY_FRAKTION_SELECTOR = 0xaa37c4ae;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Events                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev 'keccak256(\\\"ContentMinted(uint256,address)\\\")'\\n    uint256 private constant _CONTENT_MINTED_EVENT_SELECTOR =\\n        0x15d512bd00e3acbb8a53b8fd503e98977b1af7618af12cbf83e463aefe880c1b;\\n\\n    /// @dev 'keccak256(\\\"FractionMinted(uint256,address,uint256,uint256)\\\")'\\n    uint256 private constant _FRACTION_MINTED_EVENT_SELECTOR =\\n        0x05941b053f6567cc6c1b84cbbb93a3af6df33035cb6694a8a5ad96208e610ad6;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Storage                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Reference to the fraktion tokens contract (ERC1155)\\n    FraktionTokens private fraktionTokens;\\n\\n    /// @dev Reference to the Frak token contract (ERC20)\\n    IFrakToken private frakToken;\\n\\n    /// @dev Address of our foundation wallet (for fee's payment)\\n    address private foundationWallet;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                  Function                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice  Initial constructor of our minter contract (like constructor but for upgradeable contract)\\n     * @dev     Will only run on first init, check the address as param, and then same all the param\\n     * @param   frkTokenAddr  The address of the FrkToken contract\\n     * @param   fraktionTokensAddr  The address of the FraktionTokens contract\\n     * @param   foundationAddr  The foundation wallet address\\n     */\\n    function initialize(\\n        address frkTokenAddr,\\n        address fraktionTokensAddr,\\n        address foundationAddr\\n    )\\n        external\\n        initializer\\n    {\\n        if (frkTokenAddr == address(0) || fraktionTokensAddr == address(0) || foundationAddr == address(0)) {\\n            revert InvalidAddress();\\n        }\\n\\n        // Only for v1 deployment\\n        __FrakAccessControlUpgradeable_Minter_init();\\n\\n        fraktionTokens = FraktionTokens(fraktionTokensAddr);\\n        frakToken = IFrakToken(frkTokenAddr);\\n\\n        foundationWallet = foundationAddr;\\n\\n        // Grant the badge updater role to the sender\\n        _grantRole(FrakRoles.BADGE_UPDATER, msg.sender);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                          External write functions                          */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @notice  Mint a new content to the FrkEcosystem\\n     * @dev     Will ensure the role and contract state, then the param, and finally call the FraktionTokens contract to\\n     * mint the new content\\n     * @param   contentOwnerAddress  The address of the owner of the given content\\n     * @param   commonSupply  The supply desired for each common fraktion of this content\\n     * @param   premiumSupply  The supply desired for each premium fraktion of this content\\n     * @param   goldSupply  The supply desired for each gold fraktion of this content\\n     * @param   diamondSupply  The supply desired for each diamond fraktion of this content\\n     * @return  contentId  The id of the freshly minted content\\n     */\\n    function addContent(\\n        address contentOwnerAddress,\\n        uint256 commonSupply,\\n        uint256 premiumSupply,\\n        uint256 goldSupply,\\n        uint256 diamondSupply\\n    )\\n        external\\n        payable\\n        override\\n        onlyRole(FrakRoles.MINTER)\\n        returns (ContentId contentId)\\n    {\\n        assembly {\\n            // Check owner address\\n            if iszero(contentOwnerAddress) {\\n                mstore(0x00, _INVALID_ADDRESS_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n            // Check supplies\\n            if or(\\n                or(iszero(commonSupply), gt(commonSupply, 500)),\\n                or(or(gt(premiumSupply, 200), gt(goldSupply, 50)), gt(diamondSupply, 20))\\n            ) {\\n                mstore(0x00, _INVALID_SUPPLY_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        // Then set the supply for each fraktion types\\n        uint256[] memory suppliesToType;\\n        assembly {\\n            // Init our array's\\n            suppliesToType := mload(0x40)\\n            // Update our free mem pointer\\n            mstore(0x40, add(suppliesToType, 0x100))\\n            // Init our array's length\\n            mstore(suppliesToType, 4)\\n            // Store the fraktionTypes\\n            mstore(add(suppliesToType, 0x20), or(shl(4, commonSupply), 3))\\n            mstore(add(suppliesToType, 0x40), or(shl(4, premiumSupply), 4))\\n            mstore(add(suppliesToType, 0x60), or(shl(4, goldSupply), 5))\\n            mstore(add(suppliesToType, 0x80), or(shl(4, diamondSupply), 6))\\n        }\\n        // Try to mint the new content\\n        contentId = fraktionTokens.mintNewContent(contentOwnerAddress, suppliesToType);\\n        assembly {\\n            // Emit the content minted event\\n            mstore(0, contentId)\\n            log2(0, 0x20, _CONTENT_MINTED_EVENT_SELECTOR, contentOwnerAddress)\\n        }\\n    }\\n\\n    /// @dev Add an autominted content holder\\n    function addAutoMintedContent(address autoMintHolder)\\n        external\\n        payable\\n        override\\n        onlyRole(FrakRoles.MINTER)\\n        returns (ContentId contentId)\\n    {\\n        // Each typplies to types array\\n        uint256[] memory suppliesToType;\\n        assembly {\\n            // Check owner address\\n            if iszero(autoMintHolder) {\\n                mstore(0x00, _INVALID_ADDRESS_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n            // Init our array's\\n            suppliesToType := mload(0x40)\\n            // Update our free mem pointer\\n            mstore(0x40, add(suppliesToType, 0x40))\\n            // Init our array's length\\n            mstore(suppliesToType, 1)\\n            // Store the fraktionTypes (only 1 supply of common fraktion)\\n            mstore(add(suppliesToType, 0x20), or(shl(4, 1), 3))\\n        }\\n        // Try to mint the new content\\n        contentId = fraktionTokens.mintNewContent(autoMintHolder, suppliesToType);\\n        assembly {\\n            // Emit the content minted event\\n            mstore(0, contentId)\\n            log2(0, 0x20, _CONTENT_MINTED_EVENT_SELECTOR, autoMintHolder)\\n        }\\n    }\\n\\n    /// @dev Add a content for a creator\\n    function addContentForCreator(address contentOwnerAddress)\\n        external\\n        payable\\n        override\\n        onlyRole(FrakRoles.MINTER)\\n        returns (ContentId contentId)\\n    {\\n        // Each typplies to types array\\n        uint256[] memory suppliesToType;\\n        assembly {\\n            // Check owner address\\n            if iszero(contentOwnerAddress) {\\n                mstore(0x00, _INVALID_ADDRESS_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n            // Init our array's\\n            suppliesToType := mload(0x40)\\n            // Update our free mem pointer\\n            mstore(0x40, add(suppliesToType, 0x100))\\n            // Init our array's length\\n            mstore(suppliesToType, 4)\\n            // Store the fraktionTypes\\n            // We can keep shifting since it will be replaced by constant by the compiler\\n            mstore(add(suppliesToType, 0x20), or(shl(4, 20), 3))\\n            mstore(add(suppliesToType, 0x40), or(shl(4, 7), 4))\\n            mstore(add(suppliesToType, 0x60), or(shl(4, 3), 5))\\n            mstore(add(suppliesToType, 0x80), or(shl(4, 1), 6))\\n        }\\n        // Try to mint the new content\\n        contentId = fraktionTokens.mintNewContent(contentOwnerAddress, suppliesToType);\\n        assembly {\\n            // Emit the content minted event\\n            mstore(0, contentId)\\n            log2(0, 0x20, _CONTENT_MINTED_EVENT_SELECTOR, contentOwnerAddress)\\n        }\\n    }\\n\\n    /**\\n     * @notice  Mint a new fraktion for the given amount and user\\n     * @dev     Will compute the fraktion price, ensure the user have enough Frk to buy it, if try, perform the transfer\\n     * and mint the fraktion\\n     * @param   id  The id of the fraktion to be minted for the user\\n     * @param   to  The address on which we will mint the fraktion\\n     * @param   deadline  The deadline for the permit of the allowance tx\\n     * @param   v  Signature spec secp256k1\\n     * @param   r  Signature spec secp256k1\\n     * @param   s  Signature spec secp256k1\\n     */\\n    function mintFraktionForUser(\\n        FraktionId id,\\n        address to,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n        payable\\n        onlyRole(FrakRoles.MINTER)\\n    {\\n        _mintFraktionForUserWithSig(id, to, deadline, v, r, s);\\n    }\\n\\n    /**\\n     * @notice  Mint a new fraktion for the given amount to the caller\\n     * @dev     Will compute the fraktion price, ensure the user have enough Frk to buy it, if try, perform the transfer\\n     * and mint the fraktion\\n     * @param   id  The id of the fraktion to be minted for the user\\n     * @param   deadline  The deadline for the permit of the allowance tx\\n     * @param   v  Signature spec secp256k1\\n     * @param   r  Signature spec secp256k1\\n     * @param   s  Signature spec secp256k1\\n     */\\n    function mintFraktion(FraktionId id, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable {\\n        _mintFraktionForUserWithSig(id, msg.sender, deadline, v, r, s);\\n    }\\n\\n    /**\\n     * @notice  Mint a new fraktion for the given amount to the caller\\n     * @dev     Will compute the fraktion price, ensure the user have enough Frk to buy it, if try, perform the transfer\\n     * and mint the fraktion\\n     * @param   id  The id of the fraktion to be minted for the user\\n     */\\n    function mintFraktion(FraktionId id) external payable {\\n        _mintFraktionForUser(id, msg.sender);\\n    }\\n\\n    /**\\n     * @notice  Mint a free fraktion for the given user\\n     * @dev     Will mint a new free FraktionToken for the user, by first ensuring the user doesn't have any fraktion,\\n     * only performed when contract not paused and by the right person\\n     * @param   id  Id of the free fraktion\\n     * @param   to  Address of the user\\n     */\\n    function mintFreeFraktionForUser(FraktionId id, address to) external override {\\n        _mintFreeFraktionForUser(id, to);\\n    }\\n\\n    /**\\n     * @notice  Mint a free fraktion for the given user\\n     * @dev     Will mint a new free FraktionToken for the user, by first ensuring the user doesn't have any fraktion,\\n     * only performed when contract not paused and by the right person\\n     * @param   id  Id of the free fraktion\\n     */\\n    function mintFreeFraktion(FraktionId id) external override {\\n        _mintFreeFraktionForUser(id, msg.sender);\\n    }\\n\\n    /**\\n     * @notice  Increase the total supply for the given fraktion id\\n     * @dev     Will call our FraktionTokens contract and increase the supply for the given fraktion, only if all of it\\n     * have been minted\\n     * @param   id  The id of the fraktion for which we want to increase the supply\\n     * @param   newSupply  The supply we wan't to append for this fraktion\\n     */\\n    function increaseSupply(FraktionId id, uint256 newSupply) external onlyRole(FrakRoles.MINTER) {\\n        // Update the supply\\n        fraktionTokens.addSupply(id, newSupply);\\n    }\\n\\n    /**\\n     * @notice  Update the cost badge for the given fraktion\\n     * @dev     Call to the FraktionCostBadges subclass to update the cost badge, need the right role and contract\\n     * unpaused\\n     * @param   fraktionId The id of the fraktion we will update the badge\\n     * @param   badge The new badge for the fraktion\\n     */\\n    function updateCostBadge(FraktionId fraktionId, uint96 badge) external override onlyRole(FrakRoles.BADGE_UPDATER) {\\n        _updateCostBadge(fraktionId, badge);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                          Internal write functions                          */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @notice  Mint a new fraktion for the given amount and user\\n     * @dev     Will compute the fraktion price, ensure the user have enough Frk to buy it, if try, perform the transfer\\n     * and mint the fraktion\\n     * @param   id  The id of the fraktion to be minted for the user\\n     * @param   to  The address on which we will mint the fraktion\\n     * @param   deadline  The deadline for the permit of the allowance tx\\n     * @param   v  Signature spec secp256k1\\n     * @param   r  Signature spec secp256k1\\n     * @param   s  Signature spec secp256k1\\n     */\\n    function _mintFraktionForUserWithSig(\\n        FraktionId id,\\n        address to,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        private\\n    {\\n        // Get the current user balance, and exit if he already got a fraktion of this type\\n        uint256 balance = fraktionTokens.balanceOf(to, FraktionId.unwrap(id));\\n        if (balance != 0) {\\n            revert TooManyFraktion();\\n        }\\n        // Get the cost of the fraktionId\\n        uint256 cost = getCostBadge(id);\\n        assembly {\\n            // Emit the event\\n            mstore(0, 1)\\n            mstore(0x20, cost)\\n            log3(0, 0x40, _FRACTION_MINTED_EVENT_SELECTOR, id, to)\\n        }\\n        // Call the permit functions\\n        frakToken.permit(to, address(this), cost, deadline, v, r, s);\\n        // Transfer the tokens\\n        address(frakToken).safeTransferFrom(to, foundationWallet, cost);\\n        // Mint his fraktion\\n        fraktionTokens.mint(to, id, 1);\\n    }\\n\\n    /**\\n     * @notice  Mint a new fraktion for the given amount and user\\n     * @dev     Will compute the fraktion price, ensure the user have enough Frk to buy it, if try, perform the transfer\\n     * and mint the fraktion\\n     * @param   id  The id of the fraktion to be minted for the user\\n     * @param   to  The address on which we will mint the fraktion\\n     */\\n    function _mintFraktionForUser(FraktionId id, address to) private {\\n        // Get the current user balance, and exit if he already got a fraktion of this type\\n        uint256 balance = fraktionTokens.balanceOf(to, FraktionId.unwrap(id));\\n        if (balance != 0) {\\n            revert TooManyFraktion();\\n        }\\n        // Get the cost of the fraktionId\\n        uint256 cost = getCostBadge(id);\\n        assembly {\\n            // Emit the event\\n            mstore(0, 1)\\n            mstore(0x20, cost)\\n            log3(0, 0x40, _FRACTION_MINTED_EVENT_SELECTOR, id, to)\\n        }\\n        // Transfer the tokens\\n        address(frakToken).safeTransferFrom(to, foundationWallet, cost);\\n        // Mint his fraktion\\n        fraktionTokens.mint(to, id, 1);\\n    }\\n\\n    /**\\n     * @notice  Mint a free fraktion for the given user\\n     * @dev     Will mint a new free FraktionToken for the user, by first ensuring the user doesn't have any fraktion,\\n     * only performed when contract not paused and by the right person\\n     * @param   id  Id of the free fraktion\\n     */\\n    function _mintFreeFraktionForUser(FraktionId id, address to) private {\\n        assembly {\\n            // Check if it's a free fraktion\\n            if iszero(eq(and(id, 0xF), 0x2)) {\\n                mstore(0x00, _EXPECTING_ONLY_FREE_FRAKTION_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        // Get the current user balance, and exit if he already got a fraktion of this type\\n        uint256 balance = fraktionTokens.balanceOf(to, FraktionId.unwrap(id));\\n        if (balance != 0) {\\n            return;\\n        }\\n\\n        // If we are all good, mint the free fraktion to the user\\n        fraktionTokens.mint(to, id, 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/minter/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { ContentId } from \\\"../libs/ContentId.sol\\\";\\nimport { FraktionId } from \\\"../libs/FraktionId.sol\\\";\\n\\n/// @author @KONFeature\\n/// @title IMinter\\n/// @notice Interface for the Minter contract\\n/// @custom:security-contact contact@frak.id\\ninterface IMinter {\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Errors                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Error emitted when the input supply is invalid\\n    error InvalidSupply();\\n\\n    /// @dev Error emitted when we only want to mint a free fraktion, and that's not a free fraktion\\n    error ExpectingOnlyFreeFraktion();\\n\\n    /// @dev Error emitted when the have more than one fraktions of the given type\\n    error TooManyFraktion();\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Events                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Event emitted when a new content is minted\\n    event ContentMinted(uint256 baseId, address indexed owner);\\n\\n    /// @dev Event emitted when a new fraktion for a content is minted\\n    event FractionMinted(uint256 indexed fraktionId, address indexed user, uint256 amount, uint256 cost);\\n\\n    /**\\n     * @notice  Mint a new content to the FrkEcosystem\\n     * @dev     Will ensure the role and contract state, then the param, and finally call the FraktionTokens contract to\\n     * mint the new content\\n     * @param   contentOwnerAddress  The address of the owner of the given content\\n     * @param   commonSupply  The supply desired for each common fraktion of this content\\n     * @param   premiumSupply  The supply desired for each premium fraktion of this content\\n     * @param   goldSupply  The supply desired for each gold fraktion of this content\\n     * @param   diamondSupply  The supply desired for each diamond fraktion of this content\\n     * @return  contentId  The id of the freshly minted content\\n     */\\n    function addContent(\\n        address contentOwnerAddress,\\n        uint256 commonSupply,\\n        uint256 premiumSupply,\\n        uint256 goldSupply,\\n        uint256 diamondSupply\\n    )\\n        external\\n        payable\\n        returns (ContentId contentId);\\n\\n    /// @dev Add a new auto minted content in our system\\n    function addAutoMintedContent(address autoMintHolder) external payable returns (ContentId contentId);\\n\\n    /// @dev Add a content when a creator asked for it\\n    function addContentForCreator(address contentOwnerAddress) external payable returns (ContentId contentId);\\n\\n    /**\\n     * @notice  Mint a new fraktion for the given amount and user\\n     * @dev     Will compute the fraktion price, ensure the user have enough Frk to buy it, if try, perform the transfer\\n     * and mint the fraktion\\n     * @param   id  The id of the fraktion to be minted for the user\\n     * @param   to  The address on which we will mint the fraktion\\n     * @param   deadline  The deadline for the permit of the allowance tx\\n     * @param   v  Signature spec secp256k1\\n     * @param   r  Signature spec secp256k1\\n     * @param   s  Signature spec secp256k1\\n     */\\n    function mintFraktionForUser(\\n        FraktionId id,\\n        address to,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @notice  Mint a new fraktion for the given amount to the caller\\n     * @dev     Will compute the fraktion price, ensure the user have enough Frk to buy it, if try, perform the transfer\\n     * and mint the fraktion\\n     * @param   id  The id of the fraktion to be minted for the user\\n     * @param   deadline  The deadline for the permit of the allowance tx\\n     * @param   v  Signature spec secp256k1\\n     * @param   r  Signature spec secp256k1\\n     * @param   s  Signature spec secp256k1\\n     */\\n    function mintFraktion(FraktionId id, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable;\\n\\n    /**\\n     * @notice  Mint a new fraktion for the given amount to the caller\\n     * @dev     Will compute the fraktion price, ensure the user have enough Frk to buy it, if try, perform the transfer\\n     * and mint the fraktion\\n     * @param   id  The id of the fraktion to be minted for the user\\n     */\\n    function mintFraktion(FraktionId id) external payable;\\n\\n    /**\\n     * @notice  Mint a free fraktion for the given user\\n     * @dev     Will mint a new free FraktionToken for the user, by first ensuring the user doesn't have any fraktion,\\n     * only performed when contract not paused and by the right person\\n     * @param   id  Id of the free fraktion\\n     * @param   to  Address of the user\\n     */\\n    function mintFreeFraktionForUser(FraktionId id, address to) external;\\n\\n    /**\\n     * @notice  Mint a free fraktion for the given user\\n     * @dev     Will mint a new free FraktionToken for the user, by first ensuring the user doesn't have any fraktion,\\n     * only performed when contract not paused and by the right person\\n     * @param   id  Id of the free fraktion\\n     */\\n    function mintFreeFraktion(FraktionId id) external;\\n\\n    /**\\n     * @notice  Increase the total supply for the given fraktion id\\n     * @dev     Will call our FraktionTokens contract and increase the supply for the given fraktion, only if all of it\\n     * have been minted\\n     * @param   id  The id of the fraktion for which we want to increase the supply\\n     * @param   newSupply  The supply we wan't to append for this fraktion\\n     */\\n    function increaseSupply(FraktionId id, uint256 newSupply) external;\\n}\\n\"\r\n    },\r\n    \"contracts/minter/badges/FraktionCostBadges.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { FraktionId } from \\\"../../libs/FraktionId.sol\\\";\\nimport { ContentIdLib } from \\\"../../libs/ContentId.sol\\\";\\nimport { InvalidFraktionType } from \\\"../../utils/FrakErrors.sol\\\";\\n\\n/// @author @KONFeature\\n/// @title FraktionCostBadges\\n/// @notice Abstract contract for managing the badge costs of fraktions.\\n/// @custom:security-contact contact@frak.id\\nabstract contract FraktionCostBadges {\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Errors                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev 'bytes4(keccak256(\\\"InvalidFraktionType()\\\"))'\\n    uint256 private constant _INVALID_FRAKTION_TYPE_SELECTOR = 0x3f126a45;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Events                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @dev Emitted when the badge cost of a fraktion is updated.\\n     * @param id The id of the updated fraktion.\\n     * @param badge The new badge cost of the fraktion in wei.\\n     */\\n    event FraktionCostBadgeUpdated(uint256 indexed id, uint256 badge);\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Storage                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @dev Map f nft id to cost badge.\\n     * @notice This variable is private and can only be accessed by the current contract.\\n     */\\n    mapping(FraktionId frakionId => uint96 cost) private fraktionBadges;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                             Abstract functions                             */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @dev Update the badge cost of the specified fraktion.\\n     * @notice This function can be overridden by inheriting contracts.\\n     * @param fraktionId The id of the fraktion to update the badge cost of.\\n     * @param badge The new badge cost of the fraktion in wei.\\n     */\\n    function updateCostBadge(FraktionId fraktionId, uint96 badge) external virtual;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                          Internal write functions                          */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @dev Update the badge cost of the specified fraktionId and emit an event.\\n     * @param fraktionId The id of the fraktionId to update the badge cost of.\\n     * @param badge The new badge cost of the fraktionId in wei.\\n     */\\n    function _updateCostBadge(FraktionId fraktionId, uint96 badge) internal {\\n        // Revert if the fraktion id is not a payable one\\n        if (fraktionId.isNotPayable()) {\\n            revert InvalidFraktionType();\\n        }\\n\\n        fraktionBadges[fraktionId] = badge;\\n        emit FraktionCostBadgeUpdated(FraktionId.unwrap(fraktionId), badge);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                           Public read functions                            */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @dev Returns the badge cost of the specified fraktion.\\n     * @notice If the badge of this fraktionId isn't set yet, it will be set to the default initial cost.\\n     * @param fraktionId The id of the fraktionId to get the badge cost of.\\n     * @return fraktionBadge The badge cost of the specified fraktionId in wei.\\n     */\\n    function getCostBadge(FraktionId fraktionId) public view returns (uint96 fraktionBadge) {\\n        fraktionBadge = fraktionBadges[fraktionId];\\n        if (fraktionBadge == 0) {\\n            // If the badge of this fraktionId isn't set yet, set it to default\\n            uint256 fraktionType = fraktionId.getFraktionType();\\n            fraktionBadge = initialFraktionCost(fraktionType);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the initial cost of a fraktionId of the specified fraktion type in wei.\\n     * @notice This method should only be called with valid fraktion types as defined by the FrakMath contract.\\n     * @param fraktionType The type of fraktion to get the initial cost of.\\n     * @return initialCost The initial cost of the specified fraktion type in wei.\\n     */\\n    function initialFraktionCost(uint256 fraktionType) internal pure returns (uint96 initialCost) {\\n        if (fraktionType == ContentIdLib.FRAKTION_TYPE_COMMON) {\\n            initialCost = 90 ether; // 90 FRK\\n        } else if (fraktionType == ContentIdLib.FRAKTION_TYPE_PREMIUM) {\\n            initialCost = 500 ether; // 500 FRK\\n        } else if (fraktionType == ContentIdLib.FRAKTION_TYPE_GOLD) {\\n            initialCost = 1200 ether; // 1.2k FRK\\n        } else if (fraktionType == ContentIdLib.FRAKTION_TYPE_DIAMOND) {\\n            initialCost = 3000 ether; // 3k FRK\\n        } else {\\n            assembly {\\n                mstore(0x00, _INVALID_FRAKTION_TYPE_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/ContentId.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { FraktionId } from \\\"./FraktionId.sol\\\";\\n\\n/// @dev Define the ContentId type\\ntype ContentId is uint256;\\n\\n/// @dev Tell to use the lib below for every ContentId instance\\nusing ContentIdLib for ContentId global;\\n\\n/// @author @KONFeature\\n/// @title ContentIdLib\\n/// @notice This contract is used to help us with the manipulation of the ContentId\\n/// @custom:security-contact contact@frak.id\\nlibrary ContentIdLib {\\n    /* -------------------------------------------------------------------------- */\\n    /*                                 Constants                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev The offset of the id we use to store the fraktion type\\n    uint256 internal constant ID_OFFSET = 4;\\n    /// @dev The mask we use to store the fraktion type in the fraktion id\\n    uint256 internal constant TYPE_MASK = 0xF;\\n\\n    /// @dev NFT Token type mask\\n    uint256 internal constant FRAKTION_TYPE_CREATOR = 1;\\n    /// @dev Free Token type mask\\n    uint256 internal constant FRAKTION_TYPE_FREE = 2;\\n    /// @dev Common Token type mask\\n    uint256 internal constant FRAKTION_TYPE_COMMON = 3;\\n    /// @dev Premium Token type mask\\n    uint256 internal constant FRAKTION_TYPE_PREMIUM = 4;\\n    /// @dev Gold Token type mask\\n    uint256 internal constant FRAKTION_TYPE_GOLD = 5;\\n    /// @dev Diamond Token type mask\\n    uint256 internal constant FRAKTION_TYPE_DIAMOND = 6;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                               Helper functions                              */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Build a fraktion id from a content id\\n    function toFraktionId(ContentId self, uint256 fraktionType) internal pure returns (FraktionId id) {\\n        assembly {\\n            id := or(shl(ID_OFFSET, self), fraktionType)\\n        }\\n    }\\n\\n    /// @dev Build the id for a creator NFT id\\n    function creatorFraktionId(ContentId self) internal pure returns (FraktionId id) {\\n        assembly {\\n            id := or(shl(ID_OFFSET, self), FRAKTION_TYPE_CREATOR)\\n        }\\n    }\\n\\n    /// @dev Build the id for a free NFT id\\n    function freeFraktionId(ContentId self) internal pure returns (FraktionId id) {\\n        assembly {\\n            id := or(shl(ID_OFFSET, self), FRAKTION_TYPE_FREE)\\n        }\\n    }\\n\\n    /// @dev Build the id for a common NFT id\\n    function commonFraktionId(ContentId self) internal pure returns (FraktionId id) {\\n        assembly {\\n            id := or(shl(ID_OFFSET, self), FRAKTION_TYPE_COMMON)\\n        }\\n    }\\n\\n    /// @dev Build the id for a premium NFT id\\n    function premiumFraktionId(ContentId self) internal pure returns (FraktionId id) {\\n        assembly {\\n            id := or(shl(ID_OFFSET, self), FRAKTION_TYPE_PREMIUM)\\n        }\\n    }\\n\\n    /// @dev Build the id for a gold NFT id\\n    function goldFraktionId(ContentId self) internal pure returns (FraktionId id) {\\n        assembly {\\n            id := or(shl(ID_OFFSET, self), FRAKTION_TYPE_GOLD)\\n        }\\n    }\\n\\n    /// @dev Build the id for a diamond NFT id\\n    function diamondFraktionId(ContentId self) internal pure returns (FraktionId id) {\\n        assembly {\\n            id := or(shl(ID_OFFSET, self), FRAKTION_TYPE_DIAMOND)\\n        }\\n    }\\n\\n    /// @dev Build an array of all the payable fraktion types\\n    function payableFraktionIds(ContentId self) internal pure returns (FraktionId[] memory ids) {\\n        assembly {\\n            // Store each types\\n            ids := mload(0x40)\\n            mstore(ids, 4)\\n            mstore(add(ids, 0x20), or(shl(ID_OFFSET, self), FRAKTION_TYPE_COMMON))\\n            mstore(add(ids, 0x40), or(shl(ID_OFFSET, self), FRAKTION_TYPE_PREMIUM))\\n            mstore(add(ids, 0x60), or(shl(ID_OFFSET, self), FRAKTION_TYPE_GOLD))\\n            mstore(add(ids, 0x80), or(shl(ID_OFFSET, self), FRAKTION_TYPE_DIAMOND))\\n            // Update our free mem space\\n            mstore(0x40, add(ids, 0xA0))\\n        }\\n    }\\n\\n    /// @dev Create a new array with the given element\\n    function asSingletonArray(ContentId self) internal pure returns (ContentId[] memory array) {\\n        assembly {\\n            // Get free memory space for our array, and update the free mem space index\\n            array := mload(0x40)\\n            mstore(0x40, add(array, 0x40))\\n\\n            // Store our array (1st = length, 2nd = element)\\n            mstore(array, 0x01)\\n            mstore(add(array, 0x20), self)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/FraktionId.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\n/// @dev Define the FraktionId type\\ntype FraktionId is uint256;\\n\\n/// @dev Tell to use the lib below for every FraktionId instance\\nusing FraktionIdLib for FraktionId global;\\n\\n/// @author @KONFeature\\n/// @title FraktionIdLib\\n/// @notice This contract is used to help us with the manipulation of the FraktionId\\n/// @custom:security-contact contact@frak.id\\nlibrary FraktionIdLib {\\n    /// @dev The offset of the id we use to store the fraktion type\\n    uint256 internal constant ID_OFFSET = 4;\\n    /// @dev The mask we use to store the fraktion type in the fraktion id\\n    uint256 internal constant TYPE_MASK = 0xF;\\n\\n    /// @dev Get the `contentId` from the `self` fraktion id\\n    function isNotPayable(FraktionId self) internal pure returns (bool notPayable) {\\n        assembly {\\n            let fType := and(self, TYPE_MASK)\\n            notPayable := or(lt(fType, 3), gt(fType, 6))\\n        }\\n    }\\n\\n    /// @dev Get the `contentId` from the `self` fraktion id\\n    function getContentId(FraktionId self) internal pure returns (uint256 contentId) {\\n        assembly {\\n            contentId := shr(ID_OFFSET, self)\\n        }\\n    }\\n\\n    /// @dev Get the `fraktionType` from the `self` fraktion id\\n    function getFraktionType(FraktionId self) internal pure returns (uint256 fraktionType) {\\n        assembly {\\n            fraktionType := and(self, TYPE_MASK)\\n        }\\n    }\\n\\n    /// @dev Get the `contentId` and `fraktionType` from the `self` fraktion id\\n    function extractAll(FraktionId self) internal pure returns (uint256 contentId, uint256 fraktionType) {\\n        assembly {\\n            contentId := shr(ID_OFFSET, self)\\n            fraktionType := and(self, TYPE_MASK)\\n        }\\n    }\\n\\n    /// @dev Create a new array with the given element\\n    function asSingletonArray(FraktionId self) internal pure returns (FraktionId[] memory array) {\\n        assembly {\\n            // Get free memory space for our array, and update the free mem space index\\n            array := mload(0x40)\\n            mstore(0x40, add(array, 0x40))\\n\\n            // Store our array (1st = length, 2nd = element)\\n            mstore(array, 0x01)\\n            mstore(add(array, 0x20), self)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/roles/FrakRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\n/// @author @KONFeature\\n/// @title FrakRoles\\n/// @notice All the roles of the frak ecosystem\\n/// @custom:security-contact contact@frak.id\\nlibrary FrakRoles {\\n    /// @dev Administrator role of a contra\\n    bytes32 internal constant ADMIN = 0x00;\\n\\n    /// @dev Role required to update a smart contract\\n    bytes32 internal constant UPGRADER = keccak256(\\\"UPGRADER_ROLE\\\");\\n\\n    /// @dev Role required to mint new token on in a contract\\n    bytes32 internal constant MINTER = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    /// @dev Role required to update the badge in a contract\\n    bytes32 internal constant BADGE_UPDATER = keccak256(\\\"BADGE_UPDATER_ROLE\\\");\\n\\n    /// @dev Role required to reward user for their listen\\n    bytes32 internal constant REWARDER = keccak256(\\\"REWARDER_ROLE\\\");\\n\\n    /// @dev Role required to perform token specific actions on a contract\\n    bytes32 internal constant TOKEN_CONTRACT = keccak256(\\\"TOKEN_ROLE\\\");\\n\\n    /// @dev Role required to manage the vesting wallets\\n    bytes32 internal constant VESTING_MANAGER = keccak256(\\\"VESTING_MANAGER\\\");\\n\\n    /// @dev Role required to create new vesting\\n    bytes32 internal constant VESTING_CREATOR = keccak256(\\\"VESTING_CREATOR\\\");\\n}\\n\"\r\n    },\r\n    \"contracts/fraktions/FraktionTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { ERC1155Upgradeable } from \\\"@oz-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\\\";\\nimport { FraktionTransferCallback } from \\\"./FraktionTransferCallback.sol\\\";\\nimport { ContentId } from \\\"../libs/ContentId.sol\\\";\\nimport { FraktionId } from \\\"../libs/FraktionId.sol\\\";\\nimport { ArrayLib } from \\\"../libs/ArrayLib.sol\\\";\\nimport { FrakRoles } from \\\"../roles/FrakRoles.sol\\\";\\nimport { FrakAccessControlUpgradeable } from \\\"../roles/FrakAccessControlUpgradeable.sol\\\";\\nimport { InvalidArray, InvalidSigner } from \\\"../utils/FrakErrors.sol\\\";\\nimport { EIP712Diamond } from \\\"../utils/EIP712Diamond.sol\\\";\\nimport { ECDSA } from \\\"solady/utils/ECDSA.sol\\\";\\nimport { SafeTransferLib } from \\\"solady/utils/SafeTransferLib.sol\\\";\\n\\n/// @author @KONFeature\\n/// @title FraktionTokens\\n/// @notice ERC1155 for the Frak Fraktions tokens, used as ownership proof for a content, or investisment proof\\n/// @custom:security-contact contact@frak.id\\ncontract FraktionTokens is FrakAccessControlUpgradeable, ERC1155Upgradeable, EIP712Diamond {\\n    /* -------------------------------------------------------------------------- */\\n    /*                               Custom errors                                */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Error throwned when we don't have enough supply to mint a new fNFT\\n    error InsuficiantSupply();\\n\\n    /// @dev Error throwned when we try to update the supply of a non supply aware token\\n    error SupplyUpdateNotAllowed();\\n\\n    /// @dev 'bytes4(keccak256(\\\"InsuficiantSupply()\\\"))'\\n    uint256 private constant _INSUFICIENT_SUPPLY_SELECTOR = 0xa24b545a;\\n\\n    /// @dev 'bytes4(keccak256(\\\"InvalidArray()\\\"))'\\n    uint256 private constant _INVALID_ARRAY_SELECTOR = 0x1ec5aa51;\\n\\n    /// @dev 'bytes4(keccak256(\\\"SupplyUpdateNotAllowed()\\\"))'\\n    uint256 private constant _SUPPLY_UPDATE_NOT_ALLOWED_SELECTOR = 0x48385ebd;\\n\\n    /// @dev 'bytes4(keccak256(bytes(\\\"PermitDelayExpired()\\\")))'\\n    uint256 private constant _PERMIT_DELAYED_EXPIRED_SELECTOR = 0x95fc6e60;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Events                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Event emitted when the supply of a fraktion is updated\\n    event SuplyUpdated(uint256 indexed id, uint256 supply);\\n\\n    /// @dev Event emitted when the owner of a content changed\\n    event ContentOwnerUpdated(uint256 indexed id, address indexed owner);\\n\\n    /// @dev 'keccak256(bytes(\\\"SuplyUpdated(uint256,uint256)\\\"))'\\n    uint256 private constant _SUPPLY_UPDATED_EVENT_SELECTOR =\\n        0xb137aebbacc26855c231fff6d377b18aaa6397ab7c49bb7481d78a529017564d;\\n\\n    /// @dev 'keccak256(bytes(\\\"ContentOwnerUpdated(uint256,address)\\\"))'\\n    uint256 private constant _CONTENT_OWNER_UPDATED_EVENT_SELECTOR =\\n        0x4d30aa74825efbda2206e0f3ac5b20d3d5806e54280b6684b6f380afcbfc51d2;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Storage                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev The current content id\\n    uint256 private _currentContentId;\\n\\n    /// @dev The current callback\\n    FraktionTransferCallback private transferCallback;\\n\\n    /// @dev Id of content to owner of this content\\n    /// @notice This is unused now, since we rely on the balanceOf m\\n    mapping(uint256 id => address owner) private owners;\\n\\n    /// @dev Available supply of each fraktion (classic, rare, epic and legendary only) by they id\\n    mapping(uint256 id => uint256 availableSupply) private _availableSupplies;\\n\\n    /// @dev Tell us if that fraktion is supply aware or not\\n    /// @notice unused now since we rely on the fraktion type to know if it is supply aware or not\\n    mapping(uint256 => bool) private _unused1;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                 Versioning                                 */\\n    /* -------------------------------------------------------------------------- */\\n\\n    function initialize(string calldata metadatalUrl) external initializer {\\n        __ERC1155_init(metadatalUrl);\\n        __FrakAccessControlUpgradeable_Minter_init();\\n        _initializeEIP712(\\\"Fraktions\\\");\\n        // Set the initial content id\\n        _currentContentId = 1;\\n    }\\n\\n    /// @dev Update to diamond Eip712\\n    function updateToDiamondEip712() external reinitializer(3) {\\n        _initializeEIP712(\\\"Fraktions\\\");\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                          External write functions                          */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Mint a new content, return the id of the built content\\n    /// @param ownerAddress The address of the content owner\\n    /// @param suppliesToType The supplies to type array, each element of the array is a tuple on a byte [supply, type],\\n    /// type on 0xf, supply on all the remaining bytes\\n    function mintNewContent(\\n        address ownerAddress,\\n        uint256[] calldata suppliesToType\\n    )\\n        external\\n        payable\\n        onlyRole(FrakRoles.MINTER)\\n        returns (ContentId id)\\n    {\\n        uint256 creatorTokenId;\\n        assembly {\\n            // Get the next content id and increment the current content id\\n            id := add(sload(_currentContentId.slot), 1)\\n            sstore(_currentContentId.slot, id)\\n\\n            // Get the shifted id, to ease the fraktion id creation\\n            let shiftedId := shl(0x04, id)\\n\\n            // Iterate over each fraktion type, build their id, and set their supply\\n            // Get where our offset end\\n            let offsetEnd := shl(5, suppliesToType.length)\\n            // Current iterator offset\\n            let currentOffset := 0\\n            // Infinite loop\\n            for { } 1 { } {\\n                // Get the current id\\n                let currentItem := calldataload(add(suppliesToType.offset, currentOffset))\\n                let fraktionType := and(currentItem, 0xF)\\n\\n                // Ensure the supply update of this fraktion type is allowed\\n                if or(lt(fraktionType, 3), gt(fraktionType, 6)) {\\n                    // If fraktion type lower than 3 -> free or owner\\n                    mstore(0x00, _SUPPLY_UPDATE_NOT_ALLOWED_SELECTOR)\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                // Build the fraktion id\\n                let fraktionId := or(shiftedId, fraktionType)\\n\\n                // Get the supply\\n                let supply := shr(4, currentItem)\\n\\n                // Get the supply slot and update it\\n                // Kecak (id, _availableSupplies.slot)\\n                mstore(0, fraktionId)\\n                mstore(0x20, _availableSupplies.slot)\\n                sstore(keccak256(0, 0x40), supply)\\n                // Emit the supply updated event\\n                mstore(0, supply)\\n                log2(0, 0x20, _SUPPLY_UPDATED_EVENT_SELECTOR, fraktionId)\\n\\n                // Increase the iterator\\n                currentOffset := add(currentOffset, 0x20)\\n                // Exit if we reached the end\\n                if iszero(lt(currentOffset, offsetEnd)) { break }\\n            }\\n\\n            // Update creator supply now\\n            creatorTokenId := or(shiftedId, 1)\\n            // Then store the available supply of 1 (since only one creator nft is possible)\\n            mstore(0, creatorTokenId)\\n            mstore(0x20, _availableSupplies.slot)\\n            sstore(keccak256(0, 0x40), 1)\\n        }\\n\\n        // Mint the content nft into the content owner wallet directly\\n        _mint(ownerAddress, creatorTokenId, 1, \\\"\\\");\\n\\n        // Return the content id\\n        return id;\\n    }\\n\\n    /// @dev Set the supply for the given fraktion id\\n    function addSupply(FraktionId id, uint256 supply) external payable onlyRole(FrakRoles.MINTER) {\\n        assembly {\\n            // Ensure the supply update of this fraktion type is allowed\\n            let fraktionType := and(id, 0xF)\\n            if or(lt(fraktionType, 3), gt(fraktionType, 6)) {\\n                // If fraktion type lower than 3 -> free or owner, if greater than 6 -> not a content\\n                mstore(0x00, _SUPPLY_UPDATE_NOT_ALLOWED_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n            // Kecak (id, _availableSupplies.slot)\\n            mstore(0, id)\\n            mstore(0x20, _availableSupplies.slot)\\n            let supplySlot := keccak256(0, 0x40)\\n            // Get the supply slot and update it\\n            sstore(supplySlot, add(sload(supplySlot), supply))\\n            // Emit the supply updated event\\n            mstore(0, supply)\\n            log2(0, 0x20, _SUPPLY_UPDATED_EVENT_SELECTOR, id)\\n        }\\n    }\\n\\n    /// @dev Register a new transaction callback\\n    function registerNewCallback(address callbackAddr) external onlyRole(FrakRoles.ADMIN) {\\n        transferCallback = FraktionTransferCallback(callbackAddr);\\n    }\\n\\n    /// @dev Mint a new fraktion of a nft\\n    function mint(address to, FraktionId id, uint256 amount) external payable onlyRole(FrakRoles.MINTER) {\\n        _mint(to, FraktionId.unwrap(id), amount, \\\"\\\");\\n    }\\n\\n    /// @dev Burn a fraktion of a nft\\n    function burn(FraktionId id, uint256 amount) external payable {\\n        _burn(msg.sender, FraktionId.unwrap(id), amount);\\n    }\\n\\n    /// @dev Transfer all the fraktions from the given user to a new one\\n    function transferAllFrom(address from, address to, uint256[] calldata ids) external payable {\\n        // Build the amounts matching the ids\\n        uint256 length = ids.length;\\n        uint256[] memory amounts = new uint256[](length);\\n        for (uint256 i = 0; i < length;) {\\n            unchecked {\\n                amounts[i] = balanceOf(from, ids[i]);\\n                ++i;\\n            }\\n        }\\n\\n        // Perform the batch transfer\\n        safeBatchTransferFrom(from, to, ids, amounts, \\\"\\\");\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                              Allowance methods                             */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Signature check to allow a user to transfer ERC-1155 on the behalf of the owner\\n    function permitAllTransfer(\\n        address owner,\\n        address spender,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n        payable\\n    {\\n        // Ensure deadline is valid\\n        assembly {\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, _PERMIT_DELAYED_EXPIRED_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ECDSA.recover(\\n                toTypedMessageHash(\\n                    keccak256(\\n                        abi.encode(\\n                            keccak256(\\\"PermitAllTransfer(address owner,address spender,uint256 nonce,uint256 deadline)\\\"),\\n                            owner,\\n                            spender,\\n                            useNonce(owner),\\n                            deadline\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            // Don't need to check for 0 address, or send event, since approve already do it for us\\n            if (recoveredAddress != owner) revert InvalidSigner();\\n\\n            // Approve the token\\n            _setApprovalForAll(recoveredAddress, spender, true);\\n        }\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                        Internal callback functions                         */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Handle the transfer token (so update the content investor, change the owner of some content etc)\\n    function _beforeTokenTransfer(\\n        address,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory\\n    )\\n        internal\\n        override\\n    {\\n        // Directly exit if we are not concerned by a mint or burn\\n        if (from != address(0) && to != address(0)) return;\\n\\n        // Assembly block to check supply and decrease it if needed\\n        assembly {\\n            // Base offset to access array elements\\n            let currOffset := 0x20\\n            let offsetEnd := add(currOffset, shl(5, mload(ids)))\\n\\n            // Infinite loop\\n            for { } 1 { } {\\n                // Get the id and amount\\n                let id := mload(add(ids, currOffset))\\n                let amount := mload(add(amounts, currOffset))\\n\\n                // Supply aware code block\\n                // If fraktion type == 1 (creator) or fraktion type > 2 & < 7 (payed fraktion)\\n                let fraktionType := and(id, 0xF)\\n                if or(eq(fraktionType, 1), and(gt(fraktionType, 2), lt(fraktionType, 7))) {\\n                    // Get the supply slot\\n                    // Kecak (id, _availableSupplies.slot)\\n                    mstore(0, id)\\n                    mstore(0x20, _availableSupplies.slot)\\n                    let availableSupplySlot := keccak256(0, 0x40)\\n                    let availableSupply := sload(availableSupplySlot)\\n                    // Ensure we have enough supply\\n                    if and(iszero(from), gt(amount, availableSupply)) {\\n                        mstore(0x00, _INSUFICIENT_SUPPLY_SELECTOR)\\n                        revert(0x1c, 0x04)\\n                    }\\n                    // Update the supply\\n                    if iszero(from) { availableSupply := sub(availableSupply, amount) }\\n                    if iszero(to) { availableSupply := add(availableSupply, amount) }\\n                    sstore(availableSupplySlot, availableSupply)\\n                }\\n\\n                // Increase our offset's\\n                currOffset := add(currOffset, 0x20)\\n\\n                // Exit if we reached the end\\n                if iszero(lt(currOffset, offsetEnd)) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Handle the transfer token (so update the content investor, change the owner of some content etc)\\n    function _afterTokenTransfer(\\n        address,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory\\n    )\\n        internal\\n        override\\n    {\\n        assembly {\\n            // Base offset to access array elements\\n            let currOffset := 0x20\\n            let offsetEnd := add(currOffset, shl(5, mload(ids)))\\n\\n            // Check if we got at least one fraktion needing callback (one that is higher than creator or free)\\n            let hasOneFraktionForCallback := false\\n\\n            // Infinite loop\\n            for { } 1 { } {\\n                // Get the id and amount\\n                let id := mload(add(ids, currOffset))\\n\\n                // Content owner migration code block\\n                if eq(and(id, 0xF), 1) {\\n                    let contentId := shr(0x04, id)\\n                    // Get the owner slot\\n                    // Kecak (contentId, owners.slot)\\n                    mstore(0, contentId)\\n                    mstore(0x20, owners.slot)\\n                    // Update the owner\\n                    sstore(keccak256(0, 0x40), to)\\n                    // Log the event\\n                    log3(0, 0, _CONTENT_OWNER_UPDATED_EVENT_SELECTOR, contentId, to)\\n                }\\n\\n                // Check if we need to include this in our filtered ids array\\n                hasOneFraktionForCallback := or(hasOneFraktionForCallback, gt(and(id, 0xF), 2))\\n\\n                // Increase our offset's\\n                currOffset := add(currOffset, 0x20)\\n\\n                // Exit if we reached the end\\n                if iszero(lt(currOffset, offsetEnd)) { break }\\n            }\\n\\n            // If no fraktion needing callback, exit directly\\n            if iszero(hasOneFraktionForCallback) { return(0, 0x20) }\\n            // If empty callback address, exit directly\\n            if iszero(sload(transferCallback.slot)) { return(0, 0x20) }\\n        }\\n\\n        // Call our callback\\n        transferCallback.onFraktionsTransferred(from, to, ArrayLib.asFraktionIds(ids), amounts);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                           Public view functions                            */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Batch balance of for single address\\n    function balanceOfIdsBatch(\\n        address account,\\n        FraktionId[] calldata ids\\n    )\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory batchBalances)\\n    {\\n        assembly {\\n            // Get the free mem pointer for our batch balances\\n            batchBalances := mload(0x40)\\n            // Store the size of our array\\n            mstore(batchBalances, ids.length)\\n            // Get where our array ends\\n            let end := add(ids.offset, shl(5, ids.length))\\n            // Current iterator offset\\n            let i := ids.offset\\n            // Current balance array offset\\n            let balanceOffset := add(batchBalances, 0x20)\\n            // Infinite loop\\n            for { } 1 { } {\\n                // Get the slot for the current id\\n                mstore(0, calldataload(i))\\n                mstore(0x20, 0xcb) // `_balances.slot` on the OZ contract\\n                // Store it as destination for the account balance we will check\\n                mstore(0x20, keccak256(0, 0x40))\\n                // Slot for the balance of the given account\\n                mstore(0, account)\\n                // Set the balance at the right index\\n                mstore(balanceOffset, sload(keccak256(0, 0x40)))\\n                // Increase the iterator\\n                i := add(i, 0x20)\\n                balanceOffset := add(balanceOffset, 0x20)\\n                // Exit if we reached the end\\n                if iszero(lt(i, end)) { break }\\n            }\\n            // Set the new free mem pointer\\n            mstore(0x40, balanceOffset)\\n        }\\n    }\\n\\n    /// @dev Find the owner of the given 'contentId'\\n    function ownerOf(ContentId contentId) external view returns (address) {\\n        return owners[ContentId.unwrap(contentId)];\\n    }\\n\\n    /// @dev Find the current supply of the given 'tokenId'\\n    function supplyOf(FraktionId tokenId) external view returns (uint256) {\\n        return _availableSupplies[FraktionId.unwrap(tokenId)];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IFrakToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { IERC20Upgradeable } from \\\"@oz-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\n/// @author @KONFeature\\n/// @title IFrakToken\\n/// @notice Interface for the FrakToken\\n/// @custom:security-contact contact@frak.id\\ninterface IFrakToken is IERC20Upgradeable {\\n    /// @dev error throwned when the contract cap is exceeded\\n    error CapExceed();\\n\\n    /// @dev Mint `amount` of FRK to `to`\\n    function mint(address to, uint256 amount) external;\\n\\n    /// @dev Burn `amount` of FRK\\n    function burn(uint256 amount) external;\\n\\n    /// @dev Returns the cap on the token's total supply.\\n    function cap() external view returns (uint256);\\n\\n    /// @dev EIP 2612, allow the owner to spend the given amount of FRK\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/roles/FrakAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { Initializable } from \\\"@oz-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { UUPSUpgradeable } from \\\"@oz-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport { ContextUpgradeable } from \\\"@oz-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport { FrakRoles } from \\\"./FrakRoles.sol\\\";\\nimport { NotAuthorized, RenounceForCallerOnly } from \\\"../utils/FrakErrors.sol\\\";\\n\\n/**\\n * @author @KONFeature\\n * @title FrakAccessControlUpgradeable\\n * @dev This contract provides an upgradeable access control framework, with roles and pausing functionality.\\n *\\n * Roles can be granted and revoked by a designated admin role, and certain functions can be restricted to certain roles\\n * using the 'onlyRole' modifier. The contract can also be paused, disabling all non-admin functionality.\\n *\\n * This contract is upgradeable, meaning that it can be replaced with a new implementation, while preserving its state.\\n *\\n * @custom:security-contact contact@frak.id\\n */\\nabstract contract FrakAccessControlUpgradeable is Initializable, ContextUpgradeable, UUPSUpgradeable {\\n    /* -------------------------------------------------------------------------- */\\n    /*                               Custom errors                                */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev 'bytes4(keccak256(bytes(\\\"NotAuthorized()\\\")))'\\n    uint256 private constant _NOT_AUTHORIZED_SELECTOR = 0xea8e4eb5;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Events                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Event emitted when a role is granted\\n    event RoleGranted(address indexed account, bytes32 indexed role);\\n    /// @dev Event emitted when a role is revoked\\n    event RoleRevoked(address indexed account, bytes32 indexed role);\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Storage                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Is this contract currently paused ?\\n    /// @dev Unused now, since pausim mecanism isn't here anymore, can be reused\\n    bool private _paused;\\n\\n    /// @dev Mapping of roles -> user -> hasTheRight\\n    mapping(bytes32 roles => mapping(address user => bool isAllowed)) private _roles;\\n\\n    /// @dev Initialise the contract and also grant the role to the msg sender\\n    function __FrakAccessControlUpgradeable_init() internal onlyInitializing {\\n        __Context_init();\\n        __UUPSUpgradeable_init();\\n\\n        _grantRole(FrakRoles.ADMIN, msg.sender);\\n        _grantRole(FrakRoles.UPGRADER, msg.sender);\\n\\n        // Tell we are not paused at start\\n        _paused = false;\\n    }\\n\\n    /// @dev Initialise the contract and also grant the role to the msg sender\\n    function __FrakAccessControlUpgradeable_Minter_init() internal onlyInitializing {\\n        __FrakAccessControlUpgradeable_init();\\n\\n        _grantRole(FrakRoles.MINTER, msg.sender);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                          External write functions                          */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Grant the `role` to the `account`\\n    function grantRole(bytes32 role, address account) external onlyRole(FrakRoles.ADMIN) {\\n        _grantRole(role, account);\\n    }\\n\\n    /// @dev Revoke the `role` to the `account`\\n    function revokeRole(bytes32 role, address account) external onlyRole(FrakRoles.ADMIN) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /// @dev `Account` renounce to the `role`\\n    function renounceRole(bytes32 role, address account) external {\\n        if (account != msg.sender) revert RenounceForCallerOnly();\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                          External view functions                           */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Check if the user has the given role\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role][account];\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                          Internal write functions                          */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Grant the `role` to the `account`\\n    function _grantRole(bytes32 role, address account) internal {\\n        if (!hasRole(role, account)) {\\n            _roles[role][account] = true;\\n            emit RoleGranted(account, role);\\n        }\\n    }\\n\\n    /// @dev Revoke the given `role` to the `account`\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role][account] = false;\\n            emit RoleRevoked(account, role);\\n        }\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                          Internal view functions                           */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Check that the calling user have the right `role`\\n    function _checkRole(bytes32 role) private view {\\n        address sender = msg.sender;\\n        assembly {\\n            // Kecak (role, _roles.slot)\\n            mstore(0, role)\\n            mstore(0x20, _roles.slot)\\n            let roleSlote := keccak256(0, 0x40)\\n            // Kecak (acount, roleSlot)\\n            mstore(0, sender)\\n            mstore(0x20, roleSlote)\\n            let slot := keccak256(0, 0x40)\\n\\n            // Get var at the given slot\\n            let hasTheRole := sload(slot)\\n\\n            // Ensre the user has the right roles\\n            if eq(hasTheRole, false) {\\n                mstore(0x00, _NOT_AUTHORIZED_SELECTOR)\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                 Modifiers                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * @notice Ensure the calling user have the right role\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @notice Authorize the upgrade of this contract\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(FrakRoles.UPGRADER) { }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/FrakErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\n// Access control error (when accessing unauthorized method, or renouncing role that he havn't go)\\nerror RenounceForCallerOnly();\\nerror NotAuthorized();\\n\\n// Generic error used for all the contract\\nerror InvalidArray();\\nerror InvalidAddress();\\nerror NoReward();\\nerror RewardTooLarge();\\nerror BadgeTooLarge();\\nerror InvalidFraktionType();\\n\\n/// @dev error throwned when the signer is invalid\\nerror InvalidSigner();\\n/// @dev error throwned when the permit delay is expired\\nerror PermitDelayExpired();\\n\"\r\n    },\r\n    \"lib/solady/src/utils/Multicallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Contract that enables a single call to call multiple methods on itself.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Multicallable.sol)\\nabstract contract Multicallable {\\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\\n    /// If any of the `DELEGATECALL`s reverts, the entire context is reverted,\\n    /// and the error is bubbled up.\\n    ///\\n    /// This function is deliberately made non-payable to guard against double-spending.\\n    /// (See: https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong)\\n    ///\\n    /// For efficiency, this function will directly return the results, terminating the context.\\n    /// If called internally, it must be called at the end of a function\\n    /// that returns `(bytes[] memory)`.\\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory) {\\n        assembly {\\n            mstore(0x00, 0x20)\\n            mstore(0x20, data.length) // Store `data.length` into `results`.\\n            // Early return if no data.\\n            if iszero(data.length) { return(0x00, 0x40) }\\n\\n            let results := 0x40\\n            // `shl` 5 is equivalent to multiplying by 0x20.\\n            let end := shl(5, data.length)\\n            // Copy the offsets from calldata into memory.\\n            calldatacopy(0x40, data.offset, end)\\n            // Offset into `results`.\\n            let resultsOffset := end\\n            // Pointer to the end of `results`.\\n            end := add(results, end)\\n\\n            for {} 1 {} {\\n                // The offset of the current bytes in the calldata.\\n                let o := add(data.offset, mload(results))\\n                let memPtr := add(resultsOffset, 0x40)\\n                // Copy the current bytes from calldata to the memory.\\n                calldatacopy(\\n                    memPtr,\\n                    add(o, 0x20), // The offset of the current bytes' bytes.\\n                    calldataload(o) // The length of the current bytes.\\n                )\\n                if iszero(delegatecall(gas(), address(), memPtr, calldataload(o), 0x00, 0x00)) {\\n                    // Bubble up the revert if the delegatecall reverts.\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n                // Append the current `resultsOffset` into `results`.\\n                mstore(results, resultsOffset)\\n                results := add(results, 0x20)\\n                // Append the `returndatasize()`, and the return data.\\n                mstore(memPtr, returndatasize())\\n                returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\\n                // Advance the `resultsOffset` by `returndatasize() + 0x20`,\\n                // rounded up to the next multiple of 32.\\n                resultsOffset :=\\n                    and(add(add(resultsOffset, returndatasize()), 0x3f), 0xffffffffffffffe0)\\n                if iszero(lt(results, end)) { break }\\n            }\\n            return(0x00, add(resultsOffset, 0x40))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for gas griefing protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If gas griefing protection is needed, please use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), gas(), 0x00, gas(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\\n                    returndatacopy(gas(), returndatasize(), shr(20, gas())) // For gas estimation.\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, gas(), 0x00, gas(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), gas(), 0x00, gas(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, 0x00, 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/ERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155Upgradeable.sol\\\";\\nimport \\\"./IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\\n    using AddressUpgradeable for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\\n        __ERC1155_init_unchained(uri_);\\n    }\\n\\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: address zero is not a valid owner\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) public view virtual override returns (uint256[] memory) {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[47] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/fraktions/FraktionTransferCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { FraktionId } from \\\"../libs/FraktionId.sol\\\";\\n\\n/// @author @KONFeature\\n/// @title FraktionTransferCallback\\n/// @notice Interface for contract who want to listen of the fraktion transfer (ERC1155 tokens transfer)\\n/// @custom:security-contact contact@frak.id\\ninterface FraktionTransferCallback {\\n    /**\\n     * @dev Function called when a fraktion is transfered between two person\\n     */\\n    function onFraktionsTransferred(\\n        address from,\\n        address to,\\n        FraktionId[] memory ids,\\n        uint256[] memory amount\\n    )\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"contracts/libs/ArrayLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { FraktionId } from \\\"./FraktionId.sol\\\";\\n\\n/// @author @KONFeature\\n/// @title ArrayLib\\n/// @notice Lib to help us manage array\\n/// @custom:security-contact contact@frak.id\\nlibrary ArrayLib {\\n    /// @dev Wrap a uint256 to a FraktionId type\\n    function asFraktionIds(uint256[] memory self) internal pure returns (FraktionId[] memory fraktionIds) {\\n        assembly {\\n            fraktionIds := self\\n        }\\n    }\\n\\n    /// @dev Create a singleton array of the given element\\n    function asSingletonArray(uint256 element) internal pure returns (uint256[] memory array) {\\n        assembly {\\n            // Get free memory space for our array, and update the free mem space index\\n            array := mload(0x40)\\n            mstore(0x40, add(array, 0x40))\\n\\n            // Store our array (1st = length, 2nd = element)\\n            mstore(array, 0x01)\\n            mstore(add(array, 0x20), element)\\n        }\\n    }\\n\\n    /// @dev Create a singleton array of the given element\\n    function asSingletonArray(address element) internal pure returns (address[] memory array) {\\n        assembly {\\n            // Get free memory space for our array, and update the free mem space index\\n            array := mload(0x40)\\n            mstore(0x40, add(array, 0x40))\\n\\n            // Store our array (1st = length, 2nd = element)\\n            mstore(array, 0x01)\\n            mstore(add(array, 0x20), element)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/EIP712Diamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU GPLv3\\npragma solidity 0.8.21;\\n\\nimport { Initializable } from \\\"@oz-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/// @author @KONFeature\\n/// @title EIP712Diamond\\n/// @notice EIP712Diamond base contract with diamond storage\\n/// @custom:security-contact contact@frak.id\\n/// TODO: Use OZ5 -> Import another submodule based on OZ 5.0\\ncontract EIP712Diamond {\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        address verifyingContract;\\n        bytes32 salt;\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                 Constants                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev The current version of the erc712, 2 since we switch between inline storage to diamond storage\\n    string internal constant ERC712_VERSION = \\\"2\\\";\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"));\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   Storage                                  */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev The storage struct for eip 712\\n    struct EIP712Storage {\\n        /// @dev The current domain seperator\\n        bytes32 _domainSeperator;\\n        /// @dev Nonces per account\\n        mapping(address account => uint256 nonce) _nonces;\\n    }\\n\\n    /// @dev Access the storage struct of the contract\\n    function _getEIP712Storage() internal pure returns (EIP712Storage storage $) {\\n        assembly {\\n            // keccak256(abi.encode(uint256(keccak256(\\\"EIP712Diamond\\\")) - 1)) & ~bytes32(uint256(0xff))\\n            $.slot := 0x8525956dfba681ee43bd6f7490f38cd4b2b234d15019aabbaf5a265041a3fb00\\n        }\\n    }\\n\\n    /// @dev init function\\n    function _initializeEIP712(string memory name) internal {\\n        // Build and set the domain separator\\n        _getEIP712Storage()._domainSeperator = keccak256(\\n            abi.encode(\\n                EIP712_DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                keccak256(bytes(ERC712_VERSION)),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                             Public view methods                            */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /// @dev Current domain seperator\\n    function getDomainSeperator() public view returns (bytes32) {\\n        return _getEIP712Storage()._domainSeperator;\\n    }\\n\\n    /// @dev Get the current 'nonce' for the given 'user'\\n    function getNonce(address user) public view returns (uint256) {\\n        return _getEIP712Storage()._nonces[user];\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                             Internal functions                             */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n     * Accept message hash and returns hash message in EIP712 compatible form\\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\\n     * https://eips.ethereum.org/EIPS/eip-712\\n     * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\n     * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\n     */\\n    function toTypedMessageHash(bytes32 messageHash) internal view returns (bytes32 digest) {\\n        bytes32 separator = _getEIP712Storage()._domainSeperator;\\n        assembly {\\n            // Compute the digest.\\n            mstore(0x00, 0x1901000000000000) // Store \\\"\\\\x19\\\\x01\\\".\\n            mstore(0x1a, separator) // Store the domain separator.\\n            mstore(0x3a, messageHash) // Store the message hash.\\n            digest := keccak256(0x18, 0x42)\\n            // Restore the part of the free memory slot that was overwritten.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /// @dev Use the current 'nonce' for the given 'user' (and increment it)\\n    function useNonce(address user) internal returns (uint256) {\\n        return _getEIP712Storage()._nonces[user]++;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers.\\n/// Please use EIP712 with a nonce included in the digest to prevent replay attacks.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary ECDSA {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The signature is invalid.\\n    error InvalidSignature();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    RECOVERY OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Note: as of Solady version 0.0.68, these functions will\\n    // revert upon recovery failure for more safety by default.\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            let signatureLength := mload(signature)\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        eq(signatureLength, 65), // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        eq(signature.length, 65), // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    ///\\n    /// This function only accepts EIP-2098 short form signatures.\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   TRY-RECOVER OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // WARNING!\\n    // These functions will NOT revert upon recovery failure.\\n    // Instead, they will return the zero address upon recovery failure.\\n    // It is critical that the returned address is NEVER compared against\\n    // a zero address (e.g. an uninitialized address variable).\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            let signatureLength := mload(signature)\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    eq(signatureLength, 65), // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the `signature`.\\n    ///\\n    /// This function does NOT accept EIP-2098 short form signatures.\\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\\n    /// short form signatures instead.\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    eq(signature.length, 65), // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    ///\\n    /// This function only accepts EIP-2098 short form signatures.\\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/IERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1967Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"@forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@oz-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"swap-pool/=lib/swap-pool/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/node_modules/@openzeppelin/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=lib/openzeppelin-contracts/node_modules/hardhat/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"prb-test/=lib/prb-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000,\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExpectingOnlyFreeFraktion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFraktionType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RenounceForCallerOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyFraktion\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ContentMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fraktionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"FractionMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"badge\",\"type\":\"uint256\"}],\"name\":\"FraktionCostBadgeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"autoMintHolder\",\"type\":\"address\"}],\"name\":\"addAutoMintedContent\",\"outputs\":[{\"internalType\":\"ContentId\",\"name\":\"contentId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contentOwnerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"commonSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premiumSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"goldSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"diamondSupply\",\"type\":\"uint256\"}],\"name\":\"addContent\",\"outputs\":[{\"internalType\":\"ContentId\",\"name\":\"contentId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contentOwnerAddress\",\"type\":\"address\"}],\"name\":\"addContentForCreator\",\"outputs\":[{\"internalType\":\"ContentId\",\"name\":\"contentId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"FraktionId\",\"name\":\"fraktionId\",\"type\":\"uint256\"}],\"name\":\"getCostBadge\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"fraktionBadge\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"FraktionId\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"name\":\"increaseSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"frkTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fraktionTokensAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"foundationAddr\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"FraktionId\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mintFraktion\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"FraktionId\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"mintFraktion\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"FraktionId\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mintFraktionForUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"FraktionId\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"mintFreeFraktion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"FraktionId\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mintFreeFraktionForUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"FraktionId\",\"name\":\"fraktionId\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"badge\",\"type\":\"uint96\"}],\"name\":\"updateCostBadge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Minter", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}