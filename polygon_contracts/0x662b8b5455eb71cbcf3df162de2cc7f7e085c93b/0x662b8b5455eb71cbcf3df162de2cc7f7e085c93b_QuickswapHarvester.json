{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/cygnus-harvesters/CygnusHarvester.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  CygnusHarvester.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n/*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  \\n    .               .            .               .      \ud83d\udef0\ufe0f     .           .                .           .\\n           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           ---======*.                                                 .           \u2800\\n          \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588                                               \ud83d\udce1                \ud83c\udf14                         . \\n         \u2588\u2588\u2588     \u2591\u2591\u2591  \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588        \u2800\\n        \u2591\u2588\u2588\u2588         \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591      .     .\u2800           .          \\n        \u2591\u2588\u2588\u2588          \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588       \u2800\\n        \u2591\u2591\u2588\u2588\u2588     \u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2588\u2588\u2588              .             .\u2800\\n         \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588     .----===*  \u2800\\n          \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591   \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591\u2591            .                            .\u2800\\n                       \u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588 \u2591\u2588\u2588\u2588                .                 .                 .  \u2800\\n     \ud83d\udef0\ufe0f  .             \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588                                             .                 .           \\n                       \u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591      -------=========*                      .                     \u2800\\n           .                            .       .          .            .                          .             .\u2800\\n    \\n        CYGNUS HARVESTER - X1 Vault Base Harvester                                                           \\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\npragma solidity >=0.8.17;\\n\\n// Dependencies\\nimport {ICygnusHarvester} from \\\"./interfaces/ICygnusHarvester.sol\\\";\\nimport {ReentrancyGuard} from \\\"./utils/ReentrancyGuard.sol\\\";\\n\\n// Libraries\\nimport {SafeTransferLib} from \\\"./libraries/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./libraries/FixedPointMathLib.sol\\\";\\n\\n// Interfaces\\nimport {IERC20} from \\\"./interfaces/core/IERC20.sol\\\";\\nimport {IHangar18} from \\\"./interfaces/core/IHangar18.sol\\\";\\nimport {ICygnusTerminal} from \\\"./interfaces/core/ICygnusTerminal.sol\\\";\\nimport {ICygnusX1Vault} from \\\"./interfaces/core/ICygnusX1Vault.sol\\\";\\n\\n// Aggregators\\nimport {IAggregationRouterV5, IAggregationExecutor} from \\\"./interfaces/aggregators/IAggregationRouterV5.sol\\\";\\n\\n/**\\n *  @title CygnusHarvester\\n *  @author CygnusDAO\\n *  @notice Base harvester for both borrowable and collateral pools\\n */\\nabstract contract CygnusHarvester is ICygnusHarvester, ReentrancyGuard {\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            1. LIBRARIES\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @custom:library SafeTransferLib For safe transfers of Erc20 tokens\\n     */\\n    using SafeTransferLib for address;\\n\\n    /**\\n     *  @custom:library FixedPointMathLib Arithmetic library with operations for fixed-point numbers\\n     */\\n    using FixedPointMathLib for uint256;\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            2. STORAGE\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Public \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    address public constant override ONE_INCH_ROUTER_V5 = 0x1111111254EEB25477B68fb85Ed929f73A960582;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    mapping(address => Harvester) public override harvesters;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    address[] public override allRewardTokens;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    mapping(address => bool) public isRewardToken;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    uint256 public override lastX1Collect;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    uint256 public override x1VaultReward = 0.22e18;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    uint256 public override harvesterReward = 0.03e18;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    IHangar18 public immutable override hangar18;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    address public immutable override usd;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    address public immutable override nativeToken;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    address public immutable override cygnusX1Vault;\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    bool public override simpleHarvest;\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTRUCTOR\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @notice Constructs the harvester, use the hangar18 contract to get important addresses\\n     *  @param _hangar18 The address of the contract that deploys Cygnus lending pools on this chain\\n     */\\n    constructor(IHangar18 _hangar18) {\\n        // Hangar18 on this chain\\n        hangar18 = _hangar18;\\n\\n        // Get native token for this chain (ie WETH)\\n        nativeToken = _hangar18.nativeToken();\\n\\n        // Get native token for this chain (ie WETH)\\n        usd = _hangar18.usd();\\n\\n        // Vault\\n        cygnusX1Vault = _hangar18.cygnusX1Vault();\\n    }\\n\\n    /**\\n     *  @dev This function is called for plain Ether transfers\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     *  @dev Fallback function is executed if none of the other functions match the function identifier or no data was provided\\n     */\\n    fallback() external payable {}\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. MODIFIERS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /// @custom:modifier cygnusAdmin Controls important parameters in both Collateral and Borrow contracts \ud83d\udc7d\\n    modifier cygnusAdmin() {\\n        // If msg.sender not hangar18 admin then reverts tx\\n        checkAdminPrivate();\\n        _;\\n    }\\n\\n    modifier onlyEOA() {\\n        // If msg.sender not tx.origin then reverts the tx\\n        checkEOAPrivate();\\n        _;\\n    }\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            5. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Private \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Checks that sender is admin\\n     */\\n    function checkAdminPrivate() private view {\\n        // Current admin from the factory\\n        address admin = hangar18.admin();\\n\\n        /// @custom:error MsgSenderNotAdmin Avoid unless caller is Cygnus Admin\\n        if (msg.sender != admin) revert CygnusHarvester__MsgSenderNotAdmin();\\n    }\\n\\n    /**\\n     *  @notice Checks that sender is origin\\n     */\\n    function checkEOAPrivate() private view {\\n        /// @custom:error CygnusHarvester__OnlyEOA Avoid unless caller is origin\\n        if (msg.sender != tx.origin) revert CygnusHarvester__OnlyEOAAllowed();\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Internal \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Checks the `token` balance of this contract\\n     *  @param token The token to view balance of\\n     *  @return amount This contract's `token` balance\\n     */\\n    function _checkBalance(address token) internal view returns (uint256) {\\n        // Our balance of `token`\\n        return token.balanceOf(address(this));\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Public \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    function rewardTokenBalanceAtIndex(uint256 index) public view override returns (uint256) {\\n        // Get our balance of reward token at `index`\\n        return _checkBalance(allRewardTokens[index]);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    function rewardTokensLength() public view override returns (uint256) {\\n        // Return the amount of tokens we are sending to X1 Vault\\n        return allRewardTokens.length;\\n    }\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            6. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Private \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Collects the reward token amount held by this contract and sends to vault\\n     *  @param rewardToken The address of the token we are approving\\n     */\\n    function collectX1RewardTokenPrivate(address rewardToken) private {\\n        // Get our balance of reward token `i`\\n        uint256 balance = _checkBalance(rewardToken);\\n\\n        // Check for balance\\n        if (balance > 0) {\\n            // Transfer to the vault\\n            rewardToken.safeTransfer(cygnusX1Vault, balance);\\n\\n            // Update reward in vault\\n            ICygnusX1Vault(cygnusX1Vault).updateReward(rewardToken);\\n        }\\n    }\\n\\n    /**\\n     *  @notice Adds a reward token to be collected by the X1 Vault on this chain\\n     *  @param rewardToken The address of the token to be added\\n     */\\n    function addRewardTokenPrivate(address rewardToken) private {\\n        // Push reward token to array\\n        allRewardTokens.push(rewardToken);\\n\\n        // Mark as true\\n        isRewardToken[rewardToken] = true;\\n\\n        /// @custom:event NewX1RewardToken\\n        emit RewardTokenAdded(rewardToken, allRewardTokens.length);\\n    }\\n\\n    /**\\n     *  @notice Removes a reward token from the harvester\\n     *  @param rewardToken The address of the token to be removed\\n     */\\n    function removeRewardTokenPrivate(address rewardToken) private {\\n        // Mark as false\\n        isRewardToken[rewardToken] = false;\\n\\n        // Gas savings\\n        uint256 length = allRewardTokens.length;\\n\\n        // Loop through each reward token\\n        for (uint256 i; i < length; i++) {\\n            // If token is found then we remove it\\n            if (allRewardTokens[i] == rewardToken) {\\n                // Move token to the last index of the array\\n                allRewardTokens[i] = allRewardTokens[length - 1];\\n\\n                // Pop last index\\n                allRewardTokens.pop();\\n\\n                // Escape\\n                break;\\n            }\\n        }\\n\\n        /// @custom:event RewardTokenRemoved\\n        emit RewardTokenRemoved(rewardToken, allRewardTokens.length);\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Internal \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract\\n     *  @param token The address of the token we are approving\\n     *  @param amount The amount to approve\\n     */\\n    function _approveToken(address token, address to, uint256 amount) internal {\\n        // Check allowance for `router` for deposit\\n        if (IERC20(token).allowance(address(this), to) >= amount) return;\\n\\n        // Is less than amount, safe approve max\\n        token.safeApprove(to, type(uint256).max);\\n    }\\n\\n    /**\\n     *  @notice Processes rewards for the caller of the harvest/reinvest and for the X1 Vault\\n     *  @param token The address of the rewardToken\\n     *  @param amount Our balance of `token`\\n     *  @return The amount of `token` left after processing rewards\\n     */\\n    function _processX1Rewards(address token, uint256 amount) internal returns (uint256) {\\n        // Calculate the amount that the X1 Vault receives\\n        uint256 x1Reward = amount.mulWad(x1VaultReward);\\n\\n        // Transfer to the X1 Vault\\n        if (x1Reward > 0) token.safeTransfer(cygnusX1Vault, x1Reward);\\n\\n        // Return balance left of the reward token that is left to be reinvested\\n        return _checkBalance(token);\\n    }\\n\\n    /**\\n     *  @notice Creates the swap with 1Inch's AggregatorV5. We pass an extra param `updatedAmount` to eliminate\\n     *          any slippage from the byte data passed.\\n     *  @param swapdata The data from 1inch `swap` query\\n     *  @param srcAmount The balanceOf this contract`s srcToken\\n     *  @return amountOut The amount received of destination token\\n     */\\n    function _swapTokensOneInch(\\n        bytes calldata swapdata,\\n        address srcToken,\\n        uint256 srcAmount,\\n        address dstToken,\\n        address receiver\\n    ) internal returns (uint256 amountOut) {\\n        // Get aggregation executor, swap params and the encoded calls for the executor from 1inch API call\\n        (address caller, IAggregationRouterV5.SwapDescription memory desc, , bytes memory data) = abi.decode(\\n            swapdata,\\n            (address, IAggregationRouterV5.SwapDescription, bytes, bytes)\\n        );\\n\\n        // Update swap amount to current balance of src token (if needed)\\n        if (desc.amount != srcAmount) desc.amount = srcAmount;\\n\\n        /// @custom:error SrcTokenNotValid Avoid swapping anything but the harvested token\\n        if (address(desc.srcToken) != srcToken) revert CygnusHarvester__SrcTokenNotValid();\\n\\n        /// @custom;error DstTokenNotValid Avoid swapping to anything but the harvester's want token\\n        if (address(desc.dstToken) != dstToken) revert CygnusHarvester__DstTokenNotValid();\\n\\n        /// @custom:error DstReceiverNotValid Avoid swapping to anyone but the harvester's receiver address\\n        if (desc.dstReceiver != receiver) revert CygnusHarvester__DstReceiverNotValid();\\n\\n        // Approve 1Inch Router in `srcToken` if necessary\\n        _approveToken(srcToken, ONE_INCH_ROUTER_V5, srcAmount);\\n\\n        // Swap `srcToken` to `dstToken` passing empty permit bytes\\n        (amountOut, ) = IAggregationRouterV5(ONE_INCH_ROUTER_V5).swap(IAggregationExecutor(caller), desc, new bytes(0), data);\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 External \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     *  @custom:security only-admin\\n     */\\n    function getRewards(address terminal) external override nonReentrant returns (address[] memory tokens, uint256[] memory amounts) {\\n        // Tokens and amounts harvested\\n        (tokens, amounts) = ICygnusTerminal(terminal).getRewards();\\n\\n        // Return the amounts to be reinvested by substracting the vault reward from the harvested amount.\\n        // The full amounts are accessible on the terminal contracts.\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            // Substract the harvested amount by the vault and harvester rewards\\n            amounts[i] -= amounts[i].mulWad(x1VaultReward);\\n        }\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     *  @custom:security only-admin\\n     */\\n    function harvestToX1Vault(address terminal) external virtual override nonReentrant {\\n        /// @custom;error SimpleHarvestNotEnabled Avoid if simple harvest has not been enabled yet\\n        if (!simpleHarvest) revert CygnusHarvester__SimpleHarvestNotEnabled();\\n\\n        // Harvest rewards\\n        (address[] memory tokens, uint256[] memory amounts) = ICygnusTerminal(terminal).getRewards();\\n\\n        // Loop through each token\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            // If amount `i` is greater than 0\\n            if (amounts[i] > 0 && isRewardToken[tokens[i]]) {\\n                // Caller reward\\n                uint256 harvesterAmount = amounts[i].mulWad(harvesterReward);\\n\\n                // Transfer to harvester\\n                tokens[i].safeTransferFrom(terminal, msg.sender, harvesterAmount);\\n\\n                // Transfer the rest to the vault\\n                tokens[i].safeTransferFrom(terminal, cygnusX1Vault, amounts[i] - harvesterAmount);\\n\\n                // Update reward\\n                ICygnusX1Vault(cygnusX1Vault).updateReward(tokens[i]);\\n            }\\n        }\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     *  @custom:security only-admin\\n     */\\n    function collectX1RewardsAll() external override nonReentrant {\\n        // Gas savings, get all reward tokens\\n        address[] memory rewardTokens = allRewardTokens;\\n\\n        // Loop through each reward token\\n        for (uint256 i = 0; i < rewardTokens.length; i++) {\\n            // Check balance and send private\\n            collectX1RewardTokenPrivate(rewardTokens[i]);\\n        }\\n\\n        /// @custom:event CygnusX1VaultCollect\\n        emit CygnusX1VaultCollect(lastX1Collect = block.timestamp, msg.sender, allRewardTokens.length);\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ADMIN ONLY \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     *  @custom:security only-admin\\n     */\\n    function addRewardToken(address rewardToken) public override cygnusAdmin {\\n        /// @custom;error RewardTokenAlreadyAdded\\n        if (isRewardToken[rewardToken]) revert CygnusHarvester__RewardTokenAlreadyAdded();\\n\\n        // Add reward token to array and mark it as true in mapping\\n        addRewardTokenPrivate(rewardToken);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     *  @custom:security only-admin\\n     */\\n    function removeRewardToken(address rewardToken) public override cygnusAdmin {\\n        /// @custom;error RewardTokenNotAdded\\n        if (!isRewardToken[rewardToken]) revert CygnusHarvester__RewardTokenNotAdded();\\n\\n        // Remove reward token from array and remove from mapping\\n        removeRewardTokenPrivate(rewardToken);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     *  @custom:security only-admin\\n     */\\n    function setTerminalHarvester(address terminal, address wantToken, address receiver) external override cygnusAdmin {\\n        // Get the underlying\\n        address underlying = ICygnusTerminal(terminal).underlying();\\n\\n        // Make harvester\\n        Harvester memory harvester = Harvester({underlying: underlying, terminal: terminal, wantToken: wantToken, receiver: receiver});\\n\\n        // Set harvester\\n        harvesters[terminal] = harvester;\\n\\n        /// @custom:event NewHarvester\\n        emit NewHarvester(terminal, underlying, wantToken, receiver);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     *  @custom:security only-admin\\n     */\\n    function setWeightX1Vault(uint256 newWeight) external override cygnusAdmin {\\n        /// @custom:error X1VaultRewardTooHigh Avoid setting reward above 50%\\n        if (newWeight > 0.5e18) revert CygnusHarvester__X1VaultRewardTooHigh();\\n\\n        // X1 Vault reward weight up until now\\n        uint256 oldWeight = x1VaultReward;\\n\\n        /// @custom:event NewX1VaultWeight\\n        emit NewX1VaultWeight(oldWeight, x1VaultReward = newWeight);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     *  @custom:security only-admin\\n     */\\n    function setWeightHarvester(uint256 newWeight) external override cygnusAdmin {\\n        /// @custom:error X1VaultRewardTooHigh Avoid setting reward above 10%\\n        if (newWeight > 0.1e18) revert CygnusHarvester__HarvestRewardTooHigh();\\n\\n        // X1 Vault reward weight up until now\\n        uint256 oldWeight = harvesterReward;\\n\\n        /// @custom:event NewX1VaultWeight\\n        emit NewHarvesterWeight(oldWeight, harvesterReward = newWeight);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     *  @custom:security only-admin\\n     */\\n    function switchSimpleHarvest() external override cygnusAdmin {\\n        // Switch on/off\\n        simpleHarvest = !simpleHarvest;\\n\\n        /// @custom:event SimpleHarvestSwitch\\n        emit SimpleHarvestSwitch(simpleHarvest);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/interfaces/aggregators/IAggregationRouterV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.17;\\n\\nimport {IERC20} from \\\"../core/IERC20.sol\\\";\\n\\n/**\\n *  @title Interface for making arbitrary calls during swap\\n */\\ninterface IAggregationExecutor {\\n    /**\\n     *  @notice Executes calls for `msgSender`\\n     */\\n    function execute(address msgSender) external payable; // 0x4b64e492\\n}\\n\\n/**\\n * @title IAggregationRouterV4 OneInch's Aggregation Router\\n */\\ninterface IAggregationRouterV5 {\\n    /**\\n     *  @custom:member srcToken The address of the token we are swapping\\n     *  @custom:member dstToken The address of the token we are receiving\\n     *  @custom:member srcReceiver The address that is swapping the tokens\\n     *  @custom:member dstReceiver The address that is receiving the tokens\\n     *  @custom:member amount Amount of `srcToken` we are swapping\\n     *  @custom:member minReturnAmount The min return amount of `srcToken`\\n     *  @custom:member flags Flags for the swap\\n     */\\n    struct SwapDescription {\\n        IERC20 srcToken;\\n        IERC20 dstToken;\\n        address payable srcReceiver;\\n        address payable dstReceiver;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 flags;\\n    }\\n\\n    /**\\n     * @notice Performs a swap, delegating all calls encoded in `data` to `caller`. See tests for usage examples\\n     * @param caller Aggregation executor that executes calls described in `data`\\n     * @param desc Swap description\\n     * @param data Encoded calls that `caller` should execute in between of swaps\\n     * @param permit Permit data for the swap, we pass LOCAL_BYTES\\n     * @return returnAmount Resulting token amount\\n     * @return spentAmount Spent amount from the swap\\n     */\\n    function swap(\\n        IAggregationExecutor caller,\\n        SwapDescription calldata desc,\\n        bytes calldata permit,\\n        bytes calldata data\\n    ) external payable returns (uint256 returnAmount, uint256 spentAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/interfaces/core/ICygnusNebulaRegistry.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  ICygnusNebulaRegistry.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/**\\n *  @title ICygnusNebulaRegistry Interface to interact with Cygnus' LP Oracle\\n *  @author CygnusDAO\\n */\\ninterface ICygnusNebulaRegistry {\\n    /**\\n     *  @notice Gets the latest info for an initialized LP Token\\n     *  @param lpTokenPair The address of the LP Token\\n     *  @return tokens Array of addresses of all the LP's assets\\n     *  @return prices Array of prices of each asset (in denom token)\\n     *  @return reserves Array of reserves of each asset in the LP\\n     *  @return tokenDecimals Array of decimals of each token\\n     *  @return reservesUsd Array of reserves of each asset in USD\\n     */\\n    function getLPTokenInfo(\\n        address lpTokenPair\\n    )\\n        external\\n        view\\n        returns (\\n            IERC20[] memory tokens,\\n            uint256[] memory prices,\\n            uint256[] memory reserves,\\n            uint256[] memory tokenDecimals,\\n            uint256[] memory reservesUsd\\n        );\\n}\\n\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/interfaces/core/ICygnusTerminal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.17;\\n\\n// Interfaces\\nimport {IHangar18} from \\\"./IHangar18.sol\\\";\\n\\n/**\\n *  @notice Simple interface for Cygnus Vault tokens (CygUSD and CygLP) with functions only needed for the harvester\\n */\\ninterface ICygnusTerminal {\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n           3. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Public \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @return hangar18 The address of the Cygnus Factory contract used to deploy this shuttle\\n     */\\n    function hangar18() external view returns (IHangar18);\\n\\n    /**\\n     *  @return underlying The address of the underlying (LP Token for collateral contracts, USDC for borrow contracts)\\n     */\\n    function underlying() external view returns (address);\\n\\n    /**\\n     *  @return shuttleId The ID of this shuttle (shared by Collateral and Borrow)\\n     */\\n    function shuttleId() external view returns (uint256);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 External \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Get the pending rewards manually - helpful to get rewards through static calls\\n     *\\n     *  @return tokens The addresses of the reward tokens earned by harvesting rewards\\n     *  @return amounts The amounts of each token received\\n     *\\n     *  @custom:security non-reentrant\\n     */\\n    function getRewards() external returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /**\\n     *  @notice Only the harvester can reinvest\\n     *  @notice Reinvests all rewards from the rewarder to buy more USD to then deposit back into the rewarder\\n     *          This makes totalBalance increase in this contract, increasing the exchangeRate between\\n     *          CygUSD and underlying and thus lowering utilization rate and borrow rate\\n     *\\n     *  @custom:security only-harvester\\n     */\\n    function reinvestRewards_y7b(uint256 liquidity) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/interfaces/core/ICygnusX1Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.17;\\n\\nimport {IHangar18} from \\\"./IHangar18.sol\\\";\\n\\n// Vault\\ninterface ICygnusX1Vault {\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            1. CUSTOM ERRORS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @dev Reverts when withdrawing more than user balance\\n     *  @custom:error AmountExceedsBalance\\n     */\\n    error CygnusX1Vault__AmountExceedsBalance();\\n\\n    /**\\n     *  @dev Reverts when msg.sender is not admin\\n     *  @custom:error MsgSenderNotAdmin\\n     */\\n    error CygnusX1Vault__MsgSenderNotAdmin();\\n\\n    /**\\n     *  @dev Reverts when attempting to change state of a non-existing token \\n     *  @custom:error InvalidRewardToken\\n     */\\n    error CygnusX1Vault__InvalidRewardToken();\\n\\n    /**\\n     *  @dev Reverts when adding an already-added token\\n     *  @custom:error TokenAlreadyAdded\\n     */\\n    error CygnusX1Vault__TokenAlreadyAdded();\\n\\n    /**\\n     *  @dev Reverts when the deposit fee set is above max\\n     *  @custom:error DepositFeeTooHigh\\n     */\\n    error CygnusX1Vault__DepositFeeTooHigh();\\n\\n    /**\\n     *  @dev Reverts when adding more tokens than max allowed vault size\\n     *  @custom:error VaultIsFull\\n     */\\n    error CygnusX1Vault__VaultIsFull();\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            2. CUSTOM EVENTS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @notice Emitted when a user deposits CYG\\n     *  @param user The address of the user that deposited\\n     *  @param amount The amount of CYG deposited\\n     *  @param fee The fee taken from the deposit\\n     */\\n    event Deposit(address indexed user, uint256 amount, uint256 fee);\\n\\n    /**\\n     *  @notice Emitted when owner changes the deposit fee percentage\\n     *  @param newFee The new deposit fee percentage\\n     *  @param oldFee The old deposit fee percentage\\n     */\\n    event NewDepositFee(uint256 newFee, uint256 oldFee);\\n\\n    /**\\n     *  @notice Emitted when a user withdraws CYG\\n     *  @param user The address of the withdrawing user\\n     *  @param amount The amount of CYG withdrawn\\n     */\\n    event Withdraw(address indexed user, uint256 amount);\\n\\n    /**\\n     *  @notice Emitted when a user claims reward\\n     *  @param user The address of the user claiming rewards\\n     *  @param rewardToken The address of the reward token claimed\\n     *  @param amount The amount of the reward token claimed\\n     */\\n    event ClaimReward(address indexed user, address indexed rewardToken, uint256 amount);\\n\\n    /**\\n     *  @notice Emitted when a user emergency withdraws from the vault\\n     *  @param user The address of the user performing the emergency withdraw\\n     *  @param amount The amount of CYG emergency withdrawn\\n     */\\n    event EmergencyWithdraw(address indexed user, uint256 amount);\\n\\n    /**\\n     *  @notice Emitted when owner adds a token to the reward tokens list\\n     *  @param sender msg.sender\\n     *  @param vaultSize The vault size after this token was added\\n     *  @param token The address of the token added to the reward tokens list\\n     */\\n    event NewRewardToken(address sender, uint256 vaultSize, address token);\\n\\n    /**\\n     *  @notice Emitted when owner removes a token from the reward tokens list\\n     *  @param token The address of the token removed from the reward tokens list\\n     */\\n    event RewardTokenRemoved(address token);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /** \\n     *  @notice The name of the x1 vault\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     *  @notice Address of the hangar18 on this chain\\n     *  @return The hangar18\\n     */\\n    function hangar18() external view returns (IHangar18);\\n\\n    /// @notice Accumulated `token` rewards per share, scaled to `ACC_REWARD_PER_SHARE_PRECISION`\\n    /// @param token The reward token address\\n    /// @return The reward per share for the given token\\n    function accRewardPerShare(address token) external view returns (uint256);\\n\\n    /**\\n     *  @notice Indicates if a token is an active reward token\\n     *  @param token The reward token address\\n     *  @return True if token is an active reward token, false otherwise\\n     */\\n    function isRewardToken(address token) external view returns (bool);\\n\\n    /**\\n     *  @notice Last reward balance of `token`\\n     *  @param token The reward token address\\n     *  @return The balance of the reward token\\n     */\\n    function lastRewardBalance(address token) external view returns (uint256);\\n\\n    /**\\n     *  @notice The list of all active reward tokens\\n     *  @return The address array of all active reward tokens\\n     */\\n    function allRewardTokens(uint256) external view returns (address);\\n\\n    /**\\n     *  @return The precision used to calculate rewards per share\\n     */\\n    function ACC_REWARD_PER_SHARE_PRECISION() external pure returns (uint256);\\n\\n    /**\\n     *  @return The maximum number of reward tokens allowed\\n     */\\n    function MAX_REWARD_TOKENS() external pure returns (uint256);\\n\\n    /**\\n     *  @return The maximum deposit fee percentage\\n     */\\n    function MAX_DEPOSIT_FEE() external pure returns (uint256);\\n\\n    /**\\n     *  @return The address of the staking token (CYG)\\n     */\\n    function cygToken() external view returns (address);\\n\\n    /**\\n     *  @return The current balance of staked CYG\\n     */\\n    function cygStakedBalance() external view returns (uint256);\\n\\n    /**\\n     *  @return The deposit fee (if any)\\n     */\\n    function x1DepositFee() external view returns (uint256);\\n\\n    /**\\n     *  @notice View function to see pending reward token\\n     *  @param user The address of the user\\n     *  @param token The address of the token\\n     *  @return Pending amount of `token` to be collected by `user`\\n     */\\n    function pendingReward(address user, address token) external view returns (uint256);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Public \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Update reward variables\\n     *  @param token The address of the reward token\\n     *  @dev Needs to be called before any deposit or withdrawal\\n     */\\n    function updateReward(address token) external;\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 External \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Deposit CYG for reward token allocation\\n     *  @param cygAmount The amount of CYG to deposit\\n     */\\n    function deposit(uint256 cygAmount) external;\\n\\n    /**\\n     *  @notice Withdraw CYG and harvest the rewards\\n     *  @param _amount The amount of CYG to withdraw\\n     */\\n    function withdraw(uint256 _amount) external;\\n\\n    /**\\n     *  @notice Add a reward token\\n     *  @param token The address of the reward token\\n     *  @custom:security only-admin\\n     */\\n    function addRewardToken(address token) external;\\n\\n    /**\\n     *  @notice Remove a reward token\\n     *  @param token The address of the reward token\\n     *  @custom:security only-admin\\n     */\\n    function removeRewardToken(address token) external;\\n\\n    /**\\n     *  @notice Set the deposit fee percent\\n     *  @param fee The new deposit fee percent\\n     *  @custom:security only-admin\\n     */\\n    function setNewDepositFee(uint256 fee) external;\\n\\n    /**\\n     *  @notice Withdraws CYG without caring about rewards\\n     */\\n    function emergencyWithdraw() external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/interfaces/core/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >=0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/interfaces/core/IHangar18.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  IHangar18.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.17;\\n\\n// Orbiters\\nimport {ICygnusNebulaRegistry} from \\\"./ICygnusNebulaRegistry.sol\\\";\\n\\n// Oracles\\n\\n/**\\n *  @title The interface for the Cygnus Factory\\n *  @notice The Cygnus factory facilitates creation of collateral and borrow pools\\n */\\ninterface IHangar18 {\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Public \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Array of LP Token pairs deployed\\n     *  @param _shuttleId The ID of the shuttle deployed\\n     *  @return launched Whether this pair exists or not\\n     *  @return shuttleId The ID of this shuttle\\n     *  @return borrowable The address of the borrow contract\\n     *  @return collateral The address of the collateral contract\\n     *  @return orbiterId The ID of the orbiters used to deploy this lending pool\\n     */\\n    function allShuttles(\\n        uint256 _shuttleId\\n    ) external view returns (bool launched, uint88 shuttleId, address borrowable, address collateral, uint96 orbiterId);\\n\\n    /**\\n     *  @notice Official record of all lending pools deployed\\n     *  @param _lpTokenPair The address of the LP Token\\n     *  @param _orbiterId The ID of the orbiter for this LP Token\\n     *  @return launched Whether this pair exists or not\\n     *  @return shuttleId The ID of this shuttle\\n     *  @return borrowable The address of the borrow contract\\n     *  @return collateral The address of the collateral contract\\n     *  @return orbiterId The ID of the orbiters used to deploy this lending pool\\n     */\\n    function getShuttles(\\n        address _lpTokenPair,\\n        uint256 _orbiterId\\n    ) external view returns (bool launched, uint88 shuttleId, address borrowable, address collateral, uint96 orbiterId);\\n\\n    /**\\n     *  @return Human friendly name for this contract\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     *  @return The version of this contract\\n     */\\n    function version() external view returns (string memory);\\n\\n    /**\\n     *  @return usd The address of the borrowable token (stablecoin)\\n     */\\n    function usd() external view returns (address);\\n\\n    /**\\n     *  @return nativeToken The address of the chain's native token\\n     */\\n    function nativeToken() external view returns (address);\\n\\n    /**\\n     *  @notice The address of the nebula registry on this chain\\n     */\\n    function nebulaRegistry() external view returns (ICygnusNebulaRegistry);\\n\\n    /**\\n     *  @return admin The address of the Cygnus Admin which grants special permissions in collateral/borrow contracts\\n     */\\n    function admin() external view returns (address);\\n\\n    /**\\n     *  @return pendingAdmin The address of the requested account to be the new Cygnus Admin\\n     */\\n    function pendingAdmin() external view returns (address);\\n\\n    /**\\n     *  @return daoReserves The address that handles Cygnus reserves from all pools\\n     */\\n    function daoReserves() external view returns (address);\\n\\n    /**\\n     * @dev Returns the address of the contract to be the new DAO reserves.\\n     * @return pendingDaoReserves The address of the requested contract to be the new DAO reserves.\\n     */\\n    function pendingDaoReserves() external view returns (address);\\n\\n    /**\\n     * @dev Returns the address of the CygnusDAO revenue vault.\\n     * @return cygnusX1Vault The address of the CygnusDAO revenue vault.\\n     */\\n    function cygnusX1Vault() external view returns (address);\\n\\n    /**\\n     * @dev Returns the total number of orbiter pairs deployed (1 collateral + 1 borrow = 1 orbiter).\\n     * @return orbitersDeployed The total number of orbiter pairs deployed.\\n     */\\n    function orbitersDeployed() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total number of shuttles deployed.\\n     * @return shuttlesDeployed The total number of shuttles deployed.\\n     */\\n    function shuttlesDeployed() external view returns (uint256);\\n\\n    /**\\n     *  @dev Returns the chain ID\\n     */\\n    function chainId() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the borrowable TVL (Total Value Locked) in USD for a specific shuttle.\\n     * @param shuttleId The ID of the shuttle for which the borrowable TVL is requested.\\n     * @return The borrowable TVL in USD for the specified shuttle.\\n     */\\n    function borrowableTvlUsd(uint256 shuttleId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the collateral TVL (Total Value Locked) in USD for a specific shuttle.\\n     * @param shuttleId The ID of the shuttle for which the collateral TVL is requested.\\n     * @return The collateral TVL in USD for the specified shuttle.\\n     */\\n    function collateralTvlUsd(uint256 shuttleId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total TVL (Total Value Locked) in USD for a specific shuttle.\\n     * @param shuttleId The ID of the shuttle for which the total TVL is requested.\\n     * @return The total TVL in USD for the specified shuttle.\\n     */\\n    function shuttleTvlUsd(uint256 shuttleId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the USD value of the DAO Cyg LP reserves.\\n     * @return The USD value of the DAO Cyg LP reserves.\\n     */\\n    function daoCygLPReservesUsd() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the USD value of the DAO Cyg USD reserves.\\n     * @return The USD value of the DAO Cyg USD reserves.\\n     */\\n    function daoCygUsdReservesUsd() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total USD value of CygnusDAO reserves.\\n     * @return The total USD value of CygnusDAO reserves.\\n     */\\n    function cygnusTotalReservesUsd() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total amount borrowed in USD.\\n     * @return The total amount borrowed in USD.\\n     */\\n    function totalBorrowsUsd() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total borrowable TVL (Total Value Locked) in USD for all shuttles.\\n     * @return The total borrowable TVL in USD.\\n     */\\n    function allBorrowablesTvlUsd() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total collateral TVL (Total Value Locked) in USD for all shuttles.\\n     * @return The total collateral TVL in USD.\\n     */\\n    function allCollateralsTvlUsd() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total TVL (Total Value Locked) in USD for CygnusDAO.\\n     * @return The total TVL in USD for CygnusDAO.\\n     */\\n    function cygnusTvlUsd() external view returns (uint256);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 External \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Admin \ud83d\udc7d\\n     *  @notice Turns off orbiters making them not able for deployment of pools\\n     *\\n     *  @param orbiterId The ID of the orbiter pairs we want to switch the status of\\n     *\\n     *  @custom:security only-admin\\n     */\\n    function switchOrbiterStatus(uint256 orbiterId) external;\\n\\n    /**\\n     *  @notice Admin \ud83d\udc7d\\n     *  @notice Initializes both Borrow arms and the collateral arm\\n     *\\n     *  @param lpTokenPair The address of the underlying LP Token this pool is for\\n     *  @param orbiterId The ID of the orbiters we want to deploy to (= dex Id)\\n     *  @return borrowable The address of the Cygnus borrow contract for this pool\\n     *  @return collateral The address of the Cygnus collateral contract for both borrow tokens\\n     *\\n     *  @custom:security non-reentrant only-admin \ud83d\udc7d\\n     */\\n    function deployShuttle(address lpTokenPair, uint256 orbiterId) external returns (address borrowable, address collateral);\\n\\n    /**\\n     *  @notice Admin \ud83d\udc7d\\n     *  @notice Sets a new pending admin for Cygnus\\n     *\\n     *  @param newCygnusAdmin Address of the requested Cygnus admin\\n     *\\n     *  @custom:security only-admin\\n     */\\n    function setPendingAdmin(address newCygnusAdmin) external;\\n\\n    /**\\n     *  @notice Admin \ud83d\udc7d\\n     *  @notice Approves the pending admin and is the new Cygnus admin\\n     *\\n     *  @custom:security only-admin\\n     */\\n    function setNewCygnusAdmin() external;\\n\\n    /**\\n     *  @notice Admin \ud83d\udc7d\\n     *  @notice Sets the address for the future reserves manger if accepted\\n     *  @param newDaoReserves The address of the requested contract to be the new daoReserves\\n     *  @custom:security only-admin\\n     */\\n    function setPendingDaoReserves(address newDaoReserves) external;\\n\\n    /**\\n     *  @notice Admin \ud83d\udc7d\\n     *  @notice Accepts the new implementation contract\\n     *\\n     *  @custom:security only-admin\\n     */\\n    function setNewDaoReserves() external;\\n\\n    /**\\n     *  @notice Admin \ud83d\udc7d\\n     *  @notice Sets the address of the new x1 vault which accumulates rewards over time\\n     *\\n     *  @custom:security only-admin\\n     */\\n    function setCygnusX1Vault(address newX1Vault) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/interfaces/ICygnusHarvester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity >=0.8.17;\\n\\nimport {IHangar18} from \\\"./core/IHangar18.sol\\\";\\n\\n// Interface to interact with harvester if needed\\ninterface ICygnusHarvester {\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            1. CUSTOM ERRORS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /// @dev Reverts if msg.sender is not harvester admin\\n    /// @custom:error MsgSenderNotAdmin\\n    error CygnusHarvester__MsgSenderNotAdmin();\\n\\n    /// @dev Reverts if harvester does not exist for a terminal token\\n    /// @custom:error HarvesterNotSet\\n    error CygnusHarvester__HarvesterNotSet();\\n\\n    /// @dev Reverts if removing a reward token that is not yet added to the harvester\\n    /// @custom:error RewardTokenNotValid\\n    error CygnusHarvester__RewardTokenNotAdded();\\n\\n    /// @dev Reverts if adding a token that is already set\\n    /// @custom:error RewardTokenAlreadyAdded\\n    error CygnusHarvester__RewardTokenAlreadyAdded();\\n\\n    /// @dev Reverts if the src token being swapped is not the same as the one harvested\\n    /// @custom:error SrcTokenNotValid\\n    error CygnusHarvester__SrcTokenNotValid();\\n\\n    /// @dev Reverts if the token received is not the harvester's want token\\n    /// @custom:error DstTokenNotValid\\n    error CygnusHarvester__DstTokenNotValid();\\n\\n    /// @dev Reverts if the receiver is not the harvester's receiver\\n    /// @custom:error DstReceiverNotValid\\n    error CygnusHarvester__DstReceiverNotValid();\\n\\n    /// @dev Reverts if the X1 Vault reward being set is above 50%\\n    /// @custom:error X1VaultRewardTooHigh\\n    error CygnusHarvester__X1VaultRewardTooHigh();\\n\\n    /// @dev Reverts if Paraswap tx fails\\n    /// @custom:error ParaswapTransactionFailed\\n    error CygnusHarvester__ParaswapTransactionFailed();\\n\\n    /// @dev Reverts when doing a simple harvest when its not enabled\\n    /// @custom:error SimpleHarvestNotEnabled\\n    error CygnusHarvester__SimpleHarvestNotEnabled();\\n\\n    /// @dev Reverts when tx.origin is not msg.sender\\n    /// @custom:error OnlyEOAAllowed\\n    error CygnusHarvester__OnlyEOAAllowed();\\n\\n    /// @dev Reverts when setting the harvester (EOA) reward above 10%\\n    /// @custom:error HarvestRewardTooHigh\\n    error CygnusHarvester__HarvestRewardTooHigh();\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            2. CUSTOM EVENTS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /// @dev Logs when a reward token is added\\n    /// @param token The address of the token being added\\n    /// @param length Total reward tokens this harvester has stored after adding token\\n    /// @custom:event RewardTokenAdded\\n    event RewardTokenAdded(address token, uint256 length);\\n\\n    /// @dev Logs when a reward token is removed\\n    /// @param token The address of the token being removed\\n    /// @param length Total reward tokens this harvester has stored after removing token\\n    /// @custom:event RewardTokenRemoved\\n    event RewardTokenRemoved(address token, uint256 length);\\n\\n    /// @notice Logs when a harvester is created\\n    /// @param terminal The address of borrowable/collateral\\n    /// @param underlying The address of the underlying asset for the terminal token\\n    /// @param wantToken The address of the token the harvester wants to swap to\\n    /// @param receiver The address of the receiver of the harvest\\n    /// @custom:event InitializeCollateralHarvester\\n    event NewHarvester(address terminal, address underlying, address wantToken, address receiver);\\n\\n    /// @dev Logs when the x1 vault reward is updated\\n    /// @param oldWeight The old value of the x1 vault reward before the update\\n    /// @param newWeight The new value of the x1 vault reward after the update\\n    /// @custom:event NewX1VaultWeight\\n    event NewX1VaultWeight(uint256 oldWeight, uint256 newWeight);\\n\\n    /// @dev Logs when the harvester reward is updated\\n    /// @param oldWeight The old value of the harvester reward before the update\\n    /// @param newWeight The new value of the harvester reward after the update\\n    /// @custom:event NewHarvesterWeight\\n    event NewHarvesterWeight(uint256 oldWeight, uint256 newWeight);\\n\\n    /// @dev Logs when the X1 vault collects rewards\\n    /// @param timestamp The current timestamp of the collect\\n    /// @param sender The msg.sender\\n    /// @param tokensLength The amount of reward tokens we sent to vault (even if balance is 0)\\n    /// @custom:event CygnusX1VaultCollect\\n    event CygnusX1VaultCollect(uint256 timestamp, address sender, uint256 tokensLength);\\n\\n    /// @dev Emits when the admin changes the harvest method\\n    /// @param _simpleHarvest Whether the simple harvest is on or off\\n    event SimpleHarvestSwitch(bool _simpleHarvest);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /// @dev Dex Aggregator enum (atm only 1inch is enabled, but good to have)\\n    enum DexAggregator {\\n        ONE_INCH,\\n        PARASWAP,\\n        OPEN_OCEAN\\n    }\\n\\n    /// @dev The harvester struct\\n    /// @custom:member terminal The address of the collateral or borrowable\\n    /// @custom:member underlying The address of the underlying of the terminal (ie. a stablecoin or liquidity token)\\n    /// @custom:member wantToken The address of the token the harvester wants to swap rewards into (tokenA)\\n    /// @custom:member receiver The address of the receiver of the harvest\\n    struct Harvester {\\n        address terminal;\\n        address underlying;\\n        address wantToken;\\n        address receiver;\\n    }\\n\\n    // @dev Address of the 1inch router used to reinvest\\n    function ONE_INCH_ROUTER_V5() external pure returns (address);\\n\\n    /// @dev Returns the harvester for a given terminal token\\n    function harvesters(address terminal) external view returns (address, address, address, address);\\n\\n    /// @dev Returns the reward token at `index`\\n    /// @param index The index in the array.\\n    /// @return The address of the reward token at the given index.\\n    function allRewardTokens(uint256 index) external view returns (address);\\n\\n    /// @dev Returns whether the rewardToken is stored as a reward token\\n    /// @param rewardToken The address of the reward token\\n    /// @return Whether the rewardToken is being tracked or not\\n    function isRewardToken(address rewardToken) external view returns (bool);\\n\\n    /// @dev Returns the name of the contract.\\n    /// @return The name of the contract.\\n    function name() external view returns (string memory);\\n\\n    /// @return harvesterReward Reward that the caller of the harvest/reinvest receives from the reward tokens\\n    function harvesterReward() external view returns (uint256);\\n\\n    /// @return harvesterReward Reward that the x1 vault receives from the reward tokens\\n    function x1VaultReward() external view returns (uint256);\\n\\n    /// @notice Returns the timestamp of the last X1 Vault collect. Updates after\\n    /// @return Timestamp of the last collect\\n    function lastX1Collect() external view returns (uint256);\\n\\n    /// @dev Returns the Hangar18 contract.\\n    /// @return The Hangar18 contract.\\n    function hangar18() external view returns (IHangar18);\\n\\n    /// @dev Returns the address of the native token.\\n    /// @return The address of the native token.\\n    function nativeToken() external view returns (address);\\n\\n    /// @dev Returns the address of usdc\\n    /// @return The address of usdc on this chain\\n    function usd() external view returns (address);\\n\\n    /// @dev Returns the address of the CygnusX1Vault contract.\\n    /// @return The address of the CygnusX1Vault contract.\\n    function cygnusX1Vault() external view returns (address);\\n\\n    /// @dev Returns the amount of reward tokens to be sent to the X1 Vault\\n    function rewardTokensLength() external view returns (uint256);\\n\\n    /// @notice Returns the balance of the index token at the specified index.\\n    /// @notice Helpful to use in case we use a script or a collector function to get all reward tokens of the array\\n    /// @param index The index of the index token to check the balance of.\\n    /// @return The balance of the index token at the specified index.\\n    function rewardTokenBalanceAtIndex(uint256 index) external view returns (uint256);\\n\\n    /// @notice Switches to simple harvest. If simple harvest is set, then the rewards are sent straight to the vault\\n    ///         instead of reinvested.\\n    function simpleHarvest() external view returns (bool);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /// @notice Gets the rewards from the terminalToken and returns an array of tokens with the amounts harvested. \\n    ///         The amounts harvested take into account the amount of the harvest sent to the X1 Vault.\\n    ///         This is helpful when querying how much we will be reinvesting into the terminal.\\n    /// @return tokens Array of tokens harvested\\n    /// @return amounts array of amounts harvested of each token\\n    /// @custom:security non-reentrant\\n    function getRewards(address terminalToken) external returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /// @notice Harvests the rewards directly to the vault\\n    /// @dev simpleHarvest bool must be set or else tx reverts\\n    /// @param terminalToken The address of the collateral or borrowable\\n    /// @custom:security non-reentrant\\n    function harvestToX1Vault(address terminalToken) external;\\n\\n    /// @notice Collects all pending rewards of approved tokens and sends it to the X1 vault\\n    /// @custom:security non-reentrant\\n    function collectX1RewardsAll() external;\\n\\n    /**  Admin \ud83d\udc7d  **/\\n\\n    ///  @notice Admin \ud83d\udc7d\\n    ///  @notice Add a reward token to be collected by the X1 Vault\\n    ///  @param token The address of the token\\n    ///  @custom:security only-admin\\n    function addRewardToken(address token) external;\\n\\n    ///  @notice Admin \ud83d\udc7d\\n    ///  @notice Remove a reward token to be collected by the X1 Vault\\n    ///  @param token The address of the token\\n    ///  @custom:security only-admin\\n    function removeRewardToken(address token) external;\\n\\n    /// @notice Admin \ud83d\udc7d\\n    /// @param terminal The address of borrowable/collateral\\n    /// @param wantToken The address of the token the harvester wants to swap to\\n    /// @param receiver The address of the receiver of the harvest\\n    /// @custom:security only-admin\\n    function setTerminalHarvester(address terminal, address wantToken, address receiver) external;\\n\\n    /// @notice Admin \ud83d\udc7d\\n    /// @param weight The new weight being set for the x1 vault\\n    /// @custom:security only-admin\\n    function setWeightX1Vault(uint256 weight) external;\\n\\n    /// @notice Admin \ud83d\udc7d\\n    /// @param weight The new weight being set for the caller of the harvest\\n    /// @custom:security only-admin\\n    function setWeightHarvester(uint256 weight) external;\\n\\n    /// @notice Admin \ud83d\udc7d\\n    /// @notice Switches the harvest method. The contract allows for two types of harvests:\\n    ///         - harvestToVault - Harvests all rewards and sends straight to vault\\n    ///         - reinvestRewards - Harvests all rewards and compounds a percentage to the terminal (can be 100%)\\n    /// @custom:security only-admin\\n    function switchSimpleHarvest() external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/interfaces/IHypervisor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.8.17;\\n\\ninterface IAlgebraPool {\\n    function globalState() external view returns (uint160, int24, uint16, uint16, uint8, uint8, bool);\\n}\\n\\ninterface IHypervisor {\\n    function getTotalAmounts() external view returns (uint256 total0, uint256 total1);\\n\\n    function getBasePosition() external view returns (uint128 liquidity, uint256 amount0, uint256 amount1);\\n\\n    function baseLower() external view returns (int24);\\n\\n    function baseUpper() external view returns (int24);\\n\\n    function limitLower() external view returns (int24);\\n\\n    function limitUpper() external view returns (int24);\\n\\n    function pool() external view returns (address);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @param shares Number of liquidity tokens to redeem as pool assets\\n    /// @param to Address to which redeemed pool assets are sent\\n    /// @param from Address from which liquidity tokens are sent\\n    /// @param minAmounts min amount0,1 returned for shares of liq\\n    /// @return amount0 Amount of token0 redeemed by the submitted liquidity tokens\\n    /// @return amount1 Amount of token1 redeemed by the submitted liquidity tokens\\n    function withdraw(\\n        uint256 shares,\\n        address to,\\n        address from,\\n        uint256[4] memory minAmounts\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Deposit tokens\\n    /// @param deposit0 Amount of token0 transfered from sender to Hypervisor\\n    /// @param deposit1 Amount of token1 transfered from sender to Hypervisor\\n    /// @param to Address to which liquidity tokens are minted\\n    /// @param from Address from which asset tokens are transferred\\n    /// @param inMin min spend for directDeposit is true\\n    /// @return shares Quantity of liquidity tokens minted as a result of deposit\\n    function deposit(\\n        uint256 deposit0,\\n        uint256 deposit1,\\n        address to,\\n        address from,\\n        uint256[4] memory inMin\\n    ) external returns (uint256 shares);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function whitelistedAddress() external view returns (address);\\n}\\n\\ninterface IGammaProxy {\\n    function deposit(\\n        uint256 deposit0,\\n        uint256 deposit1,\\n        address to,\\n        address pos,\\n        uint256[4] memory inMin\\n    ) external returns (uint256 liquidity);\\n\\n    function getDepositAmount(address, address, uint256) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/libraries/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The multiply-divide operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The output is undefined, as the input is zero.\\n    error Log2Undefined();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    // Store the function selector of `ExpOverflow()`.\\n                    mstore(0x00, 0xa37bfec9)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                if iszero(sgt(x, 0)) {\\n                    // Store the function selector of `LnWadUndefined()`.\\n                    mstore(0x00, 0x1615e638)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Compute k = log2(x) - 96.\\n            int256 k;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let v := x\\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\\n\\n                // For the remaining 32 bits, use a De Bruijn lookup.\\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\\n                v := shr(k, v)\\n                v := or(v, shr(1, v))\\n                v := or(v, shr(2, v))\\n                v := or(v, shr(4, v))\\n                v := or(v, shr(8, v))\\n                v := or(v, shr(16, v))\\n\\n                // forgefmt: disable-next-item\\n                k := sub(\\n                    or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))), 0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)),\\n                    96\\n                )\\n            }\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Calculates `floor(a * b / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {\\n\\n            } 1 {\\n\\n            } {\\n                // 512-bit multiply `[prod1 prod0] = x * y`.\\n                // Compute the product mod `2**256` and mod `2**256 - 1`\\n                // then use the Chinese Remainder Theorem to reconstruct\\n                // the 512 bit result. The result is stored in two 256\\n                // variables such that `product = prod1 * 2**256 + prod0`.\\n\\n                // Least significant 256 bits of the product.\\n                let prod0 := mul(x, y)\\n                let mm := mulmod(x, y, not(0))\\n                // Most significant 256 bits of the product.\\n                let prod1 := sub(mm, add(prod0, lt(mm, prod0)))\\n\\n                // Handle non-overflow cases, 256 by 256 division.\\n                if iszero(prod1) {\\n                    if iszero(d) {\\n                        // Store the function selector of `FullMulDivFailed()`.\\n                        mstore(0x00, 0xae47f702)\\n                        // Revert with (offset, size).\\n                        revert(0x1c, 0x04)\\n                    }\\n                    result := div(prod0, d)\\n                    break\\n                }\\n\\n                // Make sure the result is less than `2**256`.\\n                // Also prevents `d == 0`.\\n                if iszero(gt(d, prod1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                ///////////////////////////////////////////////\\n                // 512 by 256 division.\\n                ///////////////////////////////////////////////\\n\\n                // Make division exact by subtracting the remainder from `[prod1 prod0]`.\\n                // Compute remainder using mulmod.\\n                let remainder := mulmod(x, y, d)\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n                // Factor powers of two out of `d`.\\n                // Compute largest power of two divisor of `d`.\\n                // Always greater or equal to 1.\\n                let twos := and(d, sub(0, d))\\n                // Divide d by power of two.\\n                d := div(d, twos)\\n                // Divide [prod1 prod0] by the factors of two.\\n                prod0 := div(prod0, twos)\\n                // Shift in bits from `prod1` into `prod0`. For this we need\\n                // to flip `twos` such that it is `2**256 / twos`.\\n                // If `twos` is zero, then it becomes one.\\n                prod0 := or(prod0, mul(prod1, add(div(sub(0, twos), twos), 1)))\\n                // Invert `d mod 2**256`\\n                // Now that `d` is an odd number, it has an inverse\\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                // Compute the inverse by starting with a seed that is correct\\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                let inv := xor(mul(3, d), 2)\\n                // Now use Newton-Raphson iteration to improve the precision.\\n                // Thanks to Hensel's lifting lemma, this also works in modular\\n                // arithmetic, doubling the correct bits in each step.\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                result := mul(prod0, mul(inv, sub(2, mul(d, inv)))) // inverse mod 2**256\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                if iszero(add(result, 1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n                result := add(result, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                // Store the function selector of `DivFailed()`.\\n                mstore(0x00, 0x65244e4e)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`.\\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {\\n\\n            } 1 {\\n\\n            } {\\n                if iszero(lt(10, x)) {\\n                    // forgefmt: disable-next-item\\n                    result := and(shr(mul(22, x), 0x375f0016260009d80004ec0002d00001e0000180000180000200000400001), 0x3fffff)\\n                    break\\n                }\\n                if iszero(lt(57, x)) {\\n                    let end := 31\\n                    result := 8222838654177922817725562880000000\\n                    if iszero(lt(end, x)) {\\n                        end := 10\\n                        result := 3628800\\n                    }\\n                    for {\\n                        let w := not(0)\\n                    } 1 {\\n\\n                    } {\\n                        result := mul(result, x)\\n                        x := add(x, w)\\n                        if eq(x, end) {\\n                            break\\n                        }\\n                    }\\n                    break\\n                }\\n                // Store the function selector of `FactorialOverflow()`.\\n                mstore(0x00, 0xaba0f2a2)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(x) {\\n                // Store the function selector of `Log2Undefined()`.\\n                mstore(0x00, 0x5be3aa5c)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\\n            x := shr(r, x)\\n            x := or(x, shr(1, x))\\n            x := or(x, shr(2, x))\\n            x := or(x, shr(4, x))\\n            x := or(x, shr(8, x))\\n            x := or(x, shr(16, x))\\n\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))), 0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        unchecked {\\n            uint256 isNotPo2;\\n            assembly {\\n                isNotPo2 := iszero(iszero(and(x, sub(x, 1))))\\n            }\\n            return log2(x) + isNotPo2;\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := sub(0, shr(255, x))\\n            z := xor(mask, add(mask, x))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let a := sub(y, x)\\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue) internal pure returns (uint256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {\\n                z := x\\n            } y {\\n\\n            } {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/libraries/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.17;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) {\\n                        revert(0, 0)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overriden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) {\\n                        revert(0, 0)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal returns (bool success) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x6c.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount := mul(\\n                mload(0x20),\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                )\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/QuickswapHarvester.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  CygnusHarvester.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n/*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  \\n    .               .            .               .      \ud83d\udef0\ufe0f     .           .                .           .\\n           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           ---======*.                                                 .           \u2800\\n          \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588                                               \ud83d\udce1                \ud83c\udf14                         . \\n         \u2588\u2588\u2588     \u2591\u2591\u2591  \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588        \u2800\\n        \u2591\u2588\u2588\u2588         \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591      .     .\u2800           .          \\n        \u2591\u2588\u2588\u2588          \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588       \u2800\\n        \u2591\u2591\u2588\u2588\u2588     \u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2588\u2588\u2588              .             .\u2800\\n         \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588     .----===*  \u2800\\n          \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591   \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591\u2591            .                            .\u2800\\n                       \u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588 \u2591\u2588\u2588\u2588                .                 .                 .  \u2800\\n     \ud83d\udef0\ufe0f  .             \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588                                             .                 .           \\n                       \u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591      -------=========*                      .                     \u2800\\n           .                            .       .          .            .                          .             .\u2800\\n    \\n        CYGNUS HARVESTER - `QUICKSWAP HARVESTER (HYPERVISOR)`                                                           \\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\npragma solidity >=0.8.17;\\n\\n// Dependencies\\nimport {ICygnusHarvester, CygnusHarvester} from \\\"./CygnusHarvester.sol\\\";\\nimport {ReentrancyGuard} from \\\"./utils/ReentrancyGuard.sol\\\";\\n\\n// Libraries\\nimport {SafeTransferLib} from \\\"./libraries/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./libraries/FixedPointMathLib.sol\\\";\\n\\n// Interfaces\\nimport {IERC20} from \\\"./interfaces/core/IERC20.sol\\\";\\nimport {IHangar18} from \\\"./interfaces/core/IHangar18.sol\\\";\\nimport {ICygnusTerminal} from \\\"./interfaces/core/ICygnusTerminal.sol\\\";\\nimport {ICygnusNebulaRegistry} from \\\"./interfaces/core/ICygnusNebulaRegistry.sol\\\";\\nimport {IAlgebraPool, IGammaProxy, IHypervisor} from \\\"./interfaces/IHypervisor.sol\\\";\\n\\n/// @title QuickswapHarvester\\n/// @author CygnusDAO\\n/// @notice Harvester fo quickswap pools\\ncontract QuickswapHarvester is CygnusHarvester {\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            1. LIBRARIES\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /// @custom:library SafeTransferLib For safe transfers of Erc20 tokens\\n    using SafeTransferLib for address;\\n\\n    /// @custom:library FixedPointMathLib Arithmetic library with operations for fixed-point numbers\\n    using FixedPointMathLib for uint256;\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            2. STORAGE\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Public \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @inheritdoc ICygnusHarvester\\n     */\\n    string public override name = \\\"Cygnus: Quickswap Harvester (Hypervisor)\\\";\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTRUCTOR\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @notice Constructs the harvester, use the hangar18 contract to get important addresses\\n     *  @param _hangar18 The address of the contract that deploys Cygnus lending pools on this chain\\n     */\\n    constructor(IHangar18 _hangar18) CygnusHarvester(_hangar18) {}\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            5. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Internal \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    ///  @notice Returns the weight of each asset in the LP\\n    ///  @param lpTokenPair The address of the LP\\n    ///  @return weight0 The weight of token0 in the LP\\n    ///  @return weight1 The weight of token1 in the LP\\n    function _tokenWeights(\\n        address lpTokenPair,\\n        address token0,\\n        address token1,\\n        address gammaUniProxy\\n    ) private view returns (uint256 weight0, uint256 weight1) {\\n        // Get scalars of each toekn\\n        uint256 scalar0 = 10 ** IERC20(token0).decimals();\\n        uint256 scalar1 = 10 ** IERC20(token1).decimals();\\n\\n        // Calculate difference in units\\n        uint256 scalarDifference = scalar0.divWad(scalar1);\\n\\n        // Adjust for token decimals\\n        uint256 decimalsDenominator = scalarDifference > 1e12 ? 1e6 : 1;\\n\\n        // Get sqrt price from Algebra pool\\n        (uint256 sqrtPriceX96, , , , , , ) = IAlgebraPool(IHypervisor(lpTokenPair).pool()).globalState();\\n\\n        // Convert to price with scalar diff and denom to take into account decimals of tokens\\n        uint256 price = ((sqrtPriceX96 ** 2 * (scalarDifference / decimalsDenominator)) / (2 ** 192)) * decimalsDenominator;\\n\\n        // How much we would need to deposit of token1 if we are depositing 1 unit of token0\\n        (uint256 low1, uint256 high1) = IGammaProxy(gammaUniProxy).getDepositAmount(lpTokenPair, token0, scalar0);\\n\\n        // Final token1 amount\\n        uint256 token1Amount = ((low1 + high1) / 2).divWad(scalar1);\\n\\n        // Get ratio\\n        uint256 ratio = token1Amount.divWad(price);\\n\\n        // Return weight of token0 in the LP\\n        weight0 = 1e36 / (ratio + 1e18);\\n\\n        // Weight of token1\\n        weight1 = 1e18 - weight0;\\n    }\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            6. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Internal \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /// @notice Get the token amounts to deposit in the LP\\n    /// @param lpTokenPair The address of the gamma LP\\n    /// @param amount The usd amount\\n    /// @return amount0 The amount of token0 to deposit\\n    /// @return amount1 The amount of token1 to deposit\\n    function _getTokenAmounts(\\n        address lpTokenPair,\\n        address token0,\\n        address token1,\\n        address gammaUniProxy,\\n        uint256 amount\\n    ) internal view returns (uint256 amount0, uint256 amount1) {\\n        // Get the token weights\\n        (uint256 weight0, uint256 weight1) = _tokenWeights(lpTokenPair, token0, token1, gammaUniProxy);\\n\\n        // Amount of usd to swap to token0\\n        amount0 = weight0.mulWad(amount);\\n\\n        // Amount of usd to swap to token1\\n        amount1 = weight1.mulWad(amount);\\n    }\\n\\n    /// @notice By now we would have converted 100% of the rewards into token0 or token1, we swap optimally to another token to the other to mint LP\\n    /// @param token0 The address of token0 from the LP Token\\n    /// @param token1 The address of token1 from the LP Token\\n    /// @param wantAmount The amount of want token to convert\\n    /// @param swapdata Bytes array consisting of 1inch API swap data\\n    /// @param lpTokenPair The address of the LP Token\\n    function _swapToLPAmounts(\\n        address token0,\\n        address token1,\\n        address wantToken,\\n        uint256 wantAmount,\\n        bytes[] calldata swapdata,\\n        address lpTokenPair,\\n        address receiver,\\n        address gammaUniProxy\\n    ) internal {\\n        // Get optimal amounts of token0 and token1\\n        (uint256 amount0, uint256 amount1) = _getTokenAmounts(lpTokenPair, token0, token1, gammaUniProxy, wantAmount);\\n\\n        // Swap token0 to token1\\n        // prettier-ignore\\n        if (wantToken == token0) _swapTokensOneInch(swapdata[swapdata.length - 1], wantToken, amount1, token1, receiver);\\n        // Swap token1 to token0\\n        else if (wantToken == token1) _swapTokensOneInch(swapdata[swapdata.length - 1], wantToken, amount0, token0, receiver);\\n    }\\n\\n    /// @notice This function gets called after calling `borrow` on Borrow contract and having `amountUsd` of USD\\n    /// @param token0 The address of token0 from the LP Token\\n    /// @param token1 The address of token1 from the LP Token\\n    /// @param lpTokenPair The address of the lp token\\n    /// @return liquidity The amount of LP minted\\n    function _mintLiquidity(address token0, address token1, address lpTokenPair, address receiver) internal returns (uint256 liquidity) {\\n        // Check balance of token0\\n        uint256 deposit0 = _checkBalance(token0);\\n\\n        // Balance of token1\\n        uint256 deposit1 = _checkBalance(token1);\\n\\n        // Approve token0 in hypervisor\\n        _approveToken(token0, lpTokenPair, deposit0);\\n\\n        // Approve token1 in hypervisor\\n        _approveToken(token1, lpTokenPair, deposit1);\\n\\n        // Get the whitelsited address - the only one allowed to deposit in hypervisor\\n        address gammaUniProxy = IHypervisor(lpTokenPair).whitelistedAddress();\\n\\n        // Get the minimum and maximum limit of token1 deposit given our balance of token0\\n        (uint256 low1, uint256 high1) = IGammaProxy(gammaUniProxy).getDepositAmount(lpTokenPair, token0, deposit0);\\n\\n        // If our balance of token1 is lower than the limit, get the limit of token0\\n        if (deposit1 < low1) {\\n            // Get the high limit of token0\\n            (, uint256 high0) = IGammaProxy(gammaUniProxy).getDepositAmount(lpTokenPair, token1, deposit1);\\n\\n            // If balance of token0 is higher than limit then deposit high limit\\n            if (deposit0 > high0) deposit0 = high0;\\n        }\\n\\n        // If our balance of token1 is higher than the limit, then deposit high limit\\n        if (deposit1 > high1) deposit1 = high1;\\n\\n        // Mint LP\\n        liquidity = IGammaProxy(gammaUniProxy).deposit(deposit0, deposit1, receiver, lpTokenPair, [uint256(0), 0, 0, 0]);\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 External \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /// @notice Reinvests rewards from the terminal token into more underlying\\n    /// @param swapdata Array of bytes for the swaps\\n    /// @param collateral The address of the collateral we are reinvesting\\n    /// @return liquidity The amount of underlying we have reinvested\\n    function reinvestRewards(bytes[] calldata swapdata, address collateral) external nonReentrant returns (uint256 liquidity) {\\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 1. Get harvester\\n        // Load to storage for gas savings, since we are not doing any writes\\n        Harvester storage harvester = harvesters[collateral];\\n\\n        /// @custom:error HarvesterNotSet Avoid if harvester is not set\\n        if (harvester.underlying == address(0)) revert CygnusHarvester__HarvesterNotSet();\\n\\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 2. Harvest tokens from the terminal\\n        // Harvest rewards from the collateral\\n        (address[] memory tokens, uint256[] memory amounts) = ICygnusTerminal(harvester.terminal).getRewards();\\n\\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 3. Swap reward to the harvester's `wantToken`\\n        // Loop through each token reward\\n        for (uint256 i = 0; i < tokens.length; ) {\\n            // If token is not want and we have rewards swap\\n            if (amounts[i] > 0 && isRewardToken[tokens[i]]) {\\n                // Transfer token from Collateral\\n                tokens[i].safeTransferFrom(harvester.terminal, address(this), amounts[i]);\\n\\n                // Process rewards for X1 Vault\\n                uint256 finalAmount = _processX1Rewards(tokens[i], amounts[i]);\\n\\n                // Check that token is not wantToken\\n                if (tokens[i] != harvester.wantToken) {\\n                    // Pass swap data `i` along with the token to be swapped\\n                    liquidity += _swapTokensOneInch(\\n                        // The swap data for token `i` from harvested rewards\\n                        swapdata[i],\\n                        // The token being swapped\\n                        tokens[i],\\n                        // The amount of token `i` we are swapping to wantToken\\n                        finalAmount,\\n                        // The token we should be receiving.\\n                        harvester.wantToken,\\n                        // Receiver\\n                        harvester.receiver\\n                    );\\n                }\\n                // token is wantToken, add to `wantAmount`\\n                else liquidity += amounts[i];\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 4. Convert amount received of wantToken to liquidity\\n        // Tokens of underlying\\n        address token0 = IHypervisor(harvester.underlying).token0();\\n        address token1 = IHypervisor(harvester.underlying).token1();\\n\\n        // Get the whitelsited address - the only one allowed to deposit in hypervisor\\n        address gammaUniProxy = IHypervisor(harvester.underlying).whitelistedAddress();\\n\\n        // Swap tokens\\n        _swapToLPAmounts(token0, token1, harvester.wantToken, liquidity, swapdata, harvester.underlying, harvester.receiver, gammaUniProxy);\\n\\n        // Convert token0 and token1 to liquidity\\n        liquidity = _mintLiquidity(token0, token1, harvester.underlying, harvester.terminal);\\n\\n        // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 5. Reinvest Rewards\\n        // Reinvest rewards in core, minting 0 shares and increasing totalBalance. By depositing more LPs to the collateral\\n        // we are decreasing all borrower`s debt ratio as they now own more collateral claim more collateral\\n        ICygnusTerminal(harvester.terminal).reinvestRewards_y7b(liquidity);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-harvesters/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.17;\\n\\n/// @title ReentrancyGuard\\n/// @author Paul Razvan Berg\\n/// @notice Contract module that helps prevent reentrant calls to a function.\\n///\\n/// Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier available, which can be applied\\n/// to functions to make sure there are no nested (reentrant) calls to them.\\n///\\n/// Note that because there is a single `nonReentrant` guard, functions marked as `nonReentrant` may not\\n/// call one another. This can be worked around by making those functions `private`, and then adding\\n/// `external` `nonReentrant` entry points to them.\\n///\\n/// @dev Forked from OpenZeppelin\\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/ReentrancyGuard.sol\\nabstract contract ReentrancyGuard {\\n    /// CUSTOM ERRORS ///\\n\\n    /// @notice Emitted when there is a reentrancy call.\\n    error ReentrantCall();\\n\\n    /// PRIVATE STORAGE ///\\n\\n    bool private notEntered;\\n\\n    /// CONSTRUCTOR ///\\n\\n    /// Storing an initial non-zero value makes deployment a bit more expensive but in exchange the\\n    /// refund on every call to nonReentrant will be lower in amount. Since refunds are capped to a\\n    /// percetange of the total transaction's gas, it is best to keep them low in cases like this one,\\n    /// to increase the likelihood of the full refund coming into effect.\\n    constructor() {\\n        notEntered = true;\\n    }\\n\\n    /// MODIFIERS ///\\n\\n    /// @notice Prevents a contract from calling itself, directly or indirectly.\\n    /// @dev Calling a `nonReentrant` function from another `nonReentrant` function\\n    /// is not supported. It is possible to prevent this from happening by making\\n    /// the `nonReentrant` function external, and make it call a `private`\\n    /// function that does the actual work.\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, notEntered will be true.\\n        if (!notEntered) {\\n            revert ReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail.\\n        notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).\\n        notEntered = true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul[j]Tpeulxa[rul]xa[r]cLgvifCTUca[r]LSsTOtfDnca[r]Iulc]jmul[jul]VcTOculjmul\"\r\n        }\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IHangar18\",\"name\":\"_hangar18\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CygnusHarvester__DstReceiverNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__DstTokenNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__HarvestRewardTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__HarvesterNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__MsgSenderNotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__OnlyEOAAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__ParaswapTransactionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__RewardTokenAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__RewardTokenNotAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__SimpleHarvestNotEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__SrcTokenNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusHarvester__X1VaultRewardTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensLength\",\"type\":\"uint256\"}],\"name\":\"CygnusX1VaultCollect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"NewHarvester\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWeight\",\"type\":\"uint256\"}],\"name\":\"NewHarvesterWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWeight\",\"type\":\"uint256\"}],\"name\":\"NewX1VaultWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"RewardTokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"RewardTokenRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_simpleHarvest\",\"type\":\"bool\"}],\"name\":\"SimpleHarvestSwitch\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ONE_INCH_ROUTER_V5\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"name\":\"addRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allRewardTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectX1RewardsAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cygnusX1Vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hangar18\",\"outputs\":[{\"internalType\":\"contract IHangar18\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"}],\"name\":\"harvestToX1Vault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvesterReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"harvesters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRewardToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastX1Collect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"swapdata\",\"type\":\"bytes[]\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"reinvestRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"name\":\"removeRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"rewardTokenBalanceAtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokensLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wantToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setTerminalHarvester\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWeight\",\"type\":\"uint256\"}],\"name\":\"setWeightHarvester\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWeight\",\"type\":\"uint256\"}],\"name\":\"setWeightX1Vault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"simpleHarvest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchSimpleHarvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usd\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"x1VaultReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "QuickswapHarvester", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000008796747946871b6b8ea495cce8d7814b17959296", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}