{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/FeeModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { ERC1155TokenReceiver } from \\\"solmate/tokens/ERC1155.sol\\\";\\n\\nimport { Auth } from \\\"./mixins/Auth.sol\\\";\\nimport { Transfers } from \\\"./mixins/Transfers.sol\\\";\\n\\nimport { IExchange } from \\\"./interfaces/IExchange.sol\\\";\\nimport { IFeeModule } from \\\"./interfaces/IFeeModule.sol\\\";\\n\\nimport { Order, Side } from \\\"./libraries/Structs.sol\\\";\\nimport { CalculatorHelper } from \\\"./libraries/CalculatorHelper.sol\\\";\\n\\n/// @title Polymarket CTF Fee Module\\n/// @notice Proxies the CTFExchange contract and refunds maker orders\\n/// @author Jon Amenechi (jon@polymarket.com)\\ncontract FeeModule is IFeeModule, Auth, Transfers, ERC1155TokenReceiver {\\n    /// @notice The Exchange contract\\n    IExchange public immutable exchange;\\n\\n    /// @notice The Collateral token\\n    address public immutable collateral;\\n\\n    /// @notice The CTF contract\\n    address public immutable ctf;\\n\\n    constructor(address _exchange) {\\n        exchange = IExchange(_exchange);\\n        collateral = exchange.getCollateral();\\n        ctf = exchange.getCtf();\\n    }\\n\\n    /// @notice Matches a taker order against a list of maker orders, refunding maker order fees if necessary\\n    /// @param takerOrder       - The active order to be matched\\n    /// @param makerOrders      - The array of maker orders to be matched against the active order\\n    /// @param takerFillAmount  - The amount to fill on the taker order, always in terms of the maker amount\\n    /// @param makerFillAmounts - The array of amounts to fill on the maker orders, always in terms of the maker amount\\n    /// @param makerFeeRate     - The fee rate to be charged to maker orders\\n    function matchOrders(\\n        Order memory takerOrder,\\n        Order[] memory makerOrders,\\n        uint256 takerFillAmount,\\n        uint256[] memory makerFillAmounts,\\n        uint256 makerFeeRate\\n    ) external onlyAdmin {\\n        // Match the orders on the exchange\\n        exchange.matchOrders(takerOrder, makerOrders, takerFillAmount, makerFillAmounts);\\n\\n        // Refund maker fees\\n        _refundFees(makerOrders, makerFillAmounts, makerFeeRate);\\n    }\\n\\n    /// @notice Withdraw collected fees\\n    /// @param id       - The tokenID to be withdrawn. If 0, will be the collateral token.\\n    /// @param amount   - The amount to be withdrawn\\n    function withdrawFees(address to, uint256 id, uint256 amount) external onlyAdmin {\\n        address token = id == 0 ? collateral : ctf;\\n        _transfer(token, address(this), to, id, amount);\\n        emit FeeWithdrawn(token, to, id, amount);\\n    }\\n\\n    /// @notice Refund fees for a set of orders\\n    /// @param orders       - The array of orders\\n    /// @param fillAmounts  - The array of fill amounts for the orders\\n    /// @param feeRate      - The fee rate to be charged to maker orders\\n    function _refundFees(Order[] memory orders, uint256[] memory fillAmounts, uint256 feeRate) internal {\\n        uint256 length = orders.length;\\n        uint256 i = 0;\\n        for (; i < length;) {\\n            if(orders[i].feeRateBps > feeRate) {\\n                _refundFee(orders[i], fillAmounts[i], feeRate);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Refund fee for an order\\n    /// @param order        - The order\\n    /// @param fillAmount   - The fill amount for the order\\n    /// @param feeRate      - The fee rate to be charged to maker orders\\n    function _refundFee(Order memory order, uint256 fillAmount, uint256 feeRate) internal {\\n        // Calculate refund for the order, if any\\n        uint256 refund = CalculatorHelper.calcRefund(\\n            order.feeRateBps,\\n            feeRate,\\n            order.side == Side.BUY ? CalculatorHelper.calculateTakingAmount(fillAmount, order.makerAmount, order.takerAmount) : fillAmount,\\n            order.makerAmount,\\n            order.takerAmount,\\n            order.side\\n        );\\n\\n        uint256 id = order.side == Side.BUY ? order.tokenId : 0;\\n        address token = order.side == Side.BUY ? ctf : collateral;\\n\\n        // If the refund is non-zero, transfer it to the order maker\\n        if (refund > 0) {\\n            _transfer(token, address(this), order.maker, id, refund);\\n            emit FeeRefunded(token, order.maker, id, refund);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mixins/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { IAuth } from \\\"../interfaces/IAuth.sol\\\";\\n\\n/// @title Auth\\n/// @notice Provides access control modifiers\\nabstract contract Auth is IAuth {\\n    /// @notice Auth\\n    mapping(address => uint256) public admins;\\n\\n    modifier onlyAdmin() {\\n        if (admins[msg.sender] != 1) revert NotAdmin();\\n        _;\\n    }\\n\\n    constructor() {\\n        admins[msg.sender] = 1;\\n    }\\n\\n    /// @notice Adds an Admin\\n    /// @param admin - The address of the admin\\n    function addAdmin(address admin) external onlyAdmin {\\n        admins[admin] = 1;\\n        emit NewAdmin(msg.sender, admin);\\n    }\\n\\n    /// @notice Removes an admin\\n    /// @param admin - The address of the admin to be removed\\n    function removeAdmin(address admin) external onlyAdmin {\\n        admins[admin] = 0;\\n        emit RemovedAdmin(msg.sender, admin);\\n    }\\n\\n    /// @notice Renounces Admin privileges from the caller\\n    function renounceAdmin() external onlyAdmin {\\n        admins[msg.sender] = 0;\\n        emit RemovedAdmin(msg.sender, msg.sender);\\n    }\\n\\n    /// @notice Checks if an address is an admin\\n    /// @param addr - The address to be checked\\n    function isAdmin(address addr) external view returns (bool) {\\n        return admins[addr] == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mixins/Transfers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { TransferHelper } from \\\"../libraries/TransferHelper.sol\\\";\\n\\ncontract Transfers {\\n    /// @notice Transfers tokens. no-op if amount is zero\\n    /// @param token    - The Token to be transferred\\n    /// @param from     - The originating address\\n    /// @param to       - The destination address\\n    /// @param id       - The TokenId to be transferred, 0 if ERC20\\n    /// @param amount   - The amount of tokens to be transferred\\n    function _transfer(address token, address from, address to, uint256 id, uint256 amount) internal {\\n        if (amount > 0) {\\n            if (id == 0) {\\n                return from == address(this)\\n                    ? TransferHelper._transferERC20(token, to, amount)\\n                    : TransferHelper._transferFromERC20(token, from, to, amount);\\n            }\\n            return TransferHelper._transferFromERC1155(token, from, to, id, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Order } from \\\"../libraries/Structs.sol\\\";\\n\\ninterface IExchange {\\n    function getCollateral() external view returns (address);\\n\\n    function getCtf() external view returns (address);\\n\\n    function matchOrders(\\n        Order memory takerOrder,\\n        Order[] memory makerOrders,\\n        uint256 takerFillAmount,\\n        uint256[] memory makerFillAmounts\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFeeModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Order } from \\\"../libraries/Structs.sol\\\";\\n\\ninterface IFeeModuleEE {\\n    /// @notice Emitted when fees are withdrawn from the FeeModule\\n    event FeeWithdrawn(address token, address to, uint256 id, uint256 amount);\\n\\n    /// @notice Emitted when fees are refunded to the order maker\\n    event FeeRefunded(address token, address to, uint256 id, uint256 amount);\\n}\\n\\ninterface IFeeModule is IFeeModuleEE {\\n    function matchOrders(\\n        Order memory takerOrder,\\n        Order[] memory makerOrders,\\n        uint256 takerFillAmount,\\n        uint256[] memory makerFillAmounts,\\n        uint256 makerFeeRate\\n    ) external;\\n\\n    function withdrawFees(address to, uint256 id, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nenum Side {\\n    // 0: buy\\n    BUY,\\n    // 1: sell\\n    SELL\\n}\\n\\nenum SignatureType {\\n    // 0: ECDSA EIP712 signatures signed by EOAs\\n    EOA,\\n    // 1: EIP712 signatures signed by EOAs that own Polymarket Proxy wallets\\n    POLY_PROXY,\\n    // 2: EIP712 signatures signed by EOAs that own Polymarket Gnosis safes\\n    POLY_GNOSIS_SAFE\\n}\\n\\nstruct OrderStatus {\\n    bool isFilledOrCancelled;\\n    uint256 remaining;\\n}\\n\\nstruct Order {\\n    /// @notice Unique salt to ensure entropy\\n    uint256 salt;\\n    /// @notice Maker of the order, i.e the source of funds for the order\\n    address maker;\\n    /// @notice Signer of the order\\n    address signer;\\n    /// @notice Address of the order taker. The zero address is used to indicate a public order\\n    address taker;\\n    /// @notice Token Id of the CTF ERC1155 asset to be bought or sold\\n    /// If BUY, this is the tokenId of the asset to be bought, i.e the makerAssetId\\n    /// If SELL, this is the tokenId of the asset to be sold, i.e the takerAssetId\\n    uint256 tokenId;\\n    /// @notice Maker amount, i.e the maximum amount of tokens to be sold\\n    uint256 makerAmount;\\n    /// @notice Taker amount, i.e the minimum amount of tokens to be received\\n    uint256 takerAmount;\\n    /// @notice Timestamp after which the order is expired\\n    uint256 expiration;\\n    /// @notice Nonce used for onchain cancellations\\n    uint256 nonce;\\n    /// @notice Fee rate, in basis points, charged to the order maker, charged on proceeds\\n    uint256 feeRateBps;\\n    /// @notice The side of the order: BUY or SELL\\n    Side side;\\n    /// @notice Signature type used by the Order: EOA, POLY_PROXY or POLY_GNOSIS_SAFE\\n    SignatureType signatureType;\\n    /// @notice The order signature\\n    bytes signature;\\n}\\n\"\r\n    },\r\n    \"src/libraries/CalculatorHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Order, Side } from \\\"../libraries/Structs.sol\\\";\\n\\nlibrary CalculatorHelper {\\n    uint256 internal constant ONE = 10 ** 18;\\n\\n    uint256 internal constant BPS_DIVISOR = 10_000;\\n\\n    /// @notice Calculates the fee refund for an Order\\n    /// @notice Used to refund Order makers if a user signs a fee into an Order that is > the expeceted fee\\n    /// @param orderFeeRateBps      - The fee rate signed into the order by the user\\n    /// @param operatorFeeRateBps   - The fee rate chosen by the operator\\n    /// @param outcomeTokens        - The number of outcome tokens\\n    /// @param makerAmount          - The maker amount of the order\\n    /// @param takerAmount          - The taker amount of the order\\n    /// @param side                 - The side of the order\\n    function calcRefund(\\n        uint256 orderFeeRateBps,\\n        uint256 operatorFeeRateBps,\\n        uint256 outcomeTokens,\\n        uint256 makerAmount,\\n        uint256 takerAmount,\\n        Side side\\n    ) internal pure returns (uint256) {\\n        if (orderFeeRateBps <= operatorFeeRateBps) return 0;\\n\\n        uint256 fee = calculateFee(orderFeeRateBps, outcomeTokens, makerAmount, takerAmount, side);\\n\\n        // fee calced using order fee minus fee calced using the operator fee\\n        if (operatorFeeRateBps == 0) return fee;\\n        return fee - calculateFee(operatorFeeRateBps, outcomeTokens, makerAmount, takerAmount, side);\\n    }\\n\\n    /// @notice Calculates the taking amount, i.e the amount of tokens to be received\\n    /// @param makingAmount - The making amount\\n    /// @param makerAmount  - The maker amount of the order\\n    /// @param takerAmount  - The taker amount of the order\\n    function calculateTakingAmount(uint256 makingAmount, uint256 makerAmount, uint256 takerAmount)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (makerAmount == 0) return 0;\\n        return makingAmount * takerAmount / makerAmount;\\n    }\\n\\n    /// @notice Calculates the fee for an order\\n    /// @dev Fees are calculated based on amount of outcome tokens and the order's feeRate\\n    /// @param feeRateBps       - Fee rate, in basis points\\n    /// @param outcomeTokens    - The number of outcome tokens\\n    /// @param makerAmount      - The maker amount of the order\\n    /// @param takerAmount      - The taker amount of the order\\n    /// @param side             - The side of the order\\n    function calculateFee(\\n        uint256 feeRateBps,\\n        uint256 outcomeTokens,\\n        uint256 makerAmount,\\n        uint256 takerAmount,\\n        Side side\\n    ) internal pure returns (uint256 fee) {\\n        if (feeRateBps > 0) {\\n            uint256 price = _calculatePrice(makerAmount, takerAmount, side);\\n            if (price > 0 && price <= ONE) {\\n                if (side == Side.BUY) {\\n                    // Fee charged on Token Proceeds:\\n                    // baseRate * min(price, 1-price) * (outcomeTokens/price)\\n                    fee = (feeRateBps * min(price, ONE - price) * outcomeTokens) / (price * BPS_DIVISOR);\\n                } else {\\n                    // Fee charged on Collateral proceeds:\\n                    // baseRate * min(price, 1-price) * outcomeTokens\\n                    fee = feeRateBps * min(price, ONE - price) * outcomeTokens / (BPS_DIVISOR * ONE);\\n                }\\n            }\\n        }\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function _calculatePrice(uint256 makerAmount, uint256 takerAmount, Side side) internal pure returns (uint256) {\\n        if (side == Side.BUY) return takerAmount != 0 ? makerAmount * ONE / takerAmount : 0;\\n        return makerAmount != 0 ? takerAmount * ONE / makerAmount : 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\ninterface IAuthEE {\\n    error NotAdmin();\\n\\n    /// @notice Emitted when a new admin is added\\n    event NewAdmin(address indexed admin, address indexed newAdminAddress);\\n\\n    /// @notice Emitted when an admin is removed\\n    event RemovedAdmin(address indexed admin, address indexed removedAdmin);\\n}\\n\\ninterface IAuth is IAuthEE {\\n    function isAdmin(address) external view returns (bool);\\n\\n    function addAdmin(address) external;\\n\\n    function removeAdmin(address) external;\\n\\n    function renounceAdmin() external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity <0.9.0;\\n\\nimport { ERC1155 } from \\\"solmate/tokens/ERC1155.sol\\\";\\nimport { SafeTransferLib, ERC20 } from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\n/// @title TransferHelper\\n/// @notice Helper method to transfer tokens\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @param token    - The contract address of the token which will be transferred\\n    /// @param to       - The recipient of the transfer\\n    /// @param amount   - The amount to be transferred\\n    function _transferERC20(address token, address to, uint256 amount) internal {\\n        SafeTransferLib.safeTransfer(ERC20(token), to, amount);\\n    }\\n\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @param token    - The contract address of the token to be transferred\\n    /// @param from     - The originating address from which the tokens will be transferred\\n    /// @param to       - The destination address of the transfer\\n    /// @param amount   - The amount to be transferred\\n    function _transferFromERC20(address token, address from, address to, uint256 amount) internal {\\n        SafeTransferLib.safeTransferFrom(ERC20(token), from, to, amount);\\n    }\\n\\n    /// @notice Transfer an ERC1155 token\\n    /// @param token    - The contract address of the token to be transferred\\n    /// @param from     - The originating address from which the tokens will be transferred\\n    /// @param to       - The destination address of the transfer\\n    /// @param id       - The tokenId of the token to be transferred\\n    /// @param amount   - The amount to be transferred\\n    function _transferFromERC1155(address token, address from, address to, uint256 id, uint256 amount) internal {\\n        ERC1155(token).safeTransferFrom(from, to, id, amount, \\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchange\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotAdmin\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdminAddress\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"removedAdmin\",\"type\":\"address\"}],\"name\":\"RemovedAdmin\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ctf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"contract IExchange\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeRateBps\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"enum SignatureType\",\"name\":\"signatureType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order\",\"name\":\"takerOrder\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeRateBps\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"enum SignatureType\",\"name\":\"signatureType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"makerOrders\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"takerFillAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"makerFillAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"makerFeeRate\",\"type\":\"uint256\"}],\"name\":\"matchOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FeeModule", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000004bfb41d5b3570defd03c39a9a4d8de6bd8b8982e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}