{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/factory/IdFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"../proxy/IdentityProxy.sol\\\";\\nimport \\\"./IIdFactory.sol\\\";\\nimport \\\"../interface/IERC734.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract IdFactory is IIdFactory, Ownable {\\n\\n    mapping(address => bool) private _tokenFactories;\\n\\n    // address of the _implementationAuthority contract making the link to the implementation contract\\n    address private immutable _implementationAuthority;\\n\\n    // as it is not possible to deploy 2 times the same contract address, this mapping allows us to check which\\n    // salt is taken and which is not\\n    mapping(string => bool) private _saltTaken;\\n\\n    // ONCHAINID of the wallet owner\\n    mapping(address => address) private _userIdentity;\\n\\n    // wallets currently linked to an ONCHAINID\\n    mapping(address => address[]) private _wallets;\\n\\n    // ONCHAINID of the token\\n    mapping(address => address) private _tokenIdentity;\\n\\n    // token linked to an ONCHAINID\\n    mapping(address => address) private _tokenAddress;\\n\\n\\n    // setting\\n    constructor (address implementationAuthority) {\\n        require(implementationAuthority != address(0), \\\"invalid argument - zero address\\\");\\n        _implementationAuthority = implementationAuthority;\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-addTokenFactory}.\\n     */\\n    function addTokenFactory(address _factory) external override onlyOwner {\\n        require(_factory != address(0), \\\"invalid argument - zero address\\\");\\n        require(!isTokenFactory(_factory), \\\"already a factory\\\");\\n        _tokenFactories[_factory] = true;\\n        emit TokenFactoryAdded(_factory);\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-removeTokenFactory}.\\n     */\\n    function removeTokenFactory(address _factory) external override onlyOwner {\\n        require(_factory != address(0), \\\"invalid argument - zero address\\\");\\n        require(isTokenFactory(_factory), \\\"not a factory\\\");\\n        _tokenFactories[_factory] = false;\\n        emit TokenFactoryRemoved(_factory);\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-createIdentity}.\\n     */\\n    function createIdentity(\\n        address _wallet,\\n        string memory _salt)\\n    external onlyOwner override returns (address) {\\n        require(_wallet != address(0), \\\"invalid argument - zero address\\\");\\n        require(keccak256(abi.encode(_salt)) != keccak256(abi.encode(\\\"\\\")), \\\"invalid argument - empty string\\\");\\n        string memory oidSalt = string.concat(\\\"OID\\\",_salt);\\n        require (!_saltTaken[oidSalt], \\\"salt already taken\\\");\\n        require (_userIdentity[_wallet] == address(0), \\\"wallet already linked to an identity\\\");\\n        address identity = _deployIdentity(oidSalt, _implementationAuthority, _wallet);\\n        _saltTaken[oidSalt] = true;\\n        _userIdentity[_wallet] = identity;\\n        _wallets[identity].push(_wallet);\\n        emit WalletLinked(_wallet, identity);\\n        return identity;\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-createIdentityWithManagementKeys}.\\n     */\\n    function createIdentityWithManagementKeys(\\n        address _wallet,\\n        string memory _salt,\\n        bytes32[] memory _managementKeys\\n    ) external onlyOwner override returns (address) {\\n        require(_wallet != address(0), \\\"invalid argument - zero address\\\");\\n        require(keccak256(abi.encode(_salt)) != keccak256(abi.encode(\\\"\\\")), \\\"invalid argument - empty string\\\");\\n        string memory oidSalt = string.concat(\\\"OID\\\",_salt);\\n        require (!_saltTaken[oidSalt], \\\"salt already taken\\\");\\n        require (_userIdentity[_wallet] == address(0), \\\"wallet already linked to an identity\\\");\\n        require(_managementKeys.length > 0, \\\"invalid argument - empty list of keys\\\");\\n\\n        address identity = _deployIdentity(oidSalt, _implementationAuthority, address(this));\\n\\n        for (uint i = 0; i < _managementKeys.length; i++) {\\n            require(\\n                _managementKeys[i] != keccak256(abi.encode(_wallet))\\n                , \\\"invalid argument - wallet is also listed in management keys\\\");\\n            IERC734(identity).addKey(\\n                _managementKeys[i],\\n                1,\\n                1\\n            );\\n        }\\n\\n        IERC734(identity).removeKey(\\n            keccak256(abi.encode(address(this))),\\n            1\\n        );\\n\\n        _saltTaken[oidSalt] = true;\\n        _userIdentity[_wallet] = identity;\\n        _wallets[identity].push(_wallet);\\n        emit WalletLinked(_wallet, identity);\\n\\n        return identity;\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-createTokenIdentity}.\\n     */\\n    function createTokenIdentity(\\n        address _token,\\n        address _tokenOwner,\\n        string memory _salt)\\n    external override returns (address) {\\n        require(isTokenFactory(msg.sender) || msg.sender == owner(), \\\"only Factory or owner can call\\\");\\n        require(_token != address(0), \\\"invalid argument - zero address\\\");\\n        require(_tokenOwner != address(0), \\\"invalid argument - zero address\\\");\\n        require(keccak256(abi.encode(_salt)) != keccak256(abi.encode(\\\"\\\")), \\\"invalid argument - empty string\\\");\\n        string memory tokenIdSalt = string.concat(\\\"Token\\\",_salt);\\n        require(!_saltTaken[tokenIdSalt], \\\"salt already taken\\\");\\n        require(_tokenIdentity[_token] == address(0), \\\"token already linked to an identity\\\");\\n        address identity = _deployIdentity(tokenIdSalt, _implementationAuthority, _tokenOwner);\\n        _saltTaken[tokenIdSalt] = true;\\n        _tokenIdentity[_token] = identity;\\n        _tokenAddress[identity] = _token;\\n        emit TokenLinked(_token, identity);\\n        return identity;\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-linkWallet}.\\n     */\\n    function linkWallet(address _newWallet) external override {\\n        require(_newWallet != address(0), \\\"invalid argument - zero address\\\");\\n        require(_userIdentity[msg.sender] != address(0), \\\"wallet not linked to an identity contract\\\");\\n        require(_userIdentity[_newWallet] == address(0), \\\"new wallet already linked\\\");\\n        require(_tokenIdentity[_newWallet] == address(0), \\\"invalid argument - token address\\\");\\n        address identity = _userIdentity[msg.sender];\\n        require(_wallets[identity].length < 101, \\\"max amount of wallets per ID exceeded\\\");\\n        _userIdentity[_newWallet] = identity;\\n        _wallets[identity].push(_newWallet);\\n        emit WalletLinked(_newWallet, identity);\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-unlinkWallet}.\\n     */\\n    function unlinkWallet(address _oldWallet) external override {\\n        require(_oldWallet != address(0), \\\"invalid argument - zero address\\\");\\n        require(_oldWallet != msg.sender, \\\"cannot be called on sender address\\\");\\n        require(_userIdentity[msg.sender] == _userIdentity[_oldWallet], \\\"only a linked wallet can unlink\\\");\\n        address _identity = _userIdentity[_oldWallet];\\n        delete _userIdentity[_oldWallet];\\n        uint256 length = _wallets[_identity].length;\\n        for (uint256 i = 0; i < length; i++) {\\n            if (_wallets[_identity][i] == _oldWallet) {\\n                _wallets[_identity][i] = _wallets[_identity][length - 1];\\n                _wallets[_identity].pop();\\n                break;\\n            }\\n        }\\n        emit WalletUnlinked(_oldWallet, _identity);\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-getIdentity}.\\n     */\\n    function getIdentity(address _wallet) external override view returns (address) {\\n        if(_tokenIdentity[_wallet] != address(0)) {\\n            return _tokenIdentity[_wallet];\\n        }\\n        else {\\n            return _userIdentity[_wallet];\\n        }\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-isSaltTaken}.\\n     */\\n    function isSaltTaken(string calldata _salt) external override view returns (bool) {\\n        return _saltTaken[_salt];\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-getWallets}.\\n     */\\n    function getWallets(address _identity) external override view returns (address[] memory) {\\n        return _wallets[_identity];\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-getToken}.\\n     */\\n    function getToken(address _identity) external override view returns (address) {\\n        return _tokenAddress[_identity];\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-isTokenFactory}.\\n     */\\n    function isTokenFactory(address _factory) public override view returns(bool) {\\n        return _tokenFactories[_factory];\\n    }\\n\\n    /**\\n     *  @dev See {IdFactory-implementationAuthority}.\\n     */\\n    function implementationAuthority() public override view returns (address) {\\n        return _implementationAuthority;\\n    }\\n\\n    // deploy function with create2 opcode call\\n    // returns the address of the contract created\\n    function _deploy(string memory salt, bytes memory bytecode) private returns (address) {\\n        bytes32 saltBytes = bytes32(keccak256(abi.encodePacked(salt)));\\n        address addr;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let encoded_data := add(0x20, bytecode) // load initialization code.\\n            let encoded_size := mload(bytecode)     // load init code's length.\\n            addr := create2(0, encoded_data, encoded_size, saltBytes)\\n            if iszero(extcodesize(addr)) {\\n                revert(0, 0)\\n            }\\n        }\\n        emit Deployed(addr);\\n        return addr;\\n    }\\n\\n    // function used to deploy an identity using CREATE2\\n    function _deployIdentity\\n    (\\n        string memory _salt,\\n        address implementationAuthority,\\n        address _wallet\\n    ) private returns (address){\\n        bytes memory _code = type(IdentityProxy).creationCode;\\n        bytes memory _constructData = abi.encode(implementationAuthority, _wallet);\\n        bytes memory bytecode = abi.encodePacked(_code, _constructData);\\n        return _deploy(_salt, bytecode);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/factory/IIdFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\ninterface IIdFactory {\\n\\n    /// events\\n\\n    // event emitted whenever a single contract is deployed by the factory\\n    event Deployed(address indexed _addr);\\n\\n    // event emitted when a wallet is linked to an ONCHAINID contract\\n    event WalletLinked(address indexed wallet, address indexed identity);\\n\\n    // event emitted when a token is linked to an ONCHAINID contract\\n    event TokenLinked(address indexed token, address indexed identity);\\n\\n    // event emitted when a wallet is unlinked from an ONCHAINID contract\\n    event WalletUnlinked(address indexed wallet, address indexed identity);\\n\\n    // event emitted when an address is registered on the factory as a Token\\n    // factory address, granting this address the privilege to issue\\n    // Onchain identities for tokens\\n    event TokenFactoryAdded(address indexed factory);\\n\\n    // event emitted when a previously recorded token factory address is removed\\n    event TokenFactoryRemoved(address indexed factory);\\n\\n    /// functions\\n\\n    /**\\n     *  @dev function used to create a new Identity proxy from the factory\\n     *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\\n     *  @param _salt the salt used by create2 to issue the contract\\n     *  requires a new salt for each deployment\\n     *  _wallet cannot be linked to another ONCHAINID\\n     *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\\n     *  of the function, including calls to oracles for multichain\\n     *  deployment security (avoid identity theft), defining payment requirements, etc.\\n     */\\n    function createIdentity(address _wallet, string memory _salt) external returns (address);\\n\\n    /**\\n     *  @dev function used to create a new Identity proxy from the factory, setting the wallet and listed keys as\\n     * MANAGEMENT keys.\\n     *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\\n     *  @param _salt the salt used by create2 to issue the contract\\n     *  @param _managementKeys A list of keys hash (keccak256(abiEncoded())) to add as MANAGEMENT keys.\\n     *  requires a new salt for each deployment\\n     *  _wallet cannot be linked to another ONCHAINID\\n     *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\\n     *  of the function, including calls to oracles for multichain\\n     *  deployment security (avoid identity theft), defining payment requirements, etc.\\n     */\\n    function createIdentityWithManagementKeys(\\n        address _wallet,\\n        string memory _salt,\\n        bytes32[] memory _managementKeys\\n    ) external returns (address);\\n\\n    /**\\n     *  @dev function used to create a new Token Identity proxy from the factory\\n     *  @param _token the address of the token contract\\n     *  @param _tokenOwner the owner address of the token\\n     *  @param _salt the salt used by create2 to issue the contract\\n     *  requires a new salt for each deployment\\n     *  _token cannot be linked to another ONCHAINID\\n     *  only Token factory or owner can call (owner should only use its privilege\\n     *  for tokens not issued by a Token factory onchain\\n     */\\n    function createTokenIdentity(address _token, address _tokenOwner, string memory _salt) external returns (address);\\n\\n    /**\\n     *  @dev function used to link a new wallet to an existing identity\\n     *  @param _newWallet the address of the wallet to link\\n     *  requires msg.sender to be linked to an existing onchainid\\n     *  the _newWallet will be linked to the same OID contract as msg.sender\\n     *  _newWallet cannot be linked to an OID yet\\n     *  _newWallet cannot be address 0\\n     *  cannot link more than 100 wallets to an OID, for gas consumption reason\\n     */\\n    function linkWallet(address _newWallet) external;\\n\\n    /**\\n     *  @dev function used to unlink a wallet from an existing identity\\n     *  @param _oldWallet the address of the wallet to unlink\\n     *  requires msg.sender to be linked to the same onchainid as _oldWallet\\n     *  msg.sender cannot be _oldWallet to keep at least 1 wallet linked to any OID\\n     *  _oldWallet cannot be address 0\\n     */\\n    function unlinkWallet(address _oldWallet) external;\\n\\n    /**\\n     *  @dev function used to register an address as a token factory\\n     *  @param _factory the address of the token factory\\n     *  can be called only by Owner\\n     *  _factory cannot be registered yet\\n     *  once the factory has been registered it can deploy token identities\\n     */\\n    function addTokenFactory(address _factory) external;\\n\\n    /**\\n     *  @dev function used to unregister an address previously registered as a token factory\\n     *  @param _factory the address of the token factory\\n     *  can be called only by Owner\\n     *  _factory has to be registered previously\\n     *  once the factory has been unregistered it cannot deploy token identities anymore\\n     */\\n    function removeTokenFactory(address _factory) external;\\n\\n    /**\\n     *  @dev getter for OID contract corresponding to a wallet/token\\n     *  @param _wallet the wallet/token address\\n     */\\n    function getIdentity(address _wallet) external view returns (address);\\n\\n    /**\\n     *  @dev getter to fetch the array of wallets linked to an OID contract\\n     *  @param _identity the address of the OID contract\\n     *  returns an array of addresses linked to the OID\\n     */\\n    function getWallets(address _identity) external view returns (address[] memory);\\n\\n    /**\\n     *  @dev getter to fetch the token address linked to an OID contract\\n     *  @param _identity the address of the OID contract\\n     *  returns the address linked to the OID\\n     */\\n    function getToken(address _identity) external view returns (address);\\n\\n    /**\\n     *  @dev getter to know if an address is registered as token factory or not\\n     *  @param _factory the address of the factory\\n     *  returns true if the address corresponds to a registered factory\\n     */\\n    function isTokenFactory(address _factory) external view returns(bool);\\n\\n    /**\\n     *  @dev getter to know if a salt is taken for the create2 deployment\\n     *  @param _salt the salt used for deployment\\n     */\\n    function isSaltTaken(string calldata _salt) external view returns (bool);\\n\\n    /**\\n     * @dev getter for the implementation authority used by this factory.\\n     */\\n    function implementationAuthority() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/interface/IERC734.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\\n */\\ninterface IERC734 {\\n\\n    /**\\n     * @dev Emitted when an execution request was approved.\\n     *\\n     * Specification: MUST be triggered when approve was successfully called.\\n     */\\n    event Approved(uint256 indexed executionId, bool approved);\\n\\n    /**\\n     * @dev Emitted when an execute operation was approved and successfully performed.\\n     *\\n     * Specification: MUST be triggered when approve was called and the execution was successfully approved.\\n     */\\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n\\n    /**\\n     * @dev Emitted when an execution request was performed via `execute`.\\n     *\\n     * Specification: MUST be triggered when execute was successfully called.\\n     */\\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n\\n    /**\\n     * @dev Emitted when an execute operation was called and failed\\n     *\\n     * Specification: MUST be triggered when execute call failed\\n     */\\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\\n\\n    /**\\n     * @dev Emitted when a key was added to the Identity.\\n     *\\n     * Specification: MUST be triggered when addKey was successfully called.\\n     */\\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\\n\\n    /**\\n     * @dev Emitted when a key was removed from the Identity.\\n     *\\n     * Specification: MUST be triggered when removeKey was successfully called.\\n     */\\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\\n\\n    /**\\n     * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\\n     *\\n     * Triggers Event: `KeyAdded`\\n     *\\n     * Specification: MUST only be done by keys of purpose 1, or the identity\\n     * itself. If it's the identity itself, the approval process will determine its approval.\\n     */\\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\\n\\n    /**\\n    * @dev Approves an execution.\\n    *\\n    * Triggers Event: `Approved`\\n    * Triggers on execution successful Event: `Executed`\\n    * Triggers on execution failure Event: `ExecutionFailed`\\n    */\\n    function approve(uint256 _id, bool _approve) external returns (bool success);\\n\\n    /**\\n     * @dev Removes _purpose for _key from the identity.\\n     *\\n     * Triggers Event: `KeyRemoved`\\n     *\\n     * Specification: MUST only be done by keys of purpose 1, or the identity itself.\\n     * If it's the identity itself, the approval process will determine its approval.\\n     */\\n    function removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\\n\\n    /**\\n     * @dev Passes an execution instruction to an ERC734 identity.\\n     * How the execution is handled is up to the identity implementation:\\n     * An execution COULD be requested and require `approve` to be called with one or more keys of purpose 1 or 2 to\\n     * approve this execution.\\n     * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\\n     *\\n     * Triggers Event: ExecutionRequested\\n     * Triggers on direct execution Event: Executed\\n     */\\n    function execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\\n\\n    /**\\n     * @dev Returns the full key data, if present in the identity.\\n     */\\n    function getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\\n\\n    /**\\n     * @dev Returns the list of purposes associated with a key.\\n     */\\n    function getKeyPurposes(bytes32 _key) external view returns(uint256[] memory _purposes);\\n\\n    /**\\n     * @dev Returns an array of public key bytes32 held by this identity.\\n     */\\n    function getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\\n\\n    /**\\n     * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\\n     */\\n    function keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/interface/IImplementationAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.17;\\n\\ninterface IImplementationAuthority {\\n\\n    // event emitted when the implementation contract is updated\\n    event UpdatedImplementation(address newAddress);\\n\\n    /**\\n     * @dev updates the address used as implementation by the proxies linked\\n     * to this ImplementationAuthority contract\\n     * @param _newImplementation the address of the new implementation contract\\n     * only Owner can call\\n     */\\n    function updateImplementation(address _newImplementation) external;\\n\\n    /**\\n     * @dev returns the address of the implementation\\n     */\\n    function getImplementation() external view returns(address);\\n}\\n\"\r\n    },\r\n    \"contracts/onchainid/proxy/IdentityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interface/IImplementationAuthority.sol\\\";\\n\\ncontract IdentityProxy {\\n\\n    /**\\n     *  @dev constructor of the proxy Identity contract\\n     *  @param _implementationAuthority the implementation Authority contract address\\n     *  @param initialManagementKey the management key at deployment\\n     *  the proxy is going to use the logic deployed on the implementation contract\\n     *  deployed at an address listed in the ImplementationAuthority contract\\n     */\\n    constructor(address _implementationAuthority, address initialManagementKey) {\\n        require(_implementationAuthority != address(0), \\\"invalid argument - zero address\\\");\\n        require(initialManagementKey != address(0), \\\"invalid argument - zero address\\\");\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, _implementationAuthority)\\n        }\\n\\n        address logic = IImplementationAuthority(_implementationAuthority).getImplementation();\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success,) = logic.delegatecall(abi.encodeWithSignature(\\\"initialize(address)\\\", initialManagementKey));\\n        require(success, \\\"Initialization failed.\\\");\\n    }\\n\\n    /**\\n     *  @dev fallback proxy function used for any transaction call that is made using\\n     *  the Identity contract ABI and called on the proxy contract\\n     *  The proxy will update its local storage depending on the behaviour requested\\n     *  by the implementation contract given by the Implementation Authority\\n     */\\n    // solhint-disable-next-line no-complex-fallback\\n    fallback() external payable {\\n        address logic = IImplementationAuthority(implementationAuthority()).getImplementation();\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n        calldatacopy(0x0, 0x0, calldatasize())\\n        let success := delegatecall(sub(gas(), 10000), logic, 0x0, calldatasize(), 0, 0)\\n        let retSz := returndatasize()\\n        returndatacopy(0, 0, retSz)\\n        switch success\\n            case 0 {\\n                revert(0, retSz)\\n            }\\n            default {\\n                return(0, retSz)\\n            }\\n        }\\n    }\\n\\n    function implementationAuthority() public view returns(address) {\\n        address implemAuth;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            implemAuth := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)\\n        }\\n        return implemAuth;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementationAuthority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"TokenFactoryAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"TokenFactoryRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"identity\",\"type\":\"address\"}],\"name\":\"TokenLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"identity\",\"type\":\"address\"}],\"name\":\"WalletLinked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"identity\",\"type\":\"address\"}],\"name\":\"WalletUnlinked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"addTokenFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_salt\",\"type\":\"string\"}],\"name\":\"createIdentity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_salt\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"_managementKeys\",\"type\":\"bytes32[]\"}],\"name\":\"createIdentityWithManagementKeys\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_salt\",\"type\":\"string\"}],\"name\":\"createTokenIdentity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getIdentity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identity\",\"type\":\"address\"}],\"name\":\"getWallets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementationAuthority\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_salt\",\"type\":\"string\"}],\"name\":\"isSaltTaken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"isTokenFactory\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"linkWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"removeTokenFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldWallet\",\"type\":\"address\"}],\"name\":\"unlinkWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IdFactory", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004dc25bec44cc7b221c8bbf81d4b900868e7bf1f2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}