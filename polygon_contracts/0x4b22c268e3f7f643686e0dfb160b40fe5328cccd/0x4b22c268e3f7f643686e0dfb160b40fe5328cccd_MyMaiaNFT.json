{"SourceCode": "/**\r\n *Submitted for verification at PolygonScan.com on 2023-09-29\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    function balanceOf(address owner) external view returns (uint balance);\r\n\r\n    function ownerOf(uint tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(address from, address to, uint tokenId) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function transferFrom(address from, address to, uint tokenId) external;\r\n\r\n    function approve(address to, uint tokenId) external;\r\n\r\n    function getApproved(uint tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(\r\n        address owner,\r\n        address operator\r\n    ) external view returns (bool);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\nlibrary Math {\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_DIGITS = \"0123456789abcdef\";\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _HEX_DIGITS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC721 is IERC721 {\r\n    event Transfer(address indexed from, address indexed to, uint indexed id);\r\n    event Approval(address indexed owner, address indexed spender, uint indexed id);\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint => address) internal _ownerOf;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint) internal _balanceOf;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint => address) internal _approvals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC165).interfaceId;\r\n    }\r\n\r\n    function ownerOf(uint id) external view returns (address owner) {\r\n        owner = _ownerOf[id];\r\n        require(owner != address(0), \"token doesn't exist\");\r\n    }\r\n\r\n    function balanceOf(address owner) external view returns (uint) {\r\n        require(owner != address(0), \"owner = zero address\");\r\n        return _balanceOf[owner];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) external {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function approve(address spender, uint id) external {\r\n        address owner = _ownerOf[id];\r\n        require(\r\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\r\n            \"not authorized\"\r\n        );\r\n\r\n        _approvals[id] = spender;\r\n\r\n        emit Approval(owner, spender, id);\r\n    }\r\n\r\n    function getApproved(uint id) external view returns (address) {\r\n        require(_ownerOf[id] != address(0), \"token doesn't exist\");\r\n        return _approvals[id];\r\n    }\r\n\r\n    function _isApprovedOrOwner(\r\n        address owner,\r\n        address spender,\r\n        uint id\r\n    ) internal view returns (bool) {\r\n        return (spender == owner ||\r\n            isApprovedForAll[owner][spender] ||\r\n            spender == _approvals[id]);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint id) public {\r\n        require(from == _ownerOf[id], \"from != owner\");\r\n        require(to != address(0), \"transfer to zero address\");\r\n\r\n        require(_isApprovedOrOwner(from, msg.sender, id), \"not authorized\");\r\n\r\n        _balanceOf[from]--;\r\n        _balanceOf[to]++;\r\n        _ownerOf[id] = to;\r\n\r\n        delete _approvals[id];\r\n\r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint id) external {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                IERC721Receiver(to).onERC721Received(msg.sender, from, id, \"\") ==\r\n                IERC721Receiver.onERC721Received.selector,\r\n            \"unsafe recipient\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint id,\r\n        bytes calldata data\r\n    ) external {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                IERC721Receiver(to).onERC721Received(msg.sender, from, id, data) ==\r\n                IERC721Receiver.onERC721Received.selector,\r\n            \"unsafe recipient\"\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint id) internal {\r\n        require(to != address(0), \"mint to zero address\");\r\n        require(_ownerOf[id] == address(0), \"already minted\");\r\n        require(\r\n            to.code.length == 0 ||\r\n                IERC721Receiver(to).onERC721Received(msg.sender, msg.sender, id, \"\") ==\r\n                IERC721Receiver.onERC721Received.selector,\r\n            \"unsafe recipient\"\r\n        );\r\n        \r\n        _balanceOf[to]++;\r\n        _ownerOf[id] = to;\r\n\r\n        emit Transfer(address(0), to, id);\r\n    }\r\n\r\n    function _burn(uint id) internal {\r\n        address owner = _ownerOf[id];\r\n        require(owner != address(0), \"not minted\");\r\n\r\n        _balanceOf[owner] -= 1;\r\n\r\n        delete _ownerOf[id];\r\n        delete _approvals[id];\r\n\r\n        emit Transfer(owner, address(0), id);\r\n    }\r\n}\r\n\r\ncontract MyMaiaNFT is ERC721 {\r\n\r\n    using Strings for string;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    address public owner;\r\n    uint256 public totalSupply;\r\n    string public baseURI;\r\n    uint256 private counter;\r\n    uint256 private nonce;\r\n    uint256 constant public last = 10000;\r\n    uint256[] public remainingNftIds;\r\n\r\n    mapping(uint256 => string) private _tokenURI;\r\n    mapping(uint256 => uint256) public valueToPosition;\r\n\r\n    event UriUpdated(uint256 id, string newUri);\r\n    event NewOwner(address oldOwner, address newOwner);\r\n    error CannotMintToAddressZero(uint256 position, string message);\r\n\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    modifier arrayFillLimit(){\r\n        require(msg.sender == owner && counter < last, \"You cannot call this function anymore\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        name = \"MyMaiaNFT\";\r\n        symbol = \"MYMAIA\";\r\n        owner = msg.sender;\r\n        totalSupply = 0;\r\n        counter = 11;\r\n        nonce = 0;\r\n        baseURI = \"ipfs://\";\r\n    }\r\n\r\n    function checkIfAvailable(uint256 id) external view returns(string memory){\r\n        require(id <= last, \"Inserted nft id out of bound\");\r\n\r\n        if(_ownerOf[id] == address(0)){\r\n            return \"Available\";\r\n        }else{\r\n            return \"Not available\";\r\n        }\r\n    }\r\n    \r\n    function arrayLength()external view returns(uint256){\r\n        return remainingNftIds.length;\r\n    }\r\n\r\n    function tokenURI(uint256 nftId) external view returns (string memory){\r\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, _tokenURI[nftId]) : \"\";\r\n    }\r\n\r\n\r\n    function fillArray() external arrayFillLimit {\r\n        uint256 tempLimit = counter + 250;\r\n        for(counter; counter < tempLimit; counter++){\r\n            if(counter > last){\r\n                break;\r\n            }\r\n        valueToPosition[counter] = counter-11;\r\n        remainingNftIds.push(counter);\r\n        }\r\n    }\r\n\r\n    function setOwner(address newOwner) external onlyOwner {\r\n        owner = newOwner;\r\n\r\n        emit NewOwner(msg.sender, owner);\r\n    }\r\n    \r\n    function setBaseURI(string memory newBaseURI) external onlyOwner {\r\n        baseURI = newBaseURI;\r\n    }\r\n\r\n    function mint(address to, uint id, string memory uri) external onlyOwner {\r\n        require(_ownerOf[id] == address(0), \"Token already minted!\");\r\n        require(id <= last, \"Inserted nft id out of bound\");\r\n\r\n        if(id > 10){\r\n            _mint(to, id);\r\n            _tokenURI[id] = uri;\r\n            uint256 location = valueToPosition[id];\r\n            _deleteFromArray(id, location);\r\n\r\n        }else if(id < 11 && id > 0){\r\n            _mint(to, id);\r\n            _tokenURI[id] = uri;\r\n\r\n        }else if(id == 0){\r\n            uint256 randSelector = _randomValue(0, remainingNftIds.length-1);\r\n            id = remainingNftIds[randSelector];\r\n            _mint(to, id);\r\n            _tokenURI[id] = uri;\r\n            uint256 location = valueToPosition[id];\r\n            _deleteFromArray(id, location);\r\n        }\r\n        totalSupply++;\r\n    }\r\n\r\n    function multipleMint(address[] memory addresses, string[] memory uriList) external onlyOwner {\r\n        require(addresses.length == uriList.length, \"Input with different length\");\r\n        require(remainingNftIds.length >= addresses.length, \"Not enough NFT for everyone\");\r\n\r\n        for(uint256 i = 0; i < uriList.length; i++){\r\n\r\n            uint256 randSelector = _randomValue(0, remainingNftIds.length-1);\r\n            uint256 randomId = remainingNftIds[randSelector];\r\n            uint256 location = valueToPosition[randomId];\r\n\r\n            if(addresses[i] == address(0) || addresses[i].code.length != 0 && \r\n            IERC721Receiver(addresses[i]).onERC721Received(msg.sender, msg.sender, randomId, \"\") != IERC721Receiver.onERC721Received.selector){\r\n                revert CannotMintToAddressZero(i, \"Check the address in this position\");\r\n            }\r\n\r\n            _tokenURI[randomId] = uriList[i];\r\n            _balanceOf[addresses[i]]++;\r\n            _ownerOf[randomId] = addresses[i];\r\n\r\n            _deleteFromArray(randomId, location);\r\n\r\n            totalSupply++;\r\n\r\n            emit Transfer(address(0), addresses[i], randomId);\r\n        }\r\n    }\r\n\r\n    function updateURI(uint256 id, string memory newUri) external onlyOwner {\r\n        require(_ownerOf[id] != address(0));\r\n\r\n        _tokenURI[id] = newUri;\r\n        emit UriUpdated(id, newUri);\r\n    }\r\n\r\n    function burn(uint id) external {\r\n        require(msg.sender == _ownerOf[id], \"not owner\");\r\n        _burn(id);\r\n    }\r\n\r\n\r\n    function _randomValue(uint256 min, uint256 max) internal returns (uint amount) {\r\n        nonce++;\r\n        uint256 randomNumber = uint256(\r\n            keccak256(\r\n                abi.encodePacked(block.timestamp, block.difficulty, nonce)\r\n            )\r\n        );\r\n        return (randomNumber % (max - min + 1) + min);\r\n    }\r\n\r\n    function _deleteFromArray(uint256 id, uint256 location) internal {\r\n        if(remainingNftIds[remainingNftIds.length-1] == id){\r\n            remainingNftIds.pop();\r\n            valueToPosition[id] = 10001;\r\n        }else{\r\n            remainingNftIds[location] = remainingNftIds[remainingNftIds.length-1];\r\n            valueToPosition[remainingNftIds[remainingNftIds.length-1]] = location;\r\n            remainingNftIds.pop();\r\n            valueToPosition[id] = 10001;\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"CannotMintToAddressZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"NewOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newUri\",\"type\":\"string\"}],\"name\":\"UriUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arrayLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"checkIfAvailable\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fillArray\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"uriList\",\"type\":\"string[]\"}],\"name\":\"multipleMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remainingNftIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newUri\",\"type\":\"string\"}],\"name\":\"updateURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"valueToPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MyMaiaNFT", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6fbb5b289d90eec33066bb053f8a170fb7b5ba2f200e57b2f6ccbf7a61ce7535"}