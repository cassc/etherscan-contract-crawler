{"SourceCode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/BLENPlanting.sol\r\n\r\n// Plant: Plant crops into our field \u2705\r\n//harvest: harvest crops and pull out of the field \u2705\r\n// claimReward: users get their reward tokens\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\nerror Staking_TransferFailed();\r\nerror Staking_NeedsMoreThanZero();\r\nerror NotOwner();\r\n\r\ncontract BlenPlanting{\r\n\r\n    IERC20 public bs_stakingToken;\r\n    IERC20 public bs_rewardToken;\r\n    IERC20  token;\r\n   \r\n    //farmer's address to how much they stake\r\n    mapping(address => uint256) public bs_balances;\r\n\r\n    // total amount each address has been paid\r\n    mapping(address => uint256) public bs_userRewardPerTokenPaid;\r\n\r\n    // mapping of how much reward each address has\r\n    mapping(address => uint256) public bs_rewards;\r\n\r\n    //Planting owners address\r\n    address owner;\r\n    //date when users can be able to withdraw their rewards:BLOCK.TIMESTAMP Sunday, December 10, 2023 5:20:00 AM\r\n    uint withdrawalTime = \t1702185600;\r\n\r\n    //how many blen will be distributed to cultivators each seconds 0.0001010466blen.\r\n    uint256 public REWARD_RATE = 1000000000000000;\r\n    // total amount of blen that is planted in the field\r\n    uint256 public bs_totalSupply;\r\n    // total reward for each token for every seconds\r\n    uint256 public bs_rewardPerTokenStored;\r\n    // last time rwards re updated\r\n    uint256 public bs_lastUpdateTime;\r\n     \r\n     modifier updateReward(address account){\r\n        // how much reward per token\r\n        // last timestamp\r\n        // 12-1, user earned x tokens\r\n\r\n        bs_rewardPerTokenStored = rewardPerToken();\r\n        bs_lastUpdateTime = block.timestamp;\r\n        bs_rewards[account] = earned(account);\r\n        bs_userRewardPerTokenPaid[account] = bs_rewardPerTokenStored;\r\n        _;\r\n     }\r\n\r\n    modifier moreThanZero(uint256 amount){\r\n        if(amount == 0){\r\n            revert Staking_NeedsMoreThanZero();\r\n        }\r\n        _;\r\n    }\r\n    modifier onlyOwner() {\r\n       \r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n        _;\r\n    }\r\n\r\n        event Transfer(address _address, uint _amount);\r\n        event Plant(address farmer,address field, uint _amount);\r\n        event Harvest(address farmer, uint _amount);\r\n\r\n    constructor(address stakingToken, address rewardToken){\r\n        bs_stakingToken = IERC20(stakingToken);\r\n        bs_rewardToken = IERC20(rewardToken);\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    function earned(address account) public view returns(uint256){\r\n        //farmer's address to how much they stake\r\n        uint256 currentBalance = bs_balances[account];\r\n        // how much they have been paid already\r\n        uint256 amountPaid = bs_userRewardPerTokenPaid[account];\r\n        \r\n        uint256 currentRewardPerToken = rewardPerToken();\r\n        uint256 pastRewards = bs_rewards[account];\r\n\r\n        uint256 _earned = ((currentBalance * (currentRewardPerToken - amountPaid))/1e18) + pastRewards;\r\n        return _earned;\r\n    } \r\n\r\n    // Based on how long it's been during this most recent snapshot\r\n    function rewardPerToken()public view returns(uint256){\r\n        if(bs_totalSupply == 0){\r\n            return bs_rewardPerTokenStored;\r\n        }\r\n        return bs_rewardPerTokenStored + \r\n        (((block.timestamp - bs_lastUpdateTime)* REWARD_RATE *1e18)/bs_totalSupply);\r\n    }\r\n\r\n\r\n    //do we allow any tokens?\r\n    //or just specific tokens to be staked\r\n    function plant(uint256 amount) updateReward(msg.sender) moreThanZero(amount) external{\r\n        // kepp track of how much a user staked\r\n        // keep track of how much token we have total\r\n        // transfer token to this contract\r\n        bs_balances[msg.sender] = bs_balances[msg.sender] + amount;\r\n        bs_totalSupply = bs_totalSupply + amount;\r\n        // emit event\r\n        bool success = bs_stakingToken.transferFrom(msg.sender, address(this),amount);\r\n        if(!success){\r\n            revert Staking_TransferFailed();\r\n        }\r\n        emit Plant(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function harvest(uint256 amount) updateReward(msg.sender) moreThanZero(amount)  external{\r\n        require(bs_balances[msg.sender] >= amount, \"amount is too low\");\r\n        bs_balances[msg.sender] = bs_balances[msg.sender] - amount;\r\n        bs_totalSupply = bs_totalSupply - amount;\r\n        bool success = bs_stakingToken.transfer(msg.sender, amount);\r\n        if(!success){\r\n            revert Staking_TransferFailed();\r\n        }\r\n        emit Harvest(msg.sender, amount);\r\n    }\r\n\r\n    function claimReward() updateReward(msg.sender) external{\r\n        require(block.timestamp > withdrawalTime, \"not yet time to withdraw\");\r\n        uint256 reward = bs_rewards[msg.sender];\r\n        bool success = bs_rewardToken.transfer(msg.sender, reward);\r\n        if(!success){\r\n            revert Staking_TransferFailed();\r\n        }\r\n\r\n        emit Transfer(msg.sender, reward);\r\n    }\r\n\r\n    function increaseRewardRate(uint256 amount)external onlyOwner{\r\n        REWARD_RATE = REWARD_RATE + amount;\r\n    }\r\n\r\n    function decreaseRewardRate(uint256 amount)external onlyOwner{\r\n        REWARD_RATE = REWARD_RATE - amount;\r\n    }\r\n\r\n    function WIM(address _address, uint _amount)public onlyOwner(){\r\n        payable(_address).transfer(_amount);\r\n    }\r\n\r\n    function WIT(address _addressToken, address addressToReceive, uint _amount) onlyOwner() public {\r\n        token = IERC20(_addressToken);\r\n        token.transfer(addressToReceive, _amount);\r\n    }\r\n\r\n    receive()external payable{}\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Staking_NeedsMoreThanZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Staking_TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farmer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farmer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"field\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Plant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REWARD_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WIM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addressToReceive\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WIT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bs_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bs_lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bs_rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bs_rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bs_rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bs_stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bs_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bs_userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"plant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BlenPlanting", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001224263bffb5b3e4d59cb1f02ffb8be82e313d1c0000000000000000000000001224263bffb5b3e4d59cb1f02ffb8be82e313d1c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1a302eca560b99e293bca9d3d8ea353b44f2b5e1f01d578519a5d320383b2484"}