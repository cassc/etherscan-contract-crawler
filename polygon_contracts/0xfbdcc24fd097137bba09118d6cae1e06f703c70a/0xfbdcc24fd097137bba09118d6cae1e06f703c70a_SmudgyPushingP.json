{"SourceCode": "// File: contracts/operator-filter-registry/lib/Constants.sol\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\naddress constant CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS = 0x000000000000AAeB6D7670E522A718067333cd4E;\r\naddress constant CANONICAL_CORI_SUBSCRIPTION = 0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6;\r\n// File: contracts/operator-filter-registry/IOperatorFilterRegistry.sol\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\ninterface IOperatorFilterRegistry {\r\n    /**\r\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\r\n     *         true if supplied registrant address is not registered.\r\n     */\r\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\r\n     */\r\n    function register(address registrant) external;\r\n\r\n    /**\r\n     * @notice Registers an address with the registry and \"subscribes\" to another address's filtered operators and codeHashes.\r\n     */\r\n    function registerAndSubscribe(address registrant, address subscription) external;\r\n\r\n    /**\r\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\r\n     *         address without subscribing.\r\n     */\r\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\r\n\r\n    /**\r\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\r\n     *         Note that this does not remove any filtered addresses or codeHashes.\r\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\r\n     */\r\n    function unregister(address addr) external;\r\n\r\n    /**\r\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\r\n     */\r\n    function updateOperator(address registrant, address operator, bool filtered) external;\r\n\r\n    /**\r\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\r\n     */\r\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\r\n\r\n    /**\r\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\r\n     */\r\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\r\n\r\n    /**\r\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\r\n     */\r\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\r\n\r\n    /**\r\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\r\n     *         subscription if present.\r\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\r\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\r\n     *         used.\r\n     */\r\n    function subscribe(address registrant, address registrantToSubscribe) external;\r\n\r\n    /**\r\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\r\n     */\r\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\r\n\r\n    /**\r\n     * @notice Get the subscription address of a given registrant, if any.\r\n     */\r\n    function subscriptionOf(address addr) external returns (address registrant);\r\n\r\n    /**\r\n     * @notice Get the set of addresses subscribed to a given registrant.\r\n     *         Note that order is not guaranteed as updates are made.\r\n     */\r\n    function subscribers(address registrant) external returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\r\n     *         Note that order is not guaranteed as updates are made.\r\n     */\r\n    function subscriberAt(address registrant, uint256 index) external returns (address);\r\n\r\n    /**\r\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\r\n     */\r\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\r\n\r\n    /**\r\n     * @notice Returns true if operator is filtered by a given address or its subscription.\r\n     */\r\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\r\n\r\n    /**\r\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\r\n     */\r\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\r\n\r\n    /**\r\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\r\n     */\r\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\r\n\r\n    /**\r\n     * @notice Returns a list of filtered operators for a given address or its subscription.\r\n     */\r\n    function filteredOperators(address addr) external returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\r\n     *         Note that order is not guaranteed as updates are made.\r\n     */\r\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\r\n\r\n    /**\r\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\r\n     *         its subscription.\r\n     *         Note that order is not guaranteed as updates are made.\r\n     */\r\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\r\n\r\n    /**\r\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\r\n     *         its subscription.\r\n     *         Note that order is not guaranteed as updates are made.\r\n     */\r\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns true if an address has registered\r\n     */\r\n    function isRegistered(address addr) external returns (bool);\r\n\r\n    /**\r\n     * @dev Convenience method to compute the code hash of an arbitrary contract\r\n     */\r\n    function codeHashOf(address addr) external returns (bytes32);\r\n}\r\n// File: contracts/operator-filter-registry/OperatorFilterer.sol\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\n\r\n/**\r\n * @title  OperatorFilterer\r\n * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another\r\n *         registrant's entries in the OperatorFilterRegistry.\r\n * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:\r\n *         - 'onlyAllowedOperator' modifier for 'transferFrom' and 'safeTransferFrom' methods.\r\n *         - 'onlyAllowedOperatorApproval' modifier for 'approve' and 'setApprovalForAll' methods.\r\n *         Please note that if your token contract does not provide an owner with EIP-173, it must provide\r\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\r\n *         will be locked to the options set during construction.\r\n */\r\n\r\nabstract contract OperatorFilterer {\r\n    /// @dev Emitted when an operator is not allowed.\r\n    error OperatorNotAllowed(address operator);\r\n\r\n    IOperatorFilterRegistry public constant OPERATOR_FILTER_REGISTRY =\r\n        IOperatorFilterRegistry(CANONICAL_OPERATOR_FILTER_REGISTRY_ADDRESS);\r\n\r\n    /// @dev The constructor that is called when the contract is being deployed.\r\n    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {\r\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\r\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\r\n        // order for the modifier to filter addresses.\r\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\r\n            if (subscribe) {\r\n                OPERATOR_FILTER_REGISTRY.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\r\n            } else {\r\n                if (subscriptionOrRegistrantToCopy != address(0)) {\r\n                    OPERATOR_FILTER_REGISTRY.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\r\n                } else {\r\n                    OPERATOR_FILTER_REGISTRY.register(address(this));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A helper function to check if an operator is allowed.\r\n     */\r\n    modifier onlyAllowedOperator(address from) virtual {\r\n        // Allow spending tokens from addresses with balance\r\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\r\n        // from an EOA.\r\n        if (from != msg.sender) {\r\n            _checkFilterOperator(msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev A helper function to check if an operator approval is allowed.\r\n     */\r\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\r\n        _checkFilterOperator(operator);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev A helper function to check if an operator is allowed.\r\n     */\r\n    function _checkFilterOperator(address operator) internal view virtual {\r\n        // Check registry code length to facilitate testing in environments without a deployed registry.\r\n        if (address(OPERATOR_FILTER_REGISTRY).code.length > 0) {\r\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\r\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\r\n            if (!OPERATOR_FILTER_REGISTRY.isOperatorAllowed(address(this), operator)) {\r\n                revert OperatorNotAllowed(operator);\r\n            }\r\n        }\r\n    }\r\n}\r\n// File: contracts/operator-filter-registry/DefaultOperatorFilterer.sol\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\n\r\n/**\r\n * @title  DefaultOperatorFilterer\r\n * @notice Inherits from OperatorFilterer and automatically subscribes to the default OpenSea subscription.\r\n * @dev    Please note that if your token contract does not provide an owner with EIP-173, it must provide\r\n *         administration methods on the contract itself to interact with the registry otherwise the subscription\r\n *         will be locked to the options set during construction.\r\n */\r\n\r\nabstract contract DefaultOperatorFilterer is OperatorFilterer {\r\n    /// @dev The constructor that is called when the contract is being deployed.\r\n    constructor() OperatorFilterer(CANONICAL_CORI_SUBSCRIPTION, true) {}\r\n}\r\n\r\n\r\n\r\n// File: erc721a/contracts/IERC721A.sol\r\n\r\n\r\n// ERC721A Contracts v4.2.3\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Interface of ERC721A.\r\n */\r\ninterface IERC721A {\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error ApprovalQueryForNonexistentToken();\r\n\r\n    /**\r\n     * Cannot query the balance for the zero address.\r\n     */\r\n    error BalanceQueryForZeroAddress();\r\n\r\n    /**\r\n     * Cannot mint to the zero address.\r\n     */\r\n    error MintToZeroAddress();\r\n\r\n    /**\r\n     * The quantity of tokens minted must be more than zero.\r\n     */\r\n    error MintZeroQuantity();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error OwnerQueryForNonexistentToken();\r\n\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error TransferCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * The token must be owned by 'from'.\r\n     */\r\n    error TransferFromIncorrectOwner();\r\n\r\n    /**\r\n     * Cannot safely transfer to a contract that does not implement the\r\n     * ERC721Receiver interface.\r\n     */\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    /**\r\n     * Cannot transfer to the zero address.\r\n     */\r\n    error TransferToZeroAddress();\r\n\r\n    /**\r\n     * The token does not exist.\r\n     */\r\n    error URIQueryForNonexistentToken();\r\n\r\n    /**\r\n     * The 'quantity' minted with ERC2309 exceeds the safety limit.\r\n     */\r\n    error MintERC2309QuantityExceedsLimit();\r\n\r\n    /**\r\n     * The 'extraData' cannot be set on an unintialized ownership slot.\r\n     */\r\n    error OwnershipNotInitializedForExtraData();\r\n\r\n    // =============================================================\r\n    //                            STRUCTS\r\n    // =============================================================\r\n\r\n    struct TokenOwnership {\r\n        // The address of the owner.\r\n        address addr;\r\n        // Stores the start time of ownership with minimal overhead for tokenomics.\r\n        uint64 startTimestamp;\r\n        // Whether the token has been burned.\r\n        bool burned;\r\n        // Arbitrary data similar to 'startTimestamp' that can be set via {_extraData}.\r\n        uint24 extraData;\r\n    }\r\n\r\n    // =============================================================\r\n    //                         TOKEN COUNTERS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens in existence.\r\n     * Burned tokens will reduce the count.\r\n     * To get the total number of tokens minted, please see {_totalMinted}.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    // =============================================================\r\n    //                            IERC165\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * 'interfaceId'. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    // =============================================================\r\n    //                            IERC721\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Emitted when 'tokenId' token is transferred from 'from' to 'to'.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when 'owner' enables 'approved' to manage the 'tokenId' token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when 'owner' enables or disables\r\n     * ('approved') 'operator' to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in 'owner''s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the 'tokenId' token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'tokenId' must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers 'tokenId' token from 'from' to 'to',\r\n     * checking first that contract recipients are aware of the ERC721 protocol\r\n     * to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'from' cannot be the zero address.\r\n     * - 'to' cannot be the zero address.\r\n     * - 'tokenId' token must exist and be owned by 'from'.\r\n     * - If the caller is not 'from', it must be have been allowed to move\r\n     * this token by either {approve} or {setApprovalForAll}.\r\n     * - If 'to' refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Equivalent to 'safeTransferFrom(from, to, tokenId, '')'.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Transfers 'tokenId' from 'from' to 'to'.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\r\n     * whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'from' cannot be the zero address.\r\n     * - 'to' cannot be the zero address.\r\n     * - 'tokenId' token must be owned by 'from'.\r\n     * - If the caller is not 'from', it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    /**\r\n     * @dev Gives permission to 'to' to transfer 'tokenId' token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the\r\n     * zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - 'tokenId' must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external payable;\r\n\r\n    /**\r\n     * @dev Approve or remove 'operator' as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom}\r\n     * for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The 'operator' cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for 'tokenId' token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'tokenId' must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the 'operator' is allowed to manage all of the assets of 'owner'.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    // =============================================================\r\n    //                        IERC721Metadata\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for 'tokenId' token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    // =============================================================\r\n    //                           IERC2309\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Emitted when tokens in 'fromTokenId' to 'toTokenId'\r\n     * (inclusive) is transferred from 'from' to 'to', as defined in the\r\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\r\n     *\r\n     * See {_mintERC2309} for more details.\r\n     */\r\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\r\n}\r\n\r\n// File: erc721a/contracts/ERC721A.sol\r\n\r\n\r\n// ERC721A Contracts v4.2.3\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n/**\r\n * @dev Interface of ERC721 token receiver.\r\n */\r\ninterface ERC721A__IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC721A\r\n *\r\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\r\n * Non-Fungible Token Standard, including the Metadata extension.\r\n * Optimized for lower gas during batch mints.\r\n *\r\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\r\n * starting from '_startTokenId()'.\r\n *\r\n * Assumptions:\r\n *\r\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\r\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\r\n */\r\ncontract ERC721A is IERC721A {\r\n    // Bypass for a '--via-ir' bug (https://github.com/chiru-labs/ERC721A/pull/364).\r\n    struct TokenApprovalRef {\r\n        address value;\r\n    }\r\n\r\n    // =============================================================\r\n    //                           CONSTANTS\r\n    // =============================================================\r\n\r\n    // Mask of an entry in packed address data.\r\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\r\n\r\n    // The bit position of 'numberMinted' in packed address data.\r\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\r\n\r\n    // The bit position of 'numberBurned' in packed address data.\r\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\r\n\r\n    // The bit position of 'aux' in packed address data.\r\n    uint256 private constant _BITPOS_AUX = 192;\r\n\r\n    // Mask of all 256 bits in packed address data except the 64 bits for 'aux'.\r\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\r\n\r\n    // The bit position of 'startTimestamp' in packed ownership.\r\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\r\n\r\n    // The bit mask of the 'burned' bit in packed ownership.\r\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\r\n\r\n    // The bit position of the 'nextInitialized' bit in packed ownership.\r\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\r\n\r\n    // The bit mask of the 'nextInitialized' bit in packed ownership.\r\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\r\n\r\n    // The bit position of 'extraData' in packed ownership.\r\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\r\n\r\n    // Mask of all 256 bits in a packed ownership except the 24 bits for 'extraData'.\r\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\r\n\r\n    // The mask of the lower 160 bits for addresses.\r\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\r\n\r\n    // The maximum 'quantity' that can be minted with {_mintERC2309}.\r\n    // This limit is to prevent overflows on the address data entries.\r\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\r\n    // is required to cause an overflow, which is unrealistic.\r\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\r\n\r\n    // The 'Transfer' event signature is given by:\r\n    // 'keccak256(bytes(\"Transfer(address,address,uint256)\"))'.\r\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    // =============================================================\r\n    //                            STORAGE\r\n    // =============================================================\r\n\r\n    // The next token ID to be minted.\r\n    uint256 private _currentIndex;\r\n\r\n    // The number of tokens burned.\r\n    uint256 private _burnCounter;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to ownership details\r\n    // An empty struct value does not necessarily mean the token is unowned.\r\n    // See {_packedOwnershipOf} implementation for details.\r\n    //\r\n    // Bits Layout:\r\n    // - [0..159]   'addr'\r\n    // - [160..223] 'startTimestamp'\r\n    // - [224]      'burned'\r\n    // - [225]      'nextInitialized'\r\n    // - [232..255] 'extraData'\r\n    mapping(uint256 => uint256) private _packedOwnerships;\r\n\r\n    // Mapping owner address to address data.\r\n    //\r\n    // Bits Layout:\r\n    // - [0..63]    'balance'\r\n    // - [64..127]  'numberMinted'\r\n    // - [128..191] 'numberBurned'\r\n    // - [192..255] 'aux'\r\n    mapping(address => uint256) private _packedAddressData;\r\n\r\n    // Mapping from token ID to approved address.\r\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // =============================================================\r\n    //                          CONSTRUCTOR\r\n    // =============================================================\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _currentIndex = _startTokenId();\r\n    }\r\n\r\n    // =============================================================\r\n    //                   TOKEN COUNTING OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the starting token ID.\r\n     * To change the starting token ID, please override this function.\r\n     */\r\n    function _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the next token ID to be minted.\r\n     */\r\n    function _nextTokenId() internal view virtual returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens in existence.\r\n     * Burned tokens will reduce the count.\r\n     * To get the total number of tokens minted, please see {_totalMinted}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        // Counter underflow is impossible as _burnCounter cannot be incremented\r\n        // more than '_currentIndex - _startTokenId()' times.\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens minted in the contract.\r\n     */\r\n    function _totalMinted() internal view virtual returns (uint256) {\r\n        // Counter underflow is impossible as '_currentIndex' does not decrement,\r\n        // and it is initialized to '_startTokenId()'.\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens burned.\r\n     */\r\n    function _totalBurned() internal view virtual returns (uint256) {\r\n        return _burnCounter;\r\n    }\r\n\r\n    // =============================================================\r\n    //                    ADDRESS DATA OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in 'owner''s account.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\r\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens minted by 'owner'.\r\n     */\r\n    function _numberMinted(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of tokens burned by or on behalf of 'owner'.\r\n     */\r\n    function _numberBurned(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    /**\r\n     * Returns the auxiliary data for 'owner'. (e.g. number of whitelist mint slots used).\r\n     */\r\n    function _getAux(address owner) internal view returns (uint64) {\r\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\r\n    }\r\n\r\n    /**\r\n     * Sets the auxiliary data for 'owner'. (e.g. number of whitelist mint slots used).\r\n     * If there are multiple variables, please pack them into a uint64.\r\n     */\r\n    function _setAux(address owner, uint64 aux) internal virtual {\r\n        uint256 packed = _packedAddressData[owner];\r\n        uint256 auxCasted;\r\n        // Cast 'aux' with assembly to avoid redundant masking.\r\n        assembly {\r\n            auxCasted := aux\r\n        }\r\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\r\n        _packedAddressData[owner] = packed;\r\n    }\r\n\r\n    // =============================================================\r\n    //                            IERC165\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * 'interfaceId'. See the corresponding\r\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        // The interface IDs are constants representing the first 4 bytes\r\n        // of the XOR of all function selectors in the interface.\r\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\r\n        // (e.g. 'bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)')\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\r\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\r\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\r\n    }\r\n\r\n    // =============================================================\r\n    //                        IERC721Metadata\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for 'tokenId' token.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the 'baseURI' and the 'tokenId'. Empty\r\n     * by default, it can be overridden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return '';\r\n    }\r\n\r\n    // =============================================================\r\n    //                     OWNERSHIPS OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the owner of the 'tokenId' token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'tokenId' must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return address(uint160(_packedOwnershipOf(tokenId)));\r\n    }\r\n\r\n    /**\r\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\r\n     * It gradually moves to O(1) as tokens get transferred around over time.\r\n     */\r\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the unpacked 'TokenOwnership' struct at 'index'.\r\n     */\r\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnerships[index]);\r\n    }\r\n\r\n    /**\r\n     * @dev Initializes the ownership slot minted at 'index' for efficiency purposes.\r\n     */\r\n    function _initializeOwnershipAt(uint256 index) internal virtual {\r\n        if (_packedOwnerships[index] == 0) {\r\n            _packedOwnerships[index] = _packedOwnershipOf(index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the packed ownership data of 'tokenId'.\r\n     */\r\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (_startTokenId() <= curr)\r\n                if (curr < _currentIndex) {\r\n                    uint256 packed = _packedOwnerships[curr];\r\n                    // If not burned.\r\n                    if (packed & _BITMASK_BURNED == 0) {\r\n                        // Invariant:\r\n                        // There will always be an initialized ownership slot\r\n                        // (i.e. 'ownership.addr != address(0) && ownership.burned == false')\r\n                        // before an unintialized ownership slot\r\n                        // (i.e. 'ownership.addr == address(0) && ownership.burned == false')\r\n                        // Hence, 'curr' will not underflow.\r\n                        //\r\n                        // We can directly compare the packed value.\r\n                        // If the address is zero, packed will be zero.\r\n                        while (packed == 0) {\r\n                            packed = _packedOwnerships[--curr];\r\n                        }\r\n                        return packed;\r\n                    }\r\n                }\r\n        }\r\n        revert OwnerQueryForNonexistentToken();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the unpacked 'TokenOwnership' struct from 'packed'.\r\n     */\r\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\r\n        ownership.addr = address(uint160(packed));\r\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\r\n        ownership.burned = packed & _BITMASK_BURNED != 0;\r\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\r\n    }\r\n\r\n    /**\r\n     * @dev Packs ownership data into a single uint256.\r\n     */\r\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\r\n        assembly {\r\n            // Mask 'owner' to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            // 'owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags'.\r\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the 'nextInitialized' flag set if 'quantity' equals 1.\r\n     */\r\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\r\n        // For branchless setting of the 'nextInitialized' flag.\r\n        assembly {\r\n            // '(quantity == 1) << _BITPOS_NEXT_INITIALIZED'.\r\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                      APPROVAL OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Gives permission to 'to' to transfer 'tokenId' token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the\r\n     * zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - 'tokenId' must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) public payable virtual override {\r\n        address owner = ownerOf(tokenId);\r\n\r\n        if (_msgSenderERC721A() != owner)\r\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\r\n                revert ApprovalCallerNotOwnerNorApproved();\r\n            }\r\n\r\n        _tokenApprovals[tokenId].value = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the account approved for 'tokenId' token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'tokenId' must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\r\n\r\n        return _tokenApprovals[tokenId].value;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve or remove 'operator' as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom}\r\n     * for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The 'operator' cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if the 'operator' is allowed to manage all of the assets of 'owner'.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether 'tokenId' exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted. See {_mint}.\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return\r\n            _startTokenId() <= tokenId &&\r\n            tokenId < _currentIndex && // If within bounds,\r\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether 'msgSender' is equal to 'approvedAddress' or 'owner'.\r\n     */\r\n    function _isSenderApprovedOrOwner(\r\n        address approvedAddress,\r\n        address owner,\r\n        address msgSender\r\n    ) private pure returns (bool result) {\r\n        assembly {\r\n            // Mask 'owner' to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            owner := and(owner, _BITMASK_ADDRESS)\r\n            // Mask 'msgSender' to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\r\n            // 'msgSender == owner || msgSender == approvedAddress'.\r\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the storage slot and value for the approved address of 'tokenId'.\r\n     */\r\n    function _getApprovedSlotAndAddress(uint256 tokenId)\r\n        private\r\n        view\r\n        returns (uint256 approvedAddressSlot, address approvedAddress)\r\n    {\r\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\r\n        // The following is equivalent to 'approvedAddress = _tokenApprovals[tokenId].value'.\r\n        assembly {\r\n            approvedAddressSlot := tokenApproval.slot\r\n            approvedAddress := sload(approvedAddressSlot)\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                      TRANSFER OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Transfers 'tokenId' from 'from' to 'to'.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'from' cannot be the zero address.\r\n     * - 'to' cannot be the zero address.\r\n     * - 'tokenId' token must be owned by 'from'.\r\n     * - If the caller is not 'from', it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable virtual override {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        // The nested ifs save around 20+ gas over a compound boolean condition.\r\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner.\r\n        assembly {\r\n            if approvedAddress {\r\n                // This is equivalent to 'delete _tokenApprovals[tokenId]'.\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as 'tokenId' would have to be 2**256.\r\n        unchecked {\r\n            // We can directly increment and decrement the balances.\r\n            --_packedAddressData[from]; // Updates: 'balance -= 1'.\r\n            ++_packedAddressData[to]; // Updates: 'balance += 1'.\r\n\r\n            // Updates:\r\n            // - 'address' to the next owner.\r\n            // - 'startTimestamp' to the timestamp of transfering.\r\n            // - 'burned' to 'false'.\r\n            // - 'nextInitialized' to 'true'.\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                to,\r\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\r\n            );\r\n\r\n            // If the next slot may not have been initialized (i.e. 'nextInitialized == false') .\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    // If the next slot is within bounds.\r\n                    if (nextTokenId != _currentIndex) {\r\n                        // Initialize the next slot to maintain correctness for 'ownerOf(tokenId + 1)'.\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Equivalent to 'safeTransferFrom(from, to, tokenId, '')'.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable virtual override {\r\n        safeTransferFrom(from, to, tokenId, '');\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers 'tokenId' token from 'from' to 'to'.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'from' cannot be the zero address.\r\n     * - 'to' cannot be the zero address.\r\n     * - 'tokenId' token must exist and be owned by 'from'.\r\n     * - If the caller is not 'from', it must be approved to move this token\r\n     * by either {approve} or {setApprovalForAll}.\r\n     * - If 'to' refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public payable virtual override {\r\n        transferFrom(from, to, tokenId);\r\n        if (to.code.length != 0)\r\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before a set of serially-ordered token IDs\r\n     * are about to be transferred. This includes minting.\r\n     * And also called before burning one token.\r\n     *\r\n     * 'startTokenId' - the first token ID to be transferred.\r\n     * 'quantity' - the amount to be transferred.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When 'from' and 'to' are both non-zero, 'from''s 'tokenId' will be\r\n     * transferred to 'to'.\r\n     * - When 'from' is zero, 'tokenId' will be minted for 'to'.\r\n     * - When 'to' is zero, 'tokenId' will be burned by 'from'.\r\n     * - 'from' and 'to' are never both zero.\r\n     */\r\n    function _beforeTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a set of serially-ordered token IDs\r\n     * have been transferred. This includes minting.\r\n     * And also called after one token has been burned.\r\n     *\r\n     * 'startTokenId' - the first token ID to be transferred.\r\n     * 'quantity' - the amount to be transferred.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When 'from' and 'to' are both non-zero, 'from''s 'tokenId' has been\r\n     * transferred to 'to'.\r\n     * - When 'from' is zero, 'tokenId' has been minted for 'to'.\r\n     * - When 'to' is zero, 'tokenId' has been burned by 'from'.\r\n     * - 'from' and 'to' are never both zero.\r\n     */\r\n    function _afterTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\r\n     *\r\n     * 'from' - Previous owner of the given token ID.\r\n     * 'to' - Target address that will receive the token.\r\n     * 'tokenId' - Token ID to be transferred.\r\n     * '_data' - Optional data to send along with the call.\r\n     *\r\n     * Returns whether the call correctly returned the expected magic value.\r\n     */\r\n    function _checkContractOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\r\n            bytes4 retval\r\n        ) {\r\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\r\n        } catch (bytes memory reason) {\r\n            if (reason.length == 0) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            } else {\r\n                assembly {\r\n                    revert(add(32, reason), mload(reason))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                        MINT OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Mints 'quantity' tokens and transfers them to 'to'.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'to' cannot be the zero address.\r\n     * - 'quantity' must be greater than 0.\r\n     *\r\n     * Emits a {Transfer} event for each mint.\r\n     */\r\n    function _mint(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are incredibly unrealistic.\r\n        // 'balance' and 'numberMinted' have a maximum limit of 2**64.\r\n        // 'tokenId' has a maximum limit of 2**256.\r\n        unchecked {\r\n            // Updates:\r\n            // - 'balance += quantity'.\r\n            // - 'numberMinted += quantity'.\r\n            //\r\n            // We can directly add to the 'balance' and 'numberMinted'.\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            // Updates:\r\n            // - 'address' to the owner.\r\n            // - 'startTimestamp' to the timestamp of minting.\r\n            // - 'burned' to 'false'.\r\n            // - 'nextInitialized' to 'quantity == 1'.\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            uint256 toMasked;\r\n            uint256 end = startTokenId + quantity;\r\n\r\n            // Use assembly to loop and emit the 'Transfer' event for gas savings.\r\n            // The duplicated 'log4' removes an extra check and reduces stack juggling.\r\n            // The assembly, together with the surrounding Solidity code, have been\r\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\r\n            assembly {\r\n                // Mask 'to' to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n                toMasked := and(to, _BITMASK_ADDRESS)\r\n                // Emit the 'Transfer' event.\r\n                log4(\r\n                    0, // Start of data (0, since no data).\r\n                    0, // End of data (0, since no data).\r\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\r\n                    0, // 'address(0)'.\r\n                    toMasked, // 'to'.\r\n                    startTokenId // 'tokenId'.\r\n                )\r\n\r\n                // The 'iszero(eq(,))' check ensures that large values of 'quantity'\r\n                // that overflows uint256 will make the loop run out of gas.\r\n                // The compiler will optimize the 'iszero' away for performance.\r\n                for {\r\n                    let tokenId := add(startTokenId, 1)\r\n                } iszero(eq(tokenId, end)) {\r\n                    tokenId := add(tokenId, 1)\r\n                } {\r\n                    // Emit the 'Transfer' event. Similar to above.\r\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\r\n                }\r\n            }\r\n            if (toMasked == 0) revert MintToZeroAddress();\r\n\r\n            _currentIndex = end;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Mints 'quantity' tokens and transfers them to 'to'.\r\n     *\r\n     * This function is intended for efficient minting only during contract creation.\r\n     *\r\n     * It emits only one {ConsecutiveTransfer} as defined in\r\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\r\n     * instead of a sequence of {Transfer} event(s).\r\n     *\r\n     * Calling this function outside of contract creation WILL make your contract\r\n     * non-compliant with the ERC721 standard.\r\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\r\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'to' cannot be the zero address.\r\n     * - 'quantity' must be greater than 0.\r\n     *\r\n     * Emits a {ConsecutiveTransfer} event.\r\n     */\r\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (to == address(0)) revert MintToZeroAddress();\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are unrealistic due to the above check for 'quantity' to be below the limit.\r\n        unchecked {\r\n            // Updates:\r\n            // - 'balance += quantity'.\r\n            // - 'numberMinted += quantity'.\r\n            //\r\n            // We can directly add to the 'balance' and 'numberMinted'.\r\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            // Updates:\r\n            // - 'address' to the owner.\r\n            // - 'startTimestamp' to the timestamp of minting.\r\n            // - 'burned' to 'false'.\r\n            // - 'nextInitialized' to 'quantity == 1'.\r\n            _packedOwnerships[startTokenId] = _packOwnershipData(\r\n                to,\r\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\r\n            );\r\n\r\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\r\n\r\n            _currentIndex = startTokenId + quantity;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints 'quantity' tokens and transfers them to 'to'.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If 'to' refers to a smart contract, it must implement\r\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\r\n     * - 'quantity' must be greater than 0.\r\n     *\r\n     * See {_mint}.\r\n     *\r\n     * Emits a {Transfer} event for each mint.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, quantity);\r\n\r\n        unchecked {\r\n            if (to.code.length != 0) {\r\n                uint256 end = _currentIndex;\r\n                uint256 index = end - quantity;\r\n                do {\r\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\r\n                        revert TransferToNonERC721ReceiverImplementer();\r\n                    }\r\n                } while (index < end);\r\n                // Reentrancy protection.\r\n                if (_currentIndex != end) revert();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Equivalent to '_safeMint(to, quantity, '')'.\r\n     */\r\n    function _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, '');\r\n    }\r\n\r\n    // =============================================================\r\n    //                        BURN OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Equivalent to '_burn(tokenId, false)'.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        _burn(tokenId, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys 'tokenId'.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'tokenId' must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        address from = address(uint160(prevOwnershipPacked));\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\r\n\r\n        if (approvalCheck) {\r\n            // The nested ifs save around 20+ gas over a compound boolean condition.\r\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\r\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n        }\r\n\r\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner.\r\n        assembly {\r\n            if approvedAddress {\r\n                // This is equivalent to 'delete _tokenApprovals[tokenId]'.\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as 'tokenId' would have to be 2**256.\r\n        unchecked {\r\n            // Updates:\r\n            // - 'balance -= 1'.\r\n            // - 'numberBurned += 1'.\r\n            //\r\n            // We can directly decrement the balance, and increment the number burned.\r\n            // This is equivalent to 'packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;'.\r\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\r\n\r\n            // Updates:\r\n            // - 'address' to the last owner.\r\n            // - 'startTimestamp' to the timestamp of burning.\r\n            // - 'burned' to 'true'.\r\n            // - 'nextInitialized' to 'true'.\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                from,\r\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\r\n            );\r\n\r\n            // If the next slot may not have been initialized (i.e. 'nextInitialized == false') .\r\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    // If the next slot is within bounds.\r\n                    if (nextTokenId != _currentIndex) {\r\n                        // Initialize the next slot to maintain correctness for 'ownerOf(tokenId + 1)'.\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, address(0), tokenId);\r\n        _afterTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\r\n        unchecked {\r\n            _burnCounter++;\r\n        }\r\n    }\r\n\r\n    // =============================================================\r\n    //                     EXTRA DATA OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Directly sets the extra data for the ownership data 'index'.\r\n     */\r\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\r\n        uint256 packed = _packedOwnerships[index];\r\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\r\n        uint256 extraDataCasted;\r\n        // Cast 'extraData' with assembly to avoid redundant masking.\r\n        assembly {\r\n            extraDataCasted := extraData\r\n        }\r\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\r\n        _packedOwnerships[index] = packed;\r\n    }\r\n\r\n    /**\r\n     * @dev Called during each token transfer to set the 24bit 'extraData' field.\r\n     * Intended to be overridden by the cosumer contract.\r\n     *\r\n     * 'previousExtraData' - the value of 'extraData' before transfer.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When 'from' and 'to' are both non-zero, 'from''s 'tokenId' will be\r\n     * transferred to 'to'.\r\n     * - When 'from' is zero, 'tokenId' will be minted for 'to'.\r\n     * - When 'to' is zero, 'tokenId' will be burned by 'from'.\r\n     * - 'from' and 'to' are never both zero.\r\n     */\r\n    function _extraData(\r\n        address from,\r\n        address to,\r\n        uint24 previousExtraData\r\n    ) internal view virtual returns (uint24) {}\r\n\r\n    /**\r\n     * @dev Returns the next extra data for the packed ownership data.\r\n     * The returned result is shifted into position.\r\n     */\r\n    function _nextExtraData(\r\n        address from,\r\n        address to,\r\n        uint256 prevOwnershipPacked\r\n    ) private view returns (uint256) {\r\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\r\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\r\n    }\r\n\r\n    // =============================================================\r\n    //                       OTHER OPERATIONS\r\n    // =============================================================\r\n\r\n    /**\r\n     * @dev Returns the message sender (defaults to 'msg.sender').\r\n     *\r\n     * If you are writing GSN compatible contracts, you need to override this function.\r\n     */\r\n    function _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a uint256 to its ASCII string decimal representation.\r\n     */\r\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\r\n        assembly {\r\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\r\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\r\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\r\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\r\n            let m := add(mload(0x40), 0xa0)\r\n            // Update the free memory pointer to allocate.\r\n            mstore(0x40, m)\r\n            // Assign the 'str' to the end.\r\n            str := sub(m, 0x20)\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end of the memory to calculate the length later.\r\n            let end := str\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            // prettier-ignore\r\n            for { let temp := value } 1 {} {\r\n                str := sub(str, 1)\r\n                // Write the character to the pointer.\r\n                // The ASCII index of the '0' character is 48.\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                // Keep dividing 'temp' until zero.\r\n                temp := div(temp, 10)\r\n                // prettier-ignore\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            // Move the pointer 32 bytes leftwards to make room for the length.\r\n            str := sub(str, 0x20)\r\n            // Store the length.\r\n            mstore(str, length)\r\n        }\r\n    }\r\n}\r\n\r\n// File: erc721a/contracts/extensions/IERC721AQueryable.sol\r\n\r\n\r\n// ERC721A Contracts v4.2.3\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n/**\r\n * @dev Interface of ERC721AQueryable.\r\n */\r\ninterface IERC721AQueryable is IERC721A {\r\n    /**\r\n     * Invalid query range ('start' >= 'stop').\r\n     */\r\n    error InvalidQueryRange();\r\n\r\n    /**\r\n     * @dev Returns the 'TokenOwnership' struct at 'tokenId' without reverting.\r\n     *\r\n     * If the 'tokenId' is out of bounds:\r\n     *\r\n     * - 'addr = address(0)'\r\n     * - 'startTimestamp = 0'\r\n     * - 'burned = false'\r\n     * - 'extraData = 0'\r\n     *\r\n     * If the 'tokenId' is burned:\r\n     *\r\n     * - 'addr = <Address of owner before token was burned>'\r\n     * - 'startTimestamp = <Timestamp when token was burned>'\r\n     * - 'burned = true'\r\n     * - 'extraData = <Extra data when token was burned>'\r\n     *\r\n     * Otherwise:\r\n     *\r\n     * - 'addr = <Address of owner>'\r\n     * - 'startTimestamp = <Timestamp of start of ownership>'\r\n     * - 'burned = false'\r\n     * - 'extraData = <Extra data at start of ownership>'\r\n     */\r\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\r\n\r\n    /**\r\n     * @dev Returns an array of 'TokenOwnership' structs at 'tokenIds' in order.\r\n     * See {ERC721AQueryable-explicitOwnershipOf}\r\n     */\r\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\r\n\r\n    /**\r\n     * @dev Returns an array of token IDs owned by 'owner',\r\n     * in the range ['start', 'stop')\r\n     * (i.e. 'start <= tokenId < stop').\r\n     *\r\n     * This function allows for tokens to be queried if the collection\r\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'start < stop'\r\n     */\r\n    function tokensOfOwnerIn(\r\n        address owner,\r\n        uint256 start,\r\n        uint256 stop\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Returns an array of token IDs owned by 'owner'.\r\n     *\r\n     * This function scans the ownership mapping and is O('totalSupply') in complexity.\r\n     * It is meant to be called off-chain.\r\n     *\r\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\r\n     * multiple smaller scans if the collection is large enough to cause\r\n     * an out-of-gas error (10K collections should be fine).\r\n     */\r\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\r\n}\r\n\r\n// File: contracts/IERC721L.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\ninterface IERC721L is IERC721AQueryable {\r\n    error CannotIncreaseMaxMintableSupply();\r\n    error CannotUpdatePermanentBaseURI();\r\n    error GlobalWalletLimitOverflow();\r\n    error InsufficientStageTimeGap();\r\n    error InvalidProof();\r\n    error InvalidStage();\r\n    error InvalidStageArgsLength();\r\n    error InvalidStartAndEndTimestamp();\r\n    error NoSupplyLeft();\r\n    error NotEnoughValue();\r\n    error StageSupplyExceeded();\r\n    error TimestampExpired();\r\n    error WalletGlobalLimitExceeded();\r\n    error WalletStageLimitExceeded();\r\n    error WithdrawFailed();\r\n\r\n    struct MintStageInfo {\r\n        uint80 cost;\r\n        uint32 walletLimit; // 0 for unlimited\r\n        bytes32 merkleRoot; // 0x0 for no presale enforced\r\n        uint24 maxStageSupply; // 0 for unlimited\r\n        uint64 startTimeUnixSeconds;\r\n        uint64 endTimeUnixSeconds;\r\n    }\r\n\r\n    event UpdateStage(\r\n        uint256 stage,\r\n        uint80 cost,\r\n        uint32 walletLimit,\r\n        bytes32 merkleRoot,\r\n        uint24 maxStageSupply,\r\n        uint64 startTimeUnixSeconds,\r\n        uint64 endTimeUnixSeconds\r\n    );\r\n\r\n\r\n    event SetMaxMintableSupply(uint256 maxMintableSupply);\r\n    event SetGlobalWalletLimit(uint256 globalWalletLimit);\r\n    event SetActiveStage(uint256 activeStage);\r\n    event SetBaseURI(string baseURI);\r\n    event PermanentBaseURI(string baseURI);\r\n    event Withdraw(uint256 value);\r\n\r\n\r\n    function getNumberStages() external view returns (uint256);\r\n\r\n    function getGlobalWalletLimit() external view returns (uint256);\r\n\r\n    function getMaxMintableSupply() external view returns (uint256);\r\n\r\n    function totalMintedByAddress(address a) external view returns (uint256);\r\n\r\n    function getTokenURISuffix() external view returns (string memory);\r\n\r\n    function getStageInfo(uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            MintStageInfo memory,\r\n            uint32,\r\n            uint256\r\n        );\r\n\r\n    function getActiveStageFromTimestamp(uint64 timestamp)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n}\r\n// File: erc721a/contracts/extensions/ERC721AQueryable.sol\r\n\r\n\r\n// ERC721A Contracts v4.2.3\r\n// Creator: Chiru Labs\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n/**\r\n * @title ERC721AQueryable.\r\n *\r\n * @dev ERC721A subclass with convenience query functions.\r\n */\r\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\r\n    /**\r\n     * @dev Returns the 'TokenOwnership' struct at 'tokenId' without reverting.\r\n     *\r\n     * If the 'tokenId' is out of bounds:\r\n     *\r\n     * - 'addr = address(0)'\r\n     * - 'startTimestamp = 0'\r\n     * - 'burned = false'\r\n     * - 'extraData = 0'\r\n     *\r\n     * If the 'tokenId' is burned:\r\n     *\r\n     * - 'addr = <Address of owner before token was burned>'\r\n     * - 'startTimestamp = <Timestamp when token was burned>'\r\n     * - 'burned = true'\r\n     * - 'extraData = <Extra data when token was burned>'\r\n     *\r\n     * Otherwise:\r\n     *\r\n     * - 'addr = <Address of owner>'\r\n     * - 'startTimestamp = <Timestamp of start of ownership>'\r\n     * - 'burned = false'\r\n     * - 'extraData = <Extra data at start of ownership>'\r\n     */\r\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\r\n        TokenOwnership memory ownership;\r\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\r\n            return ownership;\r\n        }\r\n        ownership = _ownershipAt(tokenId);\r\n        if (ownership.burned) {\r\n            return ownership;\r\n        }\r\n        return _ownershipOf(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array of 'TokenOwnership' structs at 'tokenIds' in order.\r\n     * See {ERC721AQueryable-explicitOwnershipOf}\r\n     */\r\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (TokenOwnership[] memory)\r\n    {\r\n        unchecked {\r\n            uint256 tokenIdsLength = tokenIds.length;\r\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\r\n            for (uint256 i; i != tokenIdsLength; ++i) {\r\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\r\n            }\r\n            return ownerships;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array of token IDs owned by 'owner',\r\n     * in the range ['start', 'stop')\r\n     * (i.e. 'start <= tokenId < stop').\r\n     *\r\n     * This function allows for tokens to be queried if the collection\r\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - 'start < stop'\r\n     */\r\n    function tokensOfOwnerIn(\r\n        address owner,\r\n        uint256 start,\r\n        uint256 stop\r\n    ) external view virtual override returns (uint256[] memory) {\r\n        unchecked {\r\n            if (start >= stop) revert InvalidQueryRange();\r\n            uint256 tokenIdsIdx;\r\n            uint256 stopLimit = _nextTokenId();\r\n            // Set 'start = max(start, _startTokenId())'.\r\n            if (start < _startTokenId()) {\r\n                start = _startTokenId();\r\n            }\r\n            // Set 'stop = min(stop, stopLimit)'.\r\n            if (stop > stopLimit) {\r\n                stop = stopLimit;\r\n            }\r\n            uint256 tokenIdsMaxLength = balanceOf(owner);\r\n            // Set 'tokenIdsMaxLength = min(balanceOf(owner), stop - start)',\r\n            // to cater for cases where 'balanceOf(owner)' is too big.\r\n            if (start < stop) {\r\n                uint256 rangeLength = stop - start;\r\n                if (rangeLength < tokenIdsMaxLength) {\r\n                    tokenIdsMaxLength = rangeLength;\r\n                }\r\n            } else {\r\n                tokenIdsMaxLength = 0;\r\n            }\r\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\r\n            if (tokenIdsMaxLength == 0) {\r\n                return tokenIds;\r\n            }\r\n            // We need to call 'explicitOwnershipOf(start)',\r\n            // because the slot at 'start' may not be initialized.\r\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\r\n            address currOwnershipAddr;\r\n            // If the starting slot exists (i.e. not burned), initialize 'currOwnershipAddr'.\r\n            // 'ownership.address' will not be zero, as 'start' is clamped to the valid token ID range.\r\n            if (!ownership.burned) {\r\n                currOwnershipAddr = ownership.addr;\r\n            }\r\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\r\n                ownership = _ownershipAt(i);\r\n                if (ownership.burned) {\r\n                    continue;\r\n                }\r\n                if (ownership.addr != address(0)) {\r\n                    currOwnershipAddr = ownership.addr;\r\n                }\r\n                if (currOwnershipAddr == owner) {\r\n                    tokenIds[tokenIdsIdx++] = i;\r\n                }\r\n            }\r\n            // Downsize the array to fit.\r\n            assembly {\r\n                mstore(tokenIds, tokenIdsIdx)\r\n            }\r\n            return tokenIds;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array of token IDs owned by 'owner'.\r\n     *\r\n     * This function scans the ownership mapping and is O('totalSupply') in complexity.\r\n     * It is meant to be called off-chain.\r\n     *\r\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\r\n     * multiple smaller scans if the collection is large enough to cause\r\n     * an out-of-gas error (10K collections should be fine).\r\n     */\r\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\r\n        unchecked {\r\n            uint256 tokenIdsIdx;\r\n            address currOwnershipAddr;\r\n            uint256 tokenIdsLength = balanceOf(owner);\r\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\r\n            TokenOwnership memory ownership;\r\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\r\n                ownership = _ownershipAt(i);\r\n                if (ownership.burned) {\r\n                    continue;\r\n                }\r\n                if (ownership.addr != address(0)) {\r\n                    currOwnershipAddr = ownership.addr;\r\n                }\r\n                if (currOwnershipAddr == owner) {\r\n                    tokenIds[tokenIdsIdx++] = i;\r\n                }\r\n            }\r\n            return tokenIds;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File: @openzeppelin/contracts/utils/cryptography/MerkleProof.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The tree and the proofs can be generated using our\r\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\r\n * You will find a quickstart guide in the readme.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\r\n * against this attack out of the box.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a 'leaf' can be proved to be a part of a Merkle tree\r\n     * defined by 'root'. For this, a 'proof' must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {verify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function verifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProofCalldata(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from 'leaf' using 'proof'. A 'proof' is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the 'leaves' can be simultaneously proven to be a part of a merkle tree defined by\r\n     * 'root', according to 'proof' and 'proofFlags' as described in {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerify(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProof(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the root of a tree reconstructed from 'leaves' and sibling nodes in 'proof'. The reconstruction\r\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\r\n     * leaf/inner node or a proof sibling node, depending on whether each 'proofFlags' item is true or false\r\n     * respectively.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\r\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\r\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProof(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the 'leaves' array, then goes onto the\r\n        // 'hashes' array. At the end of the process, the last hash in the 'hashes' array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // 'xxx[xxxPos++]', which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\r\n        //   'proof' array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            return hashes[totalHashes - 1];\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProofCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the 'leaves' array, then goes onto the\r\n        // 'hashes' array. At the end of the process, the last hash in the 'hashes' array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // 'xxx[xxxPos++]', which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\r\n        //   'proof' array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            return hashes[totalHashes - 1];\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from 'ReentrancyGuard' will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single 'nonReentrant' guard, functions marked as\r\n * 'nonReentrant' may not call one another. This can be worked around by making\r\n * those functions 'private', and then adding 'external' 'nonReentrant' entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a 'nonReentrant' function from another 'nonReentrant'\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the 'nonReentrant' function external, and making it call a\r\n     * 'private' function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * 'onlyOwner', which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * 'onlyOwner' functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account ('newOwner').\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account ('newOwner').\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/ERC721L.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ncontract SmudgyPushingP is IERC721L, ERC721AQueryable, Ownable, ReentrancyGuard, DefaultOperatorFilterer {\r\n\r\n    // Whether base URI is permanent. Once set, base URI is immutable.\r\n    bool private _baseURIPermanent;\r\n\r\n    // The total mintable supply.\r\n    uint256 internal _maxMintableSupply = 120;\r\n\r\n    // Global wallet limit, across all stages has to be smaller than _maxMintableSupply (0 = unlimited).\r\n    uint256 private _globalWalletLimit = 8;\r\n\r\n    address private lmnft = 0x9E6865DAEeeDD093ea4A4f6c9bFbBB0cE6Bc8b17;\r\n    uint256 public min_fee = 0.05 ether;\r\n    uint256 public threshold = 3 ether;\r\n\r\n    // Current base URI.\r\n    string private _currentBaseURI = \"ipfs://null/\";\r\n\r\n    // The suffix for the token URL, e.g. \".json\".\r\n    string private _tokenURISuffix = \".json\";\r\n\r\n    // Mint stage infomation. See MintStageInfo for details.\r\n    MintStageInfo[] private _mintStages;\r\n\r\n    // Minted count per stage per wallet.\r\n    mapping(uint256 => mapping(address => uint32))\r\n        private _stageMintedCountsPerWallet;\r\n\r\n    // Minted count per stage.\r\n    mapping(uint256 => uint256) private _stageMintedCounts;\r\n\r\n    constructor() ERC721A(\"Smudgy Pushing P\", \"SMDG\") {\r\n        _mintStages.push(MintStageInfo({cost: 4000000000000000000, walletLimit: 8, merkleRoot: 0x0, maxStageSupply: 0, startTimeUnixSeconds: 1687448222, endTimeUnixSeconds: 1692545822}));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Returns whether it has enough supply for the given qty.\r\n     */\r\n    modifier hasSupply(uint256 qty) {\r\n        if (totalSupply() + qty > _maxMintableSupply) revert NoSupplyLeft();\r\n        _;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Sets stages in the format of an array of 'MintStageInfo'.\r\n     *\r\n     * Following is an example of launch with two stages. The first stage is exclusive for whitelisted wallets\r\n     * specified by merkle root.\r\n     *    [{\r\n     *      cost: 10000000000000000000,\r\n     *      maxStageSupply: 2000,\r\n     *      walletLimit: 1,\r\n     *      merkleRoot: 0x12..345,\r\n     *      startTimeUnixSeconds: 1667768000,\r\n     *      endTimeUnixSeconds: 1667771600,\r\n     *     },\r\n     *     {\r\n     *      cost: 20000000000000000000,\r\n     *      maxStageSupply: 3000,\r\n     *      walletLimit: 2,\r\n     *      merkleRoot: 0x0000000000000000000000000000000000000000000000000000000000000000,\r\n     *      startTimeUnixSeconds: 1667771600,\r\n     *      endTimeUnixSeconds: 1667775200,\r\n     *     }\r\n     * ]\r\n     */\r\n    function setStages(MintStageInfo[] calldata newStages) external onlyOwner {\r\n        uint256 originalSize = _mintStages.length;\r\n        for (uint256 i = 0; i < originalSize; i++) {\r\n            _mintStages.pop();\r\n        }\r\n\r\n\r\n        for (uint256 i = 0; i < newStages.length; i++) {\r\n            if (i >= 1) {\r\n                if (\r\n                    newStages[i].startTimeUnixSeconds <\r\n                    newStages[i - 1].endTimeUnixSeconds\r\n                ) {\r\n                    revert InsufficientStageTimeGap();\r\n                }\r\n            }\r\n            _assertValidStartAndEndTimestamp(\r\n                newStages[i].startTimeUnixSeconds,\r\n                newStages[i].endTimeUnixSeconds\r\n            );\r\n            _mintStages.push(\r\n                MintStageInfo({\r\n                    cost: newStages[i].cost,\r\n                    walletLimit: newStages[i].walletLimit,\r\n                    merkleRoot: newStages[i].merkleRoot,\r\n                    maxStageSupply: newStages[i].maxStageSupply,\r\n                    startTimeUnixSeconds: newStages[i].startTimeUnixSeconds,\r\n                    endTimeUnixSeconds: newStages[i].endTimeUnixSeconds\r\n                })\r\n            );\r\n            emit UpdateStage(\r\n                i,\r\n                newStages[i].cost,\r\n                newStages[i].walletLimit,\r\n                newStages[i].merkleRoot,\r\n                newStages[i].maxStageSupply,\r\n                newStages[i].startTimeUnixSeconds,\r\n                newStages[i].endTimeUnixSeconds\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of stages.\r\n     */\r\n    function getNumberStages() external view override returns (uint256) {\r\n        return _mintStages.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns maximum mintable supply.\r\n     */\r\n    function getMaxMintableSupply() external view override returns (uint256) {\r\n        return _maxMintableSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets maximum mintable supply.\r\n     *\r\n     * New supply cannot be larger than the old.\r\n     */\r\n    function setMaxMintableSupply(uint256 maxMintableSupply)\r\n        external\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        if (maxMintableSupply > _maxMintableSupply) {\r\n            revert CannotIncreaseMaxMintableSupply();\r\n        }\r\n        _maxMintableSupply = maxMintableSupply;\r\n        emit SetMaxMintableSupply(maxMintableSupply);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns global wallet limit. This is the max number of tokens can be minted by one wallet.\r\n     */\r\n    function getGlobalWalletLimit() external view override returns (uint256) {\r\n        return _globalWalletLimit;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets global wallet limit.\r\n     */\r\n    function setGlobalWalletLimit(uint256 globalWalletLimit)\r\n        external\r\n        onlyOwner\r\n    {\r\n        if (globalWalletLimit > _maxMintableSupply)\r\n            revert GlobalWalletLimitOverflow();\r\n        _globalWalletLimit = globalWalletLimit;\r\n        emit SetGlobalWalletLimit(globalWalletLimit);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns number of minted token for a given address.\r\n     */\r\n    function totalMintedByAddress(address a)\r\n        external\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _numberMinted(a);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns info for one stage specified by index (starting from 0).\r\n     */\r\n    function getStageInfo(uint256 index)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            MintStageInfo memory,\r\n            uint32,\r\n            uint256\r\n        )\r\n    {\r\n        if (index >= _mintStages.length) {\r\n            revert(\"InvalidStage\");\r\n        }\r\n        uint32 walletMinted = _stageMintedCountsPerWallet[index][msg.sender];\r\n        uint256 stageMinted = _stageMintedCounts[index];\r\n        return (_mintStages[index], walletMinted, stageMinted);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates info for one stage specified by index (starting from 0).\r\n     */\r\n    function updateStage(\r\n        uint256 index,\r\n        uint80 cost,\r\n        uint32 walletLimit,\r\n        bytes32 merkleRoot,\r\n        uint24 maxStageSupply,\r\n        uint64 startTimeUnixSeconds,\r\n        uint64 endTimeUnixSeconds\r\n    ) external onlyOwner {\r\n        if (index >= _mintStages.length) revert InvalidStage();\r\n        if (index >= 1) {\r\n            if (\r\n                startTimeUnixSeconds <\r\n                _mintStages[index - 1].endTimeUnixSeconds\r\n            ) {\r\n                revert InsufficientStageTimeGap();\r\n            }\r\n        }\r\n        _assertValidStartAndEndTimestamp(\r\n            startTimeUnixSeconds,\r\n            endTimeUnixSeconds\r\n        );\r\n        _mintStages[index].cost = cost;\r\n        _mintStages[index].walletLimit = walletLimit;\r\n        _mintStages[index].merkleRoot = merkleRoot;\r\n        _mintStages[index].maxStageSupply = maxStageSupply;\r\n        _mintStages[index].startTimeUnixSeconds = startTimeUnixSeconds;\r\n        _mintStages[index].endTimeUnixSeconds = endTimeUnixSeconds;\r\n\r\n        emit UpdateStage(\r\n            index,\r\n            cost,\r\n            walletLimit,\r\n            merkleRoot,\r\n            maxStageSupply,\r\n            startTimeUnixSeconds,\r\n            endTimeUnixSeconds\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints token(s).\r\n     *\r\n     * qty - number of tokens to mint\r\n     * proof - the merkle proof generated on client side. This applies if using whitelist.\r\n     */\r\n    function mint(\r\n        uint32 qty,\r\n        bytes32[] calldata proof\r\n    ) external payable nonReentrant {\r\n        _mintInternal(qty, msg.sender, proof);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Implementation of minting.\r\n     */\r\n    function _mintInternal(\r\n        uint32 qty,\r\n        address to,\r\n        bytes32[] calldata proof\r\n    ) internal hasSupply(qty) {\r\n        uint64 stageTimestamp = uint64(block.timestamp);\r\n\r\n        MintStageInfo memory stage;\r\n\r\n        uint256 activeStage = getActiveStageFromTimestamp(stageTimestamp);\r\n\r\n        stage = _mintStages[activeStage];\r\n\r\n        // Check value\r\n        if(stage.cost < threshold ) {\r\n            if (msg.value < (stage.cost + min_fee) * qty) revert NotEnoughValue();\r\n        } else {\r\n            if (msg.value < stage.cost * qty) revert NotEnoughValue();\r\n        }\r\n\r\n        // Check stage supply if applicable\r\n        if (stage.maxStageSupply > 0) {\r\n            if (_stageMintedCounts[activeStage] + qty > stage.maxStageSupply)\r\n                revert StageSupplyExceeded();\r\n        }\r\n\r\n        // Check global wallet limit if applicable\r\n        if (_globalWalletLimit > 0) {\r\n            if (_numberMinted(to) + qty > _globalWalletLimit)\r\n                revert WalletGlobalLimitExceeded();\r\n        }\r\n\r\n        // Check wallet limit for stage if applicable, limit == 0 means no limit enforced\r\n        if (stage.walletLimit > 0) {\r\n            if (\r\n                _stageMintedCountsPerWallet[activeStage][to] + qty >\r\n                stage.walletLimit\r\n            ) revert WalletStageLimitExceeded();\r\n        }\r\n\r\n        // Check merkle proof if applicable, merkleRoot == 0x00...00 means no proof required\r\n        if (stage.merkleRoot != 0) {\r\n            if (\r\n                MerkleProof.processProof(\r\n                    proof,\r\n                    keccak256(abi.encodePacked(to))\r\n                ) != stage.merkleRoot\r\n            ) revert InvalidProof();\r\n        }\r\n\r\n        _stageMintedCountsPerWallet[activeStage][to] += qty;\r\n        _stageMintedCounts[activeStage] += qty;\r\n        _safeMint(to, qty);\r\n\r\n        if(stage.cost < threshold ) {\r\n            payable(lmnft).transfer(min_fee * qty);\r\n            payable(owner()).transfer(msg.value - (min_fee * qty));\r\n        } else {\r\n            payable(lmnft).transfer((msg.value / 66) * qty);\r\n            payable(owner()).transfer(msg.value - ((msg.value / 66)  * qty));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Mints token(s) by owner.\r\n     *\r\n     * NOTE: This function bypasses validations thus only available for owner.\r\n     * This is typically used for owner to  pre-mint or mint the remaining of the supply.\r\n     */\r\n    function ownerMint(uint32 qty, address to)\r\n        external\r\n        payable\r\n        onlyOwner\r\n        hasSupply(qty)\r\n    {\r\n        if (msg.value < min_fee * qty) revert NotEnoughValue();\r\n        _safeMint(to, qty);\r\n        payable(lmnft).transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws funds by owner.\r\n     */\r\n    function withdraw() external onlyOwner {\r\n        uint256 value = address(this).balance;\r\n        (bool success, ) = msg.sender.call{value: value}(\"\");\r\n        if (!success) revert WithdrawFailed();\r\n        emit Withdraw(value);\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev Sets token base URI.\r\n     */\r\n    function setBaseURI(string calldata baseURI) external onlyOwner {\r\n        if (_baseURIPermanent) revert CannotUpdatePermanentBaseURI();\r\n        _currentBaseURI = baseURI;\r\n        emit SetBaseURI(baseURI);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets token base URI permanent. Cannot revert.\r\n     */\r\n    function setBaseURIPermanent() external onlyOwner {\r\n        _baseURIPermanent = true;\r\n        emit PermanentBaseURI(_currentBaseURI);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns token URI suffix.\r\n     */\r\n    function getTokenURISuffix()\r\n        external\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        return _tokenURISuffix;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets token URI suffix. e.g. \".json\".\r\n     */\r\n    function setTokenURISuffix(string calldata suffix) external onlyOwner {\r\n        _tokenURISuffix = suffix;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Returns token URI for a given token id.\r\n     */\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override(ERC721A, IERC721A)\r\n        returns (string memory)\r\n    {\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n\r\n        string memory baseURI = _currentBaseURI;\r\n        return\r\n            bytes(baseURI).length != 0\r\n                ? string(\r\n                    abi.encodePacked(\r\n                        baseURI,\r\n                        _toString(tokenId),\r\n                        _tokenURISuffix\r\n                    )\r\n                )\r\n                : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current active stage based on timestamp.\r\n     */\r\n    function getActiveStageFromTimestamp(uint64 timestamp)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        for (uint256 i = 0; i < _mintStages.length; i++) {\r\n            if (\r\n                timestamp >= _mintStages[i].startTimeUnixSeconds &&\r\n                timestamp < _mintStages[i].endTimeUnixSeconds\r\n            ) {\r\n                return i;\r\n            }\r\n        }\r\n        revert InvalidStage();\r\n    }\r\n\r\n    /**\r\n     * @dev Validates the start timestamp is before end timestamp. Used when updating stages.\r\n     */\r\n    function _assertValidStartAndEndTimestamp(uint64 start, uint64 end)\r\n        internal\r\n        pure\r\n    {\r\n        if (start >= end) revert InvalidStartAndEndTimestamp();\r\n    }\r\n\r\n    \r\n    function setApprovalForAll(address operator, bool approved) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\r\n        super.setApprovalForAll(operator, approved);\r\n    }\r\n\r\n    function approve(address operator, uint256 tokenId) public payable override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\r\n        super.approve(operator, tokenId);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public payable override(ERC721A, IERC721A) onlyAllowedOperator(from) {\r\n        super.transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public payable override(ERC721A, IERC721A) onlyAllowedOperator(from) {\r\n        super.safeTransferFrom(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\r\n        public\r\n        payable\r\n        override(ERC721A, IERC721A)\r\n        onlyAllowedOperator(from)\r\n    {\r\n        super.safeTransferFrom(from, to, tokenId, data);\r\n    }\r\n    \r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotIncreaseMaxMintableSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotUpdatePermanentBaseURI\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GlobalWalletLimitOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientStageTimeGap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQueryRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStageArgsLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStartAndEndTimestamp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSupplyLeft\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StageSupplyExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimestampExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WalletGlobalLimitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WalletStageLimitExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"PermanentBaseURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"activeStage\",\"type\":\"uint256\"}],\"name\":\"SetActiveStage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"SetBaseURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"globalWalletLimit\",\"type\":\"uint256\"}],\"name\":\"SetGlobalWalletLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxMintableSupply\",\"type\":\"uint256\"}],\"name\":\"SetMaxMintableSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"cost\",\"type\":\"uint80\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"walletLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"maxStageSupply\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"startTimeUnixSeconds\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"endTimeUnixSeconds\",\"type\":\"uint64\"}],\"name\":\"UpdateStage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OPERATOR_FILTER_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IOperatorFilterRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"explicitOwnershipOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"extraData\",\"type\":\"uint24\"}],\"internalType\":\"struct IERC721A.TokenOwnership\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"explicitOwnershipsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"extraData\",\"type\":\"uint24\"}],\"internalType\":\"struct IERC721A.TokenOwnership[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"getActiveStageFromTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalWalletLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxMintableSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberStages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getStageInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint80\",\"name\":\"cost\",\"type\":\"uint80\"},{\"internalType\":\"uint32\",\"name\":\"walletLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint24\",\"name\":\"maxStageSupply\",\"type\":\"uint24\"},{\"internalType\":\"uint64\",\"name\":\"startTimeUnixSeconds\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTimeUnixSeconds\",\"type\":\"uint64\"}],\"internalType\":\"struct IERC721L.MintStageInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenURISuffix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"min_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"qty\",\"type\":\"uint32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"qty\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setBaseURIPermanent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"globalWalletLimit\",\"type\":\"uint256\"}],\"name\":\"setGlobalWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxMintableSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxMintableSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint80\",\"name\":\"cost\",\"type\":\"uint80\"},{\"internalType\":\"uint32\",\"name\":\"walletLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint24\",\"name\":\"maxStageSupply\",\"type\":\"uint24\"},{\"internalType\":\"uint64\",\"name\":\"startTimeUnixSeconds\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTimeUnixSeconds\",\"type\":\"uint64\"}],\"internalType\":\"struct IERC721L.MintStageInfo[]\",\"name\":\"newStages\",\"type\":\"tuple[]\"}],\"name\":\"setStages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"suffix\",\"type\":\"string\"}],\"name\":\"setTokenURISuffix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"tokensOfOwnerIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"totalMintedByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"cost\",\"type\":\"uint80\"},{\"internalType\":\"uint32\",\"name\":\"walletLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint24\",\"name\":\"maxStageSupply\",\"type\":\"uint24\"},{\"internalType\":\"uint64\",\"name\":\"startTimeUnixSeconds\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTimeUnixSeconds\",\"type\":\"uint64\"}],\"name\":\"updateStage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SmudgyPushingP", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0e8570454140a687fe7c5b96ab5abc473d30f2170197b0113a4b4f8f32ffcc27"}