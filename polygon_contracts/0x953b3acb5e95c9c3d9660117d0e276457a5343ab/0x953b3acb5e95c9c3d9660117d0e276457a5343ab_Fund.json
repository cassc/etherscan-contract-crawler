{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Fund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./Base.sol\\\";\\n\\ninterface ICore {\\n    function owner() external returns(address);\\n\\n    function logInvestment(\\n        bytes32 nftHash,\\n        address who,\\n        address erc721,\\n        uint tokenId,\\n        uint date,\\n        address erc20,\\n        uint investment) external;\\n\\n    function logReturnOnInvestment(\\n        bool declined,\\n        bytes32 nftHash,\\n        address who,\\n        address erc721,\\n        uint tokenId,\\n        uint date,\\n        address erc20,\\n        uint investment,\\n        uint roiDate,\\n        address roiErc20,\\n        uint roi) external;\\n}\\n\\ncontract Fund is Base {\\n    using SafeMath for uint256;\\n    uint DEV_FEE = 10;\\n    uint FUND_THRESHOLD = 85;\\n    address DEV = 0xBF90AF3Ef59dD627f22bE64F2a08b2DB09bec8a3;\\n\\n    struct Info {\\n        uint status;\\n        string id;\\n        string link;\\n        address erc20;\\n        address[] erc721;\\n        uint protocolFee;\\n        uint startDate;\\n        uint endDate;\\n        uint initialFund;\\n        uint minAmount;\\n        uint maxAmount;\\n        uint actualFund;\\n        address roiErc20;\\n        uint roiAmount;\\n        uint participantCount;\\n        uint rewardsCount;\\n        uint balance;\\n        uint roiBalance;\\n    }\\n\\n    struct Vesting {\\n        address erc721;\\n        uint tokenId;\\n        uint date;\\n        address erc20;\\n        uint investment;\\n        uint roiIndex;\\n        uint roiDate;\\n        address roiErc20;\\n        uint roi;\\n    }\\n\\n    enum State{ OPEN, VESTING, DECLINED, COMPLETED }\\n\\n    State private state;\\n    uint private protocolFee;\\n\\n    string private id;\\n    string private link;\\n    address private fundErc20;\\n    address[] private erc721;\\n    uint private startDate;\\n    uint private endDate;\\n    uint private initialFund;\\n    uint private minAmount;\\n    uint private maxAmount;\\n    uint private actualFund;\\n    address private roiErc20;\\n    uint private roiAmount;\\n    \\n    mapping(address => bool) private allowedNFT;\\n    mapping(bytes32 => Vesting) private participant;\\n    uint private participantCount;\\n\\n    mapping(bytes32 => Vesting) private rewards;\\n    bytes32[] private rewardsArray;\\n    uint private rewardsCount;\\n\\n    constructor(\\n        string memory _id,\\n        string memory _link,\\n        address _erc20,\\n        address[] memory _erc721,\\n        uint _protocolFee,\\n        uint _startDate,\\n        uint _endDate,\\n        uint _initialFund,\\n        uint _minAmount,\\n        uint _maxAmount) {\\n        \\n        state = State.OPEN;\\n        id = _id;\\n        link = _link;\\n        fundErc20 = _erc20;\\n        erc721 = _erc721;\\n        protocolFee = _protocolFee;\\n        startDate = _startDate;\\n        endDate = _endDate;\\n        initialFund = _initialFund;\\n        minAmount = _minAmount;\\n        maxAmount = _maxAmount;\\n\\n        for(uint i = 0; i < erc721.length; i++ ) {\\n            allowedNFT[erc721[i]] = true;\\n        }\\n    }\\n\\n    function infos() public view returns (Info memory info) {\\n        info = Info(uint(state), id, link, fundErc20, erc721, protocolFee, startDate, endDate, \\n            initialFund, minAmount, maxAmount, actualFund, roiErc20, \\n            roiAmount, participantCount, rewardsCount, investmentBalance(), roiBalance());\\n        return info;\\n    }\\n\\n    function investmentBalance() public view returns (uint256) {\\n        if(state == State.OPEN || state == State.DECLINED) {\\n            return balance();\\n        }\\n        return actualFund;\\n    }\\n\\n    function roiBalance() public view returns (uint256) {\\n        if(roiErc20 == address(0)) {\\n            return 0;\\n        }\\n        return IERC20(roiErc20).balanceOf(address(this));\\n    }\\n\\n    function balance() public view returns (uint256) {\\n        return IERC20(fundErc20).balanceOf(address(this));\\n    }\\n\\n    function investments(address nft, uint tokenId) external view returns (bool end, Vesting memory) {\\n        bytes32 itemHash = _hashNft(nft, tokenId);\\n        Vesting memory vesting = participant[itemHash];\\n        require(vesting.erc20 != address(0) && vesting.investment > 0, \\\"investment is zero\\\");\\n\\n        if(_isClaimedReturn(itemHash)) {\\n            return (true, vesting);\\n        }\\n\\n        if(_isClaimedReward(itemHash)) {\\n            return (true, rewards[itemHash]);\\n        }\\n\\n        return (false, vesting);\\n    }\\n\\n    function claimable(address nft, uint tokenId) public view returns (address, uint) {\\n        bytes32 itemHash = _hashNft(nft, tokenId);\\n        Vesting memory item = participant[itemHash];\\n        \\n        if(state == State.DECLINED && !_isClaimedReturn(itemHash)) {\\n            return (fundErc20, item.investment);\\n        }\\n\\n        if(state == State.COMPLETED && !_isClaimedReward(itemHash)) {\\n            return claimableRewards(nft, tokenId);\\n        }\\n\\n        return (address(0), 0);\\n    }\\n\\n    function claimableRewards(address nft, uint tokenId) private view returns (address, uint) {\\n        require((state == State.COMPLETED), \\\"not COMPLETED\\\");\\n\\n        bytes32 itemHash = _hashNft(nft, tokenId);\\n        Vesting memory item = participant[itemHash];\\n\\n        uint _initFund = _decimalConvert(fundErc20, roiErc20, actualFund);\\n        uint _investment = _decimalConvert(fundErc20, roiErc20, item.investment);\\n        uint _decimal = 10 ** IERC20(roiErc20).decimals();\\n        \\n        uint _perShare = _investment.mul(_decimal).div(_initFund);\\n        uint reward = roiAmount.mul(_perShare).div(_decimal);\\n        return (roiErc20, reward);\\n    }\\n\\n    function invest(address nft, uint tokenId, uint amount) external returns(bool) {\\n        uint today = block.timestamp;\\n        bytes32 itemHash = _preValidationInvest(nft, tokenId, amount);\\n        Vesting memory item = participant[itemHash];\\n        bool newParticipant = item.investment == 0;\\n        uint investment = item.investment.add(amount);\\n    \\n        IERC20(fundErc20).transferFrom(msg.sender, address(this), amount);\\n        require(balance() <= initialFund, \\\"fund exceeded\\\");\\n        participant[itemHash] = Vesting(nft, tokenId, today, fundErc20, investment, 0, 0, address(0), 0);\\n        if(newParticipant) {\\n            participantCount++;\\n        }\\n        ICore(owner()).logInvestment(itemHash, msg.sender, nft, tokenId, today, fundErc20, amount);\\n        return true;\\n    }\\n    \\n    function cliamReward(address nft, uint tokenId) external returns(bool) {\\n        uint today = block.timestamp;\\n        bytes32 itemHash = _preValidationClaim(nft, tokenId);\\n        (address rewardErc20, uint reward) = claimableRewards(nft, tokenId);\\n\\n        IERC20(rewardErc20).transfer(msg.sender, reward);\\n        Vesting memory item = participant[itemHash];\\n        uint roiIndex = rewardsCount;\\n        rewards[itemHash] = Vesting(item.erc721, item.tokenId, item.date, item.erc20, item.investment, roiIndex, today, rewardErc20, reward);\\n        rewardsArray[roiIndex] = itemHash;\\n        rewardsCount++;\\n\\n        ICore(owner()).logReturnOnInvestment(\\n            false,\\n            itemHash,\\n            msg.sender,\\n            item.erc721,\\n            item.tokenId,\\n            item.date,\\n            item.erc20,\\n            item.investment,\\n            today,\\n            rewardErc20,\\n            reward);\\n        return true;\\n    }\\n\\n    function claimReasonDenied(address nft, uint tokenId) external returns(bool) {\\n        require(IERC721(nft).ownerOf(tokenId) == msg.sender, \\\"not owner\\\");\\n        require(state == State.DECLINED, \\\"not declined\\\");\\n\\n        bytes32 itemHash = _hashNft(nft, tokenId);\\n        Vesting storage item = participant[itemHash];\\n        require(item.investment > 0, \\\"zero investment\\\");\\n        require(item.roi <= 0, \\\"return given already\\\");\\n\\n        IERC20(fundErc20).transfer(msg.sender, item.investment);\\n        item.roiDate = block.timestamp;\\n        item.roiErc20 = fundErc20;\\n        item.roi = item.investment;\\n\\n        ICore(owner()).logReturnOnInvestment(\\n            true, \\n            itemHash,\\n            msg.sender,\\n            item.erc721,\\n            item.tokenId,\\n            item.date,\\n            item.erc20,\\n            item.investment,\\n            item.roiDate,\\n            item.roiErc20,\\n            item.roi);\\n        return true;\\n    }\\n\\n    function _preValidationClaim(address nft, uint tokenId) private view returns(bytes32) {\\n        bytes32 itemHash = _hashNft(nft, tokenId);\\n\\n        require(IERC721(nft).ownerOf(tokenId) == msg.sender, \\\"not owner\\\");\\n        require((state == State.COMPLETED), \\\"not COMPLETED\\\");\\n        Vesting memory item = rewards[itemHash];\\n        if(rewardsArray[item.roiIndex] == itemHash) {\\n            revert(\\\"reward given already\\\");\\n        }\\n        return itemHash;\\n    }\\n\\n    function _preValidationInvest(address nft, uint tokenId, uint amount) private view returns(bytes32) {\\n        uint today = block.timestamp;\\n        bytes32 itemHash = _hashNft(nft, tokenId);\\n        Vesting memory item = participant[itemHash];\\n\\n        require(allowedNFT[nft], \\\"not allowed nft\\\");\\n        require(IERC721(nft).ownerOf(tokenId) == msg.sender, \\\"not owner\\\");\\n        require(state == State.OPEN, \\\"not open\\\");\\n        require(startDate < today && today < endDate, \\\"outdated\\\");\\n        \\n        uint investment = item.investment.add(amount);\\n        require(minAmount <= investment && investment <= maxAmount, \\\"min or max limit\\\");\\n        require((balance().add(amount)) <= initialFund, \\\"fund exceeded\\\");\\n\\n        return itemHash;\\n    }\\n\\n    function _isClaimedReturn(bytes32 itemHash) private view returns (bool) {\\n        require(bytes32(0) != itemHash, \\\"hash is zero\\\");\\n        Vesting memory item = participant[itemHash];\\n        return state == State.DECLINED && item.roi > 0;\\n    }\\n\\n    function _isClaimedReward(bytes32 itemHash) private view returns (bool) {\\n        require(bytes32(0) != itemHash, \\\"hash is zero\\\");\\n        Vesting memory item = rewards[itemHash];\\n        return state == State.COMPLETED && rewardsArray[item.roiIndex] == itemHash && item.roi > 0;\\n    }\\n\\n    function _hashNft(address nft, uint tokenId) private pure returns (bytes32) {\\n        return keccak256(abi.encode(nft,tokenId));\\n    }\\n\\n    function _decimalConvert(address from, address to, uint amount) private pure returns (uint) {\\n        if(amount <= 0) return amount;\\n\\n        uint fromDecimal = IERC20(from).decimals();\\n        uint toDecimal = IERC20(to).decimals();\\n        if(fromDecimal == toDecimal) {\\n            return amount;\\n        }\\n        return amount.mul(toDecimal).div(fromDecimal);\\n    }\\n\\n    function _serviceFee(address erc20, uint revenue) private {\\n        if(revenue <= 0) return;\\n        uint fee = revenue.percentageOf(DEV_FEE);\\n        uint serviceFee = revenue.sub(fee);\\n        if(serviceFee > 0) {\\n            IERC20(erc20).transfer(owner(), serviceFee);\\n        }\\n        if(fee > 0) {\\n            IERC20(erc20).transfer(DEV, fee);\\n        }\\n    }\\n\\n    function declineFund() external onlyOwner {\\n        require(state == State.OPEN, \\\"not open\\\");\\n        state = State.DECLINED;\\n    }\\n\\n    function startFund() external onlyOwner returns(address, uint) {\\n        require(state == State.OPEN, \\\"not open\\\");\\n        uint threshold = initialFund.percentageOf(FUND_THRESHOLD);\\n        require(balance() >= threshold, \\\"fund not enough\\\");\\n        \\n        actualFund = balance();\\n        IERC20(fundErc20).transfer(ICore(owner()).owner(), actualFund);\\n        state = State.VESTING;\\n        return (fundErc20, actualFund);\\n    }\\n    \\n    function finishFund(address _erc20) external onlyOwner returns(address, uint) {\\n        require((state == State.VESTING || state == State.COMPLETED), \\\"not vesting\\\");\\n        uint _balance = IERC20(_erc20).balanceOf(address(this));\\n        uint _revenue = _balance.percentageOf10000(protocolFee);\\n\\n        _serviceFee(_erc20, _revenue);\\n        roiErc20 = _erc20;\\n        roiAmount = _balance.sub(_revenue);\\n        rewardsArray = new bytes32[](participantCount);\\n        rewardsCount = 0;\\n        state = State.COMPLETED;\\n        return (_erc20, _balance);\\n    }\\n\\n    function emergencyWithdraw(address _recipient, address _erc20) external onlyOwner returns (uint) {\\n        require(state == State.COMPLETED, \\\"not completed\\\");\\n        uint _balance = IERC20(_erc20).balanceOf(address(this));\\n        IERC20(_erc20).transfer(_recipient, _balance);\\n        return _balance;\\n    }\\n    \\n}\"\r\n    },\r\n    \"/contracts/Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function percentageOf(uint a, uint b) internal pure returns (uint256) {\\n        require(b > 0);\\n        return a * b / 100;\\n    }\\n\\n    function percentageOf10000(uint a, uint b) internal pure returns (uint256) {\\n        require(b > 0);\\n        return a * b / 10000;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint);\\n    function mint(address to, uint256 amount) external;\\n    function burn(uint256 amount) external;\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IERC721 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n    function approve(address to, uint256 tokenId) external;\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\\nabstract contract Base is Ownable {}\\n\\nabstract contract CoreBase is Base {\\n    address[] internal _allFund;\\n    mapping(address => bool) private _fundExist;\\n\\n    function _addFund (address fund) internal virtual  {\\n        require(!_existFund(fund), \\\"already added\\\");\\n        _allFund.push(fund);\\n        _fundExist[fund] = true;\\n    }\\n\\n    function _existFund (address fund) internal virtual returns(bool)  {\\n        return _fundExist[fund];\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1300\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_link\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_erc721\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialFund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimReasonDenied\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cliamReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"declineFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"}],\"name\":\"finishFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"infos\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"link\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"erc721\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialFund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualFund\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"roiErc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roiAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"participantCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct Fund.Info\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investmentBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"investments\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"end\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"roiErc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"}],\"internalType\":\"struct Fund.Vesting\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roiBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Fund", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "1300", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000049b3e7448b43f6e2f05e93ad095228036fa0c23c00000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064bf10800000000000000000000000000000000000000000000000000000000064c5a80000000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000000004746573740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000047465737400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000003206dd04615c69e8c1837926c5ceb1b8e418b61", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}