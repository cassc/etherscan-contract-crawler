{"SourceCode": "// File: utils/ISpawnCoin.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface ISpawnCoin {\r\n\r\n    event SpawnContractAddressChanged(address indexed _from, address indexed _to, uint256 time);\r\n\r\n    function setSpawnContractAddress(address addr) external;\r\n\r\n    function spawnEgg(address addr,uint256 amount) external;\r\n  \r\n}\r\n// File: security/AccessControl.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ncontract AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant NO_PERMISSION='no permission';\r\n    string constant INVALID_ADDRESS ='invalid address';\r\n    \r\n    /// @dev Administrator with highest authority. Should be a multisig wallet.\r\n    address payable superAdmin;\r\n\r\n    /// @dev Administrator of this contract.\r\n    address payable admin;\r\n\r\n    /// Sets the original admin and superAdmin of the contract to the sender account.\r\n    constructor(){\r\n        superAdmin=payable(msg.sender);\r\n        admin=payable(msg.sender);\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the superAdmin.\r\n    modifier onlySuperAdmin{\r\n        require(msg.sender==superAdmin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the admin.\r\n    modifier onlyAdmin{\r\n        require(msg.sender==admin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change superAdmin.\r\n    /// @param addr The address to transfer the right of superAdmin to.\r\n    function changeSuperAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        superAdmin=addr;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change admin.\r\n    /// @param addr The address to transfer the right of admin to.\r\n    function changeAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        admin=addr;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to withdraw balance.\r\n    function withdrawBalance(uint256 amount) external onlySuperAdmin{\r\n        superAdmin.transfer(amount);\r\n    }\r\n\r\n    fallback() external {}\r\n}\r\n// File: security/Pausable.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\ncontract Pausable is AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant PAUSED='paused';\r\n    string constant NOT_PAUSED='not paused';\r\n\r\n    /// @dev Keeps track whether the contract is paused. When this is true, most actions are blocked.\r\n    bool public paused = false;\r\n\r\n    /// @dev Modifier to allow actions only when the contract is not paused\r\n    modifier whenNotPaused {\r\n        require(!paused,PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract is paused\r\n    modifier whenPaused {\r\n        require(paused,NOT_PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to pause the contract. Used when something goes wrong\r\n    ///  and we need to limit damage.\r\n    function pause() external onlySuperAdmin whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the superAdmin.\r\n    function unpause() external onlySuperAdmin whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n// File: token/IERC20.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n\r\n    /// MUST trigger when tokens are transferred, including zero value transfers.\r\n    /// A token contract which creates new tokens SHOULD trigger a Transfer event with \r\n    ///  the _from address set to 0x0 when tokens are created.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /// MUST trigger on any successful call to approve(address _spender, uint256 _value).\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /// Returns the total token supply.\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// Returns the account balance of another account with address _owner.\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /// Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. \r\n    /// The function SHOULD throw if the message caller\u2019s account balance does not have enough tokens to spend.\r\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.\r\n    /// The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. \r\n    /// This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies. \r\n    /// The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism.\r\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// Allows _spender to withdraw from your account multiple times, up to the _value amount. \r\n    /// If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /// Returns the amount which _spender is still allowed to withdraw from _owner.\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n}\r\n// File: token/ERC20Implementation.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n/// @title Standard ERC20 token\r\n\r\ncontract ERC20Implementation is IERC20, Pausable {\r\n\r\n    mapping (address => uint256) _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) _allowed;\r\n\r\n    uint256 _totalSupply;\r\n\r\n    /// @dev Total number of tokens in existence\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner The address to query the balance of.\r\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    /// @dev Transfer token for a specified address\r\n    /// @param _to The address to transfer to.\r\n    /// @param _value The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public whenNotPaused override returns (bool success) {\r\n        require(_to != address(0),INVALID_ADDRESS);\r\n        _balances[msg.sender]-=_value;\r\n        _balances[_to]+=_value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another\r\n    /// @param _from address The address which you want to send tokens from\r\n    /// @param _to address The address which you want to transfer to\r\n    /// @param _value uint256 the amount of tokens to be transferred\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused override returns (bool success) {\r\n        require(_to != address(0),INVALID_ADDRESS);\r\n        _balances[_from]-=_value;\r\n        _balances[_to]+=_value;\r\n        _allowed[_from][msg.sender]-=_value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    /// @param _spender The address which will spend the funds.\r\n    /// @param _value The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public whenNotPaused override returns (bool success) {\r\n        require(_spender != address(0),INVALID_ADDRESS);\r\n        _allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    /// @param _owner The address which owns the funds.\r\n    /// @param _spender The address which will spend the funds.\r\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\r\n        return _allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    /// @param spender The address which will spend the funds.\r\n    /// @param addedValue The amount of tokens to increase the allowance by.\r\n    function increaseAllowance(address spender,uint256 addedValue) public whenNotPaused returns (bool) {\r\n        require(spender != address(0),INVALID_ADDRESS);\r\n        _allowed[msg.sender][spender]+=addedValue;\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    /// @param spender The address which will spend the funds.\r\n    /// @param subtractedValue The amount of tokens to decrease the allowance by.\r\n    function decreaseAllowance(address spender,uint256 subtractedValue) public whenNotPaused returns (bool) {\r\n        require(spender != address(0),INVALID_ADDRESS);\r\n        _allowed[msg.sender][spender]-=subtractedValue;\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Internal function that mints an amount of the token and assigns it to an account.\r\n    ///  This encapsulates the modification of balances such that the proper events are emitted.\r\n    /// @param account The account that will receive the created tokens.\r\n    /// @param amount The amount that will be created.\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0),INVALID_ADDRESS);\r\n        _totalSupply+=amount;\r\n        _balances[account]+=amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n}\r\n// File: CoinB.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ncontract CoinB is ERC20Implementation,ISpawnCoin {\r\n\r\n    address public SpawnContractAddress;\r\n\r\n    function name() public pure returns (string memory) {\r\n        return 'Crystal of Elements';\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return 'COE';\r\n    }\r\n\r\n    function setSpawnContractAddress(address addr) external override onlySuperAdmin {\r\n        require(addr!=address(0),INVALID_ADDRESS);\r\n        emit SpawnContractAddressChanged(SpawnContractAddress,addr,block.timestamp);\r\n        SpawnContractAddress=addr;\r\n    }\r\n\r\n    function spawnEgg(address addr,uint256 amount) external override whenNotPaused{\r\n        require(msg.sender==SpawnContractAddress,NO_PERMISSION);\r\n        _balances[addr]-=amount;\r\n        _totalSupply-=amount;\r\n        emit Transfer(addr,address(0),amount);\r\n    }\r\n\r\n    function burn(uint256 amount) external onlyAdmin{\r\n        _balances[admin]-=amount;\r\n        _totalSupply-=amount;\r\n        emit Transfer(admin, address(0), amount);\r\n    }\r\n    \r\n    /// @dev Used by admin to mint token.\r\n    function mint(address[] memory addr,uint256[] memory amount) external onlyAdmin {\r\n        require(addr.length==amount.length,'worng parameter');\r\n        for (uint256 i=0;i<addr.length;i++){\r\n            _mint(addr[i],amount[i]);\r\n        }\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SpawnContractAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"SpawnContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setSpawnContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"spawnEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CoinB", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e8d8489f0019d5719324d8c351ad9f349e763ddb1c8f189855f4d6df7df8f902"}