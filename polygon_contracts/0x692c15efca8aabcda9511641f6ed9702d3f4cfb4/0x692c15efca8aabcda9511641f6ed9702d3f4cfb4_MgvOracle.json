{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/periphery/MgvOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.10;\\n\\nimport \\\"mgv_src/MgvLib.sol\\\";\\n\\n/* The purpose of the Oracle contract is to act as a gas price and density\\n * oracle for Mangrove. It bridges to an external oracle, and allows\\n * a given sender to update the gas price and density which the oracle\\n * reports to Mangrove. */\\ncontract MgvOracle is IMgvMonitor {\\n  event SetGasprice(uint gasPrice);\\n  event SetDensity(uint density);\\n\\n  address governance;\\n  address mutator;\\n\\n  uint lastReceivedGasPrice;\\n  uint lastReceivedDensity;\\n\\n  constructor(address governance_, address initialMutator_, uint initialGasPrice_) {\\n    governance = governance_;\\n    mutator = initialMutator_;\\n\\n    lastReceivedGasPrice = initialGasPrice_;\\n    /* Set initial density from the MgvOracle to let Mangrove use its internal density by default.\\n\\n      Mangrove will reject densities from the Monitor that don't fit in 32 bits and use its internal density instead, so setting this contract's density to `type(uint).max` is a way to let Mangrove deal with density on its own. */\\n    lastReceivedDensity = type(uint).max;\\n  }\\n\\n  /* ## `authOnly` check */\\n  // NOTE: Should use standard auth method, instead of this copy from MgvGovernable\\n\\n  function authOnly() internal view {\\n    require(\\n      msg.sender == governance || msg.sender == address(this) || governance == address(0), \\\"MgvOracle/unauthorized\\\"\\n    );\\n  }\\n\\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker) external override {\\n    // Do nothing\\n  }\\n\\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker) external override {\\n    // Do nothing\\n  }\\n\\n  function setGovernance(address governance_) external {\\n    authOnly();\\n\\n    governance = governance_;\\n  }\\n\\n  function setMutator(address mutator_) external {\\n    authOnly();\\n\\n    mutator = mutator_;\\n  }\\n\\n  function setGasPrice(uint gasPrice) external {\\n    // governance or mutator are allowed to update the gasprice\\n    require(msg.sender == governance || msg.sender == mutator, \\\"MgvOracle/unauthorized\\\");\\n\\n    lastReceivedGasPrice = gasPrice;\\n    emit SetGasprice(gasPrice);\\n  }\\n\\n  function setDensity(uint density) external {\\n    // governance or mutator are allowed to update the density\\n    require(msg.sender == governance || msg.sender == mutator, \\\"MgvOracle/unauthorized\\\");\\n\\n    lastReceivedDensity = density;\\n    emit SetDensity(density);\\n  }\\n\\n  function read(address, /*outbound_tkn*/ address /*inbound_tkn*/ )\\n    external\\n    view\\n    override\\n    returns (uint gasprice, uint density)\\n  {\\n    return (lastReceivedGasPrice, lastReceivedDensity);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/MgvLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n\\n/* `MgvLib` contains data structures returned by external calls to Mangrove and the interfaces it uses for its own external calls. */\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./preprocessed/MgvStructs.post.sol\\\" as MgvStructs;\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/* # Structs\\nThe structs defined in `structs.js` have their counterpart as solidity structs that are easy to manipulate for outside contracts / callers of view functions. */\\n\\nlibrary MgvLib {\\n  /*\\n   Some miscellaneous data types useful to `Mangrove` and external contracts */\\n  //+clear+\\n\\n  /* `SingleOrder` holds data about an order-offer match in a struct. Used by `marketOrder` and `internalSnipes` (and some of their nested functions) to avoid stack too deep errors. */\\n  struct SingleOrder {\\n    address outbound_tkn;\\n    address inbound_tkn;\\n    uint offerId;\\n    MgvStructs.OfferPacked offer;\\n    /* `wants`/`gives` mutate over execution. Initially the `wants`/`gives` from the taker's pov, then actual `wants`/`gives` adjusted by offer's price and volume. */\\n    uint wants;\\n    uint gives;\\n    /* `offerDetail` is only populated when necessary. */\\n    MgvStructs.OfferDetailPacked offerDetail;\\n    MgvStructs.GlobalPacked global;\\n    MgvStructs.LocalPacked local;\\n  }\\n\\n  /* <a id=\\\"MgvLib/OrderResult\\\"></a> `OrderResult` holds additional data for the maker and is given to them _after_ they fulfilled an offer. It gives them their own returned data from the previous call, and an `mgvData` specifying whether Mangrove encountered an error. */\\n\\n  struct OrderResult {\\n    /* `makerdata` holds a message that was either returned by the maker or passed as revert message at the end of the trade execution*/\\n    bytes32 makerData;\\n    /* `mgvData` is an [internal Mangrove status code](#MgvOfferTaking/statusCodes) code. */\\n    bytes32 mgvData;\\n  }\\n}\\n\\n/* # Events\\nThe events emitted for use by bots are listed here: */\\ncontract HasMgvEvents {\\n  /* * Emitted at the creation of the new Mangrove contract on the pair (`inbound_tkn`, `outbound_tkn`)*/\\n  event NewMgv();\\n\\n  /* Mangrove adds or removes wei from `maker`'s account */\\n  /* * Credit event occurs when an offer is removed from Mangrove or when the `fund` function is called*/\\n  event Credit(address indexed maker, uint amount);\\n  /* * Debit event occurs when an offer is posted or when the `withdraw` function is called */\\n  event Debit(address indexed maker, uint amount);\\n\\n  /* * Mangrove reconfiguration */\\n  event SetActive(address indexed outbound_tkn, address indexed inbound_tkn, bool value);\\n  event SetFee(address indexed outbound_tkn, address indexed inbound_tkn, uint value);\\n  event SetGasbase(address indexed outbound_tkn, address indexed inbound_tkn, uint offer_gasbase);\\n  event SetGovernance(address value);\\n  event SetMonitor(address value);\\n  event SetUseOracle(bool value);\\n  event SetNotify(bool value);\\n  event SetGasmax(uint value);\\n  event SetDensity(address indexed outbound_tkn, address indexed inbound_tkn, uint value);\\n  event SetGasprice(uint value);\\n\\n  /* Market order execution */\\n  event OrderStart();\\n  event OrderComplete(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    address indexed taker,\\n    uint takerGot,\\n    uint takerGave,\\n    uint penalty,\\n    uint feePaid\\n  );\\n\\n  /* * Offer execution */\\n  event OfferSuccess(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint id,\\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\\n    address taker,\\n    uint takerWants,\\n    uint takerGives\\n  );\\n\\n  /* Log information when a trade execution reverts or returns a non empty bytes32 word */\\n  event OfferFail(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    uint id,\\n    // `maker` is not logged because it can be retrieved from the state using `(outbound_tkn,inbound_tkn,id)`.\\n    address taker,\\n    uint takerWants,\\n    uint takerGives,\\n    // `mgvData` may only be `\\\"mgv/makerRevert\\\"`, `\\\"mgv/makerTransferFail\\\"` or `\\\"mgv/makerReceiveFail\\\"`\\n    bytes32 mgvData\\n  );\\n\\n  /* Log information when a posthook reverts */\\n  event PosthookFail(address indexed outbound_tkn, address indexed inbound_tkn, uint offerId, bytes32 posthookData);\\n\\n  /* * After `permit` and `approve` */\\n  event Approval(address indexed outbound_tkn, address indexed inbound_tkn, address owner, address spender, uint value);\\n\\n  /* * Mangrove closure */\\n  event Kill();\\n\\n  /* * An offer was created or updated.\\n  A few words about why we include a `prev` field, and why we don't include a\\n  `next` field: in theory clients should need neither `prev` nor a `next` field.\\n  They could just 1. Read the order book state at a given block `b`.  2. On\\n  every event, update a local copy of the orderbook.  But in practice, we do not\\n  want to force clients to keep a copy of the *entire* orderbook. There may be a\\n  long tail of spam. Now if they only start with the first $N$ offers and\\n  receive a new offer that goes to the end of the book, they cannot tell if\\n  there are missing offers between the new offer and the end of the local copy\\n  of the book.\\n  \\n  So we add a prev pointer so clients with only a prefix of the book can receive\\n  out-of-prefix offers and know what to do with them. The `next` pointer is an\\n  optimization useful in Solidity (we traverse fewer memory locations) but\\n  useless in client code.\\n  */\\n  event OfferWrite(\\n    address indexed outbound_tkn,\\n    address indexed inbound_tkn,\\n    address maker,\\n    uint wants,\\n    uint gives,\\n    uint gasprice,\\n    uint gasreq,\\n    uint id,\\n    uint prev\\n  );\\n\\n  /* * `offerId` was present and is now removed from the book. */\\n  event OfferRetract(address indexed outbound_tkn, address indexed inbound_tkn, uint id, bool deprovision);\\n}\\n\\n/* # IMaker interface */\\ninterface IMaker {\\n  /* Called upon offer execution. \\n  - If the call throws, Mangrove will not try to transfer funds and the first 32 bytes of revert reason are passed to `makerPosthook`\u00a0as `makerData`\\n  - If the call returns normally, returndata is passed to `makerPosthook` as `makerData` and Mangrove will attempt to transfer the funds.\\n  */\\n  function makerExecute(MgvLib.SingleOrder calldata order) external returns (bytes32);\\n\\n  /* Called after all offers of an order have been executed. Posthook of the last executed order is called first and full reentrancy into Mangrove is enabled at this time. `order` recalls key arguments of the order that was processed and `result` recalls important information for updating the current offer. (see [above](#MgvLib/OrderResult))*/\\n  function makerPosthook(MgvLib.SingleOrder calldata order, MgvLib.OrderResult calldata result) external;\\n}\\n\\n/* # ITaker interface */\\ninterface ITaker {\\n  /* Inverted mangrove only: call to taker after loans went through */\\n  function takerTrade(\\n    address outbound_tkn,\\n    address inbound_tkn,\\n    // total amount of outbound_tkn token that was flashloaned to the taker\\n    uint totalGot,\\n    // total amount of inbound_tkn token that should be made available\\n    uint totalGives\\n  ) external;\\n}\\n\\n/* # Monitor interface\\nIf enabled, the monitor receives notification after each offer execution and is read for each pair's `gasprice` and `density`. */\\ninterface IMgvMonitor {\\n  function notifySuccess(MgvLib.SingleOrder calldata sor, address taker) external;\\n\\n  function notifyFail(MgvLib.SingleOrder calldata sor, address taker) external;\\n\\n  function read(address outbound_tkn, address inbound_tkn) external view returns (uint gasprice, uint density);\\n}\\n\"\r\n    },\r\n    \"src/preprocessed/MgvStructs.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n// Note: can't do Type.Unpacked because typechain mixes up multiple 'Unpacked' structs under different namespaces. So for consistency we don't do Type.Packed either. We do TypeUnpacked and TypePacked.\\n\\nimport {OfferPacked, OfferUnpacked} from \\\"./MgvOffer.post.sol\\\";\\nimport \\\"./MgvOffer.post.sol\\\" as Offer;\\nimport {OfferDetailPacked, OfferDetailUnpacked} from \\\"./MgvOfferDetail.post.sol\\\";\\nimport \\\"./MgvOfferDetail.post.sol\\\" as OfferDetail;\\nimport {GlobalPacked, GlobalUnpacked} from \\\"./MgvGlobal.post.sol\\\";\\nimport \\\"./MgvGlobal.post.sol\\\" as Global;\\nimport {LocalPacked, LocalUnpacked} from \\\"./MgvLocal.post.sol\\\";\\nimport \\\"./MgvLocal.post.sol\\\" as Local;\"\r\n    },\r\n    \"src/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.6.2;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address account) external view returns (uint);\\n\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n\\n  function symbol() external view returns (string memory);\\n\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function name() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/preprocessed/MgvOffer.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n// fields are of the form [name,bits,type]\\n\\n// struct_defs are of the form [name,obj]\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n/* since you can't convert bool to uint in an expression without conditionals,\\n * we add a file-level function and rely on compiler optimization\\n */\\nfunction uint_of_bool(bool b) pure returns (uint u) {\\n  assembly { u := b }\\n}\\n\\nstruct OfferUnpacked {\\n  uint prev;\\n  uint next;\\n  uint wants;\\n  uint gives;\\n}\\n\\n//some type safety for each struct\\ntype OfferPacked is uint;\\nusing Library for OfferPacked global;\\n\\nuint constant prev_bits  = 32;\\nuint constant next_bits  = 32;\\nuint constant wants_bits = 96;\\nuint constant gives_bits = 96;\\n\\nuint constant prev_before  = 0;\\nuint constant next_before  = prev_before  + prev_bits ;\\nuint constant wants_before = next_before  + next_bits ;\\nuint constant gives_before = wants_before + wants_bits;\\n\\nuint constant prev_mask  = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint constant next_mask  = 0xffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint constant wants_mask = 0xffffffffffffffff000000000000000000000000ffffffffffffffffffffffff;\\nuint constant gives_mask = 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000;\\n\\nlibrary Library {\\n  function to_struct(OfferPacked __packed) internal pure returns (OfferUnpacked memory __s) { unchecked {\\n    __s.prev = (OfferPacked.unwrap(__packed) << prev_before) >> (256-prev_bits);\\n    __s.next = (OfferPacked.unwrap(__packed) << next_before) >> (256-next_bits);\\n    __s.wants = (OfferPacked.unwrap(__packed) << wants_before) >> (256-wants_bits);\\n    __s.gives = (OfferPacked.unwrap(__packed) << gives_before) >> (256-gives_bits);\\n  }}\\n\\n  function eq(OfferPacked __packed1, OfferPacked __packed2) internal pure returns (bool) { unchecked {\\n    return OfferPacked.unwrap(__packed1) == OfferPacked.unwrap(__packed2);\\n  }}\\n\\n  function unpack(OfferPacked __packed) internal pure returns (uint __prev, uint __next, uint __wants, uint __gives) { unchecked {\\n    __prev = (OfferPacked.unwrap(__packed) << prev_before) >> (256-prev_bits);\\n    __next = (OfferPacked.unwrap(__packed) << next_before) >> (256-next_bits);\\n    __wants = (OfferPacked.unwrap(__packed) << wants_before) >> (256-wants_bits);\\n    __gives = (OfferPacked.unwrap(__packed) << gives_before) >> (256-gives_bits);\\n  }}\\n\\n  function prev(OfferPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferPacked.unwrap(__packed) << prev_before) >> (256-prev_bits);\\n  }}\\n  function prev(OfferPacked __packed,uint val) internal pure returns(OfferPacked) { unchecked {\\n    return OfferPacked.wrap((OfferPacked.unwrap(__packed) & prev_mask)\\n                                | ((val << (256-prev_bits) >> prev_before)));\\n  }}\\n  function next(OfferPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferPacked.unwrap(__packed) << next_before) >> (256-next_bits);\\n  }}\\n  function next(OfferPacked __packed,uint val) internal pure returns(OfferPacked) { unchecked {\\n    return OfferPacked.wrap((OfferPacked.unwrap(__packed) & next_mask)\\n                                | ((val << (256-next_bits) >> next_before)));\\n  }}\\n  function wants(OfferPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferPacked.unwrap(__packed) << wants_before) >> (256-wants_bits);\\n  }}\\n  function wants(OfferPacked __packed,uint val) internal pure returns(OfferPacked) { unchecked {\\n    return OfferPacked.wrap((OfferPacked.unwrap(__packed) & wants_mask)\\n                                | ((val << (256-wants_bits) >> wants_before)));\\n  }}\\n  function gives(OfferPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferPacked.unwrap(__packed) << gives_before) >> (256-gives_bits);\\n  }}\\n  function gives(OfferPacked __packed,uint val) internal pure returns(OfferPacked) { unchecked {\\n    return OfferPacked.wrap((OfferPacked.unwrap(__packed) & gives_mask)\\n                                | ((val << (256-gives_bits) >> gives_before)));\\n  }}\\n}\\n\\nfunction t_of_struct(OfferUnpacked memory __s) pure returns (OfferPacked) { unchecked {\\n  return pack(__s.prev, __s.next, __s.wants, __s.gives);\\n}}\\n\\nfunction pack(uint __prev, uint __next, uint __wants, uint __gives) pure returns (OfferPacked) { unchecked {\\n  return OfferPacked.wrap(((((0\\n                              | ((__prev << (256-prev_bits)) >> prev_before))\\n                              | ((__next << (256-next_bits)) >> next_before))\\n                              | ((__wants << (256-wants_bits)) >> wants_before))\\n                              | ((__gives << (256-gives_bits)) >> gives_before)));\\n}}\"\r\n    },\r\n    \"src/preprocessed/MgvOfferDetail.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n// fields are of the form [name,bits,type]\\n\\n// struct_defs are of the form [name,obj]\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n/* since you can't convert bool to uint in an expression without conditionals,\\n * we add a file-level function and rely on compiler optimization\\n */\\nfunction uint_of_bool(bool b) pure returns (uint u) {\\n  assembly { u := b }\\n}\\n\\nstruct OfferDetailUnpacked {\\n  address maker;\\n  uint gasreq;\\n  uint offer_gasbase;\\n  uint gasprice;\\n}\\n\\n//some type safety for each struct\\ntype OfferDetailPacked is uint;\\nusing Library for OfferDetailPacked global;\\n\\nuint constant maker_bits         = 160;\\nuint constant gasreq_bits        = 24;\\nuint constant offer_gasbase_bits = 24;\\nuint constant gasprice_bits      = 16;\\n\\nuint constant maker_before         = 0;\\nuint constant gasreq_before        = maker_before         + maker_bits        ;\\nuint constant offer_gasbase_before = gasreq_before        + gasreq_bits       ;\\nuint constant gasprice_before      = offer_gasbase_before + offer_gasbase_bits;\\n\\nuint constant maker_mask         = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\\nuint constant gasreq_mask        = 0xffffffffffffffffffffffffffffffffffffffff000000ffffffffffffffffff;\\nuint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffffff;\\nuint constant gasprice_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffff0000ffffffff;\\n\\nlibrary Library {\\n  function to_struct(OfferDetailPacked __packed) internal pure returns (OfferDetailUnpacked memory __s) { unchecked {\\n    __s.maker = address(uint160((OfferDetailPacked.unwrap(__packed) << maker_before) >> (256-maker_bits)));\\n    __s.gasreq = (OfferDetailPacked.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\\n    __s.offer_gasbase = (OfferDetailPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __s.gasprice = (OfferDetailPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n\\n  function eq(OfferDetailPacked __packed1, OfferDetailPacked __packed2) internal pure returns (bool) { unchecked {\\n    return OfferDetailPacked.unwrap(__packed1) == OfferDetailPacked.unwrap(__packed2);\\n  }}\\n\\n  function unpack(OfferDetailPacked __packed) internal pure returns (address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) { unchecked {\\n    __maker = address(uint160((OfferDetailPacked.unwrap(__packed) << maker_before) >> (256-maker_bits)));\\n    __gasreq = (OfferDetailPacked.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\\n    __offer_gasbase = (OfferDetailPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __gasprice = (OfferDetailPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n\\n  function maker(OfferDetailPacked __packed) internal pure returns(address) { unchecked {\\n    return address(uint160((OfferDetailPacked.unwrap(__packed) << maker_before) >> (256-maker_bits)));\\n  }}\\n  function maker(OfferDetailPacked __packed,address val) internal pure returns(OfferDetailPacked) { unchecked {\\n    return OfferDetailPacked.wrap((OfferDetailPacked.unwrap(__packed) & maker_mask)\\n                                | ((uint(uint160(val)) << (256-maker_bits) >> maker_before)));\\n  }}\\n  function gasreq(OfferDetailPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferDetailPacked.unwrap(__packed) << gasreq_before) >> (256-gasreq_bits);\\n  }}\\n  function gasreq(OfferDetailPacked __packed,uint val) internal pure returns(OfferDetailPacked) { unchecked {\\n    return OfferDetailPacked.wrap((OfferDetailPacked.unwrap(__packed) & gasreq_mask)\\n                                | ((val << (256-gasreq_bits) >> gasreq_before)));\\n  }}\\n  function offer_gasbase(OfferDetailPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferDetailPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n  }}\\n  function offer_gasbase(OfferDetailPacked __packed,uint val) internal pure returns(OfferDetailPacked) { unchecked {\\n    return OfferDetailPacked.wrap((OfferDetailPacked.unwrap(__packed) & offer_gasbase_mask)\\n                                | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\\n  }}\\n  function gasprice(OfferDetailPacked __packed) internal pure returns(uint) { unchecked {\\n    return (OfferDetailPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n  function gasprice(OfferDetailPacked __packed,uint val) internal pure returns(OfferDetailPacked) { unchecked {\\n    return OfferDetailPacked.wrap((OfferDetailPacked.unwrap(__packed) & gasprice_mask)\\n                                | ((val << (256-gasprice_bits) >> gasprice_before)));\\n  }}\\n}\\n\\nfunction t_of_struct(OfferDetailUnpacked memory __s) pure returns (OfferDetailPacked) { unchecked {\\n  return pack(__s.maker, __s.gasreq, __s.offer_gasbase, __s.gasprice);\\n}}\\n\\nfunction pack(address __maker, uint __gasreq, uint __offer_gasbase, uint __gasprice) pure returns (OfferDetailPacked) { unchecked {\\n  return OfferDetailPacked.wrap(((((0\\n                              | ((uint(uint160(__maker)) << (256-maker_bits)) >> maker_before))\\n                              | ((__gasreq << (256-gasreq_bits)) >> gasreq_before))\\n                              | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\\n                              | ((__gasprice << (256-gasprice_bits)) >> gasprice_before)));\\n}}\"\r\n    },\r\n    \"src/preprocessed/MgvGlobal.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n// fields are of the form [name,bits,type]\\n\\n// struct_defs are of the form [name,obj]\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n/* since you can't convert bool to uint in an expression without conditionals,\\n * we add a file-level function and rely on compiler optimization\\n */\\nfunction uint_of_bool(bool b) pure returns (uint u) {\\n  assembly { u := b }\\n}\\n\\nstruct GlobalUnpacked {\\n  address monitor;\\n  bool useOracle;\\n  bool notify;\\n  uint gasprice;\\n  uint gasmax;\\n  bool dead;\\n}\\n\\n//some type safety for each struct\\ntype GlobalPacked is uint;\\nusing Library for GlobalPacked global;\\n\\nuint constant monitor_bits   = 160;\\nuint constant useOracle_bits = 8;\\nuint constant notify_bits    = 8;\\nuint constant gasprice_bits  = 16;\\nuint constant gasmax_bits    = 24;\\nuint constant dead_bits      = 8;\\n\\nuint constant monitor_before   = 0;\\nuint constant useOracle_before = monitor_before   + monitor_bits  ;\\nuint constant notify_before    = useOracle_before + useOracle_bits;\\nuint constant gasprice_before  = notify_before    + notify_bits   ;\\nuint constant gasmax_before    = gasprice_before  + gasprice_bits ;\\nuint constant dead_before      = gasmax_before    + gasmax_bits   ;\\n\\nuint constant monitor_mask   = 0x0000000000000000000000000000000000000000ffffffffffffffffffffffff;\\nuint constant useOracle_mask = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\\nuint constant notify_mask    = 0xffffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffff;\\nuint constant gasprice_mask  = 0xffffffffffffffffffffffffffffffffffffffffffff0000ffffffffffffffff;\\nuint constant gasmax_mask    = 0xffffffffffffffffffffffffffffffffffffffffffffffff000000ffffffffff;\\nuint constant dead_mask      = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff00ffffffff;\\n\\nlibrary Library {\\n  function to_struct(GlobalPacked __packed) internal pure returns (GlobalUnpacked memory __s) { unchecked {\\n    __s.monitor = address(uint160((GlobalPacked.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\\n    __s.useOracle = (((GlobalPacked.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\\n    __s.notify = (((GlobalPacked.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\\n    __s.gasprice = (GlobalPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n    __s.gasmax = (GlobalPacked.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\\n    __s.dead = (((GlobalPacked.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\\n  }}\\n\\n  function eq(GlobalPacked __packed1, GlobalPacked __packed2) internal pure returns (bool) { unchecked {\\n    return GlobalPacked.unwrap(__packed1) == GlobalPacked.unwrap(__packed2);\\n  }}\\n\\n  function unpack(GlobalPacked __packed) internal pure returns (address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) { unchecked {\\n    __monitor = address(uint160((GlobalPacked.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\\n    __useOracle = (((GlobalPacked.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\\n    __notify = (((GlobalPacked.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\\n    __gasprice = (GlobalPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n    __gasmax = (GlobalPacked.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\\n    __dead = (((GlobalPacked.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\\n  }}\\n\\n  function monitor(GlobalPacked __packed) internal pure returns(address) { unchecked {\\n    return address(uint160((GlobalPacked.unwrap(__packed) << monitor_before) >> (256-monitor_bits)));\\n  }}\\n  function monitor(GlobalPacked __packed,address val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & monitor_mask)\\n                                | ((uint(uint160(val)) << (256-monitor_bits) >> monitor_before)));\\n  }}\\n  function useOracle(GlobalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((GlobalPacked.unwrap(__packed) << useOracle_before) >> (256-useOracle_bits)) > 0);\\n  }}\\n  function useOracle(GlobalPacked __packed,bool val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & useOracle_mask)\\n                                | ((uint_of_bool(val) << (256-useOracle_bits) >> useOracle_before)));\\n  }}\\n  function notify(GlobalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((GlobalPacked.unwrap(__packed) << notify_before) >> (256-notify_bits)) > 0);\\n  }}\\n  function notify(GlobalPacked __packed,bool val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & notify_mask)\\n                                | ((uint_of_bool(val) << (256-notify_bits) >> notify_before)));\\n  }}\\n  function gasprice(GlobalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (GlobalPacked.unwrap(__packed) << gasprice_before) >> (256-gasprice_bits);\\n  }}\\n  function gasprice(GlobalPacked __packed,uint val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & gasprice_mask)\\n                                | ((val << (256-gasprice_bits) >> gasprice_before)));\\n  }}\\n  function gasmax(GlobalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (GlobalPacked.unwrap(__packed) << gasmax_before) >> (256-gasmax_bits);\\n  }}\\n  function gasmax(GlobalPacked __packed,uint val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & gasmax_mask)\\n                                | ((val << (256-gasmax_bits) >> gasmax_before)));\\n  }}\\n  function dead(GlobalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((GlobalPacked.unwrap(__packed) << dead_before) >> (256-dead_bits)) > 0);\\n  }}\\n  function dead(GlobalPacked __packed,bool val) internal pure returns(GlobalPacked) { unchecked {\\n    return GlobalPacked.wrap((GlobalPacked.unwrap(__packed) & dead_mask)\\n                                | ((uint_of_bool(val) << (256-dead_bits) >> dead_before)));\\n  }}\\n}\\n\\nfunction t_of_struct(GlobalUnpacked memory __s) pure returns (GlobalPacked) { unchecked {\\n  return pack(__s.monitor, __s.useOracle, __s.notify, __s.gasprice, __s.gasmax, __s.dead);\\n}}\\n\\nfunction pack(address __monitor, bool __useOracle, bool __notify, uint __gasprice, uint __gasmax, bool __dead) pure returns (GlobalPacked) { unchecked {\\n  return GlobalPacked.wrap(((((((0\\n                              | ((uint(uint160(__monitor)) << (256-monitor_bits)) >> monitor_before))\\n                              | ((uint_of_bool(__useOracle) << (256-useOracle_bits)) >> useOracle_before))\\n                              | ((uint_of_bool(__notify) << (256-notify_bits)) >> notify_before))\\n                              | ((__gasprice << (256-gasprice_bits)) >> gasprice_before))\\n                              | ((__gasmax << (256-gasmax_bits)) >> gasmax_before))\\n                              | ((uint_of_bool(__dead) << (256-dead_bits)) >> dead_before)));\\n}}\"\r\n    },\r\n    \"src/preprocessed/MgvLocal.post.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// SPDX-License-Identifier: Unlicense\\n\\n// fields are of the form [name,bits,type]\\n\\n// struct_defs are of the form [name,obj]\\n\\n/* ************************************************** *\\n            GENERATED FILE. DO NOT EDIT.\\n * ************************************************** */\\n\\n/* since you can't convert bool to uint in an expression without conditionals,\\n * we add a file-level function and rely on compiler optimization\\n */\\nfunction uint_of_bool(bool b) pure returns (uint u) {\\n  assembly { u := b }\\n}\\n\\nstruct LocalUnpacked {\\n  bool active;\\n  uint fee;\\n  uint density;\\n  uint offer_gasbase;\\n  bool lock;\\n  uint best;\\n  uint last;\\n}\\n\\n//some type safety for each struct\\ntype LocalPacked is uint;\\nusing Library for LocalPacked global;\\n\\nuint constant active_bits        = 8;\\nuint constant fee_bits           = 16;\\nuint constant density_bits       = 112;\\nuint constant offer_gasbase_bits = 24;\\nuint constant lock_bits          = 8;\\nuint constant best_bits          = 32;\\nuint constant last_bits          = 32;\\n\\nuint constant active_before        = 0;\\nuint constant fee_before           = active_before        + active_bits       ;\\nuint constant density_before       = fee_before           + fee_bits          ;\\nuint constant offer_gasbase_before = density_before       + density_bits      ;\\nuint constant lock_before          = offer_gasbase_before + offer_gasbase_bits;\\nuint constant best_before          = lock_before          + lock_bits         ;\\nuint constant last_before          = best_before          + best_bits         ;\\n\\nuint constant active_mask        = 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint constant fee_mask           = 0xff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\nuint constant density_mask       = 0xffffff0000000000000000000000000000ffffffffffffffffffffffffffffff;\\nuint constant offer_gasbase_mask = 0xffffffffffffffffffffffffffffffffff000000ffffffffffffffffffffffff;\\nuint constant lock_mask          = 0xffffffffffffffffffffffffffffffffffffffff00ffffffffffffffffffffff;\\nuint constant best_mask          = 0xffffffffffffffffffffffffffffffffffffffffff00000000ffffffffffffff;\\nuint constant last_mask          = 0xffffffffffffffffffffffffffffffffffffffffffffffffff00000000ffffff;\\n\\nlibrary Library {\\n  function to_struct(LocalPacked __packed) internal pure returns (LocalUnpacked memory __s) { unchecked {\\n    __s.active = (((LocalPacked.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\\n    __s.fee = (LocalPacked.unwrap(__packed) << fee_before) >> (256-fee_bits);\\n    __s.density = (LocalPacked.unwrap(__packed) << density_before) >> (256-density_bits);\\n    __s.offer_gasbase = (LocalPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __s.lock = (((LocalPacked.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\\n    __s.best = (LocalPacked.unwrap(__packed) << best_before) >> (256-best_bits);\\n    __s.last = (LocalPacked.unwrap(__packed) << last_before) >> (256-last_bits);\\n  }}\\n\\n  function eq(LocalPacked __packed1, LocalPacked __packed2) internal pure returns (bool) { unchecked {\\n    return LocalPacked.unwrap(__packed1) == LocalPacked.unwrap(__packed2);\\n  }}\\n\\n  function unpack(LocalPacked __packed) internal pure returns (bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) { unchecked {\\n    __active = (((LocalPacked.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\\n    __fee = (LocalPacked.unwrap(__packed) << fee_before) >> (256-fee_bits);\\n    __density = (LocalPacked.unwrap(__packed) << density_before) >> (256-density_bits);\\n    __offer_gasbase = (LocalPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n    __lock = (((LocalPacked.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\\n    __best = (LocalPacked.unwrap(__packed) << best_before) >> (256-best_bits);\\n    __last = (LocalPacked.unwrap(__packed) << last_before) >> (256-last_bits);\\n  }}\\n\\n  function active(LocalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((LocalPacked.unwrap(__packed) << active_before) >> (256-active_bits)) > 0);\\n  }}\\n  function active(LocalPacked __packed,bool val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & active_mask)\\n                                | ((uint_of_bool(val) << (256-active_bits) >> active_before)));\\n  }}\\n  function fee(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << fee_before) >> (256-fee_bits);\\n  }}\\n  function fee(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & fee_mask)\\n                                | ((val << (256-fee_bits) >> fee_before)));\\n  }}\\n  function density(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << density_before) >> (256-density_bits);\\n  }}\\n  function density(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & density_mask)\\n                                | ((val << (256-density_bits) >> density_before)));\\n  }}\\n  function offer_gasbase(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << offer_gasbase_before) >> (256-offer_gasbase_bits);\\n  }}\\n  function offer_gasbase(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & offer_gasbase_mask)\\n                                | ((val << (256-offer_gasbase_bits) >> offer_gasbase_before)));\\n  }}\\n  function lock(LocalPacked __packed) internal pure returns(bool) { unchecked {\\n    return (((LocalPacked.unwrap(__packed) << lock_before) >> (256-lock_bits)) > 0);\\n  }}\\n  function lock(LocalPacked __packed,bool val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & lock_mask)\\n                                | ((uint_of_bool(val) << (256-lock_bits) >> lock_before)));\\n  }}\\n  function best(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << best_before) >> (256-best_bits);\\n  }}\\n  function best(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & best_mask)\\n                                | ((val << (256-best_bits) >> best_before)));\\n  }}\\n  function last(LocalPacked __packed) internal pure returns(uint) { unchecked {\\n    return (LocalPacked.unwrap(__packed) << last_before) >> (256-last_bits);\\n  }}\\n  function last(LocalPacked __packed,uint val) internal pure returns(LocalPacked) { unchecked {\\n    return LocalPacked.wrap((LocalPacked.unwrap(__packed) & last_mask)\\n                                | ((val << (256-last_bits) >> last_before)));\\n  }}\\n}\\n\\nfunction t_of_struct(LocalUnpacked memory __s) pure returns (LocalPacked) { unchecked {\\n  return pack(__s.active, __s.fee, __s.density, __s.offer_gasbase, __s.lock, __s.best, __s.last);\\n}}\\n\\nfunction pack(bool __active, uint __fee, uint __density, uint __offer_gasbase, bool __lock, uint __best, uint __last) pure returns (LocalPacked) { unchecked {\\n  return LocalPacked.wrap((((((((0\\n                              | ((uint_of_bool(__active) << (256-active_bits)) >> active_before))\\n                              | ((__fee << (256-fee_bits)) >> fee_before))\\n                              | ((__density << (256-density_bits)) >> density_before))\\n                              | ((__offer_gasbase << (256-offer_gasbase_bits)) >> offer_gasbase_before))\\n                              | ((uint_of_bool(__lock) << (256-lock_bits)) >> lock_before))\\n                              | ((__best << (256-best_bits)) >> best_before))\\n                              | ((__last << (256-last_bits)) >> last_before)));\\n}}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"kandel/=lib/kandel/\",\r\n      \"mgv_lib/=lib/\",\r\n      \"mgv_script/=script/\",\r\n      \"mgv_src/=src/\",\r\n      \"mgv_test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialMutator_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialGasPrice_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"density\",\"type\":\"uint256\"}],\"name\":\"SetDensity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"SetGasprice\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"OfferPacked\",\"name\":\"offer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"OfferDetailPacked\",\"name\":\"offerDetail\",\"type\":\"uint256\"},{\"internalType\":\"GlobalPacked\",\"name\":\"global\",\"type\":\"uint256\"},{\"internalType\":\"LocalPacked\",\"name\":\"local\",\"type\":\"uint256\"}],\"internalType\":\"struct MgvLib.SingleOrder\",\"name\":\"sor\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"notifyFail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"outbound_tkn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inbound_tkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"internalType\":\"OfferPacked\",\"name\":\"offer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wants\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gives\",\"type\":\"uint256\"},{\"internalType\":\"OfferDetailPacked\",\"name\":\"offerDetail\",\"type\":\"uint256\"},{\"internalType\":\"GlobalPacked\",\"name\":\"global\",\"type\":\"uint256\"},{\"internalType\":\"LocalPacked\",\"name\":\"local\",\"type\":\"uint256\"}],\"internalType\":\"struct MgvLib.SingleOrder\",\"name\":\"sor\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"}],\"name\":\"notifySuccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"read\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"density\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"density\",\"type\":\"uint256\"}],\"name\":\"setDensity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mutator_\",\"type\":\"address\"}],\"name\":\"setMutator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MgvOracle", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "00000000000000000000000059a424169526ecae25856038598f862043dcedf700000000000000000000000010b124da45bc440171664cee59aafa23979c96160000000000000000000000000000000000000000000000000000000000000082", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}