{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n    @author The Calystral Team\r\n    @title The Fame' Interface\r\n*/\r\ninterface IFame {\r\n    /* ========== EVENTS ========== */\r\n    /**\r\n        @dev MUST emit when crates are staked.\r\n        The `from` argument MUST be the owner of the crates.\r\n        The `beneficiary` argument MUST be befeniciary of the owner.\r\n        The `baseAmount` argument MUST be the amount of base set crates staked.\r\n        The `transcendentAmount` argument MUST be the amount of transcendent set crates staked.\r\n    */\r\n    event Staked(\r\n        address indexed from,\r\n        address indexed beneficiary,\r\n        uint256 baseAmount,\r\n        uint256 transcendentAmount\r\n    );\r\n    /**\r\n        @dev MUST emit when crates are staked.\r\n        The `from` argument MUST be the owner of the crates.\r\n        The `beneficiary` argument MUST be befeniciary of the owner.\r\n        The `baseAmount` argument MUST be the amount of base set crates staked.\r\n        The `transcendentAmount` argument MUST be the amount of transcendent set crates staked.\r\n    */\r\n    event Withdrawn(\r\n        address indexed owner,\r\n        uint256 baseAmount,\r\n        uint256 transcendentAmount\r\n    );\r\n    /**\r\n        @dev MUST emit when alpha fame rewards are updated.\r\n        The `rewards` argument MUST be the amount of alpha fame reward since the last update.\r\n        The `totalAlphaFameRewarded` argument MUST be the total amount of alpha fame reward.\r\n    */\r\n    event FameRewarded(uint256 rewards, uint256 totalAlphaFameRewarded);\r\n    /**\r\n        @dev MUST emit when a user spent alpha fame.\r\n        The `user` argument MUST be the user who spent alpha fame.\r\n        The `amount` argument MUST be the amount of spent alpha fame.\r\n    */\r\n    event FameSpent(address indexed user, uint256 amount);\r\n    /**\r\n        @dev MUST emit when a beneficiary receives more stake points.\r\n        The `beneficiary` argument MUST be the beneficiary who receives stake points.\r\n        The `amount` argument MUST be the amoun of stake points reveceived.\r\n    */\r\n    event StakePointsAdded(address indexed beneficiary, uint256 amount);\r\n    /**\r\n        @dev MUST emit when a beneficiary removes more stake points.\r\n        The `beneficiary` argument MUST be the beneficiary who removes stake points.\r\n        The `amount` argument MUST be the amoun of stake points removed.\r\n    */\r\n    event StakePointsRemoved(address indexed beneficiary, uint256 amount);\r\n    /**\r\n        @dev MUST emit when the weekly reward is updated.\r\n        The `value` argument MUST be the new weekly reward value.\r\n    */\r\n    event WeeklyRewardUpdated(uint256 value);\r\n    /**\r\n        @dev MUST emit when the block time is updated.\r\n        The `milliseconds` argument MUST be the new block time in milliseconds.\r\n    */\r\n    event BlockTimeUpdated(uint256 milliseconds);\r\n    /**\r\n        @dev MUST emit when the fame per block is updated.\r\n        The `famePerBlock` argument MUST be the new fame per block.\r\n    */\r\n    event FamePerBlockUpdated(uint256 famePerBlock);\r\n\r\n    /* ========== EXTERNAL FUNCTIONS ========== */\r\n    /**\r\n        @notice SOULD NOT accept single transfer assets.\r\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\r\n        This function SHOULD reject any transfer and MUST result in the transaction being reverted by the caller.\r\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\r\n        @param _from      The address which previously owned the token\r\n        @param _id        The ID of the token being transferred\r\n        @param _value     The amount of tokens being transferred\r\n        @param _data      Additional data with no specified format\r\n        @return           `bytes4(keccak256(\"false\"))`\r\n    */\r\n    function onERC1155Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @notice Handle the receipt of multiple ERC1155 token types.\r\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\r\n        This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\r\n        This function MUST revert if it rejects the transfer(s).\r\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n        Reverts if the user sets a new beneficary while holding stakes.\r\n        Reverts if _data does not cointain a valid address as the beneficiary.\r\n        Reverts if nothing is staked.\r\n        Reverts if anything else than base set or transcendent set from the original Assets contract are staked.\r\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param _from      The address which previously owned the token\r\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\r\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\r\n        @param _data      Additional data with no specified format\r\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address _operator,\r\n        address _from,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _values,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @notice Withdraw a specified amount of crates.\r\n        @dev Withdraw a specified amount of crates.\r\n        @param baseAmount           The amount of base set crates\r\n        @param transcendentAmount   The amount of transcendent set crates\r\n        Reverts if there is nothing to withdraw.\r\n    */\r\n    function withdraw(uint256 baseAmount, uint256 transcendentAmount) external;\r\n\r\n    /**\r\n        @notice Withdraw all staked crates.\r\n        @dev Withdraw all crates.\r\n        Reverts if there is nothing to withdraw.\r\n    */\r\n    function withdrawAll() external;\r\n\r\n    /**\r\n        @notice Withdraw a specified amount of crates.\r\n        @dev Withdraw a specified amount of crates.\r\n        Uses Meta Transactions - transactions are signed by the owner but are executed by anybody.\r\n        Reverts if the signature is invalid.\r\n        Reverts if the transaction expired.\r\n        Reverts if the transaction was executed already.\r\n        Reverts if there is nothing to withdraw.\r\n        Emits the `TransferBatch` event where the `to` argument is the original owner address.\r\n        @param signature    The signature of the signing account as proof for execution allowance\r\n        @param signer       The signing account. This SHOULD be the owner of the assets\r\n        @param nonce        Each sent meta transaction includes a nonce to prevent that a signed transaction is executed multiple times\r\n        @param maxTimestamp The maximum point in time before the meta transaction expired, thus becoming invalid\r\n    */\r\n    function metaWithdraw(\r\n        bytes memory signature,\r\n        address signer,\r\n        uint256 baseAmount,\r\n        uint256 transcendentAmount,\r\n        uint256 nonce,\r\n        uint256 maxTimestamp\r\n    ) external;\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n    /**\r\n        @notice Get the burn nonce of a specific user.\r\n        @dev    Get the burn nonce of a specific user / signer.\r\n        @param  signer The requested signer\r\n        @return The burn nonce of a specific user\r\n    */\r\n    function getMetaNonce(address signer) external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the amount of alpha fame rewarded per stake point.\r\n        @dev    Get the amount of alpha fame rewarded per stake point. This value can only increase ever.\r\n        @return The amount of alpha fame rewarded per stake point\r\n    */\r\n    function calculatedAlphaFamePerStakePoint() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the current alpha fame balance of a user.\r\n        @dev    Get the current alpha fame balance of a user.\r\n        @param  userAddress address of the user\r\n        @return The current alpha fame balance of a user\r\n    */\r\n    function calculatedAlphaFameBalance(address userAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Get the block time.\r\n        @dev    Get the block time. This value is set by the admin and does not reflect the actual block time of the blockchain.\r\n        @return The block time\r\n    */\r\n    function getBlockTime() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the weekly alpha fame reward.\r\n        @dev    Get the weekly alpha fame reward.\r\n        @return The weekly alpha fame reward\r\n    */\r\n    function getWeeklyReward() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the last update block.\r\n        @dev    Get the last update block.\r\n        @return The last update block\r\n    */\r\n    function getLastUpdateBlock() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the alpha fame reward per block.\r\n        @dev    Get the alpha fame reward per block.\r\n        @return The alpha fame reward per block\r\n    */\r\n    function getFamePerBlock() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the staked base set crates of a user.\r\n        @dev    Get the staked base set crates of a user.\r\n        @param  owner address of the owner\r\n        @return The staked base set crates of a user\r\n    */\r\n    function getStakedBaseBalance(address owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Get the staked transcendent set crates of a user.\r\n        @dev    Get the staked transcendent set crates of a user.\r\n        @param  owner address of the owner\r\n        @return The staked transcendent set crates of a user\r\n    */\r\n    function getStakedTranscendentBalance(address owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Get the beneficiary of a user.\r\n        @dev    Get the beneficiary of a user.\r\n        @param  owner address of the owner\r\n        @return The beneficiary of a user\r\n    */\r\n    function getBeneficiary(address owner) external view returns (address);\r\n\r\n    /**\r\n        @notice Get the stake points total supply.\r\n        @dev    Get the stake points total supply.\r\n        @return The stake points total supply\r\n    */\r\n    function getStakePointsTotalSupply() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the stake points balance of a user.\r\n        @dev    Get the stake points balance of a user.\r\n        @param  userAddress address of the user\r\n        @return The stake points balance of a user\r\n    */\r\n    function getStakePointsBalance(address userAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Get the total amount of rewarded alpha fame.\r\n        @dev    Get the total amount of rewarded alpha fame.\r\n        @return The total amount of rewarded alpha fame\r\n    */\r\n    function getTotalAlphaFameRewarded() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the total amount of spent alpha fame.\r\n        @dev    Get the total amount of spent alpha fame.\r\n        @return The total amount of spent alpha fame\r\n    */\r\n    function getTotalAlphaFameSpent() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the amount of alpha fame a user has in his/her vault.\r\n        @dev    Get the amount of alpha fame a user has in his/her vault.\r\n        @param  userAddress address of the user\r\n        @return The amount of alpha fame a user has in his/her vault\r\n    */\r\n    function getAlphaFameVault(address userAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Get the alpha fame debit of a user.\r\n        @dev    Get the alpha fame debit of a user.\r\n        @param  userAddress address of the user\r\n        @return The alpha fame debit of a user\r\n    */\r\n    function getAlphaFameDebit(address userAddress)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n    /**\r\n        @notice Spend alpha fame.\r\n        @dev    Spend alpha fame.\r\n        Reverts if spending amount is 0.\r\n        Reverts if user doesn't have enough alpha fame.\r\n        @param  from address of the user\r\n        @param  amount amount to spend\r\n    */\r\n    function spendAlphaFame(address from, uint256 amount) external;\r\n\r\n    /**\r\n        @notice Set a new value for the weekly reward.\r\n        @dev    Set a new value for the weekly reward.\r\n        Reverts if value is smaller than 1e18 (as decimals).\r\n        @param  value new weekly reward value\r\n    */\r\n    function setWeeklyReward(uint256 value) external;\r\n\r\n    /**\r\n        @notice Set a new millisecond value for the block time.\r\n        @dev    Set a new millisecond value for the block time.\r\n        Reverts if block time is set to 0.\r\n        @param  milliseconds new millisecond value\r\n    */\r\n    function setBlockTime(uint256 milliseconds) external;\r\n}\r\n\r\n/**\r\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\r\n*/\r\ninterface IERC1155TokenReceiver {\r\n    /**\r\n        @notice Handle the receipt of a single ERC1155 token type.\r\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\r\n        This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\r\n        This function MUST revert if it rejects the transfer.\r\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\r\n        @param _from      The address which previously owned the token\r\n        @param _id        The ID of the token being transferred\r\n        @param _value     The amount of tokens being transferred\r\n        @param _data      Additional data with no specified format\r\n        @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n    */\r\n    function onERC1155Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @notice Handle the receipt of multiple ERC1155 token types.\r\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\r\n        This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\r\n        This function MUST revert if it rejects the transfer(s).\r\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param _from      The address which previously owned the token\r\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\r\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\r\n        @param _data      Additional data with no specified format\r\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address _operator,\r\n        address _from,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _values,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n    @author The Calystral Team\r\n    @title The RegistrableContractState's Interface\r\n*/\r\ninterface IRegistrableContractState is IERC165 {\r\n    /*==============================\r\n    =           EVENTS             =\r\n    ==============================*/\r\n    /// @dev MUST emit when the contract is set to an active state.\r\n    event Activated();\r\n    /// @dev MUST emit when the contract is set to an inactive state.\r\n    event Inactivated();\r\n\r\n    /*==============================\r\n    =          FUNCTIONS           =\r\n    ==============================*/\r\n    /**\r\n        @notice Sets the contract state to active.\r\n        @dev Sets the contract state to active.\r\n    */\r\n    function setActive() external;\r\n\r\n    /**\r\n        @notice Sets the contract state to inactive.\r\n        @dev Sets the contract state to inactive.\r\n    */\r\n    function setInactive() external;\r\n\r\n    /**\r\n        @dev Sets the registry contract object.\r\n        Reverts if the registryAddress doesn't implement the IRegistry interface.\r\n        @param registryAddress The registry address\r\n    */\r\n    function setRegistry(address registryAddress) external;\r\n\r\n    /**\r\n        @notice Returns the current contract state.\r\n        @dev Returns the current contract state.\r\n        @return The current contract state (true == active; false == inactive)\r\n    */\r\n    function getIsActive() external view returns (bool);\r\n\r\n    /**\r\n        @notice Returns the Registry address.\r\n        @dev Returns the Registry address.\r\n        @return The Registry address\r\n    */\r\n    function getRegistryAddress() external view returns (address);\r\n\r\n    /**\r\n        @notice Returns the current address associated with `key` identifier.\r\n        @dev Look-up in the Registry.\r\n        Returns the current address associated with `key` identifier.\r\n        @return The key identifier\r\n    */\r\n    function getContractAddress(uint256 key) external view returns (address);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor() {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n/**\r\n    @author The Calystral Team\r\n    @title The Registry's Interface\r\n*/\r\ninterface IRegistry is IRegistrableContractState {\r\n    /*==============================\r\n    =           EVENTS             =\r\n    ==============================*/\r\n    /**\r\n        @dev MUST emit when an entry in the Registry is set or updated.\r\n        The `key` argument MUST be the key of the entry which is set or updated.\r\n        The `value` argument MUST be the address of the entry which is set or updated.\r\n    */\r\n    event EntrySet(uint256 indexed key, address value);\r\n    /**\r\n        @dev MUST emit when an entry in the Registry is removed.\r\n        The `key` argument MUST be the key of the entry which is removed.\r\n        The `value` argument MUST be the address of the entry which is removed.\r\n    */\r\n    event EntryRemoved(uint256 indexed key, address value);\r\n\r\n    /*==============================\r\n    =          FUNCTIONS           =\r\n    ==============================*/\r\n    /**\r\n        @notice Sets the MultiSigAdmin contract as Registry entry 1.\r\n        @dev Sets the MultiSigAdmin contract as Registry entry 1.\r\n        @param msaAddress The contract address of the MultiSigAdmin\r\n    */\r\n    function initializeMultiSigAdmin(address msaAddress) external;\r\n\r\n    /**\r\n        @notice Checks if the registry Map contains the key.\r\n        @dev Returns true if the key is in the registry map. O(1).\r\n        @param key  The key to search for\r\n        @return     The boolean result\r\n    */\r\n    function contains(uint256 key) external view returns (bool);\r\n\r\n    /**\r\n        @notice Returns the registry map length.\r\n        @dev Returns the number of key-value pairs in the registry map. O(1).\r\n        @return     The registry map length\r\n    */\r\n    function length() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Returns the key-value pair stored at position `index` in the registry map.\r\n        @dev Returns the key-value pair stored at position `index` in the registry map. O(1).\r\n        Note that there are no guarantees on the ordering of entries inside the\r\n        array, and it may change when more entries are added or removed.\r\n        Requirements:\r\n        - `index` must be strictly less than {length}.\r\n        @param index    The position in the registry map\r\n        @return         The key-value pair as a tuple\r\n    */\r\n    function at(uint256 index) external view returns (uint256, address);\r\n\r\n    /**\r\n        @notice Tries to return the value associated with `key`.\r\n        @dev Tries to return the value associated with `key`.  O(1).\r\n        Does not revert if `key` is not in the registry map.\r\n        @param key    The key to search for\r\n        @return       The key-value pair as a tuple\r\n    */\r\n    function tryGet(uint256 key) external view returns (bool, address);\r\n\r\n    /**\r\n        @notice Returns the value associated with `key`.\r\n        @dev Returns the value associated with `key`.  O(1).\r\n        Requirements:\r\n        - `key` must be in the registry map.\r\n        @param key    The key to search for\r\n        @return       The contract address\r\n    */\r\n    function get(uint256 key) external view returns (address);\r\n\r\n    /**\r\n        @notice Returns all indices, keys, addresses.\r\n        @dev Returns all indices, keys, addresses as three seperate arrays.\r\n        @return Indices, keys, addresses\r\n    */\r\n    function getAll()\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            address[] memory\r\n        );\r\n\r\n    /**\r\n        @notice Adds a key-value pair to a map, or updates the value for an existing\r\n        key.\r\n        @dev Adds a key-value pair to the registry map, or updates the value for an existing\r\n        key. O(1).\r\n        Returns true if the key was added to the registry map, that is if it was not\r\n        already present.\r\n        @param key    The key as an identifier\r\n        @param value  The address of the contract\r\n        @return       Success as a bool\r\n    */\r\n    function set(uint256 key, address value) external returns (bool);\r\n\r\n    /**\r\n        @notice Removes a value from the registry map.\r\n        @dev Removes a value from the registry map. O(1).\r\n        Returns true if the key was removed from the registry map, that is if it was present.\r\n        @param key    The key as an identifier\r\n        @return       Success as a bool\r\n    */\r\n    function remove(uint256 key) external returns (bool);\r\n\r\n    /**\r\n        @notice Sets a contract state to active.\r\n        @dev Sets a contract state to active.\r\n        @param key    The key as an identifier\r\n    */\r\n    function setContractActiveByKey(uint256 key) external;\r\n\r\n    /**\r\n        @notice Sets a contract state to active.\r\n        @dev Sets a contract state to active.\r\n        @param contractAddress The contract's address\r\n    */\r\n    function setContractActiveByAddress(address contractAddress) external;\r\n\r\n    /**\r\n        @notice Sets all contracts within the registry to state active.\r\n        @dev Sets all contracts within the registry to state active.\r\n        Does NOT revert if any contract doesn't implement the RegistrableContractState interface.\r\n        Does NOT revert if it is an externally owned user account.\r\n    */\r\n    function setAllContractsActive() external;\r\n\r\n    /**\r\n        @notice Sets a contract state to inactive.\r\n        @dev Sets a contract state to inactive.\r\n        @param key    The key as an identifier\r\n    */\r\n    function setContractInactiveByKey(uint256 key) external;\r\n\r\n    /**\r\n        @notice Sets a contract state to inactive.\r\n        @dev Sets a contract state to inactive.\r\n        @param contractAddress The contract's address\r\n    */\r\n    function setContractInactiveByAddress(address contractAddress) external;\r\n\r\n    /**\r\n        @notice Sets all contracts within the registry to state inactive.\r\n        @dev Sets all contracts within the registry to state inactive.\r\n        Does NOT revert if any contract doesn't implement the RegistrableContractState interface.\r\n        Does NOT revert if it is an externally owned user account.\r\n    */\r\n    function setAllContractsInactive() external;\r\n}\r\n\r\n/**\r\n    @author The Calystral Team\r\n    @title A helper parent contract: Pausable & Registry\r\n*/\r\ncontract RegistrableContractState is IRegistrableContractState, ERC165 {\r\n    /*==============================\r\n    =          CONSTANTS           =\r\n    ==============================*/\r\n\r\n    /*==============================\r\n    =            STORAGE           =\r\n    ==============================*/\r\n    /// @dev Current contract state\r\n    bool private _isActive;\r\n    /// @dev Current registry pointer\r\n    address private _registryAddress;\r\n\r\n    /*==============================\r\n    =          MODIFIERS           =\r\n    ==============================*/\r\n    modifier isActive() {\r\n        _isActiveCheck();\r\n        _;\r\n    }\r\n\r\n    modifier isAuthorizedAdmin() {\r\n        _isAuthorizedAdmin();\r\n        _;\r\n    }\r\n\r\n    modifier isAuthorizedAdminOrRegistry() {\r\n        _isAuthorizedAdminOrRegistry();\r\n        _;\r\n    }\r\n\r\n    /*==============================\r\n    =          CONSTRUCTOR         =\r\n    ==============================*/\r\n    /**\r\n        @notice Creates and initializes the contract.\r\n        @dev Creates and initializes the contract.\r\n        Registers all implemented interfaces.\r\n        Inheriting contracts are INACTIVE by default.\r\n    */\r\n    constructor(address registryAddress) {\r\n        _registryAddress = registryAddress;\r\n\r\n        _registerInterface(type(IRegistrableContractState).interfaceId);\r\n    }\r\n\r\n    /*==============================\r\n    =      PUBLIC & EXTERNAL       =\r\n    ==============================*/\r\n\r\n    /*==============================\r\n    =          RESTRICTED          =\r\n    ==============================*/\r\n    function setActive() external override isAuthorizedAdminOrRegistry() {\r\n        _isActive = true;\r\n\r\n        emit Activated();\r\n    }\r\n\r\n    function setInactive() external override isAuthorizedAdminOrRegistry() {\r\n        _isActive = false;\r\n\r\n        emit Inactivated();\r\n    }\r\n\r\n    function setRegistry(address registryAddress)\r\n        external\r\n        override\r\n        isAuthorizedAdmin()\r\n    {\r\n        _registryAddress = registryAddress;\r\n\r\n        try\r\n            _registryContract().supportsInterface(type(IRegistry).interfaceId)\r\n        returns (bool supportsInterface) {\r\n            require(\r\n                supportsInterface,\r\n                \"The provided contract does not implement the Registry interface\"\r\n            );\r\n        } catch {\r\n            revert(\r\n                \"The provided contract does not implement the Registry interface\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /*==============================\r\n    =          VIEW & PURE         =\r\n    ==============================*/\r\n    function getIsActive() public view override returns (bool) {\r\n        return _isActive;\r\n    }\r\n\r\n    function getRegistryAddress() public view override returns (address) {\r\n        return _registryAddress;\r\n    }\r\n\r\n    function getContractAddress(uint256 key)\r\n        public\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return _registryContract().get(key);\r\n    }\r\n\r\n    /*==============================\r\n    =      INTERNAL & PRIVATE      =\r\n    ==============================*/\r\n    /**\r\n        @dev Returns the target Registry object.\r\n        @return The target Registry object\r\n    */\r\n    function _registryContract() internal view returns (IRegistry) {\r\n        return IRegistry(_registryAddress);\r\n    }\r\n\r\n    /**\r\n        @dev Checks if the contract is in an active state.\r\n        Reverts if the contract is INACTIVE.\r\n    */\r\n    function _isActiveCheck() internal view {\r\n        require(_isActive == true, \"The contract is not active\");\r\n    }\r\n\r\n    /**\r\n        @dev Checks if the msg.sender is the Admin.\r\n        Reverts if msg.sender is not the Admin.\r\n    */\r\n    function _isAuthorizedAdmin() internal view {\r\n        require(msg.sender == getContractAddress(1), \"Unauthorized call\");\r\n    }\r\n\r\n    /**\r\n        @dev Checks if the msg.sender is the Admin or the Registry.\r\n        Reverts if msg.sender is not the Admin or the Registry.\r\n    */\r\n    function _isAuthorizedAdminOrRegistry() internal view {\r\n        require(\r\n            msg.sender == _registryAddress ||\r\n                msg.sender == getContractAddress(1),\r\n            \"Unauthorized call\"\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n    Note: Simple contract to use as base for const vals\r\n*/\r\ncontract CommonConstants {\r\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61; // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\r\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81; // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\r\n}\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(\r\n            uint256(s) <=\r\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\r\n            \"ECDSA: invalid signature 's' value\"\r\n        );\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n            );\r\n    }\r\n}\r\n\r\n/**\r\n    @title ERC-1155 Multi Token Standard\r\n    @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\r\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\r\n */\r\ninterface IERC1155 {\r\n    /* is ERC165 */\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\r\n        The `_operator` argument MUST be msg.sender.\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_id` argument MUST be the token type being transferred.\r\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\r\n    */\r\n    event TransferSingle(\r\n        address indexed _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _id,\r\n        uint256 _value\r\n    );\r\n\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\r\n        The `_operator` argument MUST be msg.sender.\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_ids` argument MUST be the list of tokens being transferred.\r\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\r\n    */\r\n    event TransferBatch(\r\n        address indexed _operator,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256[] _ids,\r\n        uint256[] _values\r\n    );\r\n\r\n    /**\r\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled).\r\n    */\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n    /**\r\n        @dev MUST emit when the URI is updated for a token ID.\r\n        URIs are defined in RFC 3986.\r\n        The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\r\n    */\r\n    event URI(string _value, uint256 indexed _id);\r\n\r\n    /**\r\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\r\n        MUST revert on any other error.\r\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _id      ID of the token type\r\n        @param _value   Transfer amount\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) external;\r\n\r\n    /**\r\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if length of `_ids` is not the same as length of `_values`.\r\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\r\n        MUST revert on any other error.\r\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\r\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _ids     IDs of each token type (order and length must match _values array)\r\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\r\n    */\r\n    function safeBatchTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _values,\r\n        bytes calldata _data\r\n    ) external;\r\n\r\n    /**\r\n        @notice Get the balance of an account's Tokens.\r\n        @param _owner  The address of the token holder\r\n        @param _id     ID of the Token\r\n        @return        The _owner's balance of the Token type requested\r\n     */\r\n    function balanceOf(address _owner, uint256 _id)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Get the balance of multiple account/token pairs\r\n        @param _owners The addresses of the token holders\r\n        @param _ids    ID of the Tokens\r\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n     */\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n        @dev MUST emit the ApprovalForAll event on success.\r\n        @param _operator  Address to add to the set of authorized operators\r\n        @param _approved  True if the operator is approved, false to revoke approval\r\n    */\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /**\r\n        @notice Queries the approval status of an operator for a given owner.\r\n        @param _owner     The owner of the Tokens\r\n        @param _operator  Address of authorized operator\r\n        @return           True if the operator is approved, false if not\r\n    */\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n/**\r\n    @title ERC-1155 Mixed Fungible Token Standard\r\n */\r\ninterface IERC1155MixedFungible {\r\n    /**\r\n        @notice Returns true for non-fungible token id.\r\n        @dev    Returns true for non-fungible token id.\r\n        @param _id  Id of the token\r\n        @return     If a token is non-fungible\r\n     */\r\n    function isNonFungible(uint256 _id) external pure returns (bool);\r\n\r\n    /**\r\n        @notice Returns true for fungible token id.\r\n        @dev    Returns true for fungible token id.\r\n        @param _id  Id of the token\r\n        @return     If a token is fungible\r\n     */\r\n    function isFungible(uint256 _id) external pure returns (bool);\r\n\r\n    /**\r\n        @notice Returns the mint# of a token type.\r\n        @dev    Returns the mint# of a token type.\r\n        @param _id  Id of the token\r\n        @return     The mint# of a token type.\r\n     */\r\n    function getNonFungibleIndex(uint256 _id) external pure returns (uint256);\r\n\r\n    /**\r\n        @notice Returns the base type of a token id.\r\n        @dev    Returns the base type of a token id.\r\n        @param _id  Id of the token\r\n        @return     The base type of a token id.\r\n     */\r\n    function getNonFungibleBaseType(uint256 _id)\r\n        external\r\n        pure\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Returns true if the base type of the token id is a non-fungible base type.\r\n        @dev    Returns true if the base type of the token id is a non-fungible base type.\r\n        @param _id  Id of the token\r\n        @return     The non-fungible base type info as bool\r\n     */\r\n    function isNonFungibleBaseType(uint256 _id) external pure returns (bool);\r\n\r\n    /**\r\n        @notice Returns true if the base type of the token id is a fungible base type.\r\n        @dev    Returns true if the base type of the token id is a fungible base type.\r\n        @param _id  Id of the token\r\n        @return     The fungible base type info as bool\r\n     */\r\n    function isNonFungibleItem(uint256 _id) external pure returns (bool);\r\n\r\n    /**\r\n        @notice Returns the owner of a token.\r\n        @dev    Returns the owner of a token.\r\n        @param _id  Id of the token\r\n        @return     The owner address\r\n     */\r\n    function ownerOf(uint256 _id) external view returns (address);\r\n}\r\n\r\n/**\r\n    @author The Calystral Team\r\n    @title The ERC1155CalystralMixedFungibleMintable' Interface\r\n*/\r\ninterface IERC1155CalystralMixedFungibleMintable {\r\n    /**\r\n        @dev MUST emit when a release timestamp is set or updated.\r\n        The `typeId` argument MUST be the id of a type.\r\n        The `timestamp` argument MUST be the timestamp of the release in seconds.\r\n    */\r\n    event OnReleaseTimestamp(uint256 indexed typeId, uint256 timestamp);\r\n\r\n    /**\r\n        @notice Updates the metadata base URI.\r\n        @dev Updates the `_metadataBaseURI`.\r\n        @param uri The metadata base URI\r\n    */\r\n    function updateMetadataBaseURI(string calldata uri) external;\r\n\r\n    /**\r\n        @notice Creates a non-fungible type.\r\n        @dev Creates a non-fungible type. This function only creates the type and is not used for minting.\r\n        The type also has a maxSupply since there can be multiple tokens of the same type, e.g. 100x 'Pikachu'.\r\n        Reverts if the `maxSupply` is 0 or exceeds the `MAX_TYPE_SUPPLY`.\r\n        @param maxSupply        The maximum amount that can be created of this type, unlimited SHOULD be 2**128 (uint128) as the max. MUST NOT be set to 0\r\n        @param releaseTimestamp The timestamp for the release time, SHOULD be set to 1337 for releasing it right away. MUST NOT be set to 0\r\n        @return                 The `typeId`\r\n    */\r\n    function createNonFungibleType(uint256 maxSupply, uint256 releaseTimestamp)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Creates a fungible type.\r\n        @dev Creates a fungible type. This function only creates the type and is not used for minting.\r\n        Reverts if the `maxSupply` is 0 or exceeds the `MAX_TYPE_SUPPLY`.\r\n        @param maxSupply        The maximum amount that can be created of this type, unlimited SHOULD be 2**128 (uint128) as the max. MUST NOT be set to 0\r\n        @param releaseTimestamp The timestamp for the release time, SHOULD be set to 1337 for releasing it right away. MUST NOT be set to 0\r\n        @return                 The `typeId`\r\n    */\r\n    function createFungibleType(uint256 maxSupply, uint256 releaseTimestamp)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Mints a non-fungible type.\r\n        @dev Mints a non-fungible type.\r\n        Reverts if type id is not existing.\r\n        Reverts if out of stock.\r\n        Emits the `TransferSingle` event.\r\n        @param typeId   The type which should be minted\r\n        @param toArr    An array of receivers\r\n    */\r\n    function mintNonFungible(uint256 typeId, address[] calldata toArr) external;\r\n\r\n    /**\r\n        @notice Mints a fungible type.\r\n        @dev Mints a fungible type.\r\n        Reverts if array lengths are unequal.\r\n        Reverts if type id is not existing.\r\n        Reverts if out of stock.\r\n        Emits the `TransferSingle` event.\r\n        @param typeId   The type which should be minted\r\n        @param toArr    An array of receivers\r\n    */\r\n    function mintFungible(\r\n        uint256 typeId,\r\n        address[] calldata toArr,\r\n        uint256[] calldata quantitiesArr\r\n    ) external;\r\n\r\n    /**\r\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        Uses Meta Transactions - transactions are signed by the owner or operator of the owner but are executed by anybody.\r\n        Reverts if the signature is invalid.\r\n        Reverts if array lengths are unequal.\r\n        Reverts if the transaction expired.\r\n        Reverts if the transaction was executed already.\r\n        Reverts if the signer is not the asset owner or approved operator of the owner.\r\n        Reverts if `_to` is the zero address.\r\n        Reverts if balance of holder for token `_id` is lower than the `_value` sent.\r\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param signature    The signature of the signing account as proof for execution allowance\r\n        @param signer       The signing account. This SHOULD be the owner of the asset or an approved operator of the owner.\r\n        @param _to          Target address\r\n        @param _id          ID of the token type\r\n        @param _value       Transfer amount\r\n        @param _data        Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\r\n        @param nonce        Each sent meta transaction includes a nonce to prevent that a signed transaction is executed multiple times\r\n        @param maxTimestamp The maximum point in time before the meta transaction expired, thus becoming invalid\r\n    */\r\n    function metaSafeTransferFrom(\r\n        bytes memory signature,\r\n        address signer,\r\n        address _to,\r\n        uint256 _id,\r\n        uint256 _value,\r\n        bytes calldata _data,\r\n        uint256 nonce,\r\n        uint256 maxTimestamp\r\n    ) external;\r\n\r\n    /**\r\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        Uses Meta Transactions - transactions are signed by the owner or operator of the owner but are executed by anybody.\r\n        Reverts if the signature is invalid.\r\n        Reverts if array lengths are unequal.\r\n        Reverts if the transaction expired.\r\n        Reverts if the transaction was executed already.\r\n        Reverts if the signer is not the asset owner or approved operator of the owner.\r\n        Reverts if `_to` is the zero address.\r\n        Reverts if length of `_ids` is not the same as length of `_values`.\r\n        Reverts if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\r\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\r\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param signature    The signature of the signing account as proof for execution allowance\r\n        @param signer       The signing account. This SHOULD be the owner of the asset or an approved operator of the owner.\r\n        @param _to          Target address\r\n        @param _ids         IDs of each token type (order and length must match _values array)\r\n        @param _values      Transfer amounts per token type (order and length must match _ids array)\r\n        @param _data        Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\r\n        @param nonce        Each sent meta transaction includes a nonce to prevent that a signed transaction is executed multiple times\r\n        @param maxTimestamp The maximum point in time before the meta transaction expired, thus becoming invalid\r\n    */\r\n    function metaSafeBatchTransferFrom(\r\n        bytes memory signature,\r\n        address signer,\r\n        address _to,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _values,\r\n        bytes calldata _data,\r\n        uint256 nonce,\r\n        uint256 maxTimestamp\r\n    ) external;\r\n\r\n    /**\r\n        @notice Burns fungible and/or non-fungible tokens.\r\n        @dev Sends FTs and/or NFTs to 0x0 address.\r\n        Uses Meta Transactions - transactions are signed by the owner but are executed by anybody.\r\n        Reverts if the signature is invalid.\r\n        Reverts if array lengths are unequal.\r\n        Reverts if the transaction expired.\r\n        Reverts if the transaction was executed already.\r\n        Reverts if the signer is not the asset owner.\r\n        Emits the `TransferBatch` event where the `to` argument is the 0x0 address.\r\n        @param signature    The signature of the signing account as proof for execution allowance\r\n        @param signer The signing account. This SHOULD be the owner of the asset\r\n        @param ids An array of token Ids which should be burned\r\n        @param values An array of amounts which should be burned. The order matches the order in the ids array\r\n        @param nonce Each sent meta transaction includes a nonce to prevent that a signed transaction is executed multiple times\r\n        @param maxTimestamp The maximum point in time before the meta transaction expired, thus becoming invalid\r\n    */\r\n    function metaBatchBurn(\r\n        bytes memory signature,\r\n        address signer,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        uint256 nonce,\r\n        uint256 maxTimestamp\r\n    ) external;\r\n\r\n    /**\r\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n        @dev MUST emit the ApprovalForAll event on success.\r\n        Uses Meta Transactions - transactions are signed by the owner but are executed by anybody.\r\n        Reverts if the signature is invalid.\r\n        Reverts if array lengths are unequal.\r\n        Reverts if the transaction expired.\r\n        Reverts if the transaction was executed already.\r\n        Reverts if the signer is not the asset owner.\r\n        @param signature    The signature of the signing account as proof for execution allowance\r\n        @param signer       The signing account. This SHOULD be the owner of the asset\r\n        @param _operator    Address to add to the set of authorized operators\r\n        @param _approved    True if the operator is approved, false to revoke approval\r\n        @param nonce        Each sent meta transaction includes a nonce to prevent that a signed transaction is executed multiple times\r\n        @param maxTimestamp The maximum point in time before the meta transaction expired, thus becoming invalid\r\n    */\r\n    function metaSetApprovalForAll(\r\n        bytes memory signature,\r\n        address signer,\r\n        address _operator,\r\n        bool _approved,\r\n        uint256 nonce,\r\n        uint256 maxTimestamp\r\n    ) external;\r\n\r\n    /**\r\n        @notice Sets a release timestamp.\r\n        @dev Sets a release timestamp.\r\n        Reverts if `timestamp` == 0.\r\n        Reverts if the `typeId` is released already.\r\n        @param typeId       The type which should be set or updated\r\n        @param timestamp    The timestamp for the release time, SHOULD be set to 1337 for releasing it right away. MUST NOT be set to 0\r\n    */\r\n    function setReleaseTimestamp(uint256 typeId, uint256 timestamp) external;\r\n\r\n    /**\r\n        @notice Get the release timestamp of a type.\r\n        @dev Get the release timestamp of a type.\r\n        @return The release timestamp of a type.\r\n    */\r\n    function getReleaseTimestamp(uint256 typeId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Get all existing type Ids.\r\n        @dev Get all existing type Ids.\r\n        @return An array of all existing type Ids.\r\n    */\r\n    function getTypeIds() external view returns (uint256[] memory);\r\n\r\n    /**\r\n        @notice Get a specific type Id.\r\n        @dev Get a specific type Id.\r\n        Reverts if `typeNonce` is 0 or if it does not exist.\r\n        @param  typeNonce The type nonce for which the id is requested\r\n        @return A specific type Id.\r\n    */\r\n    function getTypeId(uint256 typeNonce) external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get all non-fungible assets for a specific user.\r\n        @dev Get all non-fungible assets for a specific user.\r\n        @param  owner The address of the requested user\r\n        @return An array of Ids that are owned by the user\r\n    */\r\n    function getNonFungibleAssets(address owner)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n        @notice Get all fungible assets for a specific user.\r\n        @dev Get all fungible assets for a specific user.\r\n        @param  owner The address of the requested user\r\n        @return An array of Ids that are owned by the user\r\n                An array for the amount owned of each Id\r\n    */\r\n    function getFungibleAssets(address owner)\r\n        external\r\n        view\r\n        returns (uint256[] memory, uint256[] memory);\r\n\r\n    /**\r\n        @notice Get the type nonce.\r\n        @dev Get the type nonce.\r\n        @return The type nonce.\r\n    */\r\n    function getTypeNonce() external view returns (uint256);\r\n\r\n    /**\r\n        @notice The amount of tokens that have been minted of a specific type.\r\n        @dev    The amount of tokens that have been minted of a specific type.\r\n                Reverts if the given typeId does not exist.\r\n        @param  typeId The requested type\r\n        @return The minted amount\r\n    */\r\n    function getMintedSupply(uint256 typeId) external view returns (uint256);\r\n\r\n    /**\r\n        @notice The amount of tokens that can be minted of a specific type.\r\n        @dev    The amount of tokens that can be minted of a specific type.\r\n                Reverts if the given typeId does not exist.\r\n        @param  typeId The requested type\r\n        @return The maximum mintable amount\r\n    */\r\n    function getMaxSupply(uint256 typeId) external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the burn nonce of a specific user.\r\n        @dev    Get the burn nonce of a specific user / signer.\r\n        @param  signer The requested signer\r\n        @return The burn nonce of a specific user\r\n    */\r\n    function getMetaNonce(address signer) external view returns (uint256);\r\n}\r\n\r\n/**\r\n    @author The Calystral Team\r\n    @title The Assets' Interface\r\n*/\r\ninterface IAssets is\r\n    IERC1155,\r\n    IERC1155MixedFungible,\r\n    IERC1155CalystralMixedFungibleMintable,\r\n    IRegistrableContractState\r\n{\r\n    /**\r\n        @dev MUST emit when any property type is created.\r\n        The `propertyId` argument MUST be the id of a property.\r\n        The `name` argument MUST be the name of this specific id.\r\n        The `propertyType` argument MUST be the property type.\r\n    */\r\n    event OnCreateProperty(\r\n        uint256 propertyId,\r\n        string name,\r\n        PropertyType indexed propertyType\r\n    );\r\n    /**\r\n        @dev MUST emit when an int type property is updated.\r\n        The `tokenId` argument MUST be the id of the token of which the property is updated.\r\n        The `propertyId` argument MUST be the property id which is updated.\r\n        The `value` argument MUST be the value to which the token's property is updated.\r\n    */\r\n    event OnUpdateIntProperty(\r\n        uint256 indexed tokenId,\r\n        uint256 indexed propertyId,\r\n        int256 value\r\n    );\r\n    /**\r\n        @dev MUST emit when an string type property is updated.\r\n        The `tokenId` argument MUST be the id of the token of which the property is updated.\r\n        The `propertyId` argument MUST be the property id which is updated.\r\n        The `value` argument MUST be the value to which the token's property is updated.\r\n    */\r\n    event OnUpdateStringProperty(\r\n        uint256 indexed tokenId,\r\n        uint256 indexed propertyId,\r\n        string value\r\n    );\r\n    /**\r\n        @dev MUST emit when an address type property is updated.\r\n        The `tokenId` argument MUST be the id of the token of which the property is updated.\r\n        The `propertyId` argument MUST be the property id which is updated.\r\n        The `value` argument MUST be the value to which the token's property is updated.\r\n    */\r\n    event OnUpdateAddressProperty(\r\n        uint256 indexed tokenId,\r\n        uint256 indexed propertyId,\r\n        address value\r\n    );\r\n    /**\r\n        @dev MUST emit when an byte type property is updated.\r\n        The `tokenId` argument MUST be the id of the token of which the property is updated.\r\n        The `propertyId` argument MUST be the property id which is updated.\r\n        The `value` argument MUST be the value to which the token's property is updated.\r\n    */\r\n    event OnUpdateByteProperty(\r\n        uint256 indexed tokenId,\r\n        uint256 indexed propertyId,\r\n        bytes32 value\r\n    );\r\n    /**\r\n        @dev MUST emit when an int array type property is updated.\r\n        The `tokenId` argument MUST be the id of the token of which the property is updated.\r\n        The `propertyId` argument MUST be the property id which is updated.\r\n        The `value` argument MUST be the value to which the token's property is updated.\r\n    */\r\n    event OnUpdateIntArrayProperty(\r\n        uint256 indexed tokenId,\r\n        uint256 indexed propertyId,\r\n        int256[] value\r\n    );\r\n    /**\r\n        @dev MUST emit when an address array type property is updated.\r\n        The `tokenId` argument MUST be the id of the token of which the property is updated.\r\n        The `propertyId` argument MUST be the property id which is updated.\r\n        The `value` argument MUST be the value to which the token's property is updated.\r\n    */\r\n    event OnUpdateAddressArrayProperty(\r\n        uint256 indexed tokenId,\r\n        uint256 indexed propertyId,\r\n        address[] value\r\n    );\r\n\r\n    /// @dev Enum representing all existing property types that can be used.\r\n    enum PropertyType {INT, STRING, ADDRESS, BYTE, INTARRAY, ADDRESSARRAY}\r\n\r\n    /**\r\n        @notice Creates a property of type int.\r\n        @dev Creates a property of type int.\r\n        @param name The name for this property\r\n        @return     The property id\r\n    */\r\n    function createIntProperty(string calldata name) external returns (uint256);\r\n\r\n    /**\r\n        @notice Creates a property of type string.\r\n        @dev Creates a property of type string.\r\n        @param name The name for this property\r\n        @return     The property id\r\n    */\r\n    function createStringProperty(string calldata name)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Creates a property of type address.\r\n        @dev Creates a property of type address.\r\n        @param name The name for this property\r\n        @return     The property id\r\n    */\r\n    function createAddressProperty(string calldata name)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Creates a property of type byte.\r\n        @dev Creates a property of type byte.\r\n        @param name The name for this property\r\n        @return     The property id\r\n    */\r\n    function createByteProperty(string calldata name)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Creates a property of type int array.\r\n        @dev Creates a property of type int array.\r\n        @param name The name for this property\r\n        @return     The property id\r\n    */\r\n    function createIntArrayProperty(string calldata name)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Creates a property of type address array.\r\n        @dev Creates a property of type address array.\r\n        @param name The name for this property\r\n        @return     The property id\r\n    */\r\n    function createAddressArrayProperty(string calldata name)\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n        @notice Updates an existing int property for the passed value.\r\n        @dev Updates an existing int property for the passed `value`.\r\n        @param tokenId      The id of the token of which the property is updated\r\n        @param propertyId   The property id which is updated\r\n        @param value        The value to which the token's property is updated\r\n    */\r\n    function updateIntProperty(\r\n        uint256 tokenId,\r\n        uint256 propertyId,\r\n        int256 value\r\n    ) external;\r\n\r\n    /**\r\n        @notice Updates an existing string property for the passed value.\r\n        @dev Updates an existing string property for the passed `value`.\r\n        @param tokenId      The id of the token of which the property is updated\r\n        @param propertyId   The property id which is updated\r\n        @param value        The value to which the token's property is updated\r\n    */\r\n    function updateStringProperty(\r\n        uint256 tokenId,\r\n        uint256 propertyId,\r\n        string calldata value\r\n    ) external;\r\n\r\n    /**\r\n        @notice Updates an existing address property for the passed value.\r\n        @dev Updates an existing address property for the passed `value`.\r\n        @param tokenId      The id of the token of which the property is updated\r\n        @param propertyId   The property id which is updated\r\n        @param value        The value to which the token's property is updated\r\n    */\r\n    function updateAddressProperty(\r\n        uint256 tokenId,\r\n        uint256 propertyId,\r\n        address value\r\n    ) external;\r\n\r\n    /**\r\n        @notice Updates an existing byte property for the passed value.\r\n        @dev Updates an existing byte property for the passed `value`.\r\n        @param tokenId      The id of the token of which the property is updated\r\n        @param propertyId   The property id which is updated\r\n        @param value        The value to which the token's property is updated\r\n    */\r\n    function updateByteProperty(\r\n        uint256 tokenId,\r\n        uint256 propertyId,\r\n        bytes32 value\r\n    ) external;\r\n\r\n    /**\r\n        @notice Updates an existing int array property for the passed value.\r\n        @dev Updates an existing int array property for the passed `value`.\r\n        @param tokenId      The id of the token of which the property is updated\r\n        @param propertyId   The property id which is updated\r\n        @param value        The value to which the token's property is updated\r\n    */\r\n    function updateIntArrayProperty(\r\n        uint256 tokenId,\r\n        uint256 propertyId,\r\n        int256[] calldata value\r\n    ) external;\r\n\r\n    /**\r\n        @notice Updates an existing address array property for the passed value.\r\n        @dev Updates an existing address array property for the passed `value`.\r\n        @param tokenId      The id of the token of which the property is updated\r\n        @param propertyId   The property id which is updated\r\n        @param value        The value to which the token's property is updated\r\n    */\r\n    function updateAddressArrayProperty(\r\n        uint256 tokenId,\r\n        uint256 propertyId,\r\n        address[] calldata value\r\n    ) external;\r\n\r\n    /**\r\n        @notice Get the property type of a property.\r\n        @dev Get the property type of a property.\r\n        @return The property type\r\n    */\r\n    function getPropertyType(uint256 propertyId)\r\n        external\r\n        view\r\n        returns (PropertyType);\r\n\r\n    /**\r\n        @notice Get the count of available properties.\r\n        @dev Get the count of available properties.\r\n        @return The property count\r\n    */\r\n    function getPropertyCounter() external view returns (uint256);\r\n}\r\n\r\n/**\r\n    @author The Calystral Team\r\n    @title Earn Synergy of Serra's Alpha Fame through Crate deposit!\r\n*/\r\ncontract SynergyOfSerraAlphaFame is\r\n    IFame,\r\n    IERC1155TokenReceiver,\r\n    RegistrableContractState,\r\n    ReentrancyGuard,\r\n    CommonConstants\r\n{\r\n    /*==============================\r\n    =          CONSTANTS           =\r\n    ==============================*/\r\n    /**\r\n        @notice Count of decimals for alpha fame.\r\n        @dev    1^18 decimals for alpha fame.\r\n    */\r\n    uint256 public constant DECIMALS = 1e18;\r\n    /**\r\n        @notice Milliseconds per week.\r\n        @dev    Milliseconds per week.\r\n    */\r\n    uint256 public constant MS_PER_WEEK = 604800000;\r\n    /**\r\n        @notice Each transcendent set crate rewards 2 stake points.\r\n        @dev    Each transcendent set crate rewards 2 stake points.\r\n    */\r\n    uint256 public constant TRANSCENDENT_MULTIPLIER = 2;\r\n    /**\r\n        @notice Each base set crate rewards 1 stake points.\r\n        @dev    Each base set crate rewards 1 stake points.\r\n    */\r\n    uint256 public constant BASE_MULTIPLIER = 1;\r\n    /**\r\n        @notice Token id of base set crate.\r\n        @dev    Token id of base set crate.\r\n    */\r\n    uint256 public constant BASE_ID = 340282366920938463463374607431768211456;\r\n    /**\r\n        @notice Token id of transcendent set crate.\r\n        @dev    Token id of transcendent set crate.\r\n    */\r\n    uint256 public constant TRANSCENDENT_ID =\r\n        680564733841876926926749214863536422912;\r\n\r\n    /*==============================\r\n    =            STORAGE           =\r\n    ==============================*/\r\n    /**\r\n        @notice The block time in milliseconds for the Matic Mainnet.\r\n        @dev    The block time in milliseconds for the Matic Mainnet.\r\n    */\r\n    uint256 public msBlockTime = 2100;\r\n    /**\r\n        @notice The weekly distribution amount of alpha fame.\r\n        @dev    The weekly distribution amount of alpha fame.\r\n    */\r\n    uint256 public weeklyReward;\r\n    /**\r\n        @notice Alpha fame distributed in each block.\r\n        @dev    Alpha fame distributed in each block.\r\n    */\r\n    uint256 public famePerBlock;\r\n    /**\r\n        @notice Block number of the last update.\r\n        @dev    Block number of the last update.\r\n    */\r\n    uint256 public lastUpdateBlock;\r\n    /**\r\n        @notice The amount of alpha fame reward per stake point.\r\n        @dev    The amount of alpha fame reward per stake point.\r\n    */\r\n    uint256 public famePerStakePoint;\r\n\r\n    /// @dev owner => base set crate balance\r\n    mapping(address => uint256) private _ownerToStakedBaseBalance;\r\n    /// @dev owner => transcendent set crate balance\r\n    mapping(address => uint256) private _ownerToStakedTranscendentBalance;\r\n    /// @dev owner => beneficiary\r\n    mapping(address => address) private _ownerToBeneficiary;\r\n    /// @dev The current total supply of stake points.\r\n    uint256 private _stakePointsTotalSupply;\r\n    /// @dev beneficiary => stake points balance\r\n    mapping(address => uint256) private _stakePointsBalance;\r\n    /// @dev The total amount of alpha fame ever rewarded.\r\n    uint256 private _totalAlphaFameRewarded;\r\n    /// @dev The total amount of alpha fave ever spent.\r\n    uint256 private _totalAlphaFameSpent;\r\n    /// @dev When a user withdraws, his current alpha fame earnings are stored in the user's vault. (Removed from the calculated formula)\r\n    mapping(address => uint256) private _alphaFameVault;\r\n    /// @dev This is not the actual spent value, it also contains the deficit based on the time the user wasn't staking in the past.\r\n    mapping(address => uint256) private _alphaFameDebit;\r\n    /// @dev signer => meta nonce\r\n    mapping(address => uint256) private _signerToMetaNonce;\r\n\r\n    /*==============================\r\n    =          MODIFIERS           =\r\n    ==============================*/\r\n    modifier isAuthorizedAlphaFameManager() {\r\n        _isAuthorizedAlphaFameManager();\r\n        _;\r\n    }\r\n\r\n    modifier isAuthorizedAssets() {\r\n        _isAuthorizedAssets();\r\n        _;\r\n    }\r\n\r\n    modifier updateAlphaFameRewards() {\r\n        _updateAlphaFameRewards();\r\n        _;\r\n    }\r\n\r\n    /*==============================\r\n    =          CONSTRUCTOR         =\r\n    ==============================*/\r\n    /**\r\n        @notice Creates and initializes the contract.\r\n        @dev Creates and initializes the contract.\r\n        Registers all implemented interfaces.\r\n        Contract is INACTIVE by default.\r\n        @param registryAddress  Address of the Registry\r\n    */\r\n    constructor(address registryAddress)\r\n        RegistrableContractState(registryAddress)\r\n    {\r\n        _setBlockTime(2100);\r\n\r\n        _registerInterface(type(IFame).interfaceId);\r\n        _registerInterface(type(IERC1155TokenReceiver).interfaceId);\r\n    }\r\n\r\n    /*==============================\r\n    =      PUBLIC & EXTERNAL       =\r\n    ==============================*/\r\n    //@override\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    )\r\n        external\r\n        view\r\n        override(IERC1155TokenReceiver, IFame)\r\n        isActive()\r\n        returns (bytes4)\r\n    {\r\n        return bytes4(keccak256(\"false\"));\r\n    }\r\n\r\n    function withdraw(uint256 baseAmount, uint256 transcendentAmount)\r\n        external\r\n        override\r\n        isActive()\r\n    {\r\n        _withdraw(msg.sender, baseAmount, transcendentAmount);\r\n    }\r\n\r\n    function withdrawAll() external override isActive() {\r\n        _withdraw(\r\n            msg.sender,\r\n            _ownerToStakedBaseBalance[msg.sender],\r\n            _ownerToStakedTranscendentBalance[msg.sender]\r\n        );\r\n    }\r\n\r\n    function metaWithdraw(\r\n        bytes memory signature,\r\n        address signer,\r\n        uint256 baseAmount,\r\n        uint256 transcendentAmount,\r\n        uint256 nonce,\r\n        uint256 maxTimestamp\r\n    ) external virtual override isActive() {\r\n        // Meta Transaction\r\n        bytes32 dataHash =\r\n            _getWithdrawAllDataHash(\r\n                baseAmount,\r\n                transcendentAmount,\r\n                nonce,\r\n                maxTimestamp\r\n            );\r\n        address signaturePublicKey =\r\n            ECDSA.recover(ECDSA.toEthSignedMessageHash(dataHash), signature);\r\n        require(\r\n            signer == signaturePublicKey,\r\n            \"Recovered public key does not match the signer\"\r\n        );\r\n        require(\r\n            block.timestamp < maxTimestamp,\r\n            \"This transaction is not valid anymore\"\r\n        );\r\n        require(\r\n            _signerToMetaNonce[signer] == nonce,\r\n            \"This transaction was executed already\"\r\n        );\r\n        _signerToMetaNonce[signer]++;\r\n        // Function Logic\r\n        _withdraw(signer, baseAmount, transcendentAmount);\r\n    }\r\n\r\n    /*==============================\r\n    =          RESTRICTED          =\r\n    ==============================*/\r\n    //@override\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address _from,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _values,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        override(IERC1155TokenReceiver, IFame)\r\n        isAuthorizedAssets()\r\n        updateAlphaFameRewards()\r\n        returns (bytes4)\r\n    {\r\n        bytes memory addressData = _data;\r\n        address beneficiary;\r\n        assembly {\r\n            beneficiary := mload(add(addressData, 20))\r\n        }\r\n        _stake(_from, _ids, _values, beneficiary);\r\n        return ERC1155_BATCH_ACCEPTED;\r\n    }\r\n\r\n    function spendAlphaFame(address from, uint256 amount)\r\n        external\r\n        override\r\n        isAuthorizedAlphaFameManager()\r\n        updateAlphaFameRewards()\r\n    {\r\n        require(amount > 0, \"Zero amount not allowed\");\r\n        require(calculatedAlphaFameBalance(from) >= amount, \"Not enough Fame\");\r\n        _alphaFameDebit[from] += amount;\r\n        _totalAlphaFameSpent += amount;\r\n\r\n        emit FameSpent(from, amount);\r\n    }\r\n\r\n    // Value is required to have 1e18 as decimals\r\n    function setWeeklyReward(uint256 value)\r\n        external\r\n        override\r\n        isAuthorizedAlphaFameManager()\r\n        updateAlphaFameRewards()\r\n    {\r\n        _setWeeklyReward(value);\r\n    }\r\n\r\n    function setBlockTime(uint256 milliseconds)\r\n        external\r\n        override\r\n        isAuthorizedAlphaFameManager()\r\n        updateAlphaFameRewards()\r\n    {\r\n        _setBlockTime(milliseconds);\r\n    }\r\n\r\n    /*==============================\r\n    =          VIEW & PURE         =\r\n    ==============================*/\r\n    function getMetaNonce(address signer)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _signerToMetaNonce[signer];\r\n    }\r\n\r\n    function calculatedAlphaFamePerStakePoint()\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        if (_stakePointsTotalSupply == 0) {\r\n            return famePerStakePoint;\r\n        }\r\n        return\r\n            famePerStakePoint +\r\n            ((block.number - lastUpdateBlock) * famePerBlock) /\r\n            _stakePointsTotalSupply;\r\n    }\r\n\r\n    function calculatedAlphaFameBalance(address userAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _stakePointsBalance[userAddress] *\r\n            calculatedAlphaFamePerStakePoint() +\r\n            _alphaFameVault[userAddress] -\r\n            _alphaFameDebit[userAddress];\r\n    }\r\n\r\n    function getBlockTime() public view override returns (uint256) {\r\n        return msBlockTime;\r\n    }\r\n\r\n    function getWeeklyReward() public view override returns (uint256) {\r\n        return weeklyReward;\r\n    }\r\n\r\n    function getLastUpdateBlock() public view override returns (uint256) {\r\n        return lastUpdateBlock;\r\n    }\r\n\r\n    function getFamePerBlock() public view override returns (uint256) {\r\n        return famePerBlock;\r\n    }\r\n\r\n    function getStakedBaseBalance(address owner)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _ownerToStakedBaseBalance[owner];\r\n    }\r\n\r\n    function getStakedTranscendentBalance(address owner)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _ownerToStakedTranscendentBalance[owner];\r\n    }\r\n\r\n    function getBeneficiary(address owner)\r\n        public\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return _ownerToBeneficiary[owner];\r\n    }\r\n\r\n    function getStakePointsTotalSupply()\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _stakePointsTotalSupply;\r\n    }\r\n\r\n    function getStakePointsBalance(address userAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _stakePointsBalance[userAddress];\r\n    }\r\n\r\n    function getTotalAlphaFameRewarded()\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _totalAlphaFameRewarded;\r\n    }\r\n\r\n    function getTotalAlphaFameSpent() public view override returns (uint256) {\r\n        return _totalAlphaFameSpent;\r\n    }\r\n\r\n    function getAlphaFameVault(address userAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _alphaFameVault[userAddress];\r\n    }\r\n\r\n    function getAlphaFameDebit(address userAddress)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _alphaFameDebit[userAddress];\r\n    }\r\n\r\n    /*==============================\r\n    =      INTERNAL & PRIVATE      =\r\n    ==============================*/\r\n    /**\r\n        @dev Stores the user's crates and rewards his/her beneficiary with stake points that earn alpha fame over time.\r\n        Reverts if the user sets a new beneficary while holding stakes.\r\n        Reverts if nothing is staked.\r\n        Reverts if anything else than base set or transcendent set from the original Assets contract are staked.\r\n        MUST emit Staked.\r\n        @param from         The address which previously owned the token\r\n        @param tokenIds     An array containing ids of each token being transferred (order and length must match _values array)\r\n        @param amounts      An array containing amounts of each token being transferred (order and length must match _ids array)\r\n        @param beneficiary  The beneficiary address\r\n    */\r\n    function _stake(\r\n        address from,\r\n        uint256[] calldata tokenIds,\r\n        uint256[] calldata amounts,\r\n        address beneficiary\r\n    ) private nonReentrant() {\r\n        require(\r\n            _ownerToBeneficiary[from] == beneficiary ||\r\n                (_ownerToStakedBaseBalance[from] == 0 &&\r\n                    _ownerToStakedTranscendentBalance[from] == 0),\r\n            \"You are not allowed to benefit a new SoS account\"\r\n        );\r\n        require(beneficiary != address(0), \"Beneficiary is not set\");\r\n        _ownerToBeneficiary[from] = beneficiary;\r\n\r\n        uint256 totalAmount;\r\n        for (uint256 j = 0; j < amounts.length; ++j) {\r\n            totalAmount += amounts[j];\r\n        }\r\n        require(totalAmount > 0, \"Cannot stake 0\");\r\n\r\n        uint256 totalStakePointReward;\r\n        uint256 baseAmount;\r\n        uint256 transcendentAmount;\r\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\r\n            require(\r\n                tokenIds[i] == BASE_ID || tokenIds[i] == TRANSCENDENT_ID,\r\n                \"Asset not supported\"\r\n            );\r\n            if (tokenIds[i] == BASE_ID) {\r\n                baseAmount += amounts[i];\r\n            }\r\n            if (tokenIds[i] == TRANSCENDENT_ID) {\r\n                transcendentAmount += amounts[i];\r\n            }\r\n        }\r\n        _isGanzzahlig(baseAmount, transcendentAmount);\r\n\r\n        _ownerToStakedBaseBalance[from] += baseAmount;\r\n        totalStakePointReward += _calculateStakePoints(\r\n            baseAmount,\r\n            BASE_MULTIPLIER\r\n        );\r\n        _ownerToStakedTranscendentBalance[from] += transcendentAmount;\r\n        totalStakePointReward += _calculateStakePoints(\r\n            transcendentAmount,\r\n            TRANSCENDENT_MULTIPLIER\r\n        );\r\n        _alphaFameDebit[beneficiary] +=\r\n            totalStakePointReward *\r\n            famePerStakePoint;\r\n        _addStakePoints(beneficiary, totalStakePointReward);\r\n\r\n        emit Staked(from, beneficiary, baseAmount, transcendentAmount);\r\n    }\r\n\r\n    /**\r\n        @dev Readability: Calculates the amount of stake points received.\r\n        @param crateCount        The amount of crates received.\r\n        @param crateMultiplier   The crate's type specific multiplier.\r\n        @return                  crateCount * crateMultiplier\r\n    */\r\n    function _calculateStakePoints(uint256 crateCount, uint256 crateMultiplier)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (crateCount / DECIMALS) * crateMultiplier;\r\n    }\r\n\r\n    /**\r\n        @dev Rewards the beneficiary with stake points when staked.\r\n        Emits StakePointsAdded(beneficiary, count).\r\n        @param beneficiary  The beneficiary.\r\n        @param count        The count of stake points rewarded.\r\n    */\r\n    function _addStakePoints(address beneficiary, uint256 count) private {\r\n        _stakePointsBalance[beneficiary] += count;\r\n        _stakePointsTotalSupply += count;\r\n\r\n        emit StakePointsAdded(beneficiary, count);\r\n    }\r\n\r\n    /**\r\n        @dev Removes the beneficiary's stake points when unstaked.\r\n        Emits StakePointsRemoved(beneficiary, count).\r\n        @param beneficiary  The beneficiary.\r\n        @param count        The count of stake points removed.\r\n    */\r\n    function _removeStakePoints(address beneficiary, uint256 count) private {\r\n        _stakePointsBalance[beneficiary] -= count;\r\n        _stakePointsTotalSupply -= count;\r\n\r\n        emit StakePointsRemoved(beneficiary, count);\r\n    }\r\n\r\n    /**\r\n        @notice Withdraws all staked crates.\r\n        @dev Withdraws all crates and sends them back to the rightful owner (Assets contract).\r\n        Removes all the owners stake points and stores the current earned alpha fame into his/her vault.\r\n        Reverts if there is nothing to withdraw.\r\n        Emits Withdrawn(owner, baseAmount, transcendentAmount).\r\n    */\r\n    function _withdraw(\r\n        address owner,\r\n        uint256 baseAmount,\r\n        uint256 transcendentAmount\r\n    ) private updateAlphaFameRewards() nonReentrant() {\r\n        _isGanzzahlig(baseAmount, transcendentAmount);\r\n        require(\r\n            _ownerToStakedBaseBalance[owner] > 0 ||\r\n                _ownerToStakedTranscendentBalance[owner] > 0,\r\n            \"Nothing to withdraw\"\r\n        );\r\n        _ownerToStakedBaseBalance[owner] -= baseAmount;\r\n        _ownerToStakedTranscendentBalance[owner] -= transcendentAmount;\r\n\r\n        address beneficiary = _ownerToBeneficiary[owner];\r\n        uint256 totalStakePointLoss;\r\n        totalStakePointLoss += _calculateStakePoints(\r\n            baseAmount,\r\n            BASE_MULTIPLIER\r\n        );\r\n        totalStakePointLoss += _calculateStakePoints(\r\n            transcendentAmount,\r\n            TRANSCENDENT_MULTIPLIER\r\n        );\r\n\r\n        uint256 earned = totalStakePointLoss * famePerStakePoint;\r\n\r\n        _removeStakePoints(beneficiary, totalStakePointLoss);\r\n        _alphaFameVault[beneficiary] += earned;\r\n\r\n        uint256[] memory ids = new uint256[](2);\r\n        ids[0] = BASE_ID;\r\n        ids[1] = TRANSCENDENT_ID;\r\n        uint256[] memory amounts = new uint256[](2);\r\n        amounts[0] = baseAmount;\r\n        amounts[1] = transcendentAmount;\r\n\r\n        IAssets(getContractAddress(2)).safeBatchTransferFrom(\r\n            address(this),\r\n            owner,\r\n            ids,\r\n            amounts,\r\n            \"0x0\"\r\n        );\r\n\r\n        emit Withdrawn(owner, baseAmount, transcendentAmount);\r\n    }\r\n\r\n    /**\r\n        @dev Get the data hash required for the meta transaction comparison for the withdraw executions.\r\n        @param nonce        Each sent meta transaction includes a nonce to prevent that a signed transaction is executed multiple times\r\n        @param maxTimestamp The maximum point in time before the meta transaction expired, thus becoming invalid\r\n        @return             The keccak256 hash of the data input\r\n    */\r\n    function _getWithdrawAllDataHash(\r\n        uint256 baseAmount,\r\n        uint256 transcendentAmount,\r\n        uint256 nonce,\r\n        uint256 maxTimestamp\r\n    ) private view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    address(this),\r\n                    baseAmount,\r\n                    transcendentAmount,\r\n                    nonce,\r\n                    maxTimestamp\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n        @dev    Set a new value for the weekly reward.\r\n        Reverts if value is smaller than 1e18 (as decimals). It also updated the `alphaFamePerBlock` value.\r\n        Emits WeeklyRewardUpdated(value).\r\n        @param  value new weekly reward value\r\n    */\r\n    function _setWeeklyReward(uint256 value) private {\r\n        require(\r\n            value == 0 || value >= DECIMALS,\r\n            \"AlphaFame requires 18 decimals\"\r\n        );\r\n\r\n        weeklyReward = value;\r\n        _updateAlphaFamePerBlock();\r\n\r\n        emit WeeklyRewardUpdated(value);\r\n    }\r\n\r\n    /**\r\n        @dev    Set a new millisecond value for the block time. It also updated the `alphaFamePerBlock` value.\r\n        Reverts if block time is set to 0.\r\n        Emits BlockTimeUpdated(milliseconds).\r\n        @param  milliseconds new millisecond value\r\n    */\r\n    function _setBlockTime(uint256 milliseconds) private {\r\n        require(milliseconds != 0, \"BlockTime should not be 0\");\r\n\r\n        msBlockTime = milliseconds;\r\n        _updateAlphaFamePerBlock();\r\n\r\n        emit BlockTimeUpdated(milliseconds);\r\n    }\r\n\r\n    /**\r\n        @dev    Updates the alpha fame per block reward: Weekly Reward / (milliseconds per week / block time in milliseconds).\r\n        Reverts if block time is set to 0.\r\n        Emits FamePerBlockUpdated(famePerBlock).\r\n    */\r\n    function _updateAlphaFamePerBlock() private {\r\n        uint256 blocksPerWeek = MS_PER_WEEK / msBlockTime;\r\n        famePerBlock = weeklyReward / blocksPerWeek;\r\n\r\n        emit FamePerBlockUpdated(famePerBlock);\r\n    }\r\n\r\n    /**\r\n        @dev    Updates the values required for calculating the rewarded alpha fame on each smart contract interaction.\r\n        Updates famePerStakePoint and lastUpdateBlock.\r\n        Emits FameRewarded(rewards, _totalAlphaFameRewarded) where rewards are the alpha fame distributed since the last update.\r\n    */\r\n    function _updateAlphaFameRewards() private {\r\n        uint256 previousFamePerStakePoint = famePerStakePoint;\r\n        famePerStakePoint = calculatedAlphaFamePerStakePoint();\r\n        lastUpdateBlock = block.number;\r\n\r\n        uint256 rewards =\r\n            (famePerStakePoint - previousFamePerStakePoint) *\r\n                _stakePointsTotalSupply;\r\n        _totalAlphaFameRewarded += rewards;\r\n\r\n        emit FameRewarded(rewards, _totalAlphaFameRewarded);\r\n    }\r\n\r\n    /**\r\n        @dev Checks if the msg.sender is the AlphaFameManager.\r\n        Reverts if msg.sender is not the AlphaFameManager.\r\n    */\r\n    function _isAuthorizedAlphaFameManager() private view {\r\n        require(\r\n            getContractAddress(7) == msg.sender,\r\n            \"Unauthorized call. Thanks for supporting the network with your ETH.\"\r\n        );\r\n    }\r\n\r\n    /**\r\n        @dev Checks if the msg.sender is the Assets contract.\r\n        Reverts if msg.sender is not the Assets contract.\r\n    */\r\n    function _isAuthorizedAssets() private view {\r\n        require(\r\n            getContractAddress(2) == msg.sender,\r\n            \"Unauthorized call. Thanks for supporting the network with your ETH.\"\r\n        );\r\n    }\r\n\r\n    /**\r\n        @dev Checks if crates are sent without any decimal value.\r\n        Reverts if base or transcendent crate are not ganzzahlig.\r\n    */\r\n    function _isGanzzahlig(uint256 baseAmount, uint256 transcendentAmount)\r\n        private\r\n        pure\r\n    {\r\n        require(\r\n            (baseAmount + transcendentAmount) % DECIMALS == 0,\r\n            \"Keine halben Sachen\"\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Activated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"milliseconds\",\"type\":\"uint256\"}],\"name\":\"BlockTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"famePerBlock\",\"type\":\"uint256\"}],\"name\":\"FamePerBlockUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAlphaFameRewarded\",\"type\":\"uint256\"}],\"name\":\"FameRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FameSpent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Inactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakePointsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakePointsRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transcendentAmount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WeeklyRewardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transcendentAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MS_PER_WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSCENDENT_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSCENDENT_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"calculatedAlphaFameBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculatedAlphaFamePerStakePoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"famePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"famePerStakePoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getAlphaFameDebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getAlphaFameVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"}],\"name\":\"getContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFamePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastUpdateBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"getMetaNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getStakePointsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakePointsTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getStakedBaseBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getStakedTranscendentBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalAlphaFameRewarded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalAlphaFameSpent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeeklyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transcendentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTimestamp\",\"type\":\"uint256\"}],\"name\":\"metaWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"msBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"milliseconds\",\"type\":\"uint256\"}],\"name\":\"setBlockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setInactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registryAddress\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setWeeklyReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"spendAlphaFame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weeklyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transcendentAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SynergyOfSerraAlphaFame", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "1337", "ConstructorArguments": "000000000000000000000000801b308f0213445e070f0d0cc052db38c17eda51", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3248de7051ddb79681e58bcff9a69f30cd683744419d21556e45c01e4c8b78c0"}