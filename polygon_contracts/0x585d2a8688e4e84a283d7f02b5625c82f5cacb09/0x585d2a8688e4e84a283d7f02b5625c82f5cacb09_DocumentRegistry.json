{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Proyectos propios/Test/DocumentRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n//Import Donable.sol from GitHub to add ownership and donations features to this contract.\\r\\nimport \\\"github.com/salvadorjesus/Donable-Solidity/blob/master/Donable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title DocumentRegistry\\r\\n * @dev A contract to store and manage records of documents with associated timestamps.\\r\\n */\\r\\ncontract DocumentRegistry is Donable {\\r\\n\\r\\n    /**\\r\\n     * @dev Structure representing a document with its hash, name, description, user's address, and timestamp.\\r\\n     */\\r\\n    struct Document {\\r\\n        bytes32 hash;\\r\\n        string documentName;\\r\\n        string description;\\r\\n        address userAddress;\\r\\n        uint timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mapping to store documents using a key generated from the hash and the user's address.\\r\\n     */\\r\\n    mapping(bytes32 => Document) public documents;\\r\\n\\r\\n    /**\\r\\n     * @dev Event emitted when a new document is added.\\r\\n     */\\r\\n    event DocumentAdded(\\r\\n        address indexed user,\\r\\n        bytes32 indexed hash,\\r\\n        string documentName,\\r\\n        string description,\\r\\n        uint timestamp\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Function to add a document with its hash, name, and description. The function is payable to accept donations from users.\\r\\n     * @param _hash The hash of the document.\\r\\n     * @param _documentName The name of the document.\\r\\n     * @param _description The description of the document.\\r\\n     */\\r\\n    function addDocument(bytes32 _hash, string memory _documentName, string memory _description) public payable {\\r\\n        bytes32 key = keccak256(abi.encodePacked(msg.sender, _hash));\\r\\n        require(documents[key].userAddress != msg.sender, \\\"Document already exists for this user\\\");\\r\\n\\r\\n        Document memory newDocument = Document({\\r\\n            hash: _hash,\\r\\n            documentName: _documentName,\\r\\n            description: _description,\\r\\n            userAddress: msg.sender,\\r\\n            timestamp: block.timestamp\\r\\n        });\\r\\n\\r\\n        documents[key] = newDocument;\\r\\n        //Consider the msg.value a donation to the contract\\r\\n        donateAmount(msg.value);\\r\\n        emit DocumentAdded(msg.sender, newDocument.hash, newDocument.documentName, newDocument.description, newDocument.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to get the timestamp of a specific document.\\r\\n     * @param _hash The hash of the document used to look up in the mapping.\\r\\n     * @return timestamp The timestamp of the document.\\r\\n     */\\r\\n    function getTimestamp(bytes32 _hash) public view returns (uint){\\r\\n        bytes32 key = keccak256(abi.encodePacked(msg.sender, _hash));\\r\\n        return documents[key].timestamp;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"github.com/salvadorjesus/Donable-Solidity/blob/master/Donable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title Donable\\n * @dev Provide functionality for a contract to receive and keep track of donations.\\n * The contract user can directly donate to the contract using the public function donate,\\n * or any function of a child contract can keep what\u2019s was not used from msg.amount as a\\n * donation using the modifier keepTheChange.\\n */\\ncontract Donable is Ownable\\n{\\n    /** @dev Keeps track of the amount of WEI stored in the contract that is a donation.\\n    */\\n    uint public donationPot;\\n\\n    /**\\n    * @dev Emitted when a donation is made. Indexed by donor.\\n    */\\n    event DonationMade(address indexed donor, uint donation);\\n\\n    /**\\n     * @notice Send all stored donations to the contract owner.\\n     * @dev Be mindful of the fact that the contract has complete control over\\n     * its fonds. It is possible for Donable to keep track of a donation amount\\n     * larger or smaller than what is keep in a child contract, either\\n     * because of the contract has spent it, or because donations have been\\n     * overestimated by the developer.\\n     */\\n    function withdrawDonations() public requireOwner\\n    {\\n        address payable owner = payable(getOwner());\\n        //Checks - effect - interaction pattern\\n        uint donationsToSend;\\n        // Resiliency check for potential misuse by the contract developer.\\n        if (address(this).balance >= donationPot)\\n            donationsToSend = donationPot;\\n        else\\n            donationsToSend = address(this).balance;\\n\\n        donationPot = 0;\\n        owner.transfer(donationsToSend);\\n    }\\n\\n    /**\\n    * @notice Use this function to make a donation to the contract owner.\\n    */\\n    function donate() public payable\\n    {\\n        donateAmount(msg.value);\\n    }\\n\\n    /**\\n    * @dev Internal function to keep track of a donation. It emits a DonationMade\\n    * event if donation is greater than zero.\\n    * @param donation The donated amount that needs to be accounted for.\\n    */\\n    function donateAmount(uint donation) internal\\n    {        \\n        if (donation > 0)\\n        {\\n            donationPot += donation;\\n            emit DonationMade(msg.sender, donation);\\n        }\\n    }\\n\\n    /**\\n    * @dev Internal utility function to keep track of a donation. It will \\n    * calculate the donation made as the different between spentAmount and\\n    * msg.value, then use the function donateAmount.\\n    * @param spentAmount The amount of Wei used by the caller function. The rest\\n    * of the msg.value is to be accounted as a donation.\\n    */\\n    function keepTheChange(uint spentAmount) internal\\n    {\\n        //spentAmount could be greater than msg.value in some use cases (i.e.:\\n        // the user has some kind of credit.)\\n        if (spentAmount <= msg.value)\\n        {\\n            uint change = msg.value - spentAmount;\\n            donateAmount(change);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"github.com/salvadorjesus/Donable-Solidity/blob/master/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title Ownable\\n * @dev Set & change owner. A modification of the sample contract on Remix.\\n */\\ncontract Ownable {\\n\\n    /**\\n    * @dev Storage variable to keep track of the contract owner.\\n    */\\n    address private owner;\\n    \\n    /**\\n    * @dev Event for EVM logging. Emitted during owner change or contract creation.\\n    */ \\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\\n    \\n    /**\\n    * @dev Modifier to check if the function caller is owner\\n    */\\n    modifier requireOwner() {\\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\\n        // changes to the state and to Ether balances are reverted.\\n        require(msg.sender == owner, \\\"Caller is not owner\\\");\\n        _;\\n    }\\n    \\n    /**\\n     * @dev Constructor. Sets the contract deployer as owner. \\n     */\\n    constructor() {\\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\\n        emit OwnerSet(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Change owner\\n     * @param newOwner address of new owner\\n     */\\n    function changeOwner(address newOwner) public requireOwner {\\n        emit OwnerSet(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Return owner address \\n     * @return address of owner\\n     */\\n    function getOwner() public view returns (address) {\\n        return owner;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"documentName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DocumentAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"donor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"donation\",\"type\":\"uint256\"}],\"name\":\"DonationMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_documentName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"addDocument\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"documents\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"documentName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDonations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DocumentRegistry", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}