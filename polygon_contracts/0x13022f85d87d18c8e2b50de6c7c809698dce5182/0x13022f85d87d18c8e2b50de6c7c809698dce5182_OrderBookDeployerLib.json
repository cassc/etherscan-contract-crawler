{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/IERC20Minimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\n/// @title Minimal ERC20 interface for lighter\\n/// @notice Contains a subset of the full ERC20 interface that is used in lighter\\ninterface IERC20Minimal {\\n    /// @notice Returns the balance of the account provided\\n    /// @param account The account to get the balance of\\n    /// @return balance The balance of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Transfers given amount of tokens from caller to the recipient\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return success Returns true for a successful transfer, false for unsuccessful\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers given amount of tokens from the sender to the recipient\\n    /// @param sender The sender of the transfer\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return success Returns true for a successful transfer, false for unsuccessful\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /// @return decimals Returns the decimals of the token\\n    function decimals() external returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILighterV2FlashCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\n/// @title Callback for IOrderBook#flashLoan\\n/// @notice Any contract that calls IOrderBook#flashLoan must implement this interface\\ninterface ILighterV2FlashCallback {\\n    /// @notice Called from `msg.sender` after transferring flashLoan to the recipient from IOrderBook#flashLoan\\n    /// @dev In the implementation you must repay the pool the assets sent by flashLoan.\\n    /// The caller of this method must be checked to be an order book deployed by the Factory\\n    /// @param callbackData Data passed through by the caller via the IOrderBook#flashLoan call\\n    function flashLoanCallback(bytes calldata callbackData) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILighterV2TransferCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport \\\"./external/IERC20Minimal.sol\\\";\\n\\n/// @title Callback for IOrderBook#swapExactSingle and IOrderBook#createOrder\\n/// @notice Any contract that calls IOrderBook#swapExactSingle and IOrderBook#createOrder must implement this interface with one exception\\n/// @dev If orderType is PerformanceLimitOrder, then no need to implement this interface\\n/// @dev PerformanceLimitOrder handles payments with pre-deposited funds by market-makers\\ninterface ILighterV2TransferCallback {\\n    /// @notice Called by order book after transferring received assets from IOrderBook#swapExactInput or IOrderBook#swapExactOutput for payments\\n    /// @dev In the implementation order creator must pay the order book the assets for the order\\n    /// The caller of this method must be checked to be an order book deployed by the Factory\\n    /// @param callbackData Data passed through by the caller via the IOrderBook#swapExactSingle or IOrderBook#swapExactOutput call\\n    function lighterV2TransferCallback(\\n        uint256 debitTokenAmount,\\n        IERC20Minimal debitToken,\\n        bytes calldata callbackData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport \\\"../libraries/LinkedList.sol\\\";\\nimport \\\"./external/IERC20Minimal.sol\\\";\\n\\n/// @title Order Book Interface\\n/// @notice Order book implements spot trading endpoints and storage for two assets which conform to the IERC20Minimal specification.\\ninterface IOrderBook {\\n    /// @notice Limit Order type.\\n    enum OrderType {\\n        LimitOrder, // Limit order\\n        PerformanceLimitOrder, // Limit order that uses claimable balances\\n        FoKOrder, // Fill or Kill limit order\\n        IoCOrder // Immediate or Cancel limit order\\n    }\\n\\n    /// @notice Struct to use for storing limit orders\\n    struct LimitOrder {\\n        uint32 perfMode_creatorId; // lowest bit for perfMode, remaining 31 bits for creatorId\\n        uint32 prev; // id of the previous order in the list\\n        uint32 next; // id of the next order in the list\\n        uint32 ownerId; // id of the owner of the order\\n        uint64 amount0Base; // amount0Base of the order\\n        uint64 priceBase; // priceBase of the order\\n    }\\n\\n    /// @notice Struct to use returning the paginated orders\\n    struct OrderQueryItem {\\n        bool isAsk; // true if the paginated orders are ask orders, false if bid orders\\n        uint32[] ids; // order ids of returned orders\\n        address[] owners; // owner addresses of returned orders\\n        uint256[] amount0s; // amount0s of returned orders (amount0Base * sizeTick)\\n        uint256[] prices; // prices of returned orders (priceBase * priceTick)\\n    }\\n\\n    /// @notice Emitted when a limit order gets created\\n    /// @param owner The address of the order owner\\n    /// @param id The id of the order\\n    /// @param amount0Base The amount of token0 in the limit order in terms of number of sizeTicks\\n    /// @param priceBase The price of the token0 in terms of price ticks\\n    /// @param isAsk Whether the order is an ask order\\n    /// @param orderType type of the order\\n    event CreateOrder(\\n        address indexed owner,\\n        uint32 indexed id,\\n        uint64 amount0Base,\\n        uint64 priceBase,\\n        bool isAsk,\\n        OrderType orderType\\n    );\\n\\n    /// @notice Emitted when a limit order gets canceled\\n    /// @param id The id of the canceled order\\n    event CancelLimitOrder(uint32 indexed id);\\n\\n    /// @notice Emitted when a taker initiates a swap (market order)\\n    /// @param sender The address that initiated the swap\\n    /// @param recipient The address that received the tokens from the swap\\n    /// @param isExactInput Whether the input amount is exact or output amount is exact\\n    /// @param isAsk Whether the order is an ask order\\n    /// @param swapAmount0 The amount of token0 that was swapped\\n    /// @param swapAmount1 The amount of token1 that was swapped\\n    event SwapExactAmount(\\n        address indexed sender,\\n        address indexed recipient,\\n        bool isExactInput,\\n        bool isAsk,\\n        uint256 swapAmount0,\\n        uint256 swapAmount1\\n    );\\n\\n    /// @notice Emitted when a maker gets filled by a taker\\n    /// @param askId The id of the ask order\\n    /// @param bidId The id of the bid order\\n    /// @param askOwner The address of the ask order owner\\n    /// @param bidOwner The address of the bid order owner\\n    /// @param amount0 The amount of token0 that was swapped\\n    /// @param amount1 The amount of token1 that was swapped\\n    event Swap(\\n        uint32 indexed askId,\\n        uint32 indexed bidId,\\n        address askOwner,\\n        address bidOwner,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted when flashLoan is called\\n    /// @param sender The address that initiated the flashLoan, and that received the callback\\n    /// @param recipient The address that received the tokens from flash loan\\n    /// @param amount0 The amount of token0 that was flash loaned\\n    /// @param amount1 The amount of token1 that was flash loaned\\n    event FlashLoan(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1);\\n\\n    /// @notice Emitted when user claimable balance is increased due to deposit or order operations\\n    event ClaimableBalanceIncrease(address indexed owner, uint256 amountDelta, bool isToken0);\\n\\n    /// @notice Emitted when user claimable balance is decreased due to withdraw or order operations\\n    event ClaimableBalanceDecrease(address indexed owner, uint256 amountDelta, bool isToken0);\\n\\n    /// @notice Creates a limit order.\\n    /// @param amount0Base The amount of token0 in the limit order in terms of number of sizeTicks.\\n    /// amount0 is calculated by multiplying amount0Base by sizeTick.\\n    /// @param priceBase The price of the token0 in terms of price ticks.\\n    /// amount1 is calculated by multiplying priceBase by sizeTick and priceMultiplier and dividing by priceDivider.\\n    /// @param isAsk Whether the order is an ask order\\n    /// @param owner The address which will receive the funds and that can\\n    /// cancel this order. When called by a router, it'll be populated\\n    /// with msg.sender. Smart wallets should use msg.sender directly.\\n    /// @param hintId Hint on where to insert the order in the order book.\\n    /// Can be calculated with suggestHintId function, is not used for FoK and IoC orders.\\n    /// @param orderType type of the order, if FoK or IoC remaining order will not be added for future matches.\\n    /// @param callbackData data to be passed to callback\\n    /// @return id The id of the order\\n    function createOrder(\\n        uint64 amount0Base,\\n        uint64 priceBase,\\n        bool isAsk,\\n        address owner,\\n        uint32 hintId,\\n        OrderType orderType,\\n        bytes memory callbackData\\n    ) external returns (uint32);\\n\\n    /// @notice Cancels an outstanding limit order. Refunds the remaining tokens in the order to the owner\\n    /// @param id The id of the order to cancel\\n    /// @param owner The address of the order sender\\n    /// @return isCanceled Whether the order was successfully canceled or not\\n    function cancelLimitOrder(uint32 id, address owner) external returns (bool);\\n\\n    /// @notice Swaps exact input or output amount of token0 or token1 for the other token\\n    /// @param isAsk Whether the order is an ask order, if true sender pays token0 and receives token1\\n    /// @param isExactInput Whether the input amount is exact or output amount is exact\\n    /// @param exactAmount exact token amount to swap (can be token0 or token1 based on isAsk and isExactInput)\\n    /// @param expectedAmount expected token amount to receive (can be token0 or token1 based on isAsk and isExactInput).\\n    /// if isExactInput is true, then expectedAmount is the minimum amount to receive.\\n    /// if isExactInput is false, then expectedAmount is the maximum amount to pay\\n    /// @param recipient The address which will receive the output\\n    /// @param callbackData data to be passed to callback\\n    function swapExactSingle(\\n        bool isAsk,\\n        bool isExactInput,\\n        uint256 exactAmount,\\n        uint256 expectedAmount,\\n        address recipient,\\n        bytes memory callbackData\\n    ) external returns (uint256, uint256);\\n\\n    /// @notice Flash loans token0 and token1 to the recipient, sender receives the callback\\n    /// @param recipient The address which will receive the token0 and token1\\n    /// @param amount0 The amount of token0 to flash loan\\n    /// @param amount1 The amount of token1 to flash loan\\n    /// @param callbackData data to be passed to callback\\n    function flashLoan(address recipient, uint256 amount0, uint256 amount1, bytes calldata callbackData) external;\\n\\n    /// @notice Deposits token0 or token1 from user to the order book and marks it as claimable\\n    /// to be used for performance limit orders for gas efficient limit order creations.\\n    /// @param amountToDeposit Amount to deposit\\n    /// @param isToken0 Whether the deposit is token0 or token1\\n    /// @param callbackData Byte data to send to callback\\n    function depositToken(uint256 amountToDeposit, bool isToken0, bytes memory callbackData) external;\\n\\n    /// @notice Withdraws deposited or swapped token0 or token1 to the owner.\\n    /// @param amountToClaim Amount to withdraw\\n    /// @param isToken0 Whether the claimable token is token0 or token1\\n    function claimToken(uint256 amountToClaim, bool isToken0) external;\\n\\n    /// @notice Finds the order id where the new order should be inserted to the right of\\n    /// Meant to be used off-chain to find the hintId for limit order creation functions\\n    /// @param priceBase basePrice derived from amount0Base and amount1Base\\n    /// @param isAsk Whether the new order is an ask order\\n    /// @return hintId The id of the order where the new order\\n    /// should be inserted to the right of\\n    function suggestHintId(uint64 priceBase, bool isAsk) external view returns (uint32);\\n\\n    /// @notice Returns the amount of token0 and token1 to traded between two limit orders\\n    /// @param takerOrderAmount0Base The amount0Base of the taker order\\n    /// @param takerOrderPriceBase The priceBase of the taker order\\n    /// @param makerOrderAmount0Base The amount0Base of the maker order\\n    /// @param makerOrderPriceBase The priceBase of the maker order\\n    /// @param isTakerAsk True if taker order is an ask\\n    /// @return amount0BaseReturn The amount0Base to be traded\\n    /// @return amount1BaseReturn The amount1Base to be traded\\n    function getLimitOrderSwapAmounts(\\n        uint64 takerOrderAmount0Base,\\n        uint64 takerOrderPriceBase,\\n        uint64 makerOrderAmount0Base,\\n        uint64 makerOrderPriceBase,\\n        bool isTakerAsk\\n    ) external pure returns (uint64, uint128);\\n\\n    /// @notice Returns the amount of token0 and token1 to traded between maker and swapper\\n    /// @param amount0 Exact token0 amount taker wants to trade\\n    /// @param isAsk True if swapper is an ask\\n    /// @param makerAmount0Base The amount0Base of the maker order\\n    /// @param makerPriceBase The priceBase of the maker order\\n    /// @return swapAmount0 The amount of token0 to be swapped\\n    /// @return swapAmount1 The amount of token1 to be swapped\\n    /// @return amount0BaseDelta Maker order baseAmount0 change\\n    /// @return fullTakerFill True if swapper can be fully filled by maker order\\n    function getSwapAmountsForToken0(\\n        uint256 amount0,\\n        bool isAsk,\\n        uint64 makerAmount0Base,\\n        uint64 makerPriceBase\\n    ) external view returns (uint256, uint256, uint64, bool);\\n\\n    /// @notice Returns the amount of token0 and token1 to traded between maker and swapper\\n    /// @param amount1 Exact token1 amount taker wants to trade\\n    /// @param isAsk True if swapper is an ask\\n    /// @param makerAmount0Base The amount0Base of the maker order\\n    /// @param makerPriceBase The priceBase of the maker order\\n    /// @return swapAmount0 The amount of token0 to be swapped\\n    /// @return swapAmount1 The amount of token1 to be swapped\\n    /// @return amount0BaseDelta Maker order baseAmount0 change\\n    /// @return fullTakerFill True if swapper can be fully filled by maker order\\n    function getSwapAmountsForToken1(\\n        uint256 amount1,\\n        bool isAsk,\\n        uint64 makerAmount0Base,\\n        uint64 makerPriceBase\\n    ) external view returns (uint256, uint256, uint64, bool);\\n\\n    /// @notice Returns price sorted limit orders with pagination\\n    /// @param startOrderId orderId from where the pagination should start (not inclusive)\\n    /// @dev caller can pass 0 to start from the top of the book\\n    /// @param isAsk Whether to return ask or bid orders\\n    /// @param limit Number number of orders to return in the page\\n    /// @return orderData The paginated order data\\n    function getPaginatedOrders(\\n        uint32 startOrderId,\\n        bool isAsk,\\n        uint32 limit\\n    ) external view returns (OrderQueryItem memory orderData);\\n\\n    /// @notice Returns the limit order of the given index\\n    /// @param isAsk Whether the order is an ask order\\n    /// @param id The id of the order\\n    /// @return order The limit order\\n    function getLimitOrder(bool isAsk, uint32 id) external view returns (LimitOrder memory);\\n\\n    /// @notice Returns whether an order is active or not\\n    /// @param id The id of the order\\n    /// @return isActive True if the order is active, false otherwise\\n    function isOrderActive(uint32 id) external view returns (bool);\\n\\n    /// @notice Returns whether an order is an ask order or not, fails if order is not active\\n    /// @param id The id of the order\\n    /// @return isAsk True if the order is an ask order, false otherwise\\n    function isAskOrder(uint32 id) external view returns (bool);\\n\\n    /// @notice Returns the constant for Log value of TickThreshold\\n    /// @return LOG10_TICK_THRESHOLD threshold for Log value of TickThreshold\\n    function LOG10_TICK_THRESHOLD() external view returns (uint8);\\n\\n    /// @notice Returns the constant for threshold value of orderId\\n    /// @return ORDER_ID_THRESHOLD threshold for threshold value of orderId\\n    function ORDER_ID_THRESHOLD() external view returns (uint32);\\n\\n    /// @notice Returns the constant for threshold value of creatorId\\n    /// @return CREATOR_ID_THRESHOLD threshold for threshold value of creatorId\\n    function CREATOR_ID_THRESHOLD() external view returns (uint32);\\n\\n    /// @notice The token0 (base token)\\n    /// @return token0 The token0 (base token) contract\\n    function token0() external view returns (IERC20Minimal);\\n\\n    /// @notice The token1 (quote token)\\n    /// @return token1 The token1 (quote token) contract\\n    function token1() external view returns (IERC20Minimal);\\n\\n    /// @notice Id of the order book\\n    /// @return orderBookId The unique identifier of an order book\\n    function orderBookId() external view returns (uint8);\\n\\n    /// @notice The sizeTick of the order book\\n    /// @return sizeTick The sizeTick of the order book\\n    function sizeTick() external view returns (uint128);\\n\\n    /// @notice The priceTick of the order book\\n    /// @return priceTick The priceTick of the order book\\n    function priceTick() external view returns (uint128);\\n\\n    /// @notice The priceMultiplier of the order book\\n    /// @return priceMultiplier The priceMultiplier of the order book\\n    function priceMultiplier() external view returns (uint128);\\n\\n    /// @notice The priceDivider of the order book\\n    /// @return priceDivider The priceMultiplier of the order book\\n    function priceDivider() external view returns (uint128);\\n\\n    /// @notice Returns the id of the next order Id to create\\n    /// @return orderIdCounter id of the next order\\n    function orderIdCounter() external view returns (uint32);\\n\\n    /// @notice minToken0BaseAmount minimum token0Base amount for limit order\\n    /// @return minToken0BaseAmount minToken0BaseAmount of the order book\\n    function minToken0BaseAmount() external view returns (uint64);\\n\\n    /// @notice minToken1BaseAmount minimum token1Base amount (token0Base * priceBase) for limit order\\n    /// @return minToken1BaseAmount minToken1BaseAmount of the order book\\n    function minToken1BaseAmount() external view returns (uint128);\\n\\n    /// @notice Claimable token0 amount for given address\\n    /// @return claimableToken0Balance Claimable token0 amount for given address\\n    function claimableToken0Balance(address owner) external view returns (uint256);\\n\\n    /// @notice Claimable token1 amount for given address\\n    /// @return claimableToken1Balance Claimable token1 amount for given address\\n    function claimableToken1Balance(address owner) external view returns (uint256);\\n\\n    /// @notice id of an order-owner\\n    /// @return addressToOwnerId id of an order-owner\\n    function addressToOwnerId(address owner) external view returns (uint32);\\n\\n    /// @notice address for given creatorId\\n    /// @return addressToCreatorId address for given creatorId\\n    function addressToCreatorId(address creatorAddress) external view returns (uint32);\\n\\n    /// @notice id of a creatorAddress\\n    /// @return creatorIdToAddress id of a creatorAddress\\n    function creatorIdToAddress(uint32 creatorId) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\n/// @title Errors\\n/// @notice Library containing errors that Lighter V2 Core functions may revert with\\nlibrary Errors {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      LIGHTER-V2-FACTORY\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when `msg.sender` is not the factory owner for setOwner or createOrderBook\\n    error LighterV2Factory_CallerNotOwner();\\n\\n    /// @notice Thrown when zero address is passed when setting the owner\\n    error LighterV2Factory_OwnerCannotBeZero();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      LIGHTER-V2-CREATE-ORDER-BOOK\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when token0 and token1 are identical or zero in order book creation\\n    error LighterV2CreateOrderBook_InvalidTokenPair();\\n\\n    /// @notice Thrown when an order book already exists with given token0 and token1 in order book creation\\n    error LighterV2CreateOrderBook_OrderBookAlreadyExists();\\n\\n    /// @notice Thrown when order book capacity is already reached in order book creation\\n    error LighterV2CreateOrderBook_OrderBookIdExceedsLimit();\\n\\n    /// @notice Thrown when invalid combination of logSizeTick and logPriceTick is given in order book creation\\n    error LighterV2CreateOrderBook_InvalidTickCombination();\\n\\n    /// @notice Thrown when invalid combination of minToken0BaseAmount and minToken1BaseAmount given in order book creation\\n    error LighterV2CreateOrderBook_InvalidMinAmount();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-V2-ORDER\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when invalid hintId is given in limit order creation\\n    error LighterV2Order_InvalidHintId();\\n\\n    /// @notice Thrown when given price is too small in order creation\\n    error LighterV2Order_PriceTooSmall();\\n\\n    /// @notice Thrown when given price is too big in order creation\\n    error LighterV2Order_PriceTooBig();\\n\\n    /// @notice Thrown when token0 or token1 amount is too small in limit order creation\\n    error LighterV2Order_AmountTooSmall();\\n\\n    /// @notice Thrown when order capacity is already reached in order creation\\n    error LighterV2Order_OrderIdExceedsLimit();\\n\\n    /// @notice Thrown when creator capacity is already reached in order creation\\n    error LighterV2Order_CreatorIdExceedsLimit();\\n\\n    /// @notice Thrown when tokens sent callback is insufficient in order creation or swap\\n    error LighterV2Order_InsufficentCallbackTransfer();\\n\\n    /// @notice Thrown when claimable balance is insufficient in order creation\\n    error LighterV2Order_InsufficientClaimableBalance();\\n\\n    /// @notice Thrown when FillOrKill order is not fully filled\\n    error LighterV2Order_FoKNotFilled();\\n\\n    /// @notice Thrown when contract balance decrease is larger than the transfered amount\\n    error LighterV2Base_ContractBalanceDoesNotMatchSentAmount();\\n\\n    /// @notice Thrown when caller is not the order creator or owner in order cancelation\\n    error LighterV2Owner_CallerCannotCancel();\\n\\n    /// @notice Thrown when caller tries to erase head or tail orders in order linked list\\n    error LighterV2Order_CannotEraseHeadOrTailOrders();\\n\\n    /// @notice Thrown when caller tries to cancel an order that is not active\\n    error LighterV2Order_CannotCancelInactiveOrders();\\n\\n    /// @notice Thrown when caller asks for order side for a inactive or non-existent order\\n    error LighterV2Order_OrderDoesNotExist();\\n\\n    /// @notice Thrown when caller tries to query an order book page starting from an inactive order\\n    error LighterV2Order_CannotQueryFromInactiveOrder();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-SWAP\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when order book does not have enough liquidity to fill the swap\\n    error LighterV2Swap_NotEnoughLiquidity();\\n\\n    /// @notice Thrown when swapper receives less than the minimum amount of tokens expected\\n    error LighterV2Swap_NotEnoughOutput();\\n\\n    /// @notice Thrown when swapper needs to pay more than the maximum amount of tokens they are willing to pay\\n    error LighterV2Swap_TooMuchRequested();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-V2-VAULT\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when caller tries to withdraw more than their balance or withdraw zero\\n    error LighterV2Vault_InvalidClaimAmount();\\n\\n    /// @notice Thrown when caller does not tranfer enough tokens to the vault when depositing\\n    error LighterV2Vault_InsufficentCallbackTransfer();\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-V2-FLASH-LOAN\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when caller does not tranfer enough tokens to repay for the flash loan\\n    error LighterV2FlashLoan_InsufficentCallbackTransfer();\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                  LIGHTER-V2-TOKEN-TRANSFER\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Thrown when token transfer from order book fails\\n    error LighterV2TokenTransfer_Failed();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LinkedList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport \\\"./Errors.sol\\\";\\nimport \\\"../interfaces/IOrderBook.sol\\\";\\n\\n/// @title LinkedList\\n/// @notice Struct to use for storing sorted linked lists of ask and bid orders\\nstruct LinkedList {\\n    mapping(uint32 => IOrderBook.LimitOrder) asks;\\n    mapping(uint32 => IOrderBook.LimitOrder) bids;\\n}\\n\\n/// @title LinkedListLib\\n/// @notice Implements a sorted linked list of limit orders and provides necessary functions for order management\\n/// @dev Head is represented by order id 0, tail is represented by order id 1\\nlibrary LinkedListLib {\\n    /// @notice Inserts an order into the respective linked list and keeps sorted order\\n    /// @param orderId id of the order to insert\\n    /// @param isAsk true if the order is an ask order, false if the order is a bid order\\n    /// @param hintId hint id of the order where the new order should be inserted to the right of\\n    function insert(LinkedList storage self, uint32 orderId, bool isAsk, uint32 hintId) internal {\\n        mapping(uint32 => IOrderBook.LimitOrder) storage orders = isAsk ? self.asks : self.bids;\\n        IOrderBook.LimitOrder storage order = orders[orderId];\\n\\n        if (orders[hintId].next == 0) {\\n            revert Errors.LighterV2Order_InvalidHintId();\\n        }\\n\\n        while (orders[hintId].ownerId == 0) {\\n            hintId = orders[hintId].next;\\n        }\\n\\n        // After the search, hintId will be where the new order should be inserted to the right of\\n        IOrderBook.LimitOrder memory hintOrder = orders[hintId];\\n        while (hintId != 1) {\\n            IOrderBook.LimitOrder memory nextOrder = orders[hintOrder.next];\\n            if (isAsk ? (order.priceBase < nextOrder.priceBase) : (order.priceBase > nextOrder.priceBase)) break;\\n            hintId = hintOrder.next;\\n            hintOrder = nextOrder;\\n        }\\n        while (hintId != 0) {\\n            if (isAsk ? (order.priceBase >= hintOrder.priceBase) : (order.priceBase <= hintOrder.priceBase)) break;\\n            hintId = hintOrder.prev;\\n            hintOrder = orders[hintId];\\n        }\\n\\n        order.prev = hintId;\\n        order.next = orders[hintId].next;\\n        orders[order.prev].next = orderId;\\n        orders[order.next].prev = orderId;\\n    }\\n\\n    /// @notice Removes given order id from the respective linked list\\n    /// @dev Updates the respective linked list but does not delete the order, sets the ownerId to 0 instead\\n    /// @param orderId The order id to remove\\n    /// @param isAsk true if the order is an ask order, false if the order is a bid order\\n    function erase(LinkedList storage self, uint32 orderId, bool isAsk) internal {\\n        if (orderId <= 1) {\\n            revert Errors.LighterV2Order_CannotEraseHeadOrTailOrders();\\n        }\\n\\n        mapping(uint32 => IOrderBook.LimitOrder) storage orders = isAsk ? self.asks : self.bids;\\n\\n        if (orders[orderId].ownerId == 0) {\\n            revert Errors.LighterV2Order_CannotCancelInactiveOrders();\\n        }\\n        IOrderBook.LimitOrder storage order = orders[orderId];\\n        order.ownerId = 0;\\n\\n        uint32 prev = order.prev;\\n        uint32 next = order.next;\\n        orders[prev].next = next;\\n        orders[next].prev = prev;\\n    }\\n\\n    /// @notice Returns a struct that represents order page with given parameters\\n    /// @param startOrderId The order id to start the pagination from (not inclusive)\\n    /// @param isAsk true if the paginated orders are ask orders, false if bid orders\\n    /// @param limit The number of orders to return\\n    /// @param ownerIdToAddress Mapping from owner id to owner address\\n    /// @param sizeTick The size tick of the order book\\n    /// @param priceTick The price tick of the order book\\n    function getPaginatedOrders(\\n        LinkedList storage self,\\n        uint32 startOrderId,\\n        bool isAsk,\\n        uint32 limit,\\n        mapping(uint32 => address) storage ownerIdToAddress,\\n        uint128 sizeTick,\\n        uint128 priceTick\\n    ) public view returns (IOrderBook.OrderQueryItem memory paginatedOrders) {\\n        mapping(uint32 => IOrderBook.LimitOrder) storage orders = isAsk ? self.asks : self.bids;\\n\\n        if (orders[startOrderId].ownerId == 0) {\\n            revert Errors.LighterV2Order_CannotQueryFromInactiveOrder();\\n        }\\n        uint32 i = 0;\\n        paginatedOrders.ids = new uint32[](limit);\\n        paginatedOrders.owners = new address[](limit);\\n        paginatedOrders.amount0s = new uint256[](limit);\\n        paginatedOrders.prices = new uint256[](limit);\\n        for (uint32 pointer = orders[startOrderId].next; pointer != 1 && i < limit; pointer = orders[pointer].next) {\\n            IOrderBook.LimitOrder memory order = orders[pointer];\\n            paginatedOrders.ids[i] = pointer;\\n            paginatedOrders.owners[i] = ownerIdToAddress[order.ownerId];\\n            paginatedOrders.amount0s[i] = uint256(order.amount0Base) * sizeTick;\\n            paginatedOrders.prices[i] = order.priceBase * priceTick;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        paginatedOrders.isAsk = isAsk;\\n    }\\n\\n    /// @notice Finds the order id where the order with given price should be inserted to the right of\\n    /// @param priceBase The priceBase to suggest the hintId for\\n    /// @return hintId The order id where the order with given price should be inserted to the right of\\n    function suggestHintId(LinkedList storage self, uint64 priceBase, bool isAsk) public view returns (uint32) {\\n        mapping(uint32 => IOrderBook.LimitOrder) storage orders = isAsk ? self.asks : self.bids;\\n        uint32 hintOrderId = 0;\\n        IOrderBook.LimitOrder memory hintOrder = orders[hintOrderId];\\n        while (hintOrderId != 1) {\\n            IOrderBook.LimitOrder memory nextOrder = orders[hintOrder.next];\\n            if (isAsk ? (priceBase < nextOrder.priceBase) : (priceBase > nextOrder.priceBase)) break;\\n            hintOrderId = hintOrder.next;\\n            hintOrder = nextOrder;\\n        }\\n        return hintOrderId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OrderBookDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\nimport \\\"../OrderBook.sol\\\";\\n\\n/// @title OrderBookDeployLib\\n/// @notice Deploys a new order book and initializes it with given arguments\\nlibrary OrderBookDeployerLib {\\n    /// @notice Deploys a new order book and initializes it with given arguments\\n    /// @param orderBookId Id of the order book\\n    /// @param token0 address of token0 (base token)\\n    /// @param token1 address of token1 (quote token)\\n    /// @param logSizeTick log10 of sizeTick\\n    /// @param logPriceTick log10 of priceTick\\n    /// @param minToken0BaseAmount minimum token0 base amount for limit order creations\\n    /// @param minToken1BaseAmount minimum token1 base amount for limit order creations\\n    /// @return orderBookAddress address of the deployed order book\\n    function deployOrderBook(\\n        uint8 orderBookId,\\n        address token0,\\n        address token1,\\n        uint8 logSizeTick,\\n        uint8 logPriceTick,\\n        uint64 minToken0BaseAmount,\\n        uint128 minToken1BaseAmount\\n    ) external returns (address) {\\n        return\\n            address(\\n                new OrderBook(\\n                    orderBookId,\\n                    token0,\\n                    token1,\\n                    logSizeTick,\\n                    logPriceTick,\\n                    minToken0BaseAmount,\\n                    minToken1BaseAmount\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"./interfaces/IOrderBook.sol\\\";\\nimport \\\"./interfaces/ILighterV2FlashCallback.sol\\\";\\nimport \\\"./interfaces/ILighterV2TransferCallback.sol\\\";\\n\\nimport \\\"./libraries/LinkedList.sol\\\";\\nimport \\\"./libraries/Errors.sol\\\";\\nimport {IERC20Minimal} from \\\"./interfaces/external/IERC20Minimal.sol\\\";\\n\\n/**\\n * @title Order Book\\n * @notice Contract representing an order book for trading token pairs. It manages\\n * the creation and interaction of orders, and tracks various parameters related\\n * to order management.\\n * @notice OrderBook can handle different types of orders and order-life-cycle management\\n * @notice User can swap tokens in the order book via direct call on orderBook or via router\\n * @dev for direct order book interaction of order-creation and token-swap, ensure the caller\\n *      has implemented the callback interface to handle payments\\n */\\ncontract OrderBook is IOrderBook, ReentrancyGuard {\\n    /// @dev Limits the value for size and price ticks\\n    uint8 public constant LOG10_TICK_THRESHOLD = 38;\\n\\n    /// @dev Limits the total number of orders that can be created\\n    uint32 public constant ORDER_ID_THRESHOLD = (1 << 32) - 1;\\n\\n    /// @dev Limits the unique number of creators, which are smart contracts\\n    /// that call the order book and implements the callback interfaces\\n    uint32 public constant CREATOR_ID_THRESHOLD = (1 << 31) - 1;\\n\\n    uint64 public constant MAX_PRICE = type(uint64).max;\\n\\n    // Using the LinkedListLib for order management\\n    using LinkedListLib for LinkedList;\\n\\n    /// @notice The ERC20 token used as token0 in the trading pair\\n    IERC20Minimal public immutable token0;\\n\\n    /// @notice The ERC20 token used as token1 in the trading pair\\n    IERC20Minimal public immutable token1;\\n\\n    /// @notice The id of the order book\\n    uint8 public immutable orderBookId;\\n\\n    /// @notice The minimum base token0 amount required for an order to be valid\\n    uint64 public immutable minToken0BaseAmount;\\n\\n    /// @notice The minimum base token1 amount required for an order to be valid (token0Base * priceBase)\\n    uint128 public immutable minToken1BaseAmount;\\n\\n    /// @notice The step size for token0 amounts\\n    uint128 public immutable sizeTick;\\n\\n    /// @notice The step size for unit token0 price\\n    uint128 public immutable priceTick;\\n\\n    /// @notice The multiplier used for calculating the amount1 from priceBase and amount0Base\\n    uint128 public immutable priceMultiplier;\\n\\n    /// @notice The divider used for calculating the amount1 from priceBase and amount0Base\\n    uint128 public immutable priceDivider;\\n\\n    /// @dev The id of the next order to be created, also used for setting ownerId and creatorId for gas efficiency\\n    uint32 public orderIdCounter;\\n\\n    /// @notice The data structure used for storing the active orders\\n    /// @dev If an ask order, book needs to store at least amount0Base * sizeTick amount of token0. If a bid order,\\n    /// book needs to store at least amount0Base * priceMultiplier * sizeTick / priceDivider amount of token1\\n    LinkedList private _orders;\\n\\n    /// @notice Mapping from address to claimable token0 balance\\n    mapping(address => uint256) public claimableToken0Balance;\\n\\n    /// @notice Mapping from address to claimable token1 balance\\n    mapping(address => uint256) public claimableToken1Balance;\\n\\n    /// @notice Mapping from ownerId to address\\n    mapping(uint32 => address) public ownerIdToAddress;\\n\\n    /// @notice Mapping from address to ownerId\\n    mapping(address => uint32) public addressToOwnerId;\\n\\n    /// @notice Mapping from address to creatorId\\n    mapping(address => uint32) public addressToCreatorId;\\n\\n    /// @notice Mapping from creatorId to address\\n    mapping(uint32 => address) public creatorIdToAddress;\\n\\n    /// @notice A struct containing variables used for order matching.\\n    struct MatchOrderLocalVars {\\n        uint32 index; // id of the maker order being matched\\n        address makerAddress; // owner address of the maker order\\n        uint256 filledAmount0; // Amount of token0 already filled in the taker order\\n        uint256 filledAmount1; // Amount of token1 already filled in the taker order\\n        uint256 amount; // Exact amount of tokens to be sent or received in a swap\\n        uint64 makerAmount0BaseChange; // Maker order amont0Base change\\n        uint256 swapAmount0; // Amount of token0 to be swaped with maker order\\n        uint256 swapAmount1; // Amount of token1 to be swaped with maker order\\n        uint64 swapAmount0Base; // Base amount of token0 to be swaped with maker order\\n        uint128 swapAmount1Base; // Base amount of token1 to be swaped with maker order\\n        bool atLeastOneFullSwap; // Flag indicating if taker took at least one maker order fully\\n        bool fullTakerFill; // Flag indicating if taker order is fully filled\\n        uint32 swapCount; // Count of swaps performed\\n        uint32 swapCapacity; // Capacity swaps array\\n        SwapData[] swaps; // Array of swap data\\n    }\\n\\n    /// @notice A struct containing payment-related data for order and swap operations.\\n    struct PaymentData {\\n        bool isAsk; // Flag indicating if the taker order is an ask order\\n        bool isPerfMode; // Flag indicating if the taker order is a performance limit order\\n        address recipient; // Recipient address for payments\\n        uint256 filledAmount0; // Total amount of token0 in the swaps\\n        uint256 filledAmount1; // Total amount of token1 in the swaps\\n        uint256 remainingLimitOrderAmount; // Amount taker needs to pay for unmatched part of their limit order\\n        uint32 swapCount; // Count of swaps performed\\n        SwapData[] swaps; // Array of swap data\\n        bytes callbackData; // Additional callback data for payment.\\n    }\\n\\n    /// @dev Struct that holds swap data during matching\\n    struct SwapData {\\n        address makerAddress; // Address of the owner of the matched order\\n        uint256 swapAmount; // Amount of tokens matched in the order\\n        bool isPerfMode; // Flag indicating if the order is in performance mode\\n    }\\n\\n    /// @notice Contract constructor\\n    /// @param _orderBookId The id of the order book\\n    /// @param _token0Address The base token address\\n    /// @param _token1Address The quote token address\\n    /// @param _logSizeTick log10 of base token tick, size of the base token\\n    /// should be multiples of 10**logSizeTick for limit orders\\n    /// @param _logPriceTick log10 of price tick, price of unit base token\\n    /// should be multiples of 10**logPriceTick for limit orders\\n    /// @param _minToken0BaseAmount minimum token0Base amount for limit orders\\n    /// @param _minToken1BaseAmount minimum token1Base amount (token0Base * priceBase) for limit orders\\n    /// @dev Initializes the contract and linked lists with provided parameters\\n    constructor(\\n        uint8 _orderBookId,\\n        address _token0Address,\\n        address _token1Address,\\n        uint8 _logSizeTick,\\n        uint8 _logPriceTick,\\n        uint64 _minToken0BaseAmount,\\n        uint128 _minToken1BaseAmount\\n    ) {\\n        token0 = IERC20Minimal(_token0Address);\\n        token1 = IERC20Minimal(_token1Address);\\n        orderBookId = _orderBookId;\\n        uint8 token0Decimals = token0.decimals();\\n\\n        if (_logSizeTick >= LOG10_TICK_THRESHOLD || _logPriceTick >= LOG10_TICK_THRESHOLD) {\\n            revert Errors.LighterV2CreateOrderBook_InvalidTickCombination();\\n        }\\n\\n        sizeTick = uint128(10 ** _logSizeTick);\\n        priceTick = uint128(10 ** _logPriceTick);\\n        uint128 priceMultiplierCheck = 1;\\n        uint128 priceDividerCheck = 1;\\n        if (_logSizeTick + _logPriceTick >= token0Decimals) {\\n            if (_logSizeTick + _logPriceTick - token0Decimals >= LOG10_TICK_THRESHOLD) {\\n                revert Errors.LighterV2CreateOrderBook_InvalidTickCombination();\\n            }\\n            priceMultiplierCheck = uint128(10 ** (_logSizeTick + _logPriceTick - token0Decimals));\\n        } else {\\n            if (token0Decimals - _logSizeTick - _logPriceTick >= LOG10_TICK_THRESHOLD) {\\n                revert Errors.LighterV2CreateOrderBook_InvalidTickCombination();\\n            }\\n            priceDividerCheck = uint128(10 ** (token0Decimals - _logPriceTick - _logSizeTick));\\n        }\\n\\n        priceMultiplier = priceMultiplierCheck;\\n        priceDivider = priceDividerCheck;\\n\\n        if (_minToken0BaseAmount == 0 || _minToken1BaseAmount == 0) {\\n            revert Errors.LighterV2CreateOrderBook_InvalidMinAmount();\\n        }\\n        minToken0BaseAmount = _minToken0BaseAmount;\\n        minToken1BaseAmount = _minToken1BaseAmount;\\n\\n        // Create the head node for asks linked list, this node can not be deleted\\n        _orders.asks[0] = LimitOrder({\\n            prev: 0,\\n            next: 1,\\n            perfMode_creatorId: 0,\\n            ownerId: 1,\\n            amount0Base: 0,\\n            priceBase: 0\\n        });\\n        // Create the tail node for asks linked list, this node can not be deleted\\n        _orders.asks[1] = LimitOrder({\\n            prev: 0,\\n            next: 1,\\n            perfMode_creatorId: 0,\\n            ownerId: 1,\\n            amount0Base: 0,\\n            priceBase: MAX_PRICE\\n        });\\n        // Create the head node for bids linked list, this node can not be deleted\\n        _orders.bids[0] = LimitOrder({\\n            prev: 0,\\n            next: 1,\\n            perfMode_creatorId: 0,\\n            ownerId: 1,\\n            amount0Base: 0,\\n            priceBase: MAX_PRICE\\n        });\\n        // Create the tail node for bids linked list, this node can not be deleted\\n        _orders.bids[1] = LimitOrder({\\n            prev: 0,\\n            next: 1,\\n            perfMode_creatorId: 0,\\n            ownerId: 1,\\n            amount0Base: 0,\\n            priceBase: 0\\n        });\\n        // Id 0 and 1 are used for heads and tails. Next order should start from id 2\\n        orderIdCounter = 2;\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function createOrder(\\n        uint64 amount0Base,\\n        uint64 priceBase,\\n        bool isAsk,\\n        address owner,\\n        uint32 hintId,\\n        OrderType orderType,\\n        bytes memory callbackData\\n    ) external override nonReentrant returns (uint32 newOrderId) {\\n        newOrderId = orderIdCounter;\\n\\n        // For every order type, the amount0Base needs to be at least 1\\n        if (amount0Base == 0) {\\n            revert Errors.LighterV2Order_AmountTooSmall();\\n        }\\n\\n        // priceBase needs to be at least priceDivider\\n        // this guarantees that any increase of amount0Base will increase amount1 by at least 1\\n        // as priceDivider is guaranteed to be at least 1, an error is always thrown if priceBase = 0,\\n        // which is reserved for the dummy order with id 0\\n        if (priceBase < priceDivider) {\\n            revert Errors.LighterV2Order_PriceTooSmall();\\n        }\\n\\n        // do not allow orders with the max price, as the price is reserved for the big dummy order.\\n        // this is required so no order is inserted after the dummy order with id 1\\n        if (priceBase == MAX_PRICE) {\\n            revert Errors.LighterV2Order_PriceTooBig();\\n        }\\n\\n        if (orderType == OrderType.LimitOrder || orderType == OrderType.PerformanceLimitOrder) {\\n            if (hintId >= newOrderId) {\\n                revert Errors.LighterV2Order_InvalidHintId();\\n            }\\n            if ((amount0Base < minToken0BaseAmount || priceBase * amount0Base < minToken1BaseAmount)) {\\n                revert Errors.LighterV2Order_AmountTooSmall();\\n            }\\n        }\\n\\n        LimitOrder memory newOrder;\\n\\n        {\\n            if (newOrderId >= ORDER_ID_THRESHOLD) {\\n                revert Errors.LighterV2Order_OrderIdExceedsLimit();\\n            }\\n\\n            orderIdCounter = newOrderId + 1;\\n\\n            newOrder = LimitOrder({\\n                perfMode_creatorId: 0, // Only set if order needs to be inserted into the order book\\n                prev: 0, // Only set if order needs to be inserted into the order book\\n                next: 0, // Only set if order needs to be inserted into the order book\\n                ownerId: 0, // Only set if order needs to be inserted into the order book\\n                amount0Base: amount0Base,\\n                priceBase: priceBase\\n            });\\n\\n            emit CreateOrder(owner, newOrderId, amount0Base, priceBase, isAsk, orderType);\\n        }\\n\\n        (uint256 filledAmount0, uint256 filledAmount1, uint32 swapCount, SwapData[] memory swaps) = _matchOrder(\\n            newOrder,\\n            newOrderId,\\n            owner,\\n            isAsk\\n        );\\n        // Short circuit payments if Fill or Kill order is not fully filled and needs to be killed\\n        if (orderType == OrderType.FoKOrder && newOrder.amount0Base > 0) {\\n            revert Errors.LighterV2Order_FoKNotFilled();\\n        }\\n\\n        // Computes the amount caller needs to pay for remaning part of their limit order\\n        uint256 remainingLimitOrderAmount = 0;\\n        if (\\n            (orderType == OrderType.LimitOrder || orderType == OrderType.PerformanceLimitOrder) &&\\n            newOrder.amount0Base > 0\\n        ) {\\n            remainingLimitOrderAmount = (isAsk)\\n                ? (uint256(newOrder.amount0Base) * sizeTick)\\n                : (uint256(newOrder.amount0Base) * newOrder.priceBase * priceMultiplier) / priceDivider;\\n        }\\n\\n        // Handle token transfers between makers and takers and for remainingLimitOrderAmount\\n        if (\\n            filledAmount0 > 0 ||\\n            filledAmount1 > 0 ||\\n            orderType == OrderType.LimitOrder ||\\n            orderType == OrderType.PerformanceLimitOrder\\n        ) {\\n            _handlePayments(\\n                PaymentData(\\n                    isAsk,\\n                    orderType == OrderType.PerformanceLimitOrder,\\n                    owner,\\n                    filledAmount0,\\n                    filledAmount1,\\n                    remainingLimitOrderAmount,\\n                    swapCount,\\n                    swaps,\\n                    callbackData\\n                )\\n            );\\n        }\\n\\n        // If the order is not fully filled, set remaining value in newOrder and insert it into respective order book\\n        if (remainingLimitOrderAmount > 0) {\\n            // Get the ownerId if exists, otherwise set the ownerId using the from address\\n            newOrder.ownerId = addressToOwnerId[owner];\\n            if (newOrder.ownerId == 0) {\\n                newOrder.ownerId = newOrderId;\\n                addressToOwnerId[owner] = newOrder.ownerId;\\n                ownerIdToAddress[newOrderId] = owner;\\n            }\\n\\n            // creatorId can only be non-zero if msg.sender different from the owner and order is a limit order\\n            if (msg.sender != owner) {\\n                newOrder.perfMode_creatorId = addressToCreatorId[msg.sender];\\n                if (newOrder.perfMode_creatorId == 0) {\\n                    // LimitOrder stores 31 bits for the creator id, only allow setting a non-zero creator id if it's below the limit\\n                    if (newOrderId >= CREATOR_ID_THRESHOLD) {\\n                        revert Errors.LighterV2Order_CreatorIdExceedsLimit();\\n                    }\\n                    newOrder.perfMode_creatorId = newOrderId;\\n                    addressToCreatorId[msg.sender] = newOrder.perfMode_creatorId;\\n                    creatorIdToAddress[newOrder.perfMode_creatorId] = msg.sender;\\n                }\\n                newOrder.perfMode_creatorId <<= 1;\\n            }\\n\\n            if (orderType == OrderType.PerformanceLimitOrder) {\\n                newOrder.perfMode_creatorId = newOrder.perfMode_creatorId | 1;\\n            }\\n\\n            if (isAsk) {\\n                _orders.asks[newOrderId] = newOrder;\\n                _orders.insert(newOrderId, isAsk, hintId);\\n            } else {\\n                _orders.bids[newOrderId] = newOrder;\\n                _orders.insert(newOrderId, isAsk, hintId);\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function cancelLimitOrder(uint32 id, address owner) external override nonReentrant returns (bool) {\\n        if (!isOrderActive(id)) {\\n            return false;\\n        }\\n\\n        LimitOrder memory order;\\n\\n        bool isAsk = isAskOrder(id);\\n        if (isAsk) {\\n            order = _orders.asks[id];\\n        } else {\\n            order = _orders.bids[id];\\n        }\\n\\n        address _owner = ownerIdToAddress[order.ownerId];\\n        uint32 creatorId = (order.perfMode_creatorId >> 1);\\n        address creator = _owner;\\n        if (creatorId != 0) {\\n            creator = creatorIdToAddress[creatorId];\\n        }\\n\\n        // only the creator or the owner can cancel the order\\n        if ((owner != _owner) || (msg.sender != creator && msg.sender != _owner)) {\\n            revert Errors.LighterV2Owner_CallerCannotCancel();\\n        }\\n\\n        emit CancelLimitOrder(id);\\n\\n        if (isAsk) {\\n            uint256 amount0 = uint256(order.amount0Base) * sizeTick;\\n            bool success = false;\\n            if ((order.perfMode_creatorId & 1) == 0) {\\n                success = _sendToken(token0, _owner, amount0);\\n            }\\n            if (!success) {\\n                claimableToken0Balance[_owner] += amount0;\\n                if ((order.perfMode_creatorId & 1) == 0) {\\n                    emit ClaimableBalanceIncrease(_owner, amount0, true);\\n                }\\n            }\\n            _orders.erase(id, isAsk);\\n        } else {\\n            uint256 amount1 = ((uint256(order.amount0Base) * order.priceBase) * priceMultiplier) / priceDivider;\\n            bool success = false;\\n            if ((order.perfMode_creatorId & 1) == 0) {\\n                success = _sendToken(token1, _owner, amount1);\\n            }\\n            if (!success) {\\n                claimableToken1Balance[_owner] += amount1;\\n                if ((order.perfMode_creatorId & 1) == 0) {\\n                    emit ClaimableBalanceIncrease(_owner, amount1, false);\\n                }\\n            }\\n            _orders.erase(id, isAsk);\\n        }\\n        return true;\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function swapExactSingle(\\n        bool isAsk,\\n        bool isExactInput,\\n        uint256 exactAmount,\\n        uint256 expectedAmount,\\n        address recipient,\\n        bytes memory callbackData\\n    ) external override nonReentrant returns (uint256, uint256) {\\n        (uint256 filledAmount0, uint256 filledAmount1, uint32 swapCount, SwapData[] memory swaps) = _matchSwapOrder(\\n            isAsk,\\n            isExactInput,\\n            exactAmount,\\n            expectedAmount,\\n            recipient\\n        );\\n\\n        _handlePayments(\\n            PaymentData(isAsk, false, recipient, filledAmount0, filledAmount1, 0, swapCount, swaps, callbackData)\\n        );\\n\\n        emit SwapExactAmount(msg.sender, recipient, isExactInput, isAsk, filledAmount0, filledAmount1);\\n\\n        return (filledAmount0, filledAmount1);\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function flashLoan(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata callbackData\\n    ) external override nonReentrant {\\n        uint256 orderBookToken0BalanceBeforeLoan = token0.balanceOf(address(this));\\n        uint256 orderBookToken1BalanceBeforeLoan = token1.balanceOf(address(this));\\n\\n        if (amount0 > 0 && !_sendToken(token0, recipient, amount0)) {\\n            revert Errors.LighterV2TokenTransfer_Failed();\\n        }\\n\\n        if (amount1 > 0 && !_sendToken(token1, recipient, amount1)) {\\n            revert Errors.LighterV2TokenTransfer_Failed();\\n        }\\n\\n        ILighterV2FlashCallback(msg.sender).flashLoanCallback(callbackData);\\n\\n        if (token0.balanceOf(address(this)) < orderBookToken0BalanceBeforeLoan) {\\n            revert Errors.LighterV2FlashLoan_InsufficentCallbackTransfer();\\n        }\\n\\n        if (token1.balanceOf(address(this)) < orderBookToken1BalanceBeforeLoan) {\\n            revert Errors.LighterV2FlashLoan_InsufficentCallbackTransfer();\\n        }\\n\\n        emit FlashLoan(msg.sender, recipient, amount0, amount1);\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function depositToken(\\n        uint256 amountToDeposit,\\n        bool isToken0,\\n        bytes memory callbackData\\n    ) external override nonReentrant {\\n        address owner = msg.sender;\\n        IERC20Minimal token = isToken0 ? token0 : token1;\\n        uint256 balanceBefore = token.balanceOf(address(this));\\n\\n        ILighterV2TransferCallback(owner).lighterV2TransferCallback(amountToDeposit, token, callbackData);\\n\\n        if (token.balanceOf(address(this)) < balanceBefore + amountToDeposit) {\\n            revert Errors.LighterV2Vault_InsufficentCallbackTransfer();\\n        }\\n        if (isToken0) {\\n            claimableToken0Balance[owner] += amountToDeposit;\\n        } else {\\n            claimableToken1Balance[owner] += amountToDeposit;\\n        }\\n        emit ClaimableBalanceIncrease(owner, amountToDeposit, isToken0);\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function claimToken(uint256 amountToClaim, bool isToken0) external override nonReentrant {\\n        address owner = msg.sender;\\n        uint256 amount = isToken0 ? claimableToken0Balance[owner] : claimableToken1Balance[owner];\\n        if (amountToClaim > 0 && amountToClaim <= amount) {\\n            if (isToken0) {\\n                claimableToken0Balance[owner] -= amountToClaim;\\n                if (!_sendToken(token0, owner, amountToClaim)) {\\n                    revert Errors.LighterV2TokenTransfer_Failed();\\n                }\\n            } else {\\n                claimableToken1Balance[owner] -= amountToClaim;\\n                if (!_sendToken(token1, owner, amountToClaim)) {\\n                    revert Errors.LighterV2TokenTransfer_Failed();\\n                }\\n            }\\n            emit ClaimableBalanceDecrease(owner, amountToClaim, isToken0);\\n        } else {\\n            revert Errors.LighterV2Vault_InvalidClaimAmount();\\n        }\\n    }\\n\\n    /// @dev Matches the given limit order against the available maker orders.\\n    /// @param order The taker order to be matched\\n    /// @param orderId The id of the taker order\\n    /// @param isAsk Indicates whether the taker order is an ask order or not\\n    /// @return filledAmount0 The total amount of token0 swapped in matching\\n    /// @return filledAmount1 The total amount of token1 swapped in matching\\n    /// @return swapCount The count of swaps performed\\n    /// @return swaps The array that contains data of swaps performed\\n    function _matchOrder(\\n        LimitOrder memory order,\\n        uint32 orderId,\\n        address owner,\\n        bool isAsk\\n    ) internal returns (uint256, uint256, uint32, SwapData[] memory) {\\n        MatchOrderLocalVars memory matchOrderLocalVars;\\n\\n        mapping(uint32 => LimitOrder) storage makerOrders = isAsk ? _orders.bids : _orders.asks;\\n\\n        matchOrderLocalVars.index = makerOrders[0].next;\\n\\n        while (matchOrderLocalVars.index != 1 && order.amount0Base > 0) {\\n            LimitOrder storage bestOrder = makerOrders[matchOrderLocalVars.index];\\n            matchOrderLocalVars.makerAddress = ownerIdToAddress[bestOrder.ownerId];\\n            (matchOrderLocalVars.swapAmount0Base, matchOrderLocalVars.swapAmount1Base) = getLimitOrderSwapAmounts(\\n                order.amount0Base,\\n                order.priceBase,\\n                bestOrder.amount0Base,\\n                bestOrder.priceBase,\\n                isAsk\\n            );\\n\\n            if (matchOrderLocalVars.swapAmount0Base == 0 || matchOrderLocalVars.swapAmount1Base == 0) break;\\n\\n            matchOrderLocalVars.swapAmount0 = uint256(matchOrderLocalVars.swapAmount0Base) * sizeTick;\\n            matchOrderLocalVars.swapAmount1 =\\n                (uint256(matchOrderLocalVars.swapAmount1Base) * priceMultiplier) /\\n                priceDivider;\\n\\n            if (isAsk) {\\n                emit Swap(\\n                    orderId,\\n                    matchOrderLocalVars.index,\\n                    owner,\\n                    matchOrderLocalVars.makerAddress,\\n                    matchOrderLocalVars.swapAmount0,\\n                    matchOrderLocalVars.swapAmount1\\n                );\\n            } else {\\n                emit Swap(\\n                    matchOrderLocalVars.index,\\n                    orderId,\\n                    matchOrderLocalVars.makerAddress,\\n                    owner,\\n                    matchOrderLocalVars.swapAmount0,\\n                    matchOrderLocalVars.swapAmount1\\n                );\\n            }\\n\\n            matchOrderLocalVars.filledAmount0 = matchOrderLocalVars.filledAmount0 + matchOrderLocalVars.swapAmount0;\\n            matchOrderLocalVars.filledAmount1 = matchOrderLocalVars.filledAmount1 + matchOrderLocalVars.swapAmount1;\\n\\n            // if there are not enough free slots in the matchOrderLocalVars.matchedOrders, increase size to accommodate\\n            if (matchOrderLocalVars.swapCount == matchOrderLocalVars.swapCapacity) {\\n                // initial capacity will be 4, and we'll double afterwards\\n                uint32 newCapacity = 4;\\n                if (matchOrderLocalVars.swapCapacity != 0) {\\n                    newCapacity = matchOrderLocalVars.swapCapacity * 2;\\n                }\\n\\n                SwapData[] memory newSwaps = new SwapData[](newCapacity);\\n                for (uint32 i = 0; i < matchOrderLocalVars.swapCapacity; i += 1) {\\n                    newSwaps[i] = matchOrderLocalVars.swaps[i];\\n                }\\n\\n                matchOrderLocalVars.swaps = newSwaps;\\n                matchOrderLocalVars.swapCapacity = newCapacity;\\n            }\\n\\n            matchOrderLocalVars.swaps[matchOrderLocalVars.swapCount++] = SwapData({\\n                makerAddress: matchOrderLocalVars.makerAddress,\\n                isPerfMode: (bestOrder.perfMode_creatorId & 1 == 1),\\n                swapAmount: isAsk ? matchOrderLocalVars.swapAmount0 : matchOrderLocalVars.swapAmount1\\n            });\\n\\n            order.amount0Base = order.amount0Base - matchOrderLocalVars.swapAmount0Base;\\n\\n            if (bestOrder.amount0Base == matchOrderLocalVars.swapAmount0Base) {\\n                // Remove the best bid from the order book if it is fully filled\\n                matchOrderLocalVars.atLeastOneFullSwap = true;\\n                bestOrder.ownerId = 0;\\n            } else {\\n                // Update the best bid if it is partially filled\\n                bestOrder.amount0Base = bestOrder.amount0Base - matchOrderLocalVars.swapAmount0Base;\\n                break;\\n            }\\n\\n            matchOrderLocalVars.index = bestOrder.next;\\n        }\\n        if (matchOrderLocalVars.atLeastOneFullSwap) {\\n            makerOrders[matchOrderLocalVars.index].prev = 0;\\n            makerOrders[0].next = matchOrderLocalVars.index;\\n        }\\n\\n        return (\\n            matchOrderLocalVars.filledAmount0,\\n            matchOrderLocalVars.filledAmount1,\\n            matchOrderLocalVars.swapCount,\\n            matchOrderLocalVars.swaps\\n        );\\n    }\\n\\n    /// @dev Matches the given swap request (market order) against the available maker orders.\\n    /// @param isAsk Indicates whether the swap request is an ask order or not\\n    /// @param isExactInput Indicates whether the swapper indicated exact input or output\\n    /// @param exactAmount The exact amount swapper wants to receive or send depending on isExactInput\\n    /// @param thresholdAmount The minimum amount to be received or maximum amount to be sent\\n    /// @param recipient The recipient address for swaps\\n    /// @return filledAmount0 The total amount of token0 swapped in matching\\n    /// @return filledAmount1 The total amount of token1 swapped in matching\\n    /// @return swapCount The count of swaps performed\\n    /// @return swaps The array that contains data of swaps performed\\n    function _matchSwapOrder(\\n        bool isAsk,\\n        bool isExactInput,\\n        uint256 exactAmount,\\n        uint256 thresholdAmount,\\n        address recipient\\n    ) internal returns (uint256, uint256, uint32, SwapData[] memory) {\\n        MatchOrderLocalVars memory matchOrderLocalVars;\\n        mapping(uint32 => LimitOrder) storage makerOrders = isAsk ? _orders.bids : _orders.asks;\\n        matchOrderLocalVars.amount = exactAmount;\\n        matchOrderLocalVars.index = makerOrders[0].next;\\n        matchOrderLocalVars.fullTakerFill = exactAmount == 0;\\n\\n        while (matchOrderLocalVars.index != 1 && !matchOrderLocalVars.fullTakerFill) {\\n            LimitOrder storage bestMatch = makerOrders[matchOrderLocalVars.index];\\n\\n            (\\n                matchOrderLocalVars.swapAmount0,\\n                matchOrderLocalVars.swapAmount1,\\n                matchOrderLocalVars.makerAmount0BaseChange,\\n                matchOrderLocalVars.fullTakerFill\\n            ) = (isExactInput && isAsk) || (!isExactInput && !isAsk)\\n                ? getSwapAmountsForToken0(matchOrderLocalVars.amount, isAsk, bestMatch.amount0Base, bestMatch.priceBase)\\n                : getSwapAmountsForToken1(\\n                    matchOrderLocalVars.amount,\\n                    isAsk,\\n                    bestMatch.amount0Base,\\n                    bestMatch.priceBase\\n                );\\n\\n            // If the swap amount is 0, break the loop since next orders guaranteed to have 0 as well\\n            if (matchOrderLocalVars.swapAmount0 == 0 || matchOrderLocalVars.swapAmount1 == 0) break;\\n\\n            if (isAsk) {\\n                emit Swap(\\n                    0, // emit 0 id for swap requests (market order)\\n                    matchOrderLocalVars.index,\\n                    recipient,\\n                    ownerIdToAddress[bestMatch.ownerId],\\n                    matchOrderLocalVars.swapAmount0,\\n                    matchOrderLocalVars.swapAmount1\\n                );\\n            } else {\\n                emit Swap(\\n                    matchOrderLocalVars.index,\\n                    0, // emit 0 id for swap requests (market order)\\n                    ownerIdToAddress[bestMatch.ownerId],\\n                    recipient,\\n                    matchOrderLocalVars.swapAmount0,\\n                    matchOrderLocalVars.swapAmount1\\n                );\\n            }\\n\\n            matchOrderLocalVars.filledAmount0 += matchOrderLocalVars.swapAmount0;\\n            matchOrderLocalVars.filledAmount1 += matchOrderLocalVars.swapAmount1;\\n\\n            // if there are not enough free slots in the matchOrderLocalVars.swaps, increase size to accommodate\\n            if (matchOrderLocalVars.swapCount == matchOrderLocalVars.swapCapacity) {\\n                // initial capacity will be 4, and we'll double afterwards\\n                uint32 newCapacity = 4;\\n                if (matchOrderLocalVars.swapCapacity != 0) {\\n                    newCapacity = matchOrderLocalVars.swapCapacity * 2;\\n                }\\n\\n                SwapData[] memory newSwaps = new SwapData[](newCapacity);\\n                for (uint32 i = 0; i < matchOrderLocalVars.swapCapacity; i += 1) {\\n                    newSwaps[i] = matchOrderLocalVars.swaps[i];\\n                }\\n\\n                matchOrderLocalVars.swaps = newSwaps;\\n                matchOrderLocalVars.swapCapacity = newCapacity;\\n            }\\n\\n            matchOrderLocalVars.swaps[matchOrderLocalVars.swapCount++] = SwapData({\\n                makerAddress: ownerIdToAddress[bestMatch.ownerId],\\n                isPerfMode: (bestMatch.perfMode_creatorId & 1 == 1),\\n                swapAmount: isAsk ? matchOrderLocalVars.swapAmount0 : matchOrderLocalVars.swapAmount1\\n            });\\n\\n            if (bestMatch.amount0Base == matchOrderLocalVars.makerAmount0BaseChange) {\\n                // Remove the best bid from the order book if it is fully filled\\n                matchOrderLocalVars.atLeastOneFullSwap = true;\\n                bestMatch.ownerId = 0;\\n            } else {\\n                // Update the best bid if it is partially filled\\n                bestMatch.amount0Base -= matchOrderLocalVars.makerAmount0BaseChange;\\n                break;\\n            }\\n\\n            matchOrderLocalVars.index = bestMatch.next;\\n            if (matchOrderLocalVars.fullTakerFill) {\\n                // Break before updating the amount, if taker specifies exactOutput taker will receive largest\\n                // amount of output tokens they can buy with same input needed for exactOutput. Amount can be\\n                // negative if taker is receiving slightly more than exactOutput (depending on the ticks).\\n                break;\\n            }\\n\\n            if ((isAsk && isExactInput) || (!isAsk && !isExactInput)) {\\n                matchOrderLocalVars.amount -= matchOrderLocalVars.swapAmount0;\\n            } else {\\n                matchOrderLocalVars.amount -= matchOrderLocalVars.swapAmount1;\\n            }\\n        }\\n\\n        if (matchOrderLocalVars.atLeastOneFullSwap) {\\n            makerOrders[matchOrderLocalVars.index].prev = 0;\\n            makerOrders[0].next = matchOrderLocalVars.index;\\n        }\\n\\n        if (!matchOrderLocalVars.fullTakerFill) {\\n            revert Errors.LighterV2Swap_NotEnoughLiquidity();\\n        }\\n\\n        if (\\n            isExactInput &&\\n            ((isAsk && matchOrderLocalVars.filledAmount1 < thresholdAmount) ||\\n                (!isAsk && matchOrderLocalVars.filledAmount0 < thresholdAmount))\\n        ) {\\n            revert Errors.LighterV2Swap_NotEnoughOutput();\\n        } else if (\\n            !isExactInput &&\\n            ((isAsk && matchOrderLocalVars.filledAmount0 > thresholdAmount) ||\\n                (!isAsk && matchOrderLocalVars.filledAmount1 > thresholdAmount))\\n        ) {\\n            revert Errors.LighterV2Swap_TooMuchRequested();\\n        }\\n\\n        return (\\n            matchOrderLocalVars.filledAmount0,\\n            matchOrderLocalVars.filledAmount1,\\n            matchOrderLocalVars.swapCount,\\n            matchOrderLocalVars.swaps\\n        );\\n    }\\n\\n    /// @dev Handles the payment logic for a matched order.\\n    /// @param paymentData The payment data containing information about the swaps and payments\\n    function _handlePayments(PaymentData memory paymentData) internal {\\n        // Determine debit and credit tokens based on the order type\\n        IERC20Minimal debitToken = paymentData.isAsk ? token0 : token1;\\n        IERC20Minimal creditToken = paymentData.isAsk ? token1 : token0;\\n\\n        uint256 debitTokenAmount = (paymentData.isAsk ? paymentData.filledAmount0 : paymentData.filledAmount1) +\\n            paymentData.remainingLimitOrderAmount;\\n        uint256 creditTokenAmount = paymentData.isAsk ? paymentData.filledAmount1 : paymentData.filledAmount0;\\n\\n        if (creditTokenAmount > 0) {\\n            if (paymentData.isPerfMode) {\\n                if (paymentData.isAsk) {\\n                    claimableToken1Balance[paymentData.recipient] += creditTokenAmount;\\n                } else {\\n                    claimableToken0Balance[paymentData.recipient] += creditTokenAmount;\\n                }\\n                // Omit emitting ClaimableBalanceIncrease for gas savings, can be inferred from swap events\\n            } else {\\n                if (!_sendToken(creditToken, paymentData.recipient, creditTokenAmount)) {\\n                    revert Errors.LighterV2TokenTransfer_Failed();\\n                }\\n            }\\n        }\\n\\n        if (paymentData.isPerfMode) {\\n            if (paymentData.isAsk) {\\n                if (claimableToken0Balance[msg.sender] < debitTokenAmount) {\\n                    revert Errors.LighterV2Order_InsufficientClaimableBalance();\\n                }\\n                claimableToken0Balance[msg.sender] -= debitTokenAmount;\\n            } else {\\n                if (claimableToken1Balance[msg.sender] < debitTokenAmount) {\\n                    revert Errors.LighterV2Order_InsufficientClaimableBalance();\\n                }\\n                claimableToken1Balance[msg.sender] -= debitTokenAmount;\\n            }\\n            // Omit emitting ClaimableBalanceDecrease for gas savings, can be inferred from swap and order creation events\\n        } else {\\n            uint256 debitTokenBalanceBeforeDebit = debitToken.balanceOf(address(this));\\n\\n            ILighterV2TransferCallback(msg.sender).lighterV2TransferCallback(\\n                debitTokenAmount,\\n                debitToken,\\n                paymentData.callbackData\\n            );\\n\\n            if (debitToken.balanceOf(address(this)) < (debitTokenBalanceBeforeDebit + debitTokenAmount)) {\\n                revert Errors.LighterV2Order_InsufficentCallbackTransfer();\\n            }\\n        }\\n\\n        // Loop through swaps and transfer tokens to the maker order owners\\n        for (uint32 swapIndex; swapIndex < paymentData.swapCount; ++swapIndex) {\\n            SwapData memory swapData = paymentData.swaps[swapIndex];\\n            if (swapData.isPerfMode) {\\n                if (paymentData.isAsk) {\\n                    claimableToken0Balance[swapData.makerAddress] += swapData.swapAmount;\\n                } else {\\n                    claimableToken1Balance[swapData.makerAddress] += swapData.swapAmount;\\n                }\\n                // omit emitting ClaimableBalanceIncrease for gas savings, can be inferred from swap events\\n            } else {\\n                bool success = _sendToken(debitToken, swapData.makerAddress, swapData.swapAmount);\\n                if (!success) {\\n                    // if transfer to maker fails, mark the amount as claimable for maker\\n                    if (paymentData.isAsk) {\\n                        claimableToken0Balance[swapData.makerAddress] += swapData.swapAmount;\\n                    } else {\\n                        claimableToken1Balance[swapData.makerAddress] += swapData.swapAmount;\\n                    }\\n                    emit ClaimableBalanceIncrease(swapData.makerAddress, swapData.swapAmount, paymentData.isAsk);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Transfer tokens from the order book to the user\\n    /// @param tokenToTransfer The token to transfer\\n    /// @param to The address to transfer to\\n    /// @param amount The amount to transfer\\n    /// @return success Whether the transfer was successful or not\\n    function _sendToken(IERC20Minimal tokenToTransfer, address to, uint256 amount) internal returns (bool) {\\n        uint256 orderBookBalanceBefore = tokenToTransfer.balanceOf(address(this));\\n        bool success = false;\\n        try tokenToTransfer.transfer(to, amount) returns (bool ret) {\\n            success = ret;\\n        } catch {\\n            success = false;\\n        }\\n\\n        uint256 sentAmount = success ? amount : 0;\\n        if (tokenToTransfer.balanceOf(address(this)) + sentAmount < orderBookBalanceBefore) {\\n            revert Errors.LighterV2Base_ContractBalanceDoesNotMatchSentAmount();\\n        }\\n        return success;\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function suggestHintId(uint64 priceBase, bool isAsk) external view override returns (uint32) {\\n        return _orders.suggestHintId(priceBase, isAsk);\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function getLimitOrderSwapAmounts(\\n        uint64 takerOrderAmount0Base,\\n        uint64 takerOrderPriceBase,\\n        uint64 makerOrderAmount0Base,\\n        uint64 makerOrderPriceBase,\\n        bool isTakerAsk\\n    ) public pure override returns (uint64 amount0BaseReturn, uint128 amount1BaseReturn) {\\n        // If the takerOrder is an ask, and the makerOrder price is at least\\n        // the takerOrder's price, then the takerOrder can be filled\\n        // If the takerOrder is a bid, and the makerOrder price is at most\\n        // the takerOrder's price, then the takerOrder can be filled\\n        if (\\n            (isTakerAsk && makerOrderPriceBase >= takerOrderPriceBase) ||\\n            (!isTakerAsk && takerOrderPriceBase >= makerOrderPriceBase)\\n        ) {\\n            if (takerOrderAmount0Base < makerOrderAmount0Base) {\\n                amount0BaseReturn = takerOrderAmount0Base;\\n            } else {\\n                amount0BaseReturn = makerOrderAmount0Base;\\n            }\\n            return (amount0BaseReturn, uint128(amount0BaseReturn * makerOrderPriceBase));\\n        }\\n\\n        return (0, 0);\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function getSwapAmountsForToken0(\\n        uint256 amount0,\\n        bool isAsk,\\n        uint64 makerAmount0Base,\\n        uint64 makerPriceBase\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256 swapAmount0, uint256 swapAmount1, uint64 amount0BaseDelta, bool fullTakerFill)\\n    {\\n        uint256 amount0BaseToTake;\\n        if (isAsk) {\\n            amount0BaseToTake = amount0 / sizeTick;\\n        } else {\\n            amount0BaseToTake = Math.ceilDiv(amount0, sizeTick);\\n        }\\n        if (amount0BaseToTake > makerAmount0Base) {\\n            amount0BaseToTake = makerAmount0Base;\\n            fullTakerFill = false;\\n        } else {\\n            fullTakerFill = true;\\n        }\\n        amount0BaseDelta = uint64(amount0BaseToTake);\\n        swapAmount0 = uint256(amount0BaseDelta) * sizeTick;\\n        swapAmount1 = (uint256(amount0BaseDelta) * makerPriceBase * priceMultiplier) / priceDivider;\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function getSwapAmountsForToken1(\\n        uint256 amount1,\\n        bool isAsk,\\n        uint64 makerAmount0Base,\\n        uint64 makerPriceBase\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256 swapAmount0, uint256 swapAmount1, uint64 amount0BaseDelta, bool fullTakerFill)\\n    {\\n        uint256 amount0BaseToTake = Math.mulDiv(amount1, priceDivider, makerPriceBase * priceMultiplier);\\n        if (isAsk) {\\n            swapAmount1 = (amount0BaseToTake * makerPriceBase * priceMultiplier) / priceDivider;\\n            if (swapAmount1 < amount1) {\\n                amount0BaseToTake += 1;\\n            }\\n        }\\n        if (amount0BaseToTake > makerAmount0Base) {\\n            amount0BaseToTake = makerAmount0Base;\\n            fullTakerFill = false;\\n        } else {\\n            fullTakerFill = true;\\n        }\\n        amount0BaseDelta = uint64(amount0BaseToTake);\\n        swapAmount1 = (uint256(amount0BaseDelta) * makerPriceBase * priceMultiplier) / priceDivider;\\n        swapAmount0 = uint256(amount0BaseDelta) * sizeTick;\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function getPaginatedOrders(\\n        uint32 startOrderId,\\n        bool isAsk,\\n        uint32 limit\\n    ) external view override returns (OrderQueryItem memory) {\\n        return _orders.getPaginatedOrders(startOrderId, isAsk, limit, ownerIdToAddress, sizeTick, priceTick);\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function getLimitOrder(bool isAsk, uint32 id) external view override returns (LimitOrder memory) {\\n        return isAsk ? _orders.asks[id] : _orders.bids[id];\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function isOrderActive(uint32 id) public view override returns (bool) {\\n        return _orders.asks[id].ownerId != 0 || _orders.bids[id].ownerId != 0;\\n    }\\n\\n    /// @inheritdoc IOrderBook\\n    function isAskOrder(uint32 id) public view override returns (bool) {\\n        if (!isOrderActive(id)) {\\n            revert Errors.LighterV2Order_OrderDoesNotExist();\\n        }\\n\\n        return _orders.asks[id].ownerId > 1;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 4150\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/LinkedList.sol\": {\r\n        \"LinkedListLib\": \"0xf93daf052aa145bdec8c29483e52030c668514cc\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[]", "ContractName": "OrderBookDeployerLib", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "4150", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}