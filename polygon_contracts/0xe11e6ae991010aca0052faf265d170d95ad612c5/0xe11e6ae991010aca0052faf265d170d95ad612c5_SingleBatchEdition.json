{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SingleBatchEdition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\nimport {SS2ERC721I} from \\\"SS2ERC721/SS2ERC721I.sol\\\";\\nimport {ERC721} from \\\"SS2ERC721/SS2ERC721.sol\\\";\\n\\nimport {EditionBase} from \\\"contracts/common/EditionBase.sol\\\";\\nimport {IBatchEdition} from \\\"contracts/interfaces/IBatchEdition.sol\\\";\\n\\nimport \\\"./interfaces/Errors.sol\\\";\\n\\n/// @notice This is a smart contract optimized for minting editions in one single batch\\n/// @dev This allows creators to mint a unique serial edition of the same media within a custom contract\\ncontract SingleBatchEdition is\\n    EditionBase,\\n    SS2ERC721I,\\n    IBatchEdition\\n{\\n    /// @param _owner User that owns and can mint the edition, gets royalty and sales payouts and can update the base url if needed.\\n    /// @param _name Name of edition, used in the title as \\\"$NAME NUMBER/TOTAL\\\"\\n    /// @param _symbol Symbol of the new token contract\\n    /// @param _description Description of edition, used in the description field of the NFT\\n    /// @param _imageUrl Image URL of the edition. Strongly encouraged to be used, but if necessary, only animation URL can be used. One of animation and image url need to exist in a edition to render the NFT.\\n    /// @param _animationUrl Animation URL of the edition. Not required, but if omitted image URL needs to be included. This follows the opensea spec for NFTs\\n    /// @param _editionSize Number of editions that can be minted in total. If 0, unlimited editions can be minted.\\n    /// @param _royaltyBPS BPS of the royalty set on the contract. Can be 0 for no royalty.\\n    /// @param _mintPeriodSeconds The amount of time in seconds after which editions can no longer be minted or purchased. Use 0 to have no expiration\\n    function initialize(\\n        address _owner,\\n        string calldata _name,\\n        string calldata _symbol,\\n        string calldata _description,\\n        string calldata _animationUrl,\\n        string calldata _imageUrl,\\n        uint256 _editionSize,\\n        uint256 _royaltyBPS,\\n        uint256 _mintPeriodSeconds\\n    ) public override initializer {\\n        __SS2ERC721_init(_name, _symbol);\\n        __EditionBase_init(_owner, _description, _animationUrl, _imageUrl, _editionSize, _royaltyBPS, _mintPeriodSeconds);\\n    }\\n\\n\\n    /*//////////////////////////////////////////////////////////////\\n                   COLLECTOR / TOKEN OWNER FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @param addresses A tightly packed and sorted list of at most 1228 addresses to mint to\\n    function mintBatch(bytes calldata addresses) external override returns (uint256 lastTokenId) {\\n        lastTokenId = _mint(addresses);\\n\\n        // run the validations at the end, once we know the number minted\\n        // this makes reverts more expensive, but the happy path cheaper\\n        _mintChecks(lastTokenId);\\n    }\\n\\n    /// @param pointer An SSTORE2 pointer to a list of addresses to send the newly minted editions to, packed tightly\\n    function mintBatch(address pointer) public override returns (uint256 lastTokenId) {\\n        lastTokenId = _mint(pointer);\\n\\n        // run the validations at the end, once we know the number minted\\n        // this makes reverts more expensive, but the happy path cheaper\\n        _mintChecks(lastTokenId);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      OPERATOR FILTERER OVERRIDES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\\n        public\\n        override\\n        onlyAllowedOperator(from)\\n    {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Validates the supply and time limits for minting with a single SLOAD and SSTORE\\n    /// @dev this is based on _mintPreFlightChecks in Edition\\n    /// @dev does not enforce the sale price, as the mint functions are not payable\\n    function _mintChecks(uint256 quantity) internal returns (uint64 _tokenId) {\\n        if (!isApprovedMinter(msg.sender)) {\\n            revert Unauthorized();\\n        }\\n\\n        uint256 _state;\\n        uint256 _postState;\\n        uint64 _editionSize;\\n        uint64 _endOfMintPeriod;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            _state := sload(state.slot)\\n            _editionSize := shr(192, _state)\\n            _endOfMintPeriod := shr(128, _state)\\n\\n            // can not realistically overflow\\n            // the fields in EditionState are ordered so that incrementing state increments numberMinted\\n            _postState := add(_state, quantity)\\n\\n            // perform the addition only once and extract numberMinted + 1 from _postState\\n            _tokenId := and(_postState, 0xffffffffffffffff)\\n        }\\n\\n        enforceSupplyLimit(_editionSize, _tokenId);\\n        enforceTimeLimit(_endOfMintPeriod);\\n\\n        // update storage\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(state.slot, _postState)\\n        }\\n\\n        return _tokenId;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           SS2ERC721 GOODIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// Returns the SSTORE2 pointer for this edition if minted, or 0 if not minted\\n    function getPrimaryOwnersPointer(uint256 index) public view override returns (address) {\\n        if (index > 0) {\\n            return address(0);\\n        }\\n\\n        return _ownersPrimaryPointer;\\n    }\\n\\n    /// Returns true if the given address is one of the primary owners of this edition\\n    /// A primary owner is defined as an address in the SSTORE2 array of primary owners\\n    /// used during the initial mint of the edition.\\n    /// Note that this does not look up if the address is still a current owner (they\\n    /// may have transferred or burned their token)\\n    function isPrimaryOwner(address tokenOwner) public view override returns (bool) {\\n        return _balanceOfPrimary(tokenOwner) != 0;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           METADATA FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Get the base64-encoded json metadata for a token\\n    /// @param tokenId the token id to get the metadata for\\n    /// @return base64-encoded json metadata object\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        // reverts with NOT_MINTED if token does not exist\\n        ownerOf(tokenId);\\n\\n        return createTokenMetadata(name, tokenId, editionSize());\\n    }\\n\\n    /// @notice Get the base64-encoded json metadata object for the edition\\n    function contractURI() public view override returns (string memory) {\\n        return createContractMetadata(name, state.royaltyBPS, owner);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public pure override(ERC721, EditionBase) returns (bool) {\\n        return EditionBase.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/EditionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\n\\nimport {\\n    IERC2981Upgradeable,\\n    IERC165Upgradeable\\n} from \\\"@openzeppelin-contracts-upgradeable/interfaces/IERC2981Upgradeable.sol\\\";\\nimport {AddressUpgradeable} from \\\"@openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\nimport {Initializable} from \\\"SS2ERC721/common/utils/Initializable.sol\\\";\\nimport {OwnedInitializable} from \\\"contracts/solmate-initializable/auth/OwnedInitializable.sol\\\";\\n\\nimport {EditionMetadataRenderer} from \\\"contracts/common/EditionMetadataRenderer.sol\\\";\\nimport {IEditionBase, EditionState} from \\\"contracts/interfaces/IEditionBase.sol\\\";\\nimport \\\"contracts/interfaces/Errors.sol\\\";\\nimport {OptionalOperatorFilterer} from \\\"contracts/utils/OptionalOperatorFilterer.sol\\\";\\n\\nabstract contract EditionBase is\\n    IEditionBase,\\n    Initializable,\\n    EditionMetadataRenderer,\\n    OptionalOperatorFilterer,\\n    OwnedInitializable,\\n    IERC2981Upgradeable\\n{\\n    /*//////////////////////////////////////////////////////////////\\n                            STATE VARIABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    EditionState internal state;\\n\\n    // Addresses allowed to mint edition\\n    mapping(address => bool) allowedMinters;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              INITIALIZER\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function __EditionBase_init(\\n        address _owner,\\n        string calldata _description,\\n        string calldata _animationUrl,\\n        string calldata _imageUrl,\\n        uint256 _editionSize,\\n        uint256 _royaltyBPS,\\n        uint256 _mintPeriodSeconds\\n    ) internal onlyInitializing {\\n        // Set ownership to original sender of contract call\\n        __Owned_init(_owner);\\n\\n        description = _description;\\n        animationUrl = _animationUrl;\\n        imageUrl = _imageUrl;\\n\\n        uint64 _endOfMintPeriod;\\n        if (_mintPeriodSeconds > 0) {\\n            // overflows are not expected to happen for timestamps, and have no security implications\\n            unchecked {\\n                uint256 endOfMintPeriodUint256 = block.timestamp + _mintPeriodSeconds;\\n                _endOfMintPeriod = requireUint64(endOfMintPeriodUint256);\\n            }\\n        }\\n\\n        state = EditionState({\\n            editionSize: requireUint64(_editionSize),\\n            endOfMintPeriod: _endOfMintPeriod,\\n            royaltyBPS: requireUint16(_royaltyBPS),\\n            salePriceTwei: 0,\\n            numberMinted: 0,\\n            __reserved: 0\\n        });\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           METADATA FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function editionSize() public view returns (uint256) {\\n        return state.editionSize;\\n    }\\n\\n    /// Returns the timestamp when the minting period ends, or 0 if there is no time limit\\n    function endOfMintPeriod() public view override returns (uint256) {\\n        return state.endOfMintPeriod;\\n    }\\n\\n    /// Returns whether the edition can still be minted/purchased\\n    function isMintingEnded() public view override returns (bool) {\\n        uint256 _endOfMintPeriod = state.endOfMintPeriod;\\n        return _endOfMintPeriod > 0 && uint64(block.timestamp) > _endOfMintPeriod;\\n    }\\n\\n    function isApprovedMinter(address minter) public view override returns (bool) {\\n        return allowedMinters[minter] || allowedMinters[address(0x0)] || owner == minter;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return state.numberMinted;\\n    }\\n\\n        /// @notice Get royalty information for token\\n    /// @param _salePrice Sale price for the token\\n    function royaltyInfo(uint256, uint256 _salePrice)\\n        external\\n        view\\n        override\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        if (owner == address(0x0)) {\\n            return (address(0x0), 0);\\n        }\\n        return (owner, (_salePrice * state.royaltyBPS) / 10_000);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override(IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x2a55205a || // ERC165 Interface ID for ERC2981\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                  CREATOR / COLLECTION OWNER FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev This withdraws ETH from the contract to the contract owner.\\n    function withdraw() external override onlyOwner {\\n        // No need for gas limit to trusted address.\\n        AddressUpgradeable.sendValue(payable(owner), address(this).balance);\\n    }\\n\\n    /// @notice Sets the approved minting status of the given address.\\n    /// @param minter address to set approved minting status for\\n    /// @param allowed boolean if that address is allowed to mint\\n    /// @dev This requires that msg.sender is the owner of the given edition id.\\n    /// @dev If the ZeroAddress (address(0x0)) is set as a minter, anyone will be allowed to mint.\\n    /// @dev This setup is similar to setApprovalForAll in the ERC721 spec.\\n    function setApprovedMinter(address minter, bool allowed) public override onlyOwner {\\n        allowedMinters[minter] = allowed;\\n    }\\n\\n    /// @notice Updates the external_url field in the metadata\\n    function setExternalUrl(string calldata _externalUrl) public override onlyOwner {\\n        emit ExternalUrlUpdated(externalUrl, _externalUrl);\\n\\n        externalUrl = _externalUrl;\\n    }\\n\\n    function setStringProperties(string[] calldata names, string[] calldata values) public override onlyOwner {\\n        uint256 length = names.length;\\n        if (values.length != length) {\\n            revert LengthMismatch();\\n        }\\n\\n        namesOfStringProperties = names;\\n        for (uint256 i = 0; i < length;) {\\n            string calldata name = names[i];\\n            string calldata value = values[i];\\n            if (bytes(name).length == 0 || bytes(value).length == 0) {\\n                revert BadAttribute(name, value);\\n            }\\n\\n            emit PropertyUpdated(name, stringProperties[name], value);\\n\\n            stringProperties[name] = value;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function setOperatorFilter(address operatorFilter) public override onlyOwner {\\n        _setOperatorFilter(operatorFilter);\\n    }\\n\\n    function enableDefaultOperatorFilter() public override onlyOwner {\\n        _setOperatorFilter(CANONICAL_OPENSEA_SUBSCRIPTION);\\n    }\\n\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev stateless version of isMintingEnded\\n    function enforceTimeLimit(uint64 _endOfMintPeriod) internal view {\\n        if (_endOfMintPeriod > 0 && uint64(block.timestamp) > _endOfMintPeriod) {\\n            revert TimeLimitReached();\\n        }\\n    }\\n\\n    function enforceSupplyLimit(uint64 _editionSize, uint64 _numberMinted) internal pure {\\n        if (_editionSize > 0 && _numberMinted > _editionSize) {\\n            revert SoldOut();\\n        }\\n    }\\n\\n    function requireUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > uint256(type(uint16).max)) {\\n            revert IntegerOverflow(value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    function requireUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > uint256(type(uint32).max)) {\\n            revert IntegerOverflow(value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    function requireUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > uint256(type(uint64).max)) {\\n            revert IntegerOverflow(value);\\n        }\\n        return uint64(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/EditionMetadataRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\nimport {Base64} from \\\"contracts/utils/Base64.sol\\\";\\nimport {LibString} from \\\"contracts/utils/LibString.sol\\\";\\n\\nimport {EditionMetadataState} from \\\"./EditionMetadataState.sol\\\";\\n\\n/// logic for rendering metadata associated with editions\\ncontract EditionMetadataRenderer is EditionMetadataState {\\n    /// Generate edition metadata from storage information as base64-json blob\\n    /// Combines the media data and metadata\\n    /// @param name Name of NFT in metadata\\n    /// @param tokenId Token ID for specific token\\n    /// @param editionSize Size of entire edition to show\\n    function createTokenMetadata(\\n        string memory name,\\n        uint256 tokenId,\\n        uint256 editionSize\\n    ) internal view returns (string memory) {\\n        return\\n            toBase64DataUrl(\\n                createTokenMetadataJson(name, tokenId, editionSize)\\n            );\\n    }\\n\\n    /// Function to create the metadata json string for the nft edition\\n    /// @param name Name of NFT in metadata\\n    /// @param tokenId Token ID for specific token\\n    /// @param editionSize Size of entire edition to show\\n    function createTokenMetadataJson(\\n        string memory name,\\n        uint256 tokenId,\\n        uint256 editionSize\\n    ) internal view returns (string memory) {\\n        string memory editionSizeText;\\n        if (editionSize > 0) {\\n            editionSizeText = string.concat(\\n                \\\"/\\\",\\n                LibString.toString(editionSize)\\n            );\\n        }\\n\\n        string memory externalURLText = \\\"\\\";\\n        if (bytes(externalUrl).length > 0) {\\n            externalURLText = string.concat('\\\",\\\"external_url\\\":\\\"', externalUrl);\\n        }\\n\\n        string memory mediaData = tokenMediaData(imageUrl, animationUrl);\\n\\n        return\\n            string.concat(\\n                '{\\\"name\\\":\\\"',\\n                LibString.escapeJSON(name),\\n                \\\" #\\\",\\n                LibString.toString(tokenId),\\n                editionSizeText,\\n                '\\\",\\\"',\\n                'description\\\":\\\"',\\n                LibString.escapeJSON(description),\\n                externalURLText,\\n                '\\\"',\\n                mediaData,\\n                getPropertiesJson(),\\n                \\\"}\\\"\\n            );\\n    }\\n\\n    /// Encodes contract level metadata into base64-data url format\\n    /// @dev see https://docs.opensea.io/docs/contract-level-metadata\\n    /// @dev borrowed from https://github.com/ourzora/zora-drops-contracts/blob/main/src/utils/NFTMetadataRenderer.sol\\n    function createContractMetadata(\\n        string memory name,\\n        uint256 royaltyBPS,\\n        address royaltyRecipient\\n    ) internal view returns (string memory) {\\n        string memory imageSpace = \\\"\\\";\\n        if (bytes(imageUrl).length > 0) {\\n            imageSpace = string.concat('\\\",\\\"image\\\":\\\"', imageUrl);\\n        }\\n\\n        string memory externalURLSpace = \\\"\\\";\\n        if (bytes(externalUrl).length > 0) {\\n            externalURLSpace = string.concat(\\n                '\\\",\\\"external_link\\\":\\\"',\\n                externalUrl\\n            );\\n        }\\n\\n        return\\n            toBase64DataUrl(\\n                string.concat(\\n                    '{\\\"name\\\":\\\"',\\n                    LibString.escapeJSON(name),\\n                    '\\\",\\\"description\\\":\\\"',\\n                    LibString.escapeJSON(description),\\n                    // this is for opensea since they don't respect ERC2981 right now\\n                    '\\\",\\\"seller_fee_basis_points\\\":',\\n                    LibString.toString(royaltyBPS),\\n                    ',\\\"fee_recipient\\\":\\\"',\\n                    LibString.toHexString(royaltyRecipient),\\n                    imageSpace,\\n                    externalURLSpace,\\n                    '\\\"}'\\n                )\\n            );\\n    }\\n\\n    /// Encodes the argument json bytes into base64-data uri format\\n    /// @param json Raw json to base64 and turn into a data-uri\\n    function toBase64DataUrl(string memory json)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            string.concat(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(bytes(json))\\n            );\\n    }\\n\\n    function tokenMediaData(string memory imageUrl, string memory animationUrl)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bool hasImage = bytes(imageUrl).length > 0;\\n        bool hasAnimation = bytes(animationUrl).length > 0;\\n        string memory buffer = \\\"\\\";\\n\\n        if (hasImage) {\\n            buffer = string.concat(',\\\"image\\\":\\\"', imageUrl, '\\\"');\\n        }\\n\\n        if (hasAnimation) {\\n            buffer = string.concat(\\n                buffer,\\n                ',\\\"animation_url\\\":\\\"',\\n                animationUrl,\\n                '\\\"'\\n            );\\n        }\\n\\n        return buffer;\\n    }\\n\\n    /// Produces Enjin Metadata style simple properties\\n    /// @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md#erc-1155-metadata-uri-json-schema\\n    function getPropertiesJson() internal view returns (string memory) {\\n        uint256 length = namesOfStringProperties.length;\\n        if (length == 0) {\\n            return ',\\\"properties\\\":{}';\\n        }\\n\\n        string memory buffer = ',\\\"properties\\\":{';\\n\\n        unchecked {\\n            // `length - 1` can not underflow because of the `length == 0` check above\\n            uint256 lengthMinusOne = length - 1;\\n\\n            for (uint256 i = 0; i < lengthMinusOne; ) {\\n                string storage _name = namesOfStringProperties[i];\\n                string storage _value = stringProperties[_name];\\n\\n                buffer = string.concat(\\n                    buffer,\\n                    stringifyStringAttribute(_name, _value),\\n                    \\\",\\\"\\n                );\\n\\n                // counter increment can not overflow\\n                ++i;\\n            }\\n\\n            // add the last attribute without a trailing comma\\n            string storage lastName = namesOfStringProperties[lengthMinusOne];\\n            buffer = string.concat(\\n                buffer,\\n                stringifyStringAttribute(lastName, stringProperties[lastName])\\n            );\\n        }\\n\\n        buffer = string.concat(buffer, \\\"}\\\");\\n\\n        return buffer;\\n    }\\n\\n    function stringifyStringAttribute(string storage name, string storage value)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // let's only escape the value, property names should not be using any special characters\\n        return\\n            string.concat('\\\"', name, '\\\":\\\"', LibString.escapeJSON(value), '\\\"');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/EditionMetadataState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\ncontract EditionMetadataState {\\n    string public description;\\n\\n    // Media Urls\\n    // animation_url field in the metadata\\n    string public animationUrl;\\n\\n    // Image in the metadata\\n    string public imageUrl;\\n\\n    // URL that will appear below the asset's image on OpenSea\\n    string public externalUrl;\\n\\n    string[] internal namesOfStringProperties;\\n\\n    mapping(string => string) internal stringProperties;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\nerror BadAttribute(string name, string value);\\nerror IntegerOverflow(uint256 value);\\nerror InvalidArgument();\\nerror LengthMismatch();\\nerror NotForSale();\\nerror OperatorNotAllowed(address operator);\\nerror PriceTooLow();\\nerror SoldOut();\\nerror TimeLimitReached();\\nerror Unauthorized();\\nerror WrongPrice();\\n\"\r\n    },\r\n    \"contracts/interfaces/IBatchEdition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\nimport {IEditionBase} from \\\"./IEditionBase.sol\\\";\\nimport {IBatchMintable} from \\\"./IBatchMintable.sol\\\";\\n\\ninterface IBatchEdition is IEditionBase, IBatchMintable {\\n    // just a convenience wrapper for the parent editions\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBatchMintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\ninterface IBatchMintable {\\n    function getPrimaryOwnersPointer(uint256 index) external view returns(address);\\n\\n    function isPrimaryOwner(address tokenOwner) external view returns(bool);\\n\\n    function mintBatch(bytes calldata addresses) external returns (uint256);\\n\\n    function mintBatch(address pointer) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEditionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\nstruct EditionState {\\n    // how many tokens have been minted (can not be more than editionSize)\\n    uint64 numberMinted;\\n    // reserved space to keep the state a uint256\\n    uint16 __reserved;\\n    // Price to mint in twei (1 twei = 1000 gwei), so the supported price range is 0.000001 to 4294.967295 ETH\\n    // To accept ERC20 or a different price range, use a specialized sales contract as the approved minter\\n    uint32 salePriceTwei;\\n    // Royalty amount in bps (uint16 is large enough to store 10000 bps)\\n    uint16 royaltyBPS;\\n    // the edition can be minted up to this timestamp in seconds -- 0 means no end date\\n    uint64 endOfMintPeriod;\\n    // Total size of edition that can be minted\\n    uint64 editionSize;\\n}\\n\\ninterface IEditionBase {\\n    event ExternalUrlUpdated(string oldExternalUrl, string newExternalUrl);\\n    event PropertyUpdated(string name, string oldValue, string newValue);\\n\\n    function contractURI() external view returns (string memory);\\n\\n    function editionSize() external view returns (uint256);\\n\\n    function initialize(\\n        address _owner,\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _description,\\n        string memory _animationUrl,\\n        string memory _imageUrl,\\n        uint256 _editionSize,\\n        uint256 _royaltyBPS,\\n        uint256 _mintPeriodSeconds\\n    ) external;\\n\\n    function enableDefaultOperatorFilter() external;\\n\\n    function endOfMintPeriod() external view returns (uint256);\\n\\n    function isApprovedMinter(address minter) external view returns (bool);\\n\\n    function isMintingEnded() external view returns (bool);\\n\\n    function setApprovedMinter(address minter, bool allowed) external;\\n\\n    function setExternalUrl(string calldata _externalUrl) external;\\n\\n    function setOperatorFilter(address operatorFilter) external;\\n\\n    function setStringProperties(string[] calldata names, string[] calldata values) external;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function withdraw() external;\\n}\\n\"\r\n    },\r\n    \"contracts/solmate-initializable/auth/IOwned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\ninterface IOwned {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function owner() external view returns (address);\\n\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/solmate-initializable/auth/OwnedInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {Initializable} from \\\"SS2ERC721/common/utils/Initializable.sol\\\";\\nimport {IOwned} from \\\"./IOwned.sol\\\";\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author karmacoma (replaced constructor with initializer)\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract OwnedInitializable is Initializable, IOwned {\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              INITIALIZER\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function __Owned_init(address _owner) internal onlyInitializing {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode strings in Base64.\\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol) @ 41d29ed\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(\\n        bytes memory data,\\n        bool fileSafe,\\n        bool noPadding\\n    ) internal pure returns (string memory result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(\\n                    0x3f,\\n                    sub(\\n                        \\\"ghijklmnopqrstuvwxyz0123456789-_\\\",\\n                        mul(iszero(fileSafe), 0x0230)\\n                    )\\n                )\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                // Run over the input, 3 bytes at a time.\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\\n\\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    // prettier-ignore\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n\\n                let r := mod(dataLength, 3)\\n\\n                switch noPadding\\n                case 0 {\\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n                    // Write the length of the string.\\n                    mstore(result, encodedLength)\\n                }\\n                default {\\n                    // Write the length of the string.\\n                    mstore(\\n                        result,\\n                        sub(encodedLength, add(iszero(iszero(r)), eq(r, 1)))\\n                    )\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(end, 31), not(31)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Encodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let end := add(data, dataLength)\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                switch and(dataLength, 3)\\n                case 0 {\\n                    // If padded.\\n                    decodedLength := sub(\\n                        decodedLength,\\n                        add(\\n                            eq(and(mload(end), 0xFF), 0x3d),\\n                            eq(and(mload(end), 0xFFFF), 0x3d3d)\\n                        )\\n                    )\\n                }\\n                default {\\n                    // If non-padded.\\n                    decodedLength := add(\\n                        decodedLength,\\n                        sub(and(dataLength, 3), 1)\\n                    )\\n                }\\n\\n                result := mload(0x40)\\n\\n                // Write the length of the string.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let\\n                    m\\n                := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(\\n                    0x3b,\\n                    0x04080c1014181c2024282c3034383c4044484c5054585c6064\\n                )\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n\\n                    ptr := add(ptr, 3)\\n\\n                    // prettier-ignore\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 32 + 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\\n\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol) @ 016c4ac\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = uint256(int256(-1));\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        assembly (\\\"memory-safe\\\") {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for {} 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                length := sub(length, 1)\\n                // prettier-ignore\\n                if iszero(length) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := add(sub(end, str), 2)\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 0x20)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            let m := add(start, 0xa0)\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := add(sub(end, str), 2)\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 0x20)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the length, 0x02 bytes for the prefix,\\n            // and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x02 + 0x28) is 0x60.\\n            str := add(start, 0x60)\\n\\n            // Allocate the memory.\\n            mstore(0x40, str)\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let length := 20\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                length := sub(length, 1)\\n                // prettier-ignore\\n                if iszero(length) { break }\\n            }\\n\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 32)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, 42)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   OTHER STRING OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurances of `search` replaced with `replacement`.\\n    function replace(\\n        string memory subject,\\n        string memory search,\\n        string memory replacement\\n    ) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) {\\n                    h := keccak256(search, searchLength)\\n                }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                // prettier-ignore\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        // prettier-ignore\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            // prettier-ignore\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            // prettier-ignore\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            // prettier-ignore\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            // Zeroize the slot after the string.\\n            let last := add(add(result, 0x20), k)\\n            mstore(last, 0)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n            // Store the length of the result.\\n            mstore(result, k)\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(\\n        string memory subject,\\n        string memory search,\\n        uint256 from\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            // prettier-ignore\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    // `result = min(from, subjectLength)`.\\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(add(search, 0x20))\\n\\n                // prettier-ignore\\n                if iszero(lt(subject, subjectSearchEnd)) { break }\\n\\n                if iszero(lt(searchLength, 32)) {\\n                    // prettier-ignore\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        // prettier-ignore\\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\\n                    }\\n                    break\\n                }\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(\\n        string memory subject,\\n        string memory search,\\n        uint256 from\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            // prettier-ignore\\n            for {} 1 {} {\\n                let searchLength := mload(search)\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) {\\n                    from := fromMax\\n                }\\n                if iszero(mload(search)) {\\n                    result := from\\n                    break\\n                }\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\\n\\n                subject := add(add(subject, 0x20), from)\\n                // prettier-ignore\\n                if iszero(gt(subject, subjectSearchEnd)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                // prettier-ignore\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(subjectSearchEnd, 1))\\n                        break\\n                    }\\n                    subject := sub(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(\\n                            add(subject, 0x20),\\n                            mul(withinRange, sub(subjectLength, searchLength))\\n                        ),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    // prettier-ignore\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        // prettier-ignore\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    // prettier-ignore\\n                    if iszero(times) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(output, 0)\\n                // Store the length.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(\\n        string memory subject,\\n        uint256 start,\\n        uint256 end\\n    ) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) {\\n                end := subjectLength\\n            }\\n            if iszero(gt(subjectLength, start)) {\\n                start := subjectLength\\n            }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                // Copy the `subject` one word at a time, backwards.\\n                // prettier-ignore\\n                for { let o := and(add(resultLength, 31), not(31)) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := sub(o, 0x20)\\n                    // prettier-ignore\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(\\n                    sub(add(subject, subjectLength), searchLength),\\n                    1\\n                )\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) {\\n                    h := keccak256(search, searchLength)\\n                }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                // prettier-ignore\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            // prettier-ignore\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        assembly {\\n            if mload(indices) {\\n                let indexPtr := add(indices, 0x20)\\n                let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n                mstore(sub(indicesEnd, 0x20), mload(subject))\\n                mstore(indices, add(mload(indices), 1))\\n                let prevIndex := 0\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let index := mload(indexPtr)\\n                    mstore(indexPtr, 0x60)\\n                    if iszero(eq(index, prevIndex)) {\\n                        let element := mload(0x40)\\n                        let elementLength := sub(index, prevIndex)\\n                        mstore(element, elementLength)\\n                        // Copy the `subject` one word at a time, backwards.\\n                        // prettier-ignore\\n                        for { let o := and(add(elementLength, 31), not(31)) } 1 {} {\\n                            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                            o := sub(o, 0x20)\\n                            // prettier-ignore\\n                            if iszero(o) { break }\\n                        }\\n                        // Zeroize the slot after the string.\\n                        mstore(add(add(element, 0x20), elementLength), 0)\\n                        // Allocate memory for the length and the bytes,\\n                        // rounded up to a multiple of 32.\\n                        mstore(0x40, add(element, and(add(elementLength, 63), not(31))))\\n                        // Store the `element` into the array.\\n                        mstore(indexPtr, element)\\n                    }\\n                    prevIndex := add(index, mload(delimiter))\\n                    indexPtr := add(indexPtr, 0x20)\\n                    // prettier-ignore\\n                    if iszero(lt(indexPtr, indicesEnd)) { break }\\n                }\\n                result := indices\\n                if iszero(mload(delimiter)) {\\n                    result := add(indices, 0x20)\\n                    mstore(result, sub(mload(indices), 2))\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            // prettier-ignore\\n            for { let o := and(add(mload(a), 32), not(31)) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := sub(o, 0x20)\\n                // prettier-ignore\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, mload(a))\\n            // Copy `b` one word at a time, backwards.\\n            // prettier-ignore\\n            for { let o := and(add(bLength, 32), not(31)) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := sub(o, 0x20)\\n                // prettier-ignore\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            // prettier-ignore\\n            for {\\n                let end := add(s, mload(s))\\n                result := add(mload(0x40), 0x20)\\n                // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n                // Store \\\"0123456789abcdef\\\" in scratch space.\\n                // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n                // into the scratch space.\\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n                // Bitmask for detecting `[\\\"\\\\\\\"\\\", \\\"\\\\\\\\\\\"]`.\\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            } iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) { // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) { // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            let last := result\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Restore the result to the start of the free memory.\\n            result := mload(0x40)\\n            // Store the length of the result.\\n            mstore(result, sub(last, add(result, 0x20)))\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result := mul(\\n                // Load the length and the bytes.\\n                mload(add(a, 0x1f)),\\n                // `length != 0 && length < 32`. Abuses underflow.\\n                // Assumes that the length is valid and within the block gas limit.\\n                lt(sub(mload(a), 1), 0x1f)\\n            )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\\n    function unpackOne(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result := mul(\\n                // Load the length and the bytes of `a` and `b`.\\n                or(\\n                    shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                    mload(sub(add(b, 0x1e), aLength))\\n                ),\\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                // Assumes that the lengths are valid and within the block gas limit.\\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n            )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(\\n                add(resultB, 0x1f),\\n                mload(add(add(resultA, 0x20), mload(resultA)))\\n            )\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(add(a, 0x20), mload(a)), 0)\\n            // Store the return offset.\\n            // Assumes that the string does not start from the scratch space.\\n            mstore(sub(a, 0x20), 0x20)\\n            // End the transaction, returning the string.\\n            return(sub(a, 0x20), add(mload(a), 0x40))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/OptionalOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\nimport { IOperatorFilterRegistry } from \\\"operator-filter-registry/IOperatorFilterRegistry.sol\\\";\\n\\nimport { OperatorNotAllowed } from \\\"../interfaces/Errors.sol\\\";\\n\\n/// Less aggro than DefaultOperatorFilterer, it does not automatically register and subscribe to the default filter\\n/// Instead, this is off by default, opt-in, and relies only on view functions (no register call)\\nabstract contract OptionalOperatorFilterer {\\n    address public constant CANONICAL_OPENSEA_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\\n    address public constant CANONICAL_OPENSEA_REGISTRY = address(0x000000000000AAeB6D7670E522A718067333cd4E);\\n\\n    address public activeOperatorFilter = address(0);\\n\\n    event OperatorFilterChanged(address indexed operatorFilter);\\n\\n    /// Set to CANONICAL_OPENSEA_SUBSCRIPTION to use the default OpenSea operator filter\\n    /// Set to address(0) to disable operator filtering\\n    function _setOperatorFilter(address operatorFilter) internal {\\n        activeOperatorFilter = operatorFilter;\\n        emit OperatorFilterChanged(operatorFilter);\\n    }\\n\\n    /// @dev modified from operator-filter-registry/OperatorFilterer.sol\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /// @dev modified from operator-filter-registry/OperatorFilterer.sol\\n    function _checkFilterOperator(address operator) internal view {\\n        if (activeOperatorFilter == address(0)) {\\n            return;\\n        }\\n\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (CANONICAL_OPENSEA_REGISTRY.code.length == 0) {\\n            return;\\n        }\\n\\n        if (!IOperatorFilterRegistry(CANONICAL_OPENSEA_REGISTRY).isOperatorAllowed(activeOperatorFilter, operator)) {\\n            revert OperatorNotAllowed(operator);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/SS2ERC721/src/SS2ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {SSTORE2} from \\\"solmate/utils/SSTORE2.sol\\\";\\n\\nimport {SS2ERC721Base, ERC721, ERC721TokenReceiver} from \\\"./common/SS2ERC721Base.sol\\\";\\n\\n/// @notice SSTORE2-backed version of Solmate's ERC721, optimized for minting in a single batch\\nabstract contract SS2ERC721 is SS2ERC721Base {\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// stored as SSTORE2 pointer (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n    ///\\n    /// array of abi.encodePacked(address1, address2, address3...) where address1 is the owner of token 1,\\n    /// address2 is the owner of token 2, etc.\\n    /// This means that:\\n    /// - addresses are stored contiguously in storage with no gaps (rather than 1 address per slot)\\n    /// - this is optimized for the mint path and using as few storage slots as possible for the primary owners\\n    /// - the tradeoff is that it causes extra gas and storage costs in the transfer/burn paths\\n    /// - this also causes extra costs in the ownerOf/balanceOf/tokenURI functions, but these are view functions\\n    ///\\n    /// Assumptions:\\n    /// - the list of addresses contains no duplicate\\n    /// - the list of addresses is sorted\\n    /// - the first valid token id is 1\\n    address internal _ownersPrimaryPointer;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {}\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         OWNER / BALANCE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _ownersPrimaryLength() internal view override returns (uint256) {\\n        if (_ownersPrimaryPointer == address(0)) {\\n            return 0;\\n        }\\n\\n        // checked math will underflow if _ownersPrimaryPointer.code.length == 0\\n        return (_ownersPrimaryPointer.code.length - 1) / 20;\\n    }\\n\\n    function _ownerOfPrimary(uint256 id) internal view override returns (address owner) {\\n        // this is an internal method, so return address(0) and let the caller decide if they want to revert\\n        if (id == 0) {\\n            return address(0);\\n        }\\n\\n        address pointer = _ownersPrimaryPointer;\\n        if (pointer == address(0)) {\\n            return address(0);\\n        }\\n\\n        unchecked {\\n            // can not underflow because we checked id != 0\\n            uint256 zeroBasedId = id - 1;\\n\\n            // this can overflow!\\n            uint256 start = zeroBasedId * 20;\\n\\n            // check for overflow and exit cleanly if it happens\\n            if (start < zeroBasedId) {\\n                return address(0);\\n            }\\n\\n            // if we read past the end of the bucket, we will get 0 bytes back\\n            // which is great, because we're supposed to return address(0) in that case anyway\\n            owner = SSTORE2_readRawAddress(pointer, start);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev this function creates a new SSTORE2 pointer, and saves it\\n    /// @dev reading addresses from calldata means we can assemble the creation code with a single memory copy\\n    function _mint(bytes calldata addresses) internal virtual returns (uint256 numMinted) {\\n        assembly {\\n            function revert_invalid_addresses() {\\n                let ptr := mload(FREE_MEM_PTR)\\n                mstore(ptr, shl(224, ERROR_STRING_SELECTOR))\\n                mstore(add(ptr, 0x04), WORD_SIZE) // String offset\\n                mstore(add(ptr, 0x24), 17) // Revert reason length\\n                mstore(add(ptr, 0x44), \\\"INVALID_ADDRESSES\\\")\\n                revert(ptr, 0x64) // Revert data length is 4 bytes for selector and 3 slots of 0x20 bytes\\n            }\\n\\n            function revert_already_minted() {\\n                let ptr := mload(FREE_MEM_PTR)\\n                mstore(ptr, shl(224, ERROR_STRING_SELECTOR))\\n                mstore(add(ptr, 0x04), WORD_SIZE) // String offset\\n                mstore(add(ptr, 0x24), 14) // Revert reason length\\n                mstore(add(ptr, 0x44), \\\"ALREADY_MINTED\\\")\\n                revert(ptr, 0x64) // Revert data length is 4 bytes for selector and 3 slots of 0x20 bytes\\n            }\\n\\n            function revert_not_sorted() {\\n                let ptr := mload(FREE_MEM_PTR)\\n                mstore(ptr, shl(224, ERROR_STRING_SELECTOR))\\n                mstore(add(ptr, 0x04), WORD_SIZE) // String offset\\n                mstore(add(ptr, 0x24), 20) // Revert reason length\\n                mstore(add(ptr, 0x44), \\\"ADDRESSES_NOT_SORTED\\\")\\n                revert(ptr, 0x64) // Revert data length is 4 bytes for selector and 3 slots of 0x20 bytes\\n            }\\n\\n            let stored_primary_pointer := sload(_ownersPrimaryPointer.slot)\\n            let primary_pointer := and(stored_primary_pointer, BITMASK_ADDRESS)\\n\\n            // if the primary pointer is already set, we can't mint\\n            // note: we don't clean the upper bits of the address, we check against the full word\\n            if gt(primary_pointer, 0) { revert_already_minted() }\\n\\n            // we expect addresses.length to be > 0\\n            if eq(addresses.length, 0) {\\n                revert_invalid_addresses()\\n            }\\n\\n            // we expect the SSTORE2 pointer to contain a list of packed addresses\\n            // so the length must be a multiple of 20 bytes\\n            if gt(mod(addresses.length, ADDRESS_SIZE_BYTES), 0) { revert_invalid_addresses() }\\n\\n            // the SSTORE2 creation code is SSTORE2_CREATION_CODE_PREFIX + addresses_data\\n            let creation_code_len := add(SSTORE2_CREATION_CODE_OFFSET, addresses.length)\\n            let creation_code_ptr := mload(FREE_MEM_PTR)\\n\\n            // copy the creation code prefix\\n            // this sets up the memory at creation_code_ptr with the following word:\\n            //      600B5981380380925939F3000000000000000000000000000000000000000000\\n            // this also has the advantage of storing fresh 0 bytes\\n            mstore(\\n                creation_code_ptr,\\n                shl(\\n                    168, // shift the prefix to the left by 21 bytes\\n                    SSTORE2_CREATION_CODE_PREFIX\\n                )\\n            )\\n\\n            // copy the address data in memory after the creation code prefix\\n            // after this call, the memory at creation_code_ptr will look like this:\\n            //      600B5981380380925939F300AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n            // note that the 00 bytes between the prefix and the first address is guaranteed to be clean\\n            // because of the shl above\\n            let addresses_data_ptr := add(creation_code_ptr, SSTORE2_CREATION_CODE_OFFSET)\\n            calldatacopy(\\n                addresses_data_ptr, // destOffset in memory\\n                addresses.offset, // offset in calldata\\n                addresses.length // length\\n            )\\n\\n            numMinted := div(addresses.length, ADDRESS_SIZE_BYTES)\\n            let prev := 0\\n            for { let i := 0 } lt(i, numMinted) {} {\\n                // compute the pointer to the recipient address\\n                let to_ptr := add(addresses_data_ptr, mul(i, ADDRESS_SIZE_BYTES))\\n\\n                // mload loads a whole 32-byte word, so we get the 20 bytes we want plus 12 bytes we don't:\\n                //      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBB\\n                // so we shift right by 12 bytes to get rid of the extra bytes and align the address:\\n                //      000000000000000000000000AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n                // this guarantees that the high bits of `to` are clean\\n                let to := shr(ADDRESS_OFFSET_BITS, mload(to_ptr))\\n\\n                // make sure that the addresses are sorted, the binary search in balanceOf relies on it\\n                if iszero(gt(to, prev)) { revert_not_sorted() }\\n\\n                prev := to\\n\\n                // counter increment, can not overflow\\n                // increment before emitting the event, because the first valid tokenId is 1\\n                i := add(i, 1)\\n\\n                // emit the Transfer event\\n                log4(\\n                    0, // dataOffset\\n                    0, // dataSize\\n                    TRANSFER_EVENT_SIGNATURE, // topic1 = signature\\n                    0, // topic2 = from\\n                    to, // topic3 = to\\n                    i // topic4 = tokenId\\n                )\\n            }\\n\\n            // perform the SSTORE2 write\\n            let clean_pointer :=\\n                create(\\n                    0, // value\\n                    creation_code_ptr, // offset\\n                    creation_code_len // length\\n                )\\n\\n            // we need to restore the upper bits that may have been set if data was packed in the same slot\\n            // stored_primary_pointer is either 0 (if the slot was clean) or [12-bytes || address(0)]\\n            // so we OR it with the clean pointer to restore the upper bits\\n            sstore(_ownersPrimaryPointer.slot, or(clean_pointer, stored_primary_pointer))\\n        }\\n    }\\n\\n    /// @dev specialized version that performs a batch mint with no safeMint checks\\n    /// @dev this function reads from an existing SSTORE2 pointer, and saves it\\n    function _mint(address pointer) internal virtual returns (uint256 numMinted) {\\n        assembly {\\n            function revert_invalid_addresses() {\\n                let ptr := mload(FREE_MEM_PTR)\\n                mstore(ptr, shl(224, ERROR_STRING_SELECTOR))\\n                mstore(add(ptr, 0x04), WORD_SIZE) // String offset\\n                mstore(add(ptr, 0x24), 17) // Revert reason length\\n                mstore(add(ptr, 0x44), \\\"INVALID_ADDRESSES\\\")\\n                revert(ptr, 0x64) // Revert data length is 4 bytes for selector and 3 slots of 0x20 bytes\\n            }\\n\\n            function revert_already_minted() {\\n                let ptr := mload(FREE_MEM_PTR)\\n                mstore(ptr, shl(224, ERROR_STRING_SELECTOR))\\n                mstore(add(ptr, 0x04), WORD_SIZE) // String offset\\n                mstore(add(ptr, 0x24), 14) // Revert reason length\\n                mstore(add(ptr, 0x44), \\\"ALREADY_MINTED\\\")\\n                revert(ptr, 0x64) // Revert data length is 4 bytes for selector and 3 slots of 0x20 bytes\\n            }\\n\\n            function revert_not_sorted() {\\n                let ptr := mload(FREE_MEM_PTR)\\n                mstore(ptr, shl(224, ERROR_STRING_SELECTOR))\\n                mstore(add(ptr, 0x04), WORD_SIZE) // String offset\\n                mstore(add(ptr, 0x24), 20) // Revert reason length\\n                mstore(add(ptr, 0x44), \\\"ADDRESSES_NOT_SORTED\\\")\\n                revert(ptr, 0x64) // Revert data length is 4 bytes for selector and 3 slots of 0x20 bytes\\n            }\\n\\n            let stored_primary_pointer := sload(_ownersPrimaryPointer.slot)\\n            let primary_pointer := and(stored_primary_pointer, BITMASK_ADDRESS)\\n\\n            // if the primary pointer is already set, we can't mint\\n            // note: we don't clean the upper bits of the address, we check against the full word\\n            if gt(primary_pointer, 0) { revert_already_minted() }\\n\\n            // zero-out the upper bits of `pointer`\\n            let clean_pointer := and(pointer, BITMASK_ADDRESS)\\n\\n            let pointer_codesize := extcodesize(clean_pointer)\\n\\n            // if pointer_codesize is 0, then it is not an SSTORE2 pointer\\n            // if pointer_codesize is 1, then it may be a valid but empty SSTORE2 pointer\\n            if lt(pointer_codesize, 2) { revert_invalid_addresses() }\\n\\n            // subtract 1 because SSTORE2 prepends the data with a `00` byte (a STOP opcode)\\n            // can not overflow because pointer_codesize is at least 2\\n            let addresses_length := sub(pointer_codesize, 1)\\n\\n            // we expect the SSTORE2 pointer to contain a list of packed addresses\\n            // so the length must be a multiple of 20 bytes\\n            if gt(mod(addresses_length, ADDRESS_SIZE_BYTES), 0) { revert_invalid_addresses() }\\n\\n            // perform the SSTORE2 read, store the data in memory at `addresses_data`\\n            let addresses_data := mload(FREE_MEM_PTR)\\n            extcodecopy(\\n                clean_pointer, // address\\n                addresses_data, // memory offset\\n                SSTORE2_DATA_OFFSET, // destination offset\\n                addresses_length // size\\n            )\\n\\n            numMinted := div(addresses_length, ADDRESS_SIZE_BYTES)\\n            let prev := 0\\n            for { let i := 0 } lt(i, numMinted) {} {\\n                // compute the pointer to the recipient address\\n                let to_ptr := add(addresses_data, mul(i, ADDRESS_SIZE_BYTES))\\n\\n                // mload loads a whole 32-byte word, so we get the 20 bytes we want plus 12 bytes we don't:\\n                //      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBB\\n                // so we shift right by 12 bytes to get rid of the extra bytes and align the address:\\n                //      000000000000000000000000AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\n                // this guarantees that the high bits of `to` are clean\\n                let to := shr(ADDRESS_OFFSET_BITS, mload(to_ptr))\\n\\n                // make sure that the addresses are sorted, the binary search in balanceOf relies on it\\n                if iszero(gt(to, prev)) { revert_not_sorted() }\\n\\n                prev := to\\n\\n                // counter increment, can not overflow\\n                // increment before emitting the event, because the first valid tokenId is 1\\n                i := add(i, 1)\\n\\n                // emit the Transfer event\\n                log4(\\n                    0, // dataOffset\\n                    0, // dataSize\\n                    TRANSFER_EVENT_SIGNATURE, // topic1 = signature\\n                    0, // topic2 = from\\n                    to, // topic3 = to\\n                    i // topic4 = tokenId\\n                )\\n            }\\n\\n            // we need to restore the upper bits that may have been set if data was packed in the same slot\\n            // stored_primary_pointer is either 0 (if the slot was clean) or [12-bytes || address(0)]\\n            // so we OR it with the clean pointer to restore the upper bits\\n            sstore(_ownersPrimaryPointer.slot, or(clean_pointer, stored_primary_pointer))\\n        }\\n    }\\n\\n    function _safeMint(address pointer) internal virtual returns (uint256 numMinted) {\\n        numMinted = _safeMint(pointer, \\\"\\\");\\n    }\\n\\n    /// @dev specialized version that performs a batch mint with a safeMint check at each iteration\\n    /// @dev in _safeMint, we try to keep assembly usage at a minimum\\n    function _safeMint(address pointer, bytes memory data) internal virtual returns (uint256 numMinted) {\\n        require(_ownersPrimaryPointer == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        bytes memory addresses = SSTORE2.read(pointer);\\n        uint256 length = addresses.length;\\n        require(length > 0 && length % 20 == 0, \\\"INVALID_ADDRESSES\\\");\\n\\n        numMinted = length / 20;\\n        address prev = address(0);\\n\\n        for (uint256 i = 0; i < numMinted;) {\\n            address to;\\n            assembly {\\n                to := shr(96, mload(add(addresses, add(32, mul(i, 20)))))\\n                i := add(i, 1)\\n            }\\n\\n            // enforce that the addresses are sorted with no duplicates, and no zero addresses\\n            require(to > prev, \\\"ADDRESSES_NOT_SORTED\\\");\\n            prev = to;\\n\\n            emit Transfer(address(0), to, i);\\n\\n            require(_checkOnERC721Received(address(0), to, i, data), \\\"UNSAFE_RECIPIENT\\\");\\n        }\\n\\n        _ownersPrimaryPointer = pointer;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/SS2ERC721/src/SS2ERC721I.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {SS2ERC721} from \\\"./SS2ERC721.sol\\\";\\nimport {Initializable} from \\\"./common/utils/Initializable.sol\\\";\\n\\n/// @notice Initializable version of SS2ERC721\\nabstract contract SS2ERC721I is SS2ERC721, Initializable {\\n    /*//////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor() SS2ERC721(\\\"\\\", \\\"\\\") {\\n        _lockInitializers();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              INITIALIZER\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function __SS2ERC721_init(string memory _name, string memory _symbol) internal onlyInitializing {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/SS2ERC721/src/common/SS2ERC721Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC721, ERC721TokenReceiver} from \\\"solmate/tokens/ERC721.sol\\\";\\n\\nabstract contract SS2ERC721Base is ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WORD_SIZE = 32;\\n    uint256 internal constant ADDRESS_SIZE_BYTES = 20;\\n    uint256 internal constant ADDRESS_OFFSET_BITS = 96;\\n    uint256 internal constant FREE_MEM_PTR = 0x40;\\n    uint256 internal constant SSTORE2_DATA_OFFSET = 1;\\n    uint256 internal constant ERROR_STRING_SELECTOR = 0x08c379a0; // Error(string)\\n    uint256 internal constant SSTORE2_CREATION_CODE_PREFIX = 0x600B5981380380925939F3; // see SSTORE2.sol\\n    uint256 internal constant SSTORE2_CREATION_CODE_OFFSET = 12; // prefix length + 1 for a 0 byte\\n\\n    // The `Transfer` event signature is given by:\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    bytes32 internal constant TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    // The mask of the lower 160 bits for addresses.\\n    uint256 internal constant BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n    /// @dev a flag for _balanceIndicator\\n    uint256 internal constant SKIP_PRIMARY_BALANCE = 1 << 255;\\n\\n    /// @dev a flag for _ownerIndicator\\n    /// @dev use a different value then SKIP_PRIMARY_BALANCE to avoid confusion\\n    uint256 internal constant BURNED = 1 << 254;\\n\\n    uint256 internal constant BALANCE_MASK = type(uint256).max >> 1;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            MUTABLE STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev mapping from token id to indicator (owner address plus burned flag packed in the higher bits)\\n    mapping(uint256 => uint256) internal _ownerIndicator;\\n\\n    /// @dev 255-bit balance + 1-bit not primary owner flag\\n    ///\\n    /// - ownerIndicator[id] == 0 == (not_burned, address(0))\\n    ///     means that there is no secondary owner for id and we should fall back to the primary owner check\\n    ///\\n    /// - ownerIndicator[id] == (burned, address(0))\\n    ///     means that address(0) *is* the secondary owner, no need to fall back on the primary owner check\\n    ///\\n    /// - ownerIndicator[id] == (not_burned, owner)\\n    ///     means that `owner` is the secondary owner, no need to fall back on the primary owner check\\n    mapping(address => uint256) internal _balanceIndicator;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             VIEW FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// implementations must override this function to return the number of tokens minted\\n    function _ownersPrimaryLength() internal view virtual returns (uint256);\\n\\n    /// implementations must override this function to return the primary owner of a token\\n    /// or address(0) if the token does not exist\\n    function _ownerOfPrimary(uint256 id) internal view virtual returns (address owner);\\n\\n    /// @dev performs no bounds check, just a raw extcodecopy on the pointer\\n    /// @return addr the address at the given pointer (may include 0 bytes if reading past the end of the pointer)\\n    function SSTORE2_readRawAddress(address pointer, uint256 start) internal view returns (address addr) {\\n        // we're going to read 20 bytes from the pointer in the first scratch space slot\\n        uint256 dest_offset = 12;\\n\\n        assembly {\\n            start := add(start, 1) // add the SSTORE2 DATA_OFFSET\\n\\n            // clear it the first scratch space slot\\n            mstore(0, 0)\\n\\n            extcodecopy(pointer, dest_offset, start, 20)\\n\\n            addr := mload(0)\\n        }\\n    }\\n\\n    function _getOwnerSecondary(uint256 id) internal view returns (address owner) {\\n        owner = address(uint160(_ownerIndicator[id]));\\n    }\\n\\n    function _setOwnerSecondary(uint256 id, address owner) internal {\\n        if (owner == address(0)) {\\n            _setBurned(id);\\n        } else {\\n            // we don't expect this to be called after burning, so no need to carry over the BURNED flag\\n            _ownerIndicator[id] = uint160(owner);\\n        }\\n    }\\n\\n    function _hasBeenBurned(uint256 id) internal view returns (bool) {\\n        return _ownerIndicator[id] & BURNED != 0;\\n    }\\n\\n    /// @dev sets the burned flag *and* sets the owner to address(0)\\n    function _setBurned(uint256 id) internal {\\n        _ownerIndicator[id] = BURNED;\\n    }\\n\\n    // binary search of the address based on _ownerOfPrimary\\n    // performs O(log n) sloads\\n    // relies on the assumption that the list of addresses is sorted and contains no duplicates\\n    // returns 1 if the address is found in _ownersPrimary, 0 if not\\n    function _balanceOfPrimary(address owner) internal view returns (uint256) {\\n        uint256 low = 1;\\n        uint256 high = _ownersPrimaryLength();\\n        uint256 mid = (low + high) / 2;\\n\\n        // TODO: unchecked\\n        while (low <= high) {\\n            address midOwner = _ownerOfPrimary(mid);\\n            if (midOwner == owner) {\\n                return 1;\\n            } else if (midOwner < owner) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n            mid = (low + high) / 2;\\n        }\\n\\n        return 0;\\n    }\\n\\n    /// @dev for internal use -- does not revert on unminted token ids\\n    function __ownerOf(uint256 id) internal view returns (address owner) {\\n        uint256 ownerIndicator = _ownerIndicator[id];\\n        owner = address(uint160(ownerIndicator));\\n\\n        if (ownerIndicator & BURNED == BURNED) {\\n            // normally 0, but return what has been set in the mapping in case inherited contract changes it\\n            return owner;\\n        }\\n\\n        // we use 0 as a sentinel value, meaning that we can't burn by setting the owner to address(0)\\n        if (owner == address(0)) {\\n            owner = _ownerOfPrimary(id);\\n        }\\n    }\\n\\n    function ownerOf(uint256 id) public view virtual override returns (address owner) {\\n        owner = __ownerOf(id);\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual override returns (uint256 balance) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        uint256 balanceIndicator = _balanceIndicator[owner];\\n        balance = balanceIndicator & BALANCE_MASK;\\n\\n        if (balanceIndicator & SKIP_PRIMARY_BALANCE == 0) {\\n            balance += _balanceOfPrimary(owner);\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual override {\\n        // need to use the ownerOf getter here instead of directly accessing the storage\\n        address owner = __ownerOf(id);\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 id) public virtual override {\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id], \\\"NOT_AUTHORIZED\\\"\\n        );\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        address owner = _moveTokenTo(id, to);\\n\\n        require(from == owner, \\\"WRONG_FROM\\\");\\n\\n        unchecked {\\n            ++_balanceIndicator[to];\\n        }\\n    }\\n\\n    /// @dev needs to be overridden here to invoke our custom version of transferFrom\\n    function safeTransferFrom(address from, address to, uint256 id) public virtual override {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0\\n                || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\")\\n                    == ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /// @dev needs to be overridden here to invoke our custom version of transferFrom\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public virtual override {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0\\n                || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)\\n                    == ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _burn(uint256 id) internal virtual override {\\n        _moveTokenTo(id, address(0));\\n    }\\n\\n    function _moveTokenTo(uint256 id, address to) private returns (address owner) {\\n        owner = _getOwnerSecondary(id);\\n\\n        if (owner == address(0)) {\\n            owner = _ownerOfPrimary(id);\\n            require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n            _balanceIndicator[owner] |= SKIP_PRIMARY_BALANCE;\\n        } else {\\n            unchecked {\\n                --_balanceIndicator[owner];\\n            }\\n        }\\n\\n        _setOwnerSecondary(id, to);\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, to, id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\\n        internal\\n        returns (bool)\\n    {\\n        if (to.code.length == 0) {\\n            return true;\\n        }\\n\\n        try ERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\\n            return retval == ERC721TokenReceiver.onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert(\\\"UNSAFE_RECIPIENT\\\");\\n            } else {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/SS2ERC721/src/common/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient Initializable implementation with no reinitializers\\n/// @dev warning: this contract is not compatible with OpenZeppelin's Initializable\\n/// @dev warning: this should be considered very experimental\\n/// @author karmacoma\\nabstract contract Initializable {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Initialized();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    enum InitState {\\n        NOT_INITIALIZED,\\n        INITIALIZING,\\n        INITIALIZED\\n    }\\n\\n    InitState private _initState;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INITIALIZABLE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier initializer() {\\n        bool isTopLevelCall = _initState == InitState.NOT_INITIALIZED;\\n\\n        require((isTopLevelCall) || (_initState == InitState.INITIALIZING), \\\"ALREADY_INITIALIZED\\\");\\n        if (isTopLevelCall) {\\n            _initState = InitState.INITIALIZING;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initState = InitState.INITIALIZED;\\n            emit Initialized();\\n        }\\n    }\\n\\n    modifier onlyInitializing() {\\n        require(_initState == InitState.INITIALIZING, \\\"NOT_INITIALIZING\\\");\\n        _;\\n    }\\n\\n    /// locks the contract, preventing any further initialization\\n    function _lockInitializers() internal virtual {\\n        require(_initState == InitState.NOT_INITIALIZED, \\\"MUST_BE_NOT_INITIALIZED\\\");\\n        _initState = InitState.INITIALIZED;\\n        emit Initialized();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC2981Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n    function register(address registrant) external;\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n    function unregister(address addr) external;\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n    function subscriptionOf(address addr) external returns (address registrant);\\n    function subscribers(address registrant) external returns (address[] memory);\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n    function filteredOperators(address addr) external returns (address[] memory);\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n    function isRegistered(address addr) external returns (bool);\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"SS2ERC721/=lib/SS2ERC721/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/operator-filter-registry/lib/openzeppelin-contracts/contracts/\",\r\n      \"operator-filter-registry/=lib/operator-filter-registry/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"BadAttribute\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"IntegerOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SoldOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimeLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldExternalUrl\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newExternalUrl\",\"type\":\"string\"}],\"name\":\"ExternalUrlUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operatorFilter\",\"type\":\"address\"}],\"name\":\"OperatorFilterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"PropertyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANONICAL_OPENSEA_REGISTRY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CANONICAL_OPENSEA_SUBSCRIPTION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeOperatorFilter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"animationUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editionSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableDefaultOperatorFilter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endOfMintPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"externalUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPrimaryOwnersPointer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"imageUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_animationUrl\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_imageUrl\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_editionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_royaltyBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintPeriodSeconds\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"isApprovedMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMintingEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"isPrimaryOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"name\":\"mintBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"addresses\",\"type\":\"bytes\"}],\"name\":\"mintBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setApprovedMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_externalUrl\",\"type\":\"string\"}],\"name\":\"setExternalUrl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operatorFilter\",\"type\":\"address\"}],\"name\":\"setOperatorFilter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"values\",\"type\":\"string[]\"}],\"name\":\"setStringProperties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SingleBatchEdition", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}