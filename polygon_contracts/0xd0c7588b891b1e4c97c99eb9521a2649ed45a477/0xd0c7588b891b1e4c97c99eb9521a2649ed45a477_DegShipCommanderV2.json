{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DegShipCommanderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./DegShipFactoryV2.sol\\\";\\nimport \\\"./interfaces/IDegShipV2.sol\\\";\\nimport \\\"./interfaces/IDegCrewExtend.sol\\\";\\nimport \\\"./interfaces/IDegShipCommanderV2.sol\\\";\\nimport \\\"./interfaces/IDegSwap.sol\\\";\\n\\ncontract DegShipCommanderV2 is IDegShipCommanderV2, Ownable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    IDegShipFactoryV2 public shipFactory;\\n    IDegCrewExtend public immutable shipCrew;\\n\\n    IDegSwap public degSwap = IDegSwap(0x10eC58aB42691f0108cC6f06C017bb00366e427D);\\n\\n    uint256 private constant MAX = type(uint256).max;\\n\\n    mapping(address => uint256) public shipRewardPool;\\n    mapping(address => uint256) public shipTotalReward;\\n\\n    bool public isUpdateShipOrder;\\n    mapping(address => mapping(address => bool)) public shipPointCollect;\\n\\n    mapping(address => uint256) public luckPool;\\n    mapping(address => bool) public luckDividend;\\n\\n    address[] public feeReceiver;\\n\\n    struct LastedDeposit{\\n        string serial;\\n        address user;\\n        uint256 amount;\\n        uint256 time;\\n    }\\n\\n    LastedDeposit[] public lastedDeposits;\\n\\n    mapping(uint => uint256) public dayRecordPool;\\n    mapping(uint => uint256) public dayInvestTotal;\\n    mapping(uint => mapping(address => uint256)) public dayUserInvestTotal;\\n\\n    uint public immutable aDay = 1 days; \\n    uint public immutable startTime;\\n    uint public recordDay;\\n\\n    constructor(\\n        address _crewAddress\\n    ) {\\n        startTime = 1681941600;\\n        shipFactory = new DegShipFactoryV2(startTime, aDay, address(this), msg.sender);\\n        shipCrew = IDegCrewExtend(_crewAddress);   \\n    }\\n\\n    receive() external payable {}\\n\\n    modifier onlyCrewOrShip() {\\n        require(msg.sender == address(shipCrew) || shipCrew.isCaller(msg.sender) || msg.sender == owner(), \\\"Wrong ship or crew by address\\\");\\n        _;\\n    }\\n\\n    modifier onlyCrew(){\\n        require(msg.sender == address(shipCrew), \\\"Wrong crew call\\\");\\n        _;\\n    }\\n\\n    function setFeeReceiver(address[] memory _addrs) external onlyOwner{\\n        feeReceiver = _addrs;\\n    }\\n\\n    function setShipFactory(address _factory) external onlyOwner{\\n        shipFactory = IDegShipFactoryV2(_factory);\\n    }\\n\\n    function getSerials() external view returns (string[] memory) {\\n        return shipFactory.getSerials();\\n    }\\n\\n    function crewAddress() external view returns (address) {\\n        return address(shipCrew);\\n    }\\n\\n    function initNewSerialShip(string memory serial, uint256 ticketPrice, uint256 percent, uint256 perCycle) private returns (address newShip){\\n        newShip = shipFactory.shipCreated(serial, shipFactory.serialIndex(serial), ticketPrice, percent, perCycle);\\n    }\\n\\n    function createNewSerialShip(string memory serial, uint256 ticketPrice, uint256 percent, uint256 perCycle) external onlyOwner{\\n        require(shipFactory.serialShip(serial) == address(0), \\\"Serial exist\\\");\\n        address shipAddr = initNewSerialShip(serial, ticketPrice, percent, perCycle);\\n        shipCrew.addCaller(shipAddr);\\n        shipFactory.setSerialShip(serial, shipAddr);\\n    }\\n\\n    event EventShipIncome(address indexed _ship, uint256 _amount);\\n\\n    function shipIncome(address _ship, uint256 _income) private {\\n        unchecked {\\n            shipRewardPool[_ship] += _income;\\n        }\\n        emit EventShipIncome(_ship, _income);\\n    }\\n\\n    event EventShipOutcome(address indexed _ship, uint256 _amount);\\n    event EventShipInsufficientReward(address indexed _ship);\\n\\n    function shipOutcome(address _ship, address _user, uint256 _outcome) external onlyCrewOrShip() {\\n        uint256 nowReleaseToken = shipReleaseAmountToStop(_ship);\\n        _outcome = nowReleaseToken >= _outcome ? _outcome : nowReleaseToken;\\n        if( _outcome > 0 ){\\n            unchecked {\\n                shipTotalReward[_ship] += _outcome;\\n            }\\n            address ticket = shipFactory.getTicketTokenByShip(_ship);\\n            if (ticket == address(0)){\\n                payable(_user).transfer(_outcome);\\n            }else{\\n                IERC20(ticket).transfer(_user, _outcome);\\n            }\\n            emit EventShipOutcome(_ship, _outcome);\\n        } else {\\n            emit EventShipInsufficientReward(_ship);\\n        }\\n    }\\n\\n    function shipReleaseAmountToStop(address _ship) public view returns (uint256) {\\n        return shipRewardPool[_ship] > shipTotalReward[_ship] ? shipRewardPool[_ship].sub(shipTotalReward[_ship]) : 0;\\n    }\\n\\n    function checkShipStop(address _ship) public view returns (bool) {\\n        if (shipRewardPool[_ship] > 0 && shipReleaseAmountToStop(_ship) == 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    event EventDestroyShipOfSerial(address indexed oldShip, address indexed newShip);\\n\\n    function destroyShipOfSerial(string memory serial) private {\\n        address oldShip = shipFactory.serialShip(serial);\\n        uint256 percents = IDegShipV2(oldShip).dayRewardPercents();\\n        uint256 perCycle = IDegShipV2(oldShip).dayPerCycle();\\n        uint256 shipPrice = shipFactory.ticketAmount(serial);\\n        address newShip = initNewSerialShip(serial, shipPrice, percents,perCycle);\\n        shipCrew.addCaller(newShip);\\n        shipFactory.addSerialNewShip(serial, newShip);\\n        emit EventDestroyShipOfSerial(oldShip, newShip);\\n    }\\n\\n    function shipIndexStatus(string memory serial, uint8 sindex) external view returns (bool) {\\n        address ship = shipFactory.serialIndexShip(serial, sindex);\\n        return IDegShipV2(ship).stopped();\\n    }\\n\\n    function _basicDistributeDeposit(address _ticket, address _ship, uint256 _amount) private returns (uint256 totalFee){\\n        uint256 nodeFee = _amount.mul(3).div(1000);\\n        uint256 daoFee = _amount.mul(2).div(1000);\\n        uint256 techFee = _amount.mul(1).div(1000);\\n        uint256 coinFee = _amount.mul(10).div(1000);\\n        uint256 fomoFee = _amount.mul(2).div(1000);\\n\\n        if (_ticket == address(0)) {\\n            payable(feeReceiver[0]).transfer(nodeFee);\\n            payable(feeReceiver[1]).transfer(daoFee);\\n            payable(feeReceiver[2]).transfer(coinFee);\\n            payable(feeReceiver[3]).transfer(techFee);\\n            if (shipFactory.isLuckPoolByShip(_ship) == false){\\n                payable(feeReceiver[4]).transfer(fomoFee);\\n            }\\n        } else {\\n            IERC20(_ticket).transfer(feeReceiver[0], nodeFee);\\n            IERC20(_ticket).transfer(feeReceiver[1], daoFee);\\n            IERC20(_ticket).transfer(feeReceiver[3], techFee);\\n            uint256 totalCollect = coinFee;\\n            if (shipFactory.isLuckPoolByShip(_ship) == false){\\n                totalCollect += fomoFee;\\n            }\\n            IERC20(_ticket).transfer(feeReceiver[4], totalCollect);\\n        }\\n        if (shipFactory.isLuckPoolByShip(_ship) == true){\\n            luckPool[_ship] += fomoFee;\\n        }\\n\\n        if (_ticket == address(0)) {\\n            // only origin coin mint coin\\n            dayRecordPool[recordDay] += coinFee;\\n        }\\n        unchecked {\\n            totalFee = nodeFee + daoFee + coinFee + techFee + fomoFee;\\n        }\\n    }\\n\\n    function _distributeDeposit(address _ticket, address _ship, uint256 _amount) private {\\n        uint256 totalFee = _basicDistributeDeposit(_ticket, _ship, _amount);\\n        uint256 _poolAmount = _amount.sub(totalFee);\\n        // Record pool amount\\n        shipIncome(_ship, _poolAmount);\\n    }\\n\\n    function register(address refer) external {\\n        require(refer != msg.sender, \\\"Cannot refer your self\\\");\\n        require(refer != address(0), \\\"Refer is illegel\\\");\\n        shipCrew.register(msg.sender, refer);\\n    }\\n\\n    event ShipStopped(address indexed _ship);\\n\\n    modifier recordDayModifier() {\\n        if (getDay() > recordDay){\\n            recordDay = getDay();\\n        }\\n        _;\\n    }\\n\\n    modifier prepareShipStock(string memory serial) {\\n        if (!shipFactory.stockReset(serial, recordDay) && shipFactory.shipSupply(serial) > 0) {\\n            shipFactory.setDayShipStock(serial, recordDay, shipFactory.shipSupply(serial));\\n        }\\n        _;\\n    }\\n\\n    event CheckLastShipPointEvent(address indexed _user, address indexed _ship, uint256 _amount);\\n\\n    function checkLastShipPoint(address _user, string memory _serial) private {\\n        // check my last ship point\\n        address lastShip = shipFactory.lastShipOfSerial(_serial);\\n        if (lastShip != address(0)) {\\n            uint nowOrderId = shipCrew.userTakeOrderInShip(_user, lastShip);\\n            if (nowOrderId > 0) {\\n                uint256 amount = IDegShipV2(lastShip).orderAmountByUnfreezeId(_user, nowOrderId - 1);\\n                if ( amount > 0 ) {\\n                    if (isUpdateShipOrder) {\\n                        // will open to use this function after M0T1 banned\\n                        IDegShipV2(lastShip).destroyUserOrder(_user, nowOrderId - 1);\\n                        shipCrew.addUserPointBalance(_user, amount);\\n                        emit CheckLastShipPointEvent(_user, lastShip, amount);\\n                    } else if (!shipPointCollect[lastShip][_user]){\\n                        // fixed old version ship contract, it'll unused after the second ship destroyed\\n                        shipCrew.addUserPointBalance(_user, amount);\\n                        shipPointCollect[lastShip][_user] = true;\\n                        emit CheckLastShipPointEvent(_user, lastShip, amount);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function afterLaunch(address _token, string memory serial, address _ship, uint256 _amount) private {\\n        // record invest order infos\\n        if (_token == address(0)){\\n            recordMintCoin(msg.sender, _amount);\\n        }\\n        recordDeposits(serial, msg.sender, _amount);\\n        // ship stopped gameover\\n        bool _checkShipStatus = checkShipStop(_ship);\\n        if ( _checkShipStatus ) {\\n            // stopped start another ship\\n            luckDividend[_ship] = true;\\n            if(shipFactory.shipFactoryAutoMaker(serial)) {\\n                destroyShipOfSerial(serial);\\n            }\\n            emit ShipStopped(_ship);\\n        }\\n    }\\n\\n    function beforOrderCheck(address _ship) private view {\\n        require(_ship != address(0), \\\"Invalid ship serial\\\");\\n        bool _shipStatus = IDegShipV2(_ship).stopped();\\n        require(!_shipStatus, \\\"Ship stopped\\\");\\n        // check last order and this order is passed\\n    }\\n\\n    function getDay() public view returns (uint) {\\n        if (block.timestamp > startTime){\\n            return (block.timestamp - startTime) / aDay;\\n        }else{\\n            return 0;\\n        }\\n    }\\n\\n    function shipStockCheck(string memory serial) public view returns(uint) {\\n        if (shipFactory.stockReset(serial, recordDay)) {\\n            return shipFactory.shipStocks(serial, recordDay);\\n        } else {\\n            return shipFactory.shipSupply(serial);\\n        }\\n    }\\n\\n    event EventLaunch(address indexed _user, address indexed _ship, uint256 _amount, uint _orderIndex);\\n    event EventReLaunch(address indexed _user, address indexed _ship, uint256 _amount, uint _orderIndex);\\n\\n    // serial's ticket token and amount\\n    function ticketTokenAndAmount(string memory serial) public view returns(address ticketToken, uint256 ticketAmount){\\n        ticketToken = shipFactory.ticketToken(serial);\\n        ticketAmount = shipFactory.ticketAmount(serial); \\n    }\\n\\n    function launchShip(string memory serial, uint256 _amount) external payable recordDayModifier prepareShipStock(serial) {\\n        address _ticketToken;\\n        uint256 ticketAmount;\\n        (_ticketToken, ticketAmount) = ticketTokenAndAmount(serial);\\n        require(_amount >= ticketAmount && _amount.mod(ticketAmount) == 0, \\\"Ticket amount err\\\");\\n        require(_amount.div(ticketAmount) <= shipFactory.limitLaunchNum(serial), \\\"Overflow the num\\\");\\n        address _launchShipAddr = shipFactory.serialShip(serial);\\n        beforOrderCheck(_launchShipAddr);\\n\\n        if (shipFactory.shipSupply(serial) > 0){\\n            require(shipStockCheck(serial) >= _amount, \\\"Insufficient stocks\\\");\\n        }\\n\\n        address _refer = shipCrew.checkRefer(msg.sender);\\n        require(_refer != address(0), \\\"Regist first\\\");\\n        // user now order index\\n        uint nowOrderId = shipCrew.userTakeOrderInShip(msg.sender, _launchShipAddr);\\n        require(nowOrderId == 0, \\\"Must new launch\\\");\\n        // pay ticket\\n        if(_ticketToken == address(0)){\\n            require(msg.value >= _amount, \\\"pay amount error\\\");\\n        }else{\\n            IERC20(_ticketToken).transferFrom(msg.sender, address(this), _amount);\\n        }\\n        \\n        _distributeDeposit(_ticketToken, _launchShipAddr, _amount);\\n        // check last ship point\\n        checkLastShipPoint(msg.sender, serial);\\n        // main launch the ship\\n        IDegShipV2(_launchShipAddr).launch(msg.sender, _amount, nowOrderId);\\n\\n        if (shipFactory.shipSupply(serial) > 0) {\\n            shipFactory.subStock(serial, recordDay, _amount);\\n        }\\n        afterLaunch(_ticketToken, serial, _launchShipAddr, _amount);\\n        // user point to dividend\\n        shipCrew.pointDividend(msg.sender, _launchShipAddr);\\n        // trigger collect my deg mint\\n        degSwap.collectUserDegBal(msg.sender);\\n        emit EventLaunch(msg.sender, _launchShipAddr, _amount, nowOrderId);\\n    }\\n\\n    function reEntry(string memory serial) external payable recordDayModifier prepareShipStock(serial) {\\n        address _launchShipAddr = shipFactory.serialShip(serial);\\n        // check ship status\\n        beforOrderCheck(_launchShipAddr);\\n        uint nowOrderId = shipCrew.userTakeOrderInShip(msg.sender, _launchShipAddr);\\n        require(nowOrderId > 0, \\\"None order regist\\\");\\n        uint256 _amount = IDegShipV2(_launchShipAddr).orderAmountById(msg.sender, nowOrderId - 1);\\n        bool _condition = IDegShipV2(_launchShipAddr).checkOrderCondition(msg.sender, nowOrderId - 1, _amount);\\n        require(_condition, \\\"Order condition is not allowed!\\\");\\n        // relaunch now ship\\n        address _ticketToken = shipFactory.ticketToken(serial);\\n        // pay ticket\\n        if(_ticketToken == address(0)){\\n            require(msg.value >= _amount, \\\"pay amount error\\\");\\n        }else{\\n            IERC20(_ticketToken).transferFrom(msg.sender, address(this), _amount);\\n        }\\n\\n        _distributeDeposit(_ticketToken, _launchShipAddr, _amount);\\n        // check last ship point\\n        // checkLastShipPoint(msg.sender, serial); only launch to check\\n        // relaunch\\n        IDegShipV2(_launchShipAddr).reLaunch(msg.sender, nowOrderId);\\n        // after launch process\\n        afterLaunch(_ticketToken, serial, _launchShipAddr, _amount);\\n        // user point to dividend\\n        shipCrew.pointDividend(msg.sender, _launchShipAddr);\\n        // trigger collect my deg mint\\n        degSwap.collectUserDegBal(msg.sender);\\n        emit EventReLaunch(msg.sender, _launchShipAddr, _amount, nowOrderId);\\n    }\\n\\n    function fomoBonusAmount(uint totalAmout) public pure returns(uint256 firstBonus, uint256 secondBonus, uint256 thirdBonus) {\\n        uint256 thirdTotalBouns = totalAmout.mul(50).div(100);\\n        thirdBonus = thirdTotalBouns.div(46);\\n        uint256 secondTotalBonus = totalAmout.mul(20).div(100);\\n        secondBonus = secondTotalBonus.div(3);\\n        firstBonus = totalAmout.sub(thirdTotalBouns).sub(secondTotalBonus);\\n    }\\n\\n    // share fomo bonus trigger by any one\\n    function dividendFomoBonus(address _ship) external {\\n        require(luckDividend[_ship], \\\"Ship not ended\\\");\\n        uint256 totalPool = luckPool[_ship];\\n        require(totalPool > 0, \\\"Pool is empty\\\");\\n        address ticketToken = shipFactory.getTicketTokenByShip(_ship);\\n        uint totalInvestor = IDegShipV2(_ship).getDepositorsLength();\\n        if (totalInvestor > 0) {\\n            uint endIndex = totalInvestor - 1;\\n            uint startIndex = endIndex > 50 ? endIndex - 50 : 0;\\n\\n            (uint256 firstBonus, uint256 secondBonus, uint256 thirdBonus) = fomoBonusAmount(totalPool);\\n            uint256 remindBonus = totalPool;\\n            for (uint i = startIndex + 1; i <= endIndex; i++) {\\n                address accuqire = IDegShipV2(_ship).depositors(i);\\n                uint bonus;\\n                if (i == endIndex) {\\n                    //30%\\n                    bonus = firstBonus;\\n                } else if(i > endIndex - 4 && i < endIndex){\\n                    //20% div 3\\n                    bonus = secondBonus;\\n                } else {\\n                    bonus = thirdBonus;\\n                }\\n                if( bonus > 0 ){\\n                    if (ticketToken == address(0)) {\\n                        payable(accuqire).transfer(bonus);\\n                    } else {\\n                        IERC20(ticketToken).transfer(accuqire, bonus);\\n                    }\\n                    remindBonus -= bonus;\\n                }\\n            }\\n\\n            if (remindBonus > 0){\\n                if (ticketToken == address(0)) {\\n                    payable(feeReceiver[4]).transfer(remindBonus);\\n                } else {\\n                    IERC20(ticketToken).transfer(feeReceiver[4], remindBonus);\\n                }\\n            }\\n        }\\n        luckPool[_ship] = 0;\\n    }\\n\\n    // check my bonus point\\n    function checkMyPoint(string memory _serial) external payable {\\n        checkLastShipPoint(msg.sender, _serial);\\n    }\\n\\n    function getLastedDepositsLength() external view returns (uint) {\\n        return lastedDeposits.length;\\n    }\\n\\n    function recordMintCoin(address _user, uint256 _amount) private {\\n        uint _today = getDay();\\n        unchecked {\\n            dayInvestTotal[_today] += _amount;\\n            dayUserInvestTotal[_today][_user] += _amount;\\n        }\\n    }\\n\\n    function recordDeposits(string memory _serial, address _user, uint256 _amount) private {\\n        lastedDeposits.push(LastedDeposit(\\n            _serial,\\n            _user,\\n            _amount,\\n            block.timestamp\\n        ));\\n    }\\n\\n    function collectGas(address _addr) external onlyOwner {\\n        payable(_addr).transfer(address(this).balance);\\n    }\\n\\n    function emergencyWithdraw(address _token, address _user, uint256 _amount) external onlyOwner {\\n        IERC20(_token).transfer(_user, _amount);\\n    }\\n\\n    function setDegSwap(address _addr) external onlyOwner{\\n        degSwap = IDegSwap(_addr);\\n    }\\n\\n    function setUpdateShipOrder(bool _flag) external onlyOwner{\\n        isUpdateShipOrder = _flag;\\n    }\\n}\"\r\n    },\r\n    \"contracts/DegShipFactoryV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IDegShipFactoryV2.sol\\\";\\nimport \\\"./libraries/Strings.sol\\\";\\nimport \\\"./DegShipV2.sol\\\";\\n\\ncontract DegShipFactoryV2 is IDegShipFactoryV2, Ownable {\\n    \\n    string[] public serials;\\n    mapping(string => address) public serialShip; // serial's ship address\\n    mapping(string => uint256) public serialIndex; // serial's ship round\\n    mapping(address => string) public shipToSerial; // record ship's serial\\n    mapping(string => mapping(uint256 => address)) public serialIndexShip;\\n\\n    mapping(string => bool) public shipFactoryAutoMaker;\\n    mapping(string => address) public ticketToken;\\n    mapping(string => uint256) public ticketAmount;\\n\\n    mapping(string => uint) public limitLaunchNum;\\n    mapping(string => uint256) public shipSupply;\\n    mapping(string => mapping(uint => uint256)) public shipStocks;\\n    mapping(string => mapping(uint => bool)) public stockReset;\\n\\n    mapping(string => bool) public isLuckPool;\\n\\n    address public commander;\\n    mapping(address => bool) public isCaller;  // contract caller allowed\\n\\n    uint public immutable startTime;\\n    uint public immutable factoryDay;\\n\\n    constructor (uint _time, uint _ady, address _commander, address _ow){\\n        startTime = _time;\\n        factoryDay = _ady;\\n        commander = _commander; \\n        isCaller[_commander] = true;\\n        _transferOwnership(_ow);\\n    }\\n\\n    modifier onlyCaller() {\\n        require(isCaller[msg.sender] || msg.sender == owner(), \\\"Wrong Caller\\\");\\n        _;\\n    }\\n\\n    function setCommander(address _commander) external onlyOwner{\\n        isCaller[commander] = false;\\n        commander = _commander;\\n        isCaller[_commander] = true;\\n    }\\n\\n    function setCaller(address _caller, bool _flag) external onlyOwner{\\n        isCaller[_caller] = _flag;\\n    }\\n\\n    // must need set when the ship start up\\n    function setSerialTicketPrice(string memory _serial, uint256 amount) external onlyOwner{\\n        ticketAmount[_serial] = amount;\\n    }\\n\\n    function setSerialTicketToken(string memory _serial, address token) external onlyOwner{\\n        ticketToken[_serial] = token;\\n    }\\n\\n    function addSerials(string memory _serial) external onlyOwner{\\n        require(serialShip[_serial] == address(0), \\\"Serial exist\\\");\\n        serials.push(_serial);\\n        shipFactoryAutoMaker[_serial] = true;\\n    }\\n\\n    function setShipFactoryAutoMaker(string memory _serial, bool _flag) external onlyOwner{\\n        shipFactoryAutoMaker[_serial] = _flag;\\n    }\\n\\n    function setShipSupply(string memory _serial, uint256 _num) external onlyOwner{\\n        shipSupply[_serial] = _num;\\n    }\\n\\n    function setStockReset(string memory _serial, uint _day, bool _flag) external onlyOwner{\\n        stockReset[_serial][_day] = _flag;\\n    }\\n\\n    function setShipLimitNum(string memory _serial, uint _num) external onlyOwner{\\n        limitLaunchNum[_serial] = _num;\\n    }\\n\\n    // private function\\n    function addSerialShip(string memory _serial, address _ship) private {\\n        serialShip[_serial] = _ship;\\n        shipToSerial[_ship] = _serial;\\n    }\\n\\n    function addSerialIndexShip(string memory _serial, uint256 _index, address _ship) private{\\n        serialIndexShip[_serial][_index] = _ship;\\n    }\\n\\n    event ShipCreated(address indexed _ship, string _serial, uint256 _index, uint256 _price);\\n    // commaner function\\n    function shipCreated(\\n        string memory _serial, \\n        uint256 _index, \\n        uint256 _amount,\\n        uint256 percent, \\n        uint256 perCycle) external onlyCaller returns (address ship) {\\n        require(shipFactoryAutoMaker[_serial], \\\"Serial make ship closed\\\");\\n        address newShip = address(new DegShipV2());\\n        ticketAmount[_serial] = _amount;\\n        if (limitLaunchNum[_serial] == 0){\\n            limitLaunchNum[_serial] = 1;\\n        }\\n        IDegShipV2(newShip).initialize(commander, _serial, string(abi.encodePacked(_serial, Strings.toString(_index))), percent, perCycle);\\n        ship = newShip;\\n        emit ShipCreated(newShip, _serial, _index, _amount);\\n    }\\n\\n    function setSerialShip(string memory _serial, address _ship) external onlyCaller{\\n        addSerialShip(_serial, _ship);\\n        addSerialIndexShip(_serial, serialIndex[_serial], _ship);\\n    }\\n\\n    function addSerialNewShip(string memory _serial, address _newShip) external onlyCaller{\\n        addSerialShip(_serial, _newShip);\\n        serialIndex[_serial] += 1;\\n        addSerialIndexShip(_serial, serialIndex[_serial], _newShip);\\n    }\\n\\n    function setDayShipStock(string memory _serial, uint _day, uint256 _num) external onlyCaller{\\n        shipStocks[_serial][_day] = _num;\\n        stockReset[_serial][_day] = true;\\n    }\\n\\n    function subStock(string memory _serial, uint _day, uint256 _num) external onlyCaller{\\n        shipStocks[_serial][_day] -= _num;\\n    }\\n\\n    function setLuckPoolStatus(string memory _serial, bool _luck) external onlyCaller{\\n        isLuckPool[_serial] = _luck;\\n    }\\n\\n    // public function\\n    function getDay() public view returns (uint){\\n        if ( block.timestamp > startTime){\\n            return (block.timestamp - startTime) / factoryDay;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function getSerialLen() public view returns (uint256){\\n        return serials.length;\\n    }\\n\\n    function getSerials() public view returns (string[] memory){\\n        return serials;\\n    }\\n\\n    function getSerialByIndex(uint256 _index) public view returns (string memory){\\n        return serials[_index];\\n    }\\n\\n    function getTicketTokenByShip(address _ship) public view returns (address){\\n        return ticketToken[shipToSerial[_ship]];\\n    }\\n\\n    function getTicketAmountByShip(address _ship) public view returns (uint256){\\n        return ticketAmount[shipToSerial[_ship]];\\n    }\\n\\n    function isLuckPoolByShip(address _ship) public view returns (bool){\\n        return isLuckPool[shipToSerial[_ship]];\\n    }\\n\\n    // last ship\\n    function lastShipOfSerial(string memory _serail) public view returns(address _ship) {\\n        if (serialIndex[_serail] > 0) {\\n            _ship = serialIndexShip[_serail][serialIndex[_serail] - 1];\\n        }\\n    }\\n\\n    function getDepositorByInterval(address _ship, uint _start, uint _end) public view returns (address[] memory) {\\n        uint len = IDegShipV2(_ship).getDepositorsLength();\\n        address[] memory addrs;\\n        if (len == 0 || _start > _end){\\n            addrs = new address[](1);\\n            addrs[0] = address(0);\\n            return addrs;\\n        }\\n\\n        if (_end >= len){\\n            _end = len - 1;\\n        }\\n\\n        addrs = new address[](_end - _start + 1);\\n        for (uint i = _start; i <= _end; i++) {\\n            addrs[i - _start] = IDegShipV2(_ship).depositors(i);\\n        }\\n        return addrs;\\n    }\\n\\n    function getDepositorByNum(address _ship, uint _num) external view returns(address[] memory){\\n        uint len = IDegShipV2(_ship).getDepositorsLength();\\n        uint _start;\\n        address[] memory addrs;\\n        if ( len == 0 ) {\\n            addrs = new address[](1);\\n            addrs[0] = address(0);\\n            return addrs;\\n        } else if (len > _num) {\\n            _start = len - _num;\\n            addrs = new address[](_num);\\n        } else {\\n            addrs = new address[](len);\\n        }\\n        for (uint i = _start; i <= len - 1; i++) {\\n            addrs[i - _start] = IDegShipV2(_ship).depositors(i);\\n        }\\n        return addrs;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/DegShipV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./interfaces/IDegCrew.sol\\\";\\nimport \\\"./interfaces/IDegShipCommanderV2.sol\\\";\\nimport \\\"./interfaces/IDegShipV2.sol\\\";\\n\\ncontract DegShipV2 is IDegShipV2 {\\n    using SafeMath for uint256; \\n\\n    string public shipName;\\n    IDegCrew public crewAddress;\\n    uint public startTime;\\n\\n    address public factory;\\n    string public shipSerial;\\n\\n    struct OrderInfo {\\n        uint256 amount; \\n        uint256 start;\\n        uint256 unfreeze; \\n        bool isUnfreezed;\\n    }\\n\\n    mapping(address => OrderInfo[]) public orderInfos;\\n\\n    address[] public depositors;\\n\\n    uint256 public dayPerCycle = 1 days;\\n\\n    uint256 public dayRewardPercents = 1; // static reward\\n\\n    IDegShipCommanderV2 public commander;\\n\\n    bool public stopped = false;\\n\\n    constructor() {\\n        factory = msg.sender;\\n    }\\n\\n    event EventInitialShip(address indexed _commander, string _name, address _crew, uint _percent, uint _perCycle);\\n\\n    function initialize(address _commander,\\n        string memory _serial, \\n        string memory _name, uint256 _dayReward, uint256 _perCycle) external {\\n        require(msg.sender == factory, 'DegShip Factory: FORBIDDEN'); // sufficient check\\n        shipName = _name;\\n        shipSerial = _serial;\\n        commander = IDegShipCommanderV2(_commander);\\n        crewAddress = IDegCrew(commander.crewAddress());\\n        \\n        startTime = block.timestamp;\\n        dayRewardPercents = _dayReward;\\n        dayPerCycle = _perCycle;\\n        emit EventInitialShip(_commander, shipName, address(crewAddress), dayRewardPercents, dayPerCycle);\\n    }\\n\\n    event ShipLaunched(address indexed _from, bool _shipStatus, uint256 _amount);\\n\\n    function afterLaunch(address from, uint256 amount) private {\\n        stopped = commander.checkShipStop(address(this));\\n        emit ShipLaunched(from, stopped, amount);\\n    }\\n\\n    // start\\n    function launch(address from, uint256 _amount, uint orderIndex) external {\\n        require(msg.sender == address(commander), \\\"Invalid commander\\\");\\n        crewAddress.deposit(from, _amount);\\n        // _unfreezeFundAndUpdateReward(from, orderIndex);\\n        uint nowTime = block.timestamp;\\n        if (nowTime < commander.startTime()) {\\n            nowTime = commander.startTime();\\n        }\\n        uint256 unfreezeTime = nowTime.add(dayPerCycle);\\n        orderInfos[from].push(OrderInfo(\\n            _amount, \\n            nowTime, \\n            unfreezeTime,\\n            false\\n        ));\\n        depositors.push(from);\\n        crewAddress.updateUserDepositShipOid(from, address(this), orderIndex + 1);\\n        afterLaunch(from, _amount);\\n    }\\n\\n    function reLaunch(address from, uint orderIndex) external {\\n        require(msg.sender == address(commander), \\\"Invalid commander\\\");\\n        OrderInfo storage order = orderInfos[from][orderIndex - 1];\\n        crewAddress.reDeposit(from, address(this), order.amount, orderIndex);\\n        _unfreezeFundQuit(from, order.amount);\\n        \\n        uint nowTime = block.timestamp;\\n        uint256 _unfreezeTime = nowTime.add(dayPerCycle);\\n        order.start = nowTime;\\n        order.unfreeze = _unfreezeTime;\\n\\n        afterLaunch(from, order.amount);\\n    }\\n\\n    function destroyUserOrder(address _user, uint _orderIndex) external {\\n        require(msg.sender == address(commander), \\\"Invalid commander\\\");\\n        require(block.timestamp >= orderInfos[_user][_orderIndex].unfreeze, \\\"Order is still running\\\" );\\n        orderInfos[_user][_orderIndex].isUnfreezed = true;\\n    }\\n\\n    function getOrderLength(address _user) public view returns(uint256) {\\n        return orderInfos[_user].length;\\n    }\\n\\n    function getDepositorsLength() public view returns(uint256) {\\n        return depositors.length;\\n    }\\n\\n    function orderAmountById(address _user, uint _orderIndex) public view returns (uint256){\\n        return orderInfos[_user][_orderIndex].amount;\\n    }\\n\\n    function orderAmountByUnfreezeId(address _user, uint _orderIndex) public view returns (uint256){\\n        if(orderInfos[_user][_orderIndex].isUnfreezed == false){\\n            return orderAmountById(_user, _orderIndex);\\n        }\\n        return 0;\\n    }\\n\\n    function checkOrderCondition(address _user, uint _index, uint256 _amount) public view returns (bool){\\n        if(_amount >= orderInfos[_user][_index].amount && block.timestamp >= orderInfos[_user][_index].unfreeze){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _unfreezeFundQuit(address _user, uint256 _amount) private {\\n        uint256 staticReward = _amount.mul(dayRewardPercents).div(100);\\n        commander.shipOutcome(address(this), _user, _amount.add(staticReward));\\n    }\\n\\n    // function _unfreezeFundAndUpdateReward(address _user, uint256 _nowLen) private {\\n    //     if(_nowLen > 0){\\n    //         OrderInfo storage order = orderInfos[_user][_nowLen - 1];\\n    //         if(order.isUnfreezed == false){\\n    //             order.isUnfreezed = true;\\n    //             _unfreezeFundQuit(_user, order.amount);\\n    //         }\\n    //     }\\n    // }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDegCrew.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IDegCrew {\\n    function register(address from, address refer) external;\\n    function deposit(address, uint256) external;\\n    function reDeposit(address from, address ship, uint256 _amount, uint _orderIndex) external;\\n    function updateLevel(address) external;\\n    function isCaller(address) external view returns (bool);\\n\\n    function checkRefer(address user) external view returns (address);\\n    function userRevenue(address user) external view returns (uint256);\\n    \\n    function addUserPointBalance(address _user, uint256 _amount) external;\\n    function subUserPointBalance(address _user, uint256 _amount) external;\\n    function balanceOfPoint(address _user) external view returns (uint256);\\n    function updateUserDepositShipOid(address _user, address _ship, uint _oid) external;\\n    function userTakeOrderInShip(address _user, address _ship) external view returns (uint);\\n\\n    function pointDividend(address _user, address _ship) external;\\n    function myPointAvailable(address _user, uint _day) external view returns (uint256 _bonus);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDegCrewExtend.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./IDegCrew.sol\\\";\\n\\ninterface IDegCrewExtend is IDegCrew{\\n    function addCaller(address) external;\\n    function modifyCaller(address, address) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDegShipCommanderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IDegShipCommanderV2 {\\n    function crewAddress() external view returns (address);\\n    function shipOutcome(address, address, uint256) external;\\n    function checkShipStop(address) external view returns (bool);\\n    function shipReleaseAmountToStop(address _ship) external view returns (uint256);\\n\\n    function getDay() external view returns (uint);\\n    function startTime() external view returns (uint);\\n    function dayRecordPool(uint _day) external view returns (uint256);\\n    function dayInvestTotal(uint _day) external view returns (uint256);\\n    function dayUserInvestTotal(uint _day, address _address) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDegShipFactoryV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IDegShipFactoryV2 {\\n    function getDay() external view returns(uint256);\\n    function getSerials() external view returns(string[] calldata);\\n    function getSerialLen() external view returns (uint256);\\n    function getSerialByIndex(uint256 _index) external view returns(string calldata);\\n\\n    function serialShip(string calldata) external view returns (address);\\n    function serialIndex(string calldata) external view returns (uint256);\\n    function shipToSerial(address) external view returns (string calldata);\\n    function serialIndexShip(string calldata, uint256) external view returns (address);\\n    function shipFactoryAutoMaker(string calldata) external view returns(bool);\\n\\n    // public last ship\\n    function lastShipOfSerial(string memory _serail) external view returns(address _ship);\\n    function getDepositorByNum(address _ship, uint _num) external view returns(address[] memory addrs);\\n\\n    // only commander\\n    function setSerialShip(string memory _serial, address _ship) external;\\n    function addSerialNewShip(string memory _serial, address _newShip) external;\\n    function shipCreated(string calldata _serial, uint256 _index, \\n        uint256 _amount, uint256 percent, uint256 perCycle) external returns (address _ship);\\n\\n    function subStock(string memory _serial,uint _day, uint256 _num) external;\\n    function setDayShipStock(string memory _serial, uint _day, uint256 _num) external;\\n\\n    // public \\n    function isLuckPoolByShip(address _ship) external view returns (bool);\\n    function isLuckPool(string calldata _serial) external view returns (bool);\\n\\n    function ticketToken(string calldata _serail) external view returns (address);\\n    function ticketAmount(string calldata _serail) external view returns (uint256);\\n    function getTicketTokenByShip(address _ship) external view returns (address);\\n    function getTicketAmountByShip(address _ship) external view returns (uint256);\\n\\n    function limitLaunchNum(string calldata _serial) external view returns (uint);\\n    function shipSupply(string calldata _serial) external view returns(uint256);\\n    function shipStocks(string calldata _serial, uint day) external view returns (uint256);\\n\\n    function stockReset(string calldata _serial, uint day) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDegShipV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IDegShipV2 {\\n    function initialize(address _commander,string calldata _serial, string calldata _name, uint256 _percent, uint256 _perCycle) external;\\n\\n    function dayPerCycle() external view returns (uint256);\\n    function dayRewardPercents() external view returns (uint256);\\n\\n    function checkOrderCondition(address _user,uint _index, uint256 _amount) external view returns (bool);\\n    function orderAmountById(address _user, uint _orderIndex) external view returns (uint256);\\n    function orderAmountByUnfreezeId(address _user, uint _orderIndex) external view returns (uint256);\\n    function getOrderLength(address _user) external view returns(uint256);\\n\\n    function depositors(uint) external view returns(address);\\n    function getDepositorsLength() external view returns(uint256);\\n\\n    function destroyUserOrder(address from, uint orderIndex) external;\\n    function launch(address from, uint256 amount, uint orderIndex) external;\\n    function reLaunch(address from, uint orderIndex) external;\\n    function stopped() external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDegSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IDegSwap {\\n    function collectUserDegBal(address _user) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Strings {\\n    \\n    function toString(uint256 value) internal pure returns (string memory) {\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_crewAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"CheckLastShipPointEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldShip\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newShip\",\"type\":\"address\"}],\"name\":\"EventDestroyShipOfSerial\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_orderIndex\",\"type\":\"uint256\"}],\"name\":\"EventLaunch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_orderIndex\",\"type\":\"uint256\"}],\"name\":\"EventReLaunch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"EventShipIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"}],\"name\":\"EventShipInsufficientReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"EventShipOutcome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"}],\"name\":\"ShipStopped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_serial\",\"type\":\"string\"}],\"name\":\"checkMyPoint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"}],\"name\":\"checkShipStop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"collectGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"serial\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perCycle\",\"type\":\"uint256\"}],\"name\":\"createNewSerialShip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crewAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayInvestTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayRecordPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dayUserInvestTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"degSwap\",\"outputs\":[{\"internalType\":\"contract IDegSwap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"}],\"name\":\"dividendFomoBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmout\",\"type\":\"uint256\"}],\"name\":\"fomoBonusAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"firstBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thirdBonus\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastedDepositsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSerials\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUpdateShipOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastedDeposits\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"serial\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"serial\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"launchShip\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"luckDividend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"luckPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"serial\",\"type\":\"string\"}],\"name\":\"reEntry\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recordDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"refer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setDegSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addrs\",\"type\":\"address[]\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setShipFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setUpdateShipOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shipCrew\",\"outputs\":[{\"internalType\":\"contract IDegCrewExtend\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shipFactory\",\"outputs\":[{\"internalType\":\"contract IDegShipFactoryV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"serial\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"sindex\",\"type\":\"uint8\"}],\"name\":\"shipIndexStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_outcome\",\"type\":\"uint256\"}],\"name\":\"shipOutcome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shipPointCollect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ship\",\"type\":\"address\"}],\"name\":\"shipReleaseAmountToStop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shipRewardPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"serial\",\"type\":\"string\"}],\"name\":\"shipStockCheck\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shipTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"serial\",\"type\":\"string\"}],\"name\":\"ticketTokenAndAmount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ticketToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ticketAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DegShipCommanderV2", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000b8585b946659c0bce884f4a85b587758fbeb43ea", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}