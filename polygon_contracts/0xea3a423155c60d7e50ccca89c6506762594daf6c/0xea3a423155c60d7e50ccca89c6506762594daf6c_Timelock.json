{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/peripherals/Timelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./interfaces/ITimelockTarget.sol\\\";\\nimport \\\"./interfaces/ITimelock.sol\\\";\\nimport \\\"./interfaces/IHandlerTarget.sol\\\";\\nimport \\\"../access/interfaces/IAdmin.sol\\\";\\nimport \\\"../core/interfaces/IVault.sol\\\";\\nimport \\\"../core/interfaces/IVaultUtils.sol\\\";\\nimport \\\"../core/interfaces/IMvlpManager.sol\\\";\\nimport \\\"../referrals/interfaces/IReferralStorage.sol\\\";\\nimport \\\"../tokens/interfaces/IYieldToken.sol\\\";\\nimport \\\"../tokens/interfaces/IBaseToken.sol\\\";\\nimport \\\"../tokens/interfaces/IMintable.sol\\\";\\nimport \\\"../tokens/interfaces/IUSDM.sol\\\";\\nimport \\\"../staking/interfaces/IVester.sol\\\";\\n\\nimport \\\"../libraries/math/SafeMath.sol\\\";\\nimport \\\"../libraries/token/IERC20.sol\\\";\\n\\ncontract Timelock is ITimelock {\\n    using SafeMath for uint256;\\n\\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\\n    uint256 public constant MAX_BUFFER = 5 days;\\n    uint256 public constant MAX_FUNDING_RATE_FACTOR = 200; // 0.02%\\n    uint256 public constant MAX_LEVERAGE_VALIDATION = 500000; // 50x\\n\\n    uint256 public buffer;\\n    address public admin;\\n\\n    address public tokenManager;\\n    address public mintReceiver;\\n    address public mvlpManager;\\n    uint256 public maxTokenSupply;\\n\\n    uint256 public marginFeeBasisPoints;\\n    uint256 public maxMarginFeeBasisPoints;\\n    bool public shouldToggleIsLeverageEnabled;\\n\\n    mapping (bytes32 => uint256) public pendingActions;\\n\\n    mapping (address => bool) public isHandler;\\n    mapping (address => bool) public isKeeper;\\n\\n    event SignalPendingAction(bytes32 action);\\n    event SignalApprove(address token, address spender, uint256 amount, bytes32 action);\\n    event SignalWithdrawToken(address target, address token, address receiver, uint256 amount, bytes32 action);\\n    event SignalMint(address token, address receiver, uint256 amount, bytes32 action);\\n    event SignalSetGov(address target, address gov, bytes32 action);\\n    event SignalSetHandler(address target, address handler, bool isActive, bytes32 action);\\n    event SignalSetPriceFeed(address vault, address priceFeed, bytes32 action);\\n    event SignalRedeemUsdm(address vault, address token, uint256 amount);\\n    event SignalVaultSetTokenConfig(\\n        address vault,\\n        address token,\\n        uint256 tokenDecimals,\\n        uint256 tokenWeight,\\n        uint256 minProfitBps,\\n        uint256 maxUsdmAmount,\\n        bool isStable,\\n        bool isShortable\\n    );\\n    event ClearAction(bytes32 action);\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"Timelock: forbidden\\\");\\n        _;\\n    }\\n\\n    modifier onlyHandlerAndAbove() {\\n        require(msg.sender == admin || isHandler[msg.sender], \\\"Timelock: forbidden\\\");\\n        _;\\n    }\\n\\n    modifier onlyKeeperAndAbove() {\\n        require(msg.sender == admin || isHandler[msg.sender] || isKeeper[msg.sender], \\\"Timelock: forbidden\\\");\\n        _;\\n    }\\n\\n    modifier onlyTokenManager() {\\n        require(msg.sender == tokenManager, \\\"Timelock: forbidden\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _admin,\\n        uint256 _buffer,\\n        address _tokenManager,\\n        address _mintReceiver,\\n        address _mvlpManager,\\n        uint256 _maxTokenSupply,\\n        uint256 _marginFeeBasisPoints,\\n        uint256 _maxMarginFeeBasisPoints\\n    ) public {\\n        require(_buffer <= MAX_BUFFER, \\\"Timelock: invalid _buffer\\\");\\n        admin = _admin;\\n        buffer = _buffer;\\n        tokenManager = _tokenManager;\\n        mintReceiver = _mintReceiver;\\n        mvlpManager = _mvlpManager;\\n        maxTokenSupply = _maxTokenSupply;\\n\\n        marginFeeBasisPoints = _marginFeeBasisPoints;\\n        maxMarginFeeBasisPoints = _maxMarginFeeBasisPoints;\\n    }\\n\\n    function setAdmin(address _admin) external override onlyTokenManager {\\n        admin = _admin;\\n    }\\n\\n    function setExternalAdmin(address _target, address _admin) external onlyAdmin {\\n        require(_target != address(this), \\\"Timelock: invalid _target\\\");\\n        IAdmin(_target).setAdmin(_admin);\\n    }\\n\\n    function setContractHandler(address _handler, bool _isActive) external onlyAdmin {\\n        isHandler[_handler] = _isActive;\\n    }\\n\\n    function setKeeper(address _keeper, bool _isActive) external onlyAdmin {\\n        isKeeper[_keeper] = _isActive;\\n    }\\n\\n    function setBuffer(uint256 _buffer) external onlyAdmin {\\n        require(_buffer <= MAX_BUFFER, \\\"Timelock: invalid _buffer\\\");\\n        require(_buffer > buffer, \\\"Timelock: buffer cannot be decreased\\\");\\n        buffer = _buffer;\\n    }\\n\\n    function setMaxLeverage(address _vault, uint256 _maxLeverage) external onlyAdmin {\\n      require(_maxLeverage > MAX_LEVERAGE_VALIDATION, \\\"Timelock: invalid _maxLeverage\\\");\\n      IVault(_vault).setMaxLeverage(_maxLeverage);\\n    }\\n\\n    function setFundingRate(address _vault, uint256 _fundingInterval, uint256 _fundingRateFactor, uint256 _stableFundingRateFactor) external onlyKeeperAndAbove {\\n        require(_fundingRateFactor < MAX_FUNDING_RATE_FACTOR, \\\"Timelock: invalid _fundingRateFactor\\\");\\n        require(_stableFundingRateFactor < MAX_FUNDING_RATE_FACTOR, \\\"Timelock: invalid _stableFundingRateFactor\\\");\\n        IVault(_vault).setFundingRate(_fundingInterval, _fundingRateFactor, _stableFundingRateFactor);\\n    }\\n\\n    function setShouldToggleIsLeverageEnabled(bool _shouldToggleIsLeverageEnabled) external onlyHandlerAndAbove {\\n        shouldToggleIsLeverageEnabled = _shouldToggleIsLeverageEnabled;\\n    }\\n\\n    function setMarginFeeBasisPoints(uint256 _marginFeeBasisPoints, uint256 _maxMarginFeeBasisPoints) external onlyHandlerAndAbove {\\n        marginFeeBasisPoints = _marginFeeBasisPoints;\\n        maxMarginFeeBasisPoints = _maxMarginFeeBasisPoints;\\n    }\\n\\n    function setSwapFees(\\n        address _vault,\\n        uint256 _taxBasisPoints,\\n        uint256 _stableTaxBasisPoints,\\n        uint256 _mintBurnFeeBasisPoints,\\n        uint256 _swapFeeBasisPoints,\\n        uint256 _stableSwapFeeBasisPoints\\n    ) external onlyKeeperAndAbove {\\n        IVault vault = IVault(_vault);\\n\\n        vault.setFees(\\n            _taxBasisPoints,\\n            _stableTaxBasisPoints,\\n            _mintBurnFeeBasisPoints,\\n            _swapFeeBasisPoints,\\n            _stableSwapFeeBasisPoints,\\n            maxMarginFeeBasisPoints,\\n            vault.liquidationFeeUsd(),\\n            vault.minProfitTime(),\\n            vault.hasDynamicFees()\\n        );\\n    }\\n\\n    // assign _marginFeeBasisPoints to this.marginFeeBasisPoints\\n    // because enableLeverage would update Vault.marginFeeBasisPoints to this.marginFeeBasisPoints\\n    // and disableLeverage would reset the Vault.marginFeeBasisPoints to this.maxMarginFeeBasisPoints\\n    function setFees(\\n        address _vault,\\n        uint256 _taxBasisPoints,\\n        uint256 _stableTaxBasisPoints,\\n        uint256 _mintBurnFeeBasisPoints,\\n        uint256 _swapFeeBasisPoints,\\n        uint256 _stableSwapFeeBasisPoints,\\n        uint256 _marginFeeBasisPoints,\\n        uint256 _liquidationFeeUsd,\\n        uint256 _minProfitTime,\\n        bool _hasDynamicFees\\n    ) external onlyKeeperAndAbove {\\n        marginFeeBasisPoints = _marginFeeBasisPoints;\\n\\n        IVault(_vault).setFees(\\n            _taxBasisPoints,\\n            _stableTaxBasisPoints,\\n            _mintBurnFeeBasisPoints,\\n            _swapFeeBasisPoints,\\n            _stableSwapFeeBasisPoints,\\n            maxMarginFeeBasisPoints,\\n            _liquidationFeeUsd,\\n            _minProfitTime,\\n            _hasDynamicFees\\n        );\\n    }\\n\\n    function enableLeverage(address _vault) external override onlyHandlerAndAbove {\\n        IVault vault = IVault(_vault);\\n\\n        if (shouldToggleIsLeverageEnabled) {\\n            vault.setIsLeverageEnabled(true);\\n        }\\n\\n        vault.setFees(\\n            vault.taxBasisPoints(),\\n            vault.stableTaxBasisPoints(),\\n            vault.mintBurnFeeBasisPoints(),\\n            vault.swapFeeBasisPoints(),\\n            vault.stableSwapFeeBasisPoints(),\\n            marginFeeBasisPoints,\\n            vault.liquidationFeeUsd(),\\n            vault.minProfitTime(),\\n            vault.hasDynamicFees()\\n        );\\n    }\\n\\n    function disableLeverage(address _vault) external override onlyHandlerAndAbove {\\n        IVault vault = IVault(_vault);\\n\\n        if (shouldToggleIsLeverageEnabled) {\\n            vault.setIsLeverageEnabled(false);\\n        }\\n\\n        vault.setFees(\\n            vault.taxBasisPoints(),\\n            vault.stableTaxBasisPoints(),\\n            vault.mintBurnFeeBasisPoints(),\\n            vault.swapFeeBasisPoints(),\\n            vault.stableSwapFeeBasisPoints(),\\n            maxMarginFeeBasisPoints, // marginFeeBasisPoints\\n            vault.liquidationFeeUsd(),\\n            vault.minProfitTime(),\\n            vault.hasDynamicFees()\\n        );\\n    }\\n\\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external override onlyHandlerAndAbove {\\n        IVault(_vault).setIsLeverageEnabled(_isLeverageEnabled);\\n    }\\n\\n    function setTokenConfig(\\n        address _vault,\\n        address _token,\\n        uint256 _tokenWeight,\\n        uint256 _minProfitBps,\\n        uint256 _maxUsdmAmount,\\n        uint256 _bufferAmount,\\n        uint256 _usdmAmount\\n    ) external onlyKeeperAndAbove {\\n        require(_minProfitBps <= 500, \\\"Timelock: invalid _minProfitBps\\\");\\n\\n        IVault vault = IVault(_vault);\\n        require(vault.whitelistedTokens(_token), \\\"Timelock: token not yet whitelisted\\\");\\n\\n        uint256 tokenDecimals = vault.tokenDecimals(_token);\\n        bool isStable = vault.stableTokens(_token);\\n        bool isShortable = vault.shortableTokens(_token);\\n\\n        IVault(_vault).setTokenConfig(\\n            _token,\\n            tokenDecimals,\\n            _tokenWeight,\\n            _minProfitBps,\\n            _maxUsdmAmount,\\n            isStable,\\n            isShortable\\n        );\\n\\n        IVault(_vault).setBufferAmount(_token, _bufferAmount);\\n\\n        IVault(_vault).setUsdmAmount(_token, _usdmAmount);\\n    }\\n\\n    function setUsdmAmounts(address _vault, address[] memory _tokens, uint256[] memory _usdmAmounts) external onlyKeeperAndAbove {\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            IVault(_vault).setUsdmAmount(_tokens[i], _usdmAmounts[i]);\\n        }\\n    }\\n\\n    function updateUsdmSupply(uint256 usdmAmount) external onlyKeeperAndAbove {\\n        address usdm = IMvlpManager(mvlpManager).usdm();\\n        uint256 balance = IERC20(usdm).balanceOf(mvlpManager);\\n\\n        IUSDM(usdm).addVault(address(this));\\n\\n        if (usdmAmount > balance) {\\n            uint256 mintAmount = usdmAmount.sub(balance);\\n            IUSDM(usdm).mint(mvlpManager, mintAmount);\\n        } else {\\n            uint256 burnAmount = balance.sub(usdmAmount);\\n            IUSDM(usdm).burn(mvlpManager, burnAmount);\\n        }\\n\\n        IUSDM(usdm).removeVault(address(this));\\n    }\\n\\n    function setMvlpCooldownDuration(uint256 _cooldownDuration) external onlyAdmin {\\n        IMvlpManager(mvlpManager).setCooldownDuration(_cooldownDuration);\\n    }\\n\\n    function setMaxGlobalShortSize(address _vault, address _token, uint256 _amount) external onlyAdmin {\\n        IVault(_vault).setMaxGlobalShortSize(_token, _amount);\\n    }\\n\\n    function removeAdmin(address _token, address _account) external onlyAdmin {\\n        IYieldToken(_token).removeAdmin(_account);\\n    }\\n\\n    function setIsSwapEnabled(address _vault, bool _isSwapEnabled) external onlyKeeperAndAbove {\\n        IVault(_vault).setIsSwapEnabled(_isSwapEnabled);\\n    }\\n\\n    function setTier(address _referralStorage, uint256 _tierId, uint256 _totalRebate, uint256 _discountShare) external onlyKeeperAndAbove {\\n        IReferralStorage(_referralStorage).setTier(_tierId, _totalRebate, _discountShare);\\n    }\\n\\n    function setReferrerTier(address _referralStorage, address _referrer, uint256 _tierId) external onlyKeeperAndAbove {\\n        IReferralStorage(_referralStorage).setReferrerTier(_referrer, _tierId);\\n    }\\n\\n    function govSetCodeOwner(address _referralStorage, bytes32 _code, address _newAccount) external onlyKeeperAndAbove {\\n        IReferralStorage(_referralStorage).govSetCodeOwner(_code, _newAccount);\\n    }\\n\\n    function setVaultUtils(address _vault, IVaultUtils _vaultUtils) external onlyAdmin {\\n        IVault(_vault).setVaultUtils(_vaultUtils);\\n    }\\n\\n    function setMaxGasPrice(address _vault, uint256 _maxGasPrice) external onlyAdmin {\\n        require(_maxGasPrice > 5000000000, \\\"Invalid _maxGasPrice\\\");\\n        IVault(_vault).setMaxGasPrice(_maxGasPrice);\\n    }\\n\\n    function withdrawFees(address _vault, address _token, address _receiver) external onlyAdmin {\\n        IVault(_vault).withdrawFees(_token, _receiver);\\n    }\\n\\n    function batchWithdrawFees(address _vault, address[] memory _tokens) external onlyKeeperAndAbove {\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            IVault(_vault).withdrawFees(_tokens[i], admin);\\n        }\\n    }\\n\\n    function setInPrivateLiquidationMode(address _vault, bool _inPrivateLiquidationMode) external onlyAdmin {\\n        IVault(_vault).setInPrivateLiquidationMode(_inPrivateLiquidationMode);\\n    }\\n\\n    function setLiquidator(address _vault, address _liquidator, bool _isActive) external onlyAdmin {\\n        IVault(_vault).setLiquidator(_liquidator, _isActive);\\n    }\\n\\n    function setInPrivateTransferMode(address _token, bool _inPrivateTransferMode) external onlyAdmin {\\n        IBaseToken(_token).setInPrivateTransferMode(_inPrivateTransferMode);\\n    }\\n\\n    function batchSetBonusRewards(address _vester, address[] memory _accounts, uint256[] memory _amounts) external onlyKeeperAndAbove {\\n        require(_accounts.length == _amounts.length, \\\"Timelock: invalid lengths\\\");\\n\\n        if (!IHandlerTarget(_vester).isHandler(address(this))) {\\n            IHandlerTarget(_vester).setHandler(address(this), true);\\n        }\\n\\n        for (uint256 i = 0; i < _accounts.length; i++) {\\n            address account = _accounts[i];\\n            uint256 amount = _amounts[i];\\n            IVester(_vester).setBonusRewards(account, amount);\\n        }\\n    }\\n\\n    function transferIn(address _sender, address _token, uint256 _amount) external onlyAdmin {\\n        IERC20(_token).transferFrom(_sender, address(this), _amount);\\n    }\\n\\n    function signalApprove(address _token, address _spender, uint256 _amount) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"approve\\\", _token, _spender, _amount));\\n        _setPendingAction(action);\\n        emit SignalApprove(_token, _spender, _amount, action);\\n    }\\n\\n    function approve(address _token, address _spender, uint256 _amount) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"approve\\\", _token, _spender, _amount));\\n        _validateAction(action);\\n        _clearAction(action);\\n        IERC20(_token).approve(_spender, _amount);\\n    }\\n\\n    function signalWithdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"withdrawToken\\\", _target, _token, _receiver, _amount));\\n        _setPendingAction(action);\\n        emit SignalWithdrawToken(_target, _token, _receiver, _amount, action);\\n    }\\n\\n    function withdrawToken(address _target, address _token, address _receiver, uint256 _amount) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"withdrawToken\\\", _target, _token, _receiver, _amount));\\n        _validateAction(action);\\n        _clearAction(action);\\n        IBaseToken(_target).withdrawToken(_token, _receiver, _amount);\\n    }\\n\\n    function signalMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"mint\\\", _token, _receiver, _amount));\\n        _setPendingAction(action);\\n        emit SignalMint(_token, _receiver, _amount, action);\\n    }\\n\\n    function processMint(address _token, address _receiver, uint256 _amount) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"mint\\\", _token, _receiver, _amount));\\n        _validateAction(action);\\n        _clearAction(action);\\n\\n        _mint(_token, _receiver, _amount);\\n    }\\n\\n    function signalSetGov(address _target, address _gov) external override onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"setGov\\\", _target, _gov));\\n        _setPendingAction(action);\\n        emit SignalSetGov(_target, _gov, action);\\n    }\\n\\n    function setGov(address _target, address _gov) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"setGov\\\", _target, _gov));\\n        _validateAction(action);\\n        _clearAction(action);\\n        ITimelockTarget(_target).setGov(_gov);\\n    }\\n\\n    function signalSetHandler(address _target, address _handler, bool _isActive) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"setHandler\\\", _target, _handler, _isActive));\\n        _setPendingAction(action);\\n        emit SignalSetHandler(_target, _handler, _isActive, action);\\n    }\\n\\n    function setHandler(address _target, address _handler, bool _isActive) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"setHandler\\\", _target, _handler, _isActive));\\n        _validateAction(action);\\n        _clearAction(action);\\n        IHandlerTarget(_target).setHandler(_handler, _isActive);\\n    }\\n\\n    function signalSetPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"setPriceFeed\\\", _vault, _priceFeed));\\n        _setPendingAction(action);\\n        emit SignalSetPriceFeed(_vault, _priceFeed, action);\\n    }\\n\\n    function setPriceFeed(address _vault, address _priceFeed) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"setPriceFeed\\\", _vault, _priceFeed));\\n        _validateAction(action);\\n        _clearAction(action);\\n        IVault(_vault).setPriceFeed(_priceFeed);\\n    }\\n\\n    function signalRedeemUsdm(address _vault, address _token, uint256 _amount) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"redeemUsdm\\\", _vault, _token, _amount));\\n        _setPendingAction(action);\\n        emit SignalRedeemUsdm(_vault, _token, _amount);\\n    }\\n\\n    function redeemUsdm(address _vault, address _token, uint256 _amount) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\\"redeemUsdm\\\", _vault, _token, _amount));\\n        _validateAction(action);\\n        _clearAction(action);\\n\\n        address usdm = IVault(_vault).usdm();\\n        IVault(_vault).setManager(address(this), true);\\n        IUSDM(usdm).addVault(address(this));\\n\\n        IUSDM(usdm).mint(address(this), _amount);\\n        IERC20(usdm).transfer(address(_vault), _amount);\\n\\n        IVault(_vault).sellUSDM(_token, mintReceiver);\\n\\n        IVault(_vault).setManager(address(this), false);\\n        IUSDM(usdm).removeVault(address(this));\\n    }\\n\\n    function signalVaultSetTokenConfig(\\n        address _vault,\\n        address _token,\\n        uint256 _tokenDecimals,\\n        uint256 _tokenWeight,\\n        uint256 _minProfitBps,\\n        uint256 _maxUsdmAmount,\\n        bool _isStable,\\n        bool _isShortable\\n    ) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\n            \\\"vaultSetTokenConfig\\\",\\n            _vault,\\n            _token,\\n            _tokenDecimals,\\n            _tokenWeight,\\n            _minProfitBps,\\n            _maxUsdmAmount,\\n            _isStable,\\n            _isShortable\\n        ));\\n\\n        _setPendingAction(action);\\n\\n        emit SignalVaultSetTokenConfig(\\n            _vault,\\n            _token,\\n            _tokenDecimals,\\n            _tokenWeight,\\n            _minProfitBps,\\n            _maxUsdmAmount,\\n            _isStable,\\n            _isShortable\\n        );\\n    }\\n\\n    function vaultSetTokenConfig(\\n        address _vault,\\n        address _token,\\n        uint256 _tokenDecimals,\\n        uint256 _tokenWeight,\\n        uint256 _minProfitBps,\\n        uint256 _maxUsdmAmount,\\n        bool _isStable,\\n        bool _isShortable\\n    ) external onlyAdmin {\\n        bytes32 action = keccak256(abi.encodePacked(\\n            \\\"vaultSetTokenConfig\\\",\\n            _vault,\\n            _token,\\n            _tokenDecimals,\\n            _tokenWeight,\\n            _minProfitBps,\\n            _maxUsdmAmount,\\n            _isStable,\\n            _isShortable\\n        ));\\n\\n        _validateAction(action);\\n        _clearAction(action);\\n\\n        IVault(_vault).setTokenConfig(\\n            _token,\\n            _tokenDecimals,\\n            _tokenWeight,\\n            _minProfitBps,\\n            _maxUsdmAmount,\\n            _isStable,\\n            _isShortable\\n        );\\n    }\\n\\n    function cancelAction(bytes32 _action) external onlyAdmin {\\n        _clearAction(_action);\\n    }\\n\\n    function _mint(address _token, address _receiver, uint256 _amount) private {\\n        IMintable mintable = IMintable(_token);\\n\\n        if (!mintable.isMinter(address(this))) {\\n            mintable.setMinter(address(this), true);\\n        }\\n\\n        mintable.mint(_receiver, _amount);\\n        require(IERC20(_token).totalSupply() <= maxTokenSupply, \\\"Timelock: maxTokenSupply exceeded\\\");\\n    }\\n\\n    function _setPendingAction(bytes32 _action) private {\\n        require(pendingActions[_action] == 0, \\\"Timelock: action already signalled\\\");\\n        pendingActions[_action] = block.timestamp.add(buffer);\\n        emit SignalPendingAction(_action);\\n    }\\n\\n    function _validateAction(bytes32 _action) private view {\\n        require(pendingActions[_action] != 0, \\\"Timelock: action not signalled\\\");\\n        require(pendingActions[_action] < block.timestamp, \\\"Timelock: action time not yet passed\\\");\\n    }\\n\\n    function _clearAction(bytes32 _action) private {\\n        require(pendingActions[_action] != 0, \\\"Timelock: invalid _action\\\");\\n        delete pendingActions[_action];\\n        emit ClearAction(_action);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/peripherals/interfaces/ITimelockTarget.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface ITimelockTarget {\\n    function setGov(address _gov) external;\\n    function withdrawToken(address _token, address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/peripherals/interfaces/ITimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface ITimelock {\\n    function setAdmin(address _admin) external;\\n    function enableLeverage(address _vault) external;\\n    function disableLeverage(address _vault) external;\\n    function setIsLeverageEnabled(address _vault, bool _isLeverageEnabled) external;\\n    function signalSetGov(address _target, address _gov) external;\\n}\\n\"\r\n    },\r\n    \"contracts/peripherals/interfaces/IHandlerTarget.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IHandlerTarget {\\n    function isHandler(address _account) external returns (bool);\\n    function setHandler(address _handler, bool _isActive) external;\\n}\\n\"\r\n    },\r\n    \"contracts/access/interfaces/IAdmin.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IAdmin {\\n    function setAdmin(address _admin) external;\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IVaultUtils.sol\\\";\\n\\ninterface IVault {\\n    function isInitialized() external view returns (bool);\\n\\n    function isSwapEnabled() external view returns (bool);\\n\\n    function isLeverageEnabled() external view returns (bool);\\n\\n    function setVaultUtils(IVaultUtils _vaultUtils) external;\\n\\n    function setError(uint256 _errorCode, string calldata _error) external;\\n\\n    function router() external view returns (address);\\n\\n    function usdm() external view returns (address);\\n\\n    function gov() external view returns (address);\\n\\n    function whitelistedTokenCount() external view returns (uint256);\\n\\n    function maxLeverage() external view returns (uint256);\\n\\n    function minProfitTime() external view returns (uint256);\\n\\n    function hasDynamicFees() external view returns (bool);\\n\\n    function fundingInterval() external view returns (uint256);\\n\\n    function totalTokenWeights() external view returns (uint256);\\n\\n    function getTargetUsdmAmount(address _token) external view returns (uint256);\\n\\n    function inManagerMode() external view returns (bool);\\n\\n    function inPrivateLiquidationMode() external view returns (bool);\\n\\n    function maxGasPrice() external view returns (uint256);\\n\\n    function approvedRouters(address _account, address _router) external view returns (bool);\\n\\n    function isLiquidator(address _account) external view returns (bool);\\n\\n    function isManager(address _account) external view returns (bool);\\n\\n    function minProfitBasisPoints(address _token) external view returns (uint256);\\n\\n    function tokenBalances(address _token) external view returns (uint256);\\n\\n    function lastFundingTimes(address _token) external view returns (uint256);\\n\\n    function setMaxLeverage(uint256 _maxLeverage) external;\\n\\n    function setInManagerMode(bool _inManagerMode) external;\\n\\n    function setManager(address _manager, bool _isManager) external;\\n\\n    function setIsSwapEnabled(bool _isSwapEnabled) external;\\n\\n    function setIsLeverageEnabled(bool _isLeverageEnabled) external;\\n\\n    function setMaxGasPrice(uint256 _maxGasPrice) external;\\n\\n    function setUsdmAmount(address _token, uint256 _amount) external;\\n\\n    function setBufferAmount(address _token, uint256 _amount) external;\\n\\n    function setMaxGlobalShortSize(address _token, uint256 _amount) external;\\n\\n    function setInPrivateLiquidationMode(bool _inPrivateLiquidationMode) external;\\n\\n    function setLiquidator(address _liquidator, bool _isActive) external;\\n\\n    function setFundingRate(\\n        uint256 _fundingInterval,\\n        uint256 _fundingRateFactor,\\n        uint256 _stableFundingRateFactor\\n    ) external;\\n\\n    function setFees(\\n        uint256 _taxBasisPoints,\\n        uint256 _stableTaxBasisPoints,\\n        uint256 _mintBurnFeeBasisPoints,\\n        uint256 _swapFeeBasisPoints,\\n        uint256 _stableSwapFeeBasisPoints,\\n        uint256 _marginFeeBasisPoints,\\n        uint256 _liquidationFeeUsd,\\n        uint256 _minProfitTime,\\n        bool _hasDynamicFees\\n    ) external;\\n\\n    function setTokenConfig(\\n        address _token,\\n        uint256 _tokenDecimals,\\n        uint256 _redemptionBps,\\n        uint256 _minProfitBps,\\n        uint256 _maxUsdmAmount,\\n        bool _isStable,\\n        bool _isShortable\\n    ) external;\\n\\n    function setPriceFeed(address _priceFeed) external;\\n\\n    function withdrawFees(address _token, address _receiver) external returns (uint256);\\n\\n    function directPoolDeposit(address _token) external;\\n\\n    function buyUSDM(address _token, address _receiver) external returns (uint256);\\n\\n    function sellUSDM(address _token, address _receiver) external returns (uint256);\\n\\n    function swap(\\n        address _tokenIn,\\n        address _tokenOut,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function increasePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        uint256 _sizeDelta,\\n        bool _isLong\\n    ) external;\\n\\n    function decreasePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        uint256 _collateralDelta,\\n        uint256 _sizeDelta,\\n        bool _isLong,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function liquidatePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong,\\n        address _feeReceiver\\n    ) external;\\n\\n    function tokenToUsdMin(address _token, uint256 _tokenAmount) external view returns (uint256);\\n\\n    function priceFeed() external view returns (address);\\n\\n    function fundingRateFactor() external view returns (uint256);\\n\\n    function stableFundingRateFactor() external view returns (uint256);\\n\\n    function cumulativeFundingRates(address _token) external view returns (uint256);\\n\\n    function getNextFundingRate(address _token) external view returns (uint256);\\n\\n    function getFeeBasisPoints(\\n        address _token,\\n        uint256 _usdmDelta,\\n        uint256 _feeBasisPoints,\\n        uint256 _taxBasisPoints,\\n        bool _increment\\n    ) external view returns (uint256);\\n\\n    function liquidationFeeUsd() external view returns (uint256);\\n\\n    function taxBasisPoints() external view returns (uint256);\\n\\n    function stableTaxBasisPoints() external view returns (uint256);\\n\\n    function mintBurnFeeBasisPoints() external view returns (uint256);\\n\\n    function swapFeeBasisPoints() external view returns (uint256);\\n\\n    function stableSwapFeeBasisPoints() external view returns (uint256);\\n\\n    function marginFeeBasisPoints() external view returns (uint256);\\n\\n    function allWhitelistedTokensLength() external view returns (uint256);\\n\\n    function allWhitelistedTokens(uint256) external view returns (address);\\n\\n    function whitelistedTokens(address _token) external view returns (bool);\\n\\n    function stableTokens(address _token) external view returns (bool);\\n\\n    function shortableTokens(address _token) external view returns (bool);\\n\\n    function feeReserves(address _token) external view returns (uint256);\\n\\n    function globalShortSizes(address _token) external view returns (uint256);\\n\\n    function globalShortAveragePrices(address _token) external view returns (uint256);\\n\\n    function maxGlobalShortSizes(address _token) external view returns (uint256);\\n\\n    function tokenDecimals(address _token) external view returns (uint256);\\n\\n    function tokenWeights(address _token) external view returns (uint256);\\n\\n    function guaranteedUsd(address _token) external view returns (uint256);\\n\\n    function poolAmounts(address _token) external view returns (uint256);\\n\\n    function bufferAmounts(address _token) external view returns (uint256);\\n\\n    function reservedAmounts(address _token) external view returns (uint256);\\n\\n    function usdmAmounts(address _token) external view returns (uint256);\\n\\n    function maxUsdmAmounts(address _token) external view returns (uint256);\\n\\n    function getRedemptionAmount(address _token, uint256 _usdmAmount) external view returns (uint256);\\n\\n    function getMaxPrice(address _token) external view returns (uint256);\\n\\n    function getMinPrice(address _token) external view returns (uint256);\\n\\n    function getDelta(\\n        address _indexToken,\\n        uint256 _size,\\n        uint256 _averagePrice,\\n        bool _isLong,\\n        uint256 _lastIncreasedTime\\n    ) external view returns (bool, uint256);\\n\\n    function getPosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong\\n    )\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            bool,\\n            uint256\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IVaultUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IVaultUtils {\\n    function updateCumulativeFundingRate(\\n        address _collateralToken,\\n        address _indexToken\\n    ) external returns (bool);\\n\\n    function validateIncreasePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        uint256 _sizeDelta,\\n        bool _isLong\\n    ) external view;\\n\\n    function validateDecreasePosition(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        uint256 _collateralDelta,\\n        uint256 _sizeDelta,\\n        bool _isLong,\\n        address _receiver\\n    ) external view;\\n\\n    function validateLiquidation(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong,\\n        bool _raise\\n    ) external view returns (uint256, uint256);\\n\\n    function getEntryFundingRate(\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong\\n    ) external view returns (uint256);\\n\\n    function getPositionFee(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong,\\n        uint256 _sizeDelta\\n    ) external view returns (uint256);\\n\\n    function getFundingFee(\\n        address _account,\\n        address _collateralToken,\\n        address _indexToken,\\n        bool _isLong,\\n        uint256 _size,\\n        uint256 _entryFundingRate\\n    ) external view returns (uint256);\\n\\n    function getBuyUsdmFeeBasisPoints(address _token, uint256 _usdmAmount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getSellUsdmFeeBasisPoints(address _token, uint256 _usdmAmount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getSwapFeeBasisPoints(\\n        address _tokenIn,\\n        address _tokenOut,\\n        uint256 _usdmAmount\\n    ) external view returns (uint256);\\n\\n    function getFeeBasisPoints(\\n        address _token,\\n        uint256 _usdmDelta,\\n        uint256 _feeBasisPoints,\\n        uint256 _taxBasisPoints,\\n        bool _increment\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IMvlpManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IMvlpManager {\\n    function usdm() external view returns (address);\\n    function cooldownDuration() external returns (uint256);\\n    function setCooldownDuration(uint256 _cooldownDuration) external;\\n\\n    function lastAddedAt(address _account) external returns (uint256);\\n\\n    function addLiquidity(\\n        address _token,\\n        uint256 _amount,\\n        uint256 _minUsdm,\\n        uint256 _minMvlp\\n    ) external returns (uint256);\\n\\n    function addLiquidityForAccount(\\n        address _fundingAccount,\\n        address _account,\\n        address _token,\\n        uint256 _amount,\\n        uint256 _minUsdm,\\n        uint256 _minMvlp\\n    ) external returns (uint256);\\n\\n    function removeLiquidity(\\n        address _tokenOut,\\n        uint256 _mvlpAmount,\\n        uint256 _minOut,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function removeLiquidityForAccount(\\n        address _account,\\n        address _tokenOut,\\n        uint256 _mvlpAmount,\\n        uint256 _minOut,\\n        address _receiver\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/referrals/interfaces/IReferralStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IReferralStorage {\\n    function codeOwners(bytes32 _code) external view returns (address);\\n\\n    function getTraderReferralInfo(address _account) external view returns (bytes32, address);\\n\\n    function setTraderReferralCode(address _account, bytes32 _code) external;\\n\\n    function setTier(\\n        uint256 _tierId,\\n        uint256 _totalRebate,\\n        uint256 _discountShare\\n    ) external;\\n\\n    function setReferrerTier(address _referrer, uint256 _tierId) external;\\n\\n    function govSetCodeOwner(bytes32 _code, address _newAccount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/interfaces/IYieldToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IYieldToken {\\n    function totalStaked() external view returns (uint256);\\n    function stakedBalance(address _account) external view returns (uint256);\\n    function removeAdmin(address _account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/interfaces/IBaseToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IBaseToken {\\n    function totalStaked() external view returns (uint256);\\n\\n    function stakedBalance(address _account) external view returns (uint256);\\n\\n    function removeAdmin(address _account) external;\\n\\n    function setInPrivateTransferMode(bool _inPrivateTransferMode) external;\\n\\n    function withdrawToken(\\n        address _token,\\n        address _account,\\n        uint256 _amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/interfaces/IMintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IMintable {\\n    function isMinter(address _account) external returns (bool);\\n    function setMinter(address _minter, bool _isActive) external;\\n    function mint(address _account, uint256 _amount) external;\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/interfaces/IUSDM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IUSDM {\\n    function addVault(address _vault) external;\\n\\n    function removeVault(address _vault) external;\\n\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/interfaces/IVester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IVester {\\n    function rewardTracker() external view returns (address);\\n\\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\\n\\n    function claimable(address _account) external view returns (uint256);\\n    function cumulativeClaimAmounts(address _account) external view returns (uint256);\\n    function claimedAmounts(address _account) external view returns (uint256);\\n    function pairAmounts(address _account) external view returns (uint256);\\n    function getVestedAmount(address _account) external view returns (uint256);\\n    function transferredAverageStakedAmounts(address _account) external view returns (uint256);\\n    function transferredCumulativeRewards(address _account) external view returns (uint256);\\n    function cumulativeRewardDeductions(address _account) external view returns (uint256);\\n    function bonusRewards(address _account) external view returns (uint256);\\n\\n    function transferStakeValues(address _sender, address _receiver) external;\\n    function setTransferredAverageStakedAmounts(address _account, uint256 _amount) external;\\n    function setTransferredCumulativeRewards(address _account, uint256 _amount) external;\\n    function setCumulativeRewardDeductions(address _account, uint256 _amount) external;\\n    function setBonusRewards(address _account, uint256 _amount) external;\\n\\n    function getMaxVestableAmount(address _account) external view returns (uint256);\\n    function getCombinedAverageStakedAmount(address _account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_buffer\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mintReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mvlpManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxTokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marginFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxMarginFeeBasisPoints\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"action\",\"type\":\"bytes32\"}],\"name\":\"ClearAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"action\",\"type\":\"bytes32\"}],\"name\":\"SignalApprove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"action\",\"type\":\"bytes32\"}],\"name\":\"SignalMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"action\",\"type\":\"bytes32\"}],\"name\":\"SignalPendingAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SignalRedeemUsdm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gov\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"action\",\"type\":\"bytes32\"}],\"name\":\"SignalSetGov\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"action\",\"type\":\"bytes32\"}],\"name\":\"SignalSetHandler\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"action\",\"type\":\"bytes32\"}],\"name\":\"SignalSetPriceFeed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenDecimals\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenWeight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minProfitBps\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxUsdmAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isShortable\",\"type\":\"bool\"}],\"name\":\"SignalVaultSetTokenConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"action\",\"type\":\"bytes32\"}],\"name\":\"SignalWithdrawToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_BUFFER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FUNDING_RATE_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LEVERAGE_VALIDATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vester\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchSetBonusRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"batchWithdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_action\",\"type\":\"bytes32\"}],\"name\":\"cancelAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"disableLeverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"enableLeverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referralStorage\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_code\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_newAccount\",\"type\":\"address\"}],\"name\":\"govSetCodeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isHandler\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKeeper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marginFeeBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMarginFeeBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mvlpManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pendingActions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"processMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeemUsdm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buffer\",\"type\":\"uint256\"}],\"name\":\"setBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_handler\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setContractHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setExternalAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_taxBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stableTaxBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintBurnFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stableSwapFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marginFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidationFeeUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minProfitTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_hasDynamicFees\",\"type\":\"bool\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fundingInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fundingRateFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stableFundingRateFactor\",\"type\":\"uint256\"}],\"name\":\"setFundingRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"setGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_handler\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_inPrivateLiquidationMode\",\"type\":\"bool\"}],\"name\":\"setInPrivateLiquidationMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_inPrivateTransferMode\",\"type\":\"bool\"}],\"name\":\"setInPrivateTransferMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isLeverageEnabled\",\"type\":\"bool\"}],\"name\":\"setIsLeverageEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isSwapEnabled\",\"type\":\"bool\"}],\"name\":\"setIsSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setLiquidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marginFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxMarginFeeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setMarginFeeBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxGasPrice\",\"type\":\"uint256\"}],\"name\":\"setMaxGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMaxGlobalShortSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxLeverage\",\"type\":\"uint256\"}],\"name\":\"setMaxLeverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cooldownDuration\",\"type\":\"uint256\"}],\"name\":\"setMvlpCooldownDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"}],\"name\":\"setPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referralStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tierId\",\"type\":\"uint256\"}],\"name\":\"setReferrerTier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_shouldToggleIsLeverageEnabled\",\"type\":\"bool\"}],\"name\":\"setShouldToggleIsLeverageEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_taxBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stableTaxBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintBurnFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapFeeBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stableSwapFeeBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setSwapFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referralStorage\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tierId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalRebate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_discountShare\",\"type\":\"uint256\"}],\"name\":\"setTier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minProfitBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxUsdmAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bufferAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdmAmount\",\"type\":\"uint256\"}],\"name\":\"setTokenConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_usdmAmounts\",\"type\":\"uint256[]\"}],\"name\":\"setUsdmAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"contract IVaultUtils\",\"name\":\"_vaultUtils\",\"type\":\"address\"}],\"name\":\"setVaultUtils\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldToggleIsLeverageEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"signalApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"signalMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"signalRedeemUsdm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"signalSetGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_handler\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"signalSetHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"}],\"name\":\"signalSetPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minProfitBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxUsdmAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isStable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isShortable\",\"type\":\"bool\"}],\"name\":\"signalVaultSetTokenConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"signalWithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdmAmount\",\"type\":\"uint256\"}],\"name\":\"updateUsdmSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minProfitBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxUsdmAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isStable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isShortable\",\"type\":\"bool\"}],\"name\":\"vaultSetTokenConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Timelock", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000c1048db8e91e68b468b1d7b513fbb666c6e1622d000000000000000000000000000000000000000000000000000000000001518000000000000000000000000093415c0b0f59ff7c8f5b763ed1fcc617d1418df900000000000000000000000093415c0b0f59ff7c8f5b763ed1fcc617d1418df900000000000000000000000013e733ddd6725a8133bec31b2fc5994fa5c26ea9000000000000000000000000000000000000000000084595161401484a000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000001f4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}