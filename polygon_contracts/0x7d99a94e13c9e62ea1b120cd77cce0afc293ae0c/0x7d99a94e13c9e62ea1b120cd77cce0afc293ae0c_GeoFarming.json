{"SourceCode": "/*\r\n  ________            __________      .__            \r\n /  _____/  ____  ____\\______   \\____ |  | ___.__.   \r\n/   \\  ____/ __ \\/  _ \\|     ___/  _ \\|  |<   |  |   \r\n\\    \\_\\  \\  ___(  <_> )    |  (  <_> )  |_\\___  |   \r\n \\______  /\\___  >____/|____|   \\____/|____/ ____|   \r\n        \\/     \\/                          \\/        \r\n   ___________                    .__                \r\n   \\_   _____/____ _______  _____ |__| ____    ____  \r\n    |    __) \\__  \\\\_  __ \\/     \\|  |/    \\  / ___\\ \r\n    |     \\   / __ \\|  | \\/  Y Y  \\  |   |  \\/ /_/  >\r\n    \\___  /  (____  /__|  |__|_|  /__|___|  /\\___  / \r\n        \\/        \\/            \\/        \\//_____/  \r\n*/\r\n//SPDX-License-Identifier: GPL v3\r\n\r\npragma solidity >=0.8.0;\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface GeoPolyNFT {\r\n\r\n\tfunction getMintingString(uint256 tokenID) external view returns(string memory);\r\n\tfunction balanceOf(address wallet, uint256 tokenID) external returns(uint256);\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from,address to,uint256 id,uint256 amount, bytes calldata data) external;\r\n\tfunction getWalletNFTs(address wallet) external view returns(uint256[] memory);\r\n}\r\n\r\ninterface Geos20 {\r\n\tfunction decimals() external view returns(uint256);\r\n    function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\nlibrary GeopolyFarmingHelper {\r\n\tfunction findIndexInArr(uint256 val, uint256[] memory arr) public pure returns(bool,uint256){\r\n        for(uint256 i=0; i<arr.length; i++){\r\n            if(val == arr[i]){\r\n                return(true, i);\r\n            }\r\n        }\r\n        return(false, 0);\r\n    }\r\n\r\n    function getFirstDigit(uint256 _in) public pure returns(uint256){\r\n        uint256 temp = _in;\r\n        while(temp >= 10){\r\n            temp /= 10;\r\n        }\r\n        return temp;\r\n    }\r\n\r\n    function getValue(uint256 _in) public pure returns(uint256){\r\n        uint256 temp = _in;\r\n        uint256 cnt = 1;\r\n        uint256 val = 0;\r\n        while(temp >= 10){\r\n            cnt += 1;\r\n            temp /= 10;\r\n        }\r\n        if(cnt > 3){\r\n            uint256 _dCnt = cnt-3;\r\n            uint256 temp2 = 0;\r\n            val = temp*(10**_dCnt);\r\n            for(uint256 i=0; i<_dCnt; i++){\r\n                temp2 = getFirstDigit((_in - (temp*(10**(cnt-1-i)) ) ));\r\n                val += temp2*(10**(_dCnt-(i+1)));\r\n                temp = temp2;\r\n            }\r\n        }else{\r\n            val = temp;\r\n        }\r\n        return(val);\r\n    }\r\n}\r\n\r\n\r\n\r\nabstract contract GeopolyRoles is Ownable {\r\n    mapping(address => bool) private geopolyContracts;\r\n    mapping(address => bool) private geopolyAdmins;\r\n\r\n    function addToGeopolyContracts(address _nContract) public onlyOwner {\r\n        geopolyContracts[_nContract] = true;\r\n    }\r\n\r\n    function removeFromGeopolyContracts(address _contract) public onlyOwner {\r\n        geopolyContracts[_contract] = false;\r\n    }\r\n\r\n    function addToGeopolyAdmins(address _nAdmin) public onlyOwner {\r\n    \tgeopolyAdmins[_nAdmin] = true;\r\n    }\r\n\r\n    function removeFromGeopolyAdmins(address _admin) public onlyOwner {\r\n    \tgeopolyAdmins[_admin] = false;\r\n    }\r\n\r\n    modifier isAdmin(){\r\n    \trequire(geopolyAdmins[_msgSender()], \"GeopolyRoles: Address not admin\");\r\n        _;\r\n    }\r\n\r\n    modifier isGeopolyContract() {\r\n        require(geopolyContracts[_msgSender()], \"GeopolyRoles: Address not a geopoly contract\");\r\n        _;\r\n    }\r\n}\r\n\r\ninterface GeoSpeical {\r\n    function doAll(string calldata _in) external pure returns(uint256, uint256, uint256, string memory, string memory);\r\n}\r\n\r\n\r\n\r\ncontract GeoFarming is GeopolyRoles {\r\n\r\n\tevent FarmingStarted(uint256 tokenID, address owner, uint256 unlockTime, uint256 spinsAmount);\r\n\tevent FarmingHarvested(uint256 tokenID, address owner, uint256 timestamp, uint256 spinsAmount);\r\n\tevent SpinsPurchased(uint256 amount, address owner);\r\n\r\n\t// address for the NFT contract `ERC1155`\r\n\taddress NFT = 0x0b72a80C151DeC838Cb6fBCE002c09eD35897345;\r\n\t// current status for farming\r\n\tbool private farmingStatus;\r\n\t// farming fee, once paid on each NFT farm done\r\n\tuint256 farmingFee;\r\n\t// basis for calculating reward\r\n\tuint256 baseMultiplier = 1;\r\n\tuint256 baseDivisor = 1;\r\n\tuint256 baseOffset = 0;\r\n\t// price basis for tokens of 18 decimals\r\n\tuint256 priceBasis = 1 ether;\r\n\t// Mapping for each address on how many geospins\r\n\tmapping(address => uint256) _spins;\r\n\t// Mapping for each token supported how much for 1 GeoSpin\r\n\tmapping(address => uint256) _costs;\r\n\t// nft locking time\r\n\tuint256 nftLockTime = 120;\r\n\t// the return value of the selector\r\n\tbytes4 _ERC1155Selector = 0xf23a6e61;\r\n\t// a structure for all the different farmings\r\n\tstruct Farmings {\r\n\t\taddress owner;\r\n\t\tuint256 lockTs;\r\n\t\tuint256 unlockTs;\r\n\t\tuint256 spinReward;\r\n\t}\r\n\r\n\t// Mapping for each token to Farmings\r\n\tmapping(uint256 => Farmings) _farmings;\r\n\t// a reference for all the tokens currently farming\r\n\tuint256[] tokensFarming;\r\n\t// sale of geoSpins allowed\r\n\tbool geoSpinSales;\r\n    // library contract address\r\n    address geospecial = 0x44DA64602f77f7Caded40D71E0f1A252E6800064;\r\n    // change the status of the Geospin sales for tokens\r\n\tfunction changeGeoSpinSaleStatus(bool _nStatus) public isAdmin {\r\n\t\tgeoSpinSales = _nStatus;\r\n\t}\r\n\r\n\tfunction changeRewardBasis(uint256 _nBaseMultiplier, uint256 _nBaseDivisor, uint256 _nBaseOffset) public isAdmin {\r\n\t\tbaseMultiplier = _nBaseMultiplier;\r\n\t\tbaseDivisor = _nBaseDivisor;\r\n\t\tbaseOffset = _nBaseOffset;\r\n\t}\r\n\r\n\tfunction changeFarmingFee(uint256 _nFee) public isAdmin {\r\n\t\tfarmingFee = _nFee;\r\n\t} \r\n\r\n\tfunction changeFarmingStatus(bool _farmingStatus) public isAdmin {\r\n\t\tfarmingStatus = _farmingStatus;\r\n\t}\r\n\r\n\tfunction changeNFTFarmingPeriod(uint256 _nFarmingPeriod) public isAdmin{\r\n\t\tnftLockTime = _nFarmingPeriod;\r\n\t}\r\n\r\n\tfunction nftFarmingPeriod() public view returns(uint256){\r\n\t\treturn(nftLockTime);\r\n\t}\r\n\r\n\t// check if tokenID is farming\r\n\tfunction isNFTFarming(uint256 tokenID) public view returns(bool){\r\n\t\treturn(_farmings[tokenID].lockTs > 0);\r\n\t}\r\n\r\n\tfunction spinsReward(uint256 tokenID) public view returns(uint256){\r\n\t\treturn(_farmings[tokenID].spinReward);\r\n\t}\r\n\r\n\t// check farming time remaining will return a timestamp in seconds of when is unlocked\r\n\tfunction farmingTime(uint256 tokenID) public view returns(uint256){\r\n\t\treturn(_farmings[tokenID].unlockTs);\r\n\t}\r\n\t// check the original NFT owner of the tokenID\r\n\tfunction nftOwner(uint256 tokenID) public view returns(address){\r\n\t\trequire(isNFTFarming(tokenID), \"GeopolyFarms: This token is not currently farming\");\r\n\t\treturn(_farmings[tokenID].owner);\r\n\t}\r\n\t// safe add farming to the tokenID\r\n\tfunction _safeAddFarming(uint256 tokenID, address owner, uint256 lockTS, uint256 unlockTS) internal {\r\n\t\t_farmings[tokenID] = Farmings(owner, lockTS, unlockTS, getRewards(tokenID));\r\n\t\ttokensFarming.push(tokenID);\r\n\t}\r\n\t// safe remove farming from the tokenID\r\n\tfunction _safeRemoveFarming(uint256 tokenID) internal {\r\n\t\t_safeAddSpins(_farmings[tokenID].spinReward, _farmings[tokenID].owner);\r\n\t\t_farmings[tokenID] = Farmings(address(0), 0, 0, 0);\r\n\t\t(bool sucess, uint256 index) = GeopolyFarmingHelper.findIndexInArr(tokenID, tokensFarming);\r\n\t\tif(sucess){\r\n\t\t\tdelete(tokensFarming[index]);\r\n\t\t}else{\r\n\t\t\trevert(\"Cannot find index\");\r\n\t\t}\r\n\t}\r\n\r\n\t// remove the 0s stuck in the array from deletion to free up gas for users\r\n\tfunction cleanUp() external {\r\n        uint256 _count = 0;\r\n        for(uint256 i=0; i<tokensFarming.length; i++){\r\n            if(tokensFarming[i] != 0){\r\n                _count +=1;\r\n            }\r\n        }\r\n        uint256[] memory _nAllTokens = new uint256[](_count);\r\n        uint256 _index = 0;\r\n        for(uint256 i=0; i<tokensFarming.length; i++){\r\n            if(tokensFarming[i] != 0){\r\n                _nAllTokens[_index] = tokensFarming[i];\r\n                _index +=1;\r\n            }\r\n        }\r\n        tokensFarming = _nAllTokens;\r\n\t}\r\n\r\n\t// initiate the farm \r\n\tfunction Farm(uint256 tokenID) external payable {\r\n\t\trequire(farmingStatus, \"GeopolyFarms: Sorry Farming is under maintainance\");\r\n\t\trequire(!isNFTFarming(tokenID), \"GeopolyFarms: This NFT has already started farming\");\r\n\t\trequire(msg.value >= farmingFee, \"GeopolyFarms: You need to pay a farming fee to start farming your NFT\");\r\n\t\trequire(recieve1155Token(msg.sender, tokenID), \"GeopolyFarms: Cannot Farm your NFT\");\r\n\t\t_safeAddFarming(tokenID, msg.sender, block.timestamp, (block.timestamp + nftLockTime));\r\n\r\n\t}\r\n\t// harvest the farm initated\r\n\tfunction Harvest(uint256 tokenID) external {\r\n\t\trequire(nftOwner(tokenID) == msg.sender, \"GeopolyFarms: Cannot harvest an NFT that is not your own\");\r\n\t\trequire(block.timestamp >= farmingTime(tokenID), \"GeopolyFarms: This NFT is not done farming yet\");\r\n\t\trequire(send1155Token(msg.sender, tokenID), \"GeopolyFarms: Cannot send back the NFT\");\r\n\t\t_safeRemoveFarming(tokenID);\r\n\t}\r\n\t//get all the current nfts farming\r\n\tfunction getWalletFarmings(address wallet) public view returns(uint256[] memory walletFarmings){\r\n\t\tuint256 count = 0;\r\n\t\tfor(uint256 i=0; i<tokensFarming.length; i++){\r\n\t\t\tif(_farmings[tokensFarming[i]].owner == wallet){\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t}\t\r\n\t\twalletFarmings = new uint256[](count);\r\n\t\tcount = 0;\r\n\t\tfor(uint256 i=0; i<tokensFarming.length; i++){\r\n\t\t\tif(_farmings[tokensFarming[i]].owner == wallet){\r\n\t\t\t\twalletFarmings[count] = tokensFarming[i];\r\n\t\t\t\tcount += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// get all the users NFTs (farming&&notFarming)\r\n\tfunction getWalletNFTs(address owner) public view returns(uint256[] memory allNFTs) {\r\n\t\tuint256[] memory nftsMain = GeoPolyNFT(NFT).getWalletNFTs(owner);\r\n\t\tuint256[] memory nftsFarming = getWalletFarmings(owner);\r\n\t \tuint256 _fLen = nftsMain.length;\r\n        uint256 _nLen = nftsFarming.length;\r\n        uint256 _combinedLen = _fLen + _nLen;\r\n        allNFTs = new uint256[](_combinedLen);\r\n        if(_fLen != 0){\r\n            for(uint256 i=0; i<_fLen; i++){\r\n                allNFTs[i] = nftsMain[i];\r\n            }\r\n        }\r\n        if(_nLen != 0){\r\n            if(_fLen != 0){\r\n                for(uint256 i=0; i<_nLen; i++){\r\n                    allNFTs[(_fLen+i)] = nftsFarming[i];\r\n                }\r\n            }else{\r\n                for(uint256 i=0; i<_nLen; i++){\r\n                        allNFTs[i] = nftsFarming[i];\r\n                }\r\n            }\r\n        }\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * boring ERC1155 function to acknowledge that GeopolyFarms can receieve ERC1155 tokens\r\n\t */\r\n    function onERC1155Received(address ,address ,uint256 ,uint256 ,bytes calldata) public view returns(bytes4){\r\n    \treturn(_ERC1155Selector);\r\n    }\r\n\r\n\t/**\r\n\t * boring ERC1155 function to send tokens\r\n\t */\r\n\tfunction send1155Token(address owner, uint256 tokenID) internal returns(bool) {\r\n\t\trequire(GeoPolyNFT(NFT).balanceOf(address(this), tokenID) > 0, \"GeopolyFarms: We do not own this NFT.\");\r\n\t\tGeoPolyNFT(NFT).safeTransferFrom(address(this), owner, tokenID, 1, \"\");\r\n\t\treturn true;\r\n\t}\r\n\t/**\r\n\t * boring ERC1155 function to recieve tokens\r\n\t */\r\n\tfunction recieve1155Token(address owner, uint256 tokenID) internal returns(bool) {\r\n\t\trequire(GeoPolyNFT(NFT).balanceOf(owner, tokenID) > 0, \"GeopolyFarms: Cannot farm NFT you dont own\");\r\n\t\trequire(GeoPolyNFT(NFT).isApprovedForAll(owner, address(this)), \"GeopolyFarms: Need to approve us to farm your NFT\");\r\n\t\tGeoPolyNFT(NFT).safeTransferFrom(owner, address(this), tokenID, 1, \"\");\r\n\t\treturn true;\r\n\t}\r\n    /**\r\n     * boring ERC20 function to send tokens\r\n     */\r\n    function send20Token(address token, address reciever, uint256 amount) internal returns(bool){\r\n        require(Geos20(token).balanceOf(address(this)) > amount, \"No enough balance\");\r\n        require(Geos20(token).transfer(reciever, amount), \"Cannot currently transfer\");\r\n        return true;\r\n    }\r\n\r\n\t/**\r\n     * boring ERC20 function to recieve tokens\r\n     */\r\n    function recieve20Token(address token, address sender, uint256 amount) internal returns(bool) {\r\n        require(Geos20(token).allowance(sender, address(this)) >= amount, \"Need to approve us for WIZZY to farm\");\r\n        require(Geos20(token).transferFrom(sender, address(this), amount), \"Need to pay us WIZZY to go farming\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * boring ERC20 function to get token decimals\r\n     */\r\n\tfunction getTokenDecimals(address token) internal view returns(uint256 decimals){\r\n\t\tdecimals = Geos20(token).decimals();\r\n\t\trequire(decimals != 0, \"GeopolyFarms: Cannot pay with a 0 decimal token\");\r\n\t}\r\n\t// checks if the token is supported to be paid with for geospons\r\n\tfunction isTokenSupported(address token) internal view returns(bool){\r\n\t\treturn(_costs[token] != 0);\r\n\t}\r\n\t// get the cost of the 1 geospin for this token\r\n\tfunction _getCost(address token) internal view returns(uint256 cost){\r\n\t\tif(token == address(this)){\r\n\t\t\tcost = _costs[address(this)]*priceBasis;\r\n\t\t}else{\r\n\t\t\trequire(isTokenSupported(token), \"GeopolyFarms: This token is not supported\");\r\n\t\t\tcost = _costs[token]*(10**getTokenDecimals(token));\t\t\t\r\n\t\t}\r\n\t\trequire(cost != 0, \"GeopolyFarms: Cost cannot be zero.\");\r\n\t}\r\n\t// buy spins using any supported token\r\n\tfunction buySpins(uint256 amount, address token) external payable {\r\n\t\trequire(geoSpinSales, \"GeopolyFarms: Sale of geospins is paused\");\r\n\t\tif(token == address(0)){\r\n\t\t\trequire(msg.value >= (_getCost(address(this))*amount), \"GeopolyFarms: need to pay cost for geospins in matic\");\r\n\t\t}else{\r\n\t\t\trequire(recieve20Token(token, msg.sender, (_getCost(token))*amount), \"GeopolyFarms: need to pay cost for geospins in tokens\");\r\n\t\t}\r\n\t\t_safeAddSpins(amount, msg.sender);\r\n\t\temit SpinsPurchased(amount, msg.sender);\r\n\t}\r\n\r\n\t// remove spins called from any geopoly contract\r\n\tfunction removeSpin(address owner, uint256 amount) external isGeopolyContract {\r\n\t\trequire(spinBalance(owner) >= amount, \"GeopolyFarms: Not enough spins\");\r\n\t\t_spins[owner] -= amount;\r\n\t}\r\n\r\n\t// add spins internal function to add the amount to owner address\r\n\tfunction _safeAddSpins(uint256 amount, address owner) internal {\r\n\t\trequire(amount != 0, \"GeopolyFarms: Cannot add 0 spins\");\r\n\t\t_spins[owner] += amount;\r\n\t}\r\n\t// returns the spin balance of a wallet\r\n\tfunction spinBalance(address wallet) public view returns(uint256){\r\n\t\treturn(_spins[wallet]);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice to change the value for the native token, use the address of \r\n\t * the contract \r\n\t * @dev sets the supported token address and amount as a cost for 1 geospin\r\n\t */\r\n\tfunction setSupportedToken(address token, uint256 amount) external isAdmin {\r\n\t\t_costs[token] = amount;\r\n\t}\r\n\t// returns the current farming status \r\n\tfunction checkFarmStatus() public view returns(bool){\r\n\t\treturn(farmingStatus);\r\n\t}\r\n\t//  returns the NFT category and tier of an NFT\r\n\tfunction _checkNFTProps(uint256 tokenID) internal view returns(uint256 category, uint256 tier){\r\n        string memory _main = GeoPolyNFT(NFT).getMintingString(tokenID);\r\n        (category,tier,,,) = GeoSpeical(geospecial).doAll(_main);\r\n\t}\r\n\r\n\tfunction getRewards(uint256 tokenID) public view returns(uint256 _reward){\r\n\t\t(uint256 category, uint256 tier) = _checkNFTProps(tokenID);\r\n              if(category == 25){\r\n            category = 10;\r\n        }else if(category == 26){\r\n            category = 20;\r\n        }else{\r\n            category = category;\r\n        }\r\n        _reward = (category/2)+1;\r\n\t\tif(tier != 1){\r\n            uint256 temp = _reward*100;\r\n            for(uint256 i=1; i<tier; i++){\r\n                temp += ((temp*25)/100);\r\n            }\r\n            _reward = GeopolyFarmingHelper.getValue(temp);\r\n            if(category % 2 != 0){\r\n                _reward += 1;\r\n            }\r\n\t\t}\r\n\t\t_reward = ((_reward*baseMultiplier)/baseDivisor)+baseOffset;\r\n\t}\r\n\r\n\r\n\tfunction withdrawNative(uint256 amount, address to) external onlyOwner {\r\n\t\trequire(address(this).balance >= amount,\"GeopolyFarms: Not enough balance\");\r\n        require(payable(to).send(amount), \"GeopolyFarms: Cannot process withdrawal to this address\");\r\n\t}\r\n\r\n\tfunction withdraw20Tokens(address token, uint256 amount, address to) external onlyOwner {\r\n\t\trequire(Geos20(token).balanceOf(address(this)) > amount, \"GeopolyFarms: Not enough balance\");\r\n\t\trequire(Geos20(token).transfer(to, amount));\r\n\t}\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spinsAmount\",\"type\":\"uint256\"}],\"name\":\"FarmingHarvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spinsAmount\",\"type\":\"uint256\"}],\"name\":\"FarmingStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SpinsPurchased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Farm\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nAdmin\",\"type\":\"address\"}],\"name\":\"addToGeopolyAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nContract\",\"type\":\"address\"}],\"name\":\"addToGeopolyContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"buySpins\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nFee\",\"type\":\"uint256\"}],\"name\":\"changeFarmingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_farmingStatus\",\"type\":\"bool\"}],\"name\":\"changeFarmingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_nStatus\",\"type\":\"bool\"}],\"name\":\"changeGeoSpinSaleStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nFarmingPeriod\",\"type\":\"uint256\"}],\"name\":\"changeNFTFarmingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nBaseMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nBaseDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nBaseOffset\",\"type\":\"uint256\"}],\"name\":\"changeRewardBasis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkFarmStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cleanUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"farmingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getWalletFarmings\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"walletFarmings\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getWalletNFTs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"allNFTs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"isNFTFarming\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftFarmingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"nftOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeFromGeopolyAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"removeFromGeopolyContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeSpin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSupportedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"spinBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"spinsReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw20Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GeoFarming", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "GeopolyFarmingHelper:0dd38875abdc9dc6c0c7b3d205187434e54214b0", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://de1358b559dd30dac0f9d1faa26915d4c8bacf22db0e93ac31a9214b0989d831"}