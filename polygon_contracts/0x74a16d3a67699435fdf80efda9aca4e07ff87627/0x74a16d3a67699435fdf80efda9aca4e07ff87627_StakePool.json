{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2021-06-15\r\n*/\r\n\r\npragma abicoder v2;\r\npragma solidity >=0.7.6;\r\n\r\n\r\n// SPDX-License-Identifier: MIT\r\ninterface IStakePoolCreator {\r\n    function version() external returns (uint);\r\n\r\n    function create() external returns (address);\r\n    function initialize(address poolAddress, address pair, address rewardToken, address timelock, address stakePoolRewardFund, bytes calldata data) external;\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract TimeLock {\r\n    using SafeMath for uint256;\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint indexed newDelay);\r\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n\r\n    uint public constant GRACE_PERIOD = 14 days;\r\n    uint public constant MINIMUM_DELAY = 1 days;\r\n    uint public constant MAXIMUM_DELAY = 30 days;\r\n    bool private _initialized;\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint public delay;\r\n    bool public admin_initialized;\r\n    mapping(bytes32 => bool) public queuedTransactions;\r\n\r\n    constructor() public {\r\n        admin_initialized = false;\r\n        _initialized = false;\r\n    }\r\n\r\n    function initialize(address _admin, uint _delay) public {\r\n        require(_initialized == false, \"Timelock::constructor: Initialized must be false.\");\r\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = _delay;\r\n        admin = _admin;\r\n        _initialized = true;\r\n        emit NewAdmin(admin);\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setDelay(uint _delay) public {\r\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n        require(_delay >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(_delay <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = _delay;\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address _pendingAdmin) public {\r\n        // allows one time setting of admin for deployment purposes\r\n        if (admin_initialized) {\r\n            require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n        } else {\r\n            require(msg.sender == admin, \"Timelock::setPendingAdmin: First call must come from admin.\");\r\n            admin_initialized = true;\r\n        }\r\n        pendingAdmin = _pendingAdmin;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\r\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\r\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\r\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call{value : value}(callData);\r\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\ninterface IStakePool {\r\n    event Deposit(address indexed account, uint256 amount);\r\n    event AddRewardPool(uint256 indexed poolId);\r\n    event UpdateRewardPool(uint256 indexed poolId, uint256 endRewardTime, uint256 rewardPerSecond);\r\n    event PayRewardPool(uint256 indexed poolId, address indexed rewardToken, address indexed account, uint256 pendingReward, uint256 rebaseAmount, uint256 paidReward);\r\n    event UpdateRewardRebaser(uint256 indexed poolId, address rewardRebaser);\r\n    event UpdateRewardMultiplier(uint256 indexed poolId, address rewardMultiplier);\r\n    event Withdraw(address indexed account, uint256 amount);\r\n    function version() external view returns (uint);\r\n    function stakeToken() external view returns (address);\r\n    function initialize(address _stakeToken, uint _unstakingFrozenTime, address _rewardFund, address _timelock) external;\r\n\r\n    function stake(uint) external;\r\n\r\n    function stakeFor(address _account) external;\r\n\r\n    function withdraw(uint) external;\r\n\r\n    function getReward(uint8 _pid, address _account) external;\r\n\r\n    function getAllRewards(address _account) external;\r\n    function claimReward() external;\r\n    function pendingReward(uint8 _pid, address _account) external view returns (uint);\r\n\r\n    function allowRecoverRewardToken(address _token) external view returns (bool);\r\n    function getRewardPerSecond(uint8 pid) external view returns (uint);\r\n    function rewardPoolInfoLength() external view returns (uint);\r\n\r\n    function unfrozenStakeTime(address _account) external view returns (uint);\r\n\r\n    function emergencyWithdraw() external;\r\n\r\n    function updateReward() external;\r\n\r\n    function updateReward(uint8 _pid) external;\r\n\r\n    function updateRewardPool(uint8 _pid, uint256 _endRewardTime, uint256 _rewardPerSecond) external;\r\n    function stopRewardPool(uint8 _pid) external;\r\n    function getRewardMultiplier(uint8 _pid, uint _from, uint _to, uint _rewardPerSecond) external view returns (uint);\r\n\r\n    function getRewardRebase(uint8 _pid, address _rewardToken, uint _pendingReward) external view returns (uint);\r\n\r\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external;\r\n\r\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external;\r\n\r\n    function getUserInfo(uint8 _pid, address _account) external view returns (uint amount, uint rewardDebt, uint accumulatedEarned, uint lockReward, uint lockRewardReleased);\r\n\r\n    function addRewardPool(\r\n        address _rewardToken,\r\n        address _rewardRebaser,\r\n        address _rewardMultiplier,\r\n        uint256 _startTime,\r\n        uint256 _endRewardTime,\r\n        uint256 _rewardPerSecond,\r\n        uint256 _lockRewardPercent,\r\n        uint256 _startVestingTime,\r\n        uint256 _endVestingTime\r\n    ) external;\r\n}\r\n\r\ninterface IStakePoolController {\r\n    event MasterCreated(address indexed farm, address indexed stakeToken, uint version, address timelock, address stakePoolRewardFund, uint totalStakePool);\r\n    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\r\n    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\r\n    event SetStakePoolCreator(address indexed contractAddress, uint verion);\r\n    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\r\n    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\r\n    event SetStakePoolVerifier(address indexed contractAddress, bool value);\r\n    event ChangeGovernance(address indexed governance);\r\n    event SetFeeCollector(address indexed feeCollector);\r\n    event SetFeeToken(address indexed token);\r\n    event SetFeeAmount(uint indexed amount);\r\n    event SetExtraFeeRate(uint indexed amount);\r\n\r\n\r\n\r\n    function allStakePools(uint) external view returns (address stakePool);\r\n\r\n    function isStakePool(address contractAddress) external view returns (bool);\r\n    function isStakePoolVerifier(address contractAddress) external view returns (bool);\r\n\r\n    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\r\n    function isWhitelistStakePool(address contractAddress) external view returns (int8);\r\n    function setStakePoolVerifier(address contractAddress, bool state) external;\r\n    function setWhitelistStakingFor(address contractAddress, bool state) external;\r\n\r\n    function setWhitelistStakePool(address contractAddress, int8 state) external;\r\n    function addStakePoolCreator(address contractAddress) external;\r\n\r\n    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\r\n    function isAllowEmergencyWithdrawStakePool(address _address) external view returns (bool);\r\n    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\r\n\r\n    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\r\n    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external;\r\n    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\r\n    function setEnableWhitelistRewardRebaser(bool value) external;\r\n    function setEnableWhitelistRewardMultiplier(bool value) external;\r\n    function allStakePoolsLength() external view returns (uint);\r\n\r\n    function create(uint version, address stakeToken, address rewardToken, uint rewardFundAmount, uint delayTimeLock, bytes calldata data) external returns (address);\r\n\r\n    function setGovernance(address) external;\r\n\r\n    function setFeeCollector(address _address) external;\r\n    function setFeeToken(address _token) external;\r\n    function setFeeAmount(uint _token) external;\r\n    function setExtraFeeRate(uint _extraFeeRate) external;\r\n\r\n}\r\n\r\ninterface IStakePoolRewardRebaser {\r\n    function getRebaseAmount(address rewardToken, uint baseAmount) external view returns (uint);\r\n}\r\n\r\ninterface IStakePoolRewardMultiplier {\r\n    function getRewardMultiplier(uint _start, uint _end, uint _from, uint _to, uint _rewardPerSecond) external view returns (uint);\r\n}\r\n\r\ninterface IERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IStakePoolRewardFund {\r\n    function initialize(address _stakePool, address _timelock) external;\r\n\r\n    function safeTransfer(address _token, address _to, uint _value) external;\r\n}\r\n\r\ncontract StakePool is IStakePool {\r\n    using SafeMath for uint;\r\n    uint public override version;\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint amount;\r\n        mapping(uint8 => uint) rewardDebt;\r\n        mapping(uint8 => uint) reward;\r\n        mapping(uint8 => uint) accumulatedEarned; // will accumulate every time user harvest\r\n        mapping(uint8 => uint) lockReward;\r\n        mapping(uint8 => uint) lockRewardReleased;\r\n        uint lastStakeTime;\r\n    }\r\n\r\n    // Info of each rewardPool funding.\r\n    struct RewardPoolInfo {\r\n        address rewardToken;     // Address of rewardPool token contract.\r\n        address rewardRebaser;     // Address of rewardRebaser contract.\r\n        address rewardMultiplier;     // Address of rewardMultiplier contract.\r\n        uint startRewardTime;   // Start reward block number that rewardPool distribution occurs.\r\n        uint lastRewardTime;   // Last block number that rewardPool distribution occurs.\r\n        uint endRewardTime;    // Block time which rewardPool distribution ends.\r\n        uint rewardPerSecond;    // Reward token amount to distribute per block.\r\n        uint accRewardPerShare; // Accumulated rewardPool per share, times 1e18.\r\n\r\n        uint lockRewardPercent; // Lock reward percent - 0 to disable lock & vesting\r\n        uint startVestingTime; // Block time which vesting starts.\r\n        uint endVestingTime;   // Block time which vesting ends.\r\n        uint vestingDuration;\r\n\r\n        uint totalPaidRewards;\r\n    }\r\n\r\n    mapping(address => UserInfo) public userInfo;\r\n    RewardPoolInfo[] public rewardPoolInfo;\r\n    address public override stakeToken;\r\n    address public rewardFund;\r\n    address public timelock;\r\n    address public controller;\r\n\r\n    uint public balance;\r\n    uint public unstakingFrozenTime = 3 days;\r\n    uint private unlocked = 1;\r\n    bool private _initialized = false;\r\n\r\n    constructor(address _controller, uint _version) public {\r\n        controller = _controller;\r\n        timelock = msg.sender;\r\n        version = _version;\r\n    }\r\n    modifier lock() {\r\n        require(unlocked == 1, 'StakePool: LOCKED');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n    modifier onlyTimeLock() {\r\n        require(msg.sender == timelock, \"StakePool: !timelock\");\r\n        _;\r\n    }\r\n\r\n    function allowRecoverRewardToken(address _token) external view override returns (bool) {\r\n        for (uint8 pid = 0; pid < rewardPoolInfo.length; ++pid) {\r\n            RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\r\n            if (rewardPool.rewardToken == _token) {\r\n                // do not allow to drain reward token if less than 3 days after pool ends\r\n                if (block.timestamp < (rewardPool.endRewardTime + (3 days))) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    // called once by the factory at time of deployment\r\n    function initialize(address _stakeToken, uint _unstakingFrozenTime, address _rewardFund, address _timelock) external override {\r\n        require(_initialized == false, \"StakePool: Initialize must be false.\");\r\n        require(unstakingFrozenTime <= 30 days, \"StakePool: unstakingFrozenTime > 30 days\");\r\n        stakeToken = _stakeToken;\r\n        unstakingFrozenTime = _unstakingFrozenTime;\r\n        rewardFund = _rewardFund;\r\n        timelock = _timelock;\r\n        _initialized = true;\r\n    }\r\n\r\n    function addRewardPool(\r\n        address _rewardToken, address _rewardRebaser, address _rewardMultiplier,\r\n        uint256 _startTime, uint256 _endRewardTime,\r\n        uint256 _rewardPerSecond, uint256 _lockRewardPercent,\r\n        uint256 _startVestingTime, uint256 _endVestingTime\r\n    ) external override lock onlyTimeLock {\r\n        require(rewardPoolInfo.length <= 16, \"StakePool: Reward pool length > 16\");\r\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"StakePool: Invalid reward rebaser\");\r\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"StakePool: Invalid reward multiplier\");\r\n        require(_startVestingTime <= _endVestingTime, \"StakePool: startVestingTime > endVestingTime\");\r\n        _startTime = (block.timestamp > _startTime) ? block.timestamp : _startTime;\r\n        require(_startTime < _endRewardTime, \"StakePool: startTime >= endRewardTime\");\r\n        require(_lockRewardPercent <= 100, \"StakePool: invalid lockRewardPercent\");\r\n        updateReward();\r\n        rewardPoolInfo.push(RewardPoolInfo({\r\n        rewardToken : _rewardToken,\r\n        rewardRebaser : _rewardRebaser,\r\n        startRewardTime : _startTime,\r\n        rewardMultiplier : _rewardMultiplier,\r\n        lastRewardTime : _startTime,\r\n        endRewardTime : _endRewardTime,\r\n        rewardPerSecond : _rewardPerSecond,\r\n        accRewardPerShare : 0,\r\n        lockRewardPercent : _lockRewardPercent,\r\n        startVestingTime : _startVestingTime,\r\n        endVestingTime : _endVestingTime,\r\n        vestingDuration : _endVestingTime - _startVestingTime,\r\n        totalPaidRewards : 0\r\n        }));\r\n        emit AddRewardPool(rewardPoolInfo.length - 1);\r\n    }\r\n\r\n    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external override lock onlyTimeLock {\r\n        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), \"StakePool: Invalid reward multiplier\");\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        rewardPool.rewardMultiplier = _rewardMultiplier;\r\n        updateReward(_pid);\r\n        emit UpdateRewardMultiplier(_pid, _rewardMultiplier);\r\n    }\r\n\r\n    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external override lock onlyTimeLock {\r\n        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), \"StakePool: Invalid reward rebaser\");\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        rewardPool.rewardRebaser = _rewardRebaser;\r\n        updateReward(_pid);\r\n        emit UpdateRewardRebaser(_pid, _rewardRebaser);\r\n    }\r\n\r\n    // Return reward multiplier over the given _from to _to block.\r\n    function getRewardMultiplier(uint8 _pid, uint _from, uint _to, uint _rewardPerSecond) public override view returns (uint) {\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        address rewardMultiplier = rewardPool.rewardMultiplier;\r\n        if (rewardMultiplier == address(0)) {\r\n            return _to.sub(_from).mul(_rewardPerSecond);\r\n        }\r\n        return IStakePoolRewardMultiplier(rewardMultiplier).getRewardMultiplier(\r\n            rewardPool.startRewardTime,\r\n            rewardPool.endRewardTime,\r\n            _from,\r\n            _to,\r\n            _rewardPerSecond\r\n        );\r\n    }\r\n\r\n    function getRewardRebase(uint8 _pid, address _rewardToken, uint _pendingReward) public override view returns (uint) {\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        address rewardRebaser = rewardPool.rewardRebaser;\r\n        if (rewardRebaser == address(0)) {\r\n            return _pendingReward;\r\n        }\r\n        return IStakePoolRewardRebaser(rewardRebaser).getRebaseAmount(_rewardToken, _pendingReward);\r\n    }\r\n\r\n    function getRewardPerSecond(uint8 pid, uint from, uint to) public view returns (uint) {\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\r\n        uint rewardPerSecond = rewardPool.rewardPerSecond;\r\n        if (from < rewardPool.startRewardTime || from > rewardPool.endRewardTime) return 0;\r\n        uint reward = getRewardMultiplier(pid, from, to, rewardPerSecond);\r\n        return getRewardRebase(pid, rewardPool.rewardToken, reward);\r\n    }\r\n\r\n    function getRewardPerSecond(uint8 pid) external override view returns (uint) {\r\n        return getRewardPerSecond(pid, block.timestamp, block.timestamp + 1);\r\n    }\r\n\r\n    function updateRewardPool(uint8 _pid, uint256 _endRewardTime, uint256 _rewardPerSecond) public override lock onlyTimeLock {\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        require(block.timestamp <= rewardPool.endRewardTime && block.timestamp <= _endRewardTime, \"StakePool: blockTime > endRewardTime\");\r\n        updateReward(_pid);\r\n        rewardPool.endRewardTime = _endRewardTime;\r\n        rewardPool.rewardPerSecond = _rewardPerSecond;\r\n        emit UpdateRewardPool(_pid, _endRewardTime, _rewardPerSecond);\r\n    }\r\n\r\n    function stopRewardPool(uint8 _pid) public override lock onlyTimeLock {\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        updateReward(_pid);\r\n        rewardPool.endRewardTime = block.timestamp;\r\n        rewardPool.rewardPerSecond = 0;\r\n        emit UpdateRewardPool(_pid, rewardPool.endRewardTime, rewardPool.rewardPerSecond);\r\n    }\r\n\r\n    function stake(uint _amount) external lock override {\r\n        TransferHelper.safeTransferFrom(stakeToken, msg.sender, address(this), _amount);\r\n        _stakeFor(msg.sender);\r\n    }\r\n\r\n    function stakeFor(address _account) external lock override {\r\n        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), \"StakePool: Invalid sender\");\r\n        _stakeFor(_account);\r\n    }\r\n\r\n    function _stakeFor(address _account) internal {\r\n        uint _amount = IERC20(stakeToken).balanceOf(address(this)).sub(balance);\r\n        require(_amount > 0, \"StakePool: Invalid balance\");\r\n        balance = balance.add(_amount);\r\n        UserInfo storage user = userInfo[_account];\r\n        getAllRewards(_account);\r\n        user.amount = user.amount.add(_amount);\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\r\n        }\r\n        user.lastStakeTime = block.timestamp;\r\n        emit Deposit(_account, _amount);\r\n    }\r\n\r\n    function rewardPoolInfoLength() public override view returns (uint) {\r\n        return rewardPoolInfo.length;\r\n    }\r\n\r\n    function unfrozenStakeTime(address _account) public override view returns (uint) {\r\n        return userInfo[_account].lastStakeTime + unstakingFrozenTime;\r\n    }\r\n\r\n    function removeStakeInternal(uint _amount) internal {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.amount >= _amount, \"StakePool: invalid withdraw amount\");\r\n        require(block.timestamp >= user.lastStakeTime.add(unstakingFrozenTime), \"StakePool: frozen\");\r\n        getAllRewards(msg.sender);\r\n        balance = balance.sub(_amount);\r\n        user.amount = user.amount.sub(_amount);\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint _amount) public lock override {\r\n        removeStakeInternal(_amount);\r\n        TransferHelper.safeTransfer(stakeToken, msg.sender, _amount);\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    function exit() external {\r\n        withdraw(userInfo[msg.sender].amount);\r\n    }\r\n\r\n    function getAllRewards(address _account) public override {\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            getReward(_pid, _account);\r\n        }\r\n    }\r\n\r\n    function claimReward() external override {\r\n        getAllRewards(msg.sender);\r\n    }\r\n\r\n    function getReward(uint8 _pid, address _account) public override {\r\n        updateReward(_pid);\r\n        UserInfo storage user = userInfo[_account];\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        uint _accRewardPerShare = rewardPool.accRewardPerShare;\r\n        uint _pendingReward = user.amount.mul(_accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\r\n        uint _lockRewardPercent = rewardPool.lockRewardPercent;\r\n        if (_lockRewardPercent > 0) {\r\n            if (block.timestamp > rewardPool.endVestingTime) {\r\n                uint _unlockReward = user.lockReward[_pid].sub(user.lockRewardReleased[_pid]);\r\n                if (_unlockReward > 0) {\r\n                    _pendingReward = _pendingReward.add(_unlockReward);\r\n                    user.lockRewardReleased[_pid] = user.lockRewardReleased[_pid].add(_unlockReward);\r\n                }\r\n            } else {\r\n                if (_pendingReward > 0) {\r\n                    uint _toLocked = _pendingReward.mul(_lockRewardPercent).div(100);\r\n                    _pendingReward = _pendingReward.sub(_toLocked);\r\n                    user.lockReward[_pid] = user.lockReward[_pid].add(_toLocked);\r\n                }\r\n                uint _startVestingTime = rewardPool.startVestingTime;\r\n                if (block.timestamp > _startVestingTime) {\r\n                    uint _toReleased = user.lockReward[_pid].mul(block.timestamp.sub(_startVestingTime)).div(rewardPool.vestingDuration);\r\n                    uint _lockRewardReleased = user.lockRewardReleased[_pid];\r\n                    if (_toReleased > _lockRewardReleased) {\r\n                        uint _unlockReward = _toReleased.sub(_lockRewardReleased);\r\n                        user.lockRewardReleased[_pid] = _lockRewardReleased.add(_unlockReward);\r\n                        _pendingReward = _pendingReward.add(_unlockReward);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (_pendingReward > 0) {\r\n            user.accumulatedEarned[_pid] = user.accumulatedEarned[_pid].add(_pendingReward);\r\n            rewardPool.totalPaidRewards = rewardPool.totalPaidRewards.add(_pendingReward);\r\n            user.rewardDebt[_pid] = user.amount.mul(_accRewardPerShare).div(1e18);\r\n            uint reward = user.reward[_pid].add(_pendingReward);\r\n            user.reward[_pid] = reward;\r\n            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\r\n            address rewardToken = rewardPool.rewardToken;\r\n            uint rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\r\n            if (rewardBalance > 0) {\r\n                user.reward[_pid] = 0;\r\n                uint rebaseAmount = getRewardRebase(_pid, rewardToken, reward);\r\n                uint paidAmount = rebaseAmount > rewardBalance ? rewardBalance : rebaseAmount;\r\n                IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, _account, paidAmount);\r\n                emit PayRewardPool(_pid, rewardToken, _account, reward, rebaseAmount, paidAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function pendingReward(uint8 _pid, address _account) external override view returns (uint) {\r\n        UserInfo storage user = userInfo[_account];\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        uint _accRewardPerShare = rewardPool.accRewardPerShare;\r\n        uint lpSupply = IERC20(stakeToken).balanceOf(address(this));\r\n        uint _endRewardTime = rewardPool.endRewardTime;\r\n        uint _endRewardTimeApplicable = block.timestamp > _endRewardTime ? _endRewardTime : block.timestamp;\r\n        uint _lastRewardTime = rewardPool.lastRewardTime;\r\n        if (_endRewardTimeApplicable > _lastRewardTime && lpSupply != 0) {\r\n            uint _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardTime, _endRewardTimeApplicable, rewardPool.rewardPerSecond).mul(1e18).div(lpSupply);\r\n            _accRewardPerShare = _accRewardPerShare.add(_incRewardPerShare);\r\n        }\r\n        uint pending = user.amount.mul(_accRewardPerShare).div(1e18).add(user.reward[_pid]).sub(user.rewardDebt[_pid]);\r\n        return getRewardRebase(_pid, rewardPool.rewardToken, pending);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw() external lock override {\r\n        require(unstakingFrozenTime == 0 || IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), \"StakePool: Not allow emergencyWithdraw\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint amount = user.amount;\r\n        balance = balance.sub(amount);\r\n        user.amount = 0;\r\n        TransferHelper.safeTransfer(stakeToken, msg.sender, amount);\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            user.rewardDebt[_pid] = 0;\r\n            user.reward[_pid] = 0;\r\n        }\r\n    }\r\n\r\n    function getUserInfo(uint8 _pid, address _account) public override view returns (uint amount, uint rewardDebt, uint accumulatedEarned, uint lockReward, uint lockRewardReleased) {\r\n        UserInfo storage user = userInfo[_account];\r\n        amount = user.amount;\r\n        rewardDebt = user.rewardDebt[_pid];\r\n        accumulatedEarned = user.accumulatedEarned[_pid];\r\n        lockReward = user.lockReward[_pid];\r\n        lockRewardReleased = user.lockRewardReleased[_pid];\r\n    }\r\n\r\n    function updateReward() public override {\r\n        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\r\n        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\r\n            updateReward(_pid);\r\n        }\r\n    }\r\n\r\n    function updateReward(uint8 _pid) public override {\r\n        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\r\n        uint _endRewardTime = rewardPool.endRewardTime;\r\n        uint _endRewardTimeApplicable = block.timestamp > _endRewardTime ? _endRewardTime : block.timestamp;\r\n        uint _lastRewardTime = rewardPool.lastRewardTime;\r\n        if (_endRewardTimeApplicable > _lastRewardTime) {\r\n            uint lpSupply = IERC20(stakeToken).balanceOf(address(this));\r\n            if (lpSupply > 0) {\r\n                uint _incRewardPerShare = getRewardMultiplier(_pid, _lastRewardTime, _endRewardTimeApplicable, rewardPool.rewardPerSecond).mul(1e18).div(lpSupply);\r\n                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare.add(_incRewardPerShare);\r\n            }\r\n            rewardPool.lastRewardTime = _endRewardTimeApplicable;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract StakePoolCreator is IStakePoolCreator {\r\n    uint public override version = 3001;\r\n\r\n    struct PoolRewardInfo {\r\n        address rewardRebaser;\r\n        address rewardMultiplier;\r\n        uint256 startBlock;\r\n        uint256 endRewardBlock;\r\n        uint256 rewardPerBlock;\r\n        uint256 lockRewardPercent;\r\n        uint256 startVestingBlock;\r\n        uint256 endVestingBlock;\r\n        uint unstakingFrozenTime;\r\n    }\r\n    function create() external override returns (address) {\r\n        StakePool pool = new StakePool(msg.sender, version);\r\n        return address(pool);\r\n    }\r\n    function initialize(address poolAddress, address pair, address rewardToken, address timelock, address stakePoolRewardFund, bytes calldata data) external override {\r\n        StakePool pool = StakePool(poolAddress);\r\n        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\r\n        pool.addRewardPool(\r\n            rewardToken,\r\n            poolRewardInfo.rewardRebaser,\r\n            poolRewardInfo.rewardMultiplier,\r\n            poolRewardInfo.startBlock,\r\n            poolRewardInfo.endRewardBlock,\r\n            poolRewardInfo.rewardPerBlock,\r\n            poolRewardInfo.lockRewardPercent,\r\n            poolRewardInfo.startVestingBlock,\r\n            poolRewardInfo.endVestingBlock\r\n        );\r\n        pool.initialize(pair, poolRewardInfo.unstakingFrozenTime, address(stakePoolRewardFund), address(timelock));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"AddRewardPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rebaseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidReward\",\"type\":\"uint256\"}],\"name\":\"PayRewardPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardMultiplier\",\"type\":\"address\"}],\"name\":\"UpdateRewardMultiplier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endRewardTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerSecond\",\"type\":\"uint256\"}],\"name\":\"UpdateRewardPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardRebaser\",\"type\":\"address\"}],\"name\":\"UpdateRewardRebaser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardRebaser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardMultiplier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockRewardPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startVestingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endVestingTime\",\"type\":\"uint256\"}],\"name\":\"addRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"allowRecoverRewardToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerSecond\",\"type\":\"uint256\"}],\"name\":\"getRewardMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"pid\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"getRewardPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"pid\",\"type\":\"uint8\"}],\"name\":\"getRewardPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pendingReward\",\"type\":\"uint256\"}],\"name\":\"getRewardRebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumulatedEarned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockRewardReleased\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_unstakingFrozenTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_rewardFund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timelock\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardPoolInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardRebaser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardMultiplier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockRewardPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startVestingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endVestingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPaidRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPoolInfoLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"stopRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"unfrozenStakeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakingFrozenTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"}],\"name\":\"updateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_rewardMultiplier\",\"type\":\"address\"}],\"name\":\"updateRewardMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_endRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerSecond\",\"type\":\"uint256\"}],\"name\":\"updateRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pid\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_rewardRebaser\",\"type\":\"address\"}],\"name\":\"updateRewardRebaser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastStakeTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakePool", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000badc009227a5fe0b423b994669dd68d0d3cc722c0000000000000000000000000000000000000000000000000000000000000bb9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://463c941054aae8887bd1ed63d8956b400bf49ceb3500f80600a5876bc4f6a137"}