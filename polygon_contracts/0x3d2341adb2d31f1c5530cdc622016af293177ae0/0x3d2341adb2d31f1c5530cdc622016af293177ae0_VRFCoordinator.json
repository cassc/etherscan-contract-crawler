{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2020-08-26\r\n*/\r\n\r\n// File: contracts/vendor/SafeMath.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/LinkTokenInterface.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\n// File: contracts/interfaces/BlockHashStoreInterface.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\ninterface BlockHashStoreInterface {\r\n  function getBlockhash(uint256 number) external view returns (bytes32);\r\n}\r\n\r\n// File: contracts/VRF.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n/** ****************************************************************************\r\n  * @notice Verification of verifiable-random-function (VRF) proofs, following\r\n  * @notice https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\r\n  * @notice See https://eprint.iacr.org/2017/099.pdf for security proofs.\r\n\r\n  * @dev Bibliographic references:\r\n\r\n  * @dev Goldberg, et al., \"Verifiable Random Functions (VRFs)\", Internet Draft\r\n  * @dev draft-irtf-cfrg-vrf-05, IETF, Aug 11 2019,\r\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05\r\n\r\n  * @dev Papadopoulos, et al., \"Making NSEC5 Practical for DNSSEC\", Cryptology\r\n  * @dev ePrint Archive, Report 2017/099, https://eprint.iacr.org/2017/099.pdf\r\n  * ****************************************************************************\r\n  * @dev USAGE\r\n\r\n  * @dev The main entry point is randomValueFromVRFProof. See its docstring.\r\n  * ****************************************************************************\r\n  * @dev PURPOSE\r\n\r\n  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\r\n  * @dev to Vera the verifier in such a way that Vera can be sure he's not\r\n  * @dev making his output up to suit himself. Reggie provides Vera a public key\r\n  * @dev to which he knows the secret key. Each time Vera provides a seed to\r\n  * @dev Reggie, he gives back a value which is computed completely\r\n  * @dev deterministically from the seed and the secret key.\r\n\r\n  * @dev Reggie provides a proof by which Vera can verify that the output was\r\n  * @dev correctly computed once Reggie tells it to her, but without that proof,\r\n  * @dev the output is computationally indistinguishable to her from a uniform\r\n  * @dev random sample from the output space.\r\n\r\n  * @dev The purpose of this contract is to perform that verification.\r\n  * ****************************************************************************\r\n  * @dev DESIGN NOTES\r\n\r\n  * @dev The VRF algorithm verified here satisfies the full unqiqueness, full\r\n  * @dev collision resistance, and full pseudorandomness security properties.\r\n  * @dev See \"SECURITY PROPERTIES\" below, and\r\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-3\r\n\r\n  * @dev An elliptic curve point is generally represented in the solidity code\r\n  * @dev as a uint256[2], corresponding to its affine coordinates in\r\n  * @dev GF(FIELD_SIZE).\r\n\r\n  * @dev For the sake of efficiency, this implementation deviates from the spec\r\n  * @dev in some minor ways:\r\n\r\n  * @dev - Keccak hash rather than the SHA256 hash recommended in\r\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\r\n  * @dev   Keccak costs much less gas on the EVM, and provides similar security.\r\n\r\n  * @dev - Secp256k1 curve instead of the P-256 or ED25519 curves recommended in\r\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\r\n  * @dev   For curve-point multiplication, it's much cheaper to abuse ECRECOVER\r\n\r\n  * @dev - hashToCurve recursively hashes until it finds a curve x-ordinate. On\r\n  * @dev   the EVM, this is slightly more efficient than the recommendation in\r\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\r\n  * @dev   step 5, to concatenate with a nonce then hash, and rehash with the\r\n  * @dev   nonce updated until a valid x-ordinate is found.\r\n\r\n  * @dev - hashToCurve does not include a cipher version string or the byte 0x1\r\n  * @dev   in the hash message, as recommended in step 5.B of the draft\r\n  * @dev   standard. They are unnecessary here because no variation in the\r\n  * @dev   cipher suite is allowed.\r\n\r\n  * @dev - Similarly, the hash input in scalarFromCurvePoints does not include a\r\n  * @dev   commitment to the cipher suite, either, which differs from step 2 of\r\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\r\n  * @dev   . Also, the hash input is the concatenation of the uncompressed\r\n  * @dev   points, not the compressed points as recommended in step 3.\r\n\r\n  * @dev - In the calculation of the challenge value \"c\", the \"u\" value (i.e.\r\n  * @dev   the value computed by Reggie as the nonce times the secp256k1\r\n  * @dev   generator point, see steps 5 and 7 of\r\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\r\n  * @dev   ) is replaced by its ethereum address, i.e. the lower 160 bits of the\r\n  * @dev   keccak hash of the original u. This is because we only verify the\r\n  * @dev   calculation of u up to its address, by abusing ECRECOVER.\r\n  * ****************************************************************************\r\n  * @dev   SECURITY PROPERTIES\r\n\r\n  * @dev Here are the security properties for this VRF:\r\n\r\n  * @dev Full uniqueness: For any seed and valid VRF public key, there is\r\n  * @dev   exactly one VRF output which can be proved to come from that seed, in\r\n  * @dev   the sense that the proof will pass verifyVRFProof.\r\n\r\n  * @dev Full collision resistance: It's cryptographically infeasible to find\r\n  * @dev   two seeds with same VRF output from a fixed, valid VRF key\r\n\r\n  * @dev Full pseudorandomness: Absent the proofs that the VRF outputs are\r\n  * @dev   derived from a given seed, the outputs are computationally\r\n  * @dev   indistinguishable from randomness.\r\n\r\n  * @dev https://eprint.iacr.org/2017/099.pdf, Appendix B contains the proofs\r\n  * @dev for these properties.\r\n\r\n  * @dev For secp256k1, the key validation described in section\r\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.6\r\n  * @dev is unnecessary, because secp256k1 has cofactor 1, and the\r\n  * @dev representation of the public key used here (affine x- and y-ordinates\r\n  * @dev of the secp256k1 point on the standard y^2=x^3+7 curve) cannot refer to\r\n  * @dev the point at infinity.\r\n  * ****************************************************************************\r\n  * @dev OTHER SECURITY CONSIDERATIONS\r\n  *\r\n  * @dev The seed input to the VRF could in principle force an arbitrary amount\r\n  * @dev of work in hashToCurve, by requiring extra rounds of hashing and\r\n  * @dev checking whether that's yielded the x ordinate of a secp256k1 point.\r\n  * @dev However, under the Random Oracle Model the probability of choosing a\r\n  * @dev point which forces n extra rounds in hashToCurve is 2\u207b\u207f. The base cost\r\n  * @dev for calling hashToCurve is about 25,000 gas, and each round of checking\r\n  * @dev for a valid x ordinate costs about 15,555 gas, so to find a seed for\r\n  * @dev which hashToCurve would cost more than 2,017,000 gas, one would have to\r\n  * @dev try, in expectation, about 2\u00b9\u00b2\u2078 seeds, which is infeasible for any\r\n  * @dev foreseeable computational resources. (25,000 + 128 * 15,555 < 2,017,000.)\r\n\r\n  * @dev Since the gas block limit for the Ethereum main net is 10,000,000 gas,\r\n  * @dev this means it is infeasible for an adversary to prevent correct\r\n  * @dev operation of this contract by choosing an adverse seed.\r\n\r\n  * @dev (See TestMeasureHashToCurveGasCost for verification of the gas cost for\r\n  * @dev hashToCurve.)\r\n\r\n  * @dev It may be possible to make a secure constant-time hashToCurve function.\r\n  * @dev See notes in hashToCurve docstring.\r\n*/\r\ncontract VRF {\r\n\r\n  // See https://www.secg.org/sec2-v2.pdf, section 2.4.1, for these constants.\r\n  uint256 constant private GROUP_ORDER = // Number of points in Secp256k1\r\n    // solium-disable-next-line indentation\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\r\n  // Prime characteristic of the galois field over which Secp256k1 is defined\r\n  uint256 constant private FIELD_SIZE =\r\n    // solium-disable-next-line indentation\r\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\r\n  uint256 constant private WORD_LENGTH_BYTES = 0x20;\r\n\r\n  // (base^exponent) % FIELD_SIZE\r\n  // Cribbed from https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4\r\n  function bigModExp(uint256 base, uint256 exponent)\r\n    internal view returns (uint256 exponentiation) {\r\n      uint256 callResult;\r\n      uint256[6] memory bigModExpContractInputs;\r\n      bigModExpContractInputs[0] = WORD_LENGTH_BYTES;  // Length of base\r\n      bigModExpContractInputs[1] = WORD_LENGTH_BYTES;  // Length of exponent\r\n      bigModExpContractInputs[2] = WORD_LENGTH_BYTES;  // Length of modulus\r\n      bigModExpContractInputs[3] = base;\r\n      bigModExpContractInputs[4] = exponent;\r\n      bigModExpContractInputs[5] = FIELD_SIZE;\r\n      uint256[1] memory output;\r\n      assembly { // solhint-disable-line no-inline-assembly\r\n      callResult := staticcall(\r\n        not(0),                   // Gas cost: no limit\r\n        0x05,                     // Bigmodexp contract address\r\n        bigModExpContractInputs,\r\n        0xc0,                     // Length of input segment: 6*0x20-bytes\r\n        output,\r\n        0x20                      // Length of output segment\r\n      )\r\n      }\r\n      if (callResult == 0) {revert(\"bigModExp failure!\");}\r\n      return output[0];\r\n    }\r\n\r\n  // Let q=FIELD_SIZE. q % 4 = 3, \u2234 x\u2261r^2 mod q \u21d2 x^SQRT_POWER\u2261\u00b1r mod q.  See\r\n  // https://en.wikipedia.org/wiki/Modular_square_root#Prime_or_prime_power_modulus\r\n  uint256 constant private SQRT_POWER = (FIELD_SIZE + 1) >> 2;\r\n\r\n  // Computes a s.t. a^2 = x in the field. Assumes a exists\r\n  function squareRoot(uint256 x) internal view returns (uint256) {\r\n    return bigModExp(x, SQRT_POWER);\r\n  }\r\n\r\n  // The value of y^2 given that (x,y) is on secp256k1.\r\n  function ySquared(uint256 x) internal pure returns (uint256) {\r\n    // Curve is y^2=x^3+7. See section 2.4.1 of https://www.secg.org/sec2-v2.pdf\r\n    uint256 xCubed = mulmod(x, mulmod(x, x, FIELD_SIZE), FIELD_SIZE);\r\n    return addmod(xCubed, 7, FIELD_SIZE);\r\n  }\r\n\r\n  // True iff p is on secp256k1\r\n  function isOnCurve(uint256[2] memory p) internal pure returns (bool) {\r\n    return ySquared(p[0]) == mulmod(p[1], p[1], FIELD_SIZE);\r\n  }\r\n\r\n  // Hash x uniformly into {0, ..., FIELD_SIZE-1}.\r\n  function fieldHash(bytes memory b) internal pure returns (uint256 x_) {\r\n    x_ = uint256(keccak256(b));\r\n    // Rejecting if x >= FIELD_SIZE corresponds to step 2.1 in section 2.3.4 of\r\n    // http://www.secg.org/sec1-v2.pdf , which is part of the definition of\r\n    // string_to_point in the IETF draft\r\n    while (x_ >= FIELD_SIZE) {\r\n      x_ = uint256(keccak256(abi.encodePacked(x_)));\r\n    }\r\n  }\r\n\r\n  // Hash b to a random point which hopefully lies on secp256k1. The y ordinate\r\n  // is always even, due to\r\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\r\n  // step 5.C, which references arbitrary_string_to_point, defined in\r\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5 as\r\n  // returning the point with given x ordinate, and even y ordinate.\r\n  function newCandidateSecp256k1Point(bytes memory b)\r\n    internal view returns (uint256[2] memory p) {\r\n      p[0] = fieldHash(b);\r\n      p[1] = squareRoot(ySquared(p[0]));\r\n      if (p[1] % 2 == 1) {\r\n        p[1] = FIELD_SIZE - p[1];\r\n      }\r\n    }\r\n\r\n  // Domain-separation tag for initial hash in hashToCurve. Corresponds to\r\n  // vrf.go/hashToCurveHashPrefix\r\n  uint256 constant HASH_TO_CURVE_HASH_PREFIX = 1;\r\n\r\n  // Cryptographic hash function onto the curve.\r\n  //\r\n  // Corresponds to algorithm in section 5.4.1.1 of the draft standard. (But see\r\n  // DESIGN NOTES above for slight differences.)\r\n  //\r\n  // TODO(alx): Implement a bounded-computation hash-to-curve, as described in\r\n  // \"Construction of Rational Points on Elliptic Curves over Finite Fields\"\r\n  // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.831.5299&rep=rep1&type=pdf\r\n  // and suggested by\r\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-01#section-5.2.2\r\n  // (Though we can't used exactly that because secp256k1's j-invariant is 0.)\r\n  //\r\n  // This would greatly simplify the analysis in \"OTHER SECURITY CONSIDERATIONS\"\r\n  // https://www.pivotaltracker.com/story/show/171120900\r\n  function hashToCurve(uint256[2] memory pk, uint256 input)\r\n    internal view returns (uint256[2] memory rv) {\r\n      rv = newCandidateSecp256k1Point(abi.encodePacked(HASH_TO_CURVE_HASH_PREFIX,\r\n                                                       pk, input));\r\n      while (!isOnCurve(rv)) {\r\n        rv = newCandidateSecp256k1Point(abi.encodePacked(rv[0]));\r\n      }\r\n    }\r\n\r\n  /** *********************************************************************\r\n   * @notice Check that product==scalar*multiplicand\r\n   *\r\n   * @dev Based on Vitalik Buterin's idea in ethresear.ch post cited below.\r\n   *\r\n   * @param multiplicand: secp256k1 point\r\n   * @param scalar: non-zero GF(GROUP_ORDER) scalar\r\n   * @param product: secp256k1 expected to be multiplier * multiplicand\r\n   * @return verifies true iff product==scalar*multiplicand, with cryptographically high probability\r\n   */\r\n  function ecmulVerify(uint256[2] memory multiplicand, uint256 scalar,\r\n    uint256[2] memory product) internal pure returns(bool verifies)\r\n  {\r\n    require(scalar != 0); // Rules out an ecrecover failure case\r\n    uint256 x = multiplicand[0]; // x ordinate of multiplicand\r\n    uint8 v = multiplicand[1] % 2 == 0 ? 27 : 28; // parity of y ordinate\r\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\r\n    // Point corresponding to address ecrecover(0, v, x, s=scalar*x) is\r\n    // (x\u207b\u00b9 mod GROUP_ORDER) * (scalar * x * multiplicand - 0 * g), i.e.\r\n    // scalar*multiplicand. See https://crypto.stackexchange.com/a/18106\r\n    bytes32 scalarTimesX = bytes32(mulmod(scalar, x, GROUP_ORDER));\r\n    address actual = ecrecover(bytes32(0), v, bytes32(x), scalarTimesX);\r\n    // Explicit conversion to address takes bottom 160 bits\r\n    address expected = address(uint256(keccak256(abi.encodePacked(product))));\r\n    return (actual == expected);\r\n  }\r\n\r\n  // Returns x1/z1-x2/z2=(x1z2-x2z1)/(z1z2) in projective coordinates on P\u00b9(\ud835\udd3d\u2099)\r\n  function projectiveSub(uint256 x1, uint256 z1, uint256 x2, uint256 z2)\r\n    internal pure returns(uint256 x3, uint256 z3) {\r\n      uint256 num1 = mulmod(z2, x1, FIELD_SIZE);\r\n      uint256 num2 = mulmod(FIELD_SIZE - x2, z1, FIELD_SIZE);\r\n      (x3, z3) = (addmod(num1, num2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\r\n    }\r\n\r\n  // Returns x1/z1*x2/z2=(x1x2)/(z1z2), in projective coordinates on P\u00b9(\ud835\udd3d\u2099)\r\n  function projectiveMul(uint256 x1, uint256 z1, uint256 x2, uint256 z2)\r\n    internal pure returns(uint256 x3, uint256 z3) {\r\n      (x3, z3) = (mulmod(x1, x2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\r\n    }\r\n\r\n  /** **************************************************************************\r\n      @notice Computes elliptic-curve sum, in projective co-ordinates\r\n\r\n      @dev Using projective coordinates avoids costly divisions\r\n\r\n      @dev To use this with p and q in affine coordinates, call\r\n      @dev projectiveECAdd(px, py, qx, qy). This will return\r\n      @dev the addition of (px, py, 1) and (qx, qy, 1), in the\r\n      @dev secp256k1 group.\r\n\r\n      @dev This can be used to calculate the z which is the inverse to zInv\r\n      @dev in isValidVRFOutput. But consider using a faster\r\n      @dev re-implementation such as ProjectiveECAdd in the golang vrf package.\r\n\r\n      @dev This function assumes [px,py,1],[qx,qy,1] are valid projective\r\n           coordinates of secp256k1 points. That is safe in this contract,\r\n           because this method is only used by linearCombination, which checks\r\n           points are on the curve via ecrecover.\r\n      **************************************************************************\r\n      @param px The first affine coordinate of the first summand\r\n      @param py The second affine coordinate of the first summand\r\n      @param qx The first affine coordinate of the second summand\r\n      @param qy The second affine coordinate of the second summand\r\n\r\n      (px,py) and (qx,qy) must be distinct, valid secp256k1 points.\r\n      **************************************************************************\r\n      Return values are projective coordinates of [px,py,1]+[qx,qy,1] as points\r\n      on secp256k1, in P\u00b2(\ud835\udd3d\u2099)\r\n      @return sx \r\n      @return sy\r\n      @return sz\r\n  */\r\n  function projectiveECAdd(uint256 px, uint256 py, uint256 qx, uint256 qy)\r\n    internal pure returns(uint256 sx, uint256 sy, uint256 sz) {\r\n      // See \"Group law for E/K : y^2 = x^3 + ax + b\", in section 3.1.2, p. 80,\r\n      // \"Guide to Elliptic Curve Cryptography\" by Hankerson, Menezes and Vanstone\r\n      // We take the equations there for (sx,sy), and homogenize them to\r\n      // projective coordinates. That way, no inverses are required, here, and we\r\n      // only need the one inverse in affineECAdd.\r\n\r\n      // We only need the \"point addition\" equations from Hankerson et al. Can\r\n      // skip the \"point doubling\" equations because p1 == p2 is cryptographically\r\n      // impossible, and require'd not to be the case in linearCombination.\r\n\r\n      // Add extra \"projective coordinate\" to the two points\r\n      (uint256 z1, uint256 z2) = (1, 1);\r\n\r\n      // (lx, lz) = (qy-py)/(qx-px), i.e., gradient of secant line.\r\n      uint256 lx = addmod(qy, FIELD_SIZE - py, FIELD_SIZE);\r\n      uint256 lz = addmod(qx, FIELD_SIZE - px, FIELD_SIZE);\r\n\r\n      uint256 dx; // Accumulates denominator from sx calculation\r\n      // sx=((qy-py)/(qx-px))^2-px-qx\r\n      (sx, dx) = projectiveMul(lx, lz, lx, lz); // ((qy-py)/(qx-px))^2\r\n      (sx, dx) = projectiveSub(sx, dx, px, z1); // ((qy-py)/(qx-px))^2-px\r\n      (sx, dx) = projectiveSub(sx, dx, qx, z2); // ((qy-py)/(qx-px))^2-px-qx\r\n\r\n      uint256 dy; // Accumulates denominator from sy calculation\r\n      // sy=((qy-py)/(qx-px))(px-sx)-py\r\n      (sy, dy) = projectiveSub(px, z1, sx, dx); // px-sx\r\n      (sy, dy) = projectiveMul(sy, dy, lx, lz); // ((qy-py)/(qx-px))(px-sx)\r\n      (sy, dy) = projectiveSub(sy, dy, py, z1); // ((qy-py)/(qx-px))(px-sx)-py\r\n\r\n      if (dx != dy) { // Cross-multiply to put everything over a common denominator\r\n        sx = mulmod(sx, dy, FIELD_SIZE);\r\n        sy = mulmod(sy, dx, FIELD_SIZE);\r\n        sz = mulmod(dx, dy, FIELD_SIZE);\r\n      } else { // Already over a common denominator, use that for z ordinate\r\n        sz = dx;\r\n      }\r\n    }\r\n\r\n  // p1+p2, as affine points on secp256k1.\r\n  //\r\n  // invZ must be the inverse of the z returned by projectiveECAdd(p1, p2).\r\n  // It is computed off-chain to save gas.\r\n  //\r\n  // p1 and p2 must be distinct, because projectiveECAdd doesn't handle\r\n  // point doubling.\r\n  function affineECAdd(\r\n    uint256[2] memory p1, uint256[2] memory p2,\r\n    uint256 invZ) internal pure returns (uint256[2] memory) {\r\n    uint256 x;\r\n    uint256 y;\r\n    uint256 z;\r\n    (x, y, z) = projectiveECAdd(p1[0], p1[1], p2[0], p2[1]);\r\n    require(mulmod(z, invZ, FIELD_SIZE) == 1, \"invZ must be inverse of z\");\r\n    // Clear the z ordinate of the projective representation by dividing through\r\n    // by it, to obtain the affine representation\r\n    return [mulmod(x, invZ, FIELD_SIZE), mulmod(y, invZ, FIELD_SIZE)];\r\n  }\r\n\r\n  // True iff address(c*p+s*g) == lcWitness, where g is generator. (With\r\n  // cryptographically high probability.)\r\n  function verifyLinearCombinationWithGenerator(\r\n    uint256 c, uint256[2] memory p, uint256 s, address lcWitness)\r\n    internal pure returns (bool) {\r\n      // Rule out ecrecover failure modes which return address 0.\r\n      require(lcWitness != address(0), \"bad witness\");\r\n      uint8 v = (p[1] % 2 == 0) ? 27 : 28; // parity of y-ordinate of p\r\n      bytes32 pseudoHash = bytes32(GROUP_ORDER - mulmod(p[0], s, GROUP_ORDER)); // -s*p[0]\r\n      bytes32 pseudoSignature = bytes32(mulmod(c, p[0], GROUP_ORDER)); // c*p[0]\r\n      // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\r\n      // The point corresponding to the address returned by\r\n      // ecrecover(-s*p[0],v,p[0],c*p[0]) is\r\n      // (p[0]\u207b\u00b9 mod GROUP_ORDER)*(c*p[0]-(-s)*p[0]*g)=c*p+s*g.\r\n      // See https://crypto.stackexchange.com/a/18106\r\n      // https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v\r\n      address computed = ecrecover(pseudoHash, v, bytes32(p[0]), pseudoSignature);\r\n      return computed == lcWitness;\r\n    }\r\n\r\n  // c*p1 + s*p2. Requires cp1Witness=c*p1 and sp2Witness=s*p2. Also\r\n  // requires cp1Witness != sp2Witness (which is fine for this application,\r\n  // since it is cryptographically impossible for them to be equal. In the\r\n  // (cryptographically impossible) case that a prover accidentally derives\r\n  // a proof with equal c*p1 and s*p2, they should retry with a different\r\n  // proof nonce.) Assumes that all points are on secp256k1\r\n  // (which is checked in verifyVRFProof below.)\r\n  function linearCombination(\r\n    uint256 c, uint256[2] memory p1, uint256[2] memory cp1Witness,\r\n    uint256 s, uint256[2] memory p2, uint256[2] memory sp2Witness,\r\n    uint256 zInv)\r\n    internal pure returns (uint256[2] memory) {\r\n      require((cp1Witness[0] - sp2Witness[0]) % FIELD_SIZE != 0,\r\n              \"points in sum must be distinct\");\r\n      require(ecmulVerify(p1, c, cp1Witness), \"First multiplication check failed\");\r\n      require(ecmulVerify(p2, s, sp2Witness), \"Second multiplication check failed\");\r\n      return affineECAdd(cp1Witness, sp2Witness, zInv);\r\n    }\r\n\r\n  // Domain-separation tag for the hash taken in scalarFromCurvePoints.\r\n  // Corresponds to scalarFromCurveHashPrefix in vrf.go\r\n  uint256 constant SCALAR_FROM_CURVE_POINTS_HASH_PREFIX = 2;\r\n\r\n  // Pseudo-random number from inputs. Matches vrf.go/scalarFromCurvePoints, and\r\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\r\n  // The draft calls (in step 7, via the definition of string_to_int, in\r\n  // https://datatracker.ietf.org/doc/html/rfc8017#section-4.2 ) for taking the\r\n  // first hash without checking that it corresponds to a number less than the\r\n  // group order, which will lead to a slight bias in the sample.\r\n  //\r\n  // TODO(alx): We could save a bit of gas by following the standard here and\r\n  // using the compressed representation of the points, if we collated the y\r\n  // parities into a single bytes32.\r\n  // https://www.pivotaltracker.com/story/show/171120588\r\n  function scalarFromCurvePoints(\r\n    uint256[2] memory hash, uint256[2] memory pk, uint256[2] memory gamma,\r\n    address uWitness, uint256[2] memory v)\r\n    internal pure returns (uint256 s) {\r\n      return uint256(\r\n        keccak256(abi.encodePacked(SCALAR_FROM_CURVE_POINTS_HASH_PREFIX,\r\n                                   hash, pk, gamma, v, uWitness)));\r\n    }\r\n\r\n  // True if (gamma, c, s) is a correctly constructed randomness proof from pk\r\n  // and seed. zInv must be the inverse of the third ordinate from\r\n  // projectiveECAdd applied to cGammaWitness and sHashWitness. Corresponds to\r\n  // section 5.3 of the IETF draft.\r\n  //\r\n  // TODO(alx): Since I'm only using pk in the ecrecover call, I could only pass\r\n  // the x ordinate, and the parity of the y ordinate in the top bit of uWitness\r\n  // (which I could make a uint256 without using any extra space.) Would save\r\n  // about 2000 gas. https://www.pivotaltracker.com/story/show/170828567\r\n  function verifyVRFProof(\r\n    uint256[2] memory pk, uint256[2] memory gamma, uint256 c, uint256 s,\r\n    uint256 seed, address uWitness, uint256[2] memory cGammaWitness,\r\n    uint256[2] memory sHashWitness, uint256 zInv)\r\n    internal view {\r\n      require(isOnCurve(pk), \"public key is not on curve\");\r\n      require(isOnCurve(gamma), \"gamma is not on curve\");\r\n      require(isOnCurve(cGammaWitness), \"cGammaWitness is not on curve\");\r\n      require(isOnCurve(sHashWitness), \"sHashWitness is not on curve\");\r\n      // Step 5. of IETF draft section 5.3 (pk corresponds to 5.3's Y, and here\r\n      // we use the address of u instead of u itself. Also, here we add the\r\n      // terms instead of taking the difference, and in the proof consruction in\r\n      // vrf.GenerateProof, we correspondingly take the difference instead of\r\n      // taking the sum as they do in step 7 of section 5.1.)\r\n      require(\r\n        verifyLinearCombinationWithGenerator(c, pk, s, uWitness),\r\n        \"addr(c*pk+s*g)\u2260_uWitness\"\r\n      );\r\n      // Step 4. of IETF draft section 5.3 (pk corresponds to Y, seed to alpha_string)\r\n      uint256[2] memory hash = hashToCurve(pk, seed);\r\n      // Step 6. of IETF draft section 5.3, but see note for step 5 about +/- terms\r\n      uint256[2] memory v = linearCombination(\r\n        c, gamma, cGammaWitness, s, hash, sHashWitness, zInv);\r\n      // Steps 7. and 8. of IETF draft section 5.3\r\n      uint256 derivedC = scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\r\n      require(c == derivedC, \"invalid proof\");\r\n    }\r\n\r\n  // Domain-separation tag for the hash used as the final VRF output.\r\n  // Corresponds to vrfRandomOutputHashPrefix in vrf.go\r\n  uint256 constant VRF_RANDOM_OUTPUT_HASH_PREFIX = 3;\r\n\r\n  // Length of proof marshaled to bytes array. Shows layout of proof\r\n  uint public constant PROOF_LENGTH = 64 + // PublicKey (uncompressed format.)\r\n    64 + // Gamma\r\n    32 + // C\r\n    32 + // S\r\n    32 + // Seed\r\n    0 + // Dummy entry: The following elements are included for gas efficiency:\r\n    32 + // uWitness (gets padded to 256 bits, even though it's only 160)\r\n    64 + // cGammaWitness\r\n    64 + // sHashWitness\r\n    32; // zInv  (Leave Output out, because that can be efficiently calculated)\r\n\r\n  /* ***************************************************************************\r\n   * @notice Returns proof's output, if proof is valid. Otherwise reverts\r\n\r\n   * @param proof A binary-encoded proof, as output by vrf.Proof.MarshalForSolidityVerifier\r\n   *\r\n   * Throws if proof is invalid, otherwise:\r\n   * @return output i.e., the random output implied by the proof\r\n   * ***************************************************************************\r\n   * @dev See the calculation of PROOF_LENGTH for the binary layout of proof.\r\n   */\r\n  function randomValueFromVRFProof(bytes memory proof)\r\n    internal view returns (uint256 output) {\r\n      require(proof.length == PROOF_LENGTH, \"wrong proof length\");\r\n\r\n      uint256[2] memory pk; // parse proof contents into these variables\r\n      uint256[2] memory gamma;\r\n      // c, s and seed combined (prevents \"stack too deep\" compilation error)\r\n      uint256[3] memory cSSeed;\r\n      address uWitness;\r\n      uint256[2] memory cGammaWitness;\r\n      uint256[2] memory sHashWitness;\r\n      uint256 zInv;\r\n      (pk, gamma, cSSeed, uWitness, cGammaWitness, sHashWitness, zInv) = abi.decode(\r\n        proof, (uint256[2], uint256[2], uint256[3], address, uint256[2],\r\n                uint256[2], uint256));\r\n      verifyVRFProof(\r\n        pk,\r\n        gamma,\r\n        cSSeed[0], // c\r\n        cSSeed[1], // s\r\n        cSSeed[2], // seed\r\n        uWitness,\r\n        cGammaWitness,\r\n        sHashWitness,\r\n        zInv\r\n      );\r\n      output = uint256(keccak256(abi.encode(VRF_RANDOM_OUTPUT_HASH_PREFIX, gamma)));\r\n    }\r\n}\r\n\r\n// File: contracts/VRFRequestIDBase.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract VRFRequestIDBase {\r\n\r\n  /**\r\n   * @notice returns the seed which is actually input to the VRF coordinator\r\n   *\r\n   * @dev To prevent repetition of VRF output due to repetition of the\r\n   * @dev user-supplied seed, that seed is combined in a hash with the\r\n   * @dev user-specific nonce, and the address of the consuming contract. The\r\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\r\n   * @dev the final seed, but the nonce does protect against repetition in\r\n   * @dev requests which are included in a single block.\r\n   *\r\n   * @param _userSeed VRF seed input provided by user\r\n   * @param _requester Address of the requesting contract\r\n   * @param _nonce User-specific nonce at the time of the request\r\n   */\r\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\r\n    address _requester, uint256 _nonce)\r\n    internal pure returns (uint256)\r\n  {\r\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the id for this request\r\n   * @param _keyHash The serviceAgreement ID to be used for this request\r\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\r\n   * @return The id for this request\r\n   *\r\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\r\n   * @dev contract, but the one generated by makeVRFInputSeed\r\n   */\r\n  function makeRequestId(\r\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\r\n  }\r\n}\r\n\r\n// File: contracts/VRFConsumerBase.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\n\r\n/** ****************************************************************************\r\n * @notice Interface for contracts using VRF randomness\r\n * *****************************************************************************\r\n * @dev PURPOSE\r\n *\r\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\r\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\r\n * @dev making his output up to suit himself. Reggie provides Vera a public key\r\n * @dev to which he knows the secret key. Each time Vera provides a seed to\r\n * @dev Reggie, he gives back a value which is computed completely\r\n * @dev deterministically from the seed and the secret key.\r\n *\r\n * @dev Reggie provides a proof by which Vera can verify that the output was\r\n * @dev correctly computed once Reggie tells it to her, but without that proof,\r\n * @dev the output is indistinguishable to her from a uniform random sample\r\n * @dev from the output space.\r\n *\r\n * @dev The purpose of this contract is to make it easy for unrelated contracts\r\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\r\n * @dev simple access to a verifiable source of randomness.\r\n * *****************************************************************************\r\n * @dev USAGE\r\n *\r\n * @dev Calling contracts must inherit from VRFConsumerInterface, and can\r\n * @dev initialize VRFConsumerInterface's attributes in their constructor as\r\n * @dev shown:\r\n *\r\n * @dev   contract VRFConsumer {\r\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\r\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\r\n * @dev         <initialization with other arguments goes here>\r\n * @dev       }\r\n * @dev   }\r\n *\r\n * @dev The oracle will have given you an ID for the VRF keypair they have\r\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\r\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\r\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\r\n * @dev want to generate randomness from.\r\n *\r\n * @dev Once the VRFCoordinator has received and validated the oracle's response\r\n * @dev to your request, it will call your contract's fulfillRandomness method.\r\n *\r\n * @dev The randomness argument to fulfillRandomness is the actual random value\r\n * @dev generated from your seed.\r\n *\r\n * @dev The requestId argument is generated from the keyHash and the seed by\r\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\r\n * @dev requests open, you can use the requestId to track which seed is\r\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\r\n * @dev details.\r\n *\r\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\r\n * @dev differ. (Which is critical to making unpredictable randomness! See the\r\n * @dev next section.)\r\n *\r\n * *****************************************************************************\r\n * @dev SECURITY CONSIDERATIONS\r\n *\r\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\r\n * @dev block in which the request is made, user-provided seeds have no impact\r\n * @dev on its economic security properties. They are only included for API\r\n * @dev compatability with previous versions of this contract.\r\n *\r\n * @dev Since the block hash of the block which contains the requestRandomness()\r\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\r\n * @dev miner could, in principle, fork the blockchain to evict the block\r\n * @dev containing the request, forcing the request to be included in a\r\n * @dev different block with a different hash, and therefore a different input\r\n * @dev to the VRF. However, such an attack would incur a substantial economic\r\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\r\n * @dev until it calls fulfillRandomness().\r\n */\r\nabstract contract VRFConsumerBase is VRFRequestIDBase {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n   * @notice fulfillRandomness handles the VRF response. Your contract must\r\n   * @notice implement it.\r\n   *\r\n   * @dev The VRFCoordinator expects a calling contract to have a method with\r\n   * @dev this signature, and will trigger it once it has verified the proof\r\n   * @dev associated with the randomness (It is triggered via a call to\r\n   * @dev rawFulfillRandomness, below.)\r\n   *\r\n   * @param requestId The Id initially returned by requestRandomness\r\n   * @param randomness the VRF output\r\n   */\r\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\r\n    internal virtual;\r\n\r\n  /**\r\n   * @notice requestRandomness initiates a request for VRF output given _seed\r\n   *\r\n   * @dev See \"SECURITY CONSIDERATIONS\" above for more information on _seed.\r\n   *\r\n   * @dev The fulfillRandomness method receives the output, once it's provided\r\n   * @dev by the Oracle, and verified by the vrfCoordinator.\r\n   *\r\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\r\n   * @dev the _fee must exceed the fee specified during registration of the\r\n   * @dev _keyHash.\r\n   *\r\n   * @param _keyHash ID of public key against which randomness is generated\r\n   * @param _fee The amount of LINK to send with the request\r\n   * @param _seed seed mixed into the input of the VRF\r\n   *\r\n   * @return requestId unique ID for this request\r\n   *\r\n   * @dev The returned requestId can be used to distinguish responses to *\r\n   * @dev concurrent requests. It is passed as the first argument to\r\n   * @dev fulfillRandomness.\r\n   */\r\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\r\n    public returns (bytes32 requestId)\r\n  {\r\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\r\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\r\n    // the hash of the block containing this request to obtain the seed/input\r\n    // which is finally passed to the VRF cryptographic machinery.\r\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\r\n    // nonces[_keyHash] must stay in sync with\r\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\r\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\r\n    // This provides protection against the user repeating their input\r\n    // seed, which would result in a predictable/duplicate output.\r\n    nonces[_keyHash] = nonces[_keyHash].add(1);\r\n    return makeRequestId(_keyHash, vRFSeed);\r\n  }\r\n\r\n  LinkTokenInterface immutable internal LINK;\r\n  address immutable private vrfCoordinator;\r\n\r\n  // Nonces for each VRF key from which randomness has been requested.\r\n  //\r\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\r\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) public nonces;\r\n  constructor(address _vrfCoordinator, address _link) public {\r\n    vrfCoordinator = _vrfCoordinator;\r\n    LINK = LinkTokenInterface(_link);\r\n  }\r\n\r\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\r\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\r\n  // the origin of the call\r\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\r\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\r\n    fulfillRandomness(requestId, randomness);\r\n  }\r\n}\r\n\r\n// File: contracts/VRFCoordinator.sol\r\n\r\npragma solidity 0.6.6;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title VRFCoordinator coordinates on-chain verifiable-randomness requests\r\n * @title with off-chain responses\r\n */\r\ncontract VRFCoordinator is VRF, VRFRequestIDBase {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  LinkTokenInterface internal LINK;\r\n  BlockHashStoreInterface internal blockHashStore;\r\n\r\n  constructor(address _link, address _blockHashStore) public {\r\n    LINK = LinkTokenInterface(_link);\r\n    blockHashStore = BlockHashStoreInterface(_blockHashStore);\r\n  }\r\n\r\n  struct Callback { // Tracks an ongoing request\r\n    address callbackContract; // Requesting contract, which will receive response\r\n    // Amount of LINK paid at request time. Total LINK = 1e9 * 1e18 < 2^96, so\r\n    // this representation is adequate, and saves a word of storage when this\r\n    // field follows the 160-bit callbackContract address.\r\n    uint96 randomnessFee;\r\n    // Commitment to seed passed to oracle by this contract, and the number of\r\n    // the block in which the request appeared. This is the keccak256 of the\r\n    // concatenation of those values. Storing this commitment saves a word of\r\n    // storage.\r\n    bytes32 seedAndBlockNum;\r\n  }\r\n\r\n  struct ServiceAgreement { // Tracks oracle commitments to VRF service\r\n    address vRFOracle; // Oracle committing to respond with VRF service\r\n    uint96 fee; // Minimum payment for oracle response. Total LINK=1e9*1e18<2^96\r\n    bytes32 jobID; // ID of corresponding chainlink job in oracle's DB\r\n  }\r\n\r\n  mapping(bytes32 /* (provingKey, seed) */ => Callback) public callbacks;\r\n  mapping(bytes32 /* provingKey */ => ServiceAgreement)\r\n    public serviceAgreements;\r\n  mapping(address /* oracle */ => uint256 /* LINK balance */)\r\n    public withdrawableTokens;\r\n  mapping(bytes32 /* provingKey */ => mapping(address /* consumer */ => uint256))\r\n    private nonces;\r\n\r\n  // The oracle only needs the jobID to look up the VRF, but specifying public\r\n  // key as well prevents a malicious oracle from inducing VRF outputs from\r\n  // another oracle by reusing the jobID.\r\n  event RandomnessRequest(\r\n    bytes32 keyHash,\r\n    uint256 seed,\r\n    bytes32 indexed jobID,\r\n    address sender,\r\n    uint256 fee,\r\n    bytes32 requestID);\r\n\r\n  event NewServiceAgreement(bytes32 keyHash, uint256 fee);\r\n\r\n  event RandomnessRequestFulfilled(bytes32 requestId, uint256 output);\r\n\r\n  /**\r\n   * @notice Commits calling address to serve randomness\r\n   * @param _fee minimum LINK payment required to serve randomness\r\n   * @param _oracle the address of the Chainlink node with the proving key and job\r\n   * @param _publicProvingKey public key used to prove randomness\r\n   * @param _jobID ID of the corresponding chainlink job in the oracle's db\r\n   */\r\n  function registerProvingKey(\r\n    uint256 _fee, address _oracle, uint256[2] calldata _publicProvingKey, bytes32 _jobID\r\n  )\r\n    external\r\n  {\r\n    bytes32 keyHash = hashOfKey(_publicProvingKey);\r\n    address oldVRFOracle = serviceAgreements[keyHash].vRFOracle;\r\n    require(oldVRFOracle == address(0), \"please register a new key\");\r\n    require(_oracle != address(0), \"_oracle must not be 0x0\");\r\n    serviceAgreements[keyHash].vRFOracle = _oracle;\r\n    serviceAgreements[keyHash].jobID = _jobID;\r\n    // Yes, this revert message doesn't fit in a word\r\n    require(_fee <= 1e9 ether,\r\n      \"you can't charge more than all the LINK in the world, greedy\");\r\n    serviceAgreements[keyHash].fee = uint96(_fee);\r\n    emit NewServiceAgreement(keyHash, _fee);\r\n  }\r\n\r\n  /**\r\n   * @notice Called by LINK.transferAndCall, on successful LINK transfer\r\n   *\r\n   * @dev To invoke this, use the requestRandomness method in VRFConsumerBase.\r\n   *\r\n   * @dev The VRFCoordinator will call back to the calling contract when the\r\n   * @dev oracle responds, on the method fulfillRandomness. See\r\n   * @dev VRFConsumerBase.fulfilRandomness for its signature. Your consuming\r\n   * @dev contract should inherit from VRFConsumerBase, and implement\r\n   * @dev fulfilRandomness.\r\n   *\r\n   * @param _sender address: who sent the LINK (must be a contract)\r\n   * @param _fee amount of LINK sent\r\n   * @param _data abi-encoded call to randomnessRequest\r\n   */\r\n  function onTokenTransfer(address _sender, uint256 _fee, bytes memory _data)\r\n    public\r\n    onlyLINK\r\n  {\r\n    (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\r\n    randomnessRequest(keyHash, seed, _fee, _sender);\r\n  }\r\n\r\n  /**\r\n   * @notice creates the chainlink request for randomness\r\n   *\r\n   * @param _keyHash ID of the VRF public key against which to generate output\r\n   * @param _consumerSeed Input to the VRF, from which randomness is generated\r\n   * @param _feePaid Amount of LINK sent with request. Must exceed fee for key\r\n   * @param _sender Requesting contract; to be called back with VRF output\r\n   *\r\n   * @dev _consumerSeed is mixed with key hash, sender address and nonce to\r\n   * @dev obtain preSeed, which is passed to VRF oracle, which mixes it with the\r\n   * @dev hash of the block containing this request, to compute the final seed.\r\n   *\r\n   * @dev The requestId used to store the request data is constructed from the\r\n   * @dev preSeed and keyHash.\r\n   */\r\n  function randomnessRequest(\r\n    bytes32 _keyHash,\r\n    uint256 _consumerSeed,\r\n    uint256 _feePaid,\r\n    address _sender\r\n  )\r\n    internal\r\n    sufficientLINK(_feePaid, _keyHash)\r\n  {\r\n    uint256 nonce = nonces[_keyHash][_sender];\r\n    uint256 preSeed = makeVRFInputSeed(_keyHash, _consumerSeed, _sender, nonce);\r\n    bytes32 requestId = makeRequestId(_keyHash, preSeed);\r\n    // Cryptographically guaranteed by preSeed including an increasing nonce\r\n    assert(callbacks[requestId].callbackContract == address(0));\r\n    callbacks[requestId].callbackContract = _sender;\r\n    assert(_feePaid < 1e27); // Total LINK fits in uint96\r\n    callbacks[requestId].randomnessFee = uint96(_feePaid);\r\n    callbacks[requestId].seedAndBlockNum = keccak256(abi.encodePacked(\r\n      preSeed, block.number));\r\n    emit RandomnessRequest(_keyHash, preSeed, serviceAgreements[_keyHash].jobID,\r\n      _sender, _feePaid, requestId);\r\n    nonces[_keyHash][_sender] = nonces[_keyHash][_sender].add(1);\r\n  }\r\n\r\n  // Offsets into fulfillRandomnessRequest's _proof of various values\r\n  //\r\n  // Public key. Skips byte array's length prefix.\r\n  uint256 public constant PUBLIC_KEY_OFFSET = 0x20;\r\n  // Seed is 7th word in proof, plus word for length, (6+1)*0x20=0xe0\r\n  uint256 public constant PRESEED_OFFSET = 0xe0;\r\n\r\n  /**\r\n   * @notice Called by the chainlink node to fulfill requests\r\n   *\r\n   * @param _proof the proof of randomness. Actual random output built from this\r\n   *\r\n   * @dev The structure of _proof corresponds to vrf.MarshaledOnChainResponse,\r\n   * @dev in the node source code. I.e., it is a vrf.MarshaledProof with the\r\n   * @dev seed replaced by the preSeed, followed by the hash of the requesting\r\n   * @dev block.\r\n   */\r\n  function fulfillRandomnessRequest(bytes memory _proof) public {\r\n    (bytes32 currentKeyHash, Callback memory callback, bytes32 requestId,\r\n     uint256 randomness) = getRandomnessFromProof(_proof);\r\n\r\n    // Pay oracle\r\n    address oadd = serviceAgreements[currentKeyHash].vRFOracle;\r\n    withdrawableTokens[oadd] = withdrawableTokens[oadd].add(\r\n      callback.randomnessFee);\r\n\r\n    // Forget request. Must precede callback (prevents reentrancy)\r\n    delete callbacks[requestId];\r\n    callBackWithRandomness(requestId, randomness, callback.callbackContract);\r\n\r\n    emit RandomnessRequestFulfilled(requestId, randomness);\r\n  }\r\n\r\n  function callBackWithRandomness(bytes32 requestId, uint256 randomness,\r\n    address consumerContract) internal {\r\n    // Dummy variable; allows access to method selector in next line. See\r\n    // https://github.com/ethereum/solidity/issues/3506#issuecomment-553727797\r\n    VRFConsumerBase v;\r\n    bytes memory resp = abi.encodeWithSelector(\r\n      v.rawFulfillRandomness.selector, requestId, randomness);\r\n    // The bound b here comes from https://eips.ethereum.org/EIPS/eip-150. The\r\n    // actual gas available to the consuming contract will be b-floor(b/64).\r\n    // This is chosen to leave the consuming contract ~200k gas, after the cost\r\n    // of the call itself.\r\n    uint256 b = 206000;\r\n    require(gasleft() >= b, \"not enough gas for consumer\");\r\n    // A low-level call is necessary, here, because we don't want the consuming\r\n    // contract to be able to revert this execution, and thus deny the oracle\r\n    // payment for a valid randomness response. This also necessitates the above\r\n    // check on the gasleft, as otherwise there would be no indication if the\r\n    // callback method ran out of gas.\r\n    //\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success,) = consumerContract.call(resp);\r\n    // Avoid unused-local-variable warning. (success is only present to prevent\r\n    // a warning that the return value of consumerContract.call is unused.)\r\n    (success);\r\n  }\r\n\r\n  function getRandomnessFromProof(bytes memory _proof)\r\n    internal view returns (bytes32 currentKeyHash, Callback memory callback,\r\n      bytes32 requestId, uint256 randomness) {\r\n    // blockNum follows proof, which follows length word (only direct-number\r\n    // constants are allowed in assembly, so have to compute this in code)\r\n    uint256 BLOCKNUM_OFFSET = 0x20 + PROOF_LENGTH;\r\n    // _proof.length skips the initial length word, so not including the\r\n    // blocknum in this length check balances out.\r\n    require(_proof.length == BLOCKNUM_OFFSET, \"wrong proof length\");\r\n    uint256[2] memory publicKey;\r\n    uint256 preSeed;\r\n    uint256 blockNum;\r\n    assembly { // solhint-disable-line no-inline-assembly\r\n      publicKey := add(_proof, PUBLIC_KEY_OFFSET)\r\n      preSeed := mload(add(_proof, PRESEED_OFFSET))\r\n      blockNum := mload(add(_proof, BLOCKNUM_OFFSET))\r\n    }\r\n    currentKeyHash = hashOfKey(publicKey);\r\n    requestId = makeRequestId(currentKeyHash, preSeed);\r\n    callback = callbacks[requestId];\r\n    require(callback.callbackContract != address(0), \"no corresponding request\");\r\n    require(callback.seedAndBlockNum == keccak256(abi.encodePacked(preSeed,\r\n      blockNum)), \"wrong preSeed or block num\");\r\n\r\n    bytes32 blockHash = blockhash(blockNum);\r\n    if (blockHash == bytes32(0)) {\r\n      blockHash = blockHashStore.getBlockhash(blockNum);\r\n      require(blockHash != bytes32(0), \"please prove blockhash\");\r\n    }\r\n    // The seed actually used by the VRF machinery, mixing in the blockhash\r\n    uint256 actualSeed = uint256(keccak256(abi.encodePacked(preSeed, blockHash)));\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly { // Construct the actual proof from the remains of _proof\r\n      mstore(add(_proof, PRESEED_OFFSET), actualSeed)\r\n      mstore(_proof, PROOF_LENGTH)\r\n    }\r\n    randomness = VRF.randomValueFromVRFProof(_proof); // Reverts on failure\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the oracle operator to withdraw their LINK\r\n   * @param _recipient is the address the funds will be sent to\r\n   * @param _amount is the amount of LINK transferred from the Coordinator contract\r\n   */\r\n  function withdraw(address _recipient, uint256 _amount)\r\n    external\r\n    hasAvailableFunds(_amount)\r\n  {\r\n    withdrawableTokens[msg.sender] = withdrawableTokens[msg.sender].sub(_amount);\r\n    assert(LINK.transfer(_recipient, _amount));\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the serviceAgreements key associated with this public key\r\n   * @param _publicKey the key to return the address for\r\n   */\r\n  function hashOfKey(uint256[2] memory _publicKey) public pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(_publicKey));\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if amount is not at least what was agreed upon in the service agreement\r\n   * @param _feePaid The payment for the request\r\n   * @param _keyHash The key which the request is for\r\n   */\r\n  modifier sufficientLINK(uint256 _feePaid, bytes32 _keyHash) {\r\n    require(_feePaid >= serviceAgreements[_keyHash].fee, \"Below agreed payment\");\r\n    _;\r\n  }\r\n\r\n/**\r\n   * @dev Reverts if not sent from the LINK token\r\n   */\r\n  modifier onlyLINK() {\r\n    require(msg.sender == address(LINK), \"Must use LINK token\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if amount requested is greater than withdrawable balance\r\n   * @param _amount The given amount to compare to `withdrawableTokens`\r\n   */\r\n  modifier hasAvailableFunds(uint256 _amount) {\r\n    require(withdrawableTokens[msg.sender] >= _amount, \"can't withdraw more than balance\");\r\n    _;\r\n  }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_blockHashStore\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"NewServiceAgreement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"jobID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestID\",\"type\":\"bytes32\"}],\"name\":\"RandomnessRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"name\":\"RandomnessRequestFulfilled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRESEED_OFFSET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROOF_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUBLIC_KEY_OFFSET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"callbacks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"callbackContract\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"randomnessFee\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"seedAndBlockNum\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"fulfillRandomnessRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"_publicKey\",\"type\":\"uint256[2]\"}],\"name\":\"hashOfKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256[2]\",\"name\":\"_publicProvingKey\",\"type\":\"uint256[2]\"},{\"internalType\":\"bytes32\",\"name\":\"_jobID\",\"type\":\"bytes32\"}],\"name\":\"registerProvingKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"serviceAgreements\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vRFOracle\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"fee\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"jobID\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VRFCoordinator", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b0897686c545045afc77cf20ec7a532e3120e0f1000000000000000000000000683be5e11c1cdce9e63522f45223f47250d71778", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1881f125e9a7356d8ba82f7cb4affab38cc35ea01f2ee0cdef7101b1c52bc5f3"}