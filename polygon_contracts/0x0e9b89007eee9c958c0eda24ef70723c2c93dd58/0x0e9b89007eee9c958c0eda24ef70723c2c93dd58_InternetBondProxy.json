{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/contracts/InternetBondProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.6;\\n\\nimport \\\"./interfaces/ICrossChainBridge.sol\\\";\\n\\ncontract InternetBondProxy {\\n\\n    bytes32 private constant BEACON_SLOT = bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1);\\n\\n    fallback() external {\\n        address bridge;\\n        bytes32 slot = BEACON_SLOT;\\n        assembly {\\n            bridge := sload(slot)\\n        }\\n        address impl = ICrossChainBridge(bridge).getBondImplementation();\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 {revert(0, returndatasize())}\\n            default {return (0, returndatasize())}\\n        }\\n    }\\n\\n    function setBeacon(address newBeacon) external {\\n        address beacon;\\n        bytes32 slot = BEACON_SLOT;\\n        assembly {\\n            beacon := sload(slot)\\n        }\\n        require(beacon == address(0x00));\\n        assembly {\\n            sstore(slot, newBeacon)\\n        }\\n    }\\n}\\n\\nlibrary InternetBondProxyUtils {\\n\\n    bytes constant internal INTERNET_BOND_PROXY_BYTECODE = hex\\\"608060405234801561001057600080fd5b50610215806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063d42afb56146100fd575b60008061005960017fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d516101a2565b60001b9050805491506000826001600160a01b0316631626425c6040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561009f57600080fd5b505af11580156100b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100d79190610185565b90503660008037600080366000845af43d6000803e8080156100f8573d6000f35b3d6000fd5b61011061010b366004610161565b610112565b005b60008061014060017fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d516101a2565b8054925090506001600160a01b0382161561015a57600080fd5b9190915550565b60006020828403121561017357600080fd5b813561017e816101c7565b9392505050565b60006020828403121561019757600080fd5b815161017e816101c7565b6000828210156101c257634e487b7160e01b600052601160045260246000fd5b500390565b6001600160a01b03811681146101dc57600080fd5b5056fea2646970667358221220d283edebb1e56b63c1cf809c7a7219bbf056c367c289dabb51fdba5f71cdf44c64736f6c63430008060033\\\";\\n\\n    bytes32 constant internal INTERNET_BOND_PROXY_HASH = keccak256(INTERNET_BOND_PROXY_BYTECODE);\\n\\n    bytes4 constant internal SET_META_DATA_SIG = bytes4(keccak256(\\\"initAndObtainOwnership(bytes32,bytes32,uint256,address,address,bool)\\\"));\\n    bytes4 constant internal SET_BEACON_SIG = bytes4(keccak256(\\\"setBeacon(address)\\\"));\\n\\n    function deployInternetBondProxy(address bridge, bytes32 salt, ICrossChainBridge.Metadata memory metaData, address ratioFeed) internal returns (address) {\\n        /* lets concat bytecode with constructor parameters */\\n        bytes memory bytecode = INTERNET_BOND_PROXY_BYTECODE;\\n        /* deploy new contract and store contract address in result variable */\\n        address result;\\n        assembly {\\n            result := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(result != address(0x00), \\\"deploy failed\\\");\\n        /* setup impl */\\n        (bool success, bytes memory returnValue) = result.call(abi.encodePacked(SET_BEACON_SIG, abi.encode(bridge)));\\n        require(success, string(abi.encodePacked(\\\"setBeacon failed: \\\", returnValue)));\\n        /* setup meta data */\\n        bytes memory inputData = new bytes(0xc4);\\n        bool isRebasing = metaData.bondMetadata[1] == bytes1(0x01);\\n        bytes4 selector = SET_META_DATA_SIG;\\n        assembly {\\n            mstore(add(inputData, 0x20), selector)\\n            mstore(add(inputData, 0x24), mload(metaData))\\n            mstore(add(inputData, 0x44), mload(add(metaData, 0x20)))\\n            mstore(add(inputData, 0x64), mload(add(metaData, 0x40)))\\n            mstore(add(inputData, 0x84), mload(add(metaData, 0x60)))\\n            mstore(add(inputData, 0xa4), ratioFeed)\\n            mstore(add(inputData, 0xc4), isRebasing)\\n        }\\n        (success, returnValue) = result.call(inputData);\\n        require(success, string(abi.encodePacked(\\\"set metadata failed: \\\", returnValue)));\\n        /* return generated contract address */\\n        return result;\\n    }\\n\\n    function internetBondProxyAddress(address deployer, bytes32 salt) internal pure returns (address) {\\n        bytes32 bytecodeHash = keccak256(INTERNET_BOND_PROXY_BYTECODE);\\n        bytes32 hash = keccak256(abi.encodePacked(uint8(0xff), address(deployer), salt, bytecodeHash));\\n        return address(bytes20(hash << 96));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/ICrossChainBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.6;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\ninterface ICrossChainBridge {\\n\\n    event ContractAllowed(address contractAddress, uint256 toChain);\\n    event ContractDisallowed(address contractAddress, uint256 toChain);\\n    event ConsensusChanged(address consensusAddress);\\n    event TokenImplementationChanged(address consensusAddress);\\n    event BondImplementationChanged(address consensusAddress);\\n\\n    struct Metadata {\\n        bytes32 symbol;\\n        bytes32 name;\\n        uint256 originChain;\\n        address originAddress;\\n        bytes32 bondMetadata; // encoded metadata version, bond type\\n    }\\n\\n    event DepositLocked(\\n        uint256 chainId,\\n        address indexed fromAddress,\\n        address indexed toAddress,\\n        address fromToken,\\n        address toToken,\\n        uint256 totalAmount,\\n        Metadata metadata\\n    );\\n    event DepositBurned(\\n        uint256 chainId,\\n        address indexed fromAddress,\\n        address indexed toAddress,\\n        address fromToken,\\n        address toToken,\\n        uint256 totalAmount,\\n        Metadata metadata,\\n        address originToken\\n    );\\n\\n    event WithdrawMinted(\\n        bytes32 receiptHash,\\n        address indexed fromAddress,\\n        address indexed toAddress,\\n        address fromToken,\\n        address toToken,\\n        uint256 totalAmount\\n    );\\n    event WithdrawUnlocked(\\n        bytes32 receiptHash,\\n        address indexed fromAddress,\\n        address indexed toAddress,\\n        address fromToken,\\n        address toToken,\\n        uint256 totalAmount\\n    );\\n\\n    enum InternetBondType {\\n        NOT_BOND,\\n        REBASING_BOND,\\n        NONREBASING_BOND\\n    }\\n\\n    function isPeggedToken(address toToken) external returns (bool);\\n\\n    function deposit(uint256 toChain, address toAddress) payable external;\\n\\n    function deposit(address fromToken, uint256 toChain, address toAddress, uint256 amount) external;\\n\\n    function withdraw(bytes calldata encodedProof, bytes calldata rawReceipt, bytes calldata receiptRootSignature) external;\\n\\n    function factoryPeggedToken(uint256 fromChain, Metadata calldata metaData) external;\\n\\n    function factoryPeggedBond(uint256 fromChain, Metadata calldata metaData) external;\\n\\n    function getTokenImplementation() external returns (address);\\n\\n    function getBondImplementation() external returns (address);\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IERC20Mintable {\\n\\n    function mint(address account, uint256 amount) external;\\n\\n    function burn(address account, uint256 amount) external;\\n}\\n\\ninterface IERC20Pegged {\\n\\n    function getOrigin() external view returns (uint256, address);\\n}\\n\\ninterface IERC20Extra {\\n\\n    function name() external returns (string memory);\\n\\n    function decimals() external returns (uint8);\\n\\n    function symbol() external returns (string memory);\\n}\\n\\ninterface IERC20InternetBond {\\n\\n    function ratio() external view returns (uint256);\\n\\n    function isRebasing() external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBeacon\",\"type\":\"address\"}],\"name\":\"setBeacon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "InternetBondProxy", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x31be0fa706e391a88c3a09cc13112bd55e0887f5", "SwarmSource": ""}