{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/EntryPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"./interfaces/IWallet.sol\\\";\\nimport \\\"./interfaces/IPaymaster.sol\\\";\\nimport \\\"./interfaces/ICreate2Deployer.sol\\\";\\nimport \\\"./StakeManager.sol\\\";\\nimport \\\"./lib/UserOperation.sol\\\";\\n\\n/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\ncontract EntryPoint is StakeManager {\\n    using UserOperationLib for UserOperation;\\n\\n    enum PaymentMode {\\n        paymasterDeposit, // if paymaster is set, use paymaster's deposit to pay.\\n        walletDeposit // pay with wallet deposit.\\n    }\\n\\n    address public immutable create2factory;\\n\\n    /***\\n     * An event emitted after each successful request\\n     * @param requestId - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request\\n     * @param actualGasCost - the total cost (in gas) of this request.\\n     * @param actualGasPrice - the actual gas price the sender agreed to pay.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     */\\n    event UserOperationEvent(\\n        bytes32 indexed requestId,\\n        address indexed sender,\\n        address indexed paymaster,\\n        uint256 nonce,\\n        uint256 actualGasCost,\\n        uint256 actualGasPrice,\\n        bool success\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param requestId the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(\\n        bytes32 indexed requestId,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param paymaster - if paymaster.validatePaymasterUserOp fails,\\n     *       this will be the paymaster's address. if validateUserOp failed,\\n     *       this value will be zero (since it failed before accessing the paymaster)\\n     *  @param reason - revert reason\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of wallet/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, address paymaster, string reason);\\n\\n    /**\\n     * @param _create2factory - contract to \\\"create2\\\" wallets\\n     *      (not the EntryPoint itself, so that the EntryPoint can be upgraded)\\n     * @param _paymasterStake - minimum required locked stake for a paymaster\\n     * @param _unstakeDelaySec - minimum time (in seconds) a paymaster stake must be locked\\n     */\\n    constructor(\\n        address _create2factory,\\n        uint256 _paymasterStake,\\n        uint32 _unstakeDelaySec\\n    ) StakeManager(_paymasterStake, _unstakeDelaySec) {\\n        require(_create2factory != address(0), \\\"invalid create2factory\\\");\\n        require(_unstakeDelaySec > 0, \\\"invalid unstakeDelay\\\");\\n        require(_paymasterStake > 0, \\\"invalid paymasterStake\\\");\\n        create2factory = _create2factory;\\n    }\\n\\n    /**\\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\\n     * @param beneficiary the address to receive the fees\\n     * @param amount amount to transfer.\\n     */\\n    function _compensate(address payable beneficiary, uint256 amount) internal {\\n        require(beneficiary != address(0), \\\"invalid beneficiary\\\");\\n        (bool success, ) = beneficiary.call{value: amount}(\\\"\\\");\\n        require(success);\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public {\\n        uint256 opslen = ops.length;\\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\\n        unchecked {\\n            for (uint256 i = 0; i < opslen; i++) {\\n                uint256 preGas = gasleft();\\n                UserOperation calldata op = ops[i];\\n\\n                bytes memory context;\\n                uint256 contextOffset;\\n                bytes32 requestId = getRequestId(op);\\n                uint256 prefund;\\n                PaymentMode paymentMode;\\n                (prefund, paymentMode, context) = _validatePrepayment(i, op, requestId);\\n                assembly {\\n                    contextOffset := context\\n                }\\n                opInfos[i] = UserOpInfo(\\n                    requestId,\\n                    prefund,\\n                    paymentMode,\\n                    contextOffset,\\n                    preGas - gasleft() + op.preVerificationGas\\n                );\\n            }\\n            uint256 collected = 0;\\n\\n            for (uint256 i = 0; i < ops.length; i++) {\\n                uint256 preGas = gasleft();\\n                UserOperation calldata op = ops[i];\\n                UserOpInfo memory opInfo = opInfos[i];\\n                uint256 contextOffset = opInfo.contextOffset;\\n                bytes memory context;\\n                assembly {\\n                    context := contextOffset\\n                }\\n\\n                try this.innerHandleOp(op, opInfo, context) returns (uint256 _actualGasCost) {\\n                    collected += _actualGasCost;\\n                } catch {\\n                    uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\\n                    collected += _handlePostOp(i, IPaymaster.PostOpMode.postOpReverted, op, opInfo, context, actualGas);\\n                }\\n            }\\n            _compensate(beneficiary, collected);\\n        } //unchecked\\n    }\\n\\n    struct UserOpInfo {\\n        bytes32 requestId;\\n        uint256 prefund;\\n        PaymentMode paymentMode;\\n        uint256 contextOffset;\\n        uint256 preOpGas;\\n    }\\n\\n    /**\\n     * inner function to handle a UserOperation.\\n     * Must be declared \\\"external\\\" to open a call context, but it can only be called by handleOps.\\n     */\\n    function innerHandleOp(\\n        UserOperation calldata op,\\n        UserOpInfo calldata opInfo,\\n        bytes calldata context\\n    ) external returns (uint256 actualGasCost) {\\n        uint256 preGas = gasleft();\\n        require(msg.sender == address(this));\\n\\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\\n        if (op.callData.length > 0) {\\n            (bool success, bytes memory result) = address(op.getSender()).call{gas: op.callGas}(op.callData);\\n            if (!success) {\\n                if (result.length > 0) {\\n                    emit UserOperationRevertReason(opInfo.requestId, op.getSender(), op.nonce, result);\\n                }\\n                mode = IPaymaster.PostOpMode.opReverted;\\n            }\\n        }\\n\\n        unchecked {\\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\\n            /**\\n             * note: opIndex is ignored\\n             * (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\\n             */\\n            return _handlePostOp(0, mode, op, opInfo, context, actualGas);\\n        }\\n    }\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getRequestId(UserOperation calldata userOp) public view returns (bytes32) {\\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\\n    }\\n\\n    /**\\n     * Simulate a call to wallet.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * Validation succeeds if the call doesn't revert.\\n     * @dev The node must also verify it doesn't use banned opcodes,\\n     *      and that it doesn't reference storage outside the wallet's data.\\n     *      In order to split the running opcodes of the wallet (validateUserOp)\\n     *      from the paymaster's validatePaymasterUserOp,\\n     *      it should look for the NUMBER opcode at depth=1 (which itself is a banned opcode)\\n     * @return preOpGas total gas used by validation (including contract creation)\\n     * @return prefund the amount the wallet had to prefund (zero in case a paymaster pays)\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external returns (uint256 preOpGas, uint256 prefund) {\\n        uint256 preGas = gasleft();\\n\\n        bytes32 requestId = getRequestId(userOp);\\n        (prefund, , ) = _validatePrepayment(0, userOp, requestId);\\n        preOpGas = preGas - gasleft() + userOp.preVerificationGas;\\n        require(msg.sender == address(0), \\\"must be called off-chain with from=zero-addr\\\");\\n    }\\n\\n    function _getPaymentInfo(UserOperation calldata userOp)\\n        internal\\n        view\\n        returns (uint256 requiredPrefund, PaymentMode paymentMode)\\n    {\\n        requiredPrefund = userOp.requiredPreFund();\\n        if (userOp.hasPaymaster()) {\\n            paymentMode = PaymentMode.paymasterDeposit;\\n        } else {\\n            paymentMode = PaymentMode.walletDeposit;\\n        }\\n    }\\n\\n    // create the sender's contract if needed.\\n    function _createSenderIfNeeded(UserOperation calldata op) internal {\\n        if (op.initCode.length != 0) {\\n            // note that we're still under the gas limit of validate, so probably\\n            // this create2 creates a proxy account.\\n            // @dev initCode must be unique (e.g. contains the signer address), to make sure\\n            //   it can only be executed from the entryPoint, and called with its initialization code (callData)\\n            address sender1 = ICreate2Deployer(create2factory).deploy(op.initCode, bytes32(op.nonce));\\n            require(sender1 != address(0), \\\"create2 failed\\\");\\n            require(sender1 == op.getSender(), \\\"sender doesn't match create2 address\\\");\\n        }\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     * @param salt the salt parameter, to be passed as \\\"nonce\\\" in the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode, uint256 salt) public view returns (address) {\\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(create2factory), salt, keccak256(initCode)));\\n\\n        // NOTE: cast last 20 bytes of hash to address\\n        return address(uint160(uint256(hash)));\\n    }\\n\\n    /**\\n     * call wallet.validateUserOp.\\n     * revert (with FailedOp) in case validateUserOp reverts, or wallet didn't send required prefund.\\n     * decrement wallet's deposit if needed\\n     */\\n    function _validateWalletPrepayment(\\n        uint256 opIndex,\\n        UserOperation calldata op,\\n        bytes32 requestId,\\n        uint256 requiredPrefund,\\n        PaymentMode paymentMode\\n    ) internal returns (uint256 gasUsedByValidateWalletPrepayment) {\\n        unchecked {\\n            uint256 preGas = gasleft();\\n            _createSenderIfNeeded(op);\\n            uint256 missingWalletFunds = 0;\\n            address sender = op.getSender();\\n            if (paymentMode != PaymentMode.paymasterDeposit) {\\n                uint256 bal = balanceOf(sender);\\n                missingWalletFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\\n            }\\n            // solhint-disable-next-line no-empty-blocks\\n            try\\n                IWallet(sender).validateUserOp{gas: op.verificationGas}(op, requestId, missingWalletFunds)\\n            {} catch Error(string memory revertReason) {\\n                revert FailedOp(opIndex, address(0), revertReason);\\n            } catch {\\n                revert FailedOp(opIndex, address(0), \\\"\\\");\\n            }\\n            if (paymentMode != PaymentMode.paymasterDeposit) {\\n                DepositInfo storage senderInfo = deposits[sender];\\n                uint256 deposit = senderInfo.deposit;\\n                if (requiredPrefund > deposit) {\\n                    revert FailedOp(opIndex, address(0), \\\"wallet didn't pay prefund\\\");\\n                }\\n                senderInfo.deposit = uint112(deposit - requiredPrefund);\\n            }\\n            gasUsedByValidateWalletPrepayment = preGas - gasleft();\\n        }\\n    }\\n\\n    /**\\n     * in case the request has a paymaster:\\n     * validate paymaster is staked and has enough deposit.\\n     * call paymaster.validatePaymasterUserOp.\\n     * revert with proper FailedOp in case paymaster reverts.\\n     * decrement paymaster's deposit\\n     */\\n    function _validatePaymasterPrepayment(\\n        uint256 opIndex,\\n        UserOperation calldata op,\\n        bytes32 requestId,\\n        uint256 requiredPreFund,\\n        uint256 gasUsedByValidateWalletPrepayment\\n    ) internal returns (bytes memory context) {\\n        unchecked {\\n            address paymaster = op.paymaster;\\n            DepositInfo storage paymasterInfo = deposits[paymaster];\\n            uint256 deposit = paymasterInfo.deposit;\\n            bool staked = paymasterInfo.staked;\\n            if (!staked) {\\n                revert FailedOp(opIndex, paymaster, \\\"not staked\\\");\\n            }\\n            if (deposit < requiredPreFund) {\\n                revert FailedOp(opIndex, paymaster, \\\"paymaster deposit too low\\\");\\n            }\\n            paymasterInfo.deposit = uint112(deposit - requiredPreFund);\\n            uint256 gas = op.verificationGas - gasUsedByValidateWalletPrepayment;\\n            try IPaymaster(paymaster).validatePaymasterUserOp{gas: gas}(op, requestId, requiredPreFund) returns (\\n                bytes memory _context\\n            ) {\\n                context = _context;\\n            } catch Error(string memory revertReason) {\\n                revert FailedOp(opIndex, paymaster, revertReason);\\n            } catch {\\n                revert FailedOp(opIndex, paymaster, \\\"\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * validate wallet and paymaster (if defined).\\n     * also make sure total validation doesn't exceed verificationGas\\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\\n     */\\n    function _validatePrepayment(\\n        uint256 opIndex,\\n        UserOperation calldata userOp,\\n        bytes32 requestId\\n    )\\n        private\\n        returns (\\n            uint256 requiredPreFund,\\n            PaymentMode paymentMode,\\n            bytes memory context\\n        )\\n    {\\n        uint256 preGas = gasleft();\\n        uint256 maxGasValues = userOp.preVerificationGas |\\n            userOp.verificationGas |\\n            userOp.callGas |\\n            userOp.maxFeePerGas |\\n            userOp.maxPriorityFeePerGas;\\n        require(maxGasValues <= type(uint120).max, \\\"gas values overflow\\\");\\n        uint256 gasUsedByValidateWalletPrepayment;\\n        (requiredPreFund, paymentMode) = _getPaymentInfo(userOp);\\n\\n        (gasUsedByValidateWalletPrepayment) = _validateWalletPrepayment(\\n            opIndex,\\n            userOp,\\n            requestId,\\n            requiredPreFund,\\n            paymentMode\\n        );\\n\\n        //a \\\"marker\\\" where wallet opcode validation is done and paymaster opcode validation is about to start\\n        // (used only by off-chain simulateValidation)\\n        uint256 marker = block.number;\\n        (marker);\\n        if (paymentMode == PaymentMode.paymasterDeposit) {\\n            (context) = _validatePaymasterPrepayment(\\n                opIndex,\\n                userOp,\\n                requestId,\\n                requiredPreFund,\\n                gasUsedByValidateWalletPrepayment\\n            );\\n        } else {\\n            context = \\\"\\\";\\n        }\\n        unchecked {\\n            uint256 gasUsed = preGas - gasleft();\\n\\n            if (userOp.verificationGas < gasUsed) {\\n                revert FailedOp(opIndex, userOp.paymaster, \\\"Used more than verificationGas\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * process post-operation.\\n     * called just after the callData is executed.\\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\\n     * the excess amount is refunded to the wallet (or paymaster - if it is was used in the request)\\n     * @param opIndex index in the batch\\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\\n     * @param op the user operation\\n     * @param opInfo info collected during validation\\n     * @param context the context returned in validatePaymasterUserOp\\n     * @param actualGas the gas used so far by this user operation\\n     */\\n    function _handlePostOp(\\n        uint256 opIndex,\\n        IPaymaster.PostOpMode mode,\\n        UserOperation calldata op,\\n        UserOpInfo memory opInfo,\\n        bytes memory context,\\n        uint256 actualGas\\n    ) private returns (uint256 actualGasCost) {\\n        uint256 preGas = gasleft();\\n        uint256 gasPrice = UserOperationLib.gasPrice(op);\\n        unchecked {\\n            address refundAddress;\\n\\n            address paymaster = op.paymaster;\\n            if (paymaster == address(0)) {\\n                refundAddress = op.getSender();\\n            } else {\\n                refundAddress = paymaster;\\n                if (context.length > 0) {\\n                    actualGasCost = actualGas * gasPrice;\\n                    if (mode != IPaymaster.PostOpMode.postOpReverted) {\\n                        IPaymaster(paymaster).postOp{gas: op.verificationGas}(mode, context, actualGasCost);\\n                    } else {\\n                        // solhint-disable-next-line no-empty-blocks\\n                        try\\n                            IPaymaster(paymaster).postOp{gas: op.verificationGas}(mode, context, actualGasCost)\\n                        {} catch Error(string memory reason) {\\n                            revert FailedOp(opIndex, paymaster, reason);\\n                        } catch {\\n                            revert FailedOp(opIndex, paymaster, \\\"postOp revert\\\");\\n                        }\\n                    }\\n                }\\n            }\\n            actualGas += preGas - gasleft();\\n            actualGasCost = actualGas * gasPrice;\\n            if (opInfo.prefund < actualGasCost) {\\n                revert FailedOp(opIndex, paymaster, \\\"prefund below actualGasCost\\\");\\n            }\\n            uint256 refund = opInfo.prefund - actualGasCost;\\n            internalIncrementDeposit(refundAddress, refund);\\n            bool success = mode == IPaymaster.PostOpMode.opSucceeded;\\n            emit UserOperationEvent(\\n                opInfo.requestId,\\n                op.getSender(),\\n                op.paymaster,\\n                op.nonce,\\n                actualGasCost,\\n                gasPrice,\\n                success\\n            );\\n        } // unchecked\\n    }\\n\\n    /**\\n     * return the storage cells used internally by the EntryPoint for this sender address.\\n     * During `simulateValidation`, allow these storage cells to be accessed\\n     *  (that is, a wallet/paymaster are allowed to access their own deposit balance on the\\n     *  EntryPoint's storage, but no other account)\\n     */\\n    function getSenderStorage(address sender) external view returns (uint256[] memory senderStorageCells) {\\n        uint256 cell;\\n        DepositInfo storage info = deposits[sender];\\n\\n        assembly {\\n            cell := info.slot\\n        }\\n        senderStorageCells = new uint256[](1);\\n        senderStorageCells[0] = cell;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICreate2Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.12;\\n\\n/**\\n * create2-based deployer (eip-2470)\\n */\\ninterface ICreate2Deployer {\\n    function deploy(bytes memory initCode, bytes32 salt) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"../lib/UserOperation.sol\\\";\\n\\n/**\\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\\n */\\ninterface IPaymaster {\\n    /**\\n     * payment validation: check if paymaster agree to pay (using its stake)\\n     * revert to reject this request.\\n     * actual payment is done after postOp is called, by deducting actual call cost form the paymaster's stake.\\n     * @param userOp the user operation\\n     * @param requestId hash of the user's request data.\\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\\n     * @return context value to send to a postOp\\n     *  zero length to signify postOp is not required.\\n     */\\n    function validatePaymasterUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 requestId,\\n        uint256 maxCost\\n    ) external view returns (bytes memory context);\\n\\n    /**\\n     * post-operation handler.\\n     * Must verify sender is the entryPoint\\n     * @param mode enum with the following options:\\n     *      opSucceeded - user operation succeeded.\\n     *      opReverted  - user op reverted. still has to pay for gas.\\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\\n     * @param context - the context value returned by validatePaymasterUserOp\\n     * @param actualGasCost - actual gas used so far (without this postOp call).\\n     */\\n    function postOp(\\n        PostOpMode mode,\\n        bytes calldata context,\\n        uint256 actualGasCost\\n    ) external;\\n\\n    enum PostOpMode {\\n        opSucceeded, // user op succeeded\\n        opReverted, // user op reverted. still has to pay for gas.\\n        postOpReverted\\n        //user op succeeded, but caused postOp to revert. Now its a 2nd call, after user's op was deliberately reverted.\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"../lib/UserOperation.sol\\\";\\n\\ninterface IWallet {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp the operation that is about to be executed.\\n     * @param requestId hash of the user's request data. can be used as the basis for signature.\\n     * @param missingWalletFunds missing funds on the wallet's deposit in the entrypoint.\\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     *      The excess is left as a deposit in the entrypoint, for future calls.\\n     *      can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\"\\n     *      In case there is a paymaster in the request (or the current deposit is high enough),\\n     *      this value will be zero.\\n     */\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 requestId,\\n        uint256 missingWalletFunds\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/UserOperation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request\\n * @param nonce unique value the sender uses to verify it is not a replay.\\n * @param initCode if set, the account contract will be created by this constructor\\n * @param callData the method call to execute on this account.\\n * @param verificationGas gas used for validateUserOp and validatePaymasterUserOp\\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid.\\n *        Covers batch overhead.\\n * @param maxFeePerGas same as EIP-1559 gas parameter\\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter\\n * @param paymaster if set, the paymaster will pay for the transaction instead of the sender\\n * @param paymasterData extra data used by the paymaster for validation\\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct UserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    uint256 callGas;\\n    uint256 verificationGas;\\n    uint256 preVerificationGas;\\n    uint256 maxFeePerGas;\\n    uint256 maxPriorityFeePerGas;\\n    address paymaster;\\n    bytes paymasterData;\\n    bytes signature;\\n}\\n\\nlibrary UserOperationLib {\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/miner might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n        unchecked {\\n            uint256 maxFeePerGas = userOp.maxFeePerGas;\\n            uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    function requiredGas(UserOperation calldata userOp) internal pure returns (uint256) {\\n        unchecked {\\n            //when using a Paymaster, the verificationGas is used also to cover the postOp call.\\n            // our security model might call postOp eventually twice\\n            uint256 mul = hasPaymaster(userOp) ? 3 : 1;\\n            return userOp.callGas + userOp.verificationGas * mul + userOp.preVerificationGas;\\n        }\\n    }\\n\\n    function requiredPreFund(UserOperation calldata userOp) internal view returns (uint256 prefund) {\\n        unchecked {\\n            return requiredGas(userOp) * gasPrice(userOp);\\n        }\\n    }\\n\\n    function hasPaymaster(UserOperation calldata userOp) internal pure returns (bool) {\\n        return userOp.paymaster != address(0);\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        //lighter signature scheme. must match UserOp.ts#packUserOp\\n        bytes calldata sig = userOp.signature;\\n        // copy directly the userOp from calldata up to (but not including) the signature.\\n        // this encoding depends on the ABI encoding of calldata, but is much lighter to copy\\n        // than referencing each field separately.\\n        assembly {\\n            let ofs := userOp\\n            let len := sub(sub(sig.offset, ofs), 32)\\n            ret := mload(0x40)\\n            mstore(0x40, add(ret, add(len, 32)))\\n            mstore(ret, len)\\n            calldatacopy(add(ret, 32), ofs, len)\\n        }\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable not-rely-on-time */\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or a wallet)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by a paymaster.\\n */\\nabstract contract StakeManager {\\n    /**\\n     * minimum time (in seconds) required to lock a paymaster stake before it can be withdraw.\\n     */\\n    uint32 public immutable unstakeDelaySec;\\n\\n    /**\\n     * minimum value required to stake for a paymaster\\n     */\\n    uint256 public immutable paymasterStake;\\n\\n    constructor(uint256 _paymasterStake, uint32 _unstakeDelaySec) {\\n        unstakeDelaySec = _unstakeDelaySec;\\n        paymasterStake = _paymasterStake;\\n    }\\n\\n    event Deposited(address indexed account, uint256 totalDeposit);\\n\\n    event Withdrawn(address indexed account, address withdrawAddress, uint256 amount);\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeLocked(address indexed account, uint256 totalStaked, uint256 withdrawTime);\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n    event StakeWithdrawn(address indexed account, address withdrawAddress, uint256 amount);\\n\\n    /**\\n     * @param deposit the account's deposit\\n     * @param staked true if this account is staked as a paymaster\\n     * @param stake actual amount of ether staked for this paymaster. must be above paymasterStake\\n     * @param unstakeDelaySec minimum delay to withdraw the stake. must be above the global unstakeDelaySec\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 2^15 eth\\n     *    64 bit for full timestamp\\n     *    32 bit allow 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint64 withdrawTime;\\n    }\\n\\n    /// maps paymaster to their deposits and stakes\\n    mapping(address => DepositInfo) public deposits;\\n\\n    function getDepositInfo(address account) public view returns (DepositInfo memory info) {\\n        return deposits[account];\\n    }\\n\\n    /// return the deposit (for gas payment) of the account\\n    function balanceOf(address account) public view returns (uint256) {\\n        return deposits[account].deposit;\\n    }\\n\\n    receive() external payable {\\n        depositTo(msg.sender);\\n    }\\n\\n    function internalIncrementDeposit(address account, uint256 amount) internal {\\n        DepositInfo storage info = deposits[account];\\n        uint256 newAmount = info.deposit + amount;\\n        require(newAmount <= type(uint112).max, \\\"deposit overflow\\\");\\n        info.deposit = uint112(newAmount);\\n    }\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) public payable {\\n        internalIncrementDeposit(account, msg.value);\\n        DepositInfo storage info = deposits[account];\\n        emit Deposited(account, info.deposit);\\n    }\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) public payable {\\n        DepositInfo storage info = deposits[msg.sender];\\n        require(_unstakeDelaySec >= unstakeDelaySec, \\\"unstake delay too low\\\");\\n        require(_unstakeDelaySec >= info.unstakeDelaySec, \\\"cannot decrease unstake time\\\");\\n        uint256 stake = info.stake + msg.value;\\n        require(stake >= paymasterStake, \\\"stake value too low\\\");\\n        require(stake < type(uint112).max, \\\"stake overflow\\\");\\n        deposits[msg.sender] = DepositInfo(info.deposit, true, uint112(stake), _unstakeDelaySec, 0);\\n        emit StakeLocked(msg.sender, stake, _unstakeDelaySec);\\n    }\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external {\\n        DepositInfo storage info = deposits[msg.sender];\\n        require(info.unstakeDelaySec != 0, \\\"not staked\\\");\\n        require(info.staked, \\\"already unstaking\\\");\\n        uint64 withdrawTime = uint64(block.timestamp) + info.unstakeDelaySec;\\n        info.withdrawTime = withdrawTime;\\n        info.staked = false;\\n        emit StakeUnlocked(msg.sender, withdrawTime);\\n    }\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external {\\n        DepositInfo storage info = deposits[msg.sender];\\n        uint256 stake = info.stake;\\n        require(stake > 0, \\\"No stake to withdraw\\\");\\n        require(info.withdrawTime > 0, \\\"must call unlockStake() first\\\");\\n        require(info.withdrawTime <= block.timestamp, \\\"Stake withdrawal is not due\\\");\\n        info.unstakeDelaySec = 0;\\n        info.withdrawTime = 0;\\n        info.stake = 0;\\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\\n        (bool success, ) = withdrawAddress.call{value: stake}(\\\"\\\");\\n        require(success, \\\"failed to withdraw stake\\\");\\n    }\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\\n        DepositInfo memory info = deposits[msg.sender];\\n        require(withdrawAmount <= info.deposit, \\\"Withdraw amount too large\\\");\\n        info.deposit = uint112(info.deposit - withdrawAmount);\\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\\n        (bool success, ) = withdrawAddress.call{value: withdrawAmount}(\\\"\\\");\\n        require(success, \\\"failed to withdraw\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_create2factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_paymasterStake\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_unstakeDelaySec\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"opIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"FailedOp\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"}],\"name\":\"StakeLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"}],\"name\":\"StakeUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualGasCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualGasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"UserOperationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"revertReason\",\"type\":\"bytes\"}],\"name\":\"UserOperationRevertReason\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_unstakeDelaySec\",\"type\":\"uint32\"}],\"name\":\"addStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"create2factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"depositTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"deposit\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"staked\",\"type\":\"bool\"},{\"internalType\":\"uint112\",\"name\":\"stake\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"unstakeDelaySec\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"withdrawTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getDepositInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint112\",\"name\":\"deposit\",\"type\":\"uint112\"},{\"internalType\":\"bool\",\"name\":\"staked\",\"type\":\"bool\"},{\"internalType\":\"uint112\",\"name\":\"stake\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"unstakeDelaySec\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"withdrawTime\",\"type\":\"uint64\"}],\"internalType\":\"struct StakeManager.DepositInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"paymasterData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"getRequestId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"getSenderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getSenderStorage\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"senderStorageCells\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"paymasterData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation[]\",\"name\":\"ops\",\"type\":\"tuple[]\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"handleOps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"paymasterData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"op\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"prefund\",\"type\":\"uint256\"},{\"internalType\":\"enum EntryPoint.PaymentMode\",\"name\":\"paymentMode\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"contextOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preOpGas\",\"type\":\"uint256\"}],\"internalType\":\"struct EntryPoint.UserOpInfo\",\"name\":\"opInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"innerHandleOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"actualGasCost\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymasterStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"paymasterData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"simulateValidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"preOpGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prefund\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeDelaySec\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"withdrawAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EntryPoint", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ce0042b868300000d44a59004da54a005ffdcf9f000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000000000000000000003c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}