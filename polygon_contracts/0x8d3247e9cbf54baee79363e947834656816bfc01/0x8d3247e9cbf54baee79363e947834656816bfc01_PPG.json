{"SourceCode": "// File contracts/PPG.sol\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n//\n// Pudgy Penguin #6873 - generated with https://dropu.io/\n//\n\n\n\ncontract PPG {\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    bytes32 internal constant _ADDRESS_RELAY_SLOT =\n        keccak256(\"dropu.launchpad.addressRelay\");\n\n    /**\n     * @notice Initializes the child contract with the base implementation address and the configuration settings\n     * @param _name The name of the NFT\n     * @param _symbol The symbol of the NFT\n     * @param _baseConfig Base configuration settings\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _addressRelay,\n        address _implementation,\n        BaseConfig memory _baseConfig\n    ) {\n        StorageSlot\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = _implementation;\n        StorageSlot.getAddressSlot(_ADDRESS_RELAY_SLOT).value = _addressRelay;\n        IAddressRelay addressRelay = IAddressRelay(\n            StorageSlot.getAddressSlot(_ADDRESS_RELAY_SLOT).value\n        );\n        address implContract = addressRelay.fallbackImplAddress();\n        (bool success, ) = implContract.delegatecall(\n            abi.encodeWithSelector(0x32ad74b0, _name, _symbol, _baseConfig)\n        );\n        require(success, \"INITIALIZER_FAILED\");\n    }\n\n    /**\n     * @dev Delegates the current call to nftImplementation\n     *\n     * This function does not return to its internal call site - it will return directly to the external caller.\n     */\n    fallback() external payable {\n        IAddressRelay addressRelay = IAddressRelay(\n            StorageSlot.getAddressSlot(_ADDRESS_RELAY_SLOT).value\n        );\n        address implContract = addressRelay.getImplAddress(msg.sig);\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implContract,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n// Sources flattened with hardhat v2.15.0 https://hardhat.org\n\n// File @openzeppelin/contracts/utils/StorageSlot.sol@v4.9.2\n\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n\n\n// File contracts/interfaces/IAddressRelay.sol\n\npragma solidity ^0.8.18;\n\n    struct Implementation {\n        address implAddress;\n        bytes4[] selectors;\n    }\n\ninterface IAddressRelay {\n    /**\n     * @notice Returns the fallback implementation address\n     */\n    function fallbackImplAddress() external returns (address);\n\n    /**\n     * @notice Adds or updates selectors and their implementation addresses\n     * @param _selectors The selectors to add or update\n     * @param _implAddress The implementation address the selectors will point to\n     */\n    function addOrUpdateSelectors(\n        bytes4[] memory _selectors,\n        address _implAddress\n    ) external;\n\n    /**\n     * @notice Removes selectors\n     * @param _selectors The selectors to remove\n     */\n    function removeSelectors(bytes4[] memory _selectors) external;\n\n    /**\n     * @notice Removes an implementation address and all the selectors that point to it\n     * @param _implAddress The implementation address to remove\n     */\n    function removeImplAddressAndAllSelectors(address _implAddress) external;\n\n    /**\n     * @notice Returns the implementation address for a given function selector\n     * @param _functionSelector The function selector to get the implementation address for\n     */\n    function getImplAddress(\n        bytes4 _functionSelector\n    ) external view returns (address implAddress_);\n\n    /**\n     * @notice Returns all the implementation addresses and the selectors they support\n     * @return impls_ An array of Implementation structs\n     */\n    function getAllImplAddressesAndSelectors()\n    external\n    view\n    returns (Implementation[] memory impls_);\n\n    /**\n     * @notice Return all the fucntion selectors associated with an implementation address\n     * @param _implAddress The implementation address to get the selectors for\n     */\n    function getSelectorsForImplAddress(\n        address _implAddress\n    ) external view returns (bytes4[] memory selectors_);\n\n    /**\n     * @notice Sets the fallback implementation address to use when a function selector is not found\n     * @param _fallbackAddress The fallback implementation address\n     */\n    function setFallbackImplAddress(address _fallbackAddress) external;\n\n    /**\n     * @notice Updates the supported interfaces\n     * @param _interfaceId The interface ID to update\n     * @param _supported Whether the interface is supported or not\n     */\n    function updateSupportedInterfaces(\n        bytes4 _interfaceId,\n        bool _supported\n    ) external;\n\n    /**\n     * @notice Returns whether the interface is supported or not\n     * @param _interfaceId The interface ID to check\n     */\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view returns (bool);\n}\n\n\n// File contracts/libraries/DropuStorage.sol\n\npragma solidity 0.8.18;\n\nstruct BaseConfig {\n    // If true tokens can be minted in the public sale\n    bool publicSaleActive;\n    // If enabled, automatic start and stop times for the public sale will be enforced, otherwise ignored\n    bool usePublicSaleTimes;\n    // If true tokens can be minted in the presale\n    bool presaleActive;\n    // If enabled, automatic start and stop times for the presale will be enforced, otherwise ignored\n    bool usePresaleTimes;\n    // If true, all tokens will be soulbound\n    bool soulbindingActive;\n    // If true, a random hash will be generated for each token\n    bool randomHashActive;\n    // If true, the default CORI subscription address will be used to enforce royalties with the Operator Filter Registry\n    bool enforceRoyalties;\n    // If true, Dropu fees will be charged for minting tokens\n    bool dropuFeeActive;\n    // The number of tokens that can be minted in the public sale per address\n    uint8 publicMintsAllowedPerAddress;\n    // The number of tokens that can be minted in the presale per address\n    uint8 presaleMintsAllowedPerAddress;\n    // The number of tokens that can be minted in the public sale per transaction\n    uint8 publicMintsAllowedPerTransaction;\n    // The number of tokens that can be minted in the presale sale per transaction\n    uint8 presaleMintsAllowedPerTransaction;\n    // Maximum supply of tokens that can be minted\n    uint16 maxSupply;\n    // Total number of tokens available for minting in the presale\n    uint16 presaleMaxSupply;\n    // The royalty payout percentage in basis points\n    uint16 royaltyBps;\n    // The price of a token in the public sale in 1/100,000 ETH - e.g. 1 = 0.00001 ETH, 100,000 = 1 ETH - multiply by 10^13 to get correct wei amount\n    uint32 publicPrice;\n    // The price of a token in the presale in 1/100,000 ETH\n    uint32 presalePrice;\n    // Used to create a default Dropu Launchpad URI for token metadata to save gas over setting a custom URI and increase fetch reliability\n    string projectSlug;\n    // The base URI for all token metadata\n    string uriBase;\n    // The address used to sign and validate presale mints\n    address presaleSignerAddress;\n    // The automatic start time for the public sale (if usePublicSaleTimes is true and publicSaleActive is true)\n    uint32 publicSaleStartTime;\n    // The automatic end time for the public sale (if usePublicSaleTimes is true and publicSaleActive is true)\n    uint32 publicSaleEndTime;\n    // The automatic start time for the presale (if usePresaleTimes is true and presaleActive is true)\n    uint32 presaleStartTime;\n    // The automatic end time for the presale (if usePresaleTimes is true and presaleActive is true)\n    uint32 presaleEndTime;\n    // If set, the UTC timestamp in seconds by which the fundingTarget must be met or funds are refundable\n    uint32 fundingEndsAt;\n    // The amount of centiETH that must be raised by fundingEndsAt or funds are refundable - multiply by 10^16\n    uint32 fundingTarget;\n    // The parameter are used to determine how to pay for the service.\n    // true: User pays the platform fee (default)\n    // false: Project owner pays the platform fee\n    bool userPayPlatformFee;\n}\n\nstruct AdvancedConfig {\n    // When false, tokens cannot be staked but can still be unstaked\n    bool stakingActive;\n    // When false, tokens cannot be loaned but can still be retrieved\n    bool loaningActive;\n    // If true tokens can be claimed for free\n    bool freeClaimActive;\n    // The number of tokens that can be minted per free claim\n    uint8 mintsPerFreeClaim;\n    // Optional address of an NFT that is eligible for free claim\n    address freeClaimContractAddress;\n    // If true tokens can be burned in order to mint\n    bool burnClaimActive;\n    // If true, the original token id of a burned token will be used for metadata\n    bool useBurnTokenIdForMetadata;\n    // The number of tokens that can be minted per burn transaction\n    uint8 mintsPerBurn;\n    // The payment required alongside a burn transaction in order to mint in 1/100,000 ETH\n    uint32 burnPayment;\n    // Permanently freezes payout addresses and basis points so they can never be updated\n    bool payoutAddressesFrozen;\n    // If set, the UTC timestamp in seconds until which tokens are refundable for refundPrice\n    uint32 refundEndsAt;\n    // The amount returned to a user in a token refund in 1/100,000 ETH\n    uint32 refundPrice;\n    // Permanently freezes metadata so it can never be changed\n    bool metadataFrozen;\n    // If true the soulbind admin address is permanently disabled\n    bool soulbindAdminTransfersPermanentlyDisabled;\n    // If true deposit tokens can be burned in order to mint\n    bool depositClaimActive;\n    // If additional payment is required to mint, this is the amount required in centiETH\n    uint32 remainingDepositPayment;\n    // The deposit token smart contract address\n    address depositContractAddress;\n    // The merkle root used to validate if deposit tokens are eligible to burn to mint\n    bytes32 depositMerkleRoot;\n    // The respective share of funds to be sent to each address in payoutAddresses in basis points\n    uint16[] payoutBasisPoints;\n    // The addresses to which funds are sent when a token is sold. If empty, funds are sent to the contract owner.\n    address[] payoutAddresses;\n    // Optional address where royalties are paid out. If not set, royalties are paid to the contract owner.\n    address royaltyPayoutAddress;\n    // Used to allow transferring soulbound tokens with admin privileges. Defaults to the contract owner if not set.\n    address soulboundAdminAddress;\n    // The address where refunded tokens are returned. If not set, refunded tokens are sent to the contract owner.\n    address refundAddress;\n    // An address authorized to call the creditCardMint function.\n    address creditCardMintAddress;\n}\n\nstruct BurnToken {\n    // The contract address of the token to be burned\n    address contractAddress;\n    // The type of contract - 1 = ERC-721, 2 = ERC-1155\n    uint8 tokenType;\n    // The number of tokens to burn per mint\n    uint8 tokensPerBurn;\n    // The ID of the token on an ERC-1155 contract eligible for burn; unused for ERC-721\n    uint16 tokenId;\n}\n\nstruct Data {\n    // ============ BASE FUNCTIONALITY ============\n    // Dropu fee to be paid per minted token (if not set, defaults to defaultDropuFeePerToken)\n    uint256 dropuFeePerToken;\n    // Keeps track of if advanced config settings have been initialized to prevent setting multiple times\n    bool advancedConfigInitialized;\n    // A mapping of token IDs to specific tokenURIs for tokens that have custom metadata\n    mapping(uint256 => string) tokenURIs;\n    // ============ CONDITIONAL FUNDING ============\n    // If true, the funding target was reached and funds are not refundable\n    bool fundingTargetReached;\n    // If true, funding success has been determined and determineFundingSuccess() can no longer be called\n    bool fundingSuccessDetermined;\n    // A mapping of token ID to price paid for the token\n    mapping(uint256 => uint256) pricePaid;\n    // ============ SOULBINDING ============\n    // Used to allow an admin to transfer soulbound tokens when necessary\n    bool soulboundAdminTransferInProgress;\n    // ============ BURN TO MINT ============\n    // Maps a token id to the burn token id that was used to mint it to match metadata\n    mapping(uint256 => uint256) tokenIdToBurnTokenId;\n    // ============ STAKING ============\n    // Used to allow direct transfers of staked tokens without unstaking first\n    bool stakingTransferActive;\n    // Returns the UNIX timestamp at which a token began staking if currently staked\n    mapping(uint256 => uint256) currentTimeStaked;\n    // Returns the total time a token has been staked in seconds, not counting the current staking time if any\n    mapping(uint256 => uint256) totalTimeStaked;\n    // ============ LOANING ============\n    // Used to keep track of the total number of tokens on loan\n    uint256 currentLoanTotal;\n    // Returns the total number of tokens loaned by an address\n    mapping(address => uint256) totalLoanedPerAddress;\n    // Returns the address of the original token owner if a token is currently on loan\n    mapping(uint256 => address) tokenOwnersOnLoan;\n    // ============ FREE CLAIM ============\n    // If true token has already been used to claim and cannot be used again\n    mapping(uint256 => bool) freeClaimUsed;\n    // ============ RANDOM HASH ============\n    // Stores a random hash for each token ID\n    mapping(uint256 => bytes32) randomHashStore;\n    // ============ ALLOWED CIREDIT MINT ADDRESSES  ============\n    address[] creditCardMintAddresses;\n}\n\nlibrary DropuStorage {\n    struct State {\n        BaseConfig cfg;\n        AdvancedConfig advCfg;\n        BurnToken[] burnTokens;\n        Data data;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"dropu.launchpad.storage.erc721a\");\n\n    function state() internal pure returns (State storage s) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            s.slot := slot\n        }\n    }\n}\n\n\n", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_addressRelay\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"publicSaleActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"usePublicSaleTimes\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"presaleActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"usePresaleTimes\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"soulbindingActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"randomHashActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enforceRoyalties\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"dropuFeeActive\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"publicMintsAllowedPerAddress\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"presaleMintsAllowedPerAddress\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"publicMintsAllowedPerTransaction\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"presaleMintsAllowedPerTransaction\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"maxSupply\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"presaleMaxSupply\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"royaltyBps\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"publicPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presalePrice\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"projectSlug\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uriBase\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"presaleSignerAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"publicSaleStartTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"publicSaleEndTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleStartTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleEndTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fundingEndsAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fundingTarget\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"userPayPlatformFee\",\"type\":\"bool\"}],\"internalType\":\"struct BaseConfig\",\"name\":\"_baseConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PPG", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000f843d889708b0d8ff5bf81b4788ab80b730e59c1000000000000000000000000860aedd08489d5b0befd79bf5e8c430fb8c306ad0000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000001350756467792050656e6775696e202336383733000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003505047000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022b800000000000000000000000000000000000000000000000000000000000007d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000027100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000003a0000000000000000000000000461d887d3a9ad4970c7593df465df51ed638ecc000000000000000000000000000000000000000000000000000000000653b35c000000000000000000000000000000000000000000000000000000000671dbac00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000157a78694e686a726f6f6a3535444c53793044464d5a0000000000000000000000000000000000000000000000000000000000000000000000000000000000005168747470733a2f2f697066732e696f2f697066732f6261667962656962633573676f32706c6d6a6b7132747a6d68726e3534626b336372686e6332337a64326d73673465613761347078726b67666e612f000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x860aedd08489d5b0befd79bf5e8c430fb8c306ad", "SwarmSource": ""}