{"SourceCode": "/******************************************\r\n    Personal Bookmaker\r\n    \r\n    Syst\u00e8mes pour effectuer un pari entre\r\n    amis dans le cadre priv\u00e9.\r\n    \r\n    Copyright \u00a9 2020-2022 Personal-Bookmaker.net\r\n    SPDX-License-Identifier: UNLICENSED\r\n******************************************/\r\n\r\npragma solidity ^0.7.0;             // on cible solidity 0.7.x\r\npragma experimental ABIEncoderV2;   // \u00e0 cause de la structure retourn\u00e9e par `getBetInfo()`\r\n\r\n\r\n/*** le contrat de pari, achet\u00e9 par l\u2019organisateur ***/\r\n\r\ncontract PrivateBet\r\n{\r\n/* constantes */\r\n\r\n    string public constant  VERSION             = \"4.1.1\";\r\n    uint public constant    NB_MAX_PARTICIPANT  = 30;       // bridage \u00e0 30 participants max\r\n    \r\n    // Message sign\u00e9 par l'appelant de `getBetInfo()` : hashMessage(\"PrivateBet\")\r\n    bytes32 private constant AUTH_MSG = 0x257cc31861cde10af4851394d4ac648b8c6ed14355eff69f4ce64eba4b8e24cf;\r\n    uint    private constant MICRO_ETH = 10**12; // 1E+18 * 1E-6 wei. 1\u00b5 eth <=> 0.1 centime d'\u20ac @1000 \u20ac/eth\r\n\r\n\r\n/* d\u00e9fintions des type personnalis\u00e9s */\r\n\r\n    struct Participant\r\n    {\r\n        bool      knownUser;    // participant autoris\u00e9s \u00e0 parier\r\n        uint8     betId;        // proposition pari\u00e9e\r\n        uint256   totalBet;     // montant totale mis\u00e9e sur une ou plusieurs propositions\r\n    }\r\n\r\n    enum State\r\n    {\r\n        Open,           // les paris sont ouverts (--> ajout de participant; pari possibles si date <= limite et montant < limite)\r\n        Canceled,       // le pari est annul\u00e9 (--> remboursement autoris\u00e9)\r\n        Closed_Winner,  // le pari est termin\u00e9 et nous avons au moins un gagnant (--> les vainqueurs peuvent retirer leur gain)\r\n        Closed_NoWinner // le pari est termin\u00e9 mais personne n'a gagn\u00e9 (--> remboursement de tous les participants autoris\u00e9)\r\n    }\r\n\r\n    // donn\u00e9s retourn\u00e9es par `getBetInfo()`\r\n    struct BetInfo {\r\n        address   owner;             // adresse de l'organisateur du pari\r\n        uint8     outcomeId;         // index du r\u00e9sultat final du pari (donne la proposition gagnante). Valide uniquement dans les \u00e9tats Closed_XXX\r\n        uint8     nbParticipant;     // nombre actuel de participant\r\n        uint8     nbPossibilities;   // nombre de r\u00e9sultats possibles\r\n        State     state;             // \u00e9tat du pari\r\n        uint32    externDescriptionId;//identifiant 32bits de description externe du pari (lien avec la BDD du site web)\r\n        uint32    betDeadlineTime;   // date limite pour parier (date UNIX / EPOC)\r\n        uint32    minimumStake_micro;// mise minimale d'un participant en \u00b5Ether\r\n        uint32    totalMaxStake_micro;//mise maximale totale pour un participant en \u00b5Ether\r\n        uint256[] betAmountByProp;   // montant total mis\u00e9 par r\u00e9sultat possible du pari\r\n    }\r\n\r\n    struct Bet {\r\n        mapping(address => Participant) participants; // BDD (via map) des info par participants\r\n        address   owner;             // adresse de l'organisateur du pari\r\n        uint32    betDeadlineTime;   // date limite pour parier (date UNIX / EPOC)\r\n        uint32    externDescriptionId;//identifiant 32bits de description externe du pari (lien avec la BDD du site web)\r\n        State     state;             // \u00e9tat du pari\r\n        uint8     outcomeId;         // index du r\u00e9sultat final du pari (donne la proposition gagnante). Valide uniquement dans les \u00e9tats Closed_XXX\r\n        uint8     nbParticipant;     // nombre actuel de participant\r\n        uint8     nbPossibilities;   // nombre de r\u00e9sultats possibles\r\n        uint256[] betAmountByProp;   // montant total mis\u00e9 par r\u00e9sultat possible du pari\r\n        uint256   winningsAmount;    // montant total des gain. Positionn\u00e9 uniquement quand la proposition gagante est fournie.\r\n        address   guestPubKeyAdr;    // pseudo cl\u00e9 publique du pari pour authentifier un invit\u00e9\r\n        uint32    minimumStake_micro;// mise minimale d'un participant en \u00b5Ether\r\n        uint32    totalMaxStake_micro;//mise maximale totale pour un participant en \u00b5Ether\r\n    }\r\n\r\n\r\n/* donn\u00e9es publiques */\r\n\r\n    bool public m_createBetDisabled; // emp\u00eache la cr\u00e9ation de nouveaux paris (cf. `disableBetCreation()`)   \r\n\r\n\r\n/* \u00e9v\u00e9nements */\r\n\r\n    // un nouveau pari est cr\u00e9\u00e9\r\n    event NewBetCreated(uint indexed betId, address indexed user);\r\n    // un nouveau participant est inscrit \r\n    event NewParticiant(uint indexed betId, address indexed user);\r\n    // une nouvelle mise est enregistr\u00e9e\r\n    event NewBet(uint indexed betId, address indexed user, uint256 stake, uint outcomeId);\r\n    // fin du pari, le r\u00e9sultat a \u00e9t\u00e9 donn\u00e9\r\n    event BetClosed(uint indexed betId, bool hasWinner);\r\n    // le pari est annul\u00e9\r\n    event BetCanceled(uint indexed betId);\r\n    // un remboursement \u00e0 l'appelant est effectu\u00e9\r\n    event Transfer(uint indexed betId, address indexed user, uint256 amount);\r\n    // un don vient d'\u00eatre effectu\u00e9\r\n    event NewDonation(uint indexed betId, address indexed user, uint256 amount);\r\n\r\n\r\n/* fonction publiques */\r\n\r\n    /// @notice Constructeur du contrat de paris\r\n    /// @dev    m\u00e9morise le cr\u00e9ateur pour lui transf\u00e9rer les dons\r\n    constructor() {\r\n        m_owner = msg.sender;\r\n    }\r\n\r\n    /// @notice Cr\u00e9ation d'un pari, appel\u00e9 par son futur organisateur. Possible si la cr\u00e9ation de paris n'est pas supendue.\r\n    /// @dev    Emmet un \u00e9venement 'NewBetCreated' pour retourner l'identifiant du pari. Met le pari dans l'\u00e9tat cr\u00e9\u00e9.\r\n    /// @param _externDescriptionId Identifiant 32bits de description externe du pari (lien avec la BDD du site web)\r\n    /// @param _nbPossibilities Nombre de r\u00e9sultats possibles du pari. Au moins 2, 255 max.\r\n    /// @param _betDeadlineTime Date limite pour parier (date UNIX / EPOC). Doit \u00eatre > \u00e0 la date actuelle\r\n    /// @param _minimumStake_micro Mise minimale d'un participant en \u00b5Ether\r\n    /// @param _totalMaxStake_micro Mise maximale totale pour un participant en \u00b5Ether. Doit \u00eatre >= \u00e0 la mise minimale\r\n    /// @param _guestPubKeyAdr pseudo cl\u00e9 publique du pari pour authentifier un invit\u00e9. 0x0 d\u00e9sactive `participate()`\r\n    /// @param _ownerParticipate Participation de l'organisateur ? Si oui on l'inscrit tout de suite.\r\n    function createBet(uint32 _externDescriptionId, uint _nbPossibilities, uint _betDeadlineTime,\r\n                uint32 _minimumStake_micro, uint32 _totalMaxStake_micro, address _guestPubKeyAdr, bool _ownerParticipate)\r\n    public {\r\n        require(!m_createBetDisabled, \"CreateBetDisabled\");  // la cr\u00e9ation de pris est actuellement suspendue\r\n        require(_nbPossibilities >= 2, \"TooFewPossibility\");   // Il faut au moins 2 possibilit\u00e9s\r\n        require(_nbPossibilities < 2**8, \"TooManyPossibilities\");// 255 possibilit\u00e9s max\r\n        require(_betDeadlineTime > block.timestamp, \"DeadlineAlreadyPassed\");   // Date limite d\u00e9j\u00e0 pass\u00e9e\r\n        require(_totalMaxStake_micro >= _minimumStake_micro, \"InvalidTotalMaxStake\");// Mise maximale doit \u00eatre au moins celle minimale\r\n\r\n        uint nextId = m_bets.length;\r\n        \r\n        Bet storage bt = m_bets.push();\r\n        bt.owner               = msg.sender;\r\n        bt.betDeadlineTime     = uint32(_betDeadlineTime);\r\n        bt.externDescriptionId = _externDescriptionId;\r\n        //bt.state             = State.Open;\r\n        bt.nbPossibilities     = uint8(_nbPossibilities);\r\n        bt.betAmountByProp     = new uint256[](_nbPossibilities);\r\n        bt.guestPubKeyAdr      = _guestPubKeyAdr;\r\n        bt.minimumStake_micro  = _minimumStake_micro;\r\n        bt.totalMaxStake_micro = _totalMaxStake_micro;\r\n        \r\n        emit NewBetCreated(nextId, msg.sender);\r\n        \r\n        // on inscrit l'organisateur ?\r\n        if (_ownerParticipate) {\r\n            bt.participants[msg.sender].knownUser = true;\r\n\r\n            // prise en compte du participant\r\n            bt.nbParticipant++;\r\n            emit NewParticiant(nextId, msg.sender);\r\n        }\r\n    }\r\n\r\n    /// @return le nombre de paris cr\u00e9\u00e9\r\n    function getNbBetCreated() public view returns(uint)  {\r\n        return m_bets.length;\r\n    }\r\n\r\n    /// @notice Permet \u00e0 *une pesonne en lien avec le pari* la consultation des donn\u00e9s publiques du pari (authentification requise)\r\n    /// @dev    Cmd r\u00e9serv\u00e9e au cr\u00e9ateur du contract, \u00e0 l'organisateur, \u00e0 l'invit\u00e9 ou \u00e0 un participant\r\n    /// @param  _id identifiant du pari\r\n    /// @param  _rSign partie 'r' de la signature ECDSA\r\n    /// @param  _sSign partie 's' de la signature ECDSA\r\n    /// @param  _vSign partie 'v' de la signature ECDSA\r\n    /// @return inf_ la structure de donn\u00e9s publiques \r\n    function getBetInfo(uint _id, bytes32 _rSign, bytes32 _sSign, uint8 _vSign) public view\r\n    returns(BetInfo memory inf_)  {\r\n        // only known user (cr\u00e9ateur du contract, organisateur, invit\u00e9 ou participant)\r\n        require(msg.sender == m_owner || msg.sender == m_bets[_id].owner ||\r\n                msg.sender == m_bets[_id].guestPubKeyAdr || // `&& m_bets[_id].guestPubKeyAdr != address(0)` innutile gr\u00e2ce \u00e0 \"InvalidSignature\"\r\n                m_bets[_id].participants[msg.sender].knownUser, \"OnlyKnownUser\");\r\n\r\n        // v\u00e9rif signature du msg pour garantir l'authenticit\u00e9 de l'appelant\r\n        address signer = ecrecover(AUTH_MSG, _vSign, _rSign, _sSign);\r\n        require(signer != address(0), \"InvalidSignature\"); // signature invalide (bug)\r\n        require(signer == msg.sender, \"WrongSigner\");  // signataire incorrecte (bug ou tentative d'usurpation d'identit\u00e9)\r\n        \r\n        Bet storage bt = m_bets[_id];\r\n        inf_.owner               = bt.owner;\r\n        inf_.outcomeId           = bt.outcomeId;\r\n        inf_.nbParticipant       = bt.nbParticipant;\r\n        inf_.nbPossibilities     = bt.nbPossibilities;\r\n        inf_.state               = bt.state;\r\n        inf_.externDescriptionId = bt.externDescriptionId;\r\n        inf_.betDeadlineTime     = bt.betDeadlineTime;\r\n        inf_.minimumStake_micro  = bt.minimumStake_micro;\r\n        inf_.totalMaxStake_micro = bt.totalMaxStake_micro;\r\n        inf_.betAmountByProp     = bt.betAmountByProp;\r\n    }\r\n\r\n    /// @notice Permet \u00e0 *l'organisateur* d'inscire un ou plusieurs participants, dans la limite de ce qui est\r\n    ///         permi et uniquement lorsque le pari est dans l'\u00e9tat ouvert.\r\n    /// @dev Emmet un \u00e9venement par participant ajout\u00e9. Le nombre de participant ajout\u00e9s peut \u00eatre inf\u00e9rieur \u00e0\r\n    ///         ce qui est attendu si la limite max est atteinte ou en cas de doublons avec des participants d\u00e9j\u00e0 inscrits.\r\n    /// @param  _id identifiant du pari\r\n    /// @param _adrParticipants Tableau d'adresses Ethereum des nouveaux participants\r\n    function addParticipants(uint _id, address[] memory _adrParticipants) public onlyOrganizer(_id) {\r\n        Bet storage bt = m_bets[_id];\r\n        require(bt.state == State.Open, \"ImproperState\");    // Etat 'ouvert' requis\r\n        \r\n        // parcours du tableau re\u00e7u dans la limite du nbr de participant max autoris\u00e9s\r\n        for (uint newUsers; newUsers < _adrParticipants.length && bt.nbParticipant < NB_MAX_PARTICIPANT; newUsers++) {\r\n            address p = _adrParticipants[newUsers];\r\n            // on ajoute uniquement le participant s'il est valide et n'est pas d\u00e9j\u00e0 connu\r\n            if (p != address(0) && !bt.participants[p].knownUser) {\r\n                bt.participants[p].knownUser = true;\r\n\r\n                // prise en compte du participant\r\n                bt.nbParticipant++;\r\n                emit NewParticiant(_id, p);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Permet \u00e0 une personne invit\u00e9e par l'organisateur de participer, dans la limite de ce qui est permi\r\n    ///         et uniquement lorsque le pari est dans l'\u00e9tat ouvert.\r\n    /// @dev Emmet un \u00e9venement 'NewParticiant' si le participant est ajout\u00e9.\r\n    ///         L'organisateur du pari transmet \u00e0 ses invit\u00e9s la cl\u00e9 priv\u00e9e correspondant \u00e0 l'adresse publique du pari.\r\n    ///         L'invit\u00e9 va signer un message comportant son adresse pour rendre la signature unique \u00e0 chaque\r\n    ///         paricipant et donc non r\u00e9utilisable par un petit malin voulant s'inscrire au m\u00eame pari et qui utiliserait\r\n    ///         Etherscan pour r\u00e9cup\u00e9er une ancienne signature.\r\n    /// @param  _id identifiant du pari\r\n    /// @param  _rSign partie 'r' de la signature ECDSA du site web certifiant que le participant a bien \u00e9t\u00e9 invit\u00e9\r\n    ///             par l'organisateur du pari.\r\n    /// @param  _sSign partie 's' de la signature ECDSA\r\n    /// @param  _vSign partie 'v' de la signature ECDSA\r\n    function participate(uint _id, bytes32 _rSign, bytes32 _sSign, uint8 _vSign) public {\r\n        Bet storage bt = m_bets[_id];\r\n        require(bt.state == State.Open, \"ImproperState\");    // Etat 'ouvert' requis\r\n        \r\n        // v\u00e9rif signature de web3.eth.accounts.sign({participant})\r\n        bytes32 msgHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n20\", msg.sender));\r\n        address signer = ecrecover(msgHash, _vSign, _rSign, _sSign);\r\n        require(signer != address(0), \"InvalidSignature\"); // signature invalide (bug)\r\n        require(signer == bt.guestPubKeyAdr, \"WrongSigner\");  // signataire incorrecte (bug, invitation modifi\u00e9e/d\u00e9sactiv\u00e9e ou tentative de fraude)\r\n        \r\n        // peut-on encore en ajouter un ?\r\n        if (bt.nbParticipant < NB_MAX_PARTICIPANT) {\r\n            address p = msg.sender;\r\n            \r\n            // on ajoute uniquement le participant s'il n'est pas d\u00e9j\u00e0 connu\r\n            if (!bt.participants[p].knownUser) {\r\n                bt.participants[p].knownUser = true;\r\n\r\n                // prise en compte du participant\r\n                bt.nbParticipant++;\r\n                emit NewParticiant(_id, p);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Permet \u00e0 l'utilisateur de savoir s'il particpe \u00e0 un pari donn\u00e9\r\n    /// @dev    Seul moyen de conna\u00eetre l'info pour les tests unitaires\r\n    /// @param  _id identifiant du pari\r\n    /// @return true si l'utilisateur fait parti des participants, false sinon\r\n    function isParticipant(uint _id) public view returns(bool)  {\r\n        return m_bets[_id].participants[msg.sender].knownUser;\r\n    }\r\n\r\n    /// @notice Permet \u00e0 *l'organisateur* de changer la pseudo cl\u00e9 publique d'invitation dans le cas o\u00f9 la cl\u00e9 priv\u00e9e\r\n    ///         correspondante est compromise ou pour suspendre les invitations.\r\n    /// @param  _id identifiant du pari\r\n    /// @param _pubKeyAdr nouvelle pseudo cl\u00e9 publique \u00e0 utiliser. 0x0 d\u00e9sactive `participate()`\r\n    function setGuestPubKeyAdr(uint _id, address _pubKeyAdr) public onlyOrganizer(_id) {\r\n        m_bets[_id].guestPubKeyAdr = _pubKeyAdr;\r\n    }\r\n\r\n    /// @notice Permet \u00e0 *l'organisateur* d'annuler le pari, uniquement lorsque le pari est dans l'\u00e9tat ouvert.\r\n    /// @dev le pari passe dans l'\u00e9tat 'annul\u00e9'. Emmet l'\u00e9venement `BetCanceled` pour enrichir l'historique.\r\n    /// @param  _id identifiant du pari\r\n    function cancelBet(uint _id) public onlyOrganizer(_id) {\r\n        Bet storage bt = m_bets[_id];\r\n        require(bt.state == State.Open, \"ImproperState\"); // Etat 'ouvert' requis\r\n\r\n        bt.state = State.Canceled;\r\n        \r\n        emit BetCanceled(_id);\r\n    }\r\n\r\n    /// @notice Permet au *participant* de parier sur une proposition le montant transmis. Celui-ci doit \u00eatre \r\n    ///         d'au moins la mise minimale la premi\u00e8re fois. Possible uniquement lorsque le pari est dans l'\u00e9tat ouvert\r\n    ///         et que la date limite de pari n'est pas pass\u00e9e.\r\n    /// @dev Emmet un l'\u00e9venement 'NewBet' avec la somme nouvellement pari\u00e9e qui peut \u00eatre inf\u00e9rieur au montant transmis\r\n    ///         si le plafond de mise maximale du participant est atteint.\r\n    /// @param  _id identifiant du pari\r\n    /// @param _outcomeId Index de la proposition sur laquelle parier\r\n    function bet(uint _id, uint _outcomeId) public payable onlyParticipant(_id) {\r\n        Bet storage bt = m_bets[_id];\r\n        require(bt.state == State.Open, \"ImproperState\");        // Etat 'ouvert' requis\r\n        require(block.timestamp <= bt.betDeadlineTime, \"DeadlineExpired\");   // Date limite d\u00e9pass\u00e9e\r\n        require(_outcomeId < bt.nbPossibilities, \"OutOfBoundIndex\");// index hors bornes\r\n        \r\n        Participant storage p = bt.participants[msg.sender];\r\n        uint256 totalBet = p.totalBet; // copie m\u00e9moire pour optimiser\r\n\r\n        // 1\u00e8re mise ?\r\n        if (totalBet == 0) {\r\n            // premi\u00e8re fois : on v\u00e9rifie qu'on a mis au moins le minimum \r\n            require(msg.value >= bt.minimumStake_micro * MICRO_ETH, \"InsufficientStake\"); // QUITTE sur err : mise insuffisante\r\n            // m\u00e9morisation de la proposition\r\n            p.betId = uint8(_outcomeId);\r\n        } else {\r\n            // on ne peut surench\u00e9rire que sur la m\u00eame proposition\r\n            require(_outcomeId == p.betId, \"MultiChoiceNotAllowed\"); // QUITTE sur err : choix multiples non permis\r\n        }\r\n        \r\n        uint256 betAmount;\r\n        \r\n        // plafond non atteint ?\r\n        uint256 totalMaxStake = bt.totalMaxStake_micro * MICRO_ETH;\r\n        if (totalBet < totalMaxStake) {\r\n            // limitation de la somme mis\u00e9e par le plafond\r\n            betAmount = (totalBet + msg.value > totalMaxStake) ? totalMaxStake - totalBet : msg.value;\r\n            // prise en compte du pari\r\n            bt.betAmountByProp[_outcomeId] += betAmount;\r\n            emit NewBet(_id, msg.sender, betAmount, _outcomeId);\r\n            // mise \u00e0 jour de la mise du joueur\r\n            p.totalBet = totalBet + betAmount;\r\n        }\r\n        \r\n        // remboursement du trop per\u00e7u le cas \u00e9ch\u00e9ant\r\n        if (msg.value > betAmount)\r\n            msg.sender.transfer(msg.value - betAmount);\r\n    }\r\n    \r\n    /// @notice Permet \u00e0 une personne invit\u00e9e par l'organisateur de participer, dans la limite de ce qui est permi,\r\n    ///         et de miser en m\u00eame temps sur une proposition le montant transmis. Celui-ci doit \u00eatre d'au moins la\r\n    ///         mise minimale. Possible uniquement lorsque le pari est dans l'\u00e9tat ouvert et que la date limite de\r\n    ///         pari n'est pas pass\u00e9e.\r\n    /// @dev Emmet un \u00e9venement 'NewParticiant' si le participant est ajout\u00e9. Emmet un l'\u00e9venement 'NewBet' avec la\r\n    ///         somme nouvellement pari\u00e9e qui peut \u00eatre inf\u00e9rieur au montant transmis si le plafond de mise maximale\r\n    ///         du participant est atteint.\r\n    ///         L'organisateur du pari transmet \u00e0 ses invit\u00e9s la cl\u00e9 priv\u00e9e correspondant \u00e0 l'adresse publique du pari.\r\n    ///         L'invit\u00e9 va signer un message comportant son adresse pour rendre la signature unique \u00e0 chaque\r\n    ///         paricipant et donc non r\u00e9utilisable par un petit malin voulant s'inscrire au m\u00eame pari et qui utiliserait\r\n    ///         Etherscan pour r\u00e9cup\u00e9er une ancienne signature.\r\n    /// @param  _id identifiant du pari\r\n    /// @param  _rSign partie 'r' de la signature ECDSA du site web certifiant que le participant a bien \u00e9t\u00e9 invit\u00e9\r\n    ///             par l'organisateur du pari.\r\n    /// @param  _sSign partie 's' de la signature ECDSA\r\n    /// @param  _vSign partie 'v' de la signature ECDSA\r\n    /// @param _outcomeId Index de la proposition sur laquelle parier\r\n    function participateAndBet(uint _id, bytes32 _rSign, bytes32 _sSign, uint8 _vSign, uint _outcomeId)\r\n    public payable {\r\n        Bet storage bt = m_bets[_id];\r\n        require(bt.state == State.Open, \"ImproperState\");    // Etat 'ouvert' requis\r\n        require(block.timestamp <= bt.betDeadlineTime, \"DeadlineExpired\");   // Date limite d\u00e9pass\u00e9e\r\n        require(_outcomeId < bt.nbPossibilities, \"OutOfBoundIndex\");// index hors bornes\r\n        require(msg.value >= bt.minimumStake_micro * MICRO_ETH, \"InsufficientStake\"); // mise insuffisante\r\n        \r\n        // v\u00e9rif signature de web3.eth.accounts.sign({participant})\r\n        bytes32 msgHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n20\", msg.sender));\r\n        address signer = ecrecover(msgHash, _vSign, _rSign, _sSign);\r\n        require(signer != address(0), \"InvalidSignature\"); // signature invalide (bug)\r\n        require(signer == bt.guestPubKeyAdr, \"WrongSigner\");  // signataire incorrecte (bug, invitation modifi\u00e9e/d\u00e9sactiv\u00e9e ou tentative de fraude)\r\n        \r\n        uint256 betAmount;\r\n        \r\n        // peut-on encore en ajouter un ?\r\n        if (bt.nbParticipant < NB_MAX_PARTICIPANT) {\r\n            Participant storage p = bt.participants[msg.sender];\r\n            \r\n            // on ajoute uniquement le participant s'il n'est pas d\u00e9j\u00e0 connu\r\n            if (!p.knownUser) {\r\n                // prise en compte du participant\r\n                bt.nbParticipant++;\r\n                emit NewParticiant(_id, msg.sender);\r\n\r\n                // limitation de la somme mis\u00e9e par le plafond\r\n                uint256 totalMaxStake = bt.totalMaxStake_micro * MICRO_ETH;\r\n                betAmount = (msg.value > totalMaxStake) ? totalMaxStake : msg.value;\r\n                // prise en compte du pari\r\n                bt.betAmountByProp[_outcomeId] += betAmount;\r\n                emit NewBet(_id, msg.sender, betAmount, _outcomeId);\r\n                // maj info du Participant\r\n                p.knownUser = true;\r\n                p.betId = uint8(_outcomeId);\r\n                p.totalBet = betAmount;\r\n            }\r\n        }\r\n        \r\n        // remboursement du trop per\u00e7u le cas \u00e9ch\u00e9ant\r\n        if (msg.value > betAmount)\r\n            msg.sender.transfer(msg.value - betAmount);\r\n    }\r\n    \r\n    /// @notice Cr\u00e9ation d'un pari, appel\u00e9 par son futur organisateur. Possible si la cr\u00e9ation de paris n'est pas supendue.\r\n    /// @dev    Emmet un \u00e9venement 'NewBetCreated' pour retourner l'identifiant du pari. Met le pari dans l'\u00e9tat cr\u00e9\u00e9.\r\n    /// @param _externDescriptionId Identifiant 32bits de description externe du pari (lien avec la BDD du site web)\r\n    /// @param _nbPossibilities Nombre de r\u00e9sultats possibles du pari. Au moins 2, 255 max.\r\n    /// @param _betDeadlineTime Date limite pour parier (date UNIX / EPOC). Doit \u00eatre > \u00e0 la date actuelle\r\n    /// @param _minimumStake_micro Mise minimale d'un participant en \u00b5Ether\r\n    /// @param _totalMaxStake_micro Mise maximale totale pour un participant en \u00b5Ether. Doit \u00eatre >= \u00e0 la mise minimale\r\n    /// @param _guestPubKeyAdr pseudo cl\u00e9 publique du pari pour authentifier un invit\u00e9. 0x0 d\u00e9sactive `participate()`\r\n    /// @param _outcomeId Index de la proposition sur laquelle parier\r\n    function createBetAndBet(uint32 _externDescriptionId, uint _nbPossibilities, uint _betDeadlineTime,\r\n                uint32 _minimumStake_micro, uint32 _totalMaxStake_micro, address _guestPubKeyAdr, uint _outcomeId)\r\n    public payable {\r\n        require(!m_createBetDisabled, \"CreateBetDisabled\");  // la cr\u00e9ation de pris est actuellement suspendue\r\n        require(_nbPossibilities >= 2, \"TooFewPossibility\");   // Il faut au moins 2 possibilit\u00e9s\r\n        require(_nbPossibilities < 2**8, \"TooManyPossibilities\");// 255 possibilit\u00e9s max\r\n        require(_betDeadlineTime > block.timestamp, \"DeadlineAlreadyPassed\");   // Date limite d\u00e9j\u00e0 pass\u00e9e\r\n        require(_totalMaxStake_micro >= _minimumStake_micro, \"InvalidTotalMaxStake\");// Mise maximale doit \u00eatre au moins celle minimale\r\n        require(_outcomeId < _nbPossibilities, \"OutOfBoundIndex\");// index hors bornes\r\n        require(msg.value >= _minimumStake_micro * MICRO_ETH, \"InsufficientStake\"); // mise insuffisante\r\n        \r\n        uint nextId = m_bets.length;\r\n        \r\n        Bet storage bt = m_bets.push();\r\n        bt.owner               = msg.sender;\r\n        bt.betDeadlineTime     = uint32(_betDeadlineTime);\r\n        bt.externDescriptionId = _externDescriptionId;\r\n        //bt.state             = State.Open;\r\n        bt.nbPossibilities     = uint8(_nbPossibilities);\r\n        bt.betAmountByProp     = new uint256[](_nbPossibilities);\r\n        bt.guestPubKeyAdr      = _guestPubKeyAdr;\r\n        bt.minimumStake_micro  = _minimumStake_micro;\r\n        bt.totalMaxStake_micro = _totalMaxStake_micro;\r\n        \r\n        emit NewBetCreated(nextId, msg.sender);\r\n        \r\n        Participant storage p = bt.participants[msg.sender];\r\n\r\n        // prise en compte du participant\r\n        bt.nbParticipant++;\r\n        emit NewParticiant(nextId, msg.sender);\r\n        \r\n        // limitation de la somme mis\u00e9e par le plafond\r\n        uint256 totalMaxStake = _totalMaxStake_micro * MICRO_ETH;\r\n        uint256 betAmount = (msg.value > totalMaxStake) ? totalMaxStake : msg.value;\r\n        // prise en compte du pari\r\n        bt.betAmountByProp[_outcomeId] = betAmount;\r\n        emit NewBet(nextId, msg.sender, betAmount, _outcomeId);\r\n        // maj info du Participant\r\n        p.knownUser = true;\r\n        p.betId = uint8(_outcomeId);\r\n        p.totalBet = betAmount;\r\n        \r\n        // remboursement du trop per\u00e7u le cas \u00e9ch\u00e9ant\r\n        if (msg.value > betAmount)\r\n            msg.sender.transfer(msg.value - betAmount);\r\n    }\r\n\r\n    /// @notice Permet \u00e0 *l'organisateur* de donner le r\u00e9sulat de pari. Possible uniquement lorsque le pari est dans\r\n    ///         l'\u00e9tat ouvert et que la date limite de pari est pass\u00e9e.\r\n    /// @dev le pari passe dans l'un des 2 \u00e9tats 'ferm\u00e9'. Emmet l'\u00e9v\u00e9nement 'BetClosed'.\r\n    /// @param  _id identifiant du pari\r\n    /// @param _outcomeId index de proposition gagnante dans la liste des possiblit\u00e9s\r\n    function setBetOutcome(uint _id, uint _outcomeId) public onlyOrganizer(_id) {\r\n        Bet storage bt = m_bets[_id];\r\n        require(bt.state == State.Open, \"ImproperState\");        // Etat 'ouvert' requis\r\n        require(block.timestamp > bt.betDeadlineTime, \"DeadlineNotPassed\");  // Date limite pas encore \u00e9chue\r\n        require(_outcomeId < bt.nbPossibilities, \"OutOfBoundIndex\");//index hors bornes\r\n\r\n        // avons nous un gagnant ?\r\n        bool hasWinner = (bt.betAmountByProp[_outcomeId] > 0);\r\n        if (hasWinner) {\r\n            // calcul du pactole des gagants\r\n            uint256 s;\r\n            uint256[] storage tbl = bt.betAmountByProp; // acc\u00e8s tableau en registre pour optimiser\r\n            uint length = tbl.length;                   // taille en cache pour optimiser\r\n            for(uint i; i < length; i++)\r\n                s += tbl[i];\r\n\r\n            // m\u00e9mo des gains pour calculer les parts de chacun des gagants\r\n            bt.winningsAmount = s;\r\n\r\n            bt.state = State.Closed_Winner;\r\n        } else {\r\n            bt.state = State.Closed_NoWinner;\r\n        }\r\n        \r\n        // m\u00e9mo r\u00e9sultat\r\n        bt.outcomeId = uint8(_outcomeId);\r\n        // retourne si on a un gagnant\r\n        emit BetClosed(_id, hasWinner);\r\n    }\r\n\r\n    /// @notice Permet au *participant* de r\u00e9cup\u00e9rer les mises pari\u00e9es en cas de pari sans gagnant\r\n    ///         ou annul\u00e9. Possible uniquement lorsque le pari est dans l'\u00e9tat 'annul\u00e9' ou 'Ferm\u00e9 sans gagnant'.\r\n    /// @dev Le champs 'Participant.totalBet' est RAZ pour noter le remboursement\r\n    /// @param  _id identifiant du pari\r\n    /// @return amount_ le montant transf\u00e9r\u00e9. Permet de savoir d'avance ce qu'il y a \u00e0 r\u00e9cup\u00e9rer.\r\n    function reimbursement(uint _id) public onlyParticipant(_id) returns(uint256 amount_) {\r\n        Bet storage bt = m_bets[_id];\r\n        require(bt.state == State.Canceled || bt.state == State.Closed_NoWinner, \"ImproperState\"); // Etat incompatible\r\n        \r\n        Participant storage p = bt.participants[msg.sender];\r\n        // qq chose \u00e0 rembourser ?\r\n        if (p.totalBet > 0)\r\n        {\r\n            amount_ = p.totalBet;\r\n            p.totalBet = 0; // on RAZ l'\u00e9tat avant le transfert pour \u00e9viter un hack par r\u00e9entrance\r\n\r\n            emit Transfer(_id, msg.sender, amount_);\r\n            msg.sender.transfer(amount_);\r\n        }\r\n    }\r\n\r\n    /// @notice Permet au *participants gagnants* de r\u00e9cup\u00e9rer leurs gains. Possible uniquement dans l'\u00e9tat\r\n    ///         'Ferm\u00e9 avec gagnant'.\r\n    /// @dev Le champs Participant.betAmountByProp[m_bets[_id].infos.outcomeId] est RAZ pour noter le retrait\r\n    /// @param  _id identifiant du pari\r\n    /// @return amount_ le montant transf\u00e9r\u00e9. Permet de savoir d'avance ce qu'il y a \u00e0 r\u00e9cup\u00e9rer.\r\n    function withdrawWinnings(uint _id) public onlyParticipant(_id) returns(uint256 amount_) {\r\n        Bet storage bt = m_bets[_id];\r\n        require(bt.state == State.Closed_Winner, \"ImproperState\"); // Etat 'ferm\u00e9 avec gagnant' requis\r\n        \r\n        Participant storage p = bt.participants[msg.sender];\r\n        \r\n        // a-t-il gagn\u00e9 ?\r\n        if (p.betId == bt.outcomeId) {\r\n            // calcul du gain commun au prorata de la mise sur la proposition gagante\r\n            amount_ = (bt.winningsAmount * p.totalBet) / bt.betAmountByProp[bt.outcomeId];\r\n        \r\n            // qq chose \u00e0 retirer ?\r\n            if (amount_ > 0) {\r\n                p.totalBet = 0; // on RAZ l'\u00e9tat avant le transfert pour \u00e9viter un hack par r\u00e9entrance\r\n    \r\n                emit Transfer(_id, msg.sender, amount_);\r\n                msg.sender.transfer(amount_);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Transfert le montant donn\u00e9 au cr\u00e9ateur du contrat (d\u00e9veloppeur du syst\u00e8me)\r\n    /// @param  _id identifiant du pari qui a sussit\u00e9 le don\r\n    /// @dev    Leve l'\u00e9venement 'NewDonation'. L'id ne sert que pour l'exploitation sur le site.\r\n    function donate(uint _id) public payable {\r\n        emit NewDonation(_id, msg.sender, msg.value);\r\n        m_owner.transfer(msg.value);\r\n    }\r\n\r\n    /// @notice Permet au *cr\u00e9ateur du syst\u00e8me* de d\u00e9asactiver ou r\u00e9activer la cr\u00e9ation de nouveaux paris\r\n    /// @dev Utile pour migrer en douceur vers une nouvelle version du syst\u00e8me, ou au cas o\u00f9 les choses tourneraient\r\n    ///         mal avec le contrat.\r\n    /// @param _disable true pour d\u00e9asactiver, false pour r\u00e9activer\r\n    function disableBetCreation(bool _disable) public onlyOwner {\r\n        m_createBetDisabled = _disable;\r\n    }\r\n\r\n\r\n/* modifieurs */\r\n\r\n    // s'assure que c'est le cr\u00e9ateur du contrat qui est l'appelant    \r\n    modifier onlyOwner {\r\n        require(msg.sender == m_owner, \"OnlyOwner\"); // Cmd r\u00e9serv\u00e9e au cr\u00e9ateur du contrat\r\n        _;\r\n    }\r\n\r\n    // s'assure que c'est l'organisateur qui est l'appelant    \r\n    modifier onlyOrganizer(uint _id) {\r\n        require(msg.sender == m_bets[_id].owner, \"OnlyOrganizer\"); // Cmd r\u00e9serv\u00e9e \u00e0 l'organisateur\r\n        _;\r\n    }\r\n\r\n    // s'assure que c'est un participant qui est l'appelant    \r\n    modifier onlyParticipant(uint _id) {\r\n        require(m_bets[_id].participants[msg.sender].knownUser, \"OnlyParticipant\"); // Cmd r\u00e9serv\u00e9e \u00e0 un participant inscrit\r\n        _;\r\n    }\r\n\r\n\r\n/* donn\u00e9es priv\u00e9es */\r\n\r\n    Bet[] private           m_bets;     // tableau des donn\u00e9s des paris\r\n    address payable private m_owner;    // adresse du cr\u00e9ateur du contrat, 'payable' pour le tranf\u00e8re des dons\r\n\r\n\r\n/* fonction internes */\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"BetCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"hasWinner\",\"type\":\"bool\"}],\"name\":\"BetClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outcomeId\",\"type\":\"uint256\"}],\"name\":\"NewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"NewBetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDonation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"NewParticiant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NB_MAX_PARTICIPANT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_adrParticipants\",\"type\":\"address[]\"}],\"name\":\"addParticipants\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_outcomeId\",\"type\":\"uint256\"}],\"name\":\"bet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"cancelBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_externDescriptionId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_nbPossibilities\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betDeadlineTime\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_minimumStake_micro\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_totalMaxStake_micro\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_guestPubKeyAdr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_ownerParticipate\",\"type\":\"bool\"}],\"name\":\"createBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_externDescriptionId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_nbPossibilities\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betDeadlineTime\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_minimumStake_micro\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_totalMaxStake_micro\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_guestPubKeyAdr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_outcomeId\",\"type\":\"uint256\"}],\"name\":\"createBetAndBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableBetCreation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_rSign\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_sSign\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_vSign\",\"type\":\"uint8\"}],\"name\":\"getBetInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"outcomeId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nbParticipant\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nbPossibilities\",\"type\":\"uint8\"},{\"internalType\":\"enum PrivateBet.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"externDescriptionId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"betDeadlineTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minimumStake_micro\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"totalMaxStake_micro\",\"type\":\"uint32\"},{\"internalType\":\"uint256[]\",\"name\":\"betAmountByProp\",\"type\":\"uint256[]\"}],\"internalType\":\"struct PrivateBet.BetInfo\",\"name\":\"inf_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNbBetCreated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isParticipant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"m_createBetDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_rSign\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_sSign\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_vSign\",\"type\":\"uint8\"}],\"name\":\"participate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_rSign\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_sSign\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_vSign\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_outcomeId\",\"type\":\"uint256\"}],\"name\":\"participateAndBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"reimbursement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_outcomeId\",\"type\":\"uint256\"}],\"name\":\"setBetOutcome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pubKeyAdr\",\"type\":\"address\"}],\"name\":\"setGuestPubKeyAdr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdrawWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PrivateBet", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c6d7212ff155796d1fed7bbc83d6d20f1577b40ed6a27d84f4a4cd063f6afb83"}