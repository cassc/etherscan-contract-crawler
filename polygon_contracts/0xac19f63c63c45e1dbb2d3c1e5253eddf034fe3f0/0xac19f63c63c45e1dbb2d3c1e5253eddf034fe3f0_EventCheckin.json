{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/IGameAccess.sol\\\";\\n\\ncontract AccessControl is Ownable {\\n    IGameAccess internal _gameAccess;\\n\\n    constructor(address gameAddress) {\\n        _gameAccess = IGameAccess(gameAddress);\\n    }\\n\\n    modifier onlyGameOwner() {\\n        bool isGameAdmin = checkAccess(msg.sender, _gameAccess.getGameAdminAddresses());\\n        bool isInternal = checkAccess(msg.sender, _gameAccess.getInterfaceAddresses());\\n        bool isOwner = msg.sender == owner();\\n        bool isGame = msg.sender == address(_gameAccess);\\n\\n        require(isGameAdmin || isInternal || isOwner || isGame, \\\"WorldAccess: caller is not GameOwner\\\");\\n        _;\\n    }\\n\\n    function setGameAddress(address gameAddress) public virtual onlyGameOwner {\\n        _gameAccess = IGameAccess(gameAddress);\\n    }\\n\\n    function checkAccess(address sender, address[] memory addresses) internal view returns(bool) {\\n        bool result = false;\\n        for (uint256 i = 0; i < addresses.length; i++) {\\n            if (addresses[i] == sender) {\\n                result = true;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/WorldAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/IGameAccess.sol\\\";\\nimport \\\"./AccessControl.sol\\\";\\n\\ncontract WorldAccess is Ownable, AccessControl {\\n    uint256 internal _worldId;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    AccessControl(gameAddress) {\\n        _worldId = worldId;\\n    }\\n\\n    modifier onlyGame() {\\n        bool isInternal = checkAccess(msg.sender, _gameAccess.getInterfaceAddresses());\\n        bool isGameAdmin = checkAccess(msg.sender, _gameAccess.getGameAdminAddresses());\\n        bool isWorldOwner = checkAccess(msg.sender, _gameAccess.getWorldOwnerAddresses(_worldId));\\n        bool isItemPackNFT = checkAccess(msg.sender, _gameAccess.getItemPackNFTAddresses(_worldId));\\n        bool isOwner = msg.sender == owner();\\n        bool isGame = msg.sender == address(_gameAccess);\\n\\n        require(isInternal || isGameAdmin || isWorldOwner || isItemPackNFT || isOwner || isGame, \\\"WorldAccess: caller is not Game/Owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyWorldAdmin() {\\n        bool isGameAdmin = checkAccess(msg.sender, _gameAccess.getGameAdminAddresses());\\n        bool isWorldOwner = checkAccess(msg.sender, _gameAccess.getWorldOwnerAddresses(_worldId));\\n        bool isWorldAdmin = checkAccess(msg.sender, _gameAccess.getWorldAdminAddresses(_worldId));\\n        bool isOwner = msg.sender == owner();\\n        bool isGame = msg.sender == address(_gameAccess);\\n\\n        require(isWorldAdmin || isGameAdmin || isWorldOwner || isOwner || isGame, \\\"WorldAccess: caller is not WorldAdmin\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/Character.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract Character is WorldAccess {\\n    // key: tokenId, value: characterDefinitionId\\n    mapping(uint256 => uint256) public characterDefinitionIds;\\n\\n    // key: tokenId, value: isRevealed\\n    mapping(uint256 => bool) public isRevealeds;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function setIsRevealed(uint256 tokenId_, bool isRevealed_) public virtual onlyGame {\\n        isRevealeds[tokenId_] = isRevealed_;\\n    }\\n\\n    function setCharacterDefinitionId(uint256 tokenId_, uint256 characterDefinitionId_) public virtual onlyGame {\\n        characterDefinitionIds[tokenId_] = characterDefinitionId_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/CharacterEdition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract CharacterEdition is WorldAccess {\\n    struct CharacterEditionRecord {\\n        uint256[] characterDefinitionIds;\\n        uint256[] weights;\\n        uint256[][] itemPackDefinitionIds;\\n    }\\n\\n    // key: characterEditionId, (key: characterDefinitionId, value: CharacterDefinitionId)\\n    mapping(uint256 => CharacterEditionRecord) private _records;\\n    // key: tokenId, value: characterEditionId\\n    mapping(uint256 => uint256) public tokenAndEditions;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function getCharacterEditionRecord(uint256 characterEditionId) public view returns(CharacterEditionRecord memory) {\\n        return _records[characterEditionId];\\n    }\\n\\n    function setCharacterEdition(uint256 characterEditionId, CharacterEditionRecord calldata record) public onlyGame {\\n        _records[characterEditionId] = record;\\n    }\\n\\n    function setTokenIdsToCharacterEdition(uint256 characterEditionId, uint256[] calldata tokenIds) public onlyGame {\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            tokenAndEditions[tokenIds[i]] = characterEditionId;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/Equipment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract Equipment is WorldAccess {\\n    // key: tokenId, value: array of equipped itemId\\n    mapping(uint256 => uint256[]) public equipments;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function getEquipments(uint256 tokenId) public virtual view returns(uint256[] memory) {\\n        return equipments[tokenId];\\n    }\\n\\n    function setEquipments(uint256 tokenId, uint256[] memory itemIds) public virtual onlyGame {\\n        equipments[tokenId] = itemIds;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/EventCheckinLog.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract EventCheckinLog is WorldAccess {\\n    struct EventCheckinLogRecord {\\n        address playerWallet;\\n        uint256 eventDefinitionId;\\n        uint256 timestamp;\\n    }\\n\\n    uint256 public checkinCount;\\n\\n    // key: eventDefinitionId, value: count\\n    mapping(uint256 => uint256) public checkinCountsPerEvent;\\n\\n    // key: Player Wallet, value: (key: eventDefinitionId, value: count)\\n    mapping(address => mapping(uint256 => uint256)) public checkinCountsPerPlayer;\\n\\n    // key: Player Wallet, value: (key: eventDefinitionId, value: timestamp(sec))\\n    mapping(address => mapping(uint256 => uint256)) public checkinTimeStampPerPlayer;\\n\\n    // key: logId, value: (key: eventDefinitionId, value: timestamp(sec))\\n    mapping(uint256 => EventCheckinLogRecord) public logs;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function log(address playerWallet, uint256 eventDefinitionId) public onlyGame {\\n        checkinCount++;\\n        checkinCountsPerEvent[eventDefinitionId]++;\\n        checkinCountsPerPlayer[playerWallet][eventDefinitionId]++;\\n        checkinTimeStampPerPlayer[playerWallet][eventDefinitionId] = block.timestamp;\\n    }\\n\\n    // @deprecated\\n    function getLogs(uint256[] calldata logIds) public view returns(EventCheckinLogRecord[] memory) {\\n        EventCheckinLogRecord[] memory records = new EventCheckinLogRecord[](logIds.length);\\n        for (uint256 i = 0; i < logIds.length; i++) {\\n            EventCheckinLogRecord memory record = logs[logIds[i]];\\n            records[i] = EventCheckinLogRecord(\\n                record.playerWallet,\\n                record.eventDefinitionId,\\n                record.timestamp\\n            );\\n        }\\n\\n        return records;\\n    }\\n}\"\r\n    },\r\n    \"contracts/data/ItemPack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../lib/IDArrayUtil.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/token/IItemPackNFT.sol\\\";\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract ItemPack is WorldAccess {\\n    uint256 private _currentIndex;\\n\\n    struct ItemPackRecord {\\n        uint256 itemPackId;\\n        uint256 itemPackDefinitionId;\\n        address playerWallet;\\n        address nftAddress;\\n        uint256 tokenId;\\n        bool isRevealed;\\n    }\\n\\n    // key: itemPackId, value: array of ItemPackRecord\\n    mapping(uint256 => ItemPackRecord) public itemPackRecords;\\n\\n    // key: NFT contract address, value: (key: tokenId, value: itemPackId)\\n    mapping(address => mapping(uint256 => uint256)) public itemPackIdsByNft;\\n\\n    // key: Wallet address, array of itemPackId\\n    mapping(address => uint256[]) private _itemPackIdsByWallet;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function mintToWallet(address playerWallet, uint256 itemPackDefinitionId_) public virtual onlyGame {\\n        _mint(itemPackDefinitionId_, playerWallet, address(0), 0);\\n    }\\n\\n    function mintByNFT(address nftAddress, uint256 tokenId, uint256 itemPackDefinitionId_) public virtual onlyGame {\\n        _mint(itemPackDefinitionId_, address(0), nftAddress, tokenId);\\n    }\\n\\n    function burnByNFT(address nftAddress, uint256 tokenId) public virtual onlyGame {\\n        _burn(itemPackIdsByNft[nftAddress][tokenId]);\\n    }\\n\\n    function burn(uint256 itemPackId) public virtual onlyGame {\\n        _burn(itemPackId);\\n    }\\n\\n    function _mint(uint256 itemPackDefinitionId_, address playerWallet, address nftAddress, uint256 tokenId) internal virtual {\\n        _currentIndex++;\\n\\n        if (playerWallet != address(0)) {\\n            _itemPackIdsByWallet[playerWallet].push(_currentIndex);\\n        }\\n\\n        if (nftAddress != address(0) && tokenId != 0) {\\n            itemPackIdsByNft[nftAddress][tokenId] = _currentIndex;\\n        }\\n\\n        itemPackRecords[_currentIndex] = ItemPackRecord(\\n            _currentIndex,\\n            itemPackDefinitionId_,\\n            playerWallet,\\n            nftAddress,\\n            tokenId,\\n            false\\n        );\\n    }\\n\\n    using IDArrayUtil for uint256[];\\n\\n    function _burn(uint256 itemPackId) internal virtual {\\n        address playerWallet = itemPackRecords[itemPackId].playerWallet;\\n        if (playerWallet != address(0)) {\\n            _itemPackIdsByWallet[playerWallet].removeById(itemPackId);\\n        }\\n\\n        itemPackRecords[itemPackId] = ItemPackRecord(itemPackId, 0, address(0), address(0), 0, true);\\n    }\\n\\n    function getItemPackIds(address playerWallet) public virtual view returns(uint256[] memory) {\\n        return _itemPackIdsByWallet[playerWallet];\\n    }\\n\\n    function itemPackDefinitionId(uint256 itemPackId) public virtual view returns (uint256) {\\n        return itemPackRecords[itemPackId].itemPackDefinitionId;\\n    }\\n\\n    function itemPackTokenId(uint256 itemPackId) public virtual view returns (uint256) {\\n        return itemPackRecords[itemPackId].tokenId;\\n    }\\n\\n    function isRevealed(uint256 itemPackId) public virtual view returns (bool) {\\n        return itemPackRecords[itemPackId].isRevealed;\\n    }\\n\\n    function getItemPackRecord(uint256 itemPackId) public virtual view returns (ItemPackRecord memory) {\\n        return itemPackRecords[itemPackId];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/ItemStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract ItemStorage is WorldAccess {\\n    // key: tokenId, (key: itemDefinitionId, value: itemCount)\\n    mapping(uint256 => mapping(uint256 => int64)) public items;\\n\\n    // key: tokenId, (key: itemDefinitionId, value: timestamp)\\n    mapping(uint256 => mapping(uint256 => uint256)) public lastAcquisitionTimestamps;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function addItems(uint256 tokenId, uint256[] calldata itemDefinitionIds, int64[] calldata amounts) public virtual onlyGame {\\n        require(itemDefinitionIds.length == amounts.length, \\\"wrong length\\\");\\n\\n        for (uint i = 0; i < itemDefinitionIds.length; i++) {\\n            addItem(tokenId, itemDefinitionIds[i], amounts[i]);\\n        }\\n    }\\n\\n    function addItem(uint256 tokenId, uint256 itemDefinitionId, int64 amount) public virtual onlyGame {\\n        items[tokenId][itemDefinitionId] += amount;\\n        if (amount > 0) {\\n            lastAcquisitionTimestamps[tokenId][itemDefinitionId] = block.timestamp;\\n        }\\n    }\\n\\n    function getItems(uint256 tokenId, uint256[] memory itemDefinitionIds) public virtual view returns(int64[] memory) {\\n        int64[] memory result = new int64[](itemDefinitionIds.length);\\n        for (uint256 i = 0; i < itemDefinitionIds.length; i++) {\\n            result[i] = items[tokenId][itemDefinitionIds[i]];\\n        }\\n\\n        return result;\\n    }\\n\\n    function hasItem(uint256 tokenId, uint256 itemDefinitionId, int64 amount) public virtual view returns(bool) {\\n        return items[tokenId][itemDefinitionId] >= amount;\\n    }\\n\\n    function getLastAcquisitionTimestamps(uint256 tokenId, uint256[] calldata itemDefinitionIds) public virtual view returns(uint256[] memory) {\\n        uint256[] memory result = new uint256[](itemDefinitionIds.length);\\n        for (uint256 i = 0; i < itemDefinitionIds.length; i++) {\\n            result[i] = lastAcquisitionTimestamps[tokenId][itemDefinitionIds[i]];\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/definitions/CharacterDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract CharacterDefinition is WorldAccess {\\n    enum EquipmentSlot { Invalid, Normal }\\n\\n    // key: characterDefinitionId\\n    mapping(uint256 => bool) characters;\\n\\n    // key: characterDefinitionId\\n    mapping(uint256 => EquipmentSlot[]) public equipmentSlots;\\n\\n    // key: characterDefinitionId, value: (key: itemId, value: equipmentSlotIndex)\\n    mapping(uint256 => mapping(uint256 => uint256)) public equipableItems;\\n\\n    // key: characterDefinitionId, value: array of itemDefinitionId\\n    mapping(uint256 => uint256[]) public defaultEquipmentIds;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function setCharacter(uint256 characterDefinitionId, bool enabled) public virtual onlyWorldAdmin {\\n        require(characterDefinitionId > 0);\\n\\n        characters[characterDefinitionId] = enabled;\\n    }\\n\\n    function setEquipmentSlots(uint256 characterDefinitionId, EquipmentSlot[] memory equipmentSlots_) public virtual onlyWorldAdmin {\\n        require(characters[characterDefinitionId], \\\"character disabled\\\");\\n        require(equipmentSlots_.length > 0);\\n\\n        equipmentSlots[characterDefinitionId] = equipmentSlots_;\\n    }\\n\\n    function getEquipmentSlots(uint256 characterDefinitionId) public view virtual returns(EquipmentSlot[] memory) {\\n        return equipmentSlots[characterDefinitionId];\\n    }\\n\\n    function isValidEquipmentSlot(uint256 characterDefinitionId, uint256 equipmentSlotIndex) public view virtual returns(bool) {\\n        return equipmentSlotIndex < equipmentSlots[characterDefinitionId].length && equipmentSlots[characterDefinitionId][equipmentSlotIndex] != EquipmentSlot.Invalid;\\n    }\\n\\n    function setEquipable(uint256 characterDefinitionId, uint256 itemId, uint256 equipmentSlotIndex) public virtual onlyWorldAdmin {\\n        require(characters[characterDefinitionId]);\\n\\n        equipableItems[characterDefinitionId][itemId] = equipmentSlotIndex;\\n    }\\n\\n    function setDefaultEquipment(uint256 characterDefinitionId, uint256 itemId, uint256 equipmentSlotIndex) public onlyWorldAdmin {\\n        if (defaultEquipmentIds[characterDefinitionId][equipmentSlotIndex] <= itemId) {\\n            defaultEquipmentIds[characterDefinitionId][equipmentSlotIndex] = itemId;\\n        }\\n    }\\n\\n    function canEquip(uint256 characterDefinitionId, uint256 itemId, uint256 equipmentSlotIndex) public virtual view returns(bool) {\\n        return equipableItems[characterDefinitionId][itemId] == equipmentSlotIndex || itemId == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/definitions/EventDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract EventDefinition is WorldAccess {\\n    struct EventDefinitionRecord {\\n        uint256 eventDefinitionId;\\n        bool enabled;\\n        uint256 itemPackDefinitionId;\\n        address eventNftAddress;\\n        uint256 executableTimes;\\n        uint256 executableTimesPerUser;\\n        uint256 endPeriod;\\n        uint256 userExecutableInterval;\\n        bool gpsCheckEnabled;\\n    }\\n\\n    mapping(uint256 => EventDefinitionRecord) private _eventDefinitions;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function getItemPackDefinitionId(uint256 eventDefinitionId) public virtual view returns(uint256) {\\n        EventDefinitionRecord memory record = _eventDefinitions[eventDefinitionId];\\n\\n        return record.itemPackDefinitionId;\\n    }\\n\\n    function getEventDefinition(uint256 eventDefinitionId) external virtual view returns(\\n            uint256, bool, uint256, address, uint256, uint256, uint256, uint256, bool) {\\n        EventDefinitionRecord memory record = _eventDefinitions[eventDefinitionId];\\n\\n        return (\\n            record.eventDefinitionId,\\n            record.enabled,\\n            record.itemPackDefinitionId,\\n            record.eventNftAddress,\\n            record.executableTimes,\\n            record.executableTimesPerUser,\\n            record.endPeriod,\\n            record.userExecutableInterval,\\n            record.gpsCheckEnabled\\n        );\\n    }\\n\\n    function setEventDefinitions(EventDefinitionRecord[] memory eventDefinitions_) public virtual onlyWorldAdmin {\\n        for (uint256 i = 0; i < eventDefinitions_.length; i++) {\\n            EventDefinitionRecord memory record = eventDefinitions_[i];\\n            _addEventDefinition(\\n                record.eventDefinitionId,\\n                record.enabled,\\n                record.itemPackDefinitionId,\\n                record.eventNftAddress,\\n                record.executableTimes,\\n                record.executableTimesPerUser,\\n                record.endPeriod,\\n                record.userExecutableInterval,\\n                record.gpsCheckEnabled\\n            );\\n        }\\n    }\\n\\n    function _addEventDefinition(\\n        uint256 eventDefinitionId,\\n        bool enabled_,\\n        uint256 itemPackDefinitionId_,\\n        address eventNftAddress_,\\n        uint256 executableTimes_,\\n        uint256 executableTimesPerUser_,\\n        uint256 endPeriod_,\\n        uint256 userExecutableInterval,\\n        bool gpsCheckEnabled\\n    ) private {\\n        _eventDefinitions[eventDefinitionId] = EventDefinitionRecord(\\n            eventDefinitionId,\\n            enabled_,\\n            itemPackDefinitionId_,\\n            eventNftAddress_,\\n            executableTimes_,\\n            executableTimesPerUser_,\\n            endPeriod_,\\n            userExecutableInterval,\\n            gpsCheckEnabled\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/definitions/ItemDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"ttt-contract-interfaces/contracts/definitions/IItemDefinition.sol\\\";\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract ItemDefinition is IItemDefinition, WorldAccess {\\n    mapping(uint256 => IItemDefinition.ItemDefinitionRecord) itemDefinitionRecords;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function _setDefinition(IItemDefinition.ItemDefinitionRecord calldata record) internal {\\n        itemDefinitionRecords[record.itemDefinitionId] = record;\\n    }\\n\\n    function setDefinitions(IItemDefinition.ItemDefinitionRecord[] calldata records) external override onlyWorldAdmin {\\n        for (uint256 i = 0; i < records.length; i++) {\\n            _setDefinition(records[i]);\\n        }\\n    }\\n\\n    function getDefinition(uint256 itemDefinitionId_) external view returns(ItemDefinitionRecord memory) {\\n        return itemDefinitionRecords[itemDefinitionId_];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/definitions/ItemPackDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract ItemPackDefinition is WorldAccess {\\n    struct SlotDefinition {\\n        uint256[] itemDefinitionIds;\\n        uint256[] weights;\\n        int64[] amounts;\\n    }\\n\\n    // key: itemPackDefinitionId\\n    mapping(uint256 => SlotDefinition[]) private _slotDefinitions;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function getSlotLength(uint256 itemPackDefinitionId) public virtual view returns(uint256) {\\n        return _slotDefinitions[itemPackDefinitionId].length;\\n    }\\n\\n    function getSlotDefinition(uint256 itemPackDefinitionId, uint256 slot) public virtual view returns(uint256[] memory, uint256[] memory, int64[] memory) {\\n        SlotDefinition memory s = _slotDefinitions[itemPackDefinitionId][slot];\\n\\n        return (s.itemDefinitionIds, s.weights, s.amounts);\\n    }\\n\\n    function setItemPackDefinition(uint256 itemPackDefinitionId, SlotDefinition[] memory itemPacks) public virtual onlyWorldAdmin {\\n        delete _slotDefinitions[itemPackDefinitionId];\\n        for (uint256 i = 0; i < itemPacks.length; i++) {\\n            SlotDefinition memory itemPack = itemPacks[i];\\n\\n            // TODO: check itemId\\n            require(itemPack.itemDefinitionIds.length > 0 && itemPack.itemDefinitionIds.length <= 100, \\\"wrong itemDefinitionIds length\\\");\\n            require(itemPack.itemDefinitionIds.length == itemPack.amounts.length, \\\"wrong amounts length\\\");\\n            require(itemPack.itemDefinitionIds.length == itemPack.weights.length, \\\"wrong weights length\\\");\\n\\n            _slotDefinitions[itemPackDefinitionId].push(itemPacks[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Game.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/IWorld.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/IGameAccess.sol\\\";\\n\\ncontract Game is IGameAccess, Ownable {\\n    mapping(uint256 => address) public worlds;\\n    mapping(uint256 => address[]) public worldAdmins;\\n    address[] public gameAdmins;\\n\\n    // key: interface name\\n    mapping(string => address) public gameInterfaces;\\n\\n    string[] public gameInterfaceKeys;\\n\\n    constructor() {\\n    }\\n\\n    function setInterfaceAddress(string memory key, address interfaceAddress) public onlyOwner {\\n        _setInterfaceAddress(key, interfaceAddress);\\n    }\\n\\n    function _setInterfaceAddress(string memory key, address interfaceAddress) private {\\n        require(_validKey(key), \\\"wrong key\\\");\\n\\n        gameInterfaces[key] = interfaceAddress;\\n    }\\n\\n    function _validKey(string memory key) private view returns(bool) {\\n        for (uint256 i = 0; i < gameInterfaceKeys.length; i++) {\\n            if (keccak256(abi.encodePacked(gameInterfaceKeys[i])) == keccak256(abi.encodePacked(key))) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function setInterfaceAddressKeys(string[] memory keys) public onlyOwner {\\n        gameInterfaceKeys = keys;\\n    }\\n\\n    function setWorld(uint256 worldId, address worldAddress) public onlyOwner {\\n        worlds[worldId] = worldAddress;\\n        IWorld world = IWorld(worldAddress);\\n        world.setGame(address(this));\\n    }\\n\\n    function getInterfaceAddress(string calldata key) external view returns(address) {\\n        return gameInterfaces[key];\\n    }\\n\\n    function setWorldAdmins(uint256 worldId, address[] calldata admins) public onlyOwner {\\n        worldAdmins[worldId] = admins;\\n    }\\n\\n    function setGameAdmins(address[] calldata admins) public onlyOwner {\\n        gameAdmins = admins;\\n    }\\n\\n    // ==============================\\n    //          IGameAccess\\n    // ==============================\\n    function getInterfaceAddresses() external view override returns(address[] memory) {\\n        address[] memory addresses = new address[](gameInterfaceKeys.length);\\n        for (uint256 i = 0; i < gameInterfaceKeys.length; i++) {\\n            string memory key = gameInterfaceKeys[i];\\n            addresses[i] = gameInterfaces[key];\\n        }\\n\\n        return addresses;\\n    }\\n\\n    function getWorldOwnerAddresses(uint256 worldId) external view override returns(address[] memory) {\\n        address[] memory addresses = new address[](2);\\n        addresses[0] = this.owner();\\n        addresses[1] = worlds[worldId];\\n\\n        return addresses;\\n    }\\n\\n    function getWorldAdminAddresses(uint256 worldId) external view override returns(address[] memory) {\\n        return worldAdmins[worldId];\\n    }\\n\\n    function getGameAdminAddresses() external view override returns(address[] memory) {\\n        return gameAdmins;\\n    }\\n\\n    function getTokenOwnerAddress(uint256 worldId, uint256 tokenId) external view override returns(address) {\\n        IWorld world = IWorld(worlds[worldId]);\\n\\n        return world.getL1NFT().getOwner(tokenId);\\n    }\\n\\n    function getItemPackNFTAddresses(uint256 worldId) external view override returns(address[] memory) {\\n        IWorld world = IWorld(worlds[worldId]);\\n        IItemPackNFT[] memory itemPacNFTs = world.getItemPackNFTs();\\n\\n        address[] memory addresses = new address[](itemPacNFTs.length);\\n        for (uint256 i = 0; i < itemPacNFTs.length; i++) {\\n            addresses[i] = address(itemPacNFTs[i]);\\n        }\\n\\n        return addresses;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/game/EventCheckin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"ttt-contract-interfaces/contracts/IEventCheckin.sol\\\";\\nimport \\\"../data/Character.sol\\\";\\nimport \\\"./GameBase.sol\\\";\\nimport \\\"../definitions/EventDefinition.sol\\\";\\nimport \\\"../definitions/ItemPackDefinition.sol\\\";\\nimport \\\"../data/ItemPack.sol\\\";\\nimport \\\"./WorldStore.sol\\\";\\n\\ncontract EventCheckin is IEventCheckin, GameBase, AccessControl {\\n    uint256 public checkinCount;\\n\\n    constructor(address game)\\n    GameBase(game)\\n    AccessControl(game) {\\n    }\\n\\n    function validateCheckin(address playerWallet, uint256 worldId, uint256 eventDefinitionId) external override view returns(bool, bool, bool, bool, bool, bool) {\\n        World world = getWorld(worldId);\\n        EventCheckinLog eventCheckinLog = world.eventCheckinLog();\\n        EventDefinition eventDefinition = world.eventDefinition();\\n\\n        bool enabled = _checkEnabled(eventDefinition, eventDefinitionId);\\n        bool executableTime = _checkExecutableTimes(playerWallet, eventCheckinLog, eventDefinition, eventDefinitionId);\\n        bool executableTimePerPlayer = _checkExecutableTimesPerPlayer(playerWallet, eventCheckinLog, eventDefinition, eventDefinitionId);\\n        bool endPeriod = _checkEndPeriod(playerWallet, eventDefinition, eventDefinitionId);\\n        bool interval = _checkInterval(playerWallet, eventCheckinLog, eventDefinition, eventDefinitionId);\\n        bool executable = enabled && executableTime && executableTimePerPlayer && endPeriod && interval;\\n\\n        return (executable, enabled, executableTime, executableTimePerPlayer, endPeriod, interval);\\n    }\\n\\n    function _validateCheckin(address playerWallet, EventCheckinLog eventCheckinLog, EventDefinition eventDefinition, uint256 eventDefinitionId) internal {\\n        require(_checkEnabled(eventDefinition, eventDefinitionId), \\\"Disabled\\\");\\n        require(_checkExecutableTimes(playerWallet, eventCheckinLog, eventDefinition, eventDefinitionId), \\\"Exceeded limit\\\");\\n        require(_checkExecutableTimesPerPlayer(playerWallet, eventCheckinLog, eventDefinition, eventDefinitionId), \\\"Exceeded limit per user\\\");\\n        require(_checkEndPeriod(playerWallet, eventDefinition, eventDefinitionId), \\\"Finished event\\\");\\n        require(_checkInterval(playerWallet, eventCheckinLog, eventDefinition, eventDefinitionId), \\\"wrong interval check\\\");\\n    }\\n\\n    function checkin(address playerWallet, uint256 worldId, uint256 eventDefinitionId) external virtual override onlyGameOwner {\\n        World world = getWorld(worldId);\\n        EventCheckinLog eventCheckinLog = world.eventCheckinLog();\\n        EventDefinition eventDefinition = world.eventDefinition();\\n\\n        _validateCheckin(playerWallet, eventCheckinLog, eventDefinition, eventDefinitionId);\\n\\n        eventCheckinLog.log(playerWallet, eventDefinitionId);\\n        uint256 itemPackDefinitionId = eventDefinition.getItemPackDefinitionId(eventDefinitionId);\\n\\n        if (itemPackDefinitionId == 0) {\\n            emit Checkin(playerWallet, worldId, eventDefinitionId, 0, 0);\\n            return;\\n        }\\n\\n        _mintItemPack(playerWallet, world, itemPackDefinitionId, eventDefinitionId);\\n    }\\n\\n    function getEventDefinition(uint256 worldId_, uint256 eventDefinitionId_) external virtual view returns(\\n            uint256, bool, uint256, address, uint256, uint256, uint256, uint256, bool) {\\n        World world = getWorld(worldId_);\\n        EventDefinition eventDefinition = world.eventDefinition();\\n\\n        return eventDefinition.getEventDefinition(eventDefinitionId_);\\n    }\\n\\n    function getCheckinCount(uint256 worldId) external override view returns(uint256) {\\n        WorldStore store = WorldStore(_game.getInterfaceAddress(\\\"WorldStore\\\"));\\n        EventCheckinLog eventCheckinLog = EventCheckinLog(store.getDataContract(worldId, \\\"EventCheckinLog\\\"));\\n\\n        return eventCheckinLog.checkinCount();\\n    }\\n\\n    function getCheckinCountPerEvent(uint256 worldId, uint256 eventDefinitionId) external override view returns(uint256) {\\n        WorldStore store = WorldStore(_game.getInterfaceAddress(\\\"WorldStore\\\"));\\n        EventCheckinLog eventCheckinLog = EventCheckinLog(store.getDataContract(worldId, \\\"EventCheckinLog\\\"));\\n\\n        return eventCheckinLog.checkinCountsPerEvent(eventDefinitionId);\\n    }\\n\\n\\n    function getCheckinCountFromPlayer(address playerWallet, uint256 worldId, uint256 eventDefinitionId) external override view returns(uint256) {\\n        WorldStore store = WorldStore(_game.getInterfaceAddress(\\\"WorldStore\\\"));\\n        EventCheckinLog eventCheckinLog = EventCheckinLog(store.getDataContract(worldId, \\\"EventCheckinLog\\\"));\\n\\n        return eventCheckinLog.checkinCountsPerPlayer(playerWallet, eventDefinitionId);\\n    }\\n\\n    function getLatestCheckinTimestampFromPlayer(address playerWallet, uint256 worldId, uint256 eventDefinitionId) external override view returns(uint256) {\\n        WorldStore store = WorldStore(_game.getInterfaceAddress(\\\"WorldStore\\\"));\\n        EventCheckinLog eventCheckinLog = EventCheckinLog(store.getDataContract(worldId, \\\"EventCheckinLog\\\"));\\n\\n        return eventCheckinLog.checkinTimeStampPerPlayer(playerWallet, eventDefinitionId);\\n    }\\n\\n    function _mintItemPack(address playerWallet, World world, uint256 itemPackDefinitionId, uint256 eventDefinitionId) private {\\n        ItemPack itemPack = world.itemPack();\\n        itemPack.mintToWallet(playerWallet, itemPackDefinitionId);\\n\\n        uint256[] memory itemPackIds = itemPack.getItemPackIds(playerWallet);\\n\\n        emit Checkin(playerWallet, world.worldId(), eventDefinitionId, itemPackDefinitionId, itemPackIds[itemPackIds.length - 1]);\\n    }\\n\\n    function _checkEnabled(EventDefinition eventDefinition, uint256 eventDefinitionId) private view returns(bool) {\\n        (,bool enabled,,,,,,,) = eventDefinition.getEventDefinition(eventDefinitionId);\\n\\n        return enabled;\\n    }\\n\\n    function _checkExecutableTimes(address playerWallet_, EventCheckinLog eventCheckinLog, EventDefinition eventDefinition, uint256 eventDefinitionId) private view returns(bool) {\\n        (,,,, uint256 executableTimes_,,,,) = eventDefinition.getEventDefinition(eventDefinitionId);\\n        uint256 currentCount = eventCheckinLog.checkinCountsPerEvent(eventDefinitionId);\\n\\n        return currentCount < executableTimes_ || executableTimes_ == 0;\\n    }\\n\\n    function _checkExecutableTimesPerPlayer(address playerWallet_, EventCheckinLog eventCheckinLog, EventDefinition eventDefinition, uint256 eventDefinitionId) private view returns(bool) {\\n        (,,,,, uint256 executableTimesPerPlayer_,,,) = eventDefinition.getEventDefinition(eventDefinitionId);\\n        uint256 count = eventCheckinLog.checkinCountsPerPlayer(playerWallet_, eventDefinitionId);\\n\\n        return count < executableTimesPerPlayer_ || executableTimesPerPlayer_ == 0;\\n    }\\n\\n    function _checkEndPeriod(address playerWallet_, EventDefinition eventDefinition, uint256 eventDefinitionId) private view returns(bool) {\\n        (,,,,,, uint256 endPeriod,,) = eventDefinition.getEventDefinition(eventDefinitionId);\\n\\n        return block.timestamp < endPeriod || endPeriod == 0;\\n    }\\n\\n    function _checkInterval(address playerWallet_, EventCheckinLog eventCheckinLog, EventDefinition eventDefinition, uint256 eventDefinitionId) private view returns(bool) {\\n        (,,,,,,,uint256 userExecutableInterval,) = eventDefinition.getEventDefinition(eventDefinitionId);\\n        uint256 lastCheckinTimestamp = eventCheckinLog.checkinTimeStampPerPlayer(playerWallet_, eventDefinitionId);\\n\\n        return block.timestamp > lastCheckinTimestamp + userExecutableInterval || userExecutableInterval == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/game/GameBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"../Game.sol\\\";\\nimport \\\"../World.sol\\\";\\nimport \\\"../data/Character.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/definitions/IItemDefinition.sol\\\";\\n\\ncontract GameBase {\\n    Game internal _game;\\n\\n    constructor(address game) {\\n        _game = Game(game);\\n    }\\n\\n    function getWorld(uint256 worldId) internal view virtual returns(World) {\\n        return World(_game.worlds(worldId));\\n    }\\n\\n    function getItemDefinition(uint256 worldId) internal view virtual returns(IItemDefinition) {\\n        World world = getWorld(worldId);\\n        if (address(world) == address(0)) {\\n            return IItemDefinition(address(0));\\n        }\\n\\n        return world.itemDefinition();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/game/WorldStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"../access/AccessControl.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/IWorldStore.sol\\\";\\n\\ncontract WorldStore is IWorldStore, AccessControl {\\n    // key: definition name\\n    string[] public definitionKeys;\\n\\n    // key: worldId, value: (key: key, value: contract address)\\n    mapping(uint256 => mapping(string => address)) private _definitions;\\n\\n    // key: data contract name\\n    string[] public dataContractKeys;\\n\\n    // key: worldId, value: (key: key, value: contract address)\\n    mapping(uint256 => mapping(string => address)) private _dataContract;\\n\\n    // key: data contract name\\n    string[] public tokenContractKeys;\\n\\n    // key: worldId, value: (key: key, value: contract address)\\n    mapping(uint256 => mapping(string => address)) private _tokenContracts;\\n\\n    constructor(address game)\\n    AccessControl(game) {\\n    }\\n\\n    function getDefinition(uint256 worldId, string memory key) external view returns(address) {\\n        return _definitions[worldId][key];\\n    }\\n\\n    function setDefinition(uint256 worldId, string memory key, address definition) external onlyGameOwner {\\n        require(_validDefinitionKey(key), \\\"wrong key\\\");\\n\\n        _definitions[worldId][key] = definition;\\n    }\\n\\n    function getDefinitionKeys() external view returns(string[] memory) {\\n        return definitionKeys;\\n    }\\n\\n    function setDefinitionKeys(string[] memory keys) external onlyGameOwner {\\n        definitionKeys = keys;\\n    }\\n\\n    function _validDefinitionKey(string memory key) private view returns(bool) {\\n        for (uint256 i = 0; i < definitionKeys.length; i++) {\\n            if (keccak256(abi.encodePacked(definitionKeys[i])) == keccak256(abi.encodePacked(key))) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function getDataContract(uint256 worldId, string memory key) external view returns(address) {\\n        return _dataContract[worldId][key];\\n    }\\n\\n    function setDataContract(uint256 worldId, string memory key, address definition) external onlyGameOwner {\\n        require(_validDataContractKey(key), \\\"wrong key\\\");\\n\\n        _dataContract[worldId][key] = definition;\\n    }\\n\\n    function getDataContractKeys() external view returns(string[] memory) {\\n        return dataContractKeys;\\n    }\\n\\n    function setDataContractKeys(string[] memory keys) external onlyGameOwner {\\n        dataContractKeys = keys;\\n    }\\n\\n    function _validDataContractKey(string memory key) private view returns(bool) {\\n        for (uint256 i = 0; i < dataContractKeys.length; i++) {\\n            if (keccak256(abi.encodePacked(dataContractKeys[i])) == keccak256(abi.encodePacked(key))) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function getTokenContract(uint256 worldId, string memory key) external view returns(address) {\\n        return _tokenContracts[worldId][key];\\n    }\\n\\n    function setTokenContract(uint256 worldId, string memory key, address contractAddress) external onlyGameOwner {\\n        require(_validTokenContractKey(key), \\\"wrong key\\\");\\n\\n        _tokenContracts[worldId][key] = contractAddress;\\n    }\\n\\n    function getTokenContractKeys() external view returns(string[] memory) {\\n        return tokenContractKeys;\\n    }\\n\\n    function setTokenContractKeys(string[] memory keys) external onlyGameOwner {\\n        tokenContractKeys = keys;\\n    }\\n\\n    function _validTokenContractKey(string memory key) private view returns(bool) {\\n        for (uint256 i = 0; i < tokenContractKeys.length; i++) {\\n            if (keccak256(abi.encodePacked(tokenContractKeys[i])) == keccak256(abi.encodePacked(key))) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IDArrayUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nlibrary IDArrayUtil {\\n    function findIndex(uint256[] memory arr, uint256 id) internal pure returns(uint256) {\\n        for (uint256 i = 0; i < arr.length; i++) {\\n            if (arr[i] == id) {\\n                return i;\\n            }\\n        }\\n\\n        revert(\\\"ID not found\\\");\\n    }\\n\\n    function removeById(uint256[] storage arr, uint256 id) internal {\\n        uint256 index = findIndex(arr, id);\\n\\n        remove(arr, index);\\n    }\\n\\n    function remove(uint256[] storage arr, uint256 _index) internal {\\n        require(_index < arr.length, \\\"out of bound\\\");\\n\\n        for (uint256 i = _index; i < arr.length - 1; i++) {\\n            arr[i] = arr[i + 1];\\n        }\\n        arr.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/World.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./data/Character.sol\\\";\\nimport \\\"./definitions/CharacterDefinition.sol\\\";\\nimport \\\"./definitions/ItemDefinition.sol\\\";\\nimport \\\"./definitions/EventDefinition.sol\\\";\\nimport \\\"./data/ItemPack.sol\\\";\\nimport \\\"./definitions/ItemPackDefinition.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/definitions/IItemDefinition.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/token/IItemPackNFT.sol\\\";\\nimport \\\"./data/CharacterEdition.sol\\\";\\nimport \\\"./data/Equipment.sol\\\";\\nimport \\\"./data/ItemStorage.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/IWorld.sol\\\";\\nimport \\\"./data/EventCheckinLog.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/IGameAccess.sol\\\";\\nimport \\\"ttt-contract-interfaces/contracts/token/IL1NFT.sol\\\";\\n\\ncontract World is Ownable, IWorld, WorldAccess {\\n    IL1NFT private _l1NFT;\\n    IItemPackNFT[] private _itemPackNFTs;\\n\\n    IGameAccess public game;\\n    uint256 public worldId;\\n\\n    uint256 private _characterIndex;\\n    uint256 private _characterDefinitionIndex;\\n    uint256 private _ItemDefinitionIndex;\\n\\n    CharacterDefinition public characterDefinition;\\n    ItemDefinition public itemDefinition;\\n    ItemPackDefinition public itemPackDefinition;\\n    EventDefinition public eventDefinition;\\n\\n    Character public character;\\n    Equipment public equipment;\\n    ItemStorage public itemStorage;\\n    ItemPack public itemPack;\\n    CharacterEdition public characterEdition;\\n    EventCheckinLog public eventCheckinLog;\\n\\n    // key: commandDefinitionId\\n    mapping(uint256 => address) public commandDefinitions;\\n\\n    constructor(address game_, uint256 worldId_)\\n    WorldAccess(worldId_, game_) {\\n        worldId = worldId_;\\n\\n        characterDefinition = new CharacterDefinition(worldId_, game_);\\n        itemPackDefinition = new ItemPackDefinition(worldId_, game_);\\n        eventDefinition = new EventDefinition(worldId_, game_);\\n        itemDefinition = new ItemDefinition(worldId_, game_);\\n\\n        character = new Character(worldId_, game_);\\n        equipment = new Equipment(worldId_, game_);\\n        itemStorage = new ItemStorage(worldId_, game_);\\n        itemPack = new ItemPack(worldId_, game_);\\n        characterEdition = new CharacterEdition(worldId_, game_);\\n        eventCheckinLog = new EventCheckinLog(worldId_, game_);\\n    }\\n\\n    function setGame(address game_) external override onlyWorldAdmin {\\n        game = IGameAccess(game_);\\n\\n        characterDefinition.setGameAddress(game_);\\n        itemPackDefinition.setGameAddress(game_);\\n        eventDefinition.setGameAddress(game_);\\n        itemDefinition.setGameAddress(game_);\\n\\n        character.setGameAddress(game_);\\n        equipment.setGameAddress(game_);\\n        itemStorage.setGameAddress(game_);\\n        characterEdition.setGameAddress(game_);\\n        eventCheckinLog.setGameAddress(game_);\\n    }\\n\\n    function setL1NFT(address l1NFT_) external onlyWorldAdmin {\\n        _l1NFT = IL1NFT(l1NFT_);\\n    }\\n\\n    function setCharacterDefinition(address characterDefinition_) public onlyWorldAdmin {\\n        characterDefinition = CharacterDefinition(characterDefinition_);\\n    }\\n\\n    function addItemPackNFT(address itemPackNFT) public onlyWorldAdmin {\\n        _itemPackNFTs.push(IItemPackNFT(itemPackNFT));\\n    }\\n\\n    function getItemPackNFTs() external view returns(IItemPackNFT[] memory) {\\n        return _itemPackNFTs;\\n    }\\n\\n    function getItemPackNFTs(uint256 itemPackId) external view returns(address) {\\n        return address(_itemPackNFTs[itemPackId]);\\n    }\\n\\n    function addCharacterDefinition(uint256 characterDefinitionId, CharacterDefinition.EquipmentSlot[] memory equipableSlots_, uint256[][] memory equipables_) public onlyWorldAdmin {\\n        characterDefinition.setCharacter(characterDefinitionId, true);\\n        characterDefinition.setEquipmentSlots(characterDefinitionId, equipableSlots_);\\n\\n        for (uint256 i = 0; i < equipables_.length; i++) {\\n            uint256[] memory equipable = equipables_[i];\\n            uint256 itemId = equipable[0];\\n            uint256 slotIndex = equipable[1];\\n\\n            characterDefinition.setEquipable(characterDefinitionId, itemId, slotIndex);\\n        }\\n    }\\n\\n    function getL1NFT() external view override returns(IL1NFT) {\\n        return _l1NFT;\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/extensions/IERC721AQueryable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721A.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryable is IERC721A {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"ttt-contract-interfaces/contracts/definitions/IItemDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IItemDefinition {\\n    struct ItemDefinitionRecord {\\n        uint256 itemDefinitionId;\\n        string category;\\n        bool enable;\\n        bool salable;\\n        bool transferable;\\n        uint256 effectivePeriod;\\n    }\\n\\n    function setDefinitions(ItemDefinitionRecord[] calldata records) external;\\n\\n    function getDefinition(uint256 itemDefinitionId_) external view returns(ItemDefinitionRecord memory);\\n}\\n\"\r\n    },\r\n    \"ttt-contract-interfaces/contracts/IEventCheckin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IEventCheckin {\\n    struct LogRecord {\\n        address playerWallet;\\n        uint256 eventDefinitionId;\\n        uint256 timestamp;\\n    }\\n\\n    event Checkin(address indexed playerWallet, uint256 indexed worldId, uint256 eventDefinitionId, uint256 itemPackDefinitionId, uint256 itemPackId);\\n\\n    function checkin(address playerWallet, uint256 worldId, uint256 eventDefinitionId) external;\\n\\n    // @returns Returns executable\\n    // - bool executable\\n    // - bool check enabled\\n    // - bool check executable times\\n    // - bool check executable times per user\\n    // - bool check end period\\n    // - bool check user executable interval\\n    function validateCheckin(address playerWallet, uint256 worldId, uint256 eventDefinitionId) external view returns(bool, bool, bool, bool, bool, bool);\\n\\n    // @returns Returns Event definition.\\n    // - uint256 eventDefinitionId\\n    // - bool enabled\\n    // - uint256 itemPackDefinitionId\\n    // - address eventNftAddress - ERC721\\n    // - uint256 executableTimes\\n    // - uint256 executableTimesPerUser\\n    // - uint256 endPeriod - unix timestamp(seconds)\\n    // - uint256 userExecutableInterval - seconds\\n    // - bool gpsCheckEnabled\\n    function getEventDefinition(uint256 worldId, uint256 eventDefinitionId) external view returns(\\n        uint256, bool, uint256, address, uint256, uint256, uint256, uint256, bool);\\n\\n    function getCheckinCount(uint256 worldId) external view returns(uint256);\\n\\n    function getCheckinCountPerEvent(uint256 worldId, uint256 eventDefinitionId) external view returns(uint256);\\n\\n    function getCheckinCountFromPlayer(address playerWallet, uint256 worldId, uint256 eventDefinitionId) external view returns(uint256);\\n\\n    function getLatestCheckinTimestampFromPlayer(address playerWallet, uint256 worldId, uint256 eventDefinitionId) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"ttt-contract-interfaces/contracts/IGameAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IGameAccess {\\n    function getInterfaceAddress(string calldata key) external view returns(address);\\n    function getInterfaceAddresses() external view returns(address[] memory);\\n    function getWorldOwnerAddresses(uint256 worldId) external view returns(address[] memory);\\n    function getWorldAdminAddresses(uint256 worldId) external view returns(address[] memory);\\n    function getGameAdminAddresses() external view returns(address[] memory);\\n    function getTokenOwnerAddress(uint256 worldId, uint256 tokenId) external view returns(address);\\n    function getItemPackNFTAddresses(uint256 worldId) external view returns(address[] memory);\\n}\\n\"\r\n    },\r\n    \"ttt-contract-interfaces/contracts/IWorld.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"./token/IL1NFT.sol\\\";\\nimport \\\"./token/IItemPackNFT.sol\\\";\\n\\ninterface IWorld {\\n    function setGame(address game_) external;\\n    function getL1NFT() external view returns(IL1NFT);\\n    function getItemPackNFTs() external view returns(IItemPackNFT[] memory);\\n}\\n\"\r\n    },\r\n    \"ttt-contract-interfaces/contracts/IWorldStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"./token/IL1NFT.sol\\\";\\nimport \\\"./token/IItemPackNFT.sol\\\";\\n\\ninterface IWorldStore {\\n    function getDefinition(uint256 worldId, string memory key) external view returns(address);\\n    function getDefinitionKeys() external view returns(string[] memory);\\n    function getDataContract(uint256 worldId, string memory key) external view returns(address);\\n    function getDataContractKeys() external view returns(string[] memory);\\n    function getTokenContract(uint256 worldId, string memory key) external view returns(address);\\n    function getTokenContractKeys() external view returns(string[] memory);\\n}\\n\"\r\n    },\r\n    \"ttt-contract-interfaces/contracts/token/IItemPackNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"erc721a/contracts/extensions/IERC721AQueryable.sol\\\";\\n\\ninterface IItemPackNFT is IERC721A {\\n    function getEnabled() external view returns(bool);\\n    function setEnabled(bool enabled) external;\\n    function mint(address to, uint256 quantity, uint256 itemPackDefinitionId) external;\\n    function burn(uint256 tokenId) external;\\n    function getTokens(address owner) external view returns(uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"ttt-contract-interfaces/contracts/token/IL1NFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"erc721a/contracts/extensions/IERC721AQueryable.sol\\\";\\n\\ninterface IL1NFT is IERC721A {\\n    function getTokens(address owner) external view returns(uint256[] memory);\\n    function getOwner(uint256 tokenId) external view returns (address owner);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"game\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"playerWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eventDefinitionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemPackDefinitionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemPackId\",\"type\":\"uint256\"}],\"name\":\"Checkin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eventDefinitionId\",\"type\":\"uint256\"}],\"name\":\"checkin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkinCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"}],\"name\":\"getCheckinCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eventDefinitionId\",\"type\":\"uint256\"}],\"name\":\"getCheckinCountFromPlayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eventDefinitionId\",\"type\":\"uint256\"}],\"name\":\"getCheckinCountPerEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"worldId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eventDefinitionId_\",\"type\":\"uint256\"}],\"name\":\"getEventDefinition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eventDefinitionId\",\"type\":\"uint256\"}],\"name\":\"getLatestCheckinTimestampFromPlayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameAddress\",\"type\":\"address\"}],\"name\":\"setGameAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eventDefinitionId\",\"type\":\"uint256\"}],\"name\":\"validateCheckin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EventCheckin", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000017cd61a2b4aba15df88c8a5f26b61f0d2b2e2b8c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}