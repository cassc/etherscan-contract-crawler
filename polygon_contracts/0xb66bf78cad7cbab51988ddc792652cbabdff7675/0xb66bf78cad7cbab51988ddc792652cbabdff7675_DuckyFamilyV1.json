{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/duckies/games/DuckyFamily/DuckyFamilyV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.18;\\n\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';\\n\\nimport '../../../interfaces/IDuckyFamily.sol';\\nimport '../../../interfaces/IDucklings.sol';\\nimport '../Seeding.sol';\\nimport '../Utils.sol';\\nimport '../Genome.sol';\\nimport './DuckyGenome.sol';\\n\\n/**\\n * @title DuckyFamilyV1\\n *\\n * @notice DuckyFamily contract defines rules of Ducky Family game, which is a card game similar to Happy Families and Uno games.\\n * This game also incorporates vouchers as defined in IVoucher interface.\\n *\\n * DuckyFamily operates on Ducklings NFT, which is defined in a corresponding contract. DuckyFamily can mint, burn and query information about NFTs\\n * by calling Ducklings contract.\\n *\\n * Users can buy NFT (card) packs of different size. When a pack is bought, a number of cards is generated and assigned to the user.\\n * The packs can be bought with Duckies token, so user should approve DuckyFamily contract to spend Duckies on his behalf.\\n *\\n * Each card has a unique genome, which is a 256-bit number. The genome is a combination of different genes, which describe the card and its properties.\\n * There are 3 types of cards introduced in this game, which are differentiated by the 'collection' gene: Duckling, Zombeak and Mythic.\\n * Duckling and Zombeak NFTs have a class system, which is defined by 'rarity' gene: Common, Rare, Epic and Legendary.\\n * Mythic NFTs are not part of the class system and are considered to be the most rare and powerful cards in the game.\\n *\\n * All cards have a set of generative genes, which are used to describe the card, its rarity and image.\\n * There are 2 types of generative genes: with even and uneven chance for each value of that gene.\\n * All values of even genes are generated with equal probability, while uneven genes have a higher chance for the first values and lower for the last values.\\n * Thus, while even genes can describe the card, uneven can set the rarity of the card.\\n *\\n * Note: don't confuse 'rarity' gene with rarity of the card. 'Rarity' gene is a part of the game logic, while rarity of the card is a value this card represents.\\n * Henceforth, if a 'Common' rarity gene card has uneven generative genes with high values (which means this card has a tiny chance to being generated),\\n * then this card can be more rare than some 'Rare' rarity gene cards.\\n * So, when we mean 'rarity' gene, we will use quotes, while when we mean rarity of the card, we will use it without quotes.\\n *\\n * Duckling are the main cards in the game, as they are the only way users can get Mythic cards.\\n * However, users are not obliged to use every Duckling cards to help them get Mythic, they can improve them and collect the rarest ones.\\n * Users can get Duckling cards from minting packs.\\n *\\n * Users can improve the 'rarity' of the card by melding them. Melding is a process of combining a flock of 5 cards to create a new one.\\n * The new card will have the same 'collection' gene as the first card in the flock, but the 'rarity' gene will be incremented.\\n * However, users must oblige to specific rules when melding cards:\\n * 1. All cards in the flock must have the same 'collection' gene.\\n * 2. All cards in the flock must have the same 'rarity' gene.\\n * 3a. When melding Common cards, all cards in the flock must have either the same Color or Family gene values.\\n * 3b. When melding Rare and Epic cards, all cards in the flock must have both the same Color and Family gene values.\\n * 3c. When melding Legendary cards, all cards in the flock must have the same Color and different Family gene values.\\n * 4. Mythic cards cannot be melded.\\n * 5. Legendary Zombeak cards cannot be melded.\\n *\\n * Other generative genes of the melded card are not random, but are calculated from the genes of the source cards.\\n * This process is called 'inheritance' and is the following:\\n * 1. Each generative gene is inherited separately\\n * 2. A gene has a high chance of being inherited from the first card in the flock, and this chance is lower for each next card in the flock.\\n * 3. A gene has a mere chance of 'positive mutation', which sets inherited gene value to be bigger than the biggest value of this gene in the flock.\\n *\\n * Melding is not free and has a different cost for each 'rarity' of the cards being melded.\\n *\\n * Zombeak are secondary cards, that you can only get when melding mutates. There is a different chance (defined in Config section below) for each 'rarity' of the Duckling cards that are being melded,\\n * that the melding result card will mutate to Zombeak. If the melding mutates, then the new card will have the same 'rarity' gene as the source cards.\\n * This logic makes Zombeak cards more rare than some Duckling cards, as they can only be obtained by melding mutating.\\n * However, Zombeak cards cannot be melded into Mythic, which means their main value is rarity.\\n *\\n * Mythic are the most rare and powerful cards in the game. They can only be obtained by melding Legendary Duckling cards with special rules described above.\\n * The rarity of the Mythic card is defined by the 'UniqId' gene, which corresponds to the picture of the card. The higher the 'UniqId' gene value, the rarer the card.\\n * The 'UniqId' value is correlated with the 'peculiarity' of the flock that creates the Mythic: the higher the peculiarity, the higher the 'UniqId' value.\\n * Peculiarity of the card is a sum of all uneven gene values of this card, and peculiarity of the flock is a sum of peculiarities of all cards in the flock.\\n *\\n * Mythic cards give bonuses to their owned depending on their rarity. These bonuses will be revealed in the future, but they may include\\n * free Yellow tokens (with vesting claim mechanism), an ability to change existing cards, stealing / fighting other cards, etc.\\n */\\ncontract DuckyFamilyV1 is IDuckyFamily, AccessControl, Seeding {\\n\\tusing Genome for uint256;\\n\\n\\t// Roles\\n\\tbytes32 public constant MAINTAINER_ROLE = keccak256('MAINTAINER_ROLE'); // can change minting and melding price\\n\\n\\taddress public issuer; // issuer of Vouchers\\n\\n\\t// Store the vouchers to avoid replay attacks\\n\\tmapping(bytes32 => bool) internal _usedVouchers;\\n\\n\\t// ------- Config -------\\n\\n\\t/// @dev constants must be duplicated both here and in DuckyGenome as Solidity does not see Library constants as constants, see https://github.com/ethereum/solidity/issues/12248\\n\\tuint8 internal constant ducklingCollectionId = 0;\\n\\tuint8 internal constant zombeakCollectionId = 1;\\n\\tuint8 internal constant mythicCollectionId = 2;\\n\\tuint8 internal constant RARITIES_NUM = 4;\\n\\n\\tuint8 internal constant collectionGeneIdx = Genome.COLLECTION_GENE_IDX;\\n\\tuint8 internal constant rarityGeneIdx = 1;\\n\\tuint8 internal constant flagsGeneIdx = Genome.FLAGS_GENE_IDX;\\n\\t// general genes start after Collection and Rarity\\n\\tuint8 internal constant generativeGenesOffset = 2;\\n\\n\\tuint8 public constant MAX_PACK_SIZE = 50;\\n\\tuint8 public constant FLOCK_SIZE = 5;\\n\\n\\t// number of values for each gene for Duckling and Zombeak collections\\n\\tuint8[][3] internal collectionsGeneValuesNum; // set in constructor\\n\\n\\t// distribution type of each gene for Duckling and Zombeak collections (0 - even, 1 - uneven)\\n\\tuint32[3] internal collectionsGeneDistributionTypes = [\\n\\t\\t2940, // reverse(001111101101) = 101101111100\\n\\t\\t2940, // reverse(001111101101) = 101101111100\\n\\t\\t107 // reverse(11010110) = 01101011\\n\\t];\\n\\n\\t// peculiarity is a sum of uneven gene values for Ducklings\\n\\tuint16 internal maxPeculiarity;\\n\\t// mythic dispersion define the interval size in which UniqId value is generated\\n\\tuint8 internal constant MYTHIC_DISPERSION = 5;\\n\\tuint8 internal mythicAmount = 60;\\n\\n\\t// chance of a Duckling of a certain rarity to be generated\\n\\tuint32[] internal rarityChances = [850, 120, 25, 5]; // per mil\\n\\n\\t// chance of a Duckling of certain rarity to mutate to Zombeak while melding\\n\\tuint32[] internal collectionMutationChances = [150, 100, 50, 10]; // per mil\\n\\n\\tuint32[] internal geneMutationChance = [955, 45]; // 4.5% to mutate gene value\\n\\tuint32[] internal geneInheritanceChances = [400, 300, 150, 100, 50]; // per mil\\n\\n\\t// ------- Public values -------\\n\\n\\tERC20Burnable public duckiesContract;\\n\\tIDucklings public ducklingsContract;\\n\\taddress public treasureVaultAddress;\\n\\n\\tuint256 public mintPrice;\\n\\tuint256[RARITIES_NUM] public meldPrices; // [0] - melding Commons, [1] - melding Rares...\\n\\n\\t// ------- Constructor -------\\n\\n\\t/**\\n\\t * @notice Sets Duckies, Ducklings and Treasure Vault addresses, minting and melding prices and other game config.\\n\\t * @dev Grants DEFAULT_ADMIN_ROLE and MAINTAINER_ROLE to the deployer.\\n\\t * @param duckiesAddress Address of Duckies ERC20 contract.\\n\\t * @param ducklingsAddress Address of Ducklings ERC721 contract.\\n\\t * @param treasureVaultAddress_ Address of Treasure Vault contract.\\n\\t */\\n\\tconstructor(address duckiesAddress, address ducklingsAddress, address treasureVaultAddress_) {\\n\\t\\t_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n\\t\\t_grantRole(MAINTAINER_ROLE, msg.sender);\\n\\n\\t\\tduckiesContract = ERC20Burnable(duckiesAddress);\\n\\t\\tducklingsContract = IDucklings(ducklingsAddress);\\n\\t\\ttreasureVaultAddress = treasureVaultAddress_;\\n\\n\\t\\tuint256 decimalsMultiplier = 10 ** duckiesContract.decimals();\\n\\n\\t\\tmintPrice = 50 * decimalsMultiplier;\\n\\t\\tmeldPrices = [\\n\\t\\t\\t100 * decimalsMultiplier,\\n\\t\\t\\t200 * decimalsMultiplier,\\n\\t\\t\\t500 * decimalsMultiplier,\\n\\t\\t\\t1000 * decimalsMultiplier\\n\\t\\t];\\n\\n\\t\\t// Duckling genes: (Collection, Rarity), Color, Family, Body, Head, Eyes, Beak, Wings, FirstName, Temper, Skill, Habitat, Breed\\n\\t\\tcollectionsGeneValuesNum[0] = [4, 5, 10, 25, 30, 14, 10, 36, 16, 12, 5, 28];\\n\\t\\t// Zombeak genes: (Collection, Rarity), Color, Family, Body, Head, Eyes, Beak, Wings, FirstName, Temper, Skill, Habitat, Breed\\n\\t\\tcollectionsGeneValuesNum[1] = [2, 3, 7, 6, 9, 7, 10, 36, 16, 12, 5, 28];\\n\\t\\t// Mythic genes: (Collection, UniqId), Temper, Skill, Habitat, Breed, Birthplace, Quirk, Favorite Food, Favorite Color\\n\\t\\tcollectionsGeneValuesNum[2] = [16, 12, 5, 28, 5, 10, 8, 4];\\n\\n\\t\\tmaxPeculiarity = DuckyGenome.calcConfigPeculiarity(\\n\\t\\t\\tcollectionsGeneValuesNum[ducklingCollectionId],\\n\\t\\t\\tcollectionsGeneDistributionTypes[ducklingCollectionId]\\n\\t\\t);\\n\\t}\\n\\n\\t// ------- Random -------\\n\\n\\t/**\\n\\t * @notice Sets the pepper for random generator.\\n\\t * @dev Require MAINTAINER_ROLE to call. Pepper is a random data changed periodically by external entity.\\n\\t * @param pepper New pepper.\\n\\t */\\n\\tfunction setPepper(bytes32 pepper) external onlyRole(MAINTAINER_ROLE) {\\n\\t\\t_setPepper(pepper);\\n\\t}\\n\\n\\t// ------- Vouchers -------\\n\\n\\t/**\\n\\t * @notice Sets the issuer of Vouchers.\\n\\t * @dev Require DEFAULT_ADMIN_ROLE to call.\\n\\t * @param account Address of a new issuer.\\n\\t */\\n\\tfunction setIssuer(address account) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tissuer = account;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Use multiple Vouchers. Check the signature and invoke internal function for each voucher.\\n\\t * @dev Vouchers are issued by the Back-End and signed by the issuer.\\n\\t * @param vouchers Array of Vouchers to use.\\n\\t * @param signature Vouchers signed by the issuer.\\n\\t */\\n\\tfunction useVouchers(Voucher[] calldata vouchers, bytes calldata signature) external {\\n\\t\\tUtils.requireCorrectSigner(abi.encode(vouchers), signature, issuer);\\n\\t\\tfor (uint8 i = 0; i < vouchers.length; i++) {\\n\\t\\t\\t_useVoucher(vouchers[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Use a single Voucher. Check the signature and invoke internal function.\\n\\t * @dev Vouchers are issued by the Back-End and signed by the issuer.\\n\\t * @param voucher Voucher to use.\\n\\t * @param signature Voucher signed by the issuer.\\n\\t */\\n\\tfunction useVoucher(Voucher calldata voucher, bytes calldata signature) external {\\n\\t\\tUtils.requireCorrectSigner(abi.encode(voucher), signature, issuer);\\n\\t\\t_useVoucher(voucher);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Check the validity of a voucher, decode voucher params and mint or meld tokens depending on voucher's type. Emits VoucherUsed event. Internal function.\\n\\t * @dev Vouchers are issued by the Back-End and signed by the issuer.\\n\\t * @param voucher Voucher to use.\\n\\t */\\n\\tfunction _useVoucher(Voucher memory voucher) internal {\\n\\t\\t_requireValidVoucher(voucher);\\n\\n\\t\\t_usedVouchers[voucher.voucherCodeHash] = true;\\n\\n\\t\\t// parse & process Voucher\\n\\t\\tif (voucher.action == uint8(VoucherActions.MintPack)) {\\n\\t\\t\\tMintParams memory mintParams = abi.decode(voucher.encodedParams, (MintParams));\\n\\n\\t\\t\\t// mintParams checks\\n\\t\\t\\tif (\\n\\t\\t\\t\\tmintParams.to == address(0) ||\\n\\t\\t\\t\\tmintParams.size == 0 ||\\n\\t\\t\\t\\tmintParams.size > MAX_PACK_SIZE\\n\\t\\t\\t) revert InvalidMintParams(mintParams);\\n\\n\\t\\t\\t_mintPackTo(mintParams.to, mintParams.size, mintParams.isTransferable);\\n\\t\\t} else if (voucher.action == uint8(VoucherActions.MeldFlock)) {\\n\\t\\t\\tMeldParams memory meldParams = abi.decode(voucher.encodedParams, (MeldParams));\\n\\n\\t\\t\\t// meldParams checks\\n\\t\\t\\tif (meldParams.owner == address(0) || meldParams.tokenIds.length != FLOCK_SIZE)\\n\\t\\t\\t\\trevert InvalidMeldParams(meldParams);\\n\\n\\t\\t\\t_meldOf(meldParams.owner, meldParams.tokenIds, meldParams.isTransferable);\\n\\t\\t} else {\\n\\t\\t\\trevert InvalidVoucher(voucher);\\n\\t\\t}\\n\\n\\t\\temit VoucherUsed(\\n\\t\\t\\tvoucher.beneficiary,\\n\\t\\t\\tvoucher.action,\\n\\t\\t\\tvoucher.voucherCodeHash,\\n\\t\\t\\tvoucher.chainId\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Check the validity of a voucher, reverts if invalid.\\n\\t * @dev Voucher address must be this contract, beneficiary must be msg.sender, voucher must not be used before, voucher must not be expired.\\n\\t * @param voucher Voucher to check.\\n\\t */\\n\\tfunction _requireValidVoucher(Voucher memory voucher) internal view {\\n\\t\\tif (_usedVouchers[voucher.voucherCodeHash])\\n\\t\\t\\trevert VoucherAlreadyUsed(voucher.voucherCodeHash);\\n\\n\\t\\tif (\\n\\t\\t\\tvoucher.target != address(this) ||\\n\\t\\t\\tvoucher.beneficiary != msg.sender ||\\n\\t\\t\\tblock.timestamp > voucher.expire ||\\n\\t\\t\\tvoucher.chainId != block.chainid\\n\\t\\t) revert InvalidVoucher(voucher);\\n\\t}\\n\\n\\t// -------- Config --------\\n\\n\\t/**\\n\\t * @notice Get the mint price in Duckies with decimals.\\n\\t * @dev Get the mint price in Duckies with decimals.\\n\\t * @return mintPrice Mint price in Duckies with decimals.\\n\\t */\\n\\tfunction getMintPrice() external view returns (uint256) {\\n\\t\\treturn mintPrice;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set the mint price in Duckies without decimals.\\n\\t * @dev Require MAINTAINER_ROLE to call.\\n\\t * @param price Mint price in Duckies without decimals.\\n\\t */\\n\\tfunction setMintPrice(uint256 price) external onlyRole(MAINTAINER_ROLE) {\\n\\t\\tmintPrice = price * 10 ** duckiesContract.decimals();\\n\\t}\\n\\n\\t/**\\n\\t * @notice Get the meld price for each 'rarity' in Duckies with decimals.\\n\\t * @dev Get the meld price for each 'rarity' in Duckies with decimals.\\n\\t * @return meldPrices Array of meld prices in Duckies with decimals.\\n\\t */\\n\\tfunction getMeldPrices() external view returns (uint256[RARITIES_NUM] memory) {\\n\\t\\treturn meldPrices;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set the meld price for each 'rarity' in Duckies without decimals.\\n\\t * @dev Require MAINTAINER_ROLE to call.\\n\\t * @param prices Array of meld prices in Duckies without decimals.\\n\\t */\\n\\tfunction setMeldPrices(\\n\\t\\tuint256[RARITIES_NUM] calldata prices\\n\\t) external onlyRole(MAINTAINER_ROLE) {\\n\\t\\tfor (uint8 i = 0; i < RARITIES_NUM; i++) {\\n\\t\\t\\tmeldPrices[i] = prices[i] * 10 ** duckiesContract.decimals();\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Get number of gene values for all collections and a number of different Mythic tokens.\\n\\t * @dev Get number of gene values for all collections and a number of different Mythic tokens.\\n\\t * @return collectionsGeneValuesNum Arrays of number of gene values for all collections and a mythic amount.\\n\\t */\\n\\tfunction getCollectionsGeneValues() external view returns (uint8[][3] memory, uint8) {\\n\\t\\treturn (collectionsGeneValuesNum, mythicAmount);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Get gene distribution types for all collections.\\n\\t * @dev Get gene distribution types for all collections.\\n\\t * @return collectionsGeneDistributionTypes Arrays of gene distribution types for all collections.\\n\\t */\\n\\tfunction getCollectionsGeneDistributionTypes() external view returns (uint32[3] memory) {\\n\\t\\treturn collectionsGeneDistributionTypes;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set gene values number for each gene for Duckling collection.\\n\\t * @dev Require DEFAULT_ADMIN_ROLE to call.\\n\\t * @param duckingGeneValuesNum Array of gene values number for each gene for Duckling collection.\\n\\t */\\n\\tfunction setDucklingGeneValues(\\n\\t\\tuint8[] memory duckingGeneValuesNum\\n\\t) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tcollectionsGeneValuesNum[0] = duckingGeneValuesNum;\\n\\t\\tmaxPeculiarity = DuckyGenome.calcConfigPeculiarity(\\n\\t\\t\\tcollectionsGeneValuesNum[ducklingCollectionId],\\n\\t\\t\\tcollectionsGeneDistributionTypes[ducklingCollectionId]\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set gene distribution types for Duckling collection.\\n\\t * @dev Require DEFAULT_ADMIN_ROLE to call.\\n\\t * @param ducklingGeneDistrTypes Gene distribution types for Duckling collection.\\n\\t */\\n\\tfunction setDucklingGeneDistributionTypes(\\n\\t\\tuint32 ducklingGeneDistrTypes\\n\\t) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tcollectionsGeneDistributionTypes[0] = ducklingGeneDistrTypes;\\n\\t\\tmaxPeculiarity = DuckyGenome.calcConfigPeculiarity(\\n\\t\\t\\tcollectionsGeneValuesNum[ducklingCollectionId],\\n\\t\\t\\tcollectionsGeneDistributionTypes[ducklingCollectionId]\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set gene values number for each gene for Zombeak collection.\\n\\t * @dev Require DEFAULT_ADMIN_ROLE to call.\\n\\t * @param zombeakGeneValuesNum Array of gene values number for each gene for Duckling collection.\\n\\t */\\n\\tfunction setZombeakGeneValues(\\n\\t\\tuint8[] memory zombeakGeneValuesNum\\n\\t) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tcollectionsGeneValuesNum[1] = zombeakGeneValuesNum;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set gene distribution types for Zombeak collection.\\n\\t * @dev Require DEFAULT_ADMIN_ROLE to call.\\n\\t * @param zombeakGeneDistrTypes Gene distribution types for Zombeak collection.\\n\\t */\\n\\tfunction setZombeakGeneDistributionTypes(\\n\\t\\tuint32 zombeakGeneDistrTypes\\n\\t) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tcollectionsGeneDistributionTypes[1] = zombeakGeneDistrTypes;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set number of different Mythic tokens.\\n\\t * @dev Require DEFAULT_ADMIN_ROLE to call.\\n\\t * @param amount Number of different Mythic tokens.\\n\\t */\\n\\tfunction setMythicAmount(uint8 amount) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tmythicAmount = amount;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set gene values number for each gene for Mythic collection.\\n\\t * @dev Require DEFAULT_ADMIN_ROLE to call.\\n\\t * @param mythicGeneValuesNum Array of gene values number for each gene for Mythic collection.\\n\\t */\\n\\tfunction setMythicGeneValues(\\n\\t\\tuint8[] memory mythicGeneValuesNum\\n\\t) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tcollectionsGeneValuesNum[2] = mythicGeneValuesNum;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set gene distribution types for Mythic collection.\\n\\t * @dev Require DEFAULT_ADMIN_ROLE to call.\\n\\t * @param mythicGeneDistrTypes Gene distribution types for Mythic collection.\\n\\t */\\n\\tfunction setMythicGeneDistributionTypes(\\n\\t\\tuint32 mythicGeneDistrTypes\\n\\t) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tcollectionsGeneDistributionTypes[2] = mythicGeneDistrTypes;\\n\\t}\\n\\n\\t// ------- Mint -------\\n\\n\\t/**\\n\\t * @notice Mint a pack with `size` of Ducklings. Transfer Duckies from the sender to the TreasureVault.\\n\\t * @dev `Size` must be less than or equal to `MAX_PACK_SIZE`.\\n\\t * @param size Number of Ducklings in the pack.\\n\\t */\\n\\tfunction mintPack(uint8 size) external {\\n\\t\\tduckiesContract.transferFrom(msg.sender, treasureVaultAddress, mintPrice * size);\\n\\t\\t_mintPackTo(msg.sender, size, true);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Mint a pack with `amount` of Ducklings to `to` and set transferable flag for each token. Internal function.\\n\\t * @dev `amount` must be less than or equal to `MAX_PACK_SIZE`.\\n\\t * @param to Address to mint the pack to.\\n\\t * @param amount Number of Ducklings in the pack.\\n\\t * @param isTransferable Transferable flag for each token.\\n\\t * @return tokenIds Array of minted token IDs.\\n\\t */\\n\\tfunction _mintPackTo(\\n\\t\\taddress to,\\n\\t\\tuint8 amount,\\n\\t\\tbool isTransferable\\n\\t) internal returns (uint256[] memory tokenIds) {\\n\\t\\tif (amount == 0 || amount > MAX_PACK_SIZE)\\n\\t\\t\\trevert MintingRulesViolated(ducklingCollectionId, amount);\\n\\n\\t\\ttokenIds = new uint256[](amount);\\n\\t\\tuint256[] memory tokenGenomes = new uint256[](amount);\\n\\n\\t\\tfor (uint256 i = 0; i < amount; i++) {\\n\\t\\t\\ttokenGenomes[i] = _generateGenome(ducklingCollectionId, _randomSeed()).setFlag(\\n\\t\\t\\t\\tGenome.FLAG_TRANSFERABLE,\\n\\t\\t\\t\\tisTransferable\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\ttokenIds = ducklingsContract.mintBatchTo(to, tokenGenomes);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Generate genome for Duckling or Zombeak.\\n\\t * @dev Generate and set all genes from a corresponding collection.\\n\\t * @param collectionId Collection ID.\\n\\t * @param seed Seed for randomization.\\n\\t * @return genome Generated genome.\\n\\t */\\n\\tfunction _generateGenome(uint8 collectionId, bytes32 seed) internal view returns (uint256) {\\n\\t\\tif (collectionId != ducklingCollectionId && collectionId != zombeakCollectionId) {\\n\\t\\t\\trevert MintingRulesViolated(collectionId, 1);\\n\\t\\t}\\n\\n\\t\\t(bytes3 bitSlice, bytes32 updatedSeed) = Utils.shiftSeedSlice(seed);\\n\\n\\t\\tuint256 genome;\\n\\n\\t\\tgenome = genome.setGene(collectionGeneIdx, collectionId);\\n\\t\\tgenome = genome.setGene(rarityGeneIdx, Utils.randomWeightedNumber(rarityChances, bitSlice));\\n\\t\\tgenome = DuckyGenome.generateAndSetGenes(\\n\\t\\t\\tgenome,\\n\\t\\t\\tcollectionId,\\n\\t\\t\\tcollectionsGeneValuesNum[collectionId],\\n\\t\\t\\tcollectionsGeneDistributionTypes[collectionId],\\n\\t\\t\\tupdatedSeed\\n\\t\\t);\\n\\t\\tgenome = genome.setGene(Genome.MAGIC_NUMBER_GENE_IDX, Genome.BASE_MAGIC_NUMBER);\\n\\n\\t\\treturn genome;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Generate mythic genome based on melding `genomes`.\\n\\t * @dev Calculates flock peculiarity, and randomizes UniqId corresponding to the peculiarity.\\n\\t * @param genomes Array of genomes to meld into Mythic.\\n\\t * @param maxPeculiarity_ Maximum peculiarity for the genomes collection config.\\n\\t * @param mythicAmount_ Number of different Mythic tokens.\\n\\t * @param seed Seed for randomization.\\n\\t * @return genome Generated Mythic genome.\\n\\t */\\n\\tfunction _generateMythicGenome(\\n\\t\\tuint256[] memory genomes,\\n\\t\\tuint16 maxPeculiarity_,\\n\\t\\tuint16 mythicAmount_,\\n\\t\\tbytes32 seed\\n\\t) internal view returns (uint256) {\\n\\t\\t(bytes3 bitSlice, bytes32 updatedSeed) = Utils.shiftSeedSlice(seed);\\n\\n\\t\\tuint16 flockPeculiarity = 0;\\n\\n\\t\\tfor (uint8 i = 0; i < genomes.length; i++) {\\n\\t\\t\\tflockPeculiarity += DuckyGenome.calcPeculiarity(\\n\\t\\t\\t\\tgenomes[i],\\n\\t\\t\\t\\tuint8(collectionsGeneValuesNum[ducklingCollectionId].length),\\n\\t\\t\\t\\tcollectionsGeneDistributionTypes[ducklingCollectionId]\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tuint16 maxSumPeculiarity = maxPeculiarity_ * uint16(genomes.length);\\n\\t\\tuint16 maxUniqId = mythicAmount_ - 1;\\n\\t\\tuint16 pivotalUniqId = uint16((uint64(flockPeculiarity) * maxUniqId) / maxSumPeculiarity); // multiply and then divide to avoid float numbers\\n\\t\\t(uint16 leftEndUniqId, uint16 uniqIdSegmentLength) = DuckyGenome.calcUniqIdGenerationParams(\\n\\t\\t\\tpivotalUniqId,\\n\\t\\t\\tmaxUniqId,\\n\\t\\t\\tMYTHIC_DISPERSION\\n\\t\\t);\\n\\n\\t\\tuint16 uniqId = leftEndUniqId + uint16(Utils.randomNumber(bitSlice, uniqIdSegmentLength));\\n\\n\\t\\tuint256 genome;\\n\\t\\tgenome = genome.setGene(collectionGeneIdx, mythicCollectionId);\\n\\t\\tgenome = genome.setGene(uint8(MythicGenes.UniqId), uint8(uniqId));\\n\\t\\tgenome = DuckyGenome.generateAndSetGenes(\\n\\t\\t\\tgenome,\\n\\t\\t\\tmythicCollectionId,\\n\\t\\t\\tcollectionsGeneValuesNum[mythicCollectionId],\\n\\t\\t\\tcollectionsGeneDistributionTypes[mythicCollectionId],\\n\\t\\t\\tupdatedSeed\\n\\t\\t);\\n\\t\\tgenome = genome.setGene(Genome.MAGIC_NUMBER_GENE_IDX, Genome.MYTHIC_MAGIC_NUMBER);\\n\\n\\t\\treturn genome;\\n\\t}\\n\\n\\t// ------- Meld -------\\n\\n\\t/**\\n\\t * @notice Meld tokens with `meldingTokenIds` into a new token. Calls internal function.\\n\\t * @dev Meld tokens with `meldingTokenIds` into a new token.\\n\\t * @param meldingTokenIds Array of token IDs to meld.\\n\\t */\\n\\tfunction meldFlock(uint256[] calldata meldingTokenIds) external {\\n\\t\\t// assume all tokens have the same rarity. This is checked later.\\n\\t\\tuint256 meldPrice = meldPrices[\\n\\t\\t\\tducklingsContract.getGenome(meldingTokenIds[0]).getGene(rarityGeneIdx)\\n\\t\\t];\\n\\t\\tduckiesContract.transferFrom(msg.sender, treasureVaultAddress, meldPrice);\\n\\n\\t\\t_meldOf(msg.sender, meldingTokenIds, true);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Meld tokens with `meldingTokenIds` into a new token. Internal function.\\n\\t * @dev Check `owner` is indeed the owner of `meldingTokenIds`. Burn NFTs with `meldingTokenIds`. Transfers Duckies to the TreasureVault.\\n\\t * @param owner Address of the owner of the tokens to meld.\\n\\t * @param meldingTokenIds Array of token IDs to meld.\\n\\t * @param isTransferable Whether the new token is transferable.\\n\\t * @return meldedTokenId ID of the new token.\\n\\t */\\n\\tfunction _meldOf(\\n\\t\\taddress owner,\\n\\t\\tuint256[] memory meldingTokenIds,\\n\\t\\tbool isTransferable\\n\\t) internal returns (uint256) {\\n\\t\\tif (meldingTokenIds.length != FLOCK_SIZE) revert MeldingRulesViolated(meldingTokenIds);\\n\\t\\tif (!ducklingsContract.isOwnerOfBatch(owner, meldingTokenIds))\\n\\t\\t\\trevert MeldingRulesViolated(meldingTokenIds);\\n\\n\\t\\tuint256[] memory meldingGenomes = ducklingsContract.getGenomes(meldingTokenIds);\\n\\t\\tDuckyGenome.requireGenomesSatisfyMelding(meldingGenomes);\\n\\n\\t\\tducklingsContract.burnBatch(meldingTokenIds);\\n\\n\\t\\tuint256 meldedGenome = _meldGenomes(meldingGenomes, _randomSeed()).setFlag(\\n\\t\\t\\tGenome.FLAG_TRANSFERABLE,\\n\\t\\t\\tisTransferable\\n\\t\\t);\\n\\t\\tuint256 meldedTokenId = ducklingsContract.mintTo(owner, meldedGenome);\\n\\n\\t\\temit Melded(owner, meldingTokenIds, meldedTokenId, block.chainid);\\n\\n\\t\\treturn meldedTokenId;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Meld `genomes` into a new genome.\\n\\t * @dev Meld `genomes` into a new genome gene by gene. Set the corresponding collection\\n\\t * @param genomes Array of genomes to meld.\\n\\t * @param seed Seed for randomization.\\n\\t * @return meldedGenome Melded genome.\\n\\t */\\n\\tfunction _meldGenomes(uint256[] memory genomes, bytes32 seed) internal view returns (uint256) {\\n\\t\\tuint8 collectionId = genomes[0].getGene(collectionGeneIdx);\\n\\t\\tRarities rarity = Rarities(genomes[0].getGene(rarityGeneIdx));\\n\\n\\t\\t(bytes3 bitSlice, bytes32 updatedSeed) = Utils.shiftSeedSlice(seed);\\n\\n\\t\\t// if melding Duckling, they can mutate or evolve into Mythic\\n\\t\\tif (collectionId == ducklingCollectionId) {\\n\\t\\t\\tif (DuckyGenome.isCollectionMutating(rarity, collectionMutationChances, bitSlice)) {\\n\\t\\t\\t\\tuint256 zombeakGenome = _generateGenome(zombeakCollectionId, updatedSeed);\\n\\t\\t\\t\\treturn zombeakGenome.setGene(rarityGeneIdx, uint8(rarity));\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (rarity == Rarities.Legendary) {\\n\\t\\t\\t\\treturn _generateMythicGenome(genomes, maxPeculiarity, mythicAmount, updatedSeed);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tuint256 meldedGenome;\\n\\n\\t\\t// set the same collection\\n\\t\\tmeldedGenome = meldedGenome.setGene(collectionGeneIdx, collectionId);\\n\\t\\t// increase rarity\\n\\t\\tmeldedGenome = meldedGenome.setGene(rarityGeneIdx, genomes[0].getGene(rarityGeneIdx) + 1);\\n\\n\\t\\tuint8[] memory geneValuesNum = collectionsGeneValuesNum[collectionId];\\n\\t\\tuint32 geneDistTypes = collectionsGeneDistributionTypes[collectionId];\\n\\n\\t\\tfor (uint8 i = 0; i < geneValuesNum.length; i++) {\\n\\t\\t\\t(bitSlice, updatedSeed) = Utils.shiftSeedSlice(updatedSeed);\\n\\t\\t\\tuint8 geneValue = DuckyGenome.meldGenes(\\n\\t\\t\\t\\tgenomes,\\n\\t\\t\\t\\tgenerativeGenesOffset + i,\\n\\t\\t\\t\\tgeneValuesNum[i],\\n\\t\\t\\t\\tDuckyGenome.getDistributionType(geneDistTypes, i),\\n\\t\\t\\t\\tgeneMutationChance,\\n\\t\\t\\t\\tgeneInheritanceChances,\\n\\t\\t\\t\\tbitSlice\\n\\t\\t\\t);\\n\\t\\t\\tmeldedGenome = meldedGenome.setGene(generativeGenesOffset + i, geneValue);\\n\\t\\t}\\n\\n\\t\\t// randomize Body for Common and Head for Rare for Ducklings\\n\\t\\tif (collectionId == ducklingCollectionId) {\\n\\t\\t\\t(bitSlice, updatedSeed) = Utils.shiftSeedSlice(updatedSeed);\\n\\t\\t\\tif (rarity == Rarities.Common) {\\n\\t\\t\\t\\tmeldedGenome = DuckyGenome.generateAndSetGene(\\n\\t\\t\\t\\t\\tmeldedGenome,\\n\\t\\t\\t\\t\\tuint8(GenerativeGenes.Body),\\n\\t\\t\\t\\t\\tgeneValuesNum[uint8(GenerativeGenes.Body) - generativeGenesOffset],\\n\\t\\t\\t\\t\\tGeneDistributionTypes.Uneven,\\n\\t\\t\\t\\t\\tbitSlice\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else if (rarity == Rarities.Rare) {\\n\\t\\t\\t\\tmeldedGenome = DuckyGenome.generateAndSetGene(\\n\\t\\t\\t\\t\\tmeldedGenome,\\n\\t\\t\\t\\t\\tuint8(GenerativeGenes.Head),\\n\\t\\t\\t\\t\\tgeneValuesNum[uint8(GenerativeGenes.Head) - generativeGenesOffset],\\n\\t\\t\\t\\t\\tGeneDistributionTypes.Uneven,\\n\\t\\t\\t\\t\\tbitSlice\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tmeldedGenome = meldedGenome.setGene(Genome.MAGIC_NUMBER_GENE_IDX, Genome.BASE_MAGIC_NUMBER);\\n\\n\\t\\treturn meldedGenome;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/duckies/games/DuckyFamily/DuckyGenome.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.18;\\n\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\n\\nimport '../../../interfaces/IDuckyFamily.sol';\\nimport '../Genome.sol';\\nimport '../Utils.sol';\\n\\n/**\\n * @title DuckyGenome\\n * @notice Library for generating Duckies genomes.\\n * @dev Contains functions for generating Duckies genomes.\\n */\\nlibrary DuckyGenome {\\n\\tusing Genome for uint256;\\n\\n\\t/// @dev constants must be duplicated both here and in DuckyFamilyV1 as Solidity does not see Library constants as constants, see https://github.com/ethereum/solidity/issues/12248\\n\\tuint8 internal constant ducklingCollectionId = 0;\\n\\tuint8 internal constant zombeakCollectionId = 1;\\n\\tuint8 internal constant mythicCollectionId = 2;\\n\\tuint8 internal constant RARITIES_NUM = 4;\\n\\n\\tuint8 internal constant collectionGeneIdx = Genome.COLLECTION_GENE_IDX;\\n\\tuint8 internal constant rarityGeneIdx = 1;\\n\\tuint8 internal constant flagsGeneIdx = Genome.FLAGS_GENE_IDX;\\n\\tuint8 internal constant generativeGenesOffset = 2;\\n\\n\\t/**\\n\\t * @notice Generates and sets genes to genome. Emits GenomeReturned event.\\n\\t * @dev Generates and sets genes to genome. Emits GenomeReturned event.\\n\\t * @param genome Genome to set genes to.\\n\\t * @param collectionId Collection Id to generate genes for.\\n\\t * @param geneValuesNum Number of gene values for each gene.\\n\\t * @param geneDistributionTypes Gene distribution types.\\n\\t * @param seed Seed for randomization.\\n\\t */\\n\\tfunction generateAndSetGenes(\\n\\t\\tuint256 genome,\\n\\t\\tuint8 collectionId,\\n\\t\\tuint8[] memory geneValuesNum,\\n\\t\\tuint32 geneDistributionTypes,\\n\\t\\tbytes32 seed\\n\\t) internal pure returns (uint256) {\\n\\t\\tuint8 genesNum = uint8(geneValuesNum.length);\\n\\t\\tbytes32 newSeed;\\n\\n\\t\\t// generate and set each gene\\n\\t\\tfor (uint8 i = 0; i < genesNum; i++) {\\n\\t\\t\\tIDuckyFamily.GeneDistributionTypes distrType = getDistributionType(\\n\\t\\t\\t\\tgeneDistributionTypes,\\n\\t\\t\\t\\ti\\n\\t\\t\\t);\\n\\t\\t\\tbytes3 bitSlice;\\n\\t\\t\\t(bitSlice, newSeed) = Utils.shiftSeedSlice(seed);\\n\\t\\t\\tgenome = generateAndSetGene(\\n\\t\\t\\t\\tgenome,\\n\\t\\t\\t\\tgenerativeGenesOffset + i,\\n\\t\\t\\t\\tgeneValuesNum[i],\\n\\t\\t\\t\\tdistrType,\\n\\t\\t\\t\\tbitSlice\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t// set default values for Ducklings\\n\\t\\tif (collectionId == ducklingCollectionId) {\\n\\t\\t\\tIDuckyFamily.Rarities rarity = IDuckyFamily.Rarities(genome.getGene(rarityGeneIdx));\\n\\n\\t\\t\\tif (rarity == IDuckyFamily.Rarities.Common) {\\n\\t\\t\\t\\tgenome = genome.setGene(uint8(IDuckyFamily.GenerativeGenes.Body), 0);\\n\\t\\t\\t\\tgenome = genome.setGene(uint8(IDuckyFamily.GenerativeGenes.Head), 0);\\n\\t\\t\\t} else if (rarity == IDuckyFamily.Rarities.Rare) {\\n\\t\\t\\t\\tgenome = genome.setGene(uint8(IDuckyFamily.GenerativeGenes.Head), 0);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn genome;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Generate and set a gene with `geneIdx` to `genome`.\\n\\t * @dev Generate and set a gene with `geneIdx` to `genome`.\\n\\t * @param genome Genome to set a gene to.\\n\\t * @param geneIdx Gene index.\\n\\t * @param geneValuesNum Number of gene values.\\n\\t * @param distrType Gene distribution type.\\n\\t * @param bitSlice Random bit slice to generate a gene from.\\n\\t * @return genome Genome with set gene.\\n\\t */\\n\\tfunction generateAndSetGene(\\n\\t\\tuint256 genome,\\n\\t\\tuint8 geneIdx,\\n\\t\\tuint8 geneValuesNum,\\n\\t\\tIDuckyFamily.GeneDistributionTypes distrType,\\n\\t\\tbytes3 bitSlice\\n\\t) internal pure returns (uint256) {\\n\\t\\tuint8 geneValue;\\n\\n\\t\\tif (distrType == IDuckyFamily.GeneDistributionTypes.Even) {\\n\\t\\t\\tgeneValue = uint8(Utils.randomNumber(bitSlice, geneValuesNum));\\n\\t\\t} else {\\n\\t\\t\\tgeneValue = uint8(generateUnevenGeneValue(geneValuesNum, bitSlice));\\n\\t\\t}\\n\\n\\t\\t// gene with value 0 means it is a default value, thus this   \\\\/\\n\\t\\tgenome = genome.setGene(geneIdx, geneValue + 1);\\n\\n\\t\\treturn genome;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Check that `genomes` satisfy melding rules. Reverts if not.\\n\\t * @dev Check that `genomes` satisfy melding rules. Reverts if not.\\n\\t * @param genomes Array of genomes to check.\\n\\t */\\n\\tfunction requireGenomesSatisfyMelding(uint256[] memory genomes) internal pure {\\n\\t\\tif (\\n\\t\\t\\t// equal collections\\n\\t\\t\\t!Genome.geneValuesAreEqual(genomes, collectionGeneIdx) ||\\n\\t\\t\\t// Rarities must be the same\\n\\t\\t\\t!Genome.geneValuesAreEqual(genomes, rarityGeneIdx) ||\\n\\t\\t\\t// not Mythic\\n\\t\\t\\tgenomes[0].getGene(collectionGeneIdx) == mythicCollectionId\\n\\t\\t) revert IDuckyFamily.IncorrectGenomesForMelding(genomes);\\n\\n\\t\\tIDuckyFamily.Rarities rarity = IDuckyFamily.Rarities(genomes[0].getGene(rarityGeneIdx));\\n\\t\\tbool sameColors = Genome.geneValuesAreEqual(\\n\\t\\t\\tgenomes,\\n\\t\\t\\tuint8(IDuckyFamily.GenerativeGenes.Color)\\n\\t\\t);\\n\\t\\tbool sameFamilies = Genome.geneValuesAreEqual(\\n\\t\\t\\tgenomes,\\n\\t\\t\\tuint8(IDuckyFamily.GenerativeGenes.Family)\\n\\t\\t);\\n\\t\\tbool uniqueFamilies = Genome.geneValuesAreUnique(\\n\\t\\t\\tgenomes,\\n\\t\\t\\tuint8(IDuckyFamily.GenerativeGenes.Family)\\n\\t\\t);\\n\\n\\t\\t// specific melding rules\\n\\t\\tif (rarity == IDuckyFamily.Rarities.Common) {\\n\\t\\t\\t// Common\\n\\t\\t\\tif (\\n\\t\\t\\t\\t// cards must have the same Color OR the same Family\\n\\t\\t\\t\\t!sameColors && !sameFamilies\\n\\t\\t\\t) revert IDuckyFamily.IncorrectGenomesForMelding(genomes);\\n\\t\\t} else {\\n\\t\\t\\t// Rare, Epic\\n\\t\\t\\tif (rarity == IDuckyFamily.Rarities.Rare || rarity == IDuckyFamily.Rarities.Epic) {\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t// cards must have the same Color AND the same Family\\n\\t\\t\\t\\t\\t!sameColors || !sameFamilies\\n\\t\\t\\t\\t) revert IDuckyFamily.IncorrectGenomesForMelding(genomes);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Legendary\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t// not Legendary Zombeak\\n\\t\\t\\t\\t\\tgenomes[0].getGene(collectionGeneIdx) == zombeakCollectionId ||\\n\\t\\t\\t\\t\\t// cards must have the same Color AND be of each Family\\n\\t\\t\\t\\t\\t!sameColors ||\\n\\t\\t\\t\\t\\t!uniqueFamilies\\n\\t\\t\\t\\t) revert IDuckyFamily.IncorrectGenomesForMelding(genomes);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Randomize if collection is mutating.\\n\\t * @dev Randomize if collection is mutating.\\n\\t * @param rarity Rarity of the collection.\\n\\t * @param mutationChances Array of mutation chances for each rarity.\\n\\t * @param bitSlice Bit slice to use for randomization.\\n\\t * @return isMutating True if mutating, false otherwise.\\n\\t */\\n\\tfunction isCollectionMutating(\\n\\t\\tIDuckyFamily.Rarities rarity,\\n\\t\\tuint32[] memory mutationChances,\\n\\t\\tbytes3 bitSlice\\n\\t) internal pure returns (bool) {\\n\\t\\t// check if mutating chance for this rarity is present\\n\\t\\tif (mutationChances.length <= uint8(rarity)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tuint32 mutationPercentage = mutationChances[uint8(rarity)];\\n\\t\\t// dynamic array is needed for `randomWeightedNumber()`\\n\\t\\tuint32[] memory chances = new uint32[](2);\\n\\t\\tchances[0] = mutationPercentage;\\n\\t\\tchances[1] = 1000 - mutationPercentage; // 1000 as changes are represented in per mil\\n\\t\\treturn Utils.randomWeightedNumber(chances, bitSlice) == 0;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Meld `gene` from `genomes` into a new gene value.\\n\\t * @dev Meld `gene` from `genomes` into a new gene value. Gene mutation and inheritance are applied.\\n\\t * @param genomes Array of genomes to meld.\\n\\t * @param gene Gene to be meld.\\n\\t * @param maxGeneValue Max gene value.\\n\\t * @param geneDistrType Gene distribution type.\\n\\t * @param mutationChance Mutation chance. Represented as [chance of no mutation, chance of mutation] in per mil.\\n\\t * @param inheritanceChances Array of inheritance chances for each rarity.\\n\\t * @param bitSlice Bit slice to use for randomization.\\n\\t * @return geneValue Melded gene value.\\n\\t */\\n\\tfunction meldGenes(\\n\\t\\tuint256[] memory genomes,\\n\\t\\tuint8 gene,\\n\\t\\tuint8 maxGeneValue,\\n\\t\\tIDuckyFamily.GeneDistributionTypes geneDistrType,\\n\\t\\tuint32[] memory mutationChance,\\n\\t\\tuint32[] memory inheritanceChances,\\n\\t\\tbytes3 bitSlice\\n\\t) internal pure returns (uint8) {\\n\\t\\t// gene mutation\\n\\t\\tif (\\n\\t\\t\\tgeneDistrType == IDuckyFamily.GeneDistributionTypes.Uneven &&\\n\\t\\t\\tUtils.randomWeightedNumber(mutationChance, bitSlice) == 1\\n\\t\\t) {\\n\\t\\t\\tuint8 maxPresentGeneValue = Genome.maxGene(genomes, gene);\\n\\t\\t\\treturn maxPresentGeneValue == maxGeneValue ? maxGeneValue : maxPresentGeneValue + 1;\\n\\t\\t}\\n\\n\\t\\t// gene inheritance\\n\\t\\tuint8 inheritanceIdx = Utils.randomWeightedNumber(inheritanceChances, bitSlice);\\n\\t\\treturn genomes[inheritanceIdx].getGene(gene);\\n\\t}\\n\\n\\t// ------- Helpers -------\\n\\n\\t/**\\n\\t * @notice Get gene distribution type.\\n\\t * @dev Get gene distribution type.\\n\\t * @param distributionTypes Distribution types.\\n\\t * @param idx Index of the gene.\\n\\t * @return Gene distribution type.\\n\\t */\\n\\tfunction getDistributionType(\\n\\t\\tuint32 distributionTypes,\\n\\t\\tuint8 idx\\n\\t) internal pure returns (IDuckyFamily.GeneDistributionTypes) {\\n\\t\\treturn\\n\\t\\t\\tdistributionTypes & (1 << idx) == 0\\n\\t\\t\\t\\t? IDuckyFamily.GeneDistributionTypes.Even\\n\\t\\t\\t\\t: IDuckyFamily.GeneDistributionTypes.Uneven;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Generate uneven gene value given the maximum number of values.\\n\\t * @dev Generate uneven gene value using reciprocal distribution described below.\\n\\t * @param valuesNum Maximum number of gene values.\\n\\t * @param bitSlice Bit slice to use for randomization.\\n\\t * @return geneValue Gene value.\\n\\t */\\n\\tfunction generateUnevenGeneValue(\\n\\t\\tuint8 valuesNum,\\n\\t\\tbytes3 bitSlice\\n\\t) internal pure returns (uint8) {\\n\\t\\t// using reciprocal distribution\\n\\t\\t// gene value is selected as ceil[(2N/(x+1))-N],\\n\\t\\t// where x is random number between 0 and 1\\n\\t\\t// Because of shape of reciprocal graph,\\n\\t\\t// evenly distributed x values will result in unevenly distributed y values.\\n\\n\\t\\t// N - number of gene values\\n\\t\\tuint256 N = uint256(valuesNum);\\n\\t\\t// Generates number from 1 to 10^6\\n\\t\\tuint256 x = 1 + Utils.randomNumber(bitSlice, 1_000_000);\\n\\t\\t// Calculates uneven distributed y, value of y is between 0 and N\\n\\t\\tuint256 y = (2 * N * 1_000) / (Math.sqrt(x) + 1_000) - N;\\n\\t\\treturn uint8(y);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Calculate max peculiarity for a supplied config.\\n\\t * @dev Sum up number of uneven gene values.\\n\\t * @param geneValuesNum Array of number of gene values for each gene.\\n\\t * @param geneDistrTypes Gene distribution types.\\n\\t * @return maxPeculiarity Max peculiarity.\\n\\t */\\n\\tfunction calcConfigPeculiarity(\\n\\t\\tuint8[] memory geneValuesNum,\\n\\t\\tuint32 geneDistrTypes\\n\\t) internal pure returns (uint16) {\\n\\t\\tuint16 sum = 0;\\n\\n\\t\\tuint8 genesNum = uint8(geneValuesNum.length);\\n\\t\\tfor (uint8 i = 0; i < genesNum; i++) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\tgetDistributionType(geneDistrTypes, i) == IDuckyFamily.GeneDistributionTypes.Uneven\\n\\t\\t\\t) {\\n\\t\\t\\t\\t// add number of values and not actual values as actual values start with 1, which means number of values and actual values are equal\\n\\t\\t\\t\\tsum += geneValuesNum[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Calculate peculiarity for a given genome.\\n\\t * @dev Sum up number of uneven gene values.\\n\\t * @param genome Genome.\\n\\t * @param genesNum Number of genes.\\n\\t * @param geneDistrTypes Gene distribution types.\\n\\t * @return peculiarity Peculiarity.\\n\\t */\\n\\tfunction calcPeculiarity(\\n\\t\\tuint256 genome,\\n\\t\\tuint8 genesNum,\\n\\t\\tuint32 geneDistrTypes\\n\\t) internal pure returns (uint16) {\\n\\t\\tuint16 sum = 0;\\n\\n\\t\\tfor (uint8 i = 0; i < genesNum; i++) {\\n\\t\\t\\tif (\\n\\t\\t\\t\\tgetDistributionType(geneDistrTypes, i) == IDuckyFamily.GeneDistributionTypes.Uneven\\n\\t\\t\\t) {\\n\\t\\t\\t\\t// add number of values and not actual values as actual values start with 1, which means number of values and actual values are equal\\n\\t\\t\\t\\tsum += genome.getGene(i + generativeGenesOffset);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Calculate `leftEndUniqId` and `uniqIdSegmentLength` for UniqId generation.\\n\\t * @dev Then UniqId is generated by adding a random number [0, `uniqIdSegmentLength`) to `leftEndUniqId`.\\n\\t * @param pivotalUniqId Pivotal UniqId.\\n\\t * @param maxUniqId Max UniqId.\\n\\t * @param mythicDispersion Half of the segment length in which mythic UniqIds are generated.\\n\\t * @return leftEndUniqId Left end of the UniqId segment.\\n\\t * @return uniqIdSegmentLength Length of the UniqId segment.\\n\\t */\\n\\tfunction calcUniqIdGenerationParams(\\n\\t\\tuint16 pivotalUniqId,\\n\\t\\tuint16 maxUniqId,\\n\\t\\tuint16 mythicDispersion\\n\\t) internal pure returns (uint16 leftEndUniqId, uint16 uniqIdSegmentLength) {\\n\\t\\tif (pivotalUniqId < mythicDispersion) {\\n\\t\\t\\t// mythic id range overlaps with left dispersion border\\n\\t\\t\\tleftEndUniqId = 0;\\n\\t\\t\\tuniqIdSegmentLength = pivotalUniqId + mythicDispersion;\\n\\t\\t} else if (maxUniqId < pivotalUniqId + mythicDispersion) {\\n\\t\\t\\t// mythic id range overlaps with right dispersion border\\n\\t\\t\\tleftEndUniqId = pivotalUniqId - mythicDispersion;\\n\\t\\t\\tuniqIdSegmentLength = maxUniqId - leftEndUniqId + 1; // +1 to include right border, where the last UniqId is located\\n\\t\\t} else {\\n\\t\\t\\t// mythic id range does not overlap with dispersion borders\\n\\t\\t\\tleftEndUniqId = pivotalUniqId - mythicDispersion;\\n\\t\\t\\tuniqIdSegmentLength = 2 * mythicDispersion;\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/duckies/games/Genome.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Genome\\n *\\n * @notice The library to work with NFT genomes.\\n *\\n * Genome is a number with a special structure that defines Duckling genes.\\n * All genes are packed consequently in the reversed order in the Genome, meaning the first gene being stored in the last Genome bits.\\n * Each gene takes up the block of 8 bits in genome, thus having 256 possible values.\\n *\\n * Example of genome, following genes Rarity, Head and Body are defined:\\n *\\n * 00000001|00000010|00000011\\n *   Body    Head     Rarity\\n *\\n * This genome can be represented in uint24 as 66051.\\n * Genes have the following values: Body = 1, Head = 2, Rarity = 3.\\n */\\nlibrary Genome {\\n\\t/// @notice Number of bits each gene constitutes. Thus, each gene can have 2^8 = 256 possible values.\\n\\tuint8 public constant BITS_PER_GENE = 8;\\n\\n\\tuint8 public constant COLLECTION_GENE_IDX = 0;\\n\\n\\t// Flags\\n\\t/// @notice Reserve 30th gene for bool flags, which are stored as a bit field.\\n\\tuint8 public constant FLAGS_GENE_IDX = 30;\\n\\tuint8 public constant FLAG_TRANSFERABLE = 1; // 0b0000_0001\\n\\n\\t// Magic number\\n\\t/// @notice Reserve 31th gene for magic number, which is used as an extension for genomes.\\n\\t/// Genomes with wrong extension are considered invalid.\\n\\tuint8 public constant MAGIC_NUMBER_GENE_IDX = 31;\\n\\tuint8 public constant BASE_MAGIC_NUMBER = 209; // \u00d0\\n\\tuint8 public constant MYTHIC_MAGIC_NUMBER = 210; // \u00d0 + 1\\n\\n\\t/**\\n\\t * @notice Read flags gene from genome.\\n\\t * @dev Read flags gene from genome.\\n\\t * @param self Genome to get flags gene from.\\n\\t * @return flags Flags gene.\\n\\t */\\n\\tfunction getFlags(uint256 self) internal pure returns (uint8) {\\n\\t\\treturn getGene(self, FLAGS_GENE_IDX);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Read specific bit mask flag from genome.\\n\\t * @dev Read specific bit mask flag from genome.\\n\\t * @param self Genome to read flag from.\\n\\t * @param flag Bit mask flag to read.\\n\\t * @return value Value of the flag.\\n\\t */\\n\\tfunction getFlag(uint256 self, uint8 flag) internal pure returns (bool) {\\n\\t\\treturn getGene(self, FLAGS_GENE_IDX) & flag > 0;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set specific bit mask flag in genome.\\n\\t * @dev Set specific bit mask flag in genome.\\n\\t * @param self Genome to set flag in.\\n\\t * @param flag Bit mask flag to set.\\n\\t * @param value Value of the flag.\\n\\t * @return genome Genome with the flag set.\\n\\t */\\n\\tfunction setFlag(uint256 self, uint8 flag, bool value) internal pure returns (uint256) {\\n\\t\\tuint8 flags = getGene(self, FLAGS_GENE_IDX);\\n\\t\\tif (value) {\\n\\t\\t\\tflags |= flag;\\n\\t\\t} else {\\n\\t\\t\\tflags &= ~flag;\\n\\t\\t}\\n\\t\\treturn setGene(self, FLAGS_GENE_IDX, flags);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Set `value` to `gene` in genome.\\n\\t * @dev Set `value` to `gene` in genome.\\n\\t * @param self Genome to set gene in.\\n\\t * @param gene Gene to set.\\n\\t * @param value Value to set.\\n\\t * @return genome Genome with the gene set.\\n\\t */\\n\\tfunction setGene(\\n\\t\\tuint256 self,\\n\\t\\tuint8 gene,\\n\\t\\t// by specifying uint8 we set maxCap for gene values, which is 256\\n\\t\\tuint8 value\\n\\t) internal pure returns (uint256) {\\n\\t\\t// number of bytes from genome's rightmost and geneBlock's rightmost\\n\\t\\t// NOTE: maximum index of a gene is actually uint5\\n\\t\\tuint8 shiftingBy = gene * BITS_PER_GENE;\\n\\n\\t\\t// remember genes we will shift off\\n\\t\\tuint256 shiftedPart = self & ((1 << shiftingBy) - 1);\\n\\n\\t\\t// shift right so that genome's rightmost bit is the geneBlock's rightmost\\n\\t\\tself >>= shiftingBy;\\n\\n\\t\\t// clear previous gene value by shifting it off\\n\\t\\tself >>= BITS_PER_GENE;\\n\\t\\tself <<= BITS_PER_GENE;\\n\\n\\t\\t// update gene's value\\n\\t\\tself += value;\\n\\n\\t\\t// reserve space for restoring previously shifted off values\\n\\t\\tself <<= shiftingBy;\\n\\n\\t\\t// restore previously shifted off values\\n\\t\\tself += shiftedPart;\\n\\n\\t\\treturn self;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Get `gene` value from genome.\\n\\t * @dev Get `gene` value from genome.\\n\\t * @param self Genome to get gene from.\\n\\t * @param gene Gene to get.\\n\\t * @return geneValue Gene value.\\n\\t */\\n\\tfunction getGene(uint256 self, uint8 gene) internal pure returns (uint8) {\\n\\t\\t// number of bytes from genome's rightmost and geneBlock's rightmost\\n\\t\\t// NOTE: maximum index of a gene is actually uint5\\n\\t\\tuint8 shiftingBy = gene * BITS_PER_GENE;\\n\\n\\t\\tuint256 temp = self >> shiftingBy;\\n\\t\\treturn uint8(temp & ((1 << BITS_PER_GENE) - 1));\\n\\t}\\n\\n\\t/**\\n\\t * @notice Get largest value of a `gene` in `genomes`.\\n\\t * @dev Get largest value of a `gene` in `genomes`.\\n\\t * @param genomes Genomes to get gene from.\\n\\t * @param gene Gene to get.\\n\\t * @return maxValue Largest value of a `gene` in `genomes`.\\n\\t */\\n\\tfunction maxGene(uint256[] memory genomes, uint8 gene) internal pure returns (uint8) {\\n\\t\\tuint8 maxValue = 0;\\n\\n\\t\\tfor (uint256 i = 0; i < genomes.length; i++) {\\n\\t\\t\\tuint8 geneValue = getGene(genomes[i], gene);\\n\\t\\t\\tif (maxValue < geneValue) {\\n\\t\\t\\t\\tmaxValue = geneValue;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn maxValue;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Check if values of `gene` in `genomes` are equal.\\n\\t * @dev Check if values of `gene` in `genomes` are equal.\\n\\t * @param genomes Genomes to check.\\n\\t * @param gene Gene to check.\\n\\t * @return isEqual True if values of `gene` in `genomes` are equal, false otherwise.\\n\\t */\\n\\tfunction geneValuesAreEqual(uint256[] memory genomes, uint8 gene) internal pure returns (bool) {\\n\\t\\tuint8 geneValue = getGene(genomes[0], gene);\\n\\n\\t\\tfor (uint256 i = 1; i < genomes.length; i++) {\\n\\t\\t\\tif (getGene(genomes[i], gene) != geneValue) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Check if values of `gene` in `genomes` are unique.\\n\\t * @dev Check if values of `gene` in `genomes` are unique.\\n\\t * @param genomes Genomes to check.\\n\\t * @param gene Gene to check.\\n\\t * @return isUnique True if values of `gene` in `genomes` are unique, false otherwise.\\n\\t */\\n\\tfunction geneValuesAreUnique(\\n\\t\\tuint256[] memory genomes,\\n\\t\\tuint8 gene\\n\\t) internal pure returns (bool) {\\n\\t\\tuint256 valuesPresentBitfield = 1 << getGene(genomes[0], gene);\\n\\n\\t\\tfor (uint256 i = 1; i < genomes.length; i++) {\\n\\t\\t\\tif (valuesPresentBitfield & (1 << getGene(genomes[i], gene)) != 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tvaluesPresentBitfield |= 1 << getGene(genomes[i], gene);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/duckies/games/Seeding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Seeding\\n * @notice A contract that provides seeds for pseudo random number generation.\\n * Seed is created from the salt, pepper, nonce, sender address, and block timestamp.\\n * Seed is divided into 32 bit slices, and each slice is later used to generate a random number.\\n * Seed user must keep track of used bit slices to avoid reusing them.\\n * Salt is a data based on block timestamp and msg sender, and is calculated every time a seed is generated.\\n * Pepper is a random data changed periodically by external entity.\\n * Nonce is incremented every time a random number is generated.\\n */\\ncontract Seeding {\\n\\tbytes32 private salt;\\n\\tbytes32 private pepper;\\n\\tuint256 private nonce;\\n\\n\\t/**\\n\\t * @notice Sets the pepper.\\n\\t * @dev Pepper is a random data changed periodically by external entity.\\n\\t * @param newPepper New pepper.\\n\\t */\\n\\tfunction _setPepper(bytes32 newPepper) internal {\\n\\t\\tpepper = newPepper;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Creates a new seed based on the salt, pepper, nonce, sender address, and block timestamp.\\n\\t * @dev Creates a new seed based on the salt, pepper, nonce, sender address, and block timestamp.\\n\\t * @return New seed.\\n\\t */\\n\\tfunction _randomSeed() internal returns (bytes32) {\\n\\t\\t// use old salt to generate a new one, so that user's predictions are invalid after function that uses random is called\\n\\t\\tsalt = keccak256(abi.encode(salt, msg.sender, block.timestamp));\\n\\t\\tunchecked {\\n\\t\\t\\tnonce++;\\n\\t\\t}\\n\\n\\t\\treturn keccak256(abi.encode(salt, pepper, nonce, msg.sender, block.timestamp));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/duckies/games/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\\n\\nimport '../../interfaces/IVoucher.sol';\\n\\n/**\\n * @title Utils\\n * @notice Utility functions for games, that include pseudo random number generation, signature verification, etc.\\n *\\n * Pseudo random number generation is based on the bitSlices, which are part of a seed created in `Seeding.sol`.\\n */\\nlibrary Utils {\\n\\tusing ECDSA for bytes32;\\n\\n\\t/**\\n\\t * @notice Invalid weights error while trying to generate a weighted random number.\\n\\t * @param weights Empty weights array.\\n\\t */\\n\\terror InvalidWeights(uint32[] weights);\\n\\n\\t/**\\n\\t * @notice Perform circular shift on the seed by 3 bytes to the left, and returns the shifted slice and the updated seed.\\n\\t * @dev User of this contract must keep track of used bit slices to avoid reusing them.\\n\\t * @param seed Seed to shift and extract the shifted slice from.\\n\\t * @return bitSlice Shifted bit slice.\\n\\t * @return updatedSeed Shifted seed.\\n\\t */\\n\\tfunction shiftSeedSlice(bytes32 seed) internal pure returns (bytes3, bytes32) {\\n\\t\\tbytes3 slice = bytes3(seed);\\n\\t\\treturn (slice, (seed << 24) | (bytes32(slice) >> 232));\\n\\t}\\n\\n\\t/**\\n\\t * @notice Extracts a number from the bit slice in range [0, max).\\n\\t * @dev Extracts a number from the bit slice in range [0, max).\\n\\t * @param bitSlice Bit slice to extract the number from.\\n\\t * @param max Max number to extract.\\n\\t * @return Extracted number in range [0, max).\\n\\t */\\n\\tfunction randomNumber(bytes3 bitSlice, uint24 max) internal pure returns (uint24) {\\n\\t\\treturn uint24(bitSlice) % max;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Generates a weighted random number in range [0, weights.length).\\n\\t * @dev Number `x` is generated with probability `weights[x] / sum(weights)`.\\n\\t * @param weights Array of weights.\\n\\t * @return Random number in range [0, weights.length).\\n\\t */\\n\\tfunction randomWeightedNumber(\\n\\t\\tuint32[] memory weights, // chances are represented in per mil\\n\\t\\tbytes3 bitSlice\\n\\t) internal pure returns (uint8) {\\n\\t\\tuint24 wsum = uint24(sum(weights));\\n\\n\\t\\t// no sense in empty weights array\\n\\t\\tif (weights.length == 0 || wsum == 0) revert InvalidWeights(weights);\\n\\n\\t\\tuint256 rnum = randomNumber(bitSlice, wsum);\\n\\n\\t\\tuint256 segmentRightBoundary = 0;\\n\\n\\t\\tfor (uint8 i = 0; i < weights.length; i++) {\\n\\t\\t\\tsegmentRightBoundary += weights[i];\\n\\t\\t\\tif (rnum < segmentRightBoundary) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// execution should never reach this\\n\\t\\treturn uint8(weights.length - 1);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Calculates sum of all elements in array.\\n\\t * @dev Calculates sum of all elements in array.\\n\\t * @param numbers Array of numbers.\\n\\t * @return res Sum of all elements in array.\\n\\t */\\n\\tfunction sum(uint32[] memory numbers) internal pure returns (uint256 res) {\\n\\t\\tfor (uint256 i = 0; i < numbers.length; i++) res += numbers[i];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Check that `signatures is `encodedData` signed by `signer`. Reverts if not.\\n\\t * @dev Check that `signatures is `encodedData` signed by `signer`. Reverts if not.\\n\\t * @param encodedData Data to check.\\n\\t * @param signature Signature to check.\\n\\t * @param signer Address of the signer.\\n\\t */\\n\\tfunction requireCorrectSigner(\\n\\t\\tbytes memory encodedData,\\n\\t\\tbytes memory signature,\\n\\t\\taddress signer\\n\\t) internal pure {\\n\\t\\taddress actualSigner = keccak256(encodedData).toEthSignedMessageHash().recover(signature);\\n\\t\\tif (actualSigner != signer) revert IVoucher.IncorrectSigner(signer, actualSigner);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDucklings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.18;\\n\\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';\\n\\n/**\\n * @title IDucklings\\n * @notice This interface defines the Ducklings ERC721-compatible contract,\\n * which provides basic functionality for minting, burning and querying information about the tokens.\\n */\\ninterface IDucklings is IERC721Upgradeable {\\n\\t/**\\n\\t * @notice Token not transferable error. Is used when trying to transfer a token that is not transferable.\\n\\t * @param tokenId Token Id that is not transferable.\\n\\t */\\n\\terror TokenNotTransferable(uint256 tokenId);\\n\\t/**\\n\\t * @notice Invalid magic number error. Is used when trying to mint a token with an invalid magic number.\\n\\t * @param magicNumber Magic number that is invalid.\\n\\t */\\n\\terror InvalidMagicNumber(uint8 magicNumber);\\n\\n\\tstruct Duckling {\\n\\t\\tuint256 genome;\\n\\t\\tuint64 birthdate;\\n\\t}\\n\\n\\t// events\\n\\t/**\\n\\t * @notice Minted event. Is emitted when a token is minted.\\n\\t * @param to Address of the token owner.\\n\\t * @param tokenId Id of the minted token.\\n\\t * @param genome Genome of the minted token.\\n\\t * @param birthdate Birthdate of the minted token.\\n\\t * @param chainId Id of the chain where the token was minted.\\n\\t */\\n\\tevent Minted(address to, uint256 tokenId, uint256 genome, uint64 birthdate, uint256 chainId);\\n\\n\\t/**\\n\\t * @notice Check whether `account` is owner of `tokenId`.\\n\\t * @dev Revert if `account` is address(0) or `tokenId` does not exist.\\n\\t * @param account Address to check.\\n\\t * @param tokenId Token Id to check.\\n\\t * @return isOwnerOf True if `account` is owner of `tokenId`, false otherwise.\\n\\t */\\n\\tfunction isOwnerOf(address account, uint256 tokenId) external view returns (bool);\\n\\n\\t/**\\n\\t * @notice Check whether `account` is owner of `tokenIds`.\\n\\t * @dev Revert if `account` is address(0) or any of `tokenIds` do not exist.\\n\\t * @param account Address to check.\\n\\t * @param tokenIds Token Ids to check.\\n\\t * @return isOwnerOfBatch True if `account` is owner of `tokenIds`, false otherwise.\\n\\t */\\n\\tfunction isOwnerOfBatch(\\n\\t\\taddress account,\\n\\t\\tuint256[] calldata tokenIds\\n\\t) external view returns (bool);\\n\\n\\t/**\\n\\t * @notice Get genome of `tokenId`.\\n\\t * @dev Revert if `tokenId` does not exist.\\n\\t * @param tokenId Token Id to get the genome of.\\n\\t * @return genome Genome of `tokenId`.\\n\\t */\\n\\tfunction getGenome(uint256 tokenId) external view returns (uint256);\\n\\n\\t/**\\n\\t * @notice Get genomes of `tokenIds`.\\n\\t * @dev Revert if any of `tokenIds` do not exist.\\n\\t * @param tokenIds Token Ids to get the genomes of.\\n\\t * @return genomes Genomes of `tokenIds`.\\n\\t */\\n\\tfunction getGenomes(uint256[] calldata tokenIds) external view returns (uint256[] memory);\\n\\n\\t/**\\n\\t * @notice Mint token with `genome` to `to`. Emits Minted event.\\n\\t * @dev Revert if `to` is address(0) or `genome` has wrong magic number.\\n\\t * @param to Address to mint token to.\\n\\t * @param genome Genome of the token to mint.\\n\\t * @return tokenId Id of the minted token.\\n\\t */\\n\\tfunction mintTo(address to, uint256 genome) external returns (uint256);\\n\\n\\t/**\\n\\t * @notice Mint tokens with `genomes` to `to`. Emits Minted event for each token.\\n\\t * @dev Revert if `to` is address(0) or any of `genomes` has wrong magic number.\\n\\t * @param to Address to mint tokens to.\\n\\t * @param genomes Genomes of the tokens to mint.\\n\\t * @return tokenIds Ids of the minted tokens.\\n\\t */\\n\\tfunction mintBatchTo(\\n\\t\\taddress to,\\n\\t\\tuint256[] calldata genomes\\n\\t) external returns (uint256[] memory);\\n\\n\\t/**\\n\\t * @notice Burn token with `tokenId`.\\n\\t * @dev Revert if `tokenId` does not exist.\\n\\t * @param tokenId Id of the token to burn.\\n\\t */\\n\\tfunction burn(uint256 tokenId) external;\\n\\n\\t/**\\n\\t * @notice Burn tokens with `tokenIds`.\\n\\t * @dev Revert if any of `tokenIds` do not exist.\\n\\t * @param tokenIds Ids of the tokens to burn.\\n\\t */\\n\\tfunction burnBatch(uint256[] calldata tokenIds) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDuckyFamily.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.18;\\n\\nimport './IVoucher.sol';\\n\\ninterface IDuckyFamily is IVoucher {\\n\\t// Errors\\n\\terror InvalidMintParams(MintParams mintParams);\\n\\terror InvalidMeldParams(MeldParams meldParams);\\n\\n\\terror MintingRulesViolated(uint8 collectionId, uint8 amount);\\n\\terror MeldingRulesViolated(uint256[] tokenIds);\\n\\terror IncorrectGenomesForMelding(uint256[] genomes);\\n\\n\\t// Events\\n\\tevent Melded(address owner, uint256[] meldingTokenIds, uint256 meldedTokenId, uint256 chainId);\\n\\n\\t// Vouchers\\n\\tenum VoucherActions {\\n\\t\\tMintPack,\\n\\t\\tMeldFlock\\n\\t}\\n\\n\\tstruct MintParams {\\n\\t\\taddress to;\\n\\t\\tuint8 size;\\n\\t\\tbool isTransferable;\\n\\t}\\n\\n\\tstruct MeldParams {\\n\\t\\taddress owner;\\n\\t\\tuint256[] tokenIds;\\n\\t\\tbool isTransferable;\\n\\t}\\n\\n\\t// DuckyFamily\\n\\n\\t// for now, Solidity does not support starting value for enum\\n\\t// enum Collections {\\n\\t// \\tDuckling = 0,\\n\\t// \\tZombeak,\\n\\t// \\tMythic\\n\\t// }\\n\\n\\tenum Rarities {\\n\\t\\tCommon,\\n\\t\\tRare,\\n\\t\\tEpic,\\n\\t\\tLegendary\\n\\t}\\n\\n\\tenum GeneDistributionTypes {\\n\\t\\tEven,\\n\\t\\tUneven\\n\\t}\\n\\n\\tenum GenerativeGenes {\\n\\t\\tCollection,\\n\\t\\tRarity,\\n\\t\\tColor,\\n\\t\\tFamily,\\n\\t\\tBody,\\n\\t\\tHead\\n\\t}\\n\\n\\tenum MythicGenes {\\n\\t\\tCollection,\\n\\t\\tUniqId\\n\\t}\\n\\n\\t// Config\\n\\tfunction getMintPrice() external view returns (uint256);\\n\\n\\tfunction getMeldPrices() external view returns (uint256[4] memory);\\n\\n\\tfunction getCollectionsGeneValues() external view returns (uint8[][3] memory, uint8);\\n\\n\\tfunction getCollectionsGeneDistributionTypes() external view returns (uint32[3] memory);\\n\\n\\t// Mint and Meld\\n\\tfunction mintPack(uint8 size) external;\\n\\n\\tfunction meldFlock(uint256[] calldata meldingTokenIds) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVoucher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.18;\\n\\n/**\\n * @notice Interface describing Voucher for redeeming game items\\n *\\n * @dev The Voucher type must have a strict implementation on backend\\n *\\n * A Voucher is a document signed from the server IssuerKey and allows the execution\\n * of actions on the game generally for creating game items, such as Booster Packs, Meld or reward tokens\\n *\\n */\\ninterface IVoucher {\\n\\t/**\\n\\t * @notice Custom error specifying that voucher has already been used.\\n\\t * @param voucherCodeHash Hash of the code of the voucher that has been used.\\n\\t */\\n\\terror VoucherAlreadyUsed(bytes32 voucherCodeHash);\\n\\n\\t/**\\n\\t * @notice Custom error specifying that voucher has not passed general voucher checks and is invalid.\\n\\t * @param voucher Voucher that is invalid.\\n\\t */\\n\\terror InvalidVoucher(Voucher voucher);\\n\\n\\t/**\\n\\t * @notice Custom error specifying that the message was expected to be signed by `expected` address, but was signed by `actual`.\\n\\t * @param expected Expected address to have signed the message.\\n\\t * @param actual Actual address that has signed the message.\\n\\t */\\n\\terror IncorrectSigner(address expected, address actual);\\n\\n\\t/**\\n\\t * @dev Build and encode the Voucher from server side\\n\\t *\\n\\t * Voucher structure will be valid only in chainId until expire timestamp\\n\\t * the beneficiary MUST be the same as the user redeeming the Voucher.\\n\\t *\\n\\t */\\n\\tstruct Voucher {\\n\\t\\taddress target; // contract address which the voucher is meant for\\n\\t\\tuint8 action; // voucher type defined by the implementation\\n\\t\\taddress beneficiary; // beneficiary account which voucher will redeem to\\n\\t\\taddress referrer; // address of the parent\\n\\t\\tuint64 expire; // expiration time in seconds UTC\\n\\t\\tuint32 chainId; // chain id of the voucher\\n\\t\\tbytes32 voucherCodeHash; // hash of voucherCode\\n\\t\\tbytes encodedParams; // voucher type specific encoded params\\n\\t}\\n\\n\\t/**\\n\\t * @notice Use vouchers that were issued and signed by the Back-end to receive game items.\\n\\t * @param vouchers Vouchers issued by the Back-end.\\n\\t * @param signature Vouchers signed by the Back-end.\\n\\t */\\n\\tfunction useVouchers(Voucher[] calldata vouchers, bytes calldata signature) external;\\n\\n\\t/**\\n\\t * @notice Use the voucher that was signed by the Back-end to receive game items.\\n\\t * @param voucher Voucher issued by the Back-end.\\n\\t * @param signature Voucher signed by the Back-end.\\n\\t */\\n\\tfunction useVoucher(Voucher calldata voucher, bytes calldata signature) external;\\n\\n\\t/**\\n\\t * @notice Event specifying that a voucher has been used.\\n\\t * @param wallet Wallet that used a voucher.\\n\\t * @param action The action of the voucher used.\\n\\t * @param voucherCodeHash The code hash of the voucher used.\\n\\t * @param chainId Id of the chain the voucher was used on.\\n\\t */\\n\\tevent VoucherUsed(address wallet, uint8 action, bytes32 voucherCodeHash, uint32 chainId);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"duckiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ducklingsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasureVaultAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"genomes\",\"type\":\"uint256[]\"}],\"name\":\"IncorrectGenomesForMelding\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"expected\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actual\",\"type\":\"address\"}],\"name\":\"IncorrectSigner\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"isTransferable\",\"type\":\"bool\"}],\"internalType\":\"struct IDuckyFamily.MeldParams\",\"name\":\"meldParams\",\"type\":\"tuple\"}],\"name\":\"InvalidMeldParams\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isTransferable\",\"type\":\"bool\"}],\"internalType\":\"struct IDuckyFamily.MintParams\",\"name\":\"mintParams\",\"type\":\"tuple\"}],\"name\":\"InvalidMintParams\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expire\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"voucherCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"encodedParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IVoucher.Voucher\",\"name\":\"voucher\",\"type\":\"tuple\"}],\"name\":\"InvalidVoucher\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"weights\",\"type\":\"uint32[]\"}],\"name\":\"InvalidWeights\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"MeldingRulesViolated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"collectionId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"}],\"name\":\"MintingRulesViolated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"voucherCodeHash\",\"type\":\"bytes32\"}],\"name\":\"VoucherAlreadyUsed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"meldingTokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"meldedTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"Melded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"action\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"voucherCodeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"}],\"name\":\"VoucherUsed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLOCK_SIZE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAINTAINER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PACK_SIZE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duckiesContract\",\"outputs\":[{\"internalType\":\"contract ERC20Burnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ducklingsContract\",\"outputs\":[{\"internalType\":\"contract IDucklings\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollectionsGeneDistributionTypes\",\"outputs\":[{\"internalType\":\"uint32[3]\",\"name\":\"\",\"type\":\"uint32[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollectionsGeneValues\",\"outputs\":[{\"internalType\":\"uint8[][3]\",\"name\":\"\",\"type\":\"uint8[][3]\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMeldPrices\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issuer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"meldingTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"meldFlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"meldPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"size\",\"type\":\"uint8\"}],\"name\":\"mintPack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"ducklingGeneDistrTypes\",\"type\":\"uint32\"}],\"name\":\"setDucklingGeneDistributionTypes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"duckingGeneValuesNum\",\"type\":\"uint8[]\"}],\"name\":\"setDucklingGeneValues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setIssuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"prices\",\"type\":\"uint256[4]\"}],\"name\":\"setMeldPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"}],\"name\":\"setMythicAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"mythicGeneDistrTypes\",\"type\":\"uint32\"}],\"name\":\"setMythicGeneDistributionTypes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"mythicGeneValuesNum\",\"type\":\"uint8[]\"}],\"name\":\"setMythicGeneValues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"pepper\",\"type\":\"bytes32\"}],\"name\":\"setPepper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"zombeakGeneDistrTypes\",\"type\":\"uint32\"}],\"name\":\"setZombeakGeneDistributionTypes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"zombeakGeneValuesNum\",\"type\":\"uint8[]\"}],\"name\":\"setZombeakGeneValues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasureVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expire\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"voucherCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"encodedParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IVoucher.Voucher\",\"name\":\"voucher\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"useVoucher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expire\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"chainId\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"voucherCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"encodedParams\",\"type\":\"bytes\"}],\"internalType\":\"struct IVoucher.Voucher[]\",\"name\":\"vouchers\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"useVouchers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DuckyFamilyV1", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000018e73a5333984549484348a94f4d219f4fab7b81000000000000000000000000435b74f6dc4a0723ca19e4dd2ac8aa1361c7b0f000000000000000000000000068d1e3f802058ce517e9ba871ab182299e74d852", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}