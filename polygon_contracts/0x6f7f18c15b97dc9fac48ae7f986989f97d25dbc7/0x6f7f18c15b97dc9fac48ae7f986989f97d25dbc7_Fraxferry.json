{"SourceCode": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.0;\r\n\r\n// Sources flattened with hardhat v2.12.0 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.7.3\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol@v4.7.3\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n\r\n// File @uniswap/v3-periphery/contracts/libraries/TransferHelper.sol@v1.4.1\r\n\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxferry/Fraxferry.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ============================ Fraxferry =============================\r\n// ====================================================================\r\n// Ferry that can be used to ship tokens between chains\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Dennis: https://github.com/denett\r\n\r\n/*\r\n** Modus operandi:\r\n** - User sends tokens to the contract. This transaction is stored in the contract.\r\n** - Captain queries the source chain for transactions to ship.\r\n** - Captain sends batch (start, end, hash) to start the trip,\r\n** - Crewmembers check the batch and can dispute it if it is invalid.\r\n** - Non disputed batches can be executed by the first officer by providing the transactions as calldata. \r\n** - Hash of the transactions must be equal to the hash in the batch. User receives their tokens on the other chain.\r\n** - In case there was a fraudulent transaction (a hacker for example), the owner can cancel a single transaction, such that it will not be executed.\r\n** - The owner can manually manage the tokens in the contract and must make sure it has enough funds.\r\n**\r\n** What must happen for a false batch to be executed:\r\n** - Captain is tricked into proposing a batch with a false hash\r\n** - All crewmembers bots are offline/censured/compromised and no one disputes the proposal\r\n**\r\n** Other risks:\r\n** - Reorgs on the source chain. Avoided, by only returning the transactions on the source chain that are at least one hour old.\r\n** - Rollbacks of optimistic rollups. Avoided by running a node.\r\n** - Operators do not have enough time to pause the chain after a fake proposal. Avoided by requiring a minimal amount of time between sending the proposal and executing it.\r\n*/\r\n\r\n\r\n\r\ncontract Fraxferry {\r\n   IERC20 immutable public token;\r\n   IERC20 immutable public targetToken;\r\n   uint immutable public chainid;\r\n   uint immutable public targetChain;   \r\n   \r\n   address public owner;\r\n   address public nominatedOwner;\r\n   address public captain;\r\n   address public firstOfficer;\r\n   mapping(address => bool) public crewmembers;\r\n\r\n   bool public paused;\r\n   \r\n   uint public MIN_WAIT_PERIOD_ADD=3600; // Minimal 1 hour waiting\r\n   uint public MIN_WAIT_PERIOD_EXECUTE=82800; // Minimal 23 hour waiting\r\n   uint public FEE=1*1e18; // 1 token\r\n   uint immutable MAX_FEE=100e18; // Max fee is 100 tokens\r\n   uint immutable public REDUCED_DECIMALS=1e10;\r\n   \r\n   Transaction[] public transactions;\r\n   mapping(uint => bool) public cancelled;\r\n   uint public executeIndex;\r\n   Batch[] public batches;\r\n   \r\n   struct Transaction {\r\n      address user;\r\n      uint64 amount;\r\n      uint32 timestamp;\r\n   }\r\n   \r\n   struct Batch {\r\n      uint64 start;\r\n      uint64 end;\r\n      uint64 departureTime;\r\n      uint64 status;\r\n      bytes32 hash;\r\n   }\r\n   \r\n   struct BatchData {\r\n      uint startTransactionNo;\r\n      Transaction[] transactions;\r\n   }\r\n\r\n   constructor(IERC20 _token, uint _chainid, IERC20 _targetToken, uint _targetChain) {\r\n      //require (block.chainid==_chainid,\"Wrong chain\");\r\n      chainid=_chainid;\r\n      token = _token;\r\n      targetToken = _targetToken;\r\n      owner = msg.sender;\r\n      targetChain = _targetChain;\r\n   }\r\n   \r\n   \r\n   // ############## Events ##############\r\n   \r\n   event Embark(address indexed sender, uint index, uint amount, uint amountAfterFee, uint timestamp);\r\n   event Disembark(uint start, uint end, bytes32 hash); \r\n   event Depart(uint batchNo,uint start,uint end,bytes32 hash); \r\n   event RemoveBatch(uint batchNo);\r\n   event DisputeBatch(uint batchNo, bytes32 hash);\r\n   event Cancelled(uint index, bool cancel);\r\n   event Pause(bool paused);\r\n   event OwnerNominated(address indexed newOwner);\r\n   event OwnerChanged(address indexed previousOwner,address indexed newOwner);\r\n   event SetCaptain(address indexed previousCaptain, address indexed newCaptain);   \r\n   event SetFirstOfficer(address indexed previousFirstOfficer, address indexed newFirstOfficer);\r\n   event SetCrewmember(address indexed crewmember,bool set); \r\n   event SetFee(uint previousFee, uint fee);\r\n   event SetMinWaitPeriods(uint previousMinWaitAdd,uint previousMinWaitExecute,uint minWaitAdd,uint minWaitExecute); \r\n   \r\n   // ############## Modifiers ##############\r\n   \r\n   modifier isOwner() {\r\n      require (msg.sender==owner,\"Not owner\");\r\n      _;\r\n   }\r\n   \r\n   modifier isCaptain() {\r\n      require (msg.sender==captain,\"Not captain\");\r\n      _;\r\n   }\r\n   \r\n   modifier isFirstOfficer() {\r\n      require (msg.sender==firstOfficer,\"Not first officer\");\r\n      _;\r\n   }   \r\n    \r\n   modifier isCrewmember() {\r\n      require (crewmembers[msg.sender] || msg.sender==owner || msg.sender==captain || msg.sender==firstOfficer,\"Not crewmember\");\r\n      _;\r\n   }\r\n   \r\n   modifier notPaused() {\r\n      require (!paused,\"Paused\");\r\n      _;\r\n   } \r\n   \r\n   // ############## Ferry actions ##############\r\n   \r\n   function embarkWithRecipient(uint amount, address recipient) public notPaused {\r\n      amount = (amount/REDUCED_DECIMALS)*REDUCED_DECIMALS; // Round amount to fit in data structure\r\n      require (amount>FEE,\"Amount too low\");\r\n      require (amount/REDUCED_DECIMALS<=type(uint64).max,\"Amount too high\");\r\n      TransferHelper.safeTransferFrom(address(token),msg.sender,address(this),amount); \r\n      uint64 amountAfterFee = uint64((amount-FEE)/REDUCED_DECIMALS);\r\n      emit Embark(recipient,transactions.length,amount,amountAfterFee*REDUCED_DECIMALS,block.timestamp);\r\n      transactions.push(Transaction(recipient,amountAfterFee,uint32(block.timestamp)));   \r\n   }\r\n   \r\n   function embark(uint amount) public {\r\n      embarkWithRecipient(amount, msg.sender) ;\r\n   }\r\n\r\n   function embarkWithSignature(\r\n      uint256 _amount,\r\n      address recipient,\r\n      uint256 deadline,\r\n      bool approveMax,\r\n      uint8 v,\r\n      bytes32 r,\r\n      bytes32 s\r\n   ) public {\r\n      uint amount = approveMax ? type(uint256).max : _amount;\r\n      IERC20Permit(address(token)).permit(msg.sender, address(this), amount, deadline, v, r, s);\r\n      embarkWithRecipient(amount,recipient);\r\n   }   \r\n   \r\n   function depart(uint start, uint end, bytes32 hash) external notPaused isCaptain {\r\n      require ((batches.length==0 && start==0) || (batches.length>0 && start==batches[batches.length-1].end+1),\"Wrong start\");\r\n      require (end>=start && end<type(uint64).max,\"Wrong end\");\r\n      batches.push(Batch(uint64(start),uint64(end),uint64(block.timestamp),0,hash));\r\n      emit Depart(batches.length-1,start,end,hash);\r\n   }\r\n   \r\n   function disembark(BatchData calldata batchData) external notPaused isFirstOfficer {\r\n      Batch memory batch = batches[executeIndex++];\r\n      require (batch.status==0,\"Batch disputed\");\r\n      require (batch.start==batchData.startTransactionNo,\"Wrong start\");\r\n      require (batch.start+batchData.transactions.length-1==batch.end,\"Wrong size\");\r\n      require (block.timestamp-batch.departureTime>=MIN_WAIT_PERIOD_EXECUTE,\"Too soon\");\r\n      \r\n      bytes32 hash = keccak256(abi.encodePacked(targetChain, targetToken, chainid, token, batch.start));\r\n      for (uint i=0;i<batchData.transactions.length;++i) {\r\n         if (!cancelled[batch.start+i]) {\r\n            TransferHelper.safeTransfer(address(token),batchData.transactions[i].user,batchData.transactions[i].amount*REDUCED_DECIMALS);\r\n         }\r\n         hash = keccak256(abi.encodePacked(hash, batchData.transactions[i].user,batchData.transactions[i].amount));\r\n      }\r\n      require (batch.hash==hash,\"Wrong hash\");\r\n      emit Disembark(batch.start,batch.end,hash);\r\n   }\r\n   \r\n   function removeBatches(uint batchNo) external isOwner {\r\n      require (executeIndex<=batchNo,\"Batch already executed\");\r\n      while (batches.length>batchNo) batches.pop();\r\n      emit RemoveBatch(batchNo);\r\n   }\r\n   \r\n   function disputeBatch(uint batchNo, bytes32 hash) external isCrewmember {\r\n      require (batches[batchNo].hash==hash,\"Wrong hash\");\r\n      require (executeIndex<=batchNo,\"Batch already executed\");\r\n      require (batches[batchNo].status==0,\"Batch already disputed\");\r\n      batches[batchNo].status=1; // Set status on disputed\r\n      _pause(true);\r\n      emit DisputeBatch(batchNo,hash);\r\n   }\r\n   \r\n   function pause() external isCrewmember {\r\n      _pause(true);\r\n   }\r\n   \r\n   function unPause() external isOwner {\r\n      _pause(false);\r\n   }   \r\n   \r\n   function _pause(bool _paused) internal {\r\n      paused=_paused;\r\n      emit Pause(_paused);\r\n   } \r\n   \r\n   function _jettison(uint index, bool cancel) internal {\r\n      require (executeIndex==0 || index>batches[executeIndex-1].end,\"Transaction already executed\");\r\n      cancelled[index]=cancel;\r\n      emit Cancelled(index,cancel);\r\n   }\r\n   \r\n   function jettison(uint index, bool cancel) external isOwner {\r\n      _jettison(index,cancel);\r\n   }\r\n   \r\n   function jettisonGroup(uint[] calldata indexes, bool cancel) external isOwner {\r\n      for (uint i=0;i<indexes.length;++i) {\r\n         _jettison(indexes[i],cancel);\r\n      }\r\n   }   \r\n   \r\n   // ############## Parameters management ##############\r\n   \r\n   function setFee(uint _FEE) external isOwner {\r\n      require(FEE<MAX_FEE);\r\n      emit SetFee(FEE,_FEE);\r\n      FEE=_FEE;\r\n   }\r\n   \r\n   function setMinWaitPeriods(uint _MIN_WAIT_PERIOD_ADD, uint _MIN_WAIT_PERIOD_EXECUTE) external isOwner {\r\n      require(_MIN_WAIT_PERIOD_ADD>=3600 && _MIN_WAIT_PERIOD_EXECUTE>=3600,\"Period too short\");\r\n      emit SetMinWaitPeriods(MIN_WAIT_PERIOD_ADD, MIN_WAIT_PERIOD_EXECUTE,_MIN_WAIT_PERIOD_ADD, _MIN_WAIT_PERIOD_EXECUTE);\r\n      MIN_WAIT_PERIOD_ADD=_MIN_WAIT_PERIOD_ADD;\r\n      MIN_WAIT_PERIOD_EXECUTE=_MIN_WAIT_PERIOD_EXECUTE;\r\n   }\r\n   \r\n   // ############## Roles management ##############\r\n   \r\n   function nominateNewOwner(address newOwner) external isOwner {\r\n      nominatedOwner = newOwner;\r\n      emit OwnerNominated(newOwner);\r\n   }   \r\n   \r\n   function acceptOwnership() external {\r\n      require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n      emit OwnerChanged(owner, nominatedOwner);\r\n      owner = nominatedOwner;\r\n      nominatedOwner = address(0);\r\n   }\r\n   \r\n   function setCaptain(address newCaptain) external isOwner {\r\n      emit SetCaptain(captain,newCaptain);\r\n      captain=newCaptain;\r\n   }\r\n   \r\n   function setFirstOfficer(address newFirstOfficer) external isOwner {\r\n      emit SetFirstOfficer(firstOfficer,newFirstOfficer);\r\n      firstOfficer=newFirstOfficer;\r\n   }    \r\n   \r\n   function setCrewmember(address crewmember, bool set) external isOwner {\r\n      crewmembers[crewmember]=set;\r\n      emit SetCrewmember(crewmember,set);\r\n   }   \r\n  \r\n   \r\n   // ############## Token management ##############   \r\n   \r\n   function sendTokens(address receiver, uint amount) external isOwner {\r\n      require (receiver!=address(0),\"Zero address not allowed\");\r\n      TransferHelper.safeTransfer(address(token),receiver,amount);\r\n   }   \r\n   \r\n   // Generic proxy\r\n   function execute(address _to, uint256 _value, bytes calldata _data) external isOwner returns (bool, bytes memory) {\r\n      require(_data.length==0 || _to.code.length>0,\"Can not call a function on a EOA\");\r\n      (bool success, bytes memory result) = _to.call{value:_value}(_data);\r\n      return (success, result);\r\n   }   \r\n   \r\n   // ############## Views ##############\r\n   function getNextBatch(uint _start, uint max) public view returns (uint start, uint end, bytes32 hash) {\r\n      uint cutoffTime = block.timestamp-MIN_WAIT_PERIOD_ADD;\r\n      if (_start<transactions.length && transactions[_start].timestamp<cutoffTime) {\r\n         start=_start;\r\n         end=start+max-1;\r\n         if (end>=transactions.length) end=transactions.length-1;\r\n         while(transactions[end].timestamp>=cutoffTime) end--;\r\n         hash = getTransactionsHash(start,end);\r\n      }\r\n   }\r\n   \r\n   function getBatchData(uint start, uint end) public view returns (BatchData memory data) {\r\n      data.startTransactionNo = start;\r\n      data.transactions = new Transaction[](end-start+1);\r\n      for (uint i=start;i<=end;++i) {\r\n         data.transactions[i-start]=transactions[i];\r\n      }\r\n   }\r\n   \r\n   function getBatchAmount(uint start, uint end) public view returns (uint totalAmount) {\r\n      for (uint i=start;i<=end;++i) {\r\n         totalAmount+=transactions[i].amount;\r\n      }\r\n      totalAmount*=REDUCED_DECIMALS;\r\n   }\r\n   \r\n   function getTransactionsHash(uint start, uint end) public view returns (bytes32) {\r\n      bytes32 result = keccak256(abi.encodePacked(chainid, token, targetChain, targetToken, uint64(start)));\r\n      for (uint i=start;i<=end;++i) {\r\n         result = keccak256(abi.encodePacked(result, transactions[i].user,transactions[i].amount));\r\n      }\r\n      return result;\r\n   }   \r\n   \r\n   function noTransactions() public view returns (uint) {\r\n      return transactions.length;\r\n   }\r\n   \r\n   function noBatches() public view returns (uint) {\r\n      return batches.length;\r\n   }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainid\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_targetChain\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"cancel\",\"type\":\"bool\"}],\"name\":\"Cancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Depart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"Disembark\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"DisputeBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAfterFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Embark\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"}],\"name\":\"RemoveBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousCaptain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newCaptain\",\"type\":\"address\"}],\"name\":\"SetCaptain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"crewmember\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"SetCrewmember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousFirstOfficer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFirstOfficer\",\"type\":\"address\"}],\"name\":\"SetFirstOfficer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousMinWaitAdd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousMinWaitExecute\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minWaitAdd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minWaitExecute\",\"type\":\"uint256\"}],\"name\":\"SetMinWaitPeriods\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WAIT_PERIOD_ADD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_WAIT_PERIOD_EXECUTE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REDUCED_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"batches\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"departureTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"status\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"captain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"crewmembers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"depart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startTransactionNo\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Fraxferry.Transaction[]\",\"name\":\"transactions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fraxferry.BatchData\",\"name\":\"batchData\",\"type\":\"tuple\"}],\"name\":\"disembark\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"disputeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"embark\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"embarkWithRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"embarkWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstOfficer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getBatchAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getBatchData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startTransactionNo\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Fraxferry.Transaction[]\",\"name\":\"transactions\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fraxferry.BatchData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"getNextBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getTransactionsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"cancel\",\"type\":\"bool\"}],\"name\":\"jettison\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indexes\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"cancel\",\"type\":\"bool\"}],\"name\":\"jettisonGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noBatches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchNo\",\"type\":\"uint256\"}],\"name\":\"removeBatches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCaptain\",\"type\":\"address\"}],\"name\":\"setCaptain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crewmember\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"setCrewmember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_FEE\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFirstOfficer\",\"type\":\"address\"}],\"name\":\"setFirstOfficer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_MIN_WAIT_PERIOD_ADD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_MIN_WAIT_PERIOD_EXECUTE\",\"type\":\"uint256\"}],\"name\":\"setMinWaitPeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetChain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Fraxferry", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "00000000000000000000000045c32fa6df82ead1e2ef74d17b76547eddfaff890000000000000000000000000000000000000000000000000000000000000089000000000000000000000000853d955acef822db058eb8505911ed77f175b99e0000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5576932e7b01a615616f43af263e14dc4e80f024a8a25d3bd971534693622e61"}