{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DCNTSDK.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/*\\n ______   _______  _______  _______  _       _________\\n(  __  \\\\ (  ____ \\\\(  ____ \\\\(  ____ \\\\( (    /|\\\\__   __/\\n| (  \\\\  )| (    \\\\/| (    \\\\/| (    \\\\/|  \\\\  ( |   ) (\\n| |   ) || (__    | |      | (__    |   \\\\ | |   | |\\n| |   | ||  __)   | |      |  __)   | (\\\\ \\\\) |   | |\\n| |   ) || (      | |      | (      | | \\\\   |   | |\\n| (__/  )| (____/\\\\| (____/\\\\| (____/\\\\| )  \\\\  |   | |\\n(______/ (_______/(_______/(_______/|/    )_)   )_(\\n\\n*/\\n\\n/// ============ Imports ============\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\nimport \\\"./interfaces/IDCNTRegistry.sol\\\";\\nimport \\\"./interfaces/IDCNTSeries.sol\\\";\\nimport \\\"./storage/EditionConfig.sol\\\";\\nimport \\\"./storage/MetadataConfig.sol\\\";\\nimport \\\"./storage/TokenGateConfig.sol\\\";\\nimport \\\"./storage/CrescendoConfig.sol\\\";\\n\\ncontract DCNTSDK is Ownable {\\n  /// ============ Storage ===========\\n  /// @notice implementation addresses for base contracts\\n  address public DCNT721AImplementation;\\n  address public DCNT4907AImplementation;\\n  address public DCNTSeriesImplementation;\\n  address public DCNTCrescendoImplementation;\\n  address public DCNTVaultImplementation;\\n  address public DCNTStakingImplementation;\\n  address public ZKEditionImplementation;\\n\\n  /// @notice address of the metadata renderer\\n  address public metadataRenderer;\\n\\n  /// @notice address of the associated registry\\n  address public contractRegistry;\\n\\n  /// ============ Events ============\\n\\n  /// @notice Emitted after successfully deploying a contract\\n  event DeployDCNT721A(address DCNT721A);\\n  event DeployDCNT4907A(address DCNT4907A);\\n  event DeployDCNTSeries(address DCNTSeries);\\n  event DeployDCNTCrescendo(address DCNTCrescendo);\\n  event DeployDCNTVault(address DCNTVault);\\n  event DeployDCNTStaking(address DCNTStaking);\\n  event DeployZKEdition(address ZKEdition);\\n\\n  /// ============ Constructor ============\\n\\n  /// @notice Creates a new DecentSDK instance\\n  constructor(\\n    address _DCNT721AImplementation,\\n    address _DCNT4907AImplementation,\\n    address _DCNTSeriesImplementation,\\n    address _DCNTCrescendoImplementation,\\n    address _DCNTVaultImplementation,\\n    address _DCNTStakingImplementation,\\n    address _metadataRenderer,\\n    address _contractRegistry,\\n    address _ZKEditionImplementation\\n  ) {\\n    DCNT721AImplementation = _DCNT721AImplementation;\\n    DCNT4907AImplementation = _DCNT4907AImplementation;\\n    DCNTSeriesImplementation = _DCNTSeriesImplementation;\\n    DCNTCrescendoImplementation = _DCNTCrescendoImplementation;\\n    DCNTVaultImplementation = _DCNTVaultImplementation;\\n    DCNTStakingImplementation = _DCNTStakingImplementation;\\n    metadataRenderer = _metadataRenderer;\\n    contractRegistry = _contractRegistry;\\n    ZKEditionImplementation = _ZKEditionImplementation;\\n  }\\n\\n  /// ============ Functions ============\\n\\n  /// @notice deploy and initialize an erc721a clone\\n  function deployDCNT721A(\\n    EditionConfig calldata _editionConfig,\\n    MetadataConfig calldata _metadataConfig,\\n    TokenGateConfig calldata _tokenGateConfig\\n  ) external returns (address clone) {\\n    clone = Clones.clone(DCNT721AImplementation);\\n    (bool success, ) = clone.call(\\n      abi.encodeWithSignature(\\n        \\\"initialize(\\\"\\n          \\\"address,\\\"\\n          \\\"(string,string,bool,bool,uint32,uint32,uint32,uint32,uint32,uint32,uint16,uint96,address,address,bytes32),\\\"\\n          \\\"(string,string,bytes,address),\\\"\\n          \\\"(address,uint88,uint8),\\\"\\n          \\\"address\\\"\\n        \\\")\\\",\\n        msg.sender,\\n        _editionConfig,\\n        _metadataConfig,\\n        _tokenGateConfig,\\n        metadataRenderer\\n      )\\n    );\\n    require(success);\\n    IDCNTRegistry(contractRegistry).register(msg.sender, clone, \\\"DCNT721A\\\");\\n    emit DeployDCNT721A(clone);\\n  }\\n\\n  /// @notice deploy and initialize a ZKEdition clone\\n  function deployZKEdition(\\n    EditionConfig calldata _editionConfig,\\n    MetadataConfig calldata _metadataConfig,\\n    TokenGateConfig calldata _tokenGateConfig,\\n    address zkVerifier\\n  ) external returns (address clone) {\\n    clone = Clones.clone(ZKEditionImplementation); //zkedition implementation\\n    (bool success, ) = clone.call(\\n      abi.encodeWithSignature(\\n        \\\"initialize(\\\"\\n          \\\"address,\\\"\\n          \\\"(string,string,bool,bool,uint32,uint32,uint32,uint32,uint32,uint32,uint16,uint96,address,address,bytes32),\\\"\\n          \\\"(string,string,bytes,address),\\\"\\n          \\\"(address,uint88,uint8),\\\"\\n          \\\"address,\\\"\\n          \\\"address\\\"\\n        \\\")\\\",\\n        msg.sender,\\n        _editionConfig,\\n        _metadataConfig,\\n        _tokenGateConfig,\\n        metadataRenderer,\\n        zkVerifier\\n      )\\n    );\\n    require(success);\\n    IDCNTRegistry(contractRegistry).register(msg.sender, clone, \\\"ZKEdition\\\");\\n    emit DeployZKEdition(clone);\\n  }\\n\\n  /// @notice deploy and initialize an erc4907a clone\\n  function deployDCNT4907A(\\n    EditionConfig calldata _editionConfig,\\n    MetadataConfig calldata _metadataConfig,\\n    TokenGateConfig calldata _tokenGateConfig\\n  ) external returns (address clone) {\\n    clone = Clones.clone(DCNT4907AImplementation);\\n    (bool success, ) = clone.call(\\n      abi.encodeWithSignature(\\n        \\\"initialize(\\\"\\n          \\\"address,\\\"\\n          \\\"(string,string,bool,bool,uint32,uint32,uint32,uint32,uint32,uint32,uint16,uint96,address,address,bytes32),\\\"\\n          \\\"(string,string,bytes,address),\\\"\\n          \\\"(address,uint88,uint8),\\\"\\n          \\\"address\\\"\\n        \\\")\\\",\\n        msg.sender,\\n        _editionConfig,\\n        _metadataConfig,\\n        _tokenGateConfig,\\n        metadataRenderer\\n      )\\n    );\\n    require(success);\\n    IDCNTRegistry(contractRegistry).register(msg.sender, clone, \\\"DCNT4907A\\\");\\n    emit DeployDCNT4907A(clone);\\n  }\\n\\n  // deploy and initialize an erc1155 clone\\n  function deployDCNTSeries(\\n    IDCNTSeries.SeriesConfig calldata _config,\\n    IDCNTSeries.Drop calldata _defaultDrop,\\n    IDCNTSeries.DropMap calldata _dropOverrides\\n  ) external returns (address clone) {\\n    clone = Clones.clone(DCNTSeriesImplementation);\\n    (bool success, ) = clone.call(\\n      abi.encodeWithSignature(\\n        \\\"initialize(\\\"\\n          \\\"address,\\\"\\n          \\\"(string,string,string,string,uint128,uint128,uint16,address,address,address,bool,bool),\\\"\\n          \\\"(uint32,uint32,uint32,uint32,uint32,uint32,uint96,bytes32,(address,uint88,uint8)),\\\"\\n          \\\"(\\\"\\n            \\\"uint256[],\\\"\\n            \\\"uint256[],\\\"\\n            \\\"uint256[],\\\"\\n            \\\"(uint32,uint32,uint32,uint32,uint32,uint32,uint96,bytes32,(address,uint88,uint8))[]\\\"\\n          \\\")\\\"\\n        \\\")\\\",\\n        msg.sender,\\n        _config,\\n        _defaultDrop,\\n        _dropOverrides\\n      )\\n    );\\n    require(success);\\n    IDCNTRegistry(contractRegistry).register(\\n      msg.sender,\\n      clone,\\n      \\\"DCNTSeries\\\"\\n    );\\n    emit DeployDCNTSeries(clone);\\n  }\\n\\n  // deploy and initialize a Crescendo clone\\n  function deployDCNTCrescendo(\\n    CrescendoConfig calldata _config,\\n    MetadataConfig calldata _metadataConfig\\n  ) external returns (address clone) {\\n    clone = Clones.clone(DCNTCrescendoImplementation);\\n    (bool success, ) = clone.call(\\n      abi.encodeWithSignature(\\n        \\\"initialize(\\\"\\n          \\\"address,\\\"\\n          \\\"(string,string,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),\\\"\\n          \\\"(string,string,bytes,address),\\\"\\n          \\\"address\\\"\\n        \\\")\\\",\\n        msg.sender,\\n        _config,\\n        _metadataConfig,\\n        metadataRenderer\\n      )\\n    );\\n    require(success);\\n    IDCNTRegistry(contractRegistry).register(\\n      msg.sender,\\n      clone,\\n      \\\"DCNTCrescendo\\\"\\n    );\\n    emit DeployDCNTCrescendo(clone);\\n  }\\n\\n  // deploy and initialize a vault wrapper clone\\n  function deployDCNTVault(\\n    address _vaultDistributionTokenAddress,\\n    address _nftVaultKeyAddress,\\n    uint256 _nftTotalSupply,\\n    uint256 _unlockDate\\n  ) external returns (address clone) {\\n    clone = Clones.clone(DCNTVaultImplementation);\\n    (bool success, ) = clone.call(\\n      abi.encodeWithSignature(\\n        \\\"initialize(address,address,address,uint256,uint256)\\\",\\n        msg.sender,\\n        _vaultDistributionTokenAddress,\\n        _nftVaultKeyAddress,\\n        _nftTotalSupply,\\n        _unlockDate\\n      )\\n    );\\n    require(success);\\n    IDCNTRegistry(contractRegistry).register(msg.sender, clone, \\\"DCNTVault\\\");\\n    emit DeployDCNTVault(clone);\\n  }\\n\\n  // deploy and initialize a vault wrapper clone\\n  function deployDCNTStaking(\\n    address _nft,\\n    address _token,\\n    uint256 _vaultDuration,\\n    uint256 _totalSupply\\n  ) external returns (address clone) {\\n    clone = Clones.clone(DCNTStakingImplementation);\\n    (bool success, ) = clone.call(\\n      abi.encodeWithSignature(\\n        \\\"initialize(address,address,address,uint256,uint256)\\\",\\n        msg.sender,\\n        _nft,\\n        _token,\\n        _vaultDuration,\\n        _totalSupply\\n      )\\n    );\\n    require(success);\\n    IDCNTRegistry(contractRegistry).register(msg.sender, clone, \\\"DCNTStaking\\\");\\n    emit DeployDCNTStaking(clone);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/ERC1155Hooks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport 'solmate/src/tokens/ERC1155.sol';\\n\\nabstract contract ERC1155Hooks is ERC1155 {\\n  function _beforeTokenTransfers(\\n    address from,\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts\\n  ) internal virtual {}\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 id,\\n    uint256 amount,\\n    bytes calldata data\\n  ) public virtual override {\\n    _beforeTokenTransfers(from, to, _asSingletonArray(id), _asSingletonArray(amount));\\n    super.safeTransferFrom(from, to, id, amount, data);\\n  }\\n\\n  function safeBatchTransferFrom(\\n    address from,\\n    address to,\\n    uint256[] calldata ids,\\n    uint256[] calldata amounts,\\n    bytes calldata data\\n  ) public virtual override {\\n    _beforeTokenTransfers(from, to, ids, amounts);\\n    super.safeBatchTransferFrom(from, to, ids, amounts, data);\\n  }\\n\\n  function _mint(\\n    address to,\\n    uint256 id,\\n    uint256 amount,\\n    bytes memory data\\n  ) internal virtual override {\\n    _beforeTokenTransfers(address(0), to, _asSingletonArray(id), _asSingletonArray(amount));\\n    super._mint(to, id, amount, data);\\n  }\\n\\n  function _batchMint(\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) internal virtual override {\\n    _beforeTokenTransfers(address(0), to, ids, amounts);\\n    super._batchMint(to, ids, amounts, data);\\n  }\\n\\n  function _burn(\\n    address from,\\n    uint256 id,\\n    uint256 amount\\n  ) internal virtual override {\\n    _beforeTokenTransfers(msg.sender, address(0), _asSingletonArray(id), _asSingletonArray(amount));\\n    super._burn(from, id, amount);\\n  }\\n\\n  function _batchBurn(\\n    address from,\\n    uint256[] memory ids,\\n    uint256[] memory amounts\\n  ) internal virtual override {\\n    _beforeTokenTransfers(msg.sender, address(0), ids, amounts);\\n    super._batchBurn(from, ids, amounts);\\n  }\\n\\n  function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n    uint256[] memory array = new uint256[](1);\\n    array[0] = element;\\n    return array;\\n  }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDCNTRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IDCNTRegistry {\\n  function register(\\n    address _deployer,\\n    address _deployment,\\n    string calldata _key\\n  ) external;\\n\\n  function remove(address _deployer, address _deployment) external;\\n\\n  function query(address _deployer) external returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDCNTSeries.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport '../extensions/ERC1155Hooks.sol';\\nimport '../storage/TokenGateConfig.sol';\\n\\n/**\\n * @title IDCNTSeries\\n * @author Zev Nevo. Will Kantaros.\\n * @dev An implementation of the ERC1155 multi-token standard.\\n */\\ninterface IDCNTSeries {\\n  /*\\n   * @dev A parameter object used to set the initial configuration of a token series.\\n   */\\n  struct SeriesConfig {\\n    string name;\\n    string symbol;\\n    string contractURI;\\n    string metadataURI;\\n    uint128 startTokenId;\\n    uint128 endTokenId;\\n    uint16 royaltyBPS;\\n    address feeManager;\\n    address payoutAddress;\\n    address currencyOracle;\\n    bool isSoulbound;\\n    bool hasAdjustableCaps;\\n  }\\n\\n  /*\\n   * @dev The configuration settings for individual tokens within the series\\n   */\\n  struct Drop {\\n    uint32 maxTokens;                  // Slot 1: XXXX---------------------------- 4  bytes (max: 4,294,967,295)\\n    uint32 maxTokensPerOwner;          // Slot 1: ----XXXX------------------------ 4  bytes (max: 4,294,967,295)\\n    uint32 presaleStart;               // Slot 1: --------XXXX-------------------- 4  bytes (max: Feburary 7th, 2106)\\n    uint32 presaleEnd;                 // Slot 1: ------------XXXX---------------- 4  bytes (max: Feburary 7th, 2106)\\n    uint32 saleStart;                  // Slot 1: ----------------XXXX------------ 4  bytes (max: Feburary 7th, 2106)\\n    uint32 saleEnd;                    // Slot 1: --------------------XXXX-------- 4  bytes (max: Feburary 7th, 2106)\\n    uint96 tokenPrice;                 // Slot 2: XXXXXXXXXXXX-------------------- 12  bytes (max: 79,228,162,514 ETH)\\n    bytes32 presaleMerkleRoot;         // Slot 3: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 32 bytes\\n    TokenGateConfig tokenGate;         // Slot 4: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 32 bytes\\n  }\\n\\n  /**\\n   * @dev A parameter object mapping token IDs, drop IDs, and drops.\\n   */\\n  struct DropMap {\\n    uint256[] tokenIds;\\n    uint256[] tokenIdDropIds;\\n    uint256[] dropIds;\\n    Drop[] drops;\\n  }\\n\\n  /*\\n   * @dev Only admins can perform this action.\\n   */\\n  error OnlyAdmin();\\n\\n  /*\\n   * @dev The provided arrays have unequal lengths.\\n   */\\n  error ArrayLengthMismatch();\\n\\n  /*\\n   * @dev The requested token does not exist.\\n   */\\n  error NonexistentToken();\\n\\n  /*\\n   * @dev The provided token range is invalid.\\n   */\\n  error InvalidTokenRange();\\n\\n  /*\\n   * @dev The token supply caps are locked and cannot be adjusted.\\n   */\\n  error CapsAreLocked();\\n\\n  /*\\n   * @dev The token supply cap cannot be decreased.\\n   */\\n  error CannotDecreaseCap();\\n\\n  /*\\n   * @dev Insufficient minimum balance for the token gate.\\n   */\\n  error TokenGateDenied();\\n\\n  /*\\n   * @dev Sales for this drop are not currently active.\\n   */\\n  error SaleNotActive();\\n\\n  /*\\n   * @dev The provided funds are insufficient to complete this transaction.\\n   */\\n  error InsufficientFunds();\\n\\n  /*\\n   * @dev The requested mint exceeds the maximum supply for this drop.\\n   */\\n  error MintExceedsMaxSupply();\\n\\n  /*\\n   * @dev The requested mint exceeds the maximum tokens per owner for this drop.\\n   */\\n  error MintExceedsMaxTokensPerOwner();\\n\\n  /*\\n   * @dev The requested airdrop exceeds the maximum supply for this drop.\\n   */\\n  error AirdropExceedsMaxSupply();\\n\\n  /*\\n   * @dev The requested burn exceeds the number of owned tokens.\\n   */\\n  error BurnExceedsOwnedTokens();\\n\\n  /*\\n   * @dev The presale is not currently active.\\n   */\\n  error PresaleNotActive();\\n\\n  /*\\n   * @dev Verification for the presale failed.\\n   */\\n  error PresaleVerificationFailed();\\n\\n  /*\\n   * @dev Soulbound tokens cannot be transferred.\\n   */\\n  error CannotTransferSoulbound();\\n\\n  /*\\n   * @dev Basis points may not exceed 100_00 (100 percent)\\n   */\\n  error InvalidBPS();\\n\\n  /*\\n   * @dev Splits are currently active and withdrawals are disabled.\\n   */\\n  error SplitsAreActive();\\n\\n  /*\\n   * @dev Transfer of fees failed.\\n   */\\n  error FeeTransferFailed();\\n\\n  /*\\n   * @dev Refund of excess funds failed.\\n   */\\n  error RefundFailed();\\n\\n  /*\\n   * @dev Withdrawal of funds failed.\\n   */\\n  error WithdrawFailed();\\n\\n  /**\\n   * @dev Initializes the contract with the specified parameters.\\n   * param _owner The owner of the contract.\\n   * param _config The configuration for the contract.\\n   * param _drops The drop configurations for the initial tokens.\\n   */\\n  function initialize(\\n    address _owner,\\n    SeriesConfig calldata _config,\\n    Drop calldata _defaultDrop,\\n    DropMap calldata _dropOverrides\\n  ) external;\\n\\n  /**\\n   * @dev Returns the name of the contract.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the contract.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the URI for a given token ID.\\n   * A single URI is returned for all token types as defined in EIP-1155's token type ID substitution mechanism.\\n   * Clients should replace `{id}` with the actual token type ID when calling the function.\\n   * @dev unused @param tokenId ID of the token to retrieve the URI for.\\n   */\\n  function uri(uint256) external view returns (string memory);\\n\\n  /**\\n   * @dev Set the URI for all token IDs.\\n   * @param uri_ The URI for token all token IDs.\\n   */\\n  function setURI(string memory uri_) external;\\n\\n  /**\\n   * @dev Returns the URI of the contract metadata.\\n   */\\n  function contractURI() external view returns (string memory);\\n\\n  /**\\n   * @dev Sets the URI of the contract metadata.\\n   * @param contractURI_ The URI of the contract metadata.\\n   */\\n  function setContractURI(string memory contractURI_) external;\\n\\n\\n  /**\\n   * @dev Returns the range of token IDs that are valid for this contract.\\n   * @return startTokenId The starting token ID for this contract.\\n   * @return endTokenId The ending token ID for this contract.\\n   */\\n  function tokenRange() external view returns (uint128 startTokenId, uint128 endTokenId);\\n\\n  /**\\n   * @dev Returns the drop configuration for the specified token ID.\\n   * @param tokenId The ID of the token to retrieve the drop configuration for.\\n   * @return drop The drop configuration mapped to the specified token ID.\\n   */\\n  function tokenDrop(uint128 tokenId) external view returns (Drop memory);\\n\\n  /**\\n   * @dev Creates new tokens and updates drop configurations for specified token IDs.\\n   * @param newTokens Optional number of new token IDs to add to the existing token range.\\n   * @param dropMap Optional parameter object mapping token IDs, drop IDs, and drops.\\n   */\\n  function setTokenDrops(uint128 newTokens, DropMap calldata dropMap) external;\\n\\n  /**\\n   * @dev Gets the current price for the specified token. If a currency oracle is set,\\n   * the price is calculated in native currency using the oracle exchange rate.\\n   * @param tokenId The ID of the token to get the price for.\\n   * @return The current price of the specified token.\\n   */\\n  function tokenPrice(uint256 tokenId) external view returns (uint256);\\n\\n  /**\\n   * @dev Gets the current minting fee for the specified token.\\n   * @param tokenId The ID of the token to get the minting fee for.\\n   * @param quantity The quantity of tokens used to calculate the minting fee.\\n   * @return The current fee for minting the specified token.\\n   */\\n  function mintFee(uint256 tokenId, uint256 quantity) external view returns (uint256);\\n\\n  /**\\n   * @dev Mints a specified number of tokens to a specified address.\\n   * @param tokenId The ID of the token to mint.\\n   * @param to The address to which the minted tokens will be sent.\\n   * @param quantity The quantity of tokens to mint.\\n   */\\n  function mint(uint256 tokenId, address to, uint256 quantity) external payable;\\n\\n  /**\\n   * @dev Mints a batch of tokens to a specified address.\\n   * @param tokenIds The IDs of the tokens to mint.\\n   * @param to The address to which the minted tokens will be sent.\\n   * @param quantities The quantities to mint of each token.\\n   */\\n  function mintBatch(\\n    address to,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata quantities\\n  ) external payable;\\n\\n  /**\\n   * @dev Burns a specified quantity of tokens from the caller's account.\\n   * @param tokenId The ID of the token to burn.\\n   * @param quantity The quantity of tokens to burn.\\n   */\\n  function burn(uint256 tokenId, uint256 quantity) external;\\n\\n  /**\\n   * @dev Mints specified tokens to multiple recipients as part of an airdrop.\\n   * @param tokenIds The IDs of the tokens to mint.\\n   * @param recipients The list of addresses to receive the minted tokens.\\n   */\\n  function mintAirdrop(uint256[] calldata tokenIds, address[] calldata recipients) external;\\n\\n  /**\\n   * @dev Mints a specified number of tokens to the presale buyer address.\\n   * @param to The address to which the minted tokens will be sent.\\n   * @param tokenId The ID of the token to mint.\\n   * @param quantity The quantity of tokens to mint.\\n   * @param maxQuantity The maximum quantity of tokens that can be minted.\\n   * @param pricePerToken The price per token in wei.\\n   * @param merkleProof The Merkle proof verifying that the presale buyer is eligible to mint tokens.\\n   */\\n  function mintPresale(\\n    address to,\\n    uint256 tokenId,\\n    uint256 quantity,\\n    uint256 maxQuantity,\\n    uint256 pricePerToken,\\n    bytes32[] calldata merkleProof\\n  ) external payable;\\n\\n  /**\\n   * @dev Pauses public minting.\\n   */\\n  function pause() external;\\n\\n  /**\\n   * @dev Unpauses public minting.\\n   */\\n  function unpause() external;\\n\\n  /**\\n   * @dev Sets the payout address to the specified address.\\n   * Use 0x0 to default to the contract owner.\\n   * @param _payoutAddress The address to set as the payout address.\\n   */\\n  function setPayoutAddress(address _payoutAddress) external;\\n\\n  /**\\n   * @dev Withdraws the balance of the contract to the payout address or the contract owner.\\n  */\\n  function withdraw() external;\\n\\n  /**\\n   * @dev Sets the royalty fee (ERC-2981: NFT Royalty Standard).\\n   * @param _royaltyBPS The royalty fee in basis points. (1/100th of a percent)\\n   */\\n  function setRoyaltyBPS(uint16 _royaltyBPS) external;\\n\\n  /**\\n   * @dev Returns the royalty recipient and amount for a given sale price.\\n   * @param tokenId The ID of the token being sold.\\n   * @param salePrice The sale price of the token.\\n   * @return receiver The address of the royalty recipient.\\n   * @return royaltyAmount The amount to be paid to the royalty recipient.\\n   */\\n  function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n    external\\n    view\\n    returns (address receiver, uint256 royaltyAmount);\\n\\n  /**\\n   * @dev Returns true if the contract supports the given interface (ERC2981 or ERC1155),\\n   * as specified by interfaceId, false otherwise.\\n   * @param interfaceId The interface identifier, as specified in ERC-165.\\n   * @return True if the contract supports interfaceId, false otherwise.\\n   */\\n  function supportsInterface(bytes4 interfaceId)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @dev Updates the operator filter registry with the specified subscription.\\n   * @param enable If true, enables the operator filter, if false, disables it.\\n   * @param operatorFilter The address of the operator filter subscription.\\n   */\\n  function updateOperatorFilter(bool enable, address operatorFilter) external;\\n\\n  /**\\n   * @dev Sets or revokes approval for a third party (\\\"operator\\\") to manage all of the caller's tokens.\\n   * @param operator The address of the operator to grant or revoke approval.\\n   * @param approved True to grant approval, false to revoke it.\\n   */\\n  function setApprovalForAll(\\n    address operator,\\n    bool approved\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/storage/CrescendoConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct CrescendoConfig {\\n  string name;\\n  string symbol;\\n  uint256 initialPrice;\\n  uint256 step1;\\n  uint256 step2;\\n  uint256 hitch;\\n  uint256 takeRateBPS;\\n  uint256 unlockDate;\\n  uint256 saleStart;\\n  uint256 royaltyBPS;\\n}\\n\"\r\n    },\r\n    \"contracts/storage/EditionConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct EditionConfig {\\n  string name;\\n  string symbol;\\n  bool hasAdjustableCap;\\n  bool isSoulbound;\\n  uint32 maxTokens;\\n  uint32 maxTokenPurchase;\\n  uint32 presaleStart;\\n  uint32 presaleEnd;\\n  uint32 saleStart;\\n  uint32 saleEnd;\\n  uint16 royaltyBPS;\\n  uint96 tokenPrice;\\n  address feeManager;\\n  address payoutAddress;\\n  bytes32 presaleMerkleRoot;\\n}\\n\"\r\n    },\r\n    \"contracts/storage/MetadataConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct MetadataConfig {\\n  string contractURI;\\n  string metadataURI;\\n  bytes metadataRendererInit;\\n  address parentIP;\\n}\\n\"\r\n    },\r\n    \"contracts/storage/TokenGateConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum SaleType {\\n  ALL,\\n  PRESALE,\\n  PRIMARY\\n}\\n\\nstruct TokenGateConfig {\\n  address tokenAddress; \\n  uint88 minBalance;\\n  SaleType saleType;\\n}\\n\"\r\n    },\r\n    \"solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_DCNT721AImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DCNT4907AImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DCNTSeriesImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DCNTCrescendoImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DCNTVaultImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DCNTStakingImplementation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_metadataRenderer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ZKEditionImplementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"DCNT4907A\",\"type\":\"address\"}],\"name\":\"DeployDCNT4907A\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"DCNT721A\",\"type\":\"address\"}],\"name\":\"DeployDCNT721A\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"DCNTCrescendo\",\"type\":\"address\"}],\"name\":\"DeployDCNTCrescendo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"DCNTSeries\",\"type\":\"address\"}],\"name\":\"DeployDCNTSeries\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"DCNTStaking\",\"type\":\"address\"}],\"name\":\"DeployDCNTStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"DCNTVault\",\"type\":\"address\"}],\"name\":\"DeployDCNTVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ZKEdition\",\"type\":\"address\"}],\"name\":\"DeployZKEdition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DCNT4907AImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DCNT721AImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DCNTCrescendoImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DCNTSeriesImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DCNTStakingImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DCNTVaultImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZKEditionImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"hasAdjustableCap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSoulbound\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"maxTokens\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxTokenPurchase\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"royaltyBPS\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"tokenPrice\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"feeManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"presaleMerkleRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct EditionConfig\",\"name\":\"_editionConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"metadataRendererInit\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"parentIP\",\"type\":\"address\"}],\"internalType\":\"struct MetadataConfig\",\"name\":\"_metadataConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"minBalance\",\"type\":\"uint88\"},{\"internalType\":\"enum SaleType\",\"name\":\"saleType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenGateConfig\",\"name\":\"_tokenGateConfig\",\"type\":\"tuple\"}],\"name\":\"deployDCNT4907A\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"hasAdjustableCap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSoulbound\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"maxTokens\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxTokenPurchase\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"royaltyBPS\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"tokenPrice\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"feeManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"presaleMerkleRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct EditionConfig\",\"name\":\"_editionConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"metadataRendererInit\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"parentIP\",\"type\":\"address\"}],\"internalType\":\"struct MetadataConfig\",\"name\":\"_metadataConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"minBalance\",\"type\":\"uint88\"},{\"internalType\":\"enum SaleType\",\"name\":\"saleType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenGateConfig\",\"name\":\"_tokenGateConfig\",\"type\":\"tuple\"}],\"name\":\"deployDCNT721A\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"initialPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"step1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"step2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hitch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeRateBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltyBPS\",\"type\":\"uint256\"}],\"internalType\":\"struct CrescendoConfig\",\"name\":\"_config\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"metadataRendererInit\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"parentIP\",\"type\":\"address\"}],\"internalType\":\"struct MetadataConfig\",\"name\":\"_metadataConfig\",\"type\":\"tuple\"}],\"name\":\"deployDCNTCrescendo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"},{\"internalType\":\"uint128\",\"name\":\"startTokenId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"endTokenId\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"royaltyBPS\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"feeManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currencyOracle\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSoulbound\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasAdjustableCaps\",\"type\":\"bool\"}],\"internalType\":\"struct IDCNTSeries.SeriesConfig\",\"name\":\"_config\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"maxTokens\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxTokensPerOwner\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"tokenPrice\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"presaleMerkleRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"minBalance\",\"type\":\"uint88\"},{\"internalType\":\"enum SaleType\",\"name\":\"saleType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenGateConfig\",\"name\":\"tokenGate\",\"type\":\"tuple\"}],\"internalType\":\"struct IDCNTSeries.Drop\",\"name\":\"_defaultDrop\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIdDropIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dropIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"maxTokens\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxTokensPerOwner\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"tokenPrice\",\"type\":\"uint96\"},{\"internalType\":\"bytes32\",\"name\":\"presaleMerkleRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"minBalance\",\"type\":\"uint88\"},{\"internalType\":\"enum SaleType\",\"name\":\"saleType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenGateConfig\",\"name\":\"tokenGate\",\"type\":\"tuple\"}],\"internalType\":\"struct IDCNTSeries.Drop[]\",\"name\":\"drops\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IDCNTSeries.DropMap\",\"name\":\"_dropOverrides\",\"type\":\"tuple\"}],\"name\":\"deployDCNTSeries\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vaultDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"deployDCNTStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultDistributionTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftVaultKeyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockDate\",\"type\":\"uint256\"}],\"name\":\"deployDCNTVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"hasAdjustableCap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSoulbound\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"maxTokens\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxTokenPurchase\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"presaleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"saleEnd\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"royaltyBPS\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"tokenPrice\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"feeManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payoutAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"presaleMerkleRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct EditionConfig\",\"name\":\"_editionConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metadataURI\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"metadataRendererInit\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"parentIP\",\"type\":\"address\"}],\"internalType\":\"struct MetadataConfig\",\"name\":\"_metadataConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"minBalance\",\"type\":\"uint88\"},{\"internalType\":\"enum SaleType\",\"name\":\"saleType\",\"type\":\"uint8\"}],\"internalType\":\"struct TokenGateConfig\",\"name\":\"_tokenGateConfig\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"zkVerifier\",\"type\":\"address\"}],\"name\":\"deployZKEdition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"clone\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataRenderer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DCNTSDK", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f342c94d81c6064941af6e511ea6b4b4ef39f1c5000000000000000000000000b63f1af6639bb53d21f31b621bf1088e8226565b0000000000000000000000004e1cc2fed80fa764e05eaedb807a9c2fc85e1fd9000000000000000000000000a35e98971608803c4f4bcd876451bff3f822cfe500000000000000000000000036c3a2b8550558fe7eb86541dafed469cacd2ff90000000000000000000000005392e06ac979e370fd45d25d0b5424cd8ca5652900000000000000000000000049799190ad4ef8299e0d078eef07bdb4309f718600000000000000000000000079cc3c93e7bec01e03ee3249e1a661dd09a1cbcd000000000000000000000000839e8a3827b567391d54e2828b6a75b27a053fdf", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}