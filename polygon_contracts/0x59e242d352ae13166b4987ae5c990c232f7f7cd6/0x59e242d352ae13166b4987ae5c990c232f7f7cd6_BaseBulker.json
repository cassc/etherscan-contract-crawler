{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bulkers/BaseBulker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"../CometInterface.sol\\\";\\nimport \\\"../IERC20NonStandard.sol\\\";\\nimport \\\"../IWETH9.sol\\\";\\n\\n/**\\n * @dev Interface for claiming rewards from the CometRewards contract\\n */\\ninterface IClaimable {\\n    function claim(address comet, address src, bool shouldAccrue) external;\\n\\n    function claimTo(address comet, address src, address to, bool shouldAccrue) external;\\n}\\n\\n/**\\n * @title Compound's Bulker contract\\n * @notice Executes multiple Comet-related actions in a single transaction\\n * @author Compound\\n * @dev Note: Only intended to be used on EVM chains that have a native token and wrapped native token that implements the IWETH interface\\n */\\ncontract BaseBulker {\\n    /** Custom events **/\\n\\n    event AdminTransferred(address indexed oldAdmin, address indexed newAdmin);\\n\\n    /** General configuration constants **/\\n\\n    /// @notice The admin of the Bulker contract\\n    address public admin;\\n\\n    /// @notice The address of the wrapped representation of the chain's native asset\\n    address payable public immutable wrappedNativeToken;\\n\\n    /** Actions **/\\n\\n    /// @notice The action for supplying an asset to Comet\\n    bytes32 public constant ACTION_SUPPLY_ASSET = \\\"ACTION_SUPPLY_ASSET\\\";\\n\\n    /// @notice The action for supplying a native asset (e.g. ETH on Ethereum mainnet) to Comet\\n    bytes32 public constant ACTION_SUPPLY_NATIVE_TOKEN = \\\"ACTION_SUPPLY_NATIVE_TOKEN\\\";\\n\\n    /// @notice The action for transferring an asset within Comet\\n    bytes32 public constant ACTION_TRANSFER_ASSET = \\\"ACTION_TRANSFER_ASSET\\\";\\n\\n    /// @notice The action for withdrawing an asset from Comet\\n    bytes32 public constant ACTION_WITHDRAW_ASSET = \\\"ACTION_WITHDRAW_ASSET\\\";\\n\\n    /// @notice The action for withdrawing a native asset from Comet\\n    bytes32 public constant ACTION_WITHDRAW_NATIVE_TOKEN = \\\"ACTION_WITHDRAW_NATIVE_TOKEN\\\";\\n\\n    /// @notice The action for claiming rewards from the Comet rewards contract\\n    bytes32 public constant ACTION_CLAIM_REWARD = \\\"ACTION_CLAIM_REWARD\\\";\\n\\n    /** Custom errors **/\\n\\n    error InvalidAddress();\\n    error InvalidArgument();\\n    error FailedToSendNativeToken();\\n    error TransferInFailed();\\n    error TransferOutFailed();\\n    error Unauthorized();\\n    error UnhandledAction();\\n\\n    /**\\n     * @notice Construct a new BaseBulker instance\\n     * @param admin_ The admin of the Bulker contract\\n     * @param wrappedNativeToken_ The address of the wrapped representation of the chain's native asset\\n     **/\\n    constructor(address admin_, address payable wrappedNativeToken_) {\\n        admin = admin_;\\n        wrappedNativeToken = wrappedNativeToken_;\\n    }\\n\\n    /**\\n     * @notice Fallback for receiving native token. Needed for ACTION_WITHDRAW_NATIVE_TOKEN\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract\\n     * @dev Note: Make sure to check that the asset being swept out is not malicious\\n     * @param recipient The address that will receive the swept funds\\n     * @param asset The address of the ERC-20 token to sweep\\n     */\\n    function sweepToken(address recipient, address asset) external {\\n        if (msg.sender != admin) revert Unauthorized();\\n\\n        uint256 balance = IERC20NonStandard(asset).balanceOf(address(this));\\n        doTransferOut(asset, recipient, balance);\\n    }\\n\\n    /**\\n     * @notice A public function to sweep accidental native token transfers to this contract\\n     * @param recipient The address that will receive the swept funds\\n     */\\n    function sweepNativeToken(address recipient) external {\\n        if (msg.sender != admin) revert Unauthorized();\\n\\n        uint256 balance = address(this).balance;\\n        (bool success, ) = recipient.call{ value: balance }(\\\"\\\");\\n        if (!success) revert FailedToSendNativeToken();\\n    }\\n\\n    /**\\n     * @notice Transfers the admin rights to a new address\\n     * @param newAdmin The address that will become the new admin\\n     */\\n    function transferAdmin(address newAdmin) external {\\n        if (msg.sender != admin) revert Unauthorized();\\n        if (newAdmin == address(0)) revert InvalidAddress();\\n\\n        address oldAdmin = admin;\\n        admin = newAdmin;\\n        emit AdminTransferred(oldAdmin, newAdmin);\\n    }\\n\\n    /**\\n     * @notice Executes a list of actions in order\\n     * @param actions The list of actions to execute in order\\n     * @param data The list of calldata to use for each action\\n     */\\n    function invoke(bytes32[] calldata actions, bytes[] calldata data) external payable {\\n        if (actions.length != data.length) revert InvalidArgument();\\n\\n        uint unusedNativeToken = msg.value;\\n        for (uint i = 0; i < actions.length; ) {\\n            bytes32 action = actions[i];\\n            if (action == ACTION_SUPPLY_ASSET) {\\n                (address comet, address to, address asset, uint amount) = abi.decode(data[i], (address, address, address, uint));\\n                supplyTo(comet, to, asset, amount);\\n            } else if (action == ACTION_SUPPLY_NATIVE_TOKEN) {\\n                (address comet, address to, uint amount) = abi.decode(data[i], (address, address, uint));\\n                uint256 nativeTokenUsed = supplyNativeTokenTo(comet, to, amount);\\n                unusedNativeToken -= nativeTokenUsed;\\n            } else if (action == ACTION_TRANSFER_ASSET) {\\n                (address comet, address to, address asset, uint amount) = abi.decode(data[i], (address, address, address, uint));\\n                transferTo(comet, to, asset, amount);\\n            } else if (action == ACTION_WITHDRAW_ASSET) {\\n                (address comet, address to, address asset, uint amount) = abi.decode(data[i], (address, address, address, uint));\\n                withdrawTo(comet, to, asset, amount);\\n            } else if (action == ACTION_WITHDRAW_NATIVE_TOKEN) {\\n                (address comet, address to, uint amount) = abi.decode(data[i], (address, address, uint));\\n                withdrawNativeTokenTo(comet, to, amount);\\n            } else if (action == ACTION_CLAIM_REWARD) {\\n                (address comet, address rewards, address src, bool shouldAccrue) = abi.decode(data[i], (address, address, address, bool));\\n                claimReward(comet, rewards, src, shouldAccrue);\\n            } else {\\n                handleAction(action, data[i]);\\n            }\\n            unchecked { i++; }\\n        }\\n\\n        // Refund unused native token back to msg.sender\\n        if (unusedNativeToken > 0) {\\n            (bool success, ) = msg.sender.call{ value: unusedNativeToken }(\\\"\\\");\\n            if (!success) revert FailedToSendNativeToken();\\n        }\\n    }\\n\\n    /**\\n     * @notice Handles any actions not handled by the BaseBulker implementation\\n     * @dev Note: Meant to be overridden by contracts that extend BaseBulker and want to support more actions\\n     */\\n    function handleAction(bytes32 action, bytes calldata data) virtual internal {\\n        revert UnhandledAction();\\n    }\\n\\n    /**\\n     * @notice Supplies an asset to a user in Comet\\n     * @dev Note: This contract must have permission to manage msg.sender's Comet account\\n     */\\n    function supplyTo(address comet, address to, address asset, uint amount) internal {\\n        CometInterface(comet).supplyFrom(msg.sender, to, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Wraps the native token and supplies wrapped native token to a user in Comet\\n     * @return The amount of the native token wrapped and supplied to Comet\\n     * @dev Note: Supports `amount` of `uint256.max` implies max only for base asset\\n     */\\n    function supplyNativeTokenTo(address comet, address to, uint amount) internal returns (uint256) {\\n        uint256 supplyAmount = amount;\\n        if (wrappedNativeToken == CometInterface(comet).baseToken()) {\\n            if (amount == type(uint256).max)\\n                supplyAmount = CometInterface(comet).borrowBalanceOf(msg.sender);\\n        }\\n        IWETH9(wrappedNativeToken).deposit{ value: supplyAmount }();\\n        IWETH9(wrappedNativeToken).approve(comet, supplyAmount);\\n        CometInterface(comet).supplyFrom(address(this), to, wrappedNativeToken, supplyAmount);\\n        return supplyAmount;\\n    }\\n\\n    /**\\n     * @notice Transfers an asset to a user in Comet\\n     * @dev Note: This contract must have permission to manage msg.sender's Comet account\\n     */\\n    function transferTo(address comet, address to, address asset, uint amount) internal {\\n        CometInterface(comet).transferAssetFrom(msg.sender, to, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraws an asset to a user in Comet\\n     * @dev Note: This contract must have permission to manage msg.sender's Comet account\\n     */\\n    function withdrawTo(address comet, address to, address asset, uint amount) internal {\\n        CometInterface(comet).withdrawFrom(msg.sender, to, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraws wrapped native token from Comet, unwraps it to the native token, and transfers it to a user\\n     * @dev Note: This contract must have permission to manage msg.sender's Comet account\\n     * @dev Note: Supports `amount` of `uint256.max` only for the base asset. Should revert for a collateral asset\\n     */\\n    function withdrawNativeTokenTo(address comet, address to, uint amount) internal {\\n        uint256 withdrawAmount = amount;\\n        if (wrappedNativeToken == CometInterface(comet).baseToken()) {\\n            if (amount == type(uint256).max)\\n                withdrawAmount = CometInterface(comet).balanceOf(msg.sender);\\n        }\\n        CometInterface(comet).withdrawFrom(msg.sender, address(this), wrappedNativeToken, withdrawAmount);\\n        IWETH9(wrappedNativeToken).withdraw(withdrawAmount);\\n        (bool success, ) = to.call{ value: withdrawAmount }(\\\"\\\");\\n        if (!success) revert FailedToSendNativeToken();\\n    }\\n\\n    /**\\n     * @notice Claims rewards for a user\\n     */\\n    function claimReward(address comet, address rewards, address src, bool shouldAccrue) internal {\\n        IClaimable(rewards).claim(comet, src, shouldAccrue);\\n    }\\n\\n    /**\\n     * @notice Similar to ERC-20 transfer, except it properly handles `transferFrom` from non-standard ERC-20 tokens\\n     * @param asset The ERC-20 token to transfer in\\n     * @param from The address to transfer from\\n     * @param amount The amount of the token to transfer\\n     * @dev Note: This does not check that the amount transferred in is actually equals to the amount specified (e.g. fee tokens will not revert)\\n     * @dev Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value. See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferIn(address asset, address from, uint amount) internal {\\n        IERC20NonStandard(asset).transferFrom(from, address(this), amount);\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {                       // This is a non-standard ERC-20\\n                    success := not(0)          // set success to true\\n                }\\n                case 32 {                      // This is a compliant ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)        // Set `success = returndata` of override external call\\n                }\\n                default {                      // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n        if (!success) revert TransferInFailed();\\n    }\\n\\n    /**\\n     * @notice Similar to ERC-20 transfer, except it properly handles `transfer` from non-standard ERC-20 tokens\\n     * @param asset The ERC-20 token to transfer out\\n     * @param to The recipient of the token transfer\\n     * @param amount The amount of the token to transfer\\n     * @dev Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value. See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n     */\\n    function doTransferOut(address asset, address to, uint amount) internal {\\n        IERC20NonStandard(asset).transfer(to, amount);\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {                      // This is a non-standard ERC-20\\n                    success := not(0)         // set success to true\\n                }\\n                case 32 {                     // This is a compliant ERC-20\\n                    returndatacopy(0, 0, 32)\\n                    success := mload(0)       // Set `success = returndata` of override external call\\n                }\\n                default {                     // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n        if (!success) revert TransferOutFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\ninterface IWETH9 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function allowance(address, address) external view returns (uint);\\n\\n    receive() external payable;\\n\\n    function deposit() external payable;\\n\\n    function withdraw(uint wad) external;\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function approve(address guy, uint wad) external returns (bool);\\n\\n    function transfer(address dst, uint wad) external returns (bool);\\n\\n    function transferFrom(address src, address dst, uint wad)\\n    external\\n    returns (bool);\\n}\"\r\n    },\r\n    \"contracts/IERC20NonStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @title IERC20NonStandard\\n * @dev Version of ERC20 with no return values for `approve`, `transfer`, and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface IERC20NonStandard {\\n    function approve(address spender, uint256 amount) external;\\n    function transfer(address to, uint256 value) external;\\n    function transferFrom(address from, address to, uint256 value) external;\\n    function balanceOf(address account) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/CometInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"./CometMainInterface.sol\\\";\\nimport \\\"./CometExtInterface.sol\\\";\\n\\n/**\\n * @title Compound's Comet Interface\\n * @notice An efficient monolithic money market protocol\\n * @author Compound\\n */\\nabstract contract CometInterface is CometMainInterface, CometExtInterface {}\\n\"\r\n    },\r\n    \"contracts/CometExtInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"./CometCore.sol\\\";\\n\\n/**\\n * @title Compound's Comet Ext Interface\\n * @notice An efficient monolithic money market protocol\\n * @author Compound\\n */\\nabstract contract CometExtInterface is CometCore {\\n    error BadAmount();\\n    error BadNonce();\\n    error BadSignatory();\\n    error InvalidValueS();\\n    error InvalidValueV();\\n    error SignatureExpired();\\n\\n    function allow(address manager, bool isAllowed) virtual external;\\n    function allowBySig(address owner, address manager, bool isAllowed, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) virtual external;\\n\\n    function collateralBalanceOf(address account, address asset) virtual external view returns (uint128);\\n    function baseTrackingAccrued(address account) virtual external view returns (uint64);\\n\\n    function baseAccrualScale() virtual external view returns (uint64);\\n    function baseIndexScale() virtual external view returns (uint64);\\n    function factorScale() virtual external view returns (uint64);\\n    function priceScale() virtual external view returns (uint64);\\n\\n    function maxAssets() virtual external view returns (uint8);\\n\\n    function totalsBasic() virtual external view returns (TotalsBasic memory);\\n\\n    function version() virtual external view returns (string memory);\\n\\n    /**\\n      * ===== ERC20 interfaces =====\\n      * Does not include the following functions/events, which are defined in `CometMainInterface` instead:\\n      * - function decimals() virtual external view returns (uint8)\\n      * - function totalSupply() virtual external view returns (uint256)\\n      * - function transfer(address dst, uint amount) virtual external returns (bool)\\n      * - function transferFrom(address src, address dst, uint amount) virtual external returns (bool)\\n      * - function balanceOf(address owner) virtual external view returns (uint256)\\n      * - event Transfer(address indexed from, address indexed to, uint256 amount)\\n      */\\n    function name() virtual external view returns (string memory);\\n    function symbol() virtual external view returns (string memory);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) virtual external returns (bool);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) virtual external view returns (uint256);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\"\r\n    },\r\n    \"contracts/CometMainInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"./CometCore.sol\\\";\\n\\n/**\\n * @title Compound's Comet Main Interface (without Ext)\\n * @notice An efficient monolithic money market protocol\\n * @author Compound\\n */\\nabstract contract CometMainInterface is CometCore {\\n    error Absurd();\\n    error AlreadyInitialized();\\n    error BadAsset();\\n    error BadDecimals();\\n    error BadDiscount();\\n    error BadMinimum();\\n    error BadPrice();\\n    error BorrowTooSmall();\\n    error BorrowCFTooLarge();\\n    error InsufficientReserves();\\n    error LiquidateCFTooLarge();\\n    error NoSelfTransfer();\\n    error NotCollateralized();\\n    error NotForSale();\\n    error NotLiquidatable();\\n    error Paused();\\n    error SupplyCapExceeded();\\n    error TimestampTooLarge();\\n    error TooManyAssets();\\n    error TooMuchSlippage();\\n    error TransferInFailed();\\n    error TransferOutFailed();\\n    error Unauthorized();\\n\\n    event Supply(address indexed from, address indexed dst, uint amount);\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Withdraw(address indexed src, address indexed to, uint amount);\\n\\n    event SupplyCollateral(address indexed from, address indexed dst, address indexed asset, uint amount);\\n    event TransferCollateral(address indexed from, address indexed to, address indexed asset, uint amount);\\n    event WithdrawCollateral(address indexed src, address indexed to, address indexed asset, uint amount);\\n\\n    /// @notice Event emitted when a borrow position is absorbed by the protocol\\n    event AbsorbDebt(address indexed absorber, address indexed borrower, uint basePaidOut, uint usdValue);\\n\\n    /// @notice Event emitted when a user's collateral is absorbed by the protocol\\n    event AbsorbCollateral(address indexed absorber, address indexed borrower, address indexed asset, uint collateralAbsorbed, uint usdValue);\\n\\n    /// @notice Event emitted when a collateral asset is purchased from the protocol\\n    event BuyCollateral(address indexed buyer, address indexed asset, uint baseAmount, uint collateralAmount);\\n\\n    /// @notice Event emitted when an action is paused/unpaused\\n    event PauseAction(bool supplyPaused, bool transferPaused, bool withdrawPaused, bool absorbPaused, bool buyPaused);\\n\\n    /// @notice Event emitted when reserves are withdrawn by the governor\\n    event WithdrawReserves(address indexed to, uint amount);\\n\\n    function supply(address asset, uint amount) virtual external;\\n    function supplyTo(address dst, address asset, uint amount) virtual external;\\n    function supplyFrom(address from, address dst, address asset, uint amount) virtual external;\\n\\n    function transfer(address dst, uint amount) virtual external returns (bool);\\n    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\\n\\n    function transferAsset(address dst, address asset, uint amount) virtual external;\\n    function transferAssetFrom(address src, address dst, address asset, uint amount) virtual external;\\n\\n    function withdraw(address asset, uint amount) virtual external;\\n    function withdrawTo(address to, address asset, uint amount) virtual external;\\n    function withdrawFrom(address src, address to, address asset, uint amount) virtual external;\\n\\n    function approveThis(address manager, address asset, uint amount) virtual external;\\n    function withdrawReserves(address to, uint amount) virtual external;\\n\\n    function absorb(address absorber, address[] calldata accounts) virtual external;\\n    function buyCollateral(address asset, uint minAmount, uint baseAmount, address recipient) virtual external;\\n    function quoteCollateral(address asset, uint baseAmount) virtual public view returns (uint);\\n\\n    function getAssetInfo(uint8 i) virtual public view returns (AssetInfo memory);\\n    function getAssetInfoByAddress(address asset) virtual public view returns (AssetInfo memory);\\n    function getCollateralReserves(address asset) virtual public view returns (uint);\\n    function getReserves() virtual public view returns (int);\\n    function getPrice(address priceFeed) virtual public view returns (uint);\\n\\n    function isBorrowCollateralized(address account) virtual public view returns (bool);\\n    function isLiquidatable(address account) virtual public view returns (bool);\\n\\n    function totalSupply() virtual external view returns (uint256);\\n    function totalBorrow() virtual external view returns (uint256);\\n    function balanceOf(address owner) virtual public view returns (uint256);\\n    function borrowBalanceOf(address account) virtual public view returns (uint256);\\n\\n    function pause(bool supplyPaused, bool transferPaused, bool withdrawPaused, bool absorbPaused, bool buyPaused) virtual external;\\n    function isSupplyPaused() virtual public view returns (bool);\\n    function isTransferPaused() virtual public view returns (bool);\\n    function isWithdrawPaused() virtual public view returns (bool);\\n    function isAbsorbPaused() virtual public view returns (bool);\\n    function isBuyPaused() virtual public view returns (bool);\\n\\n    function accrueAccount(address account) virtual external;\\n    function getSupplyRate(uint utilization) virtual public view returns (uint64);\\n    function getBorrowRate(uint utilization) virtual public view returns (uint64);\\n    function getUtilization() virtual public view returns (uint);\\n\\n    function governor() virtual external view returns (address);\\n    function pauseGuardian() virtual external view returns (address);\\n    function baseToken() virtual external view returns (address);\\n    function baseTokenPriceFeed() virtual external view returns (address);\\n    function extensionDelegate() virtual external view returns (address);\\n\\n    /// @dev uint64\\n    function supplyKink() virtual external view returns (uint);\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateSlopeLow() virtual external view returns (uint);\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateSlopeHigh() virtual external view returns (uint);\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateBase() virtual external view returns (uint);\\n    /// @dev uint64\\n    function borrowKink() virtual external view returns (uint);\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateSlopeLow() virtual external view returns (uint);\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateSlopeHigh() virtual external view returns (uint);\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateBase() virtual external view returns (uint);\\n    /// @dev uint64\\n    function storeFrontPriceFactor() virtual external view returns (uint);\\n\\n    /// @dev uint64\\n    function baseScale() virtual external view returns (uint);\\n    /// @dev uint64\\n    function trackingIndexScale() virtual external view returns (uint);\\n\\n    /// @dev uint64\\n    function baseTrackingSupplySpeed() virtual external view returns (uint);\\n    /// @dev uint64\\n    function baseTrackingBorrowSpeed() virtual external view returns (uint);\\n    /// @dev uint104\\n    function baseMinForRewards() virtual external view returns (uint);\\n    /// @dev uint104\\n    function baseBorrowMin() virtual external view returns (uint);\\n    /// @dev uint104\\n    function targetReserves() virtual external view returns (uint);\\n\\n    function numAssets() virtual external view returns (uint8);\\n    function decimals() virtual external view returns (uint8);\\n\\n    function initializeStorage() virtual external;\\n}\"\r\n    },\r\n    \"contracts/CometCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"./CometConfiguration.sol\\\";\\nimport \\\"./CometStorage.sol\\\";\\nimport \\\"./CometMath.sol\\\";\\n\\nabstract contract CometCore is CometConfiguration, CometStorage, CometMath {\\n    struct AssetInfo {\\n        uint8 offset;\\n        address asset;\\n        address priceFeed;\\n        uint64 scale;\\n        uint64 borrowCollateralFactor;\\n        uint64 liquidateCollateralFactor;\\n        uint64 liquidationFactor;\\n        uint128 supplyCap;\\n    }\\n\\n    /** Internal constants **/\\n\\n    /// @dev The max number of assets this contract is hardcoded to support\\n    ///  Do not change this variable without updating all the fields throughout the contract,\\n    //    including the size of UserBasic.assetsIn and corresponding integer conversions.\\n    uint8 internal constant MAX_ASSETS = 15;\\n\\n    /// @dev The max number of decimals base token can have\\n    ///  Note this cannot just be increased arbitrarily.\\n    uint8 internal constant MAX_BASE_DECIMALS = 18;\\n\\n    /// @dev The max value for a collateral factor (1)\\n    uint64 internal constant MAX_COLLATERAL_FACTOR = FACTOR_SCALE;\\n\\n    /// @dev Offsets for specific actions in the pause flag bit array\\n    uint8 internal constant PAUSE_SUPPLY_OFFSET = 0;\\n    uint8 internal constant PAUSE_TRANSFER_OFFSET = 1;\\n    uint8 internal constant PAUSE_WITHDRAW_OFFSET = 2;\\n    uint8 internal constant PAUSE_ABSORB_OFFSET = 3;\\n    uint8 internal constant PAUSE_BUY_OFFSET = 4;\\n\\n    /// @dev The decimals required for a price feed\\n    uint8 internal constant PRICE_FEED_DECIMALS = 8;\\n\\n    /// @dev 365 days * 24 hours * 60 minutes * 60 seconds\\n    uint64 internal constant SECONDS_PER_YEAR = 31_536_000;\\n\\n    /// @dev The scale for base tracking accrual\\n    uint64 internal constant BASE_ACCRUAL_SCALE = 1e6;\\n\\n    /// @dev The scale for base index (depends on time/rate scales, not base token)\\n    uint64 internal constant BASE_INDEX_SCALE = 1e15;\\n\\n    /// @dev The scale for prices (in USD)\\n    uint64 internal constant PRICE_SCALE = uint64(10 ** PRICE_FEED_DECIMALS);\\n\\n    /// @dev The scale for factors\\n    uint64 internal constant FACTOR_SCALE = 1e18;\\n\\n    /**\\n     * @notice Determine if the manager has permission to act on behalf of the owner\\n     * @param owner The owner account\\n     * @param manager The manager account\\n     * @return Whether or not the manager has permission\\n     */\\n    function hasPermission(address owner, address manager) public view returns (bool) {\\n        return owner == manager || isAllowed[owner][manager];\\n    }\\n\\n    /**\\n     * @dev The positive present supply balance if positive or the negative borrow balance if negative\\n     */\\n    function presentValue(int104 principalValue_) internal view returns (int256) {\\n        if (principalValue_ >= 0) {\\n            return signed256(presentValueSupply(baseSupplyIndex, uint104(principalValue_)));\\n        } else {\\n            return -signed256(presentValueBorrow(baseBorrowIndex, uint104(-principalValue_)));\\n        }\\n    }\\n\\n    /**\\n     * @dev The principal amount projected forward by the supply index\\n     */\\n    function presentValueSupply(uint64 baseSupplyIndex_, uint104 principalValue_) internal pure returns (uint256) {\\n        return uint256(principalValue_) * baseSupplyIndex_ / BASE_INDEX_SCALE;\\n    }\\n\\n    /**\\n     * @dev The principal amount projected forward by the borrow index\\n     */\\n    function presentValueBorrow(uint64 baseBorrowIndex_, uint104 principalValue_) internal pure returns (uint256) {\\n        return uint256(principalValue_) * baseBorrowIndex_ / BASE_INDEX_SCALE;\\n    }\\n\\n    /**\\n     * @dev The positive principal if positive or the negative principal if negative\\n     */\\n    function principalValue(int256 presentValue_) internal view returns (int104) {\\n        if (presentValue_ >= 0) {\\n            return signed104(principalValueSupply(baseSupplyIndex, uint256(presentValue_)));\\n        } else {\\n            return -signed104(principalValueBorrow(baseBorrowIndex, uint256(-presentValue_)));\\n        }\\n    }\\n\\n    /**\\n     * @dev The present value projected backward by the supply index (rounded down)\\n     *  Note: This will overflow (revert) at 2^104/1e18=~20 trillion principal for assets with 18 decimals.\\n     */\\n    function principalValueSupply(uint64 baseSupplyIndex_, uint256 presentValue_) internal pure returns (uint104) {\\n        return safe104((presentValue_ * BASE_INDEX_SCALE) / baseSupplyIndex_);\\n    }\\n\\n    /**\\n     * @dev The present value projected backward by the borrow index (rounded up)\\n     *  Note: This will overflow (revert) at 2^104/1e18=~20 trillion principal for assets with 18 decimals.\\n     */\\n    function principalValueBorrow(uint64 baseBorrowIndex_, uint256 presentValue_) internal pure returns (uint104) {\\n        return safe104((presentValue_ * BASE_INDEX_SCALE + baseBorrowIndex_ - 1) / baseBorrowIndex_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CometConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Compound's Comet Configuration Interface\\n * @author Compound\\n */\\ncontract CometConfiguration {\\n    struct ExtConfiguration {\\n        bytes32 name32;\\n        bytes32 symbol32;\\n    }\\n\\n    struct Configuration {\\n        address governor;\\n        address pauseGuardian;\\n        address baseToken;\\n        address baseTokenPriceFeed;\\n        address extensionDelegate;\\n\\n        uint64 supplyKink;\\n        uint64 supplyPerYearInterestRateSlopeLow;\\n        uint64 supplyPerYearInterestRateSlopeHigh;\\n        uint64 supplyPerYearInterestRateBase;\\n        uint64 borrowKink;\\n        uint64 borrowPerYearInterestRateSlopeLow;\\n        uint64 borrowPerYearInterestRateSlopeHigh;\\n        uint64 borrowPerYearInterestRateBase;\\n        uint64 storeFrontPriceFactor;\\n        uint64 trackingIndexScale;\\n        uint64 baseTrackingSupplySpeed;\\n        uint64 baseTrackingBorrowSpeed;\\n        uint104 baseMinForRewards;\\n        uint104 baseBorrowMin;\\n        uint104 targetReserves;\\n\\n        AssetConfig[] assetConfigs;\\n    }\\n\\n    struct AssetConfig {\\n        address asset;\\n        address priceFeed;\\n        uint8 decimals;\\n        uint64 borrowCollateralFactor;\\n        uint64 liquidateCollateralFactor;\\n        uint64 liquidationFactor;\\n        uint128 supplyCap;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CometStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Compound's Comet Storage Interface\\n * @dev Versions can enforce append-only storage slots via inheritance.\\n * @author Compound\\n */\\ncontract CometStorage {\\n    // 512 bits total = 2 slots\\n    struct TotalsBasic {\\n        // 1st slot\\n        uint64 baseSupplyIndex;\\n        uint64 baseBorrowIndex;\\n        uint64 trackingSupplyIndex;\\n        uint64 trackingBorrowIndex;\\n        // 2nd slot\\n        uint104 totalSupplyBase;\\n        uint104 totalBorrowBase;\\n        uint40 lastAccrualTime;\\n        uint8 pauseFlags;\\n    }\\n\\n    struct TotalsCollateral {\\n        uint128 totalSupplyAsset;\\n        uint128 _reserved;\\n    }\\n\\n    struct UserBasic {\\n        int104 principal;\\n        uint64 baseTrackingIndex;\\n        uint64 baseTrackingAccrued;\\n        uint16 assetsIn;\\n        uint8 _reserved;\\n    }\\n\\n    struct UserCollateral {\\n        uint128 balance;\\n        uint128 _reserved;\\n    }\\n\\n    struct LiquidatorPoints {\\n        uint32 numAbsorbs;\\n        uint64 numAbsorbed;\\n        uint128 approxSpend;\\n        uint32 _reserved;\\n    }\\n\\n    /// @dev Aggregate variables tracked for the entire market\\n    uint64 internal baseSupplyIndex;\\n    uint64 internal baseBorrowIndex;\\n    uint64 internal trackingSupplyIndex;\\n    uint64 internal trackingBorrowIndex;\\n    uint104 internal totalSupplyBase;\\n    uint104 internal totalBorrowBase;\\n    uint40 internal lastAccrualTime;\\n    uint8 internal pauseFlags;\\n\\n    /// @notice Aggregate variables tracked for each collateral asset\\n    mapping(address => TotalsCollateral) public totalsCollateral;\\n\\n    /// @notice Mapping of users to accounts which may be permitted to manage the user account\\n    mapping(address => mapping(address => bool)) public isAllowed;\\n\\n    /// @notice The next expected nonce for an address, for validating authorizations via signature\\n    mapping(address => uint) public userNonce;\\n\\n    /// @notice Mapping of users to base principal and other basic data\\n    mapping(address => UserBasic) public userBasic;\\n\\n    /// @notice Mapping of users to collateral data per collateral asset\\n    mapping(address => mapping(address => UserCollateral)) public userCollateral;\\n\\n    /// @notice Mapping of magic liquidator points\\n    mapping(address => LiquidatorPoints) public liquidatorPoints;\\n}\\n\"\r\n    },\r\n    \"contracts/CometMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Compound's Comet Math Contract\\n * @dev Pure math functions\\n * @author Compound\\n */\\ncontract CometMath {\\n    /** Custom errors **/\\n\\n    error InvalidUInt64();\\n    error InvalidUInt104();\\n    error InvalidUInt128();\\n    error InvalidInt104();\\n    error InvalidInt256();\\n    error NegativeNumber();\\n\\n    function safe64(uint n) internal pure returns (uint64) {\\n        if (n > type(uint64).max) revert InvalidUInt64();\\n        return uint64(n);\\n    }\\n\\n    function safe104(uint n) internal pure returns (uint104) {\\n        if (n > type(uint104).max) revert InvalidUInt104();\\n        return uint104(n);\\n    }\\n\\n    function safe128(uint n) internal pure returns (uint128) {\\n        if (n > type(uint128).max) revert InvalidUInt128();\\n        return uint128(n);\\n    }\\n\\n    function signed104(uint104 n) internal pure returns (int104) {\\n        if (n > uint104(type(int104).max)) revert InvalidInt104();\\n        return int104(n);\\n    }\\n\\n    function signed256(uint256 n) internal pure returns (int256) {\\n        if (n > uint256(type(int256).max)) revert InvalidInt256();\\n        return int256(n);\\n    }\\n\\n    function unsigned104(int104 n) internal pure returns (uint104) {\\n        if (n < 0) revert NegativeNumber();\\n        return uint104(n);\\n    }\\n\\n    function unsigned256(int256 n) internal pure returns (uint256) {\\n        if (n < 0) revert NegativeNumber();\\n        return uint256(n);\\n    }\\n\\n    function toUInt8(bool x) internal pure returns (uint8) {\\n        return x ? 1 : 0;\\n    }\\n\\n    function toBool(uint8 x) internal pure returns (bool) {\\n        return x != 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1,\r\n      \"details\": {\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf [xa[r]scLM cCTUtTOntnfDIul Lcul Vcul [j] Tpeul xa[rul] xa[r]cL gvif CTUca[r]LsTOtfDnca[r]Iulc] jmul[jul] VcTOcul jmul\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"wrappedNativeToken_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FailedToSendNativeToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArgument\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferInFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferOutFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnhandledAction\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACTION_CLAIM_REWARD\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ACTION_SUPPLY_ASSET\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ACTION_SUPPLY_NATIVE_TOKEN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ACTION_TRANSFER_ASSET\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ACTION_WITHDRAW_ASSET\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ACTION_WITHDRAW_NATIVE_TOKEN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"actions\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"invoke\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweepNativeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedNativeToken\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BaseBulker", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "000000000000000000000000cc3e7c85bb0ee4f09380e041fee95a0caedd4a020000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}