{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/proxies/IProxyCreationCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\nimport \\\"./SafeProxy.sol\\\";\\n\\n/**\\n * @title IProxyCreationCallback\\n * @dev An interface for a contract that implements a callback function to be executed after the creation of a proxy instance.\\n */\\ninterface IProxyCreationCallback {\\n    /**\\n     * @dev Function to be called after the creation of a SafeProxy instance.\\n     * @param proxy The newly created SafeProxy instance.\\n     * @param _singleton The address of the singleton contract used to create the proxy.\\n     * @param initializer The initializer function call data.\\n     * @param saltNonce The nonce used to generate the salt for the proxy deployment.\\n     */\\n    function proxyCreated(SafeProxy proxy, address _singleton, bytes calldata initializer, uint256 saltNonce) external;\\n}\\n\"\r\n    },\r\n    \"contracts/proxies/SafeProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title IProxy - Helper interface to access the singleton address of the Proxy on-chain.\\n * @author Richard Meissner - @rmeissner\\n */\\ninterface IProxy {\\n    function masterCopy() external view returns (address);\\n}\\n\\n/**\\n * @title SafeProxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\\n * @author Stefan George - <stefan@gnosis.io>\\n * @author Richard Meissner - <richard@gnosis.io>\\n */\\ncontract SafeProxy {\\n    // Singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\\n    address internal singleton;\\n\\n    /**\\n     * @notice Constructor function sets address of singleton contract.\\n     * @param _singleton Singleton address.\\n     */\\n    constructor(address _singleton) {\\n        require(_singleton != address(0), \\\"Invalid singleton address provided\\\");\\n        singleton = _singleton;\\n    }\\n\\n    /// @dev Fallback function forwards all transactions and returns all received return data.\\n    fallback() external payable {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\\n            // 0xa619486e == keccak(\\\"masterCopy()\\\"). The value is right padded to 32-bytes with 0s\\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\\n                mstore(0, _singleton)\\n                return(0, 0x20)\\n            }\\n            calldatacopy(0, 0, calldatasize())\\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            if eq(success, 0) {\\n                revert(0, returndatasize())\\n            }\\n            return(0, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proxies/SafeProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"./SafeProxy.sol\\\";\\nimport \\\"./IProxyCreationCallback.sol\\\";\\n\\n/**\\n * @title Proxy Factory - Allows to create a new proxy contract and execute a message call to the new proxy within one transaction.\\n * @author Stefan George - @Georgi87\\n */\\ncontract SafeProxyFactory {\\n    event ProxyCreation(SafeProxy indexed proxy, address singleton);\\n\\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\\n    function proxyCreationCode() public pure returns (bytes memory) {\\n        return type(SafeProxy).creationCode;\\n    }\\n\\n    /**\\n     * @notice Internal method to create a new proxy contract using CREATE2. Optionally executes an initializer call to a new proxy.\\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\\n     * @param initializer (Optional) Payload for a message call to be sent to a new proxy contract.\\n     * @param salt Create2 salt to use for calculating the address of the new proxy contract.\\n     * @return proxy Address of the new proxy contract.\\n     */\\n    function deployProxy(address _singleton, bytes memory initializer, bytes32 salt) internal returns (SafeProxy proxy) {\\n        require(isContract(_singleton), \\\"Singleton contract not deployed\\\");\\n\\n        bytes memory deploymentData = abi.encodePacked(type(SafeProxy).creationCode, uint256(uint160(_singleton)));\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\\n        }\\n        require(address(proxy) != address(0), \\\"Create2 call failed\\\");\\n\\n        if (initializer.length > 0) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) {\\n                    revert(0, 0)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Deploys a new proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\\n     */\\n    function createProxyWithNonce(address _singleton, bytes memory initializer, uint256 saltNonce) public returns (SafeProxy proxy) {\\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));\\n        proxy = deployProxy(_singleton, initializer, salt);\\n        emit ProxyCreation(proxy, _singleton);\\n    }\\n\\n    /**\\n     * @notice Deploys a new chain-specific proxy with `_singleton` singleton and `saltNonce` salt. Optionally executes an initializer call to a new proxy.\\n     * @dev Allows to create a new proxy contract that should exist only on 1 network (e.g. specific governance or admin accounts)\\n     *      by including the chain id in the create2 salt. Such proxies cannot be created on other networks by replaying the transaction.\\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\\n     */\\n    function createChainSpecificProxyWithNonce(\\n        address _singleton,\\n        bytes memory initializer,\\n        uint256 saltNonce\\n    ) public returns (SafeProxy proxy) {\\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\\n        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce, getChainId()));\\n        proxy = deployProxy(_singleton, initializer, salt);\\n        emit ProxyCreation(proxy, _singleton);\\n    }\\n\\n    /**\\n     * @notice Deploy a new proxy with `_singleton` singleton and `saltNonce` salt.\\n     *         Optionally executes an initializer call to a new proxy and calls a specified callback address `callback`.\\n     * @param _singleton Address of singleton contract. Must be deployed at the time of execution.\\n     * @param initializer Payload for a message call to be sent to a new proxy contract.\\n     * @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\\n     * @param callback Callback that will be invoked after the new proxy contract has been successfully deployed and initialized.\\n     */\\n    function createProxyWithCallback(\\n        address _singleton,\\n        bytes memory initializer,\\n        uint256 saltNonce,\\n        IProxyCreationCallback callback\\n    ) public returns (SafeProxy proxy) {\\n        uint256 saltNonceWithCallback = uint256(keccak256(abi.encodePacked(saltNonce, callback)));\\n        proxy = createProxyWithNonce(_singleton, initializer, saltNonceWithCallback);\\n        if (address(callback) != address(0)) callback.proxyCreated(proxy, _singleton, initializer, saltNonce);\\n    }\\n\\n    /**\\n     * @notice Returns true if `account` is a contract.\\n     * @dev This function will return false if invoked during the constructor of a contract,\\n     *      as the code is not actually created until after the constructor finishes.\\n     * @param account The address being queried\\n     * @return True if `account` is a contract\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @notice Returns the ID of the chain the contract is currently deployed on.\\n     * @return The ID of the current chain as a uint256.\\n     */\\n    function getChainId() public view returns (uint256) {\\n        uint256 id;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract SafeProxy\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"singleton\",\"type\":\"address\"}],\"name\":\"ProxyCreation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_singleton\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initializer\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"saltNonce\",\"type\":\"uint256\"}],\"name\":\"createChainSpecificProxyWithNonce\",\"outputs\":[{\"internalType\":\"contract SafeProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_singleton\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initializer\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"saltNonce\",\"type\":\"uint256\"},{\"internalType\":\"contract IProxyCreationCallback\",\"name\":\"callback\",\"type\":\"address\"}],\"name\":\"createProxyWithCallback\",\"outputs\":[{\"internalType\":\"contract SafeProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_singleton\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initializer\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"saltNonce\",\"type\":\"uint256\"}],\"name\":\"createProxyWithNonce\",\"outputs\":[{\"internalType\":\"contract SafeProxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SafeProxyFactory", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}