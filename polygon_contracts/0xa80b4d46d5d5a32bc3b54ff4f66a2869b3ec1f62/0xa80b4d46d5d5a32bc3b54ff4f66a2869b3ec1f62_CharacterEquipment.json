{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/game/CharacterEquipment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./GameBase.sol\\\";\\nimport \\\"../data/Character.sol\\\";\\nimport \\\"../interfaces/ICharacterEquipment.sol\\\";\\nimport \\\"../access/TokenAccess.sol\\\";\\n\\ncontract CharacterEquipment is ICharacterEquipment, GameBase, TokenAccess {\\n    constructor(address game)\\n    GameBase(game)\\n    TokenAccess(game) {\\n    }\\n\\n    function validateEquip(uint256 worldId, uint256 tokenId, uint256[] calldata itemDefinitionIds) external view override returns(EquipValidationResult memory) {\\n        World world = getWorld(worldId);\\n        Character character = world.character();\\n\\n        if (address(world) == address(0) || address(character) == address(0)) {\\n            return _returnFailedValidation(itemDefinitionIds);\\n        }\\n\\n        CharacterDefinition characterDefinition = world.characterDefinition();\\n        uint256 characterDefinitionId = character.characterDefinitionIds(tokenId);\\n        if (itemDefinitionIds.length != characterDefinition.getEquipmentSlots(characterDefinitionId).length) {\\n            return _returnFailedValidation(itemDefinitionIds);\\n        }\\n\\n        bool[] memory validSlots = _validSlots(worldId, tokenId, itemDefinitionIds);\\n        bool[] memory validItemDefinitionIds = _validItemDefinitionIds(worldId, itemDefinitionIds);\\n        bool[] memory equipableItems = _equipableItems(worldId, tokenId, itemDefinitionIds);\\n        bool[] memory validItemCounts = _validItemCounts(worldId, tokenId, itemDefinitionIds);\\n\\n        return EquipValidationResult(\\n            true,\\n            true,\\n            true,\\n            validSlots,\\n            validItemDefinitionIds,\\n            equipableItems,\\n            validItemCounts\\n        );\\n    }\\n\\n    function _returnFailedValidation(uint256[] calldata itemDefinitionIds) private view returns(EquipValidationResult memory) {\\n        bool[] memory validSlots = new bool[](itemDefinitionIds.length);\\n        bool[] memory validItemDefinitionIds = new bool[](itemDefinitionIds.length);\\n        bool[] memory equipableItems = new bool[](itemDefinitionIds.length);\\n        bool[] memory validItemCounts = new bool[](itemDefinitionIds.length);\\n\\n        for (uint256 i; i < itemDefinitionIds.length; i++) {\\n            validSlots[i] = false;\\n            validItemDefinitionIds[i] = false;\\n            equipableItems[i] = false;\\n            validItemCounts[i] = false;\\n        }\\n\\n        return EquipValidationResult(\\n            false,\\n            false,\\n            false,\\n            validSlots,\\n            validItemDefinitionIds,\\n            equipableItems,\\n            validItemCounts\\n        );\\n    }\\n\\n    function _validSlots(uint256 worldId, uint256 tokenId, uint256[] calldata itemDefinitionIds) private view returns(bool[] memory) {\\n        World world = getWorld(worldId);\\n        Character character = world.character();\\n        CharacterDefinition characterDefinition = world.characterDefinition();\\n\\n        bool[] memory validSlots = new bool[](itemDefinitionIds.length);\\n\\n        for (uint256 i; i < itemDefinitionIds.length; i++) {\\n            validSlots[i] = characterDefinition.isValidEquipmentSlot(character.characterDefinitionIds(tokenId), i);\\n        }\\n\\n        return validSlots;\\n    }\\n\\n    function _validItemDefinitionIds(uint256 worldId, uint256[] calldata itemDefinitionIds) private view returns(bool[] memory) {\\n        bool[] memory validItemDefinitionIds = new bool[](itemDefinitionIds.length);\\n\\n        for (uint256 i; i < itemDefinitionIds.length; i++) {\\n            IItemDefinition.ItemDefinitionRecord memory record = getItemDefinition(worldId).getDefinition(itemDefinitionIds[i]);\\n            validItemDefinitionIds[i] = record.enable;\\n        }\\n\\n        return validItemDefinitionIds;\\n    }\\n\\n    function _equipableItems(uint256 worldId, uint256 tokenId, uint256[] calldata itemDefinitionIds) private view returns(bool[] memory) {\\n        World world = getWorld(worldId);\\n        Character character = world.character();\\n        CharacterDefinition characterDefinition = world.characterDefinition();\\n        bool[] memory equipableItems = new bool[](itemDefinitionIds.length);\\n\\n        for (uint256 i; i < itemDefinitionIds.length; i++) {\\n            equipableItems[i] = characterDefinition.canEquip(character.characterDefinitionIds(tokenId), itemDefinitionIds[i], i);\\n        }\\n\\n        return equipableItems;\\n    }\\n\\n    function _validItemCounts(uint256 worldId, uint256 tokenId, uint256[] calldata itemDefinitionIds) private view returns(bool[] memory) {\\n        World world = getWorld(worldId);\\n        Character character = world.character();\\n        Equipment equipment = world.equipment();\\n        ItemStorage itemStorage = world.itemStorage();\\n\\n        uint256[] memory equipments = equipment.getEquipments(tokenId);\\n        bool[] memory validItemCounts = new bool[](itemDefinitionIds.length);\\n\\n        for (uint256 i; i < itemDefinitionIds.length; i++) {\\n            uint256 itemDefinitionId = itemDefinitionIds[i];\\n            int64 itemCount = itemStorage.items(tokenId, itemDefinitionId);\\n            uint256 oldItemId = equipments.length > i ? equipments[i] : 0;\\n\\n            validItemCounts[i] = (itemCount > 0 && oldItemId != itemDefinitionId) || (oldItemId == itemDefinitionId);\\n        }\\n\\n        return validItemCounts;\\n    }\\n\\n    function equip(uint256 worldId, uint256 tokenId, uint256[] calldata itemDefinitionIds) external override onlyGameUser(worldId, tokenId) {\\n        EquipValidationResult memory result = this.validateEquip(worldId, tokenId, itemDefinitionIds);\\n\\n        require(result.validWorldId, \\\"wrong worldId\\\");\\n        require(result.validTokenId, \\\"wrong tokenId\\\");\\n        require(result.validItemDefinitionIdLength, \\\"wrong itemDefinitionIds length\\\");\\n        for (uint256 i; i < itemDefinitionIds.length; i++) {\\n            require(result.validSlots[i], \\\"wrong slots\\\");\\n            require(result.validItemDefinitionIds[i], \\\"wrong validItemDefinitionIds\\\");\\n            require(result.equipableItems[i], \\\"not equipable item\\\");\\n            require(result.validItemCounts[i], \\\"not own items\\\");\\n        }\\n\\n        _equip(worldId, tokenId, itemDefinitionIds);\\n        emit Equip(worldId, tokenId, itemDefinitionIds);\\n    }\\n\\n    function getEquipments(uint256 worldId, uint256 tokenId) external view override returns(uint256[] memory) {\\n        World world = getWorld(worldId);\\n        Equipment equipment = world.equipment();\\n\\n        return equipment.getEquipments(tokenId);\\n    }\\n\\n    function _equip(uint256 worldId, uint256 tokenId, uint256[] calldata itemDefinitionIds) private {\\n        World world = getWorld(worldId);\\n        Equipment equipment = world.equipment();\\n        ItemStorage itemStorage = world.itemStorage();\\n\\n        uint256[] memory equipments = equipment.getEquipments(tokenId);\\n\\n        for (uint256 i; i < itemDefinitionIds.length; i++) {\\n            uint256 itemId = itemDefinitionIds[i];\\n            uint256 oldItemId = equipments.length > i ? equipments[i] : 0;\\n\\n            if (itemId > 0) {\\n                itemStorage.addItem(tokenId, itemId, -1);\\n            }\\n            if (oldItemId > 0) {\\n                itemStorage.addItem(tokenId, oldItemId, 1);\\n            }\\n        }\\n\\n        equipment.setEquipments(tokenId, itemDefinitionIds);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/game/GameBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Game.sol\\\";\\nimport \\\"../World.sol\\\";\\nimport \\\"../data/Character.sol\\\";\\nimport \\\"../interfaces/definitions/IItemDefinition.sol\\\";\\n\\ncontract GameBase {\\n    Game internal _game;\\n\\n    constructor(address game) {\\n        _game = Game(game);\\n    }\\n\\n    function getWorld(uint256 worldId) internal view virtual returns(World) {\\n        return World(_game.worlds(worldId));\\n    }\\n\\n    function getItemDefinition(uint256 worldId) internal view virtual returns(IItemDefinition) {\\n        World world = getWorld(worldId);\\n        if (address(world) == address(0)) {\\n            return IItemDefinition(address(0));\\n        }\\n\\n        return world.itemDefinition();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/Character.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract Character is WorldAccess {\\n    // key: tokenId, value: characterDefinitionId\\n    mapping(uint256 => uint256) public characterDefinitionIds;\\n\\n    // key: tokenId, value: isRevealed\\n    mapping(uint256 => bool) public isRevealeds;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function setIsRevealed(uint256 tokenId_, bool isRevealed_) public virtual onlyGame {\\n        isRevealeds[tokenId_] = isRevealed_;\\n    }\\n\\n    function setCharacterDefinitionId(uint256 tokenId_, uint256 characterDefinitionId_) public virtual onlyGame {\\n        characterDefinitionIds[tokenId_] = characterDefinitionId_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICharacterEquipment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface ICharacterEquipment {\\n    struct EquipValidationResult {\\n        bool validWorldId;\\n        bool validTokenId;\\n        // If the length of the equip slot is exceeded, it becomes false.\\n        bool validItemDefinitionIdLength;\\n        // Whether the equip slot is disabled\\n        bool[] validSlots;\\n        bool[] validItemDefinitionIds;\\n        bool[] equipableItems;\\n        bool[] validItemCounts;\\n    }\\n\\n    event Equip(uint256 indexed worldId, uint256 indexed tokenId, uint256[] itemIds);\\n\\n    function equip(uint256 worldId, uint256 tokenId, uint256[] calldata itemDefinitionIds) external;\\n\\n    function validateEquip(uint256 worldId, uint256 tokenId, uint256[] calldata itemDefinitionIds) external view returns(EquipValidationResult memory);\\n\\n    // Returns an array of Equipment itemDefinitionId\\n    function getEquipments(uint256 worldId, uint256 tokenId) external view returns(uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/access/TokenAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IGameAccess.sol\\\";\\nimport \\\"./AccessControl.sol\\\";\\n\\ncontract TokenAccess is Ownable, AccessControl {\\n    constructor(address gameAddress)\\n    AccessControl(gameAddress) {\\n    }\\n\\n    modifier onlyGameUser(uint256 worldId, uint256 tokenId) {\\n        bool isInternal = checkAccess(msg.sender, _gameAccess.getInterfaceAddresses());\\n        bool isGameAdmin = checkAccess(msg.sender, _gameAccess.getGameAdminAddresses());\\n        bool isWorldOwner = checkAccess(msg.sender, _gameAccess.getWorldOwnerAddresses(worldId));\\n        bool isTokenOwner = msg.sender == _gameAccess.getTokenOwnerAddress(worldId, tokenId);\\n        bool isOwner = msg.sender == owner();\\n        bool isGame = msg.sender == address(_gameAccess);\\n\\n        require(isInternal || isGameAdmin || isWorldOwner || isOwner || isTokenOwner || isGame, \\\"TokenAccess: caller is not GameUser\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Game.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IWorld.sol\\\";\\nimport \\\"./interfaces/IGameAccess.sol\\\";\\n\\ncontract Game is IGameAccess, Ownable {\\n    mapping(uint256 => address) public worlds;\\n    mapping(uint256 => address[]) public worldAdmins;\\n    address[] public gameAdmins;\\n\\n    // key: interface name\\n    mapping(string => address) public gameInterfaces;\\n\\n    string[] public gameInterfaceKeys;\\n\\n    constructor() {\\n    }\\n\\n    function setInterfaceAddress(string memory key, address interfaceAddress) public onlyOwner {\\n        _setInterfaceAddress(key, interfaceAddress);\\n    }\\n\\n    function _setInterfaceAddress(string memory key, address interfaceAddress) private {\\n        require(_validKey(key), \\\"wrong key\\\");\\n\\n        gameInterfaces[key] = interfaceAddress;\\n    }\\n\\n    function _validKey(string memory key) private view returns(bool) {\\n        for (uint256 i; i < gameInterfaceKeys.length; i++) {\\n            if (keccak256(abi.encodePacked(gameInterfaceKeys[i])) == keccak256(abi.encodePacked(key))) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function setInterfaceAddressKeys(string[] memory keys) public onlyOwner {\\n        gameInterfaceKeys = keys;\\n    }\\n\\n    function setWorld(uint256 worldId, address worldAddress) public onlyOwner {\\n        worlds[worldId] = worldAddress;\\n        IWorld world = IWorld(worldAddress);\\n        world.setGame(address(this));\\n    }\\n\\n    function getInterfaceAddress(string calldata key) external view returns(address) {\\n        return gameInterfaces[key];\\n    }\\n\\n    function setWorldAdmins(uint256 worldId, address[] calldata admins) public onlyOwner {\\n        worldAdmins[worldId] = admins;\\n    }\\n\\n    function setGameAdmins(address[] calldata admins) public onlyOwner {\\n        gameAdmins = admins;\\n    }\\n\\n    // ==============================\\n    //          IGameAccess\\n    // ==============================\\n    function getInterfaceAddresses() external view override returns(address[] memory) {\\n        address[] memory addresses = new address[](gameInterfaceKeys.length);\\n        for (uint256 i; i < gameInterfaceKeys.length; i++) {\\n            string memory key = gameInterfaceKeys[i];\\n            addresses[i] = gameInterfaces[key];\\n        }\\n\\n        return addresses;\\n    }\\n\\n    function getWorldOwnerAddresses(uint256 worldId) external view override returns(address[] memory) {\\n        address[] memory addresses = new address[](2);\\n        addresses[0] = this.owner();\\n        addresses[1] = worlds[worldId];\\n\\n        return addresses;\\n    }\\n\\n    function getWorldAdminAddresses(uint256 worldId) external view override returns(address[] memory) {\\n        return worldAdmins[worldId];\\n    }\\n\\n    function getGameAdminAddresses() external view override returns(address[] memory) {\\n        return gameAdmins;\\n    }\\n\\n    function getTokenOwnerAddress(uint256 worldId, uint256 tokenId) external view override returns(address) {\\n        IWorld world = IWorld(worlds[worldId]);\\n\\n        return world.getL1NFT().getOwner(tokenId);\\n    }\\n\\n    function getItemPackNFTAddresses(uint256 worldId) external view override returns(address[] memory) {\\n        IWorld world = IWorld(worlds[worldId]);\\n        IItemPackNFT[] memory itemPacNFTs = world.getItemPackNFTs();\\n\\n        address[] memory addresses = new address[](itemPacNFTs.length);\\n        for (uint256 i; i < itemPacNFTs.length; i++) {\\n            addresses[i] = address(itemPacNFTs[i]);\\n        }\\n\\n        return addresses;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/World.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./data/Character.sol\\\";\\nimport \\\"./definitions/CharacterDefinition.sol\\\";\\nimport \\\"./definitions/ItemDefinition.sol\\\";\\nimport \\\"./definitions/EventDefinition.sol\\\";\\nimport \\\"./data/ItemPack.sol\\\";\\nimport \\\"./definitions/ItemPackDefinition.sol\\\";\\nimport \\\"./interfaces/definitions/IItemDefinition.sol\\\";\\nimport \\\"./interfaces/token/IItemPackNFT.sol\\\";\\nimport \\\"./data/CharacterEdition.sol\\\";\\nimport \\\"./data/Equipment.sol\\\";\\nimport \\\"./data/ItemStorage.sol\\\";\\nimport \\\"./interfaces/IWorld.sol\\\";\\nimport \\\"./data/EventCheckinLog.sol\\\";\\nimport \\\"./interfaces/IGameAccess.sol\\\";\\nimport \\\"./interfaces/token/IL1NFT.sol\\\";\\n\\ncontract World is Ownable, IWorld, WorldAccess {\\n    IL1NFT private _l1NFT;\\n    IItemPackNFT[] private _itemPackNFTs;\\n\\n    IGameAccess public game;\\n    uint256 public worldId;\\n\\n    uint256 private _characterIndex;\\n    uint256 private _characterDefinitionIndex;\\n    uint256 private _ItemDefinitionIndex;\\n\\n    CharacterDefinition public characterDefinition;\\n    ItemDefinition public itemDefinition;\\n    ItemPackDefinition public itemPackDefinition;\\n    EventDefinition public eventDefinition;\\n\\n    Character public character;\\n    Equipment public equipment;\\n    ItemStorage public itemStorage;\\n    ItemPack public itemPack;\\n    CharacterEdition public characterEdition;\\n    EventCheckinLog public eventCheckinLog;\\n\\n    // key: commandDefinitionId\\n    mapping(uint256 => address) public commandDefinitions;\\n\\n    constructor(address game_, uint256 worldId_)\\n    WorldAccess(worldId_, game_) {\\n        worldId = worldId_;\\n\\n        characterDefinition = new CharacterDefinition(worldId_, game_);\\n        itemPackDefinition = new ItemPackDefinition(worldId_, game_);\\n        eventDefinition = new EventDefinition(worldId_, game_);\\n        itemDefinition = new ItemDefinition(worldId_, game_);\\n\\n        character = new Character(worldId_, game_);\\n        equipment = new Equipment(worldId_, game_);\\n        itemStorage = new ItemStorage(worldId_, game_);\\n        itemPack = new ItemPack(worldId_, game_);\\n        characterEdition = new CharacterEdition(worldId_, game_);\\n        eventCheckinLog = new EventCheckinLog(worldId_, game_);\\n    }\\n\\n    function setGame(address game_) external override onlyWorldAdmin {\\n        game = IGameAccess(game_);\\n\\n        characterDefinition.setGameAddress(game_);\\n        itemPackDefinition.setGameAddress(game_);\\n        eventDefinition.setGameAddress(game_);\\n        itemDefinition.setGameAddress(game_);\\n\\n        character.setGameAddress(game_);\\n        equipment.setGameAddress(game_);\\n        itemStorage.setGameAddress(game_);\\n        characterEdition.setGameAddress(game_);\\n        eventCheckinLog.setGameAddress(game_);\\n    }\\n\\n    function setL1NFT(address l1NFT_) external onlyWorldAdmin {\\n        _l1NFT = IL1NFT(l1NFT_);\\n    }\\n\\n    function setCharacterDefinition(address characterDefinition_) public onlyWorldAdmin {\\n        characterDefinition = CharacterDefinition(characterDefinition_);\\n    }\\n\\n    function addItemPackNFT(address itemPackNFT) public onlyWorldAdmin {\\n        _itemPackNFTs.push(IItemPackNFT(itemPackNFT));\\n    }\\n\\n    function getItemPackNFTs() external view returns(IItemPackNFT[] memory) {\\n        return _itemPackNFTs;\\n    }\\n\\n    function getItemPackNFTs(uint256 itemPackId) external view returns(address) {\\n        return address(_itemPackNFTs[itemPackId]);\\n    }\\n\\n    function addCharacterDefinition(uint256 characterDefinitionId, CharacterDefinition.EquipmentSlot[] memory equipableSlots_, uint256[][] memory equipables_) public onlyWorldAdmin {\\n        characterDefinition.setCharacter(characterDefinitionId, true);\\n        characterDefinition.setEquipmentSlots(characterDefinitionId, equipableSlots_);\\n\\n        for (uint256 i; i < equipables_.length; i++) {\\n            uint256[] memory equipable = equipables_[i];\\n            uint256 itemId = equipable[0];\\n            uint256 slotIndex = equipable[1];\\n\\n            characterDefinition.setEquipable(characterDefinitionId, itemId, slotIndex);\\n        }\\n    }\\n\\n    function getL1NFT() external view override returns(IL1NFT) {\\n        return _l1NFT;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/definitions/IItemDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IItemDefinition {\\n    struct ItemDefinitionRecord {\\n        uint256 itemDefinitionId;\\n        string category;\\n        bool enable;\\n        bool salable;\\n        bool transferable;\\n        uint256 effectivePeriod;\\n    }\\n\\n    function setDefinitions(ItemDefinitionRecord[] calldata records) external;\\n\\n    function getDefinition(uint256 itemDefinitionId_) external view returns(ItemDefinitionRecord memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWorld.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"./token/IL1NFT.sol\\\";\\nimport \\\"./token/IItemPackNFT.sol\\\";\\n\\ninterface IWorld {\\n    function setGame(address game_) external;\\n    function getL1NFT() external view returns(IL1NFT);\\n    function getItemPackNFTs() external view returns(IItemPackNFT[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGameAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IGameAccess {\\n    function getInterfaceAddresses() external view returns(address[] memory);\\n    function getWorldOwnerAddresses(uint256 worldId) external view returns(address[] memory);\\n    function getWorldAdminAddresses(uint256 worldId) external view returns(address[] memory);\\n    function getGameAdminAddresses() external view returns(address[] memory);\\n    function getTokenOwnerAddress(uint256 worldId, uint256 tokenId) external view returns(address);\\n    function getItemPackNFTAddresses(uint256 worldId) external view returns(address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/token/IL1NFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IL1NFT {\\n    function getTokens(address owner) external view returns(uint256[] memory);\\n    function getOwner(uint256 tokenId) external view returns (address owner);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/token/IItemPackNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IItemPackNFT {\\n    function getEnabled() external view returns(bool);\\n    function setEnabled(bool enabled) external;\\n    function mint(address to, uint256 quantity, uint256 itemPackDefinitionId) external;\\n    function burn(uint256 tokenId) external;\\n    function getTokens(address owner) external view returns(uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/definitions/CharacterDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract CharacterDefinition is WorldAccess {\\n    enum EquipmentSlot { Invalid, Normal }\\n\\n    // key: characterDefinitionId\\n    mapping(uint256 => bool) characters;\\n\\n    // key: characterDefinitionId\\n    mapping(uint256 => EquipmentSlot[]) public equipmentSlots;\\n\\n    // key: characterDefinitionId, value: (key: itemId, value: equipmentSlotIndex)\\n    mapping(uint256 => mapping(uint256 => uint256)) public equipableItems;\\n\\n    // key: characterDefinitionId, value: array of itemDefinitionId\\n    mapping(uint256 => uint256[]) public defaultEquipmentIds;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function setCharacter(uint256 characterDefinitionId, bool enabled) public virtual onlyWorldAdmin {\\n        require(characterDefinitionId > 0);\\n\\n        characters[characterDefinitionId] = enabled;\\n    }\\n\\n    function setEquipmentSlots(uint256 characterDefinitionId, EquipmentSlot[] memory equipmentSlots_) public virtual onlyWorldAdmin {\\n        require(characters[characterDefinitionId] == true, \\\"character disabled\\\");\\n        require(equipmentSlots_.length > 0);\\n\\n        equipmentSlots[characterDefinitionId] = equipmentSlots_;\\n    }\\n\\n    function getEquipmentSlots(uint256 characterDefinitionId) public view virtual returns(EquipmentSlot[] memory) {\\n        return equipmentSlots[characterDefinitionId];\\n    }\\n\\n    function isValidEquipmentSlot(uint256 characterDefinitionId, uint256 equipmentSlotIndex) public view virtual returns(bool) {\\n        return equipmentSlotIndex >= 0 && equipmentSlotIndex < equipmentSlots[characterDefinitionId].length && equipmentSlots[characterDefinitionId][equipmentSlotIndex] != EquipmentSlot.Invalid;\\n    }\\n\\n    function setEquipable(uint256 characterDefinitionId, uint256 itemId, uint256 equipmentSlotIndex) public virtual onlyWorldAdmin {\\n        require(characters[characterDefinitionId] == true);\\n\\n        equipableItems[characterDefinitionId][itemId] = equipmentSlotIndex;\\n    }\\n\\n    function setDefaultEquipment(uint256 characterDefinitionId, uint256 itemId, uint256 equipmentSlotIndex) public onlyWorldAdmin {\\n        if (defaultEquipmentIds[characterDefinitionId][equipmentSlotIndex] <= itemId) {\\n            defaultEquipmentIds[characterDefinitionId][equipmentSlotIndex] = itemId;\\n        }\\n    }\\n\\n    function canEquip(uint256 characterDefinitionId, uint256 itemId, uint256 equipmentSlotIndex) public virtual view returns(bool) {\\n        return equipableItems[characterDefinitionId][itemId] == equipmentSlotIndex || itemId == 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/definitions/ItemDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/definitions/IItemDefinition.sol\\\";\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract ItemDefinition is IItemDefinition, WorldAccess {\\n    mapping(uint256 => IItemDefinition.ItemDefinitionRecord) itemDefinitionRecords;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function _setDefinition(IItemDefinition.ItemDefinitionRecord calldata record) internal {\\n        itemDefinitionRecords[record.itemDefinitionId] = record;\\n    }\\n\\n    function setDefinitions(IItemDefinition.ItemDefinitionRecord[] calldata records) external override onlyWorldAdmin {\\n        for (uint256 i; i < records.length; i++) {\\n            _setDefinition(records[i]);\\n        }\\n    }\\n\\n    function getDefinition(uint256 itemDefinitionId_) external view returns(ItemDefinitionRecord memory) {\\n        return itemDefinitionRecords[itemDefinitionId_];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/definitions/EventDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract EventDefinition is WorldAccess {\\n    struct EventDefinitionRecord {\\n        uint256 eventDefinitionId;\\n        bool enabled;\\n        uint256 itemPackDefinitionId;\\n        address eventNftAddress;\\n        uint256 executableTimes;\\n        uint256 executableTimesPerUser;\\n        uint256 endPeriod;\\n        uint256 userExecutableInterval;\\n        bool gpsCheckEnabled;\\n    }\\n\\n    mapping(uint256 => EventDefinitionRecord) private _eventDefinitions;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function getItemPackDefinitionId(uint256 eventDefinitionId) public virtual view returns(uint256) {\\n        EventDefinitionRecord memory record = _eventDefinitions[eventDefinitionId];\\n\\n        return record.itemPackDefinitionId;\\n    }\\n\\n    function getEventDefinition(uint256 eventDefinitionId) external virtual view returns(\\n            uint256, bool, uint256, address, uint256, uint256, uint256, uint256, bool) {\\n        EventDefinitionRecord memory record = _eventDefinitions[eventDefinitionId];\\n\\n        return (\\n            record.eventDefinitionId,\\n            record.enabled,\\n            record.itemPackDefinitionId,\\n            record.eventNftAddress,\\n            record.executableTimes,\\n            record.executableTimesPerUser,\\n            record.endPeriod,\\n            record.userExecutableInterval,\\n            record.gpsCheckEnabled\\n        );\\n    }\\n\\n    function setEventDefinitions(EventDefinitionRecord[] memory eventDefinitions_) public virtual onlyWorldAdmin {\\n        for (uint256 i; i < eventDefinitions_.length; i++) {\\n            EventDefinitionRecord memory record = eventDefinitions_[i];\\n            _addEventDefinition(\\n                record.eventDefinitionId,\\n                record.enabled,\\n                record.itemPackDefinitionId,\\n                record.eventNftAddress,\\n                record.executableTimes,\\n                record.executableTimesPerUser,\\n                record.endPeriod,\\n                record.userExecutableInterval,\\n                record.gpsCheckEnabled\\n            );\\n        }\\n    }\\n\\n    function _addEventDefinition(\\n        uint256 eventDefinitionId,\\n        bool enabled_,\\n        uint256 itemPackDefinitionId_,\\n        address eventNftAddress_,\\n        uint256 executableTimes_,\\n        uint256 executableTimesPerUser_,\\n        uint256 endPeriod_,\\n        uint256 userExecutableInterval,\\n        bool gpsCheckEnabled\\n    ) private {\\n        _eventDefinitions[eventDefinitionId] = EventDefinitionRecord(\\n            eventDefinitionId,\\n            enabled_,\\n            itemPackDefinitionId_,\\n            eventNftAddress_,\\n            executableTimes_,\\n            executableTimesPerUser_,\\n            endPeriod_,\\n            userExecutableInterval,\\n            gpsCheckEnabled\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/ItemPack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../lib/IDArrayUtil.sol\\\";\\nimport \\\"../interfaces/token/IItemPackNFT.sol\\\";\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\nusing IDArrayUtil for uint256[];\\n\\ncontract ItemPack is WorldAccess {\\n    uint256 private _currentIndex;\\n\\n    struct ItemPackRecord {\\n        uint256 itemPackId;\\n        uint256 itemPackDefinitionId;\\n        address playerWallet;\\n        address nftAddress;\\n        uint256 tokenId;\\n        bool isRevealed;\\n    }\\n\\n    // key: itemPackId, value: array of ItemPackRecord\\n    mapping(uint256 => ItemPackRecord) public itemPackRecords;\\n\\n    // key: NFT contract address, value: (key: tokenId, value: itemPackId)\\n    mapping(address => mapping(uint256 => uint256)) public itemPackIdsByNft;\\n\\n    // key: Wallet address, array of itemPackId\\n    mapping(address => uint256[]) private _itemPackIdsByWallet;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function mintToWallet(address playerWallet, uint256 itemPackDefinitionId_) public virtual onlyGame {\\n        _mint(itemPackDefinitionId_, playerWallet, address(0), 0);\\n    }\\n\\n    function mintByNFT(address nftAddress, uint256 tokenId, uint256 itemPackDefinitionId_) public virtual onlyGame {\\n        _mint(itemPackDefinitionId_, address(0), nftAddress, tokenId);\\n    }\\n\\n    function burnByNFT(address nftAddress, uint256 tokenId) public virtual onlyGame {\\n        _burn(itemPackIdsByNft[nftAddress][tokenId]);\\n    }\\n\\n    function burn(uint256 itemPackId) public virtual onlyGame {\\n        _burn(itemPackId);\\n    }\\n\\n    function _mint(uint256 itemPackDefinitionId_, address playerWallet, address nftAddress, uint256 tokenId) internal virtual {\\n        _currentIndex++;\\n\\n        if (playerWallet != address(0)) {\\n            _itemPackIdsByWallet[playerWallet].push(_currentIndex);\\n        }\\n\\n        if (nftAddress != address(0) && tokenId != 0) {\\n            itemPackIdsByNft[nftAddress][tokenId] = _currentIndex;\\n        }\\n\\n        itemPackRecords[_currentIndex] = ItemPackRecord(\\n            _currentIndex,\\n            itemPackDefinitionId_,\\n            playerWallet,\\n            nftAddress,\\n            tokenId,\\n            false\\n        );\\n    }\\n\\n    function _burn(uint256 itemPackId) internal virtual {\\n        address playerWallet = itemPackRecords[itemPackId].playerWallet;\\n        if (playerWallet != address(0)) {\\n            _itemPackIdsByWallet[playerWallet].removeById(itemPackId);\\n        }\\n\\n        itemPackRecords[itemPackId] = ItemPackRecord(itemPackId, 0, address(0), address(0), 0, true);\\n    }\\n\\n    function getItemPackIds(address playerWallet) public virtual view returns(uint256[] memory) {\\n        return _itemPackIdsByWallet[playerWallet];\\n    }\\n\\n    function itemPackDefinitionId(uint256 itemPackId) public virtual view returns (uint256) {\\n        return itemPackRecords[itemPackId].itemPackDefinitionId;\\n    }\\n\\n    function itemPackTokenId(uint256 itemPackId) public virtual view returns (uint256) {\\n        return itemPackRecords[itemPackId].tokenId;\\n    }\\n\\n    function isRevealed(uint256 itemPackId) public virtual view returns (bool) {\\n        return itemPackRecords[itemPackId].isRevealed;\\n    }\\n\\n    function getItemPackRecord(uint256 itemPackId) public virtual view returns (ItemPackRecord memory) {\\n        return itemPackRecords[itemPackId];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/definitions/ItemPackDefinition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract ItemPackDefinition is WorldAccess {\\n    struct SlotDefinition {\\n        uint256[] itemDefinitionIds;\\n        uint256[] weights;\\n        int64[] amounts;\\n    }\\n\\n    // key: itemPackDefinitionId\\n    mapping(uint256 => SlotDefinition[]) private _slotDefinitions;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function getSlotLength(uint256 itemPackDefinitionId) public virtual view returns(uint256) {\\n        return _slotDefinitions[itemPackDefinitionId].length;\\n    }\\n\\n    function getSlotDefinition(uint256 itemPackDefinitionId, uint256 slot) public virtual view returns(uint256[] memory, uint256[] memory, int64[] memory) {\\n        SlotDefinition memory s = _slotDefinitions[itemPackDefinitionId][slot];\\n\\n        return (s.itemDefinitionIds, s.weights, s.amounts);\\n    }\\n\\n    function setItemPackDefinition(uint256 itemPackDefinitionId, SlotDefinition[] memory itemPacks) public virtual onlyWorldAdmin {\\n        delete _slotDefinitions[itemPackDefinitionId];\\n        for (uint256 i; i < itemPacks.length; i++) {\\n            SlotDefinition memory itemPack = itemPacks[i];\\n\\n            // TODO: check itemId\\n            require(itemPack.itemDefinitionIds.length > 0 && itemPack.itemDefinitionIds.length <= 100, \\\"wrong itemDefinitionIds length\\\");\\n            require(itemPack.itemDefinitionIds.length == itemPack.amounts.length, \\\"wrong amounts length\\\");\\n            require(itemPack.itemDefinitionIds.length == itemPack.weights.length, \\\"wrong weights length\\\");\\n\\n            _slotDefinitions[itemPackDefinitionId].push(itemPacks[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/CharacterEdition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract CharacterEdition is WorldAccess {\\n    struct CharacterEditionRecord {\\n        uint256[] characterDefinitionIds;\\n        uint256[] weights;\\n        uint256[][] itemPackDefinitionIds;\\n    }\\n\\n    // key: characterEditionId, (key: characterDefinitionId, value: CharacterDefinitionId)\\n    mapping(uint256 => CharacterEditionRecord) private _records;\\n    // key: tokenId, value: characterEditionId\\n    mapping(uint256 => uint256) public tokenAndEditions;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function getCharacterEditionRecord(uint256 characterEditionId) public view returns(CharacterEditionRecord memory) {\\n        return _records[characterEditionId];\\n    }\\n\\n    function setCharacterEdition(uint256 characterEditionId, CharacterEditionRecord calldata record) public onlyGame {\\n        _records[characterEditionId] = record;\\n    }\\n\\n    function setTokenIdsToCharacterEdition(uint256 characterEditionId, uint256[] calldata tokenIds) public onlyGame {\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            tokenAndEditions[tokenIds[i]] = characterEditionId;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/Equipment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract Equipment is WorldAccess {\\n    // key: tokenId, value: array of equipped itemId\\n    mapping(uint256 => uint256[]) public equipments;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function getEquipments(uint256 tokenId) public virtual view returns(uint256[] memory) {\\n        return equipments[tokenId];\\n    }\\n\\n    function setEquipments(uint256 tokenId, uint256[] memory itemIds) public virtual onlyGame {\\n        equipments[tokenId] = itemIds;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/ItemStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract ItemStorage is WorldAccess {\\n    // key: tokenId, (key: itemDefinitionId, value: itemCount)\\n    mapping(uint256 => mapping(uint256 => int64)) public items;\\n\\n    // key: tokenId, (key: itemDefinitionId, value: timestamp)\\n    mapping(uint256 => mapping(uint256 => uint256)) public lastAcquisitionTimestamps;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function addItems(uint256 tokenId, uint256[] calldata itemDefinitionIds, int64[] calldata amounts) public virtual onlyGame {\\n        require(itemDefinitionIds.length == amounts.length, \\\"wrong length\\\");\\n\\n        for (uint i; i < itemDefinitionIds.length; i++) {\\n            addItem(tokenId, itemDefinitionIds[i], amounts[i]);\\n        }\\n    }\\n\\n    function addItem(uint256 tokenId, uint256 itemDefinitionId, int64 amount) public virtual onlyGame {\\n        items[tokenId][itemDefinitionId] += amount;\\n        if (amount > 0) {\\n            lastAcquisitionTimestamps[tokenId][itemDefinitionId] = block.timestamp;\\n        }\\n    }\\n\\n    function getItems(uint256 tokenId, uint256[] memory itemDefinitionIds) public virtual view returns(int64[] memory) {\\n        int64[] memory result = new int64[](itemDefinitionIds.length);\\n        for (uint256 i; i < itemDefinitionIds.length; i++) {\\n            result[i] = items[tokenId][itemDefinitionIds[i]];\\n        }\\n\\n        return result;\\n    }\\n\\n    function hasItem(uint256 tokenId, uint256 itemDefinitionId, int64 amount) public virtual view returns(bool) {\\n        return items[tokenId][itemDefinitionId] >= amount;\\n    }\\n\\n    function getLastAcquisitionTimestamps(uint256 tokenId, uint256[] calldata itemDefinitionIds) public virtual view returns(uint256[] memory) {\\n        uint256[] memory result = new uint256[](itemDefinitionIds.length);\\n        for (uint256 i; i < itemDefinitionIds.length; i++) {\\n            result[i] = lastAcquisitionTimestamps[tokenId][itemDefinitionIds[i]];\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/data/EventCheckinLog.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"../access/WorldAccess.sol\\\";\\n\\ncontract EventCheckinLog is WorldAccess {\\n    struct EventCheckinLogRecord {\\n        address playerWallet;\\n        uint256 eventDefinitionId;\\n        uint256 timestamp;\\n    }\\n\\n    uint256 public checkinCount;\\n\\n    // key: eventDefinitionId, value: count\\n    mapping(uint256 => uint256) public checkinCountsPerEvent;\\n\\n    // key: Player Wallet, value: (key: eventDefinitionId, value: count)\\n    mapping(address => mapping(uint256 => uint256)) public checkinCountsPerPlayer;\\n\\n    // key: Player Wallet, value: (key: eventDefinitionId, value: timestamp(sec))\\n    mapping(address => mapping(uint256 => uint256)) public checkinTimeStampPerPlayer;\\n\\n    // key: logId, value: (key: eventDefinitionId, value: timestamp(sec))\\n    mapping(uint256 => EventCheckinLogRecord) public logs;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    WorldAccess(worldId, gameAddress) {\\n    }\\n\\n    function log(address playerWallet, uint256 eventDefinitionId) public onlyGame {\\n        checkinCount++;\\n        checkinCountsPerEvent[eventDefinitionId]++;\\n        checkinCountsPerPlayer[playerWallet][eventDefinitionId]++;\\n        checkinTimeStampPerPlayer[playerWallet][eventDefinitionId] = block.timestamp;\\n\\n        logs[checkinCount] = EventCheckinLogRecord(\\n            playerWallet,\\n            eventDefinitionId,\\n            block.timestamp\\n        );\\n    }\\n\\n    function getLogs(uint256[] calldata logIds) public view returns(EventCheckinLogRecord[] memory) {\\n        EventCheckinLogRecord[] memory records = new EventCheckinLogRecord[](logIds.length);\\n        for (uint256 i; i < logIds.length; i++) {\\n            EventCheckinLogRecord memory record = logs[logIds[i]];\\n            records[i] = EventCheckinLogRecord(\\n                record.playerWallet,\\n                record.eventDefinitionId,\\n                record.timestamp\\n            );\\n        }\\n\\n        return records;\\n    }\\n}\"\r\n    },\r\n    \"contracts/access/WorldAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IGameAccess.sol\\\";\\nimport \\\"./AccessControl.sol\\\";\\n\\ncontract WorldAccess is Ownable, AccessControl {\\n    uint256 internal _worldId;\\n\\n    constructor(uint256 worldId, address gameAddress)\\n    AccessControl(gameAddress) {\\n        _worldId = worldId;\\n    }\\n\\n    modifier onlyGame() {\\n        bool isInternal = checkAccess(msg.sender, _gameAccess.getInterfaceAddresses());\\n        bool isGameAdmin = checkAccess(msg.sender, _gameAccess.getGameAdminAddresses());\\n        bool isWorldOwner = checkAccess(msg.sender, _gameAccess.getWorldOwnerAddresses(_worldId));\\n        bool isItemPackNFT = checkAccess(msg.sender, _gameAccess.getItemPackNFTAddresses(_worldId));\\n        bool isOwner = msg.sender == owner();\\n        bool isGame = msg.sender == address(_gameAccess);\\n\\n        require(isInternal || isGameAdmin || isWorldOwner || isItemPackNFT || isOwner || isGame, \\\"WorldAccess: caller is not Game/Owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyWorldAdmin() {\\n        bool isGameAdmin = checkAccess(msg.sender, _gameAccess.getGameAdminAddresses());\\n        bool isWorldOwner = checkAccess(msg.sender, _gameAccess.getWorldOwnerAddresses(_worldId));\\n        bool isWorldAdmin = checkAccess(msg.sender, _gameAccess.getWorldAdminAddresses(_worldId));\\n        bool isOwner = msg.sender == owner();\\n        bool isGame = msg.sender == address(_gameAccess);\\n\\n        require(isWorldAdmin || isGameAdmin || isWorldOwner || isOwner || isGame, \\\"WorldAccess: caller is not WorldAdmin\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/IGameAccess.sol\\\";\\n\\ncontract AccessControl is Ownable {\\n    IGameAccess internal _gameAccess;\\n\\n    constructor(address gameAddress) {\\n        _gameAccess = IGameAccess(gameAddress);\\n    }\\n\\n    modifier onlyGameOwner() {\\n        bool isGameAdmin = checkAccess(msg.sender, _gameAccess.getGameAdminAddresses());\\n        bool isInternal = checkAccess(msg.sender, _gameAccess.getInterfaceAddresses());\\n        bool isOwner = msg.sender == owner();\\n        bool isGame = msg.sender == address(_gameAccess);\\n\\n        require(isGameAdmin || isInternal || isOwner || isGame, \\\"WorldAccess: caller is not GameOwner\\\");\\n        _;\\n    }\\n\\n    function setGameAddress(address gameAddress) public virtual onlyGameOwner {\\n        _gameAccess = IGameAccess(gameAddress);\\n    }\\n\\n    function checkAccess(address sender, address[] memory addresses) internal view returns(bool) {\\n        bool result = false;\\n        for (uint256 i; i < addresses.length; i++) {\\n            if (addresses[i] == sender) {\\n                result = true;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/IDArrayUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.11;\\n\\nlibrary IDArrayUtil {\\n    function findIndex(uint256[] memory arr, uint256 id) internal pure returns(uint256) {\\n        for (uint256 i = 0; i < arr.length; i++) {\\n            if (arr[i] == id) {\\n                return i;\\n            }\\n        }\\n\\n        revert(\\\"ID not found\\\");\\n    }\\n\\n    function removeById(uint256[] storage arr, uint256 id) internal {\\n        uint256 index = findIndex(arr, id);\\n\\n        remove(arr, index);\\n    }\\n\\n    function remove(uint256[] storage arr, uint256 _index) internal {\\n        require(_index < arr.length, \\\"out of bound\\\");\\n\\n        for (uint256 i = _index; i < arr.length - 1; i++) {\\n            arr[i] = arr[i + 1];\\n        }\\n        arr.pop();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"game\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"}],\"name\":\"Equip\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"itemDefinitionIds\",\"type\":\"uint256[]\"}],\"name\":\"equip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getEquipments\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gameAddress\",\"type\":\"address\"}],\"name\":\"setGameAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"worldId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"itemDefinitionIds\",\"type\":\"uint256[]\"}],\"name\":\"validateEquip\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"validWorldId\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"validTokenId\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"validItemDefinitionIdLength\",\"type\":\"bool\"},{\"internalType\":\"bool[]\",\"name\":\"validSlots\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"validItemDefinitionIds\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"equipableItems\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"validItemCounts\",\"type\":\"bool[]\"}],\"internalType\":\"struct ICharacterEquipment.EquipValidationResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CharacterEquipment", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000017cd61a2b4aba15df88c8a5f26b61f0d2b2e2b8c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}