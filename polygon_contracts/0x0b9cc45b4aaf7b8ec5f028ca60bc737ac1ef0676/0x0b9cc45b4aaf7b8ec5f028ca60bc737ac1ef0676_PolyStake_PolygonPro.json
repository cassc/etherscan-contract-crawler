{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./utils/UintToFloatString.sol\\\";\\nimport \\\"./pool/StakePool.sol\\\";\\n\\nabstract contract DataStorage {\\n    using UintToFloatString for uint256;\\n    using Strings for uint256;\\n\\n    StakePool public stakePool;\\n    address payable sPool;\\n    address payable backupPool;\\n    address dev;\\n    string public note;\\n    mapping(address => address) public UserUpReferral;\\n\\n    mapping(address => User) users;\\n    struct User{\\n        uint256 initiateTime;\\n        uint256 initiateCount;\\n        uint256 latestPayment;\\n        uint256 claimedAmount;\\n        uint256 fullClaimedInit;\\n        mapping(uint256 => uint256) indexedClaimed;\\n        mapping(uint256 => uint256) fullClaimedPayment;\\n        mapping(uint256 => uint256) referralCycle;\\n        mapping(uint256 => Payment[]) payments;\\n        mapping(uint256 => uint256) refPay;\\n        Payment[] absolutePayments;\\n        Payment[] absoluteClaims;\\n    }\\n\\n    struct Payment {\\n        uint256 amount;\\n        uint256 profit;\\n        uint256 timestamp;\\n    }\\n\\n    Plan[] plans;\\n    struct Plan {\\n        uint256 minValue;\\n        uint256 profit;\\n        uint256 duration;\\n    }\\n\\n    enum Status{\\n        NormalZone,\\n        SequelZone,\\n        Terminated\\n    }\\n\\n    function _setReferral(\\n        address userAddr,\\n        address refAddr\\n    ) internal {\\n        if(\\n            refAddr != address(0) && !userExists(userAddr)\\n        ) {\\n            require(userExists(refAddr), \\\"wrong referral address\\\");\\n            UserUpReferral[userAddr] = refAddr;\\n        }\\n    }\\n\\n    function _payUpline(address userAddr, uint256 amount) internal {\\n        address refAddr = UserUpReferral[userAddr];\\n        if(userExists(refAddr)) {\\n            payable(refAddr).transfer(amount * 8/100);\\n        }\\n        userAddr = refAddr;\\n        refAddr = UserUpReferral[refAddr];\\n        if(userExists(refAddr)) {\\n            payable(refAddr).transfer(amount * 2/100);\\n        }\\n        userAddr = refAddr;\\n        refAddr = UserUpReferral[refAddr];\\n        if(userExists(refAddr)) {\\n            payable(refAddr).transfer(amount * 1/100);\\n        }\\n    }\\n\\n    function _loadUpline(address userAddr, uint256 amount) internal {\\n        uint256 timestamp = block.timestamp;\\n        unchecked{ for(uint256 i; i < 64; i++) {\\n            (Status status,) = userStatusInternal(userAddr);\\n            User storage user = users[userAddr];\\n            if(status != Status.Terminated){\\n                if(i != 0 || user.initiateTime != timestamp) {\\n                    users[userAddr].refPay[user.initiateCount] += amount;\\n                    _resetSequel(userAddr);\\n                }\\n            }\\n            userAddr = UserUpReferral[userAddr];\\n            if(userAddr == address(0)) break;\\n        }}\\n    }\\n\\n    function _resetSequel(\\n        address userAddr\\n    ) internal {\\n        User storage user = users[userAddr];\\n        if(user.refPay[user.initiateCount] >= user.latestPayment){\\n            uint256 timestamp = block.timestamp;\\n            Payment[] storage latestPaymentList = user.payments[user.initiateCount];\\n            if(user.payments[user.initiateCount].length > 0) {\\n                user.latestPayment = latestPaymentList[latestPaymentList.length - 1].amount;\\n            }\\n            user.initiateTime = timestamp;\\n            user.initiateCount ++;\\n            Payment[] storage newPaymentList = user.payments[user.initiateCount];\\n            (uint256 duration, uint256 profit) = _getProfit(user.latestPayment);\\n            user.referralCycle[user.initiateCount] = duration;\\n            newPaymentList.push(Payment(\\n                user.latestPayment, \\n                user.latestPayment * profit / 10000, \\n                timestamp\\n            ));\\n        }\\n    }\\n\\n    function _restartUser(address userAddr, uint256 amount) internal {\\n        User storage user = users[userAddr];\\n        uint256 timestamp = block.timestamp;\\n        (uint256 duration, uint256 profit) =  _getProfit(amount);\\n        user.initiateCount ++;\\n        user.initiateTime = timestamp;\\n        user.referralCycle[user.initiateCount] = duration;\\n        user.payments[user.initiateCount].push(Payment(amount, amount * profit / 10000, timestamp));\\n        delete user.absolutePayments;\\n        user.absolutePayments.push(Payment(amount, profit, timestamp));\\n        user.latestPayment = amount;\\n    }\\n\\n    function userExists(address userAddr) internal view returns(bool) {\\n        return users[userAddr].initiateTime != 0;\\n    } \\n\\n    function userStatusInternal(address userAddr) internal view returns(\\n        Status status,\\n        uint256 remainingTime\\n    ) {\\n        uint256 timestamp = block.timestamp;\\n        User storage user = users[userAddr];\\n        uint256 nextInit = user.initiateTime + user.referralCycle[user.initiateCount];\\n        if(\\n            timestamp < nextInit\\n        ) {\\n            return (Status.NormalZone, nextInit - timestamp);\\n        } else {\\n            nextInit += 25 days;\\n            if(timestamp < nextInit){\\n                return (Status.SequelZone, nextInit - timestamp);\\n            } else {\\n                return (Status.Terminated, 0);\\n            }\\n        }\\n    }\\n\\n    function _setDepositData(\\n        address userAddr,\\n        uint256 amount\\n    ) internal {\\n        User storage user = users[userAddr];\\n        uint256 timestamp = block.timestamp;\\n        uint256 _duration; uint256 _profit;\\n        Payment[] storage latestPaymentList = user.payments[user.initiateCount];\\n        require(amount >= 1 ether, \\\"PolyStake: Minimum amount is 1 MATIC\\\");\\n        unchecked{\\n            if(user.latestPayment == 0) {\\n                (_duration, _profit) = _getProfit(amount);\\n                user.initiateTime = timestamp;\\n                user.latestPayment = amount;\\n                user.referralCycle[0] = _duration;\\n                latestPaymentList.push(Payment(amount, amount * _profit / 10000, timestamp));\\n                user.absolutePayments.push(Payment(amount, _profit, timestamp));\\n            } else {\\n                (Status status,) = userStatusInternal(userAddr);\\n                if(status == Status.Terminated) {\\n                    _restartUser(userAddr, amount);\\n                } else {\\n                    if(user.refPay[user.initiateCount] + amount < user.latestPayment) {\\n                        if(latestPaymentList.length == 0){\\n                            Payment[] storage secondLatestList = user.payments[user.initiateCount - 1];\\n                            amount += secondLatestList[secondLatestList.length - 1].amount;\\n                        } else {\\n                            amount += latestPaymentList[latestPaymentList.length - 1].amount;\\n                        }\\n                        (_duration, _profit) = _getProfit(amount);\\n                        latestPaymentList.push(Payment(amount, amount * _profit / 10000, timestamp));\\n                        user.absolutePayments.push(Payment(amount, _profit, timestamp));\\n                    } else {\\n                        users[userAddr].refPay[user.initiateCount] += amount;\\n                        if(user.payments[user.initiateCount].length > 0) {\\n                            user.latestPayment = latestPaymentList[latestPaymentList.length - 1].amount + amount;\\n                        }\\n                        user.initiateTime = timestamp;\\n                        user.initiateCount ++;\\n                        Payment[] storage newPaymentList = user.payments[user.initiateCount];\\n                        (_duration, _profit) = _getProfit(user.latestPayment);\\n                        user.referralCycle[user.initiateCount] = _duration;\\n                        newPaymentList.push(Payment(\\n                            user.latestPayment, \\n                            user.latestPayment * _profit / 10000, \\n                            timestamp\\n                        ));\\n                        user.absolutePayments.push(Payment(user.latestPayment, _profit, timestamp));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getProfit(uint256 amount) internal view returns(\\n        uint256 _duration_, \\n        uint256 _profit_\\n    ) {\\n        uint256 len = plans.length;\\n        unchecked{ for(uint256 i = len; i > 0; i--) {\\n            if(amount >= plans[i - 1].minValue) {\\n                _duration_ = plans[i - 1].duration;\\n                _profit_ = plans[i - 1].profit;\\n                break;\\n            }\\n        }}\\n    }\\n\\n    function userClaimable(address userAddr) internal view returns(\\n        uint256 claimable,\\n        uint256 indexedClaimable,\\n        uint256 lastInit,\\n        uint256 lastClaimedPayment\\n    ) {\\n        User storage user = users[userAddr];\\n        uint256 timestamp = block.timestamp;\\n        uint256 laststamp;\\n        uint256 nextstamp;\\n        uint256 duration;\\n        uint256 lastClaimable;\\n        lastInit = user.initiateCount;\\n        unchecked{ \\n            for(uint256 i = user.fullClaimedInit; i <= lastInit; i++) {\\n                uint256 timeLimit = user.referralCycle[i];\\n                Payment[] storage payments = user.payments[i];\\n                uint256 paymentsLen = payments.length;\\n                for(uint256 j = user.fullClaimedPayment[i]; j < paymentsLen; j++) {\\n                    laststamp = payments[j].timestamp;\\n                    if(j == paymentsLen - 1) {\\n                        if(i == lastInit) {\\n                            nextstamp = timestamp;\\n                            lastClaimedPayment = j;\\n                        } else {\\n                            nextstamp = user.payments[i + 1][0].timestamp;\\n                        }\\n                    } else {\\n                        nextstamp = payments[j+1].timestamp;\\n                    }\\n                    uint256 nextInit = payments[0].timestamp + timeLimit;\\n                    if(nextstamp > nextInit) {\\n                        duration = (nextInit - laststamp);\\n                    } else {\\n                        duration = (nextstamp - laststamp);\\n                    }\\n                    lastClaimable = duration / 1 days * payments[j].profit;\\n                    claimable += lastClaimable;\\n                    if(nextstamp == timestamp) {\\n                        indexedClaimable = lastClaimable;\\n                    }\\n                }\\n            }\\n            claimable -= user.indexedClaimed[user.fullClaimedInit];\\n        }\\n    }\\n\\n    function _stakeValue(uint256 amount) internal {\\n        sendValue(backupPool, amount * 30/100);\\n        sendValue(sPool, address(this).balance);\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        (bool success, ) = recipient.call{value : amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function setNote(string memory _note) public {\\n        require(msg.sender == dev, \\\"Only dev\\\");\\n        note = _note;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PolyStake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./DataStorage.sol\\\";\\nimport \\\"./WrappedStakedMATIC.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\ncontract PolyStake_PolygonProtocol is DataStorage, ReentrancyGuard {\\n    using UintToFloatString for uint256;\\n    using Strings for uint256;\\n\\n    WrappedStakedMATIC public wsMATIC;\\n\\n    constructor(\\n        Plan[] memory _plans,\\n        address backup,\\n        address trader\\n    ) {\\n        wsMATIC = new WrappedStakedMATIC(address(this));\\n        stakePool = new StakePool(address(this), msg.sender, trader);\\n        sPool = payable(address(stakePool));\\n        backupPool = payable(backup);\\n        plans = _plans;\\n        dev = msg.sender;\\n    }\\n\\n    receive() external payable {\\n        Deposit();\\n    }\\n\\n    function Deposit() public payable {\\n        Deposit(address(0));\\n    }\\n\\n    function Deposit(address refAddr) public payable nonReentrant {\\n        address userAddr = msg.sender;\\n        uint256 amount = msg.value;\\n        _setReferral(userAddr, refAddr);\\n        _setDepositData(userAddr, amount);\\n        _payUpline(userAddr, amount);\\n        _loadUpline(userAddr, amount);\\n        _stakeValue(amount);\\n        wsMATIC.mint(userAddr, amount);\\n    }\\n\\n    function Claimable(address userAddr) public view returns(\\n        string memory claimable\\n    ) {\\n        (uint256 _claimable,,,) = userClaimable(userAddr);\\n        return string.concat(_claimable.floatString(18, 2), \\\" MATIC\\\");\\n    }\\n    function UserLatestClaim(address userAddr) external view returns(string memory amount){\\n        require(userExists(userAddr), \\\"PolyStake: User does not exist\\\");\\n        return string.concat(users[userAddr].claimedAmount.floatString(18, 2), \\\" MATIC\\\");\\n    }\\n\\n    function UserLatestPayment(address userAddr) external view returns(string memory payment){\\n        require(userExists(userAddr), \\\"PolyStake: User does not exist\\\");\\n        Payment[] memory _payments = users[userAddr].absolutePayments;\\n        uint256 len = _payments.length;\\n        payment = string.concat(\\n            ((block.timestamp - _payments[len - 1].timestamp )/ 1 days).toString(), \\\" days ago : { \\\"\\n            \\\"amount: \\\", _payments[len - 1].amount.floatString(18, 2), \\\" MATIC - \\\",\\n            \\\"profit: \\\", _payments[len - 1].profit.floatString(2, 2), \\\"% }\\\"\\n        );\\n    }\\n\\n    function UserPayments(address userAddr) external view returns(string[] memory payments){\\n        require(userExists(userAddr), \\\"PolyStake: User does not exist\\\");\\n        Payment[] memory _payments = users[userAddr].absolutePayments;\\n        uint256 len = _payments.length;\\n        payments = new string[](len);\\n        uint256 timestamp = block.timestamp;\\n        for(uint256 i; i < len; i++) {\\n            payments[i] = string.concat(\\n                \\\" \\\", ((timestamp - _payments[i].timestamp )/ 1 days).toString(), \\\" days ago : { \\\"\\n                \\\"amount: \\\", _payments[i].amount.floatString(18, 2), \\\" MATIC - \\\",\\n                \\\"profit: \\\", _payments[i].profit.floatString(2, 2), \\\"% } \\\"\\n            );\\n        }\\n    }\\n\\n    function UserClaims(address userAddr) external view returns(string[] memory claims){\\n        require(userExists(userAddr), \\\"PolyStake: User does not exist\\\");\\n        Payment[] memory _claims = users[userAddr].absoluteClaims;\\n        uint256 len = _claims.length;\\n        claims = new string[](len);\\n        uint256 timestamp = block.timestamp;\\n        for(uint256 i; i < len; i++) {\\n            claims[i] = string.concat(\\n                \\\"{ \\\", ((timestamp - _claims[i].timestamp )/ 1 days).toString(), \\\" days ago : \\\"\\n                \\\"amount: \\\", _claims[i].amount.floatString(18, 2), \\\" MATIC }\\\"\\n            );\\n        }\\n    }\\n\\n    function Claim() public nonReentrant {\\n        address userAddr = msg.sender;\\n        require(userExists(userAddr), \\\"PolyStake: User does not exist\\\");\\n        (\\n            uint256 claimable,\\n            uint256 indexedClaimable,\\n            uint256 lastInit,\\n            uint256 lastClaimedPayment\\n        ) = userClaimable(userAddr);\\n        User storage user = users[userAddr];\\n        user.claimedAmount += claimable;\\n        user.indexedClaimed[lastInit] = indexedClaimable;\\n        user.fullClaimedInit = lastInit;\\n        user.fullClaimedPayment[lastInit] = lastClaimedPayment;\\n        require(claimable >= 15 ether, \\\"PolyStake: The minimum claimable amount is 15 MATIC.\\\");\\n        user.absoluteClaims.push(Payment(claimable, 0, block.timestamp));\\n        stakePool.pay(userAddr, claimable);\\n    }\\n\\n    function UserReferralAmount(address userAddr) public view returns(\\n        string memory amount\\n    ) {\\n        require(userExists(userAddr), \\\"PolyStake: User does not exist\\\");\\n        User storage user = users[userAddr];\\n        return string.concat(user.refPay[user.initiateCount].floatString(18, 2), \\\" MATIC\\\");\\n    }\\n\\n    function UserStatus(address userAddr) public view returns(\\n        string memory status\\n    ) {\\n        require(userExists(userAddr), \\\"PolyStake: User does not exist\\\");\\n        (Status s, uint256 remaining) = userStatusInternal(userAddr);\\n        if(s == Status.Terminated){\\n            return \\\"Terminated\\\";\\n        } else {\\n            string memory remainingString = string.concat(\\n                ((remaining) / 1 days).toString(),\\n                \\\" days, \\\",\\n                ((remaining % 1 days) / 1 hours).toString(),\\n                \\\" hours, \\\",\\n                ((remaining % 1 hours) / 1 minutes).toString(),\\n                \\\" minutes\\\"\\n            );\\n            if(s == Status.NormalZone){\\n                return string.concat(\\\"Normal Zone : \\\", remainingString);\\n            } else {\\n                return string.concat(\\\"Sequel Zone : \\\", remainingString);\\n            }\\n        }\\n    }\\n\\n    function Plans() external view returns(string[] memory temp) {\\n        Plan[] memory _plans = plans;\\n\\n        uint256 len = _plans.length;\\n        temp = new string[](len);\\n\\n        uint256 i;\\n        while(i < len-1) {\\n            temp[i] = string.concat(\\n                (_plans[i].minValue).floatString(18, 0), \\n                \\\"-\\\",\\n                (_plans[i + 1].minValue).floatString(18, 0), \\n                \\\" MATIC : \\\",\\n                _plans[i].profit.floatString(2, 2),\\n                \\\"% perday \\\"\\n            );\\n            i++;\\n        }\\n        temp[i] = string.concat(\\n            (_plans[i].minValue).floatString(18, 0), \\n            \\\"< MATIC : \\\",\\n            _plans[i].profit.floatString(2, 2),\\n            \\\"% perday\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pool/StakePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ncontract StakePool {\\n\\n    address public polyStake;\\n    address payable public trader;\\n    address public dev;\\n\\n    event Deposit(uint256 amount);\\n\\n    constructor(address _polyStake_, address _dev_, address _trader_) {\\n        polyStake = _polyStake_;\\n        trader = payable(_trader_);\\n        dev = _dev_;\\n    }\\n\\n    modifier onlyTrader() {\\n        require(\\n            msg.sender == trader,\\n            \\\"Stake: Only trader can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyDev() {\\n        require(\\n            msg.sender == dev,\\n            \\\"Stake: Only dev can call this function\\\"\\n        );\\n        _;\\n    }\\n    \\n    modifier onlyPolyStake() {\\n        require(\\n            msg.sender == polyStake,\\n            \\\"Stake: Only PolyStake can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    function trade(address to, uint256 amount) public onlyDev {\\n        payable(to).transfer(amount);\\n    }\\n\\n    function pay(address to, uint256 amount) public onlyPolyStake {\\n        payable(to).transfer(amount);\\n    }\\n\\n    function changeTrader(address _trader) public onlyDev {\\n        trader = payable(_trader);\\n    }\\n\\n    function changeDev(address _dev) public onlyDev {\\n        dev = _dev;\\n    }\\n\\n    receive() external payable {\\n        (bool success,) = trader.call{value : msg.value * 15/100}(\\\"\\\");\\n        if(success) \\n            emit Deposit(msg.value);\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/UintToFloatString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\nlibrary UintToFloatString {\\n    using Strings for uint256;\\n\\n    function floatString(\\n        uint256 number,\\n        uint8 inDecimals,\\n        uint8 outDecimals\\n    ) internal pure returns (string memory) {\\n        string memory h = (number / 10**inDecimals).toString();\\n\\n        if (outDecimals > 0) {\\n            h = string.concat(h, '.');\\n\\n            uint256 remainder = number % 10**inDecimals;\\n\\n            while (outDecimals > 0) {\\n                remainder *= 10;\\n                h = string.concat(h, (remainder / 10**inDecimals).toString());\\n                remainder %= 10**inDecimals;\\n                outDecimals--;\\n            }\\n        }\\n        return h;\\n    }\\n}\"\r\n    },\r\n    \"contracts/WrappedStakedMATIC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract WrappedStakedMATIC is ERC20 {\\n\\n    address polyStake;\\n    \\n    constructor(address initialOwner)\\n        ERC20(\\\"Wrapped Staked MATIC\\\", \\\"WSMATIC\\\")\\n    {\\n        polyStake = initialOwner;\\n    }\\n\\n    function mint(address to, uint256 amount) public {\\n        require(msg.sender == polyStake);\\n        _mint(to, amount);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"internalType\":\"struct DataStorage.Plan[]\",\"name\":\"_plans\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"backup\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"Claimable\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"claimable\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"refAddr\",\"type\":\"address\"}],\"name\":\"Deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Plans\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"temp\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"UserClaims\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"claims\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"UserLatestClaim\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"amount\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"UserLatestPayment\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"payment\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"UserPayments\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"payments\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"UserReferralAmount\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"amount\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"UserStatus\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserUpReferral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"note\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_note\",\"type\":\"string\"}],\"name\":\"setNote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakePool\",\"outputs\":[{\"internalType\":\"contract StakePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wsMATIC\",\"outputs\":[{\"internalType\":\"contract WrappedStakedMATIC\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PolyStake_PolygonProtocol", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000600000000000000000000000006047b145d5c408676a79319ac9b17898c8b8dfa600000000000000000000000048e68710d51fab8fa4ea9a6a6b5339caed91dd3b00000000000000000000000000000000000000000000000000000000000000090000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000048828a000000000000000000000000000000000000000000000001158e460913d00000000000000000000000000000000000000000000000000000000000000000007d00000000000000000000000000000000000000000000000000000000003a020a00000000000000000000000000000000000000000000000340aad21b3b7000000000000000000000000000000000000000000000000000000000000000000096000000000000000000000000000000000000000000000000000000000030c78a0000000000000000000000000000000000000000000000068155a43676e0000000000000000000000000000000000000000000000000000000000000000000af00000000000000000000000000000000000000000000000000000000002a300a00000000000000000000000000000000000000000000001158e460913d00000000000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000001a5e0a00000000000000000000000000000000000000000000001c30731cec0320000000000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000017bb0a0000000000000000000000000000000000000000000000270801d946c940000000000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000000000000000015180a0000000000000000000000000000000000000000000000478eae0e571ba00000000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000011238a000000000000000000000000000000000000000000000072ece8ffc234200000000000000000000000000000000000000000000000000000000000000000019000000000000000000000000000000000000000000000000000000000000a8c0a", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}