{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarGasService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport './IUpgradable.sol';\\n\\n// This should be owned by the microservice that is paying for gas.\\ninterface IAxelarGasService is IUpgradable {\\n    error NothingReceived();\\n    error TransferFailed();\\n    error InvalidAddress();\\n\\n    event GasPaidForContractCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForContractCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForContractCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForContractCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasAdded(bytes32 indexed txHash, uint256 indexed logIndex, address gasToken, uint256 gasFeeAmount, address refundAddress);\\n\\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\\n\\n    // This is called on the source chain before calling the gateway to execute a remote contract.\\n    function payGasForContractCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    // This is called on the source chain before calling the gateway to execute a remote contract.\\n    function payGasForContractCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    // This is called on the source chain before calling the gateway to execute a remote contract.\\n    function payNativeGasForContractCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundAddress\\n    ) external payable;\\n\\n    // This is called on the source chain before calling the gateway to execute a remote contract.\\n    function payNativeGasForContractCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address refundAddress\\n    ) external payable;\\n\\n    function addGas(\\n        bytes32 txHash,\\n        uint256 txIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    function addNativeGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address refundAddress\\n    ) external payable;\\n\\n    function collectFees(address payable receiver, address[] calldata tokens) external;\\n\\n    function refund(\\n        address payable receiver,\\n        address token,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IUpgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\n// General interface for upgradable contracts\\ninterface IUpgradable {\\n    error NotOwner();\\n    error InvalidOwner();\\n    error InvalidCodeHash();\\n    error InvalidImplementation();\\n    error SetupFailed();\\n    error NotProxy();\\n\\n    event Upgraded(address indexed newImplementation);\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    // Get current owner\\n    function owner() external view returns (address);\\n\\n    function contractId() external pure returns (bytes32);\\n\\n    function implementation() external view returns (address);\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external;\\n\\n    function setup(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/executables/AxelarForecallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\\nimport { IERC20 } from '../interfaces/IERC20.sol';\\nimport { IAxelarForecallable } from '../interfaces/IAxelarForecallable.sol';\\n\\ncontract AxelarForecallable is IAxelarForecallable {\\n    IAxelarGateway public immutable gateway;\\n\\n    //keccak256('forecallers');\\n    uint256 public constant FORECALLERS_SALT = 0xdb79ee324babd8834c3c1a1a2739c004fce73b812ac9f637241ff47b19e4b71f;\\n\\n    constructor(address gateway_) {\\n        if (gateway_ == address(0)) revert InvalidAddress();\\n\\n        gateway = IAxelarGateway(gateway_);\\n    }\\n\\n    function getForecaller(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) public view override returns (address forecaller) {\\n        bytes32 pos = keccak256(abi.encode(sourceChain, sourceAddress, payload, FORECALLERS_SALT));\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            forecaller := sload(pos)\\n        }\\n    }\\n\\n    function _setForecaller(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        address forecaller\\n    ) internal {\\n        bytes32 pos = keccak256(abi.encode(sourceChain, sourceAddress, payload, FORECALLERS_SALT));\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(pos, forecaller)\\n        }\\n    }\\n\\n    function forecall(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external {\\n        _checkForecall(sourceChain, sourceAddress, payload, msg.sender);\\n        if (getForecaller(sourceChain, sourceAddress, payload) != address(0)) revert AlreadyForecalled();\\n        _setForecaller(sourceChain, sourceAddress, payload, msg.sender);\\n        _execute(sourceChain, sourceAddress, payload);\\n    }\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external override {\\n        bytes32 payloadHash = keccak256(payload);\\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\\n            revert NotApprovedByGateway();\\n        address forecaller = getForecaller(sourceChain, sourceAddress, payload);\\n        if (forecaller != address(0)) {\\n            _setForecaller(sourceChain, sourceAddress, payload, address(0));\\n        } else {\\n            _execute(sourceChain, sourceAddress, payload);\\n        }\\n    }\\n\\n    function getForecallerWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) public view override returns (address forecaller) {\\n        bytes32 pos = keccak256(abi.encode(sourceChain, sourceAddress, payload, symbol, amount, FORECALLERS_SALT));\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            forecaller := sload(pos)\\n        }\\n    }\\n\\n    function _setForecallerWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address forecaller\\n    ) internal {\\n        bytes32 pos = keccak256(abi.encode(sourceChain, sourceAddress, payload, symbol, amount, FORECALLERS_SALT));\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(pos, forecaller)\\n        }\\n    }\\n\\n    function forecallWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external override {\\n        address token = gateway.tokenAddresses(tokenSymbol);\\n        uint256 amountPost = amountPostFee(amount, payload);\\n        _safeTransferFrom(token, msg.sender, amountPost);\\n        _checkForecallWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount, msg.sender);\\n        if (getForecallerWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount) != address(0))\\n            revert AlreadyForecalled();\\n        _setForecallerWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount, msg.sender);\\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amountPost);\\n    }\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external override {\\n        bytes32 payloadHash = keccak256(payload);\\n        if (\\n            !gateway.validateContractCallAndMint(\\n                commandId,\\n                sourceChain,\\n                sourceAddress,\\n                payloadHash,\\n                tokenSymbol,\\n                amount\\n            )\\n        ) revert NotApprovedByGateway();\\n        address forecaller = getForecallerWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\\n        if (forecaller != address(0)) {\\n            _setForecallerWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount, address(0));\\n            address token = gateway.tokenAddresses(tokenSymbol);\\n            _safeTransfer(token, forecaller, amount);\\n        } else {\\n            _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\\n        }\\n    }\\n\\n    function _execute(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) internal virtual {}\\n\\n    function _executeWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    // Override this to keep a fee.\\n    function amountPostFee(\\n        uint256 amount,\\n        bytes calldata /*payload*/\\n    ) public virtual override returns (uint256) {\\n        return amount;\\n    }\\n\\n    // Override this and revert if you want to only allow certain people/calls to be able to forecall.\\n    function _checkForecall(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        address forecaller\\n    ) internal virtual {}\\n\\n    // Override this and revert if you want to only allow certain people/calls to be able to forecall.\\n    function _checkForecallWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount,\\n        address forecaller\\n    ) internal virtual {}\\n\\n    function _safeTransfer(\\n        address tokenAddress,\\n        address receiver,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory returnData) = tokenAddress.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n\\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\\n    }\\n\\n    function _safeTransferFrom(\\n        address tokenAddress,\\n        address from,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory returnData) = tokenAddress.call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n\\n        if (!transferred || tokenAddress.code.length == 0) revert TransferFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\\n\\ninterface IAxelarExecutable {\\n    error InvalidAddress();\\n    error NotApprovedByGateway();\\n\\n    function gateway() external view returns (IAxelarGateway);\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarForecallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\\n\\ninterface IAxelarForecallable is IAxelarExecutable {\\n    error AlreadyForecalled();\\n    error TransferFailed();\\n\\n    function forecall(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function forecallWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external;\\n\\n    function getForecaller(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external returns (address forecaller);\\n\\n    function getForecallerWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external returns (address forecaller);\\n\\n    function amountPostFee(uint256 amount, bytes calldata payload) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAxelarGateway {\\n    /**********\\\\\\n    |* Errors *|\\n    \\\\**********/\\n\\n    error NotSelf();\\n    error NotProxy();\\n    error InvalidCodeHash();\\n    error SetupFailed();\\n    error InvalidAuthModule();\\n    error InvalidTokenDeployer();\\n    error InvalidAmount();\\n    error InvalidChainId();\\n    error InvalidCommands();\\n    error TokenDoesNotExist(string symbol);\\n    error TokenAlreadyExists(string symbol);\\n    error TokenDeployFailed(string symbol);\\n    error TokenContractDoesNotExist(address token);\\n    error BurnFailed(string symbol);\\n    error MintFailed(string symbol);\\n    error InvalidSetMintLimitsParams();\\n    error ExceedMintLimit(string symbol);\\n\\n    /**********\\\\\\n    |* Events *|\\n    \\\\**********/\\n\\n    event TokenSent(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationAddress,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event ContractCall(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload\\n    );\\n\\n    event ContractCallWithToken(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event Executed(bytes32 indexed commandId);\\n\\n    event TokenDeployed(string symbol, address tokenAddresses);\\n\\n    event ContractCallApproved(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallApprovedWithMint(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\\n\\n    event OperatorshipTransferred(bytes newOperatorsData);\\n\\n    event Upgraded(address indexed implementation);\\n\\n    /********************\\\\\\n    |* Public Functions *|\\n    \\\\********************/\\n\\n    function sendToken(\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function callContract(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function callContractWithToken(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function isContractCallApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash\\n    ) external view returns (bool);\\n\\n    function isContractCallAndMintApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function validateContractCall(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) external returns (bool);\\n\\n    function validateContractCallAndMint(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /***********\\\\\\n    |* Getters *|\\n    \\\\***********/\\n\\n    function authModule() external view returns (address);\\n\\n    function tokenDeployer() external view returns (address);\\n\\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\\n\\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\\n\\n    function allTokensFrozen() external view returns (bool);\\n\\n    function implementation() external view returns (address);\\n\\n    function tokenAddresses(string memory symbol) external view returns (address);\\n\\n    function tokenFrozen(string memory symbol) external view returns (bool);\\n\\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\\n\\n    function adminEpoch() external view returns (uint256);\\n\\n    function adminThreshold(uint256 epoch) external view returns (uint256);\\n\\n    function admins(uint256 epoch) external view returns (address[] memory);\\n\\n    /*******************\\\\\\n    |* Admin Functions *|\\n    \\\\*******************/\\n\\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata setupParams\\n    ) external;\\n\\n    /**********************\\\\\\n    |* External Functions *|\\n    \\\\**********************/\\n\\n    function setup(bytes calldata params) external;\\n\\n    function execute(bytes calldata input) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    error InvalidAccount();\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// General interface for upgradable contracts\\ninterface IUpgradable {\\n    error NotOwner();\\n    error InvalidOwner();\\n    error InvalidCodeHash();\\n    error InvalidImplementation();\\n    error SetupFailed();\\n    error NotProxy();\\n\\n    event Upgraded(address indexed newImplementation);\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    // Get current owner\\n    function owner() external view returns (address);\\n\\n    function contractId() external pure returns (bytes32);\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external;\\n\\n    function setup(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/StringAddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary StringToAddress {\\n    function toAddress(string memory _a) internal pure returns (address) {\\n        bytes memory tmp = bytes(_a);\\n        if (tmp.length != 42) return address(0);\\n        uint160 iaddr = 0;\\n        uint8 b;\\n        for (uint256 i = 2; i < 42; i++) {\\n            b = uint8(tmp[i]);\\n            if ((b >= 97) && (b <= 102)) b -= 87;\\n            else if ((b >= 65) && (b <= 70)) b -= 55;\\n            else if ((b >= 48) && (b <= 57)) b -= 48;\\n            else return address(0);\\n            iaddr |= uint160(uint256(b) << ((41 - i) << 2));\\n        }\\n        return address(iaddr);\\n    }\\n}\\n\\nlibrary AddressToString {\\n    function toString(address a) internal pure returns (string memory) {\\n        bytes memory data = abi.encodePacked(a);\\n        bytes memory characters = '0123456789abcdef';\\n        bytes memory byteString = new bytes(2 + data.length * 2);\\n\\n        byteString[0] = '0';\\n        byteString[1] = 'x';\\n\\n        for (uint256 i; i < data.length; ++i) {\\n            byteString[2 + i * 2] = characters[uint256(uint8(data[i] >> 4))];\\n            byteString[3 + i * 2] = characters[uint256(uint8(data[i] & 0x0f))];\\n        }\\n        return string(byteString);\\n    }\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IUpgradable } from '../interfaces/IUpgradable.sol';\\n\\ncontract Proxy {\\n    error InvalidImplementation();\\n    error SetupFailed();\\n    error EtherNotAccepted();\\n    error NotOwner();\\n    error AlreadyInitialized();\\n\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n    // keccak256('owner')\\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\\n\\n    constructor() {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_OWNER_SLOT, caller())\\n        }\\n    }\\n\\n    function init(\\n        address implementationAddress,\\n        address newOwner,\\n        bytes memory params\\n    ) external {\\n        address owner;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            owner := sload(_OWNER_SLOT)\\n        }\\n        if (msg.sender != owner) revert NotOwner();\\n        if (implementation() != address(0)) revert AlreadyInitialized();\\n        if (IUpgradable(implementationAddress).contractId() != contractId()) revert InvalidImplementation();\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, implementationAddress)\\n            sstore(_OWNER_SLOT, newOwner)\\n        }\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = implementationAddress.delegatecall(\\n            //0x9ded06df is the setup selector.\\n            abi.encodeWithSelector(0x9ded06df, params)\\n        );\\n        if (!success) revert SetupFailed();\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function contractId() internal pure virtual returns (bytes32) {}\\n\\n    function implementation() public view returns (address implementation_) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            implementation_ := sload(_IMPLEMENTATION_SLOT)\\n        }\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function setup(bytes calldata data) public {}\\n\\n    // solhint-disable-next-line no-complex-fallback\\n    fallback() external payable {\\n        address implementaion_ = implementation();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n\\n            let result := delegatecall(gas(), implementaion_, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    receive() external payable virtual {\\n        revert EtherNotAccepted();\\n    }\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Upgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '../interfaces/IUpgradable.sol';\\n\\nabstract contract Upgradable is IUpgradable {\\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n    // keccak256('owner')\\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\\n\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) revert NotOwner();\\n        _;\\n    }\\n\\n    function owner() public view returns (address owner_) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            owner_ := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        if (newOwner == address(0)) revert InvalidOwner();\\n\\n        emit OwnershipTransferred(newOwner);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_OWNER_SLOT, newOwner)\\n        }\\n    }\\n\\n    function implementation() public view returns (address implementation_) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            implementation_ := sload(_IMPLEMENTATION_SLOT)\\n        }\\n    }\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external override onlyOwner {\\n        if (IUpgradable(newImplementation).contractId() != IUpgradable(this).contractId())\\n            revert InvalidImplementation();\\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\\n\\n        if (params.length > 0) {\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(this.setup.selector, params));\\n\\n            if (!success) revert SetupFailed();\\n        }\\n\\n        emit Upgraded(newImplementation);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\\n        }\\n    }\\n\\n    function setup(bytes calldata data) external override {\\n        // Prevent setup from being called on the implementation\\n        if (implementation() == address(0)) revert NotProxy();\\n\\n        _setup(data);\\n    }\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function _setup(bytes calldata data) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\r\\n\\r\\ninterface IPangolinRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WAVAX() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityAVAX(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountAVAXMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountAVAX, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityAVAX(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountAVAXMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountAVAX);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityAVAXWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountAVAXMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountAVAX);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactAVAXForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactAVAX(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForAVAX(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapAVAXForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n\\r\\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountAVAXMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountAVAX);\\r\\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountAVAXMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountAVAX);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/hardhat-dependency-compiler/@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >0.0.0;\\nimport '@pangolindex/exchange-contracts/contracts/pangolin-periphery/interfaces/IPangolinRouter.sol';\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoledPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IRoledPausable {\\n    event PauserProposed(address indexed currentPauser, address indexed pendingPauser);\\n    event PauserUpdated(address indexed pendingPauser);\\n    event Paused();\\n    event Unpaused();\\n\\n    error ContractIsPaused();\\n    error NotPauser();\\n    error NotPendingPauser();\\n\\n    function updatePauser(address _newPauser) external;\\n\\n    function acceptPauser() external;\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    function paused() external view returns (bool value);\\n\\n    function pauser() external view returns (address value);\\n\\n    function pendingPauser() external view returns (address value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISquidFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ISquidFeeCollector {\\n    event FeeCollected(address token, address integrator, uint256 squidFee, uint256 integratorFee);\\n    event FeeWithdrawn(address token, address account, uint256 amount);\\n\\n    error TransferFailed();\\n    error ExcessiveIntegratorFee();\\n\\n    function collectFee(\\n        address token,\\n        uint256 amountToTax,\\n        address integratorAddress,\\n        uint256 integratorFee\\n    ) external;\\n\\n    function withdrawFee(address token) external;\\n\\n    function getBalance(address token, address account) external view returns (uint256 accountBalance);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISquidMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ISquidMulticall {\\n    enum CallType {\\n        Default,\\n        FullTokenBalance,\\n        FullNativeBalance,\\n        CollectTokenBalance\\n    }\\n\\n    struct Call {\\n        CallType callType;\\n        address target;\\n        uint256 value;\\n        bytes callData;\\n        bytes payload;\\n    }\\n\\n    error AlreadyRunning();\\n    error CallFailed(uint256 callPosition, bytes reason);\\n\\n    function run(Call[] calldata calls) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISquidRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ISquidMulticall} from \\\"./ISquidMulticall.sol\\\";\\n\\ninterface ISquidRouter {\\n    event CrossMulticallExecuted(bytes32 indexed payloadHash);\\n    event CrossMulticallFailed(bytes32 indexed payloadHash, bytes reason, address indexed refundRecipient);\\n\\n    function bridgeCall(\\n        string calldata destinationChain,\\n        string calldata bridgedTokenSymbol,\\n        uint256 amount,\\n        ISquidMulticall.Call[] calldata calls,\\n        address refundRecipient,\\n        bool forecallEnabled\\n    ) external payable;\\n\\n    function callBridge(\\n        address token,\\n        uint256 amount,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        string calldata bridgedTokenSymbol,\\n        ISquidMulticall.Call[] calldata calls\\n    ) external payable;\\n\\n    function callBridgeCall(\\n        address token,\\n        uint256 amount,\\n        string calldata destinationChain,\\n        string calldata bridgedTokenSymbol,\\n        ISquidMulticall.Call[] calldata sourceCalls,\\n        ISquidMulticall.Call[] calldata destinationCalls,\\n        address refundRecipient,\\n        bool forecallEnabled\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary StorageSlot {\\n    function setUint256(bytes32 slot, uint256 value) internal {\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function getUint256(bytes32 slot) internal view returns (uint256 value) {\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function setAddress(bytes32 slot, address value) internal {\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function getAddress(bytes32 slot) internal view returns (address value) {\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function setBool(bytes32 slot, bool value) internal {\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n\\n    function getBool(bytes32 slot) internal view returns (bool value) {\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RoledPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IRoledPausable} from \\\"./interfaces/IRoledPausable.sol\\\";\\nimport {StorageSlot} from \\\"./libraries/StorageSlot.sol\\\";\\n\\nabstract contract RoledPausable is IRoledPausable {\\n    using StorageSlot for bytes32;\\n\\n    bytes32 internal constant PAUSED_SLOT = keccak256(\\\"RoledPausable.paused\\\");\\n    bytes32 internal constant PAUSER_SLOT = keccak256(\\\"RoledPausable.pauser\\\");\\n    bytes32 internal constant PENDING_PAUSER_SLOT = keccak256(\\\"RoledPausable.pendingPauser\\\");\\n\\n    modifier whenNotPaused() {\\n        if (paused()) revert ContractIsPaused();\\n        _;\\n    }\\n\\n    modifier onlyPauser() {\\n        if (msg.sender != pauser()) revert NotPauser();\\n        _;\\n    }\\n\\n    constructor() {\\n        _setPauser(msg.sender);\\n    }\\n\\n    function updatePauser(address newPauser) external onlyPauser {\\n        PENDING_PAUSER_SLOT.setAddress(newPauser);\\n        emit PauserProposed(msg.sender, newPauser);\\n    }\\n\\n    function acceptPauser() external {\\n        if (msg.sender != pendingPauser()) revert NotPendingPauser();\\n        _setPauser(msg.sender);\\n        PENDING_PAUSER_SLOT.setAddress(address(0));\\n    }\\n\\n    function pause() external virtual onlyPauser {\\n        PAUSED_SLOT.setBool(true);\\n        emit Paused();\\n    }\\n\\n    function unpause() external virtual onlyPauser {\\n        PAUSED_SLOT.setBool(false);\\n        emit Unpaused();\\n    }\\n\\n    function pauser() public view returns (address value) {\\n        value = PAUSER_SLOT.getAddress();\\n    }\\n\\n    function paused() public view returns (bool value) {\\n        value = PAUSED_SLOT.getBool();\\n    }\\n\\n    function pendingPauser() public view returns (address value) {\\n        value = PENDING_PAUSER_SLOT.getAddress();\\n    }\\n\\n    function _setPauser(address _pauser) internal {\\n        PAUSER_SLOT.setAddress(_pauser);\\n        emit PauserUpdated(_pauser);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SquidFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {Upgradable} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Upgradable.sol\\\";\\nimport {ISquidFeeCollector} from \\\"./interfaces/ISquidFeeCollector.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract SquidFeeCollector is ISquidFeeCollector, Upgradable {\\n    bytes32 private constant BALANCES_PREFIX = keccak256(\\\"SquidFeeCollector.balances\\\");\\n    bytes32 private constant SPECIFIC_FEES_PREFIX = keccak256(\\\"SquidFeeCollector.specificFees\\\");\\n    address public immutable squidTeam;\\n    // Value expected with 2 decimals\\n    /// eg. 825 is 8.25%\\n    uint256 public immutable squidDefaultFee;\\n\\n    error ZeroAddressProvided();\\n\\n    constructor(address _squidTeam, uint256 _squidDefaultFee) {\\n        if (_squidTeam == address(0)) revert ZeroAddressProvided();\\n\\n        squidTeam = _squidTeam;\\n        squidDefaultFee = _squidDefaultFee;\\n    }\\n\\n    /// @param integratorFee Value expected with 2 decimals\\n    /// eg. 825 is 8.25%\\n    function collectFee(\\n        address token,\\n        uint256 amountToTax,\\n        address integratorAddress,\\n        uint256 integratorFee\\n    ) external {\\n        if (integratorFee > 1000) revert ExcessiveIntegratorFee();\\n\\n        uint256 specificFee = getSpecificFee(integratorAddress);\\n        uint256 squidFee = specificFee == 0 ? squidDefaultFee : specificFee;\\n\\n        uint256 baseFeeAmount = (amountToTax * integratorFee) / 10000;\\n        uint256 squidFeeAmount = (baseFeeAmount * squidFee) / 10000;\\n        uint256 integratorFeeAmount = baseFeeAmount - squidFeeAmount;\\n\\n        _safeTransferFrom(token, msg.sender, baseFeeAmount);\\n        _setBalance(token, squidTeam, getBalance(token, squidTeam) + squidFeeAmount);\\n        _setBalance(token, integratorAddress, getBalance(token, integratorAddress) + integratorFeeAmount);\\n\\n        emit FeeCollected(token, integratorAddress, squidFeeAmount, integratorFeeAmount);\\n    }\\n\\n    function withdrawFee(address token) external {\\n        uint256 balance = getBalance(token, msg.sender);\\n        _setBalance(token, msg.sender, 0);\\n        _safeTransfer(token, msg.sender, balance);\\n\\n        emit FeeWithdrawn(token, msg.sender, balance);\\n    }\\n\\n    function setSpecificFee(address integrator, uint256 fee) external onlyOwner {\\n        bytes32 slot = _computeSpecificFeeSlot(integrator);\\n        assembly {\\n            sstore(slot, fee)\\n        }\\n    }\\n\\n    function getBalance(address token, address account) public view returns (uint256 value) {\\n        bytes32 slot = _computeBalanceSlot(token, account);\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function getSpecificFee(address integrator) public view returns (uint256 value) {\\n        bytes32 slot = _computeSpecificFeeSlot(integrator);\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function contractId() external pure returns (bytes32 id) {\\n        id = keccak256(\\\"squid-fee-collector\\\");\\n    }\\n\\n    function _setBalance(\\n        address token,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        bytes32 slot = _computeBalanceSlot(token, account);\\n        assembly {\\n            sstore(slot, amount)\\n        }\\n    }\\n\\n    function _computeBalanceSlot(address token, address account) private pure returns (bytes32 slot) {\\n        slot = keccak256(abi.encodePacked(BALANCES_PREFIX, token, account));\\n    }\\n\\n    function _computeSpecificFeeSlot(address integrator) private pure returns (bytes32 slot) {\\n        slot = keccak256(abi.encodePacked(SPECIFIC_FEES_PREFIX, integrator));\\n    }\\n\\n    function _safeTransferFrom(\\n        address token,\\n        address from,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TransferFailed();\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TransferFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SquidFeeCollectorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {Proxy} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Proxy.sol\\\";\\n\\ncontract SquidFeeCollectorProxy is Proxy {\\n    function contractId() internal pure override returns (bytes32 id) {\\n        id = keccak256(\\\"squid-fee-collector\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SquidMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ISquidMulticall} from \\\"./interfaces/ISquidMulticall.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract SquidMulticall is ISquidMulticall {\\n    bool private isRunning;\\n\\n    error TransferFailed();\\n\\n    function run(Call[] calldata calls) external payable {\\n        // Prevents reentrancy\\n        if (isRunning) revert AlreadyRunning();\\n        isRunning = true;\\n\\n        for (uint256 i = 0; i < calls.length; i++) {\\n            Call memory call = calls[i];\\n\\n            if (call.callType == CallType.FullTokenBalance) {\\n                (address token, uint256 amountParameterPosition) = abi.decode(call.payload, (address, uint256));\\n                uint256 amount = IERC20(token).balanceOf(address(this));\\n                _setCallDataParameter(call.callData, amountParameterPosition, amount);\\n            } else if (call.callType == CallType.FullNativeBalance) {\\n                call.value = address(this).balance;\\n            } else if (call.callType == CallType.CollectTokenBalance) {\\n                address token = abi.decode(call.payload, (address));\\n                _safeTransferFrom(token, msg.sender, IERC20(token).balanceOf(msg.sender));\\n                continue;\\n            }\\n\\n            (bool success, bytes memory data) = call.target.call{value: call.value}(call.callData);\\n            if (!success) revert CallFailed(i, data);\\n        }\\n\\n        isRunning = false;\\n    }\\n\\n    function _safeTransferFrom(\\n        address token,\\n        address from,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, address(this), amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TransferFailed();\\n    }\\n\\n    function _setCallDataParameter(\\n        bytes memory callData,\\n        uint256 parameterPosition,\\n        uint256 value\\n    ) private pure {\\n        assembly {\\n            // 36 bytes shift because 32 for prefix + 4 for selector\\n            mstore(add(callData, add(36, mul(parameterPosition, 32))), value)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SquidRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ISquidRouter} from \\\"./interfaces/ISquidRouter.sol\\\";\\nimport {ISquidMulticall} from \\\"./interfaces/ISquidMulticall.sol\\\";\\nimport {AxelarForecallable} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/executables/AxelarForecallable.sol\\\";\\nimport {IAxelarGasService} from \\\"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IAxelarGasService.sol\\\";\\nimport {IAxelarGateway} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\\\";\\nimport {AddressToString} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/StringAddressUtils.sol\\\";\\nimport {Upgradable} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Upgradable.sol\\\";\\nimport {RoledPausable} from \\\"./RoledPausable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract SquidRouter is ISquidRouter, AxelarForecallable, Upgradable, RoledPausable {\\n    using AddressToString for address;\\n\\n    IAxelarGasService private immutable gasService;\\n    IAxelarGasService private immutable forecallGasService;\\n    ISquidMulticall private immutable squidMulticall;\\n\\n    error ZeroAddressProvided();\\n\\n    constructor(\\n        address _gateway,\\n        address _gasService,\\n        address _forecallGasService,\\n        address _multicall\\n    ) AxelarForecallable(_gateway) {\\n        if (\\n            _gateway == address(0) ||\\n            _gasService == address(0) ||\\n            _forecallGasService == address(0) ||\\n            _multicall == address(0)\\n        ) revert ZeroAddressProvided();\\n\\n        gasService = IAxelarGasService(_gasService);\\n        forecallGasService = IAxelarGasService(_forecallGasService);\\n        squidMulticall = ISquidMulticall(_multicall);\\n    }\\n\\n    function bridgeCall(\\n        string calldata destinationChain,\\n        string calldata bridgedTokenSymbol,\\n        uint256 amount,\\n        ISquidMulticall.Call[] calldata calls,\\n        address refundRecipient,\\n        bool enableForecall\\n    ) external payable whenNotPaused {\\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\\n\\n        _safeTransferFrom(bridgedTokenAddress, msg.sender, amount);\\n        _bridgeCall(destinationChain, bridgedTokenSymbol, bridgedTokenAddress, calls, refundRecipient, enableForecall);\\n    }\\n\\n    function callBridge(\\n        address token,\\n        uint256 amount,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        string calldata bridgedTokenSymbol,\\n        ISquidMulticall.Call[] calldata calls\\n    ) external payable whenNotPaused {\\n        fundAndRunMulticall(token, amount, calls);\\n\\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\\n        uint256 bridgedTokenAmount = IERC20(bridgedTokenAddress).balanceOf(address(this));\\n\\n        _approve(bridgedTokenAddress, address(gateway), bridgedTokenAmount);\\n        gateway.sendToken(destinationChain, destinationAddress, bridgedTokenSymbol, bridgedTokenAmount);\\n    }\\n\\n    function callBridgeCall(\\n        address token,\\n        uint256 amount,\\n        string calldata destinationChain,\\n        string calldata bridgedTokenSymbol,\\n        ISquidMulticall.Call[] calldata sourceCalls,\\n        ISquidMulticall.Call[] calldata destinationCalls,\\n        address refundRecipient,\\n        bool enableForecall\\n    ) external payable whenNotPaused {\\n        fundAndRunMulticall(token, amount, sourceCalls);\\n\\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\\n\\n        _bridgeCall(\\n            destinationChain,\\n            bridgedTokenSymbol,\\n            bridgedTokenAddress,\\n            destinationCalls,\\n            refundRecipient,\\n            enableForecall\\n        );\\n    }\\n\\n    function contractId() external pure override returns (bytes32 id) {\\n        id = keccak256(\\\"squid-router\\\");\\n    }\\n\\n    function fundAndRunMulticall(\\n        address token,\\n        uint256 amount,\\n        ISquidMulticall.Call[] memory calls\\n    ) public payable whenNotPaused {\\n        uint256 valueToSend;\\n\\n        if (token == address(0)) {\\n            valueToSend = amount;\\n        } else {\\n            _transferTokenToMulticall(token, amount);\\n        }\\n\\n        squidMulticall.run{value: valueToSend}(calls);\\n    }\\n\\n    function _executeWithToken(\\n        string calldata,\\n        string calldata,\\n        bytes calldata payload,\\n        string calldata bridgedTokenSymbol,\\n        uint256\\n    ) internal override {\\n        (ISquidMulticall.Call[] memory calls, address refundRecipient) = abi.decode(\\n            payload,\\n            (ISquidMulticall.Call[], address)\\n        );\\n        address bridgedTokenAddress = gateway.tokenAddresses(bridgedTokenSymbol);\\n        uint256 contractBalance = IERC20(bridgedTokenAddress).balanceOf(address(this));\\n\\n        _approve(bridgedTokenAddress, address(squidMulticall), contractBalance);\\n\\n        try squidMulticall.run(calls) {\\n            emit CrossMulticallExecuted(keccak256(payload));\\n        } catch (bytes memory reason) {\\n            // Refund tokens to refund recepient if swap fails\\n            _safeTransfer(bridgedTokenAddress, refundRecipient, contractBalance);\\n            emit CrossMulticallFailed(keccak256(payload), reason, refundRecipient);\\n        }\\n    }\\n\\n    function _bridgeCall(\\n        string calldata destinationChain,\\n        string calldata bridgedTokenSymbol,\\n        address bridgedTokenAddress,\\n        ISquidMulticall.Call[] calldata calls,\\n        address refundRecipient,\\n        bool enableForecall\\n    ) private {\\n        if (refundRecipient == address(0)) revert ZeroAddressProvided();\\n\\n        bytes memory payload = abi.encode(calls, refundRecipient);\\n        // Only works if destination router has same address\\n        string memory destinationContractAddress = address(this).toString();\\n        uint256 bridgedTokenBalance = IERC20(bridgedTokenAddress).balanceOf(address(this));\\n\\n        if (address(this).balance > 0) {\\n            IAxelarGasService executionService = enableForecall ? forecallGasService : gasService;\\n            executionService.payNativeGasForContractCallWithToken{value: address(this).balance}(\\n                address(this),\\n                destinationChain,\\n                destinationContractAddress,\\n                payload,\\n                bridgedTokenSymbol,\\n                bridgedTokenBalance,\\n                refundRecipient\\n            );\\n        }\\n        _approve(bridgedTokenAddress, address(gateway), bridgedTokenBalance);\\n        gateway.callContractWithToken(\\n            destinationChain,\\n            destinationContractAddress,\\n            payload,\\n            bridgedTokenSymbol,\\n            bridgedTokenBalance\\n        );\\n    }\\n\\n    function _approve(\\n        address tokenAddress,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        if (IERC20(tokenAddress).allowance(address(this), spender) < amount) {\\n            // Not a security issue since the contract doesn't store tokens\\n            IERC20(tokenAddress).approve(spender, type(uint256).max);\\n        }\\n    }\\n\\n    function _transferTokenToMulticall(address token, uint256 amount) private {\\n        (bool success, bytes memory returnData) = token.call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, msg.sender, address(squidMulticall), amount)\\n        );\\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n        if (!transferred || token.code.length == 0) revert TransferFailed();\\n    }\\n\\n    function _setup(bytes calldata data) internal override {\\n        address _pauser = abi.decode(data, (address));\\n        if (_pauser == address(0)) revert(\\\"Invalid pauser address\\\");\\n        _setPauser(_pauser);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SquidRouterProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {Proxy} from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradables/Proxy.sol\\\";\\n\\ncontract SquidRouterProxy is Proxy {\\n    function contractId() internal pure override returns (bytes32 id) {\\n        id = keccak256(\\\"squid-router\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EtherNotAccepted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SetupFailed\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SquidRouterProxy", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x0c05bbc439c59861ebc7d504b5d74d2701f91e62", "SwarmSource": ""}