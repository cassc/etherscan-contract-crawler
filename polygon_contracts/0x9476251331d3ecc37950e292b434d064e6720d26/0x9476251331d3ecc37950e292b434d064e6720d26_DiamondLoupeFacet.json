{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/eip/2535/core/DiamondLoupeFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\nimport { LibDiamond } from  \\\"../lib/LibDiamond.sol\\\";\\r\\nimport { IDiamondLoupe } from \\\"../interfaces/IDiamondLoupe.sol\\\";\\r\\nimport { IERC165 } from \\\"../interfaces/IERC165.sol\\\";\\r\\n\\r\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\r\\n    //get all facet\\r\\n    function facets() external override view returns (Facet[] memory) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        address[] memory allFacets=ds.facets;\\r\\n        Facet[] memory result=new Facet[](allFacets.length);\\r\\n        uint256 resultIndex=0;\\r\\n        for(uint256 i=0;i<allFacets.length;i++){\\r\\n               if(ds.FacetAddressToSelectors[allFacets[i]].length > 0){\\r\\n                   result[resultIndex].functionSelectors=ds.FacetAddressToSelectors[allFacets[i]];\\r\\n                   result[resultIndex].facetAddress=allFacets[i]; \\r\\n                   resultIndex++;\\r\\n               }\\r\\n        }\\r\\n        assembly {\\r\\n            mstore(result, resultIndex)\\r\\n        }\\r\\n        return result;\\r\\n\\r\\n    }\\r\\n    //get selectors  by facet\\r\\n    function facetFunctionSelectors(address facet) external override view returns (bytes4[] memory) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        bytes4[] memory result=ds.FacetAddressToSelectors[facet];\\r\\n        require(result.length > 0,\\\"facet inexistence\\\");\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function facetAddresses() external override view returns (address[] memory) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        address[] memory allFacets=ds.facets;\\r\\n        address[] memory result=new address[](allFacets.length);\\r\\n        uint256 resultIndex=0;\\r\\n        for(uint256 i=0;i<allFacets.length;i++){\\r\\n             if(ds.FacetAddressToSelectors[allFacets[i]].length > 0){   \\r\\n                result[resultIndex]= allFacets[i];\\r\\n                 resultIndex++;\\r\\n             }\\r\\n        }\\r\\n        assembly {\\r\\n            mstore(result, resultIndex)\\r\\n        }       \\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    //get facet by selector\\r\\n    function facetAddress(bytes4 functionSelector) external override view returns (address) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        return ds.SelectorsToFacetAddress[functionSelector];\\r\\n    }\\r\\n\\r\\n    // This implements ERC-165.\\r\\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        return ds.supportedInterfaces[_interfaceId];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/eip/2535/interfaces/IDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\ninterface IDiamond {\\r\\n    struct FacetCut{\\r\\n        address  facetAddress;\\r\\n        bytes4[] addSelectors;\\r\\n        bytes4[] removeSelectors;   \\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/eip/2535/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\nimport { IDiamond } from \\\"./IDiamond.sol\\\";\\r\\n\\r\\ninterface IDiamondCut is IDiamond {    \\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) external;    \\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/eip/2535/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\ninterface IDiamondLoupe {\\r\\n    struct Facet {\\r\\n        address facetAddress;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n\\r\\n    function facets() external view returns (Facet[] memory facets_);\\r\\n\\r\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\r\\n\\r\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\r\\n\\r\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/eip/2535/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\ninterface IERC165 {\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/eip/2535/lib/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\nimport { IDiamond } from \\\"../interfaces/IDiamond.sol\\\";\\r\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\r\\nlibrary LibDiamond {\\r\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\r\\n    struct DiamondStorage {\\r\\n        //facet's function selector\\r\\n        mapping(address=>bytes4[]) FacetAddressToSelectors;\\r\\n        //all facets\\r\\n        address[] facets;\\r\\n        //selector corresponding facet\\r\\n        mapping(bytes4=>address)  SelectorsToFacetAddress;\\r\\n        //\\r\\n        mapping(bytes4 => bool) supportedInterfaces;\\r\\n        // owner of the contract\\r\\n        address contractOwner;\\r\\n\\r\\n\\r\\n        //Allows access to the database whitelist\\r\\n        mapping(address=>bool) dBControlWhitelist;\\r\\n    }\\r\\n\\r\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    function setContractOwner(address newOwner) internal {\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        address previousOwner = ds.contractOwner;\\r\\n        ds.contractOwner = newOwner;\\r\\n        emit OwnershipTransferred(previousOwner, newOwner);\\r\\n    }\\r\\n\\r\\n    function contractOwner() internal view returns (address contractOwner_) {\\r\\n        contractOwner_ = diamondStorage().contractOwner;\\r\\n    }\\r\\n\\r\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address init, bytes data);\\r\\n    event SetDBControlWhitelist(address[]  _lists,bool[]  _status);\\r\\n    function setDBControlWhitelist(address[] memory _lists,bool[] memory _status) internal {\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        for(uint256 i;i<_lists.length;i++){\\r\\n            ds.dBControlWhitelist[_lists[i]]=_status[i];\\r\\n        }\\r\\n        emit SetDBControlWhitelist(_lists,_status);\\r\\n    }\\r\\n\\r\\n    function diamondCut(\\r\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) internal {\\r\\n          for(uint256 i=0;i<_diamondCut.length;i++){\\r\\n              require(_diamondCut[i].facetAddress!=address(0),\\\"facets must be valid address\\\");  \\r\\n              enforceHasContractCode(_diamondCut[i].facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\r\\n               if(_diamondCut[i].addSelectors.length>0){\\r\\n                  addFunctions(_diamondCut[i].facetAddress,_diamondCut[i].addSelectors);   \\r\\n               }\\r\\n\\r\\n               if(_diamondCut[i].removeSelectors.length>0){\\r\\n                  removeFunctions(_diamondCut[i].facetAddress,_diamondCut[i].removeSelectors); \\r\\n               }\\r\\n          }\\r\\n          initializeDiamondCut(_init,_calldata);\\r\\n          emit DiamondCut(_diamondCut,_init,_calldata);\\r\\n    }\\r\\n\\r\\n\\r\\n    function addFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {     \\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        for(uint256 i=0;i<functionSelectors.length;i++){\\r\\n              require(ds.SelectorsToFacetAddress[functionSelectors[i]]==address(0),\\\"selector have already added\\\");\\r\\n              ds.SelectorsToFacetAddress[functionSelectors[i]]=facetAddress;\\r\\n              ds.FacetAddressToSelectors[facetAddress].push(functionSelectors[i]);\\r\\n        }\\r\\n\\r\\n        address[] memory facets=ds.facets;\\r\\n        bool isExist;\\r\\n        for(uint256 i=0;i<facets.length;i++){\\r\\n            if(facets[i]==facetAddress){\\r\\n                isExist=true;\\r\\n            }\\r\\n        }\\r\\n        if(!isExist){\\r\\n             ds.facets.push(facetAddress);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {      \\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        for(uint256 i=0;i<functionSelectors.length;i++){\\r\\n            require(ds.SelectorsToFacetAddress[functionSelectors[i]]!=address(0),\\\"selector inexistence\\\");\\r\\n            delete ds.SelectorsToFacetAddress[functionSelectors[i]];\\r\\n            bytes4[] memory selectors=ds.FacetAddressToSelectors[facetAddress];\\r\\n            for(uint256 j=0;j<selectors.length;j++){\\r\\n                 if(selectors[j]==functionSelectors[i]){\\r\\n                      ds.FacetAddressToSelectors[facetAddress][j]=ds.FacetAddressToSelectors[facetAddress][selectors.length-1];\\r\\n                      ds.FacetAddressToSelectors[facetAddress].pop();\\r\\n                 }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\r\\n        if (_init == address(0)) {\\r\\n            return;\\r\\n        }\\r\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\r\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\r\\n        if (!success) {\\r\\n            if (error.length > 0) {\\r\\n                // bubble up error\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(error)\\r\\n                    revert(add(32, error), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(\\\"delegatecall fail\\\");\\r\\n            }\\r\\n        }        \\r\\n    }\\r\\n\\r\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\r\\n        uint256 contractSize;\\r\\n        assembly {\\r\\n            contractSize := extcodesize(_contract)\\r\\n        }\\r\\n        require(contractSize != 0,_errorMessage);  \\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DiamondLoupeFacet", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}