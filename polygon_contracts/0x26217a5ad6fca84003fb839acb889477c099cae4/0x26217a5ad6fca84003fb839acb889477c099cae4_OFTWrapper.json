{"SourceCode": "// Sources flattened with hardhat v2.17.3 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-only AND MIT\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.8.0\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @layerzerolabs/solidity-examples/contracts/token/oft/v1/interfaces/IOFTCore.sol@v1.0.0\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @dev Interface of the IOFT core standard\r\n */\r\ninterface IOFTCore is IERC165 {\r\n    /**\r\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\r\n     * _dstChainId - L0 defined chain id to send tokens too\r\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n     * _amount - amount of the tokens to transfer\r\n     * _useZro - indicates to use zro to pay L0 fees\r\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\r\n     */\r\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    /**\r\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\r\n     * `_from` the owner of token\r\n     * `_dstChainId` the destination chain identifier\r\n     * `_toAddress` can be any size depending on the `dstChainId`.\r\n     * `_amount` the quantity of tokens in wei\r\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\r\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\r\n\r\n    /**\r\n     * @dev returns the circulating amount of tokens on current chain\r\n     */\r\n    function circulatingSupply() external view returns (uint);\r\n\r\n    /**\r\n     * @dev returns the address of the ERC20 token\r\n     */\r\n    function token() external view returns (address);\r\n\r\n    /**\r\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\r\n     * `_nonce` is the outbound nonce\r\n     */\r\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes _toAddress, uint _amount);\r\n\r\n    /**\r\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\r\n     * `_nonce` is the inbound nonce.\r\n     */\r\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\r\n\r\n    event SetUseCustomAdapterParams(bool _useCustomAdapterParams);\r\n}\r\n\r\n\r\n// File @layerzerolabs/solidity-examples/contracts/token/oft/v2/interfaces/ICommonOFT.sol@v1.0.0\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @dev Interface of the IOFT core standard\r\n */\r\ninterface ICommonOFT is IERC165 {\r\n\r\n    struct LzCallParams {\r\n        address payable refundAddress;\r\n        address zroPaymentAddress;\r\n        bytes adapterParams;\r\n    }\r\n\r\n    /**\r\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\r\n     * _dstChainId - L0 defined chain id to send tokens too\r\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\r\n     * _amount - amount of the tokens to transfer\r\n     * _useZro - indicates to use zro to pay L0 fees\r\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\r\n     */\r\n    function estimateSendFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    function estimateSendAndCallFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\r\n\r\n    /**\r\n     * @dev returns the circulating amount of tokens on current chain\r\n     */\r\n    function circulatingSupply() external view returns (uint);\r\n\r\n    /**\r\n     * @dev returns the address of the ERC20 token\r\n     */\r\n    function token() external view returns (address);\r\n}\r\n\r\n\r\n// File @layerzerolabs/solidity-examples/contracts/token/oft/v2/fee/IOFTWithFee.sol@v1.0.0\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @dev Interface of the IOFT core standard\r\n */\r\ninterface IOFTWithFee is ICommonOFT {\r\n\r\n    /**\r\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\r\n     * `_from` the owner of token\r\n     * `_dstChainId` the destination chain identifier\r\n     * `_toAddress` can be any size depending on the `dstChainId`.\r\n     * `_amount` the quantity of tokens in wei\r\n     * `_minAmount` the minimum amount of tokens to receive on dstChain\r\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\r\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, uint _minAmount, LzCallParams calldata _callParams) external payable;\r\n\r\n    function sendAndCall(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, uint _minAmount, bytes calldata _payload, uint64 _dstGasForCall, LzCallParams calldata _callParams) external payable;\r\n}\r\n\r\n\r\n// File @layerzerolabs/solidity-examples/contracts/token/oft/v2/interfaces/IOFTV2.sol@v1.0.0\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/**\r\n * @dev Interface of the IOFT core standard\r\n */\r\ninterface IOFTV2 is ICommonOFT {\r\n\r\n    /**\r\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\r\n     * `_from` the owner of token\r\n     * `_dstChainId` the destination chain identifier\r\n     * `_toAddress` can be any size depending on the `dstChainId`.\r\n     * `_amount` the quantity of tokens in wei\r\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\r\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\r\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\r\n     */\r\n    function sendFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, LzCallParams calldata _callParams) external payable;\r\n\r\n    function sendAndCall(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, LzCallParams calldata _callParams) external payable;\r\n}\r\n\r\n\r\n// File @solidstate/contracts/interfaces/IERC173Internal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title Partial ERC173 interface needed by internal functions\r\n */\r\ninterface IERC173Internal {\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/IOwnableInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IOwnableInternal is IERC173Internal {\r\n    error Ownable__NotOwner();\r\n    error Ownable__NotTransitiveOwner();\r\n}\r\n\r\n\r\n// File @solidstate/contracts/interfaces/IERC173.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title Contract ownership standard interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-173\r\n */\r\ninterface IERC173 is IERC173Internal {\r\n    /**\r\n     * @notice get the ERC173 contract owner\r\n     * @return contract owner\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * @notice transfer contract ownership to new account\r\n     * @param account address of new owner\r\n     */\r\n    function transferOwnership(address account) external;\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/IOwnable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\ninterface IOwnable is IOwnableInternal, IERC173 {}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/ISafeOwnableInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface ISafeOwnableInternal is IOwnableInternal {\r\n    error SafeOwnable__NotNomineeOwner();\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/ISafeOwnable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\ninterface ISafeOwnable is ISafeOwnableInternal, IOwnable {\r\n    /**\r\n     * @notice get the nominated owner who has permission to call acceptOwnership\r\n     */\r\n    function nomineeOwner() external view returns (address);\r\n\r\n    /**\r\n     * @notice accept transfer of contract ownership\r\n     */\r\n    function acceptOwnership() external;\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/OwnableStorage.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary OwnableStorage {\r\n    struct Layout {\r\n        address owner;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.Ownable');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/utils/UintUtils.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title utility functions for uint256 operations\r\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\r\n */\r\nlibrary UintUtils {\r\n    error UintUtils__InsufficientHexLength();\r\n\r\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\r\n\r\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\r\n        return b < 0 ? sub(a, -b) : a + uint256(b);\r\n    }\r\n\r\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\r\n        return b < 0 ? add(a, -b) : a - uint256(b);\r\n    }\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return '0';\r\n        }\r\n\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n\r\n        bytes memory buffer = new bytes(digits);\r\n\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return '0x00';\r\n        }\r\n\r\n        uint256 length = 0;\r\n\r\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\r\n            unchecked {\r\n                length++;\r\n            }\r\n        }\r\n\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    function toHexString(\r\n        uint256 value,\r\n        uint256 length\r\n    ) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = '0';\r\n        buffer[1] = 'x';\r\n\r\n        unchecked {\r\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\r\n                value >>= 4;\r\n            }\r\n        }\r\n\r\n        if (value != 0) revert UintUtils__InsufficientHexLength();\r\n\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/utils/AddressUtils.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary AddressUtils {\r\n    using UintUtils for uint256;\r\n\r\n    error AddressUtils__InsufficientBalance();\r\n    error AddressUtils__NotContract();\r\n    error AddressUtils__SendValueFailed();\r\n\r\n    function toString(address account) internal pure returns (string memory) {\r\n        return uint256(uint160(account)).toHexString(20);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable account, uint256 amount) internal {\r\n        (bool success, ) = account.call{ value: amount }('');\r\n        if (!success) revert AddressUtils__SendValueFailed();\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCall(target, data, 'AddressUtils: failed low-level call');\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory error\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, error);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                'AddressUtils: failed low-level call with value'\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory error\r\n    ) internal returns (bytes memory) {\r\n        if (value > address(this).balance)\r\n            revert AddressUtils__InsufficientBalance();\r\n        return _functionCallWithValue(target, data, value, error);\r\n    }\r\n\r\n    /**\r\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\r\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\r\n     * @param target recipient of call\r\n     * @param gasAmount gas allowance for call\r\n     * @param value native token value to include in call\r\n     * @param maxCopy maximum number of bytes to copy from return data\r\n     * @param data encoded call data\r\n     * @return success whether call is successful\r\n     * @return returnData copied return data\r\n     */\r\n    function excessivelySafeCall(\r\n        address target,\r\n        uint256 gasAmount,\r\n        uint256 value,\r\n        uint16 maxCopy,\r\n        bytes memory data\r\n    ) internal returns (bool success, bytes memory returnData) {\r\n        returnData = new bytes(maxCopy);\r\n\r\n        assembly {\r\n            // execute external call via assembly to avoid automatic copying of return data\r\n            success := call(\r\n                gasAmount,\r\n                target,\r\n                value,\r\n                add(data, 0x20),\r\n                mload(data),\r\n                0,\r\n                0\r\n            )\r\n\r\n            // determine whether to limit amount of data to copy\r\n            let toCopy := returndatasize()\r\n\r\n            if gt(toCopy, maxCopy) {\r\n                toCopy := maxCopy\r\n            }\r\n\r\n            // store the length of the copied bytes\r\n            mstore(returnData, toCopy)\r\n\r\n            // copy the bytes from returndata[0:toCopy]\r\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\r\n        }\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory error\r\n    ) private returns (bytes memory) {\r\n        if (!isContract(target)) revert AddressUtils__NotContract();\r\n\r\n        (bool success, bytes memory returnData) = target.call{ value: value }(\r\n            data\r\n        );\r\n\r\n        if (success) {\r\n            return returnData;\r\n        } else if (returnData.length > 0) {\r\n            assembly {\r\n                let returnData_size := mload(returnData)\r\n                revert(add(32, returnData), returnData_size)\r\n            }\r\n        } else {\r\n            revert(error);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/OwnableInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\nabstract contract OwnableInternal is IOwnableInternal {\r\n    using AddressUtils for address;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\r\n        _;\r\n    }\r\n\r\n    modifier onlyTransitiveOwner() {\r\n        if (msg.sender != _transitiveOwner())\r\n            revert Ownable__NotTransitiveOwner();\r\n        _;\r\n    }\r\n\r\n    function _owner() internal view virtual returns (address) {\r\n        return OwnableStorage.layout().owner;\r\n    }\r\n\r\n    function _transitiveOwner() internal view virtual returns (address owner) {\r\n        owner = _owner();\r\n\r\n        while (owner.isContract()) {\r\n            try IERC173(owner).owner() returns (address transitiveOwner) {\r\n                owner = transitiveOwner;\r\n            } catch {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _transferOwnership(address account) internal virtual {\r\n        _setOwner(account);\r\n    }\r\n\r\n    function _setOwner(address account) internal virtual {\r\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\r\n        emit OwnershipTransferred(l.owner, account);\r\n        l.owner = account;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/Ownable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n/**\r\n * @title Ownership access control based on ERC173\r\n */\r\nabstract contract Ownable is IOwnable, OwnableInternal {\r\n    /**\r\n     * @inheritdoc IERC173\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IERC173\r\n     */\r\n    function transferOwnership(address account) public virtual onlyOwner {\r\n        _transferOwnership(account);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/SafeOwnableStorage.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary SafeOwnableStorage {\r\n    struct Layout {\r\n        address nomineeOwner;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.SafeOwnable');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/SafeOwnableInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\nabstract contract SafeOwnableInternal is ISafeOwnableInternal, OwnableInternal {\r\n    modifier onlyNomineeOwner() {\r\n        if (msg.sender != _nomineeOwner())\r\n            revert SafeOwnable__NotNomineeOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice get the nominated owner who has permission to call acceptOwnership\r\n     */\r\n    function _nomineeOwner() internal view virtual returns (address) {\r\n        return SafeOwnableStorage.layout().nomineeOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice accept transfer of contract ownership\r\n     */\r\n    function _acceptOwnership() internal virtual {\r\n        _setOwner(msg.sender);\r\n        delete SafeOwnableStorage.layout().nomineeOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice grant permission to given address to claim contract ownership\r\n     */\r\n    function _transferOwnership(address account) internal virtual override {\r\n        _setNomineeOwner(account);\r\n    }\r\n\r\n    /**\r\n     * @notice set nominee owner\r\n     */\r\n    function _setNomineeOwner(address account) internal virtual {\r\n        SafeOwnableStorage.layout().nomineeOwner = account;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/access/ownable/SafeOwnable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ownership access control based on ERC173 with ownership transfer safety check\r\n */\r\nabstract contract SafeOwnable is ISafeOwnable, Ownable, SafeOwnableInternal {\r\n    /**\r\n     * @inheritdoc ISafeOwnable\r\n     */\r\n    function nomineeOwner() public view virtual returns (address) {\r\n        return _nomineeOwner();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ISafeOwnable\r\n     */\r\n    function acceptOwnership() public virtual onlyNomineeOwner {\r\n        _acceptOwnership();\r\n    }\r\n\r\n    function _transferOwnership(\r\n        address account\r\n    ) internal virtual override(OwnableInternal, SafeOwnableInternal) {\r\n        super._transferOwnership(account);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/interfaces/IERC165Internal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title ERC165 interface registration interface\r\n */\r\ninterface IERC165Internal {\r\n\r\n}\r\n\r\n\r\n// File @solidstate/contracts/interfaces/IERC165.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title ERC165 interface registration interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165_ is IERC165Internal {\r\n    /**\r\n     * @notice query whether contract has registered support for given interface\r\n     * @param interfaceId interface id\r\n     * @return bool whether interface is supported\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @solidstate/contracts/introspection/ERC165/base/ERC165BaseStorage.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary ERC165BaseStorage {\r\n    struct Layout {\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.ERC165Base');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/introspection/ERC165/base/IERC165BaseInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC165BaseInternal is IERC165Internal {\r\n    error ERC165Base__InvalidInterfaceId();\r\n}\r\n\r\n\r\n// File @solidstate/contracts/introspection/ERC165/base/ERC165BaseInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n/**\r\n * @title ERC165 implementation\r\n */\r\nabstract contract ERC165BaseInternal is IERC165BaseInternal {\r\n    /**\r\n     * @notice indicates whether an interface is already supported based on the interfaceId\r\n     * @param interfaceId id of interface to check\r\n     * @return bool indicating whether interface is supported\r\n     */\r\n    function _supportsInterface(\r\n        bytes4 interfaceId\r\n    ) internal view virtual returns (bool) {\r\n        return ERC165BaseStorage.layout().supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @notice sets status of interface support\r\n     * @param interfaceId id of interface to set status for\r\n     * @param status boolean indicating whether interface will be set as supported\r\n     */\r\n    function _setSupportsInterface(\r\n        bytes4 interfaceId,\r\n        bool status\r\n    ) internal virtual {\r\n        if (interfaceId == 0xffffffff) revert ERC165Base__InvalidInterfaceId();\r\n        ERC165BaseStorage.layout().supportedInterfaces[interfaceId] = status;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/introspection/ERC165/base/IERC165Base.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC165Base is IERC165, IERC165BaseInternal {}\r\n\r\n\r\n// File @solidstate/contracts/introspection/ERC165/base/ERC165Base.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC165 implementation\r\n */\r\nabstract contract ERC165Base is IERC165Base, ERC165BaseInternal {\r\n    /**\r\n     * @inheritdoc IERC165\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return _supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\r\n */\r\nlibrary DiamondBaseStorage {\r\n    struct Layout {\r\n        // function selector => (facet address, selector slot position)\r\n        mapping(bytes4 => bytes32) facets;\r\n        // total number of selectors registered\r\n        uint16 selectorCount;\r\n        // array of selector slots with 8 selectors per slot\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        address fallbackAddress;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.DiamondBase');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/IProxy.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IProxy {\r\n    error Proxy__ImplementationIsNotContract();\r\n\r\n    fallback() external payable;\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/base/IDiamondBase.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IDiamondBase is IProxy {}\r\n\r\n\r\n// File @solidstate/contracts/proxy/Proxy.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n/**\r\n * @title Base proxy contract\r\n */\r\nabstract contract Proxy is IProxy {\r\n    using AddressUtils for address;\r\n\r\n    /**\r\n     * @notice delegate all calls to implementation contract\r\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\r\n     * @dev memory location in use by assembly may be unsafe in other contexts\r\n     */\r\n    fallback() external payable virtual {\r\n        address implementation = _getImplementation();\r\n\r\n        if (!implementation.isContract())\r\n            revert Proxy__ImplementationIsNotContract();\r\n\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(\r\n                gas(),\r\n                implementation,\r\n                0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice get logic implementation address\r\n     * @return implementation address\r\n     */\r\n    function _getImplementation() internal virtual returns (address);\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/base/DiamondBase.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n/**\r\n * @title EIP-2535 \"Diamond\" proxy base contract\r\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\r\n */\r\nabstract contract DiamondBase is IDiamondBase, Proxy {\r\n    /**\r\n     * @inheritdoc Proxy\r\n     */\r\n    function _getImplementation()\r\n        internal\r\n        view\r\n        virtual\r\n        override\r\n        returns (address implementation)\r\n    {\r\n        // inline storage layout retrieval uses less gas\r\n        DiamondBaseStorage.Layout storage l;\r\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n\r\n        implementation = address(bytes20(l.facets[msg.sig]));\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/fallback/IDiamondFallback.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IDiamondFallback is IDiamondBase {\r\n    /**\r\n     * @notice query the address of the fallback implementation\r\n     * @return fallbackAddress address of fallback implementation\r\n     */\r\n    function getFallbackAddress()\r\n        external\r\n        view\r\n        returns (address fallbackAddress);\r\n\r\n    /**\r\n     * @notice set the address of the fallback implementation\r\n     * @param fallbackAddress address of fallback implementation\r\n     */\r\n    function setFallbackAddress(address fallbackAddress) external;\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/fallback/DiamondFallback.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Fallback feature for EIP-2535 \"Diamond\" proxy\r\n */\r\nabstract contract DiamondFallback is\r\n    IDiamondFallback,\r\n    OwnableInternal,\r\n    DiamondBase\r\n{\r\n    /**\r\n     * @inheritdoc IDiamondFallback\r\n     */\r\n    function getFallbackAddress()\r\n        external\r\n        view\r\n        returns (address fallbackAddress)\r\n    {\r\n        fallbackAddress = _getFallbackAddress();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondFallback\r\n     */\r\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\r\n        _setFallbackAddress(fallbackAddress);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc DiamondBase\r\n     * @notice query custom fallback address is no implementation is found\r\n     */\r\n    function _getImplementation()\r\n        internal\r\n        view\r\n        virtual\r\n        override\r\n        returns (address implementation)\r\n    {\r\n        implementation = super._getImplementation();\r\n\r\n        if (implementation == address(0)) {\r\n            implementation = _getFallbackAddress();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice query the address of the fallback implementation\r\n     * @return fallbackAddress address of fallback implementation\r\n     */\r\n    function _getFallbackAddress()\r\n        internal\r\n        view\r\n        virtual\r\n        returns (address fallbackAddress)\r\n    {\r\n        fallbackAddress = DiamondBaseStorage.layout().fallbackAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice set the address of the fallback implementation\r\n     * @param fallbackAddress address of fallback implementation\r\n     */\r\n    function _setFallbackAddress(address fallbackAddress) internal virtual {\r\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title Diamond proxy introspection interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\r\n */\r\ninterface IDiamondReadable {\r\n    struct Facet {\r\n        address target;\r\n        bytes4[] selectors;\r\n    }\r\n\r\n    /**\r\n     * @notice get all facets and their selectors\r\n     * @return diamondFacets array of structured facet data\r\n     */\r\n    function facets() external view returns (Facet[] memory diamondFacets);\r\n\r\n    /**\r\n     * @notice get all selectors for given facet address\r\n     * @param facet address of facet to query\r\n     * @return selectors array of function selectors\r\n     */\r\n    function facetFunctionSelectors(\r\n        address facet\r\n    ) external view returns (bytes4[] memory selectors);\r\n\r\n    /**\r\n     * @notice get addresses of all facets used by diamond\r\n     * @return addresses array of facet addresses\r\n     */\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory addresses);\r\n\r\n    /**\r\n     * @notice get the address of the facet associated with given selector\r\n     * @param selector function selector to query\r\n     * @return facet facet address (zero address if not found)\r\n     */\r\n    function facetAddress(\r\n        bytes4 selector\r\n    ) external view returns (address facet);\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/writable/IDiamondWritableInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IDiamondWritableInternal {\r\n    enum FacetCutAction {\r\n        ADD,\r\n        REPLACE,\r\n        REMOVE\r\n    }\r\n\r\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\r\n\r\n    error DiamondWritable__InvalidInitializationParameters();\r\n    error DiamondWritable__RemoveTargetNotZeroAddress();\r\n    error DiamondWritable__ReplaceTargetIsIdentical();\r\n    error DiamondWritable__SelectorAlreadyAdded();\r\n    error DiamondWritable__SelectorIsImmutable();\r\n    error DiamondWritable__SelectorNotFound();\r\n    error DiamondWritable__SelectorNotSpecified();\r\n    error DiamondWritable__TargetHasNoCode();\r\n\r\n    struct FacetCut {\r\n        address target;\r\n        FacetCutAction action;\r\n        bytes4[] selectors;\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/writable/IDiamondWritable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n/**\r\n * @title Diamond proxy upgrade interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\r\n */\r\ninterface IDiamondWritable is IDiamondWritableInternal {\r\n    /**\r\n     * @notice update diamond facets and optionally execute arbitrary initialization function\r\n     * @param facetCuts array of structured Diamond facet update data\r\n     * @param target optional target of initialization delegatecall\r\n     * @param data optional initialization function call data\r\n     */\r\n    function diamondCut(\r\n        FacetCut[] calldata facetCuts,\r\n        address target,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface ISolidStateDiamond is\r\n    IDiamondBase,\r\n    IDiamondFallback,\r\n    IDiamondReadable,\r\n    IDiamondWritable,\r\n    ISafeOwnable,\r\n    IERC165\r\n{\r\n    receive() external payable;\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n/**\r\n * @title EIP-2535 \"Diamond\" proxy introspection contract\r\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\r\n */\r\nabstract contract DiamondReadable is IDiamondReadable {\r\n    /**\r\n     * @inheritdoc IDiamondReadable\r\n     */\r\n    function facets() external view returns (Facet[] memory diamondFacets) {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        diamondFacets = new Facet[](l.selectorCount);\r\n\r\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\r\n            bytes32 slot = l.selectorSlots[slotIndex];\r\n\r\n            for (\r\n                uint256 selectorSlotIndex;\r\n                selectorSlotIndex < 8;\r\n                selectorSlotIndex++\r\n            ) {\r\n                selectorIndex++;\r\n\r\n                if (selectorIndex > l.selectorCount) {\r\n                    break;\r\n                }\r\n\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(l.facets[selector]));\r\n\r\n                bool continueLoop;\r\n\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (diamondFacets[facetIndex].target == facet) {\r\n                        diamondFacets[facetIndex].selectors[\r\n                            numFacetSelectors[facetIndex]\r\n                        ] = selector;\r\n                        // probably will never have more than 256 functions from one facet contract\r\n                        require(numFacetSelectors[facetIndex] < 255);\r\n                        numFacetSelectors[facetIndex]++;\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (continueLoop) {\r\n                    continue;\r\n                }\r\n\r\n                diamondFacets[numFacets].target = facet;\r\n                diamondFacets[numFacets].selectors = new bytes4[](\r\n                    l.selectorCount\r\n                );\r\n                diamondFacets[numFacets].selectors[0] = selector;\r\n                numFacetSelectors[numFacets] = 1;\r\n                numFacets++;\r\n            }\r\n        }\r\n\r\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n            uint256 numSelectors = numFacetSelectors[facetIndex];\r\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\r\n\r\n            // setting the number of selectors\r\n            assembly {\r\n                mstore(selectors, numSelectors)\r\n            }\r\n        }\r\n\r\n        // setting the number of facets\r\n        assembly {\r\n            mstore(diamondFacets, numFacets)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondReadable\r\n     */\r\n    function facetFunctionSelectors(\r\n        address facet\r\n    ) external view returns (bytes4[] memory selectors) {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        selectors = new bytes4[](l.selectorCount);\r\n\r\n        uint256 numSelectors;\r\n        uint256 selectorIndex;\r\n\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\r\n            bytes32 slot = l.selectorSlots[slotIndex];\r\n\r\n            for (\r\n                uint256 selectorSlotIndex;\r\n                selectorSlotIndex < 8;\r\n                selectorSlotIndex++\r\n            ) {\r\n                selectorIndex++;\r\n\r\n                if (selectorIndex > l.selectorCount) {\r\n                    break;\r\n                }\r\n\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n\r\n                if (facet == address(bytes20(l.facets[selector]))) {\r\n                    selectors[numSelectors] = selector;\r\n                    numSelectors++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // set the number of selectors in the array\r\n        assembly {\r\n            mstore(selectors, numSelectors)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondReadable\r\n     */\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory addresses)\r\n    {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        addresses = new address[](l.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n\r\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\r\n            bytes32 slot = l.selectorSlots[slotIndex];\r\n\r\n            for (\r\n                uint256 selectorSlotIndex;\r\n                selectorSlotIndex < 8;\r\n                selectorSlotIndex++\r\n            ) {\r\n                selectorIndex++;\r\n\r\n                if (selectorIndex > l.selectorCount) {\r\n                    break;\r\n                }\r\n\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(l.facets[selector]));\r\n\r\n                bool continueLoop;\r\n\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facet == addresses[facetIndex]) {\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (continueLoop) {\r\n                    continue;\r\n                }\r\n\r\n                addresses[numFacets] = facet;\r\n                numFacets++;\r\n            }\r\n        }\r\n\r\n        // set the number of facet addresses in the array\r\n        assembly {\r\n            mstore(addresses, numFacets)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IDiamondReadable\r\n     */\r\n    function facetAddress(\r\n        bytes4 selector\r\n    ) external view returns (address facet) {\r\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nabstract contract DiamondWritableInternal is IDiamondWritableInternal {\r\n    using AddressUtils for address;\r\n\r\n    bytes32 private constant CLEAR_ADDRESS_MASK =\r\n        bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 private constant CLEAR_SELECTOR_MASK =\r\n        bytes32(uint256(0xffffffff << 224));\r\n\r\n    /**\r\n     * @notice update functions callable on Diamond proxy\r\n     * @param facetCuts array of structured Diamond facet update data\r\n     * @param target optional recipient of initialization delegatecall\r\n     * @param data optional initialization call data\r\n     */\r\n    function _diamondCut(\r\n        FacetCut[] memory facetCuts,\r\n        address target,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\r\n\r\n        unchecked {\r\n            uint256 originalSelectorCount = l.selectorCount;\r\n            uint256 selectorCount = originalSelectorCount;\r\n            bytes32 selectorSlot;\r\n\r\n            // Check if last selector slot is not full\r\n            if (selectorCount & 7 > 0) {\r\n                // get last selectorSlot\r\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\r\n            }\r\n\r\n            for (uint256 i; i < facetCuts.length; i++) {\r\n                FacetCut memory facetCut = facetCuts[i];\r\n                FacetCutAction action = facetCut.action;\r\n\r\n                if (facetCut.selectors.length == 0)\r\n                    revert DiamondWritable__SelectorNotSpecified();\r\n\r\n                if (action == FacetCutAction.ADD) {\r\n                    (selectorCount, selectorSlot) = _addFacetSelectors(\r\n                        l,\r\n                        selectorCount,\r\n                        selectorSlot,\r\n                        facetCut\r\n                    );\r\n                } else if (action == FacetCutAction.REPLACE) {\r\n                    _replaceFacetSelectors(l, facetCut);\r\n                } else if (action == FacetCutAction.REMOVE) {\r\n                    (selectorCount, selectorSlot) = _removeFacetSelectors(\r\n                        l,\r\n                        selectorCount,\r\n                        selectorSlot,\r\n                        facetCut\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (selectorCount != originalSelectorCount) {\r\n                l.selectorCount = uint16(selectorCount);\r\n            }\r\n\r\n            // If last selector slot is not full\r\n            if (selectorCount & 7 > 0) {\r\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n            }\r\n\r\n            emit DiamondCut(facetCuts, target, data);\r\n            _initialize(target, data);\r\n        }\r\n    }\r\n\r\n    function _addFacetSelectors(\r\n        DiamondBaseStorage.Layout storage l,\r\n        uint256 selectorCount,\r\n        bytes32 selectorSlot,\r\n        FacetCut memory facetCut\r\n    ) internal returns (uint256, bytes32) {\r\n        unchecked {\r\n            if (\r\n                facetCut.target != address(this) &&\r\n                !facetCut.target.isContract()\r\n            ) revert DiamondWritable__TargetHasNoCode();\r\n\r\n            for (uint256 i; i < facetCut.selectors.length; i++) {\r\n                bytes4 selector = facetCut.selectors[i];\r\n                bytes32 oldFacet = l.facets[selector];\r\n\r\n                if (address(bytes20(oldFacet)) != address(0))\r\n                    revert DiamondWritable__SelectorAlreadyAdded();\r\n\r\n                // add facet for selector\r\n                l.facets[selector] =\r\n                    bytes20(facetCut.target) |\r\n                    bytes32(selectorCount);\r\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\r\n\r\n                // clear selector position in slot and add selector\r\n                selectorSlot =\r\n                    (selectorSlot &\r\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\r\n                    (bytes32(selector) >> selectorInSlotPosition);\r\n\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n                    selectorSlot = 0;\r\n                }\r\n\r\n                selectorCount++;\r\n            }\r\n\r\n            return (selectorCount, selectorSlot);\r\n        }\r\n    }\r\n\r\n    function _removeFacetSelectors(\r\n        DiamondBaseStorage.Layout storage l,\r\n        uint256 selectorCount,\r\n        bytes32 selectorSlot,\r\n        FacetCut memory facetCut\r\n    ) internal returns (uint256, bytes32) {\r\n        unchecked {\r\n            if (facetCut.target != address(0))\r\n                revert DiamondWritable__RemoveTargetNotZeroAddress();\r\n\r\n            uint256 selectorSlotCount = selectorCount >> 3;\r\n            uint256 selectorInSlotIndex = selectorCount & 7;\r\n\r\n            for (uint256 i; i < facetCut.selectors.length; i++) {\r\n                bytes4 selector = facetCut.selectors[i];\r\n                bytes32 oldFacet = l.facets[selector];\r\n\r\n                if (address(bytes20(oldFacet)) == address(0))\r\n                    revert DiamondWritable__SelectorNotFound();\r\n\r\n                if (address(bytes20(oldFacet)) == address(this))\r\n                    revert DiamondWritable__SelectorIsImmutable();\r\n\r\n                if (selectorSlot == 0) {\r\n                    selectorSlotCount--;\r\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    // replace selector with last selector in l.facets\r\n                    lastSelector = bytes4(\r\n                        selectorSlot << (selectorInSlotIndex << 5)\r\n                    );\r\n\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        l.facets[lastSelector] =\r\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                            bytes20(l.facets[lastSelector]);\r\n                    }\r\n\r\n                    delete l.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = l.selectorSlots[\r\n                        oldSelectorsSlotCount\r\n                    ];\r\n\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n\r\n                    // update storage with the modified slot\r\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    selectorSlot =\r\n                        (selectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete l.selectorSlots[selectorSlotCount];\r\n                    selectorSlot = 0;\r\n                }\r\n            }\r\n\r\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\r\n\r\n            return (selectorCount, selectorSlot);\r\n        }\r\n    }\r\n\r\n    function _replaceFacetSelectors(\r\n        DiamondBaseStorage.Layout storage l,\r\n        FacetCut memory facetCut\r\n    ) internal {\r\n        unchecked {\r\n            if (!facetCut.target.isContract())\r\n                revert DiamondWritable__TargetHasNoCode();\r\n\r\n            for (uint256 i; i < facetCut.selectors.length; i++) {\r\n                bytes4 selector = facetCut.selectors[i];\r\n                bytes32 oldFacet = l.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n\r\n                if (oldFacetAddress == address(0))\r\n                    revert DiamondWritable__SelectorNotFound();\r\n                if (oldFacetAddress == address(this))\r\n                    revert DiamondWritable__SelectorIsImmutable();\r\n                if (oldFacetAddress == facetCut.target)\r\n                    revert DiamondWritable__ReplaceTargetIsIdentical();\r\n\r\n                // replace old facet address\r\n                l.facets[selector] =\r\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                    bytes20(facetCut.target);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _initialize(address target, bytes memory data) private {\r\n        if ((target == address(0)) != (data.length == 0))\r\n            revert DiamondWritable__InvalidInitializationParameters();\r\n\r\n        if (target != address(0)) {\r\n            if (target != address(this)) {\r\n                if (!target.isContract())\r\n                    revert DiamondWritable__TargetHasNoCode();\r\n            }\r\n\r\n            (bool success, ) = target.delegatecall(data);\r\n\r\n            if (!success) {\r\n                assembly {\r\n                    returndatacopy(0, 0, returndatasize())\r\n                    revert(0, returndatasize())\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n/**\r\n * @title EIP-2535 \"Diamond\" proxy update contract\r\n */\r\nabstract contract DiamondWritable is\r\n    IDiamondWritable,\r\n    DiamondWritableInternal,\r\n    OwnableInternal\r\n{\r\n    /**\r\n     * @inheritdoc IDiamondWritable\r\n     */\r\n    function diamondCut(\r\n        FacetCut[] calldata facetCuts,\r\n        address target,\r\n        bytes calldata data\r\n    ) external onlyOwner {\r\n        _diamondCut(facetCuts, target, data);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/proxy/diamond/SolidStateDiamond.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SolidState \"Diamond\" proxy reference implementation\r\n */\r\nabstract contract SolidStateDiamond is\r\n    ISolidStateDiamond,\r\n    DiamondBase,\r\n    DiamondFallback,\r\n    DiamondReadable,\r\n    DiamondWritable,\r\n    SafeOwnable,\r\n    ERC165Base\r\n{\r\n    constructor() {\r\n        bytes4[] memory selectors = new bytes4[](12);\r\n        uint256 selectorIndex;\r\n\r\n        // register DiamondFallback\r\n\r\n        selectors[selectorIndex++] = IDiamondFallback\r\n            .getFallbackAddress\r\n            .selector;\r\n        selectors[selectorIndex++] = IDiamondFallback\r\n            .setFallbackAddress\r\n            .selector;\r\n\r\n        _setSupportsInterface(type(IDiamondFallback).interfaceId, true);\r\n\r\n        // register DiamondWritable\r\n\r\n        selectors[selectorIndex++] = IDiamondWritable.diamondCut.selector;\r\n\r\n        _setSupportsInterface(type(IDiamondWritable).interfaceId, true);\r\n\r\n        // register DiamondReadable\r\n\r\n        selectors[selectorIndex++] = IDiamondReadable.facets.selector;\r\n        selectors[selectorIndex++] = IDiamondReadable\r\n            .facetFunctionSelectors\r\n            .selector;\r\n        selectors[selectorIndex++] = IDiamondReadable.facetAddresses.selector;\r\n        selectors[selectorIndex++] = IDiamondReadable.facetAddress.selector;\r\n\r\n        _setSupportsInterface(type(IDiamondReadable).interfaceId, true);\r\n\r\n        // register ERC165\r\n\r\n        selectors[selectorIndex++] = IERC165.supportsInterface.selector;\r\n\r\n        _setSupportsInterface(type(IERC165).interfaceId, true);\r\n\r\n        // register SafeOwnable\r\n\r\n        selectors[selectorIndex++] = Ownable.owner.selector;\r\n        selectors[selectorIndex++] = SafeOwnable.nomineeOwner.selector;\r\n        selectors[selectorIndex++] = Ownable.transferOwnership.selector;\r\n        selectors[selectorIndex++] = SafeOwnable.acceptOwnership.selector;\r\n\r\n        _setSupportsInterface(type(IERC173).interfaceId, true);\r\n\r\n        // diamond cut\r\n\r\n        FacetCut[] memory facetCuts = new FacetCut[](1);\r\n\r\n        facetCuts[0] = FacetCut({\r\n            target: address(this),\r\n            action: FacetCutAction.ADD,\r\n            selectors: selectors\r\n        });\r\n\r\n        _diamondCut(facetCuts, address(0), '');\r\n\r\n        // set owner\r\n\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _transferOwnership(\r\n        address account\r\n    ) internal virtual override(OwnableInternal, SafeOwnable) {\r\n        super._transferOwnership(account);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc DiamondFallback\r\n     */\r\n    function _getImplementation()\r\n        internal\r\n        view\r\n        override(DiamondBase, DiamondFallback)\r\n        returns (address implementation)\r\n    {\r\n        implementation = super._getImplementation();\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/security/pausable/IPausableInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IPausableInternal {\r\n    error Pausable__Paused();\r\n    error Pausable__NotPaused();\r\n\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n}\r\n\r\n\r\n// File @solidstate/contracts/security/pausable/IPausable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\ninterface IPausable is IPausableInternal {\r\n    /**\r\n     * @notice query whether contract is paused\r\n     * @return status whether contract is paused\r\n     */\r\n    function paused() external view returns (bool status);\r\n}\r\n\r\n\r\n// File @solidstate/contracts/security/pausable/PausableStorage.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary PausableStorage {\r\n    struct Layout {\r\n        bool paused;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.Pausable');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/security/pausable/PausableInternal.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n/**\r\n * @title Internal functions for Pausable security control module.\r\n */\r\nabstract contract PausableInternal is IPausableInternal {\r\n    modifier whenNotPaused() {\r\n        if (_paused()) revert Pausable__Paused();\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        if (!_paused()) revert Pausable__NotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice query whether contract is paused\r\n     * @return status whether contract is paused\r\n     */\r\n    function _paused() internal view virtual returns (bool status) {\r\n        status = PausableStorage.layout().paused;\r\n    }\r\n\r\n    /**\r\n     * @notice Triggers paused state, when contract is unpaused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        PausableStorage.layout().paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Triggers unpaused state, when contract is paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        delete PausableStorage.layout().paused;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/security/pausable/Pausable.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n/**\r\n * @title Pausable security control module.\r\n */\r\nabstract contract Pausable is IPausable, PausableInternal {\r\n    /**\r\n     * @inheritdoc IPausable\r\n     */\r\n    function paused() external view virtual returns (bool status) {\r\n        status = _paused();\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/security/reentrancy_guard/IReentrancyGuard.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IReentrancyGuard {\r\n    error ReentrancyGuard__ReentrantCall();\r\n}\r\n\r\n\r\n// File @solidstate/contracts/security/reentrancy_guard/ReentrancyGuardStorage.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nlibrary ReentrancyGuardStorage {\r\n    struct Layout {\r\n        uint256 status;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT =\r\n        keccak256('solidstate.contracts.storage.ReentrancyGuard');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol@v0.0.58\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n/**\r\n * @title Utility contract for preventing reentrancy attacks\r\n */\r\nabstract contract ReentrancyGuard is IReentrancyGuard {\r\n    uint256 internal constant REENTRANCY_STATUS_LOCKED = 2;\r\n    uint256 internal constant REENTRANCY_STATUS_UNLOCKED = 1;\r\n\r\n    modifier nonReentrant() virtual {\r\n        if (_isReentrancyGuardLocked()) revert ReentrancyGuard__ReentrantCall();\r\n        _lockReentrancyGuard();\r\n        _;\r\n        _unlockReentrancyGuard();\r\n    }\r\n\r\n    /**\r\n     * @notice returns true if the reentrancy guard is locked, false otherwise\r\n     */\r\n    function _isReentrancyGuardLocked() internal view virtual returns (bool) {\r\n        return\r\n            ReentrancyGuardStorage.layout().status == REENTRANCY_STATUS_LOCKED;\r\n    }\r\n\r\n    /**\r\n     * @notice lock functions that use the nonReentrant modifier\r\n     */\r\n    function _lockReentrancyGuard() internal virtual {\r\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_LOCKED;\r\n    }\r\n\r\n    /**\r\n     * @notice unlock functions that use the nonReentrant modifier\r\n     */\r\n    function _unlockReentrancyGuard() internal virtual {\r\n        ReentrancyGuardStorage.layout().status = REENTRANCY_STATUS_UNLOCKED;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/helpers/TransferHelper.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @notice Emitted when an approval action fails\r\n */\r\nerror SafeApproveError();\r\n\r\n/**\r\n * @notice Emitted when a transfer action fails\r\n */\r\nerror SafeTransferError();\r\n\r\n/**\r\n * @notice Emitted when a transferFrom action fails\r\n */\r\nerror SafeTransferFromError();\r\n\r\n/**\r\n * @notice Emitted when a transfer of the native token fails\r\n */\r\nerror SafeTransferNativeError();\r\n\r\n/**\r\n * @notice Safely approve the token to the account\r\n * @param _token The token address\r\n * @param _to The token approval recipient address\r\n * @param _value The token approval amount\r\n */\r\nfunction safeApprove(address _token, address _to, uint256 _value) {\r\n    // 0x095ea7b3 is the selector for \"approve(address,uint256)\"\r\n    (bool success, bytes memory data) = _token.call(\r\n        abi.encodeWithSelector(0x095ea7b3, _to, _value)\r\n    );\r\n\r\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\r\n\r\n    if (!condition) {\r\n        revert SafeApproveError();\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Safely transfer the token to the account\r\n * @param _token The token address\r\n * @param _to The token transfer recipient address\r\n * @param _value The token transfer amount\r\n */\r\nfunction safeTransfer(address _token, address _to, uint256 _value) {\r\n    // 0xa9059cbb is the selector for \"transfer(address,uint256)\"\r\n    (bool success, bytes memory data) = _token.call(\r\n        abi.encodeWithSelector(0xa9059cbb, _to, _value)\r\n    );\r\n\r\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\r\n\r\n    if (!condition) {\r\n        revert SafeTransferError();\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Safely transfer the token between the accounts\r\n * @param _token The token address\r\n * @param _from The token transfer source address\r\n * @param _to The token transfer recipient address\r\n * @param _value The token transfer amount\r\n */\r\nfunction safeTransferFrom(address _token, address _from, address _to, uint256 _value) {\r\n    // 0x23b872dd is the selector for \"transferFrom(address,address,uint256)\"\r\n    (bool success, bytes memory data) = _token.call(\r\n        abi.encodeWithSelector(0x23b872dd, _from, _to, _value)\r\n    );\r\n\r\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\r\n\r\n    if (!condition) {\r\n        revert SafeTransferFromError();\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Safely transfer the native token to the account\r\n * @param _to The native token transfer recipient address\r\n * @param _value The native token transfer amount\r\n */\r\nfunction safeTransferNative(address _to, uint256 _value) {\r\n    (bool success, ) = _to.call{ value: _value }(new bytes(0));\r\n\r\n    if (!success) {\r\n        revert SafeTransferNativeError();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/helpers/RefundHelper.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @notice Refunds the extra balance of the native token\r\n * @dev Reverts on subtraction if the actual balance is less than expected\r\n * @param _self The address of the executing contract\r\n * @param _expectedBalance The expected native token balance value\r\n * @param _to The refund receiver's address\r\n */\r\nfunction refundExtraBalance(address _self, uint256 _expectedBalance, address payable _to) {\r\n    uint256 extraBalance = _self.balance - _expectedBalance;\r\n\r\n    if (extraBalance > 0) {\r\n        /*TransferHelper.*/safeTransferNative(_to, extraBalance);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.8.0\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/crosschain/layerzero/interfaces/ILayerZeroEndpoint.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @title ILayerZeroEndpoint\r\n * @notice LayerZero endpoint interface\r\n */\r\ninterface ILayerZeroEndpoint {\r\n    /**\r\n     * @notice Send a cross-chain message\r\n     * @param _dstChainId The destination chain identifier\r\n     * @param _destination Remote address concatenated with local address packed into 40 bytes\r\n     * @param _payload The message content\r\n     * @param _refundAddress Refund the additional amount to this address\r\n     * @param _zroPaymentAddress The address of the ZRO token holder who would pay for the transaction\r\n     * @param _adapterParam Parameters for the adapter service\r\n     */\r\n    function send(\r\n        uint16 _dstChainId,\r\n        bytes calldata _destination,\r\n        bytes calldata _payload,\r\n        address payable _refundAddress,\r\n        address _zroPaymentAddress,\r\n        bytes calldata _adapterParam\r\n    ) external payable;\r\n\r\n    /**\r\n     * @notice Cross-chain message fee estimation\r\n     * @param _dstChainId The destination chain identifier\r\n     * @param _userApplication The application address on the source chain\r\n     * @param _payload The message content\r\n     * @param _payInZRO If false, the user application pays the protocol fee in the native token\r\n     * @param _adapterParam Parameters for the adapter service\r\n     * @return nativeFee The native token fee for the message\r\n     * @return zroFee The ZRO token fee for the message\r\n     */\r\n    function estimateFees(\r\n        uint16 _dstChainId,\r\n        address _userApplication,\r\n        bytes calldata _payload,\r\n        bool _payInZRO,\r\n        bytes calldata _adapterParam\r\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\r\n}\r\n\r\n\r\n// File contracts/Constants.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @dev The default token decimals value\r\n */\r\nuint256 constant DECIMALS_DEFAULT = 18;\r\n\r\n/**\r\n * @dev The maximum uint256 value for swap amount limit settings\r\n */\r\nuint256 constant INFINITY = type(uint256).max;\r\n\r\n/**\r\n * @dev The default limit of account list size\r\n */\r\nuint256 constant LIST_SIZE_LIMIT_DEFAULT = 100;\r\n\r\n/**\r\n * @dev The limit of swap router list size\r\n */\r\nuint256 constant LIST_SIZE_LIMIT_ROUTERS = 200;\r\n\r\n/**\r\n * @dev The factor for percentage settings. Example: 100 is 0.1%\r\n */\r\nuint256 constant MILLIPERCENT_FACTOR = 100_000;\r\n\r\n/**\r\n * @dev The de facto standard address to denote the native token\r\n */\r\naddress constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n\r\n// File contracts/interfaces/ITokenBalance.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @title ITokenBalance\r\n * @notice Token balance interface\r\n */\r\ninterface ITokenBalance {\r\n    /**\r\n     * @notice Getter of the token balance by the account\r\n     * @param _account The account address\r\n     * @return Token balance\r\n     */\r\n    function balanceOf(address _account) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/oft/wrapper/OFTWrapperStorage.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\nlibrary OFTWrapperStorage {\r\n    struct Layout {\r\n        address feeCollector;\r\n    }\r\n\r\n    bytes32 internal constant STORAGE_SLOT = keccak256('interport.oft.wrapper.OFTWrapper');\r\n\r\n    function layout() internal pure returns (Layout storage l) {\r\n        bytes32 slot = STORAGE_SLOT;\r\n        assembly {\r\n            l.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/oft/wrapper/OFTWrapperBase.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OFTWrapperBase\r\n * @notice The OFT wrapper base contract\r\n */\r\nabstract contract OFTWrapperBase is SolidStateDiamond, Pausable, ReentrancyGuard {\r\n    /**\r\n     * @notice Emitted when the address of the fee collector is set\r\n     * @param feeCollector The address of the fee collector\r\n     */\r\n    event SetFeeCollector(address indexed feeCollector);\r\n\r\n    uint256 private constant SYSTEM_VERSION_ID_VALUE = uint256(keccak256('Initial'));\r\n\r\n    /**\r\n     * @notice Initializes the OFTWrapperBase contract\r\n     * @param _feeCollector The initial address of the fee collector\r\n     */\r\n    constructor(address _feeCollector) {\r\n        _initOFTWrapperBaseDiamond();\r\n\r\n        _setFeeCollector(_feeCollector);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address of the fee collector\r\n     * @param _feeCollector The address of the fee collector\r\n     */\r\n    function setFeeCollector(address _feeCollector) external onlyOwner {\r\n        _setFeeCollector(_feeCollector);\r\n    }\r\n\r\n    /**\r\n     * @notice Enter pause state\r\n     */\r\n    function pause() external onlyOwner whenNotPaused {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @notice Exit pause state\r\n     */\r\n    function unpause() external onlyOwner whenPaused {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the contract to a new account\r\n     * @dev Can only be called by the current owner\r\n     * @param _newOwner The address of the contract owner\r\n     */\r\n    function forceTransferOwnership(address _newOwner) external onlyOwner {\r\n        _setOwner(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Performs the withdrawal of tokens, except for reserved ones\r\n     * @dev Use the \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" address for the native token\r\n     * @param _tokenAddress The address of the token\r\n     * @param _tokenAmount The amount of the token\r\n     */\r\n    function cleanup(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\r\n        if (_tokenAddress == /*Constants.*/NATIVE_TOKEN_ADDRESS) {\r\n            /*TransferHelper.*/safeTransferNative(msg.sender, _tokenAmount);\r\n        } else {\r\n            /*TransferHelper.*/safeTransfer(_tokenAddress, msg.sender, _tokenAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the token balance of the current contract\r\n     * @dev Use the \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" address for the native token\r\n     * @param _tokenAddress The address of the token\r\n     * @return The token balance of the current contract\r\n     */\r\n    function tokenBalance(address _tokenAddress) external view returns (uint256) {\r\n        if (_tokenAddress == /*Constants.*/NATIVE_TOKEN_ADDRESS) {\r\n            return address(this).balance;\r\n        } else {\r\n            return ITokenBalance(_tokenAddress).balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the address of the fee collector\r\n     * @return The address of the fee collector\r\n     */\r\n    function feeCollector() external view returns (address) {\r\n        return OFTWrapperStorage.layout().feeCollector;\r\n    }\r\n\r\n    /**\r\n     * @notice Getter of the system version identifier\r\n     * @return The system version identifier\r\n     */\r\n    function SYSTEM_VERSION_ID() external pure returns (uint256) {\r\n        return SYSTEM_VERSION_ID_VALUE;\r\n    }\r\n\r\n    function _setFeeCollector(address _feeCollector) private {\r\n        OFTWrapperStorage.layout().feeCollector = _feeCollector;\r\n\r\n        emit SetFeeCollector(_feeCollector);\r\n    }\r\n\r\n    function _initOFTWrapperBaseDiamond() private {\r\n        bytes4[] memory selectors = new bytes4[](9);\r\n        uint256 selectorIndex;\r\n\r\n        // register Pausable\r\n\r\n        selectors[selectorIndex++] = IPausable.paused.selector;\r\n\r\n        _setSupportsInterface(type(IPausable).interfaceId, true);\r\n\r\n        // register fee collector functions\r\n\r\n        selectors[selectorIndex++] = OFTWrapperBase.setFeeCollector.selector;\r\n        selectors[selectorIndex++] = OFTWrapperBase.feeCollector.selector;\r\n\r\n        // register service functions\r\n\r\n        selectors[selectorIndex++] = OFTWrapperBase.pause.selector;\r\n        selectors[selectorIndex++] = OFTWrapperBase.unpause.selector;\r\n        selectors[selectorIndex++] = OFTWrapperBase.forceTransferOwnership.selector;\r\n        selectors[selectorIndex++] = OFTWrapperBase.cleanup.selector;\r\n        selectors[selectorIndex++] = OFTWrapperBase.tokenBalance.selector;\r\n        selectors[selectorIndex++] = OFTWrapperBase.SYSTEM_VERSION_ID.selector;\r\n\r\n        // diamond cut\r\n\r\n        FacetCut[] memory facetCuts = new FacetCut[](1);\r\n\r\n        facetCuts[0] = FacetCut({\r\n            target: address(this),\r\n            action: FacetCutAction.ADD,\r\n            selectors: selectors\r\n        });\r\n\r\n        _diamondCut(facetCuts, address(0), '');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/oft/wrapper/OFTWrapperStatus.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n/**\r\n * @title OFTWrapperStatus\r\n * @notice OFTWrapper events and custom errors\r\n */\r\ninterface OFTWrapperStatus {\r\n    /**\r\n     * @notice Emitted when the OFT sending function is invoked\r\n     */\r\n    event OftSent();\r\n\r\n    /**\r\n     * @notice Emitted when the caller is not the token sender\r\n     */\r\n    error SenderError();\r\n}\r\n\r\n\r\n// File contracts/oft/wrapper/OFTWrapper.sol\r\n\r\n// Original license: SPDX_License_Identifier: AGPL-3.0-only\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title OFTWrapper\r\n * @notice The OFT wrapper contract\r\n */\r\ncontract OFTWrapper is OFTWrapperBase, OFTWrapperStatus {\r\n    /**\r\n     * @notice OFT `sendFrom` parameters structure (OFT v2)\r\n     * @param from The owner of token\r\n     * @param dstChainId The destination chain identifier\r\n     * @param toAddress Can be any size depending on the `dstChainId`\r\n     * @param amount The quantity of tokens in wei\r\n     * @param callParams LayerZero call parameters\r\n     */\r\n    struct SendFromParams {\r\n        address from;\r\n        uint16 dstChainId;\r\n        bytes32 toAddress;\r\n        uint256 amount;\r\n        ICommonOFT.LzCallParams callParams;\r\n    }\r\n\r\n    /**\r\n     * @notice OFT `sendFrom` parameters structure (OFTWithFee)\r\n     * @param from The owner of token\r\n     * @param dstChainId The destination chain identifier\r\n     * @param toAddress Can be any size depending on the `dstChainId`\r\n     * @param amount The quantity of tokens in wei\r\n     * @param minAmount The minimum amount of tokens to receive on the destination chain\r\n     * @param callParams LayerZero call parameters\r\n     */\r\n    struct SendFromWithMinAmountParams {\r\n        address from;\r\n        uint16 dstChainId;\r\n        bytes32 toAddress;\r\n        uint256 amount;\r\n        uint256 minAmount;\r\n        ICommonOFT.LzCallParams callParams;\r\n    }\r\n\r\n    /**\r\n     * @notice OFT `sendFrom` parameters structure (OFT v1)\r\n     * @param from The owner of token\r\n     * @param dstChainId The destination chain identifier\r\n     * @param toAddress Can be any size depending on the `dstChainId`\r\n     * @param amount The quantity of tokens in wei\r\n     * @param refundAddress Refund address\r\n     * @param zroPaymentAddress ZRO payment address\r\n     * @param adapterParams LayerZero adapter parameters\r\n     */\r\n    struct SendFromV1Params {\r\n        address from;\r\n        uint16 dstChainId;\r\n        bytes toAddress;\r\n        uint256 amount;\r\n        address payable refundAddress;\r\n        address zroPaymentAddress;\r\n        bytes adapterParams;\r\n    }\r\n\r\n    /**\r\n     * @notice OFT `sendTokens` parameters structure (OmnichainFungibleToken)\r\n     * @param dstChainId Send tokens to this chainId\r\n     * @param to Where to deliver the tokens on the destination chain\r\n     * @param qty How many tokens to send\r\n     * @param zroPaymentAddress ZRO payment address\r\n     * @param adapterParam LayerZero adapter parameters\r\n     */\r\n    struct SendTokensParams {\r\n        uint16 dstChainId;\r\n        bytes to;\r\n        uint256 qty;\r\n        address zroPaymentAddress;\r\n        bytes adapterParam;\r\n    }\r\n\r\n    /**\r\n     * @notice OFT `estimateSendFee` parameters structure (OFT v2 and OFTWithFee)\r\n     * @param dstChainId The destination chain identifier\r\n     * @param toAddress Can be any size depending on the `dstChainId`\r\n     * @param amount The quantity of tokens in wei\r\n     * @param useZro The ZRO token payment flag\r\n     * @param adapterParams LayerZero adapter parameters\r\n     */\r\n    struct EstimateSendFeeParams {\r\n        uint16 dstChainId;\r\n        bytes32 toAddress;\r\n        uint256 amount;\r\n        bool useZro;\r\n        bytes adapterParams;\r\n    }\r\n\r\n    /**\r\n     * @notice OFT `estimateSendFee` parameters structure (OFT v1)\r\n     * @param dstChainId The destination chain identifier\r\n     * @param toAddress Can be any size depending on the `dstChainId`\r\n     * @param amount The quantity of tokens in wei\r\n     * @param useZro The ZRO token payment flag\r\n     * @param adapterParams LayerZero adapter parameters\r\n     */\r\n    struct EstimateSendFeeV1Params {\r\n        uint16 dstChainId;\r\n        bytes toAddress;\r\n        uint256 amount;\r\n        bool useZro;\r\n        bytes adapterParams;\r\n    }\r\n\r\n    /**\r\n     * @notice OFT `estimateSendTokensFee` parameters structure (OmnichainFungibleToken)\r\n     * @param dstChainId The destination chain identifier\r\n     * @param useZro The ZRO token payment flag\r\n     * @param txParameters LayerZero tx parameters\r\n     */\r\n    struct EstimateSendTokensFeeParams {\r\n        uint16 dstChainId;\r\n        bool useZro;\r\n        bytes txParameters;\r\n    }\r\n\r\n    uint16 private constant PT_SEND = 0;\r\n\r\n    /**\r\n     * @notice Initializes the OFTWrapper contract\r\n     * @param _feeCollector The initial address of the fee collector\r\n     * @param _owner The address of the initial owner of the contract\r\n     */\r\n    constructor(address _feeCollector, address _owner) OFTWrapperBase(_feeCollector) {\r\n        _initOFTWrapperDiamond();\r\n\r\n        if (_owner != msg.sender && _owner != address(0)) {\r\n            _setOwner(_owner);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sends tokens to the destination chain (OFT v2)\r\n     * @param _oft The address of the OFT\r\n     * @param _underlyingToken The address of the underlying token\r\n     * @param _params The `sendFrom` parameters\r\n     * @param _processingFee The processing fee value\r\n     */\r\n    function oftSendFrom(\r\n        IOFTV2 _oft,\r\n        IERC20 _underlyingToken,\r\n        SendFromParams calldata _params,\r\n        uint256 _processingFee\r\n    ) external payable whenNotPaused nonReentrant {\r\n        bool useUnderlyingToken = _beforeSendFrom(\r\n            address(_oft),\r\n            address(_underlyingToken),\r\n            _params.from,\r\n            _params.amount\r\n        );\r\n\r\n        _oft.sendFrom{ value: msg.value - _processingFee }(\r\n            useUnderlyingToken ? address(this) : _params.from,\r\n            _params.dstChainId,\r\n            _params.toAddress,\r\n            _params.amount,\r\n            _params.callParams\r\n        );\r\n\r\n        _afterSendFrom(\r\n            useUnderlyingToken,\r\n            address(_oft),\r\n            address(_underlyingToken),\r\n            _processingFee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sends tokens to the destination chain (OFTWithFee)\r\n     * @param _oft The address of the OFT\r\n     * @param _underlyingToken The address of the underlying token\r\n     * @param _params The `sendFrom` parameters\r\n     * @param _processingFee The processing fee value\r\n     */\r\n    function oftSendFromWithMinAmount(\r\n        IOFTWithFee _oft,\r\n        IERC20 _underlyingToken,\r\n        SendFromWithMinAmountParams calldata _params,\r\n        uint256 _processingFee\r\n    ) external payable whenNotPaused nonReentrant {\r\n        bool useUnderlyingToken = _beforeSendFrom(\r\n            address(_oft),\r\n            address(_underlyingToken),\r\n            _params.from,\r\n            _params.amount\r\n        );\r\n\r\n        _oft.sendFrom{ value: msg.value - _processingFee }(\r\n            useUnderlyingToken ? address(this) : _params.from,\r\n            _params.dstChainId,\r\n            _params.toAddress,\r\n            _params.amount,\r\n            _params.minAmount,\r\n            _params.callParams\r\n        );\r\n\r\n        _afterSendFrom(\r\n            useUnderlyingToken,\r\n            address(_oft),\r\n            address(_underlyingToken),\r\n            _processingFee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sends tokens to the destination chain (OFT v1)\r\n     * @param _oft The address of the OFT\r\n     * @param _underlyingToken The address of the underlying token\r\n     * @param _params The `sendFrom` parameters\r\n     * @param _processingFee The processing fee value\r\n     */\r\n    function oftSendFromV1(\r\n        IOFTCore _oft,\r\n        IERC20 _underlyingToken,\r\n        SendFromV1Params calldata _params,\r\n        uint256 _processingFee\r\n    ) external payable whenNotPaused nonReentrant {\r\n        bool useUnderlyingToken = _beforeSendFrom(\r\n            address(_oft),\r\n            address(_underlyingToken),\r\n            _params.from,\r\n            _params.amount\r\n        );\r\n\r\n        _oft.sendFrom{ value: msg.value - _processingFee }(\r\n            useUnderlyingToken ? address(this) : _params.from,\r\n            _params.dstChainId,\r\n            _params.toAddress,\r\n            _params.amount,\r\n            _params.refundAddress,\r\n            _params.zroPaymentAddress,\r\n            _params.adapterParams\r\n        );\r\n\r\n        _afterSendFrom(\r\n            useUnderlyingToken,\r\n            address(_oft),\r\n            address(_underlyingToken),\r\n            _processingFee\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Sends tokens to the destination chain (OmnichainFungibleToken)\r\n     * @param _oft The address of the OFT\r\n     * @param _params The `sendTokens` parameters\r\n     * @param _processingFee The processing fee value\r\n     */\r\n    function oftSendTokens(\r\n        IOmnichainFungibleToken _oft,\r\n        SendTokensParams calldata _params,\r\n        uint256 _processingFee\r\n    ) external payable whenNotPaused nonReentrant {\r\n        uint256 initialBalance = address(this).balance - msg.value;\r\n\r\n        /*TransferHelper.*/safeTransferFrom(address(_oft), msg.sender, address(this), _params.qty);\r\n\r\n        _oft.sendTokens{ value: msg.value - _processingFee }(\r\n            _params.dstChainId,\r\n            _params.to,\r\n            _params.qty,\r\n            address(0),\r\n            _params.adapterParam\r\n        );\r\n\r\n        /*TransferHelper.*/safeTransferNative(OFTWrapperStorage.layout().feeCollector, _processingFee);\r\n\r\n        /*RefundHelper.*/refundExtraBalance(address(this), initialBalance, payable(msg.sender));\r\n\r\n        emit OftSent();\r\n    }\r\n\r\n    /**\r\n     * @notice Estimates the cross-chain transfer fees (OFT v2 and OFTWithFee)\r\n     * @param _oft The address of the OFT\r\n     * @param _params The `estimateSendFee` parameters\r\n     * @param _processingFee The processing fee value\r\n     * @return nativeFee Native fee amount\r\n     * @return zroFee ZRO fee amount\r\n     */\r\n    function oftEstimateSendFee(\r\n        ICommonOFT _oft,\r\n        EstimateSendFeeParams calldata _params,\r\n        uint256 _processingFee\r\n    ) external view returns (uint256 nativeFee, uint256 zroFee) {\r\n        (uint256 oftNativeFee, uint256 oftZroFee) = _oft.estimateSendFee(\r\n            _params.dstChainId,\r\n            _params.toAddress,\r\n            _params.amount,\r\n            _params.useZro,\r\n            _params.adapterParams\r\n        );\r\n\r\n        return (oftNativeFee + _processingFee, oftZroFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Estimates the cross-chain transfer fees (OFT v1)\r\n     * @param _oft The address of the OFT\r\n     * @param _params The `estimateSendFee` parameters\r\n     * @param _processingFee The processing fee value\r\n     * @return nativeFee Native fee amount\r\n     * @return zroFee ZRO fee amount\r\n     */\r\n    function oftEstimateSendV1Fee(\r\n        IOFTCore _oft,\r\n        EstimateSendFeeV1Params calldata _params,\r\n        uint256 _processingFee\r\n    ) external view returns (uint256 nativeFee, uint256 zroFee) {\r\n        (uint256 oftNativeFee, uint256 oftZroFee) = _oft.estimateSendFee(\r\n            _params.dstChainId,\r\n            _params.toAddress,\r\n            _params.amount,\r\n            _params.useZro,\r\n            _params.adapterParams\r\n        );\r\n\r\n        return (oftNativeFee + _processingFee, oftZroFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Estimates the cross-chain transfer fees (OmnichainFungibleToken)\r\n     * @param _oft The address of the OFT\r\n     * @param _to Where to deliver the tokens on the destination chain\r\n     * @param _qty How many tokens to send\r\n     * @param _params The `estimateFees` parameters\r\n     * @param _processingFee The processing fee value\r\n     * @return nativeFee Native fee amount\r\n     * @return zroFee ZRO fee amount\r\n     */\r\n    function oftEstimateSendTokensFee(\r\n        IOmnichainFungibleToken _oft,\r\n        bytes calldata _to,\r\n        uint256 _qty,\r\n        EstimateSendTokensFeeParams calldata _params,\r\n        uint256 _processingFee\r\n    ) external view returns (uint256 nativeFee, uint256 zroFee) {\r\n        bytes memory payload = abi.encode(_to, _qty);\r\n\r\n        (uint256 oftNativeFee, uint256 oftZroFee) = _oft.endpoint().estimateFees(\r\n            _params.dstChainId,\r\n            address(_oft),\r\n            payload,\r\n            _params.useZro,\r\n            _params.txParameters\r\n        );\r\n\r\n        return (oftNativeFee + _processingFee, oftZroFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Destination gas parameters lookup\r\n     * @param _oftAddress The address of the OFT\r\n     * @param _targetLzChainId The destination chain ID (LayerZero-specific)\r\n     * @return useCustomParameters Custom parameters flag\r\n     * @return minTargetGas Minimum destination gas\r\n     */\r\n    function oftTargetGasParameters(\r\n        address _oftAddress,\r\n        uint16 _targetLzChainId\r\n    ) external view returns (bool useCustomParameters, uint256 minTargetGas) {\r\n        if (ILzParametersConfig(_oftAddress).useCustomAdapterParams()) {\r\n            return (\r\n                true,\r\n                ILzParametersConfig(_oftAddress).minDstGasLookup(_targetLzChainId, PT_SEND)\r\n            );\r\n        } else {\r\n            return (false, 0);\r\n        }\r\n    }\r\n\r\n    function _beforeSendFrom(\r\n        address _oftAddress,\r\n        address _underlyingTokenAddress,\r\n        address _paramsFrom,\r\n        uint256 _paramsAmount\r\n    ) private returns (bool useUnderlyingToken) {\r\n        if (_paramsFrom != msg.sender) {\r\n            revert SenderError();\r\n        }\r\n\r\n        useUnderlyingToken = (_underlyingTokenAddress != address(0));\r\n\r\n        if (useUnderlyingToken) {\r\n            /*TransferHelper.*/safeTransferFrom(\r\n                _underlyingTokenAddress,\r\n                _paramsFrom,\r\n                address(this),\r\n                _paramsAmount\r\n            );\r\n\r\n            /*TransferHelper.*/safeApprove(_underlyingTokenAddress, _oftAddress, _paramsAmount);\r\n        }\r\n    }\r\n\r\n    function _afterSendFrom(\r\n        bool _useUnderlyingToken,\r\n        address _oftAddress,\r\n        address _underlyingTokenAddress,\r\n        uint256 _processingFee\r\n    ) private {\r\n        if (_useUnderlyingToken) {\r\n            /*TransferHelper.*/safeApprove(_underlyingTokenAddress, _oftAddress, 0);\r\n        }\r\n\r\n        /*TransferHelper.*/safeTransferNative(OFTWrapperStorage.layout().feeCollector, _processingFee);\r\n\r\n        emit OftSent();\r\n    }\r\n\r\n    function _initOFTWrapperDiamond() private {\r\n        bytes4[] memory selectors = new bytes4[](8);\r\n        uint256 selectorIndex;\r\n\r\n        // register OFT functions\r\n\r\n        selectors[selectorIndex++] = OFTWrapper.oftSendFrom.selector;\r\n        selectors[selectorIndex++] = OFTWrapper.oftSendFromWithMinAmount.selector;\r\n        selectors[selectorIndex++] = OFTWrapper.oftSendFromV1.selector;\r\n        selectors[selectorIndex++] = OFTWrapper.oftSendTokens.selector;\r\n\r\n        selectors[selectorIndex++] = OFTWrapper.oftEstimateSendFee.selector;\r\n        selectors[selectorIndex++] = OFTWrapper.oftEstimateSendV1Fee.selector;\r\n        selectors[selectorIndex++] = OFTWrapper.oftEstimateSendTokensFee.selector;\r\n\r\n        selectors[selectorIndex++] = OFTWrapper.oftTargetGasParameters.selector;\r\n\r\n        // diamond cut\r\n\r\n        FacetCut[] memory facetCuts = new FacetCut[](1);\r\n\r\n        facetCuts[0] = FacetCut({\r\n            target: address(this),\r\n            action: FacetCutAction.ADD,\r\n            selectors: selectors\r\n        });\r\n\r\n        _diamondCut(facetCuts, address(0), '');\r\n    }\r\n}\r\n\r\ninterface ILzParametersConfig {\r\n    function useCustomAdapterParams() external view returns (bool);\r\n\r\n    function minDstGasLookup(uint16 _dstChainId, uint16 _type) external view returns (uint256);\r\n}\r\n\r\ninterface IOmnichainFungibleToken {\r\n    function sendTokens(\r\n        uint16 _dstChainId, // send tokens to this chainId\r\n        bytes calldata _to, // where to deliver the tokens on the destination chain\r\n        uint256 _qty, // how many tokens to send\r\n        address zroPaymentAddress, // ZRO payment address\r\n        bytes calldata adapterParam // LayerZero adapter parameters\r\n    ) external payable;\r\n\r\n    function endpoint() external view returns (ILayerZeroEndpoint);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DiamondWritable__InvalidInitializationParameters\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__RemoveTargetNotZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__ReplaceTargetIsIdentical\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorIsImmutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__SelectorNotSpecified\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondWritable__TargetHasNoCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC165Base__InvalidInterfaceId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Ownable__NotTransitiveOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Pausable__NotPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Pausable__Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Proxy__ImplementationIsNotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuard__ReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeApproveError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeOwnable__NotNomineeOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFromError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferNativeError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondWritableInternal.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondWritableInternal.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OftSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"SetFeeCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"SYSTEM_VERSION_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"cleanup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondWritableInternal.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondWritableInternal.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondReadable.Facet[]\",\"name\":\"diamondFacets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"forceTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFallbackAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fallbackAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nomineeOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICommonOFT\",\"name\":\"_oft\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"toAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useZro\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"internalType\":\"struct OFTWrapper.EstimateSendFeeParams\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_processingFee\",\"type\":\"uint256\"}],\"name\":\"oftEstimateSendFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOmnichainFungibleToken\",\"name\":\"_oft\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_to\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_qty\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"useZro\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"txParameters\",\"type\":\"bytes\"}],\"internalType\":\"struct OFTWrapper.EstimateSendTokensFeeParams\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_processingFee\",\"type\":\"uint256\"}],\"name\":\"oftEstimateSendTokensFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOFTCore\",\"name\":\"_oft\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useZro\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"internalType\":\"struct OFTWrapper.EstimateSendFeeV1Params\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_processingFee\",\"type\":\"uint256\"}],\"name\":\"oftEstimateSendV1Fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOFTV2\",\"name\":\"_oft\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_underlyingToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"toAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zroPaymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"internalType\":\"struct ICommonOFT.LzCallParams\",\"name\":\"callParams\",\"type\":\"tuple\"}],\"internalType\":\"struct OFTWrapper.SendFromParams\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_processingFee\",\"type\":\"uint256\"}],\"name\":\"oftSendFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOFTCore\",\"name\":\"_oft\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_underlyingToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"toAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zroPaymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"internalType\":\"struct OFTWrapper.SendFromV1Params\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_processingFee\",\"type\":\"uint256\"}],\"name\":\"oftSendFromV1\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOFTWithFee\",\"name\":\"_oft\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_underlyingToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"toAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"refundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zroPaymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"adapterParams\",\"type\":\"bytes\"}],\"internalType\":\"struct ICommonOFT.LzCallParams\",\"name\":\"callParams\",\"type\":\"tuple\"}],\"internalType\":\"struct OFTWrapper.SendFromWithMinAmountParams\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_processingFee\",\"type\":\"uint256\"}],\"name\":\"oftSendFromWithMinAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOmnichainFungibleToken\",\"name\":\"_oft\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"to\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"zroPaymentAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"adapterParam\",\"type\":\"bytes\"}],\"internalType\":\"struct OFTWrapper.SendTokensParams\",\"name\":\"_params\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_processingFee\",\"type\":\"uint256\"}],\"name\":\"oftSendTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oftAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_targetLzChainId\",\"type\":\"uint16\"}],\"name\":\"oftTargetGasParameters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"useCustomParameters\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minTargetGas\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fallbackAddress\",\"type\":\"address\"}],\"name\":\"setFallbackAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OFTWrapper", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000070287bd7a8e1b6deb354b0df11130b3be03d1ece00000000000000000000000072e28c7f34100afefc399fcc0ae041b8fe5841ae", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://60148cc1390d387363002d3d1db1d49c9a8bda397f332995f0bfc17ab8b5962a"}