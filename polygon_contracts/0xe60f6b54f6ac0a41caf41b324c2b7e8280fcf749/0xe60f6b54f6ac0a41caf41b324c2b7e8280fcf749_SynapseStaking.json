{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/SynapseStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport { ReentrancyGuard } from \\\"./external/openzeppelin/ReentrancyGuard.sol\\\";\\n\\nimport { Ownable } from \\\"./abstract/Ownable.sol\\\";\\nimport { RewardsDistribution } from \\\"./abstract/RewardsDistribution.sol\\\";\\nimport { StableMath } from \\\"./libraries/StableMath.sol\\\";\\nimport { SafeERC20, IERC20 } from \\\"./libraries/SafeERC20.sol\\\";\\nimport { Parameterized } from \\\"./extensions/Parameterized.sol\\\";\\n\\n/**\\n * @title  SynapseStaking\\n * @notice Rewards stakers of SNP token and a given LP token with rewards in form of SNP token, on a pro-rata basis.\\n * @dev    Uses an ever increasing 'rewardPerTokenStored' variable to distribute rewards\\n *         each time a write action is called in the contract. This allows for passive reward accrual.\\n */\\ncontract SynapseStaking is Ownable, RewardsDistribution, ReentrancyGuard, Parameterized {\\n    using StableMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice stake/reward token address\\n    address public tokenAddress;\\n    /// @notice LP stake token address\\n    address public liquidityAddress;\\n    /// @notice stake manager contract address\\n    address public stakeManager;\\n\\n    /// @notice timestamp for current period finish\\n    uint256 public periodFinish;\\n    /// @notice timestamp for current super period finish\\n    uint256 public superPeriodFinish;\\n\\n    struct Data {\\n        uint256 depositedTokens; // deposited tokens amount\\n        uint256 depositedLiquidity; // deposited lp amount\\n        uint256 totalRewardsAdded; // accumulated amount of rewards added to token and liquidity staking\\n        uint256 totalRewardsClaimed; // accumulated amount of rewards claimed\\n        uint256 totalRewardsFromFees; // accumulated amount of rewards collected from fee-on-transfer\\n    }\\n\\n    Data public data;\\n\\n    struct StakingData {\\n        uint256 rewardRate; // rewardRate for the rest of the period\\n        uint256 superRewardRate; // superRewardRate for the rest of the super period\\n        uint256 lastUpdateTime; // last time any user took action\\n        uint256 lastSuperUpdateTime; // last time super staker took action\\n        uint256 rewardPerTokenStored; // accumulated per token reward since the beginning of time\\n        uint256 superRewardPerTokenStored; // super accumulated per token reward since the beginning of time\\n        uint256 stakedTokens; // amount of tokens that is used in reward per token calculation\\n        uint256 stakedSuperTokens; // amount of tokens that is used in super reward per token calculation\\n    }\\n\\n    StakingData public tokenStaking;\\n    StakingData public lpStaking;\\n\\n    struct Stake {\\n        uint256 stakeStart; // timestamp of stake creation\\n        uint256 superStakerPossibleAt; // timestamp after which user can claim super staker status\\n        //\\n        uint256 rewardPerTokenPaid; // user accumulated per token rewards\\n        uint256 superRewardPerTokenPaid; // user accumulated per token super staker rewards\\n        //\\n        uint256 tokens; // total tokens staked by user snp or lp\\n        uint256 rewards; // current not-claimed rewards from last update\\n        //\\n        uint256 withdrawalPossibleAt; // timestamp after which stake can be removed without fee\\n        bool isWithdrawing; // true = user call to remove stake\\n        bool isSuperStaker; // true = user is super staker\\n    }\\n\\n    /// @dev each holder have one stake\\n    /// @notice token stakes storage\\n    mapping(address => Stake) public tokenStake;\\n    /// @notice LP token stakes storage\\n    mapping(address => Stake) public liquidityStake;\\n\\n    /// @dev events\\n    event Claimed(address indexed user, uint256 amount);\\n    event StakeAdded(address indexed user, uint256 amount);\\n    event StakeLiquidityAdded(address indexed user, uint256 amount);\\n    event StakeRemoveRequested(address indexed user);\\n    event StakeLiquidityRemoveRequested(address indexed user);\\n    event StakeRemoved(address indexed user, uint256 amount);\\n    event StakeLiquidityRemoved(address indexed user, uint256 amount);\\n    event Recalculation(uint256 reward, uint256 lpReward);\\n    event SuperRecalculation(uint256 superReward, uint256 superLpReward);\\n\\n    /**\\n     * @param _timeToSuper time needed to become a super staker\\n     * @param _timeToUnstake time needed to unstake without fee\\n     */\\n    constructor(uint256 _timeToSuper, uint256 _timeToUnstake) {\\n        timeToSuper.value = _timeToSuper;\\n        timeToUnstake.value = _timeToUnstake;\\n        timeToSuper.lastChange = block.timestamp;\\n        timeToUnstake.lastChange = block.timestamp;\\n        timeToSuper.minDelay = WEEK;\\n        timeToUnstake.minDelay = WEEK;\\n        unstakeFee.value = 1000;\\n    }\\n\\n    /**\\n     * @dev One time initialization function\\n     * @param _token SNP token address\\n     * @param _liquidity SNP/USDC LP token address\\n     */\\n    function init(address _token, address _liquidity) external onlyOwner {\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\n        require(_liquidity != address(0), \\\"_liquidity address cannot be 0\\\");\\n        require(tokenAddress == address(0), \\\"Init already done\\\");\\n        tokenAddress = _token;\\n        liquidityAddress = _liquidity;\\n    }\\n\\n    /**\\n     * @dev Updates the reward for a given address,\\n     *      for token and LP pool, before executing function\\n     * @param _account address of staker for which rewards will be updated\\n     */\\n    modifier updateRewards(address _account) {\\n        _updateReward(_account, false);\\n        _updateReward(_account, true);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Updates the reward for a given address,\\n     *      for given pool, before executing function\\n     * @param _account address for which rewards will be updated\\n     * @param _lp true=lpStaking, false=tokenStaking\\n     */\\n    modifier updateReward(address _account, bool _lp) {\\n        _updateReward(_account, _lp);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Updates the super rewards for a given address,\\n     *      for token and LP pool, before executing function\\n     * @param _account address of super staker for which super rewards will be updated\\n     */\\n    modifier updateSuperRewards(address _account) {\\n        bool success = _updateSuperReward(_account, false);\\n        success = _updateSuperReward(_account, true) || success;\\n        if (success) {\\n            _calculateSuperRewardAmount();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev guards that the given address has selected stake\\n     * @param _account address to check\\n     * @param _lp true=lpStaking, false=tokenStaking\\n     */\\n    modifier hasPoolStake(address _account, bool _lp) {\\n        bool accountHasStake = _lp ? (liquidityStake[_account].tokens > 0) : (tokenStake[_account].tokens > 0);\\n        require(accountHasStake, \\\"Nothing staked\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev guards that the msg.sender has token or LP stake\\n     */\\n    modifier hasStake() {\\n        require((liquidityStake[msg.sender].tokens > 0) || (tokenStake[msg.sender].tokens > 0), \\\"Nothing staked\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev guards that the given address can be a super staker in selected stake\\n     * @param _account address to check\\n     * @param _lp true=lpStaking, false=tokenStaking\\n     */\\n    modifier canBeSuper(address _account, bool _lp) {\\n        Stake memory s = _lp ? liquidityStake[_account] : tokenStake[_account];\\n        require(!s.isWithdrawing, \\\"Cannot when withdrawing\\\");\\n        require(!s.isSuperStaker, \\\"Already super staker\\\");\\n        require(block.timestamp >= s.superStakerPossibleAt, \\\"Too soon\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev checks if the msg.sender can withdraw requested unstake\\n     */\\n    modifier canUnstake() {\\n        require(_canUnstake(), \\\"Cannot unstake\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev checks if for the msg.sender there is possibility to\\n     *      withdraw staked tokens without fee.\\n     */\\n    modifier cantUnstake() {\\n        require(!_canUnstake(), \\\"Unstake first\\\");\\n        _;\\n    }\\n\\n    /***************************************\\n                    ACTIONS\\n    ****************************************/\\n\\n    /**\\n     * @dev Updates reward in selected pool\\n     * @param _account address for which rewards will be updated\\n     * @param _lp true=lpStaking, false=tokenStaking\\n     */\\n    function _updateReward(address _account, bool _lp) internal {\\n        uint256 newRewardPerTokenStored = currentRewardPerTokenStored(_lp);\\n        // if statement protects against loss in initialization case\\n        if (newRewardPerTokenStored > 0) {\\n            StakingData storage sd = _lp ? lpStaking : tokenStaking;\\n            sd.rewardPerTokenStored = newRewardPerTokenStored;\\n            sd.lastUpdateTime = lastTimeRewardApplicable();\\n\\n            // setting of personal vars based on new globals\\n            if (_account != address(0)) {\\n                Stake storage s = _lp ? liquidityStake[_account] : tokenStake[_account];\\n                if (!s.isWithdrawing) {\\n                    s.rewards = _earned(_account, _lp);\\n                    s.rewardPerTokenPaid = newRewardPerTokenStored;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates super reward in selected pool\\n     * @param _account address of super staker for which super rewards will be updated\\n     * @param _lp true=lpStaking, false=tokenStaking\\n     */\\n    function _updateSuperReward(address _account, bool _lp) internal returns (bool success) {\\n        Stake storage s = _lp ? liquidityStake[_account] : tokenStake[_account];\\n        // save gas for non super stakers\\n        if (s.isSuperStaker || _account == address(0)) {\\n            uint256 newSuperRewardPerTokenStored = currentSuperRewardPerTokenStored(_lp);\\n            // if statement protects against loss in initialization case\\n            if (newSuperRewardPerTokenStored > 0) {\\n                StakingData storage sd = _lp ? lpStaking : tokenStaking;\\n                sd.superRewardPerTokenStored = newSuperRewardPerTokenStored;\\n                sd.lastSuperUpdateTime = lastTimeSuperRewardApplicable();\\n\\n                // setting of personal vars based on new globals\\n                if (_account != address(0)) {\\n                    // setting of personal vars based on new globals\\n                    if (!s.isWithdrawing) {\\n                        s.rewards = _earnedSuper(_account, _lp);\\n                        s.superRewardPerTokenPaid = newSuperRewardPerTokenStored;\\n                    }\\n                }\\n            }\\n\\n            success = true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Add tokens to stake for desired address from external contract\\n     * @param _account staker address\\n     * @param _amount number of tokens sent to contract\\n     */\\n    function onStake(address _account, uint256 _amount) external nonReentrant updateReward(_account, false) updateSuperRewards(_account) {\\n        require(msg.sender == stakeManager, \\\"Only stake manager\\\");\\n        require(!tokenStake[_account].isWithdrawing, \\\"Cannot when withdrawing\\\");\\n        require(_amount > 0, \\\"Zero Amount\\\");\\n\\n        Stake storage s = tokenStake[_account];\\n        StakingData storage sd = tokenStaking;\\n\\n        if (s.stakeStart == 0) {\\n            // new stake\\n            s.stakeStart = block.timestamp;\\n            s.superStakerPossibleAt = s.stakeStart + timeToSuper.value;\\n        }\\n\\n        // update account stake data\\n        s.tokens += _amount;\\n\\n        // update pool staking data\\n        sd.stakedTokens += _amount;\\n        if (s.isSuperStaker) {\\n            sd.stakedSuperTokens += _amount;\\n        }\\n\\n        // update global data\\n        data.depositedTokens += _amount;\\n\\n        emit StakeAdded(_account, _amount);\\n    }\\n\\n    /**\\n     * @dev Add tokens to staking contract\\n     * @param _amount of tokens to stake\\n     */\\n    function addTokenStake(uint256 _amount) external {\\n        _addStake(msg.sender, _amount, false);\\n        emit StakeAdded(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @dev Add tokens to staking contract by using permit to set allowance\\n     * @param _amount of tokens to stake\\n     * @param _deadline of permit signature\\n     * @param _approveMax allowance for the token\\n     */\\n    function addTokenStakeWithPermit(\\n        uint256 _amount,\\n        uint256 _deadline,\\n        bool _approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        uint256 value = _approveMax ? type(uint256).max : _amount;\\n        IERC20(tokenAddress).permit(msg.sender, address(this), value, _deadline, v, r, s);\\n        _addStake(msg.sender, _amount, false);\\n        emit StakeAdded(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @dev Add liquidity tokens to staking contract\\n     * @param _amount of LP tokens to stake\\n     */\\n    function addLiquidityStake(uint256 _amount) external {\\n        _addStake(msg.sender, _amount, true);\\n        emit StakeLiquidityAdded(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @dev Add liquidity tokens to staking contract\\n     * @param _amount of tokens to stake\\n     * @param _deadline of permit signature\\n     * @param _approveMax allowance for the token\\n     */\\n    function addLiquidityStakeWithPermit(\\n        uint256 _amount,\\n        uint256 _deadline,\\n        bool _approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        uint256 value = _approveMax ? type(uint256).max : _amount;\\n        IERC20(liquidityAddress).permit(msg.sender, address(this), value, _deadline, v, r, s);\\n        _addStake(msg.sender, _amount, true);\\n        emit StakeLiquidityAdded(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @dev Internal add stake function\\n     * @param _account selected staked tokens are credited to this address\\n     * @param _amount of staked tokens\\n     * @param _lp true=LP token, false=SNP token\\n     */\\n    function _addStake(\\n        address _account,\\n        uint256 _amount,\\n        bool _lp\\n    ) internal nonReentrant updateReward(_account, _lp) updateSuperRewards(_account) {\\n        require(_amount > 0, \\\"Zero Amount\\\");\\n        Stake storage s = _lp ? liquidityStake[_account] : tokenStake[_account];\\n        require(!s.isWithdrawing, \\\"Cannot when withdrawing\\\");\\n\\n        address token = _lp ? liquidityAddress : tokenAddress;\\n\\n        // check for fee-on-transfer and proceed with received amount\\n        _amount = _transferFrom(token, msg.sender, _amount);\\n\\n        if (s.stakeStart == 0) {\\n            // new stake\\n            s.stakeStart = block.timestamp;\\n            s.superStakerPossibleAt = s.stakeStart + timeToSuper.value;\\n        }\\n\\n        StakingData storage sd = _lp ? lpStaking : tokenStaking;\\n\\n        // update account stake data\\n        s.tokens += _amount;\\n\\n        // update pool staking data\\n        sd.stakedTokens += _amount;\\n        if (s.isSuperStaker) {\\n            sd.stakedSuperTokens += _amount;\\n        }\\n\\n        // update global data\\n        if (_lp) {\\n            data.depositedLiquidity += _amount;\\n        } else {\\n            data.depositedTokens += _amount;\\n        }\\n    }\\n\\n    /**\\n     * @dev Restake earned tokens and add them to token stake (instead of claiming)\\n     *      If have LP stake but not token stake - token stake will be created.\\n     */\\n    function restake() external hasStake updateRewards(msg.sender) updateSuperRewards(msg.sender) {\\n        Stake storage ts = tokenStake[msg.sender];\\n        Stake storage ls = liquidityStake[msg.sender];\\n        require(!ts.isWithdrawing, \\\"Cannot when withdrawing\\\");\\n\\n        uint256 rewards = ts.rewards + ls.rewards;\\n        require(rewards > 0, \\\"Nothing to restake\\\");\\n\\n        delete ts.rewards;\\n        delete ls.rewards;\\n\\n        if (ts.stakeStart == 0) {\\n            // new stake\\n            ts.stakeStart = block.timestamp;\\n            ts.superStakerPossibleAt = ts.stakeStart + timeToSuper.value;\\n        }\\n\\n        // update account stake data\\n        ts.tokens += rewards;\\n\\n        // update pool staking data\\n        tokenStaking.stakedTokens += rewards;\\n        if (ts.isSuperStaker) {\\n            tokenStaking.stakedSuperTokens += rewards;\\n        }\\n\\n        data.totalRewardsClaimed += rewards;\\n        data.depositedTokens += rewards;\\n\\n        emit Claimed(msg.sender, rewards);\\n        emit StakeAdded(msg.sender, rewards);\\n    }\\n\\n    /**\\n     * @dev Claims rewards for the msg.sender.\\n     */\\n    function claim() external {\\n        _claim(msg.sender, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Claim msg.sender rewards to provided address\\n     * @param _recipient address where claimed tokens should be sent\\n     */\\n    function claimTo(address _recipient) external {\\n        _claim(msg.sender, _recipient);\\n    }\\n\\n    /**\\n     * @dev Internal claim function. First updates rewards in normal and super pools\\n     *      and then transfers.\\n     * @param _account claim rewards for this address\\n     * @param _recipient claimed tokens are sent to this address\\n     */\\n    function _claim(address _account, address _recipient) internal nonReentrant hasStake updateRewards(_account) updateSuperRewards(_account) {\\n        uint256 rewards = tokenStake[_account].rewards + liquidityStake[_account].rewards;\\n\\n        require(rewards > 0, \\\"Nothing to claim\\\");\\n\\n        delete tokenStake[_account].rewards;\\n        delete liquidityStake[_account].rewards;\\n\\n        data.totalRewardsClaimed += rewards;\\n        _transfer(tokenAddress, _recipient, rewards);\\n\\n        emit Claimed(_account, rewards);\\n    }\\n\\n    /**\\n     * @dev Request unstake for deposited tokens. Marks user token stake as withdrawing,\\n     *      and start withdrawing period.\\n     */\\n    function requestUnstake() external {\\n        _requestUnstake(msg.sender, false);\\n        emit StakeRemoveRequested(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Request unstake for deposited LP tokens. Marks user lp stake as withdrawing\\n     *      and start withdrawing period.\\n     */\\n    function requestUnstakeLp() external {\\n        _requestUnstake(msg.sender, true);\\n        emit StakeLiquidityRemoveRequested(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Internal request unstake function. Update normal and super rewards for the user first.\\n     * @param _account User address\\n     * @param _lp true=it is LP stake\\n     */\\n    function _requestUnstake(address _account, bool _lp)\\n        internal\\n        hasPoolStake(_account, _lp)\\n        updateReward(_account, _lp)\\n        updateSuperRewards(_account)\\n    {\\n        Stake storage s = _lp ? liquidityStake[_account] : tokenStake[_account];\\n        require(!s.isWithdrawing, \\\"Cannot when withdrawing\\\");\\n        StakingData storage sd = _lp ? lpStaking : tokenStaking;\\n\\n        // update account stake data\\n        s.isWithdrawing = true;\\n        s.withdrawalPossibleAt = block.timestamp + timeToUnstake.value;\\n\\n        // update pool staking data\\n        sd.stakedTokens -= s.tokens;\\n        if (s.isSuperStaker) {\\n            delete s.isSuperStaker;\\n            sd.stakedSuperTokens -= s.tokens;\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraw stake for msg.sender from both stakes (if possible)\\n     */\\n    function unstake() external nonReentrant hasStake canUnstake {\\n        bool success;\\n        uint256 reward;\\n        uint256 tokens;\\n        uint256 rewards;\\n\\n        (reward, success) = _unstake(msg.sender, false);\\n        rewards += reward;\\n        if (success) {\\n            tokens += tokenStake[msg.sender].tokens;\\n            data.depositedTokens -= tokenStake[msg.sender].tokens;\\n            emit StakeRemoved(msg.sender, tokenStake[msg.sender].tokens);\\n            delete tokenStake[msg.sender];\\n        }\\n\\n        (reward, success) = _unstake(msg.sender, true);\\n        rewards += reward;\\n        if (success) {\\n            delete liquidityStake[msg.sender];\\n        }\\n\\n        if (tokens + rewards > 0) {\\n            _transfer(tokenAddress, msg.sender, tokens + rewards);\\n            if (rewards > 0) {\\n                emit Claimed(msg.sender, rewards);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal unstake function, withdraw staked LP tokens\\n     * @param _account address of account to transfer LP tokens\\n     * @param _lp true = LP stake\\n     * @return stake rewards amount\\n     * @return bool true if success\\n     */\\n    function _unstake(address _account, bool _lp) internal returns (uint256, bool) {\\n        Stake memory s = _lp ? liquidityStake[_account] : tokenStake[_account];\\n        if (!s.isWithdrawing) return (0, false);\\n        if (s.withdrawalPossibleAt > block.timestamp) return (0, false);\\n\\n        data.totalRewardsClaimed += s.rewards;\\n\\n        // only LP stake\\n        if (_lp && s.tokens > 0) {\\n            data.depositedLiquidity -= s.tokens;\\n            _transfer(liquidityAddress, _account, s.tokens);\\n            emit StakeLiquidityRemoved(_account, s.tokens);\\n        }\\n\\n        return (s.rewards, true);\\n    }\\n\\n    /**\\n     * @dev Unstake requested stake at any time accepting 10% penalty fee\\n     */\\n    function unstakeWithFee() external nonReentrant hasStake cantUnstake {\\n        Stake memory ts = tokenStake[msg.sender];\\n        Stake memory ls = liquidityStake[msg.sender];\\n        uint256 tokens;\\n        uint256 rewards;\\n\\n        if (ls.isWithdrawing) {\\n            uint256 lpTokens = _minusFee(ls.tokens); //remaining tokens remain on the contract\\n\\n            rewards += ls.rewards;\\n\\n            data.totalRewardsClaimed += ls.rewards;\\n            data.depositedLiquidity -= ls.tokens;\\n            emit StakeLiquidityRemoved(msg.sender, ls.tokens);\\n\\n            if (lpTokens > 0) {\\n                _transfer(liquidityAddress, msg.sender, lpTokens);\\n            }\\n\\n            delete liquidityStake[msg.sender];\\n        }\\n\\n        if (ts.isWithdrawing) {\\n            tokens = _minusFee(ts.tokens); // remaining tokens goes to Super Stakers\\n\\n            rewards += ts.rewards;\\n\\n            data.totalRewardsClaimed += ts.rewards;\\n            data.depositedTokens -= ts.tokens;\\n            emit StakeRemoved(msg.sender, ts.tokens);\\n\\n            delete tokenStake[msg.sender];\\n        }\\n\\n        if (tokens + rewards > 0) {\\n            _transfer(tokenAddress, msg.sender, tokens + rewards);\\n            if (rewards > 0) {\\n                emit Claimed(msg.sender, rewards);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Set Super Staker status for token pool stake if possible.\\n     */\\n    function setSuperToken() external {\\n        _setSuper(msg.sender, false);\\n    }\\n\\n    /**\\n     * @dev Set Super Staker status for LP pool stake if possible.\\n     */\\n    function setSuperLp() external {\\n        _setSuper(msg.sender, true);\\n    }\\n\\n    /**\\n     * @dev Set Super Staker status if possible for selected pool.\\n     *      Update super reward pools.\\n     * @param _account address of account to set super\\n     * @param _lp true=LP stake super staker, false=token stake super staker\\n     */\\n    function _setSuper(address _account, bool _lp)\\n        internal\\n        hasPoolStake(_account, _lp)\\n        canBeSuper(_account, _lp)\\n        updateSuperRewards(address(0))\\n    {\\n        Stake storage s = _lp ? liquidityStake[_account] : tokenStake[_account];\\n        StakingData storage sd = _lp ? lpStaking : tokenStaking;\\n\\n        sd.stakedSuperTokens += s.tokens;\\n\\n        s.isSuperStaker = true;\\n        s.superRewardPerTokenPaid = sd.superRewardPerTokenStored;\\n    }\\n\\n    /**\\n     * @dev Set stake manager address for onStake functionality\\n     */\\n    function setStakeManager(address _stakeManager) external onlyOwner {\\n        stakeManager = _stakeManager;\\n    }\\n\\n    /***************************************\\n                    GETTERS\\n    ****************************************/\\n\\n    /**\\n     * @dev Gets the last applicable timestamp for this reward period\\n     */\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return StableMath.min(block.timestamp, periodFinish);\\n    }\\n\\n    /**\\n     * @dev Gets the last applicable timestamp for this super reward period\\n     */\\n    function lastTimeSuperRewardApplicable() public view returns (uint256) {\\n        return StableMath.min(block.timestamp, superPeriodFinish);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount of unclaimed rewards per token since last update,\\n     *      and sums with stored to give the new cumulative reward per token\\n     * @param _lp true=lpStaking, false=tokenStaking\\n     * @return 'Reward' per staked token\\n     */\\n    function currentRewardPerTokenStored(bool _lp) public view returns (uint256) {\\n        StakingData memory sd = _lp ? lpStaking : tokenStaking;\\n        uint256 stakedTokens = sd.stakedTokens;\\n        uint256 rewardPerTokenStored = sd.rewardPerTokenStored;\\n        // If there is no staked tokens, avoid div(0)\\n        if (stakedTokens == 0) {\\n            return (rewardPerTokenStored);\\n        }\\n        // new reward units to distribute = rewardRate * timeSinceLastUpdate\\n        uint256 timeDelta = lastTimeRewardApplicable() - sd.lastUpdateTime;\\n        uint256 rewardUnitsToDistribute = sd.rewardRate * timeDelta;\\n        // new reward units per token = (rewardUnitsToDistribute * 1e18) / stakedTokens\\n        uint256 unitsToDistributePerToken = rewardUnitsToDistribute.divPrecisely(stakedTokens);\\n        // return summed rate\\n        return (rewardPerTokenStored + unitsToDistributePerToken);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount of unclaimed super rewards per token since last update,\\n     * and sums with stored to give the new cumulative reward per token\\n     * @param _lp true=lpStaking, false=tokenStaking\\n     * @return 'Reward' per staked token\\n     */\\n    function currentSuperRewardPerTokenStored(bool _lp) public view returns (uint256) {\\n        StakingData memory sd = _lp ? lpStaking : tokenStaking;\\n        uint256 stakedSuperTokens = sd.stakedSuperTokens;\\n        uint256 superRewardPerTokenStored = sd.superRewardPerTokenStored;\\n        // If there is no staked tokens, avoid div(0)\\n        if (stakedSuperTokens == 0) {\\n            return (superRewardPerTokenStored);\\n        }\\n\\n        // new reward units to distribute = superRewardRate * timeSinceLastSuperUpdate\\n        uint256 timeDelta = lastTimeSuperRewardApplicable() - sd.lastSuperUpdateTime;\\n        uint256 rewardUnitsToDistribute = sd.superRewardRate * timeDelta;\\n        // new reward units per token = (rewardUnitsToDistribute * 1e18) / totalSuperTokens\\n        uint256 unitsToDistributePerToken = rewardUnitsToDistribute.divPrecisely(stakedSuperTokens);\\n\\n        // return summed rate\\n        return (superRewardPerTokenStored + unitsToDistributePerToken);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount of unclaimed rewards a user has earned\\n     * @param _account user address\\n     * @param _lp true=liquidityStake, false=tokenStake\\n     * @return Total reward amount earned\\n     */\\n    function _earned(address _account, bool _lp) internal view returns (uint256) {\\n        Stake memory s = _lp ? liquidityStake[_account] : tokenStake[_account];\\n        if (s.isWithdrawing) return s.rewards;\\n        // current rate per token - rate user previously received\\n        uint256 rewardPerTokenStored = currentRewardPerTokenStored(_lp);\\n        uint256 userRewardDelta = rewardPerTokenStored - s.rewardPerTokenPaid;\\n        uint256 userNewReward = s.tokens.mulTruncate(userRewardDelta);\\n        // add to previous rewards\\n        return (s.rewards + userNewReward);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount of unclaimed super rewards a user has earned\\n     * @param _account user address\\n     * @param _lp true=liquidityStake, false=tokenStake\\n     * @return Total reward amount earned\\n     */\\n    function _earnedSuper(address _account, bool _lp) internal view returns (uint256) {\\n        Stake memory s = _lp ? liquidityStake[_account] : tokenStake[_account];\\n        if (!s.isSuperStaker || s.isWithdrawing) return s.rewards;\\n        // current rate per token - rate user previously received\\n        uint256 superRewardPerTokenStored = currentSuperRewardPerTokenStored(_lp);\\n        uint256 superRewardDelta = superRewardPerTokenStored - s.superRewardPerTokenPaid;\\n        uint256 userNewSuperReward = s.tokens.mulTruncate(superRewardDelta);\\n        // add to previous rewards\\n        return (s.rewards + userNewSuperReward);\\n    }\\n\\n    /**\\n     * @dev Calculates the claimable amounts for token and lp stake from normal and super rewards\\n     * @param _account user address\\n     * @return token - claimable reward amount for token stake\\n     * @return lp - claimable reward amount for lp stake\\n     */\\n    function claimable(address _account) external view returns (uint256 token, uint256 lp) {\\n        token = _earned(_account, false) + _earnedSuper(_account, false) - tokenStake[_account].rewards;\\n        lp = _earned(_account, true) + _earnedSuper(_account, true) - liquidityStake[_account].rewards;\\n    }\\n\\n    /**\\n     * @dev Check if staker can set super staker status on token or LP stake\\n     * @param _account address to check\\n     * @return token true if can set super staker on token stake\\n     * @return lp true if can set super staker on LP stake\\n     */\\n    function canSetSuper(address _account) external view returns (bool token, bool lp) {\\n        Stake memory ts = tokenStake[_account];\\n        Stake memory ls = liquidityStake[_account];\\n        if (ts.tokens > 0 && block.timestamp >= ts.superStakerPossibleAt && !ts.isSuperStaker && !ts.isWithdrawing) token = true;\\n        if (ls.tokens > 0 && block.timestamp >= ls.superStakerPossibleAt && !ls.isSuperStaker && !ls.isWithdrawing) lp = true;\\n    }\\n\\n    /**\\n     * @dev internal view to check if msg.sender can unstake\\n     * @return true if user requested unstake and time for unstake has passed\\n     */\\n    function _canUnstake() private view returns (bool) {\\n        return\\n            (liquidityStake[msg.sender].isWithdrawing && block.timestamp >= liquidityStake[msg.sender].withdrawalPossibleAt) ||\\n            (tokenStake[msg.sender].isWithdrawing && block.timestamp >= tokenStake[msg.sender].withdrawalPossibleAt);\\n    }\\n\\n    /**\\n     * @dev external view to check if address can stake tokens\\n     * @return true if user can stake tokens\\n     */\\n    function canStakeTokens(address _account) external view returns (bool) {\\n        return !tokenStake[_account].isWithdrawing;\\n    }\\n\\n    /**\\n     * @dev external view to check if address can stake lp\\n     * @return true if user can stake lp\\n     */\\n    function canStakeLp(address _account) external view returns (bool) {\\n        return !liquidityStake[_account].isWithdrawing;\\n    }\\n\\n    /***************************************\\n                    REWARDER\\n    ****************************************/\\n\\n    /**\\n     * @dev Notifies the contract that new rewards have been added.\\n     *      Calculates an updated rewardRate based on the rewards in period.\\n     * @param _reward Units of SNP token that have been added to the token pool\\n     * @param _lpReward Units of SNP token that have been added to the lp pool\\n     */\\n    function notifyRewardAmount(uint256 _reward, uint256 _lpReward) external onlyRewardsDistributor updateRewards(address(0)) {\\n        uint256 currentTime = block.timestamp;\\n\\n        // pull tokens\\n        require(_transferFrom(tokenAddress, msg.sender, _reward + _lpReward) == _reward + _lpReward, \\\"Exclude Rewarder from fee\\\");\\n\\n        // If previous period over, reset rewardRate\\n        if (currentTime >= periodFinish) {\\n            tokenStaking.rewardRate = _reward / WEEK;\\n            lpStaking.rewardRate = _lpReward / WEEK;\\n        }\\n        // If additional reward to existing period, calc sum\\n        else {\\n            uint256 remaining = periodFinish - currentTime;\\n\\n            uint256 leftoverReward = remaining * tokenStaking.rewardRate;\\n            tokenStaking.rewardRate = (_reward + leftoverReward) / WEEK;\\n\\n            uint256 leftoverLpReward = remaining * lpStaking.rewardRate;\\n            lpStaking.rewardRate = (_lpReward + leftoverLpReward) / WEEK;\\n        }\\n\\n        tokenStaking.lastUpdateTime = currentTime;\\n        lpStaking.lastUpdateTime = currentTime;\\n        periodFinish = currentTime + WEEK;\\n\\n        data.totalRewardsAdded += _reward + _lpReward;\\n\\n        emit Recalculation(_reward, _lpReward);\\n    }\\n\\n    /***************************************\\n                    SUPER STAKER\\n    ****************************************/\\n\\n    /**\\n     * @dev Notifies the contract that new super rewards have been added based on the collected fee.\\n     *      Calculates an updated superRewardRate based on the rewards in period.\\n     *      Function can be triggered by any super staker once a day.\\n     */\\n    function _calculateSuperRewardAmount() internal {\\n        uint256 currentTime = block.timestamp;\\n        // Do nothing if less then a day from last calculation, save gas\\n        uint256 lastTime = superPeriodFinish > 0 ? superPeriodFinish - (MONTH - 1 days) : 0;\\n        if (currentTime >= lastTime) {\\n            uint256 contractBalance = _balance(tokenAddress, address(this));\\n            uint256 feesCollected = contractBalance -\\n                data.depositedTokens -\\n                (data.totalRewardsAdded + data.totalRewardsFromFees - data.totalRewardsClaimed);\\n            data.totalRewardsFromFees += feesCollected;\\n\\n            uint256 superRewards;\\n            unchecked {\\n                superRewards = feesCollected / 2;\\n            }\\n\\n            // If previous period over, reset rewardRate\\n            if (currentTime >= superPeriodFinish) {\\n                tokenStaking.superRewardRate = superRewards / MONTH;\\n                lpStaking.superRewardRate = superRewards / MONTH;\\n            }\\n            // If additional reward to existing period, calc sum\\n            else {\\n                uint256 remaining = superPeriodFinish - currentTime;\\n\\n                uint256 leftoverSuperReward = remaining * tokenStaking.superRewardRate;\\n                tokenStaking.superRewardRate = (superRewards + leftoverSuperReward) / MONTH;\\n\\n                uint256 leftoverSuperLpReward = remaining * lpStaking.superRewardRate;\\n                lpStaking.superRewardRate = (superRewards + leftoverSuperLpReward) / MONTH;\\n            }\\n\\n            tokenStaking.lastSuperUpdateTime = currentTime;\\n            lpStaking.lastSuperUpdateTime = currentTime;\\n            superPeriodFinish = currentTime + MONTH;\\n\\n            emit SuperRecalculation(superRewards, superRewards);\\n        }\\n    }\\n\\n    /***************************************\\n                    TOKEN\\n    ****************************************/\\n\\n    /**\\n     * @dev internal ERC20 tools\\n     */\\n\\n    function _balance(address token, address user) internal view returns (uint256) {\\n        return IERC20(token).balanceOf(user);\\n    }\\n\\n    function _transferFrom(\\n        address token,\\n        address from,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        return IERC20(token).safeTransferFromDeluxe(from, amount);\\n    }\\n\\n    function _transfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        IERC20(token).safeTransfer(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nabstract contract OwnableData {\\n    address public owner;\\n    address public pendingOwner;\\n}\\n\\nabstract contract Ownable is OwnableData {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev `owner` defaults to msg.sender on construction.\\n     */\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\n     *      Can only be invoked by the current `owner`.\\n     * @param _newOwner Address of the new owner.\\n     * @param _direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\\n     */\\n    function transferOwnership(address _newOwner, bool _direct) external onlyOwner {\\n        if (_direct) {\\n            require(_newOwner != address(0), \\\"zero address\\\");\\n\\n            emit OwnershipTransferred(owner, _newOwner);\\n            owner = _newOwner;\\n            pendingOwner = address(0);\\n        } else {\\n            pendingOwner = _newOwner;\\n        }\\n    }\\n\\n    /**\\n     * @dev Needs to be called by `pendingOwner` to claim ownership.\\n     */\\n    function claimOwnership() external {\\n        address _pendingOwner = pendingOwner;\\n        require(msg.sender == _pendingOwner, \\\"caller != pending owner\\\");\\n\\n        emit OwnershipTransferred(owner, _pendingOwner);\\n        owner = _pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the Owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function _setOwner(address newOwner) internal {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/RewardsDistribution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\n\\nabstract contract RewardsDistributionData {\\n    address public rewardsDistributor;\\n}\\n\\nabstract contract RewardsDistribution is Ownable, RewardsDistributionData {\\n    event RewardsDistributorChanged(address indexed previousDistributor, address indexed newDistributor);\\n\\n    /**\\n     * @dev `rewardsDistributor` defaults to msg.sender on construction.\\n     */\\n    constructor() {\\n        rewardsDistributor = msg.sender;\\n        emit RewardsDistributorChanged(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the Reward Distributor.\\n     */\\n    modifier onlyRewardsDistributor() {\\n        require(msg.sender == rewardsDistributor, \\\"caller is not reward distributor\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Change the rewardsDistributor - only called by owner\\n     * @param _rewardsDistributor Address of the new distributor\\n     */\\n    function setRewardsDistribution(address _rewardsDistributor) external onlyOwner {\\n        require(_rewardsDistributor != address(0), \\\"zero address\\\");\\n\\n        emit RewardsDistributorChanged(rewardsDistributor, _rewardsDistributor);\\n        rewardsDistributor = _rewardsDistributor;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/Parameterized.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport { Ownable } from \\\"../abstract/Ownable.sol\\\";\\n\\npragma solidity 0.8.6;\\n\\ncontract Parameterized is Ownable {\\n    uint256 internal constant WEEK = 7 days;\\n    uint256 internal constant MONTH = 30 days;\\n\\n    struct StakeParameters {\\n        uint256 value;\\n        uint256 lastChange;\\n        uint256 minDelay;\\n    }\\n\\n    /// @notice time to allow to be Super Staker (30*24*60*60)\\n    StakeParameters public timeToSuper;\\n    /// @notice time to wait for unstake (7*24*60*60)\\n    StakeParameters public timeToUnstake;\\n\\n    /// @notice fee for premature unstake in 1/10 percent,\\n    /// @dev value 1000 = 10%\\n    StakeParameters public unstakeFee;\\n\\n    function _minusFee(uint256 val) internal view returns (uint256) {\\n        return val - ((val * unstakeFee.value) / 10000);\\n    }\\n\\n    function updateFee(uint256 val) external onlyOwner {\\n        require(block.timestamp > unstakeFee.lastChange + unstakeFee.minDelay, \\\"Soon\\\");\\n        require(val <= 2500, \\\"max fee is 25%\\\");\\n        unstakeFee.lastChange = block.timestamp;\\n        unstakeFee.value = val;\\n    }\\n\\n    function updateTimeToUnstake(uint256 val) external onlyOwner {\\n        require(block.timestamp > timeToUnstake.lastChange + timeToUnstake.minDelay, \\\"Soon\\\");\\n        require(val <= 2 * WEEK, \\\"Max delay is 14 days\\\");\\n        timeToUnstake.lastChange = block.timestamp;\\n        timeToUnstake.value = val;\\n    }\\n\\n    function updateTimeToSuper(uint256 val) external onlyOwner {\\n        require(block.timestamp > timeToSuper.lastChange + timeToSuper.minDelay, \\\"Soon\\\");\\n        require(val <= 3 * MONTH && val >= WEEK, \\\"Delay is 1 week - 3 months\\\");\\n        timeToSuper.lastChange = block.timestamp;\\n        timeToSuper.value = val;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    // EIP 2612\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function nonces(address owner) external view returns (uint256);\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport { IERC20 } from \\\"../interfaces/IERC20.sol\\\";\\n\\nlibrary SafeERC20 {\\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n    }\\n\\n    function safeName(IERC20 token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\\n        return success && data.length > 0 ? abi.decode(data, (string)) : \\\"???\\\";\\n    }\\n\\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"SafeERC20: Transfer failed\\\");\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"SafeERC20: TransferFrom failed\\\");\\n    }\\n\\n    function safeTransferFromDeluxe(IERC20 token, address from, uint256 amount) internal returns (uint256) {\\n        uint256 preBalance = token.balanceOf(address(this));\\n        safeTransferFrom(token, from, amount);\\n        uint256 postBalance = token.balanceOf(address(this));\\n        return postBalance - preBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/StableMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n// Based on StableMath from mStable\\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\\n\\nlibrary StableMath {\\n    /**\\n     * @dev Scaling unit for use in specific calculations,\\n     * where 1 * 10**18, or 1e18 represents a unit '1'\\n     */\\n    uint256 private constant FULL_SCALE = 1e18;\\n\\n    /**\\n     * @dev Provides an interface to the scaling unit\\n     * @return Scaling unit (1e18 or 1 * 10**18)\\n     */\\n    function getFullScale() internal pure returns (uint256) {\\n        return FULL_SCALE;\\n    }\\n\\n    /**\\n     * @dev Scales a given integer to the power of the full scale.\\n     * @param x   Simple uint256 to scale\\n     * @return    Scaled value a to an exact number\\n     */\\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\\n        return x * FULL_SCALE;\\n    }\\n\\n    /***************************************\\n              PRECISE ARITHMETIC\\n    ****************************************/\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulTruncateScale(x, y, FULL_SCALE);\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @param scale Scale unit\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncateScale(\\n        uint256 x,\\n        uint256 y,\\n        uint256 scale\\n    ) internal pure returns (uint256) {\\n        // e.g. assume scale = fullScale\\n        // z = 10e18 * 9e17 = 9e36\\n        // return 9e36 / 1e18 = 9e18\\n        return (x * y) / scale;\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit, rounded up to the closest base unit.\\n     */\\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e17 * 17268172638 = 138145381104e17\\n        uint256 scaled = x * y;\\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\\n        uint256 ceil = scaled + FULL_SCALE - 1;\\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\\n        return ceil / FULL_SCALE;\\n    }\\n\\n    /**\\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\\n     * @param x     Left hand input to division\\n     * @param y     Right hand input to division\\n     * @return      Result after multiplying the left operand by the scale, and\\n     *              executing the division on the right hand input.\\n     */\\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e18 * 1e18 = 8e36\\n        // e.g. 8e36 / 10e18 = 8e17\\n        return (x * FULL_SCALE) / y;\\n    }\\n\\n    /***************************************\\n                    HELPERS\\n    ****************************************/\\n\\n    /**\\n     * @dev Calculates minimum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Minimum of the two inputs\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? y : x;\\n    }\\n\\n    /**\\n     * @dev Calculated maximum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Maximum of the two inputs\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? x : y;\\n    }\\n\\n    /**\\n     * @dev Clamps a value to an upper bound\\n     * @param x           Left hand input\\n     * @param upperBound  Maximum possible value to return\\n     * @return            Input x clamped to a maximum value, upperBound\\n     */\\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\\n        return x > upperBound ? upperBound : x;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeToSuper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeToUnstake\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpReward\",\"type\":\"uint256\"}],\"name\":\"Recalculation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousDistributor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDistributor\",\"type\":\"address\"}],\"name\":\"RewardsDistributorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeLiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"StakeLiquidityRemoveRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeLiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"StakeRemoveRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"superReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"superLpReward\",\"type\":\"uint256\"}],\"name\":\"SuperRecalculation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"addLiquidityStakeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addTokenStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"addTokenStakeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"canSetSuper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"token\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"lp\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"canStakeLp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"canStakeTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"claimTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lp\",\"type\":\"bool\"}],\"name\":\"currentRewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lp\",\"type\":\"bool\"}],\"name\":\"currentSuperRewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositedLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsFromFees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeSuperRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superStakerPossibleAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerTokenPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superRewardPerTokenPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalPossibleAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWithdrawing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSuperStaker\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superRewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSuperUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerTokenStored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superRewardPerTokenStored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedSuperTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpReward\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"onStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestUnstakeLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsDistributor\",\"type\":\"address\"}],\"name\":\"setRewardsDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeManager\",\"type\":\"address\"}],\"name\":\"setStakeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSuperLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSuperToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superPeriodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToSuper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastChange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastChange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superStakerPossibleAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerTokenPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superRewardPerTokenPaid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalPossibleAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWithdrawing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSuperStaker\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superRewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSuperUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerTokenStored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"superRewardPerTokenStored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedSuperTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_direct\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastChange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeWithFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"updateTimeToSuper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"updateTimeToUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SynapseStaking", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000278d000000000000000000000000000000000000000000000000000000000000093a80", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}