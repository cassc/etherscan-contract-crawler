{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/persistent/vault/interfaces/IExternalPositionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPositionVault interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// Provides an interface to get the externalPositionLib for a given type from the Vault\\ninterface IExternalPositionVault {\\n    function getExternalPositionLibForType(uint256) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/interfaces/IFreelyTransferableSharesVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IFreelyTransferableSharesVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Provides the interface for determining whether a vault's shares\\n/// are guaranteed to be freely transferable.\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IFreelyTransferableSharesVault {\\n    function sharesAreFreelyTransferable()\\n        external\\n        view\\n        returns (bool sharesAreFreelyTransferable_);\\n}\\n\"\r\n    },\r\n    \"contracts/persistent/vault/interfaces/IMigratableVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IMigratableVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IMigratableVault {\\n    function canMigrate(address _who) external view returns (bool canMigrate_);\\n\\n    function init(\\n        address _owner,\\n        address _accessor,\\n        string calldata _fundName\\n    ) external;\\n\\n    function setAccessor(address _nextAccessor) external;\\n\\n    function setVaultLib(address _nextVaultLib) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund-deployer/IFundDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IFundDeployer Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IFundDeployer {\\n    function getOwner() external view returns (address);\\n\\n    function hasReconfigurationRequest(address) external view returns (bool);\\n\\n    function isAllowedBuySharesOnBehalfCaller(address) external view returns (bool);\\n\\n    function isAllowedVaultCall(\\n        address,\\n        bytes4,\\n        bytes32\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund/comptroller/IComptroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../vault/IVault.sol\\\";\\n\\n/// @title IComptroller Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IComptroller {\\n    function activate(bool) external;\\n\\n    function calcGav() external returns (uint256);\\n\\n    function calcGrossShareValue() external returns (uint256);\\n\\n    function callOnExtension(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external;\\n\\n    function destructActivated(uint256, uint256) external;\\n\\n    function destructUnactivated() external;\\n\\n    function getDenominationAsset() external view returns (address);\\n\\n    function getExternalPositionManager() external view returns (address);\\n\\n    function getFeeManager() external view returns (address);\\n\\n    function getFundDeployer() external view returns (address);\\n\\n    function getGasRelayPaymaster() external view returns (address);\\n\\n    function getIntegrationManager() external view returns (address);\\n\\n    function getPolicyManager() external view returns (address);\\n\\n    function getVaultProxy() external view returns (address);\\n\\n    function init(address, uint256) external;\\n\\n    function permissionedVaultAction(IVault.VaultAction, bytes calldata) external;\\n\\n    function preTransferSharesHook(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function preTransferSharesHookFreelyTransferable(address) external view;\\n\\n    function setGasRelayPaymaster(address) external;\\n\\n    function setVaultProxy(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/core/fund/vault/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../../../persistent/vault/interfaces/IExternalPositionVault.sol\\\";\\nimport \\\"../../../../persistent/vault/interfaces/IFreelyTransferableSharesVault.sol\\\";\\nimport \\\"../../../../persistent/vault/interfaces/IMigratableVault.sol\\\";\\n\\n/// @title IVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IVault is IMigratableVault, IFreelyTransferableSharesVault, IExternalPositionVault {\\n    enum VaultAction {\\n        None,\\n        // Shares management\\n        BurnShares,\\n        MintShares,\\n        TransferShares,\\n        // Asset management\\n        AddTrackedAsset,\\n        ApproveAssetSpender,\\n        RemoveTrackedAsset,\\n        WithdrawAssetTo,\\n        // External position management\\n        AddExternalPosition,\\n        CallOnExternalPosition,\\n        RemoveExternalPosition\\n    }\\n\\n    function addTrackedAsset(address) external;\\n\\n    function burnShares(address, uint256) external;\\n\\n    function buyBackProtocolFeeShares(\\n        uint256,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function callOnContract(address, bytes calldata) external returns (bytes memory);\\n\\n    function canManageAssets(address) external view returns (bool);\\n\\n    function canRelayCalls(address) external view returns (bool);\\n\\n    function getAccessor() external view returns (address);\\n\\n    function getOwner() external view returns (address);\\n\\n    function getActiveExternalPositions() external view returns (address[] memory);\\n\\n    function getTrackedAssets() external view returns (address[] memory);\\n\\n    function isActiveExternalPosition(address) external view returns (bool);\\n\\n    function isTrackedAsset(address) external view returns (bool);\\n\\n    function mintShares(address, uint256) external;\\n\\n    function payProtocolFee() external;\\n\\n    function receiveValidatedVaultAction(VaultAction, bytes calldata) external;\\n\\n    function setAccessorForFundReconfiguration(address) external;\\n\\n    function setSymbol(string calldata) external;\\n\\n    function transferShares(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function withdrawAssetTo(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/IExtension.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExtension Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for all extensions\\ninterface IExtension {\\n    function activateForFund(bool _isMigration) external;\\n\\n    function deactivateForFund() external;\\n\\n    function receiveCallFromComptroller(\\n        address _caller,\\n        uint256 _actionId,\\n        bytes calldata _callArgs\\n    ) external;\\n\\n    function setConfigForFund(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes calldata _configData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/policy-manager/IPolicy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IPolicyManager.sol\\\";\\n\\n/// @title Policy Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IPolicy {\\n    function activateForFund(address _comptrollerProxy) external;\\n\\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings) external;\\n\\n    function canDisable() external pure returns (bool canDisable_);\\n\\n    function identifier() external pure returns (string memory identifier_);\\n\\n    function implementedHooks()\\n        external\\n        pure\\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_);\\n\\n    function updateFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\\n        external;\\n\\n    function validateRule(\\n        address _comptrollerProxy,\\n        IPolicyManager.PolicyHook _hook,\\n        bytes calldata _encodedArgs\\n    ) external returns (bool isValid_);\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/policy-manager/IPolicyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/// @title PolicyManager Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for the PolicyManager\\ninterface IPolicyManager {\\n    // When updating PolicyHook, also update these functions in PolicyManager:\\n    // 1. __getAllPolicyHooks()\\n    // 2. __policyHookRestrictsCurrentInvestorActions()\\n    enum PolicyHook {\\n        PostBuyShares,\\n        PostCallOnIntegration,\\n        PreTransferShares,\\n        RedeemSharesForSpecificAssets,\\n        AddTrackedAssets,\\n        RemoveTrackedAssets,\\n        CreateExternalPosition,\\n        PostCallOnExternalPosition,\\n        RemoveExternalPosition,\\n        ReactivateExternalPosition\\n    }\\n\\n    function validatePolicies(\\n        address,\\n        PolicyHook,\\n        bytes calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/policy-manager/PolicyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../core/fund/comptroller/IComptroller.sol\\\";\\nimport \\\"../../core/fund/vault/IVault.sol\\\";\\nimport \\\"../../infrastructure/gas-relayer/GasRelayRecipientMixin.sol\\\";\\nimport \\\"../../utils/AddressArrayLib.sol\\\";\\nimport \\\"../utils/ExtensionBase.sol\\\";\\nimport \\\"./IPolicy.sol\\\";\\nimport \\\"./IPolicyManager.sol\\\";\\n\\n/// @title PolicyManager Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Manages policies for funds\\n/// @dev Any arbitrary fee is allowed by default, so all participants must be aware of\\n/// their fund's configuration, especially whether they use official policies only.\\n/// Policies that restrict current investors can only be added upon fund setup, migration, or reconfiguration.\\n/// Policies that restrict new investors or asset management actions can be added at any time.\\n/// Policies themselves specify whether or not they are allowed to be updated or removed.\\ncontract PolicyManager is IPolicyManager, ExtensionBase, GasRelayRecipientMixin {\\n    using AddressArrayLib for address[];\\n\\n    event PolicyDisabledOnHookForFund(\\n        address indexed comptrollerProxy,\\n        address indexed policy,\\n        PolicyHook indexed hook\\n    );\\n\\n    event PolicyEnabledForFund(\\n        address indexed comptrollerProxy,\\n        address indexed policy,\\n        bytes settingsData\\n    );\\n\\n    uint256 private constant POLICY_HOOK_COUNT = 10;\\n\\n    mapping(address => mapping(PolicyHook => address[])) private comptrollerProxyToHookToPolicies;\\n\\n    modifier onlyFundOwner(address _comptrollerProxy) {\\n        require(\\n            __msgSender() == IVault(getVaultProxyForFund(_comptrollerProxy)).getOwner(),\\n            \\\"Only the fund owner can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _fundDeployer, address _gasRelayPaymasterFactory)\\n        public\\n        ExtensionBase(_fundDeployer)\\n        GasRelayRecipientMixin(_gasRelayPaymasterFactory)\\n    {}\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @notice Validates and initializes policies as necessary prior to fund activation\\n    /// @param _isMigratedFund True if the fund is migrating to this release\\n    /// @dev There will be no enabledPolicies if the caller is not a valid ComptrollerProxy\\n    function activateForFund(bool _isMigratedFund) external override {\\n        address comptrollerProxy = msg.sender;\\n\\n        // Policies must assert that they are congruent with migrated vault state\\n        if (_isMigratedFund) {\\n            address[] memory enabledPolicies = getEnabledPoliciesForFund(comptrollerProxy);\\n            for (uint256 i; i < enabledPolicies.length; i++) {\\n                __activatePolicyForFund(comptrollerProxy, enabledPolicies[i]);\\n            }\\n        }\\n    }\\n\\n    /// @notice Disables a policy for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _policy The policy address to disable\\n    /// @dev If an arbitrary policy changes its `implementedHooks()` return values after it is\\n    /// already enabled on a fund, then this will not correctly disable the policy from any\\n    /// removed hook values.\\n    function disablePolicyForFund(address _comptrollerProxy, address _policy)\\n        external\\n        onlyFundOwner(_comptrollerProxy)\\n    {\\n        require(IPolicy(_policy).canDisable(), \\\"disablePolicyForFund: _policy cannot be disabled\\\");\\n\\n        PolicyHook[] memory implementedHooks = IPolicy(_policy).implementedHooks();\\n        for (uint256 i; i < implementedHooks.length; i++) {\\n\\n                bool disabled\\n             = comptrollerProxyToHookToPolicies[_comptrollerProxy][implementedHooks[i]]\\n                .removeStorageItem(_policy);\\n            if (disabled) {\\n                emit PolicyDisabledOnHookForFund(_comptrollerProxy, _policy, implementedHooks[i]);\\n            }\\n        }\\n    }\\n\\n    /// @notice Enables a policy for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _policy The policy address to enable\\n    /// @param _settingsData The encoded settings data with which to configure the policy\\n    /// @dev Disabling a policy does not delete fund config on the policy, so if a policy is\\n    /// disabled and then enabled again, its initial state will be the previous config. It is the\\n    /// policy's job to determine how to merge that config with the _settingsData param in this function.\\n    function enablePolicyForFund(\\n        address _comptrollerProxy,\\n        address _policy,\\n        bytes calldata _settingsData\\n    ) external onlyFundOwner(_comptrollerProxy) {\\n        PolicyHook[] memory implementedHooks = IPolicy(_policy).implementedHooks();\\n        for (uint256 i; i < implementedHooks.length; i++) {\\n            require(\\n                !__policyHookRestrictsCurrentInvestorActions(implementedHooks[i]),\\n                \\\"enablePolicyForFund: _policy restricts actions of current investors\\\"\\n            );\\n        }\\n\\n        __enablePolicyForFund(_comptrollerProxy, _policy, _settingsData, implementedHooks);\\n\\n        __activatePolicyForFund(_comptrollerProxy, _policy);\\n    }\\n\\n    /// @notice Enable policies for use in a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _vaultProxy The VaultProxy of the fund\\n    /// @param _configData Encoded config data\\n    function setConfigForFund(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes calldata _configData\\n    ) external override onlyFundDeployer {\\n        __setValidatedVaultProxy(_comptrollerProxy, _vaultProxy);\\n\\n        // In case there are no policies yet\\n        if (_configData.length == 0) {\\n            return;\\n        }\\n\\n        (address[] memory policies, bytes[] memory settingsData) = abi.decode(\\n            _configData,\\n            (address[], bytes[])\\n        );\\n\\n        // Sanity check\\n        require(\\n            policies.length == settingsData.length,\\n            \\\"setConfigForFund: policies and settingsData array lengths unequal\\\"\\n        );\\n\\n        // Enable each policy with settings\\n        for (uint256 i; i < policies.length; i++) {\\n            __enablePolicyForFund(\\n                _comptrollerProxy,\\n                policies[i],\\n                settingsData[i],\\n                IPolicy(policies[i]).implementedHooks()\\n            );\\n        }\\n    }\\n\\n    /// @notice Updates policy settings for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _policy The Policy contract to update\\n    /// @param _settingsData The encoded settings data with which to update the policy config\\n    function updatePolicySettingsForFund(\\n        address _comptrollerProxy,\\n        address _policy,\\n        bytes calldata _settingsData\\n    ) external onlyFundOwner(_comptrollerProxy) {\\n        IPolicy(_policy).updateFundSettings(_comptrollerProxy, _settingsData);\\n    }\\n\\n    /// @notice Validates all policies that apply to a given hook for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _hook The PolicyHook for which to validate policies\\n    /// @param _validationData The encoded data with which to validate the filtered policies\\n    function validatePolicies(\\n        address _comptrollerProxy,\\n        PolicyHook _hook,\\n        bytes calldata _validationData\\n    ) external override {\\n        // Return as quickly as possible if no policies to run\\n        address[] memory policies = getEnabledPoliciesOnHookForFund(_comptrollerProxy, _hook);\\n        if (policies.length == 0) {\\n            return;\\n        }\\n\\n        // Limit calls to trusted components, in case policies update local storage upon runs\\n        require(\\n            msg.sender == _comptrollerProxy ||\\n                msg.sender == IComptroller(_comptrollerProxy).getIntegrationManager() ||\\n                msg.sender == IComptroller(_comptrollerProxy).getExternalPositionManager(),\\n            \\\"validatePolicies: Caller not allowed\\\"\\n        );\\n\\n        for (uint256 i; i < policies.length; i++) {\\n            require(\\n                IPolicy(policies[i]).validateRule(_comptrollerProxy, _hook, _validationData),\\n                string(\\n                    abi.encodePacked(\\n                        \\\"Rule evaluated to false: \\\",\\n                        IPolicy(policies[i]).identifier()\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    // PRIVATE FUNCTIONS\\n\\n    /// @dev Helper to activate a policy for a fund\\n    function __activatePolicyForFund(address _comptrollerProxy, address _policy) private {\\n        IPolicy(_policy).activateForFund(_comptrollerProxy);\\n    }\\n\\n    /// @dev Helper to set config and enable policies for a fund\\n    function __enablePolicyForFund(\\n        address _comptrollerProxy,\\n        address _policy,\\n        bytes memory _settingsData,\\n        PolicyHook[] memory _hooks\\n    ) private {\\n        // Set fund config on policy\\n        if (_settingsData.length > 0) {\\n            IPolicy(_policy).addFundSettings(_comptrollerProxy, _settingsData);\\n        }\\n\\n        // Add policy\\n        for (uint256 i; i < _hooks.length; i++) {\\n            require(\\n                !policyIsEnabledOnHookForFund(_comptrollerProxy, _hooks[i], _policy),\\n                \\\"__enablePolicyForFund: Policy is already enabled\\\"\\n            );\\n            comptrollerProxyToHookToPolicies[_comptrollerProxy][_hooks[i]].push(_policy);\\n        }\\n\\n        emit PolicyEnabledForFund(_comptrollerProxy, _policy, _settingsData);\\n    }\\n\\n    /// @dev Helper to get all the hooks available to policies\\n    function __getAllPolicyHooks()\\n        private\\n        pure\\n        returns (PolicyHook[POLICY_HOOK_COUNT] memory hooks_)\\n    {\\n        return [\\n            PolicyHook.PostBuyShares,\\n            PolicyHook.PostCallOnIntegration,\\n            PolicyHook.PreTransferShares,\\n            PolicyHook.RedeemSharesForSpecificAssets,\\n            PolicyHook.AddTrackedAssets,\\n            PolicyHook.RemoveTrackedAssets,\\n            PolicyHook.CreateExternalPosition,\\n            PolicyHook.PostCallOnExternalPosition,\\n            PolicyHook.RemoveExternalPosition,\\n            PolicyHook.ReactivateExternalPosition\\n        ];\\n    }\\n\\n    /// @dev Helper to check if a policy hook restricts the actions of current investors.\\n    /// These hooks should not allow policy additions post-deployment or post-migration.\\n    function __policyHookRestrictsCurrentInvestorActions(PolicyHook _hook)\\n        private\\n        pure\\n        returns (bool restrictsActions_)\\n    {\\n        return\\n            _hook == PolicyHook.PreTransferShares ||\\n            _hook == PolicyHook.RedeemSharesForSpecificAssets;\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Get a list of enabled policies for the given fund\\n    /// @param _comptrollerProxy The ComptrollerProxy\\n    /// @return enabledPolicies_ The array of enabled policy addresses\\n    function getEnabledPoliciesForFund(address _comptrollerProxy)\\n        public\\n        view\\n        returns (address[] memory enabledPolicies_)\\n    {\\n        PolicyHook[POLICY_HOOK_COUNT] memory hooks = __getAllPolicyHooks();\\n\\n        for (uint256 i; i < hooks.length; i++) {\\n            enabledPolicies_ = enabledPolicies_.mergeArray(\\n                getEnabledPoliciesOnHookForFund(_comptrollerProxy, hooks[i])\\n            );\\n        }\\n\\n        return enabledPolicies_;\\n    }\\n\\n    /// @notice Get a list of enabled policies that run on a given hook for the given fund\\n    /// @param _comptrollerProxy The ComptrollerProxy\\n    /// @param _hook The PolicyHook\\n    /// @return enabledPolicies_ The array of enabled policy addresses\\n    function getEnabledPoliciesOnHookForFund(address _comptrollerProxy, PolicyHook _hook)\\n        public\\n        view\\n        returns (address[] memory enabledPolicies_)\\n    {\\n        return comptrollerProxyToHookToPolicies[_comptrollerProxy][_hook];\\n    }\\n\\n    /// @notice Check whether a given policy runs on a given hook for a given fund\\n    /// @param _comptrollerProxy The ComptrollerProxy\\n    /// @param _hook The PolicyHook\\n    /// @param _policy The policy\\n    /// @return isEnabled_ True if the policy is enabled\\n    function policyIsEnabledOnHookForFund(\\n        address _comptrollerProxy,\\n        PolicyHook _hook,\\n        address _policy\\n    ) public view returns (bool isEnabled_) {\\n        return getEnabledPoliciesOnHookForFund(_comptrollerProxy, _hook).contains(_policy);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/extensions/utils/ExtensionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../utils/FundDeployerOwnerMixin.sol\\\";\\nimport \\\"../IExtension.sol\\\";\\n\\n/// @title ExtensionBase Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Base class for an extension\\nabstract contract ExtensionBase is IExtension, FundDeployerOwnerMixin {\\n    event ValidatedVaultProxySetForFund(\\n        address indexed comptrollerProxy,\\n        address indexed vaultProxy\\n    );\\n\\n    mapping(address => address) internal comptrollerProxyToVaultProxy;\\n\\n    modifier onlyFundDeployer() {\\n        require(msg.sender == getFundDeployer(), \\\"Only the FundDeployer can make this call\\\");\\n        _;\\n    }\\n\\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\\n\\n    /// @notice Allows extension to run logic during fund activation\\n    /// @dev Unimplemented by default, may be overridden.\\n    function activateForFund(bool) external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Allows extension to run logic during fund deactivation (destruct)\\n    /// @dev Unimplemented by default, may be overridden.\\n    function deactivateForFund() external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Receives calls from ComptrollerLib.callOnExtension()\\n    /// and dispatches the appropriate action\\n    /// @dev Unimplemented by default, may be overridden.\\n    function receiveCallFromComptroller(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual override {\\n        revert(\\\"receiveCallFromComptroller: Unimplemented for Extension\\\");\\n    }\\n\\n    /// @notice Allows extension to run logic during fund configuration\\n    /// @dev Unimplemented by default, may be overridden.\\n    function setConfigForFund(\\n        address,\\n        address,\\n        bytes calldata\\n    ) external virtual override {\\n        return;\\n    }\\n\\n    /// @dev Helper to store the validated ComptrollerProxy-VaultProxy relation\\n    function __setValidatedVaultProxy(address _comptrollerProxy, address _vaultProxy) internal {\\n        comptrollerProxyToVaultProxy[_comptrollerProxy] = _vaultProxy;\\n\\n        emit ValidatedVaultProxySetForFund(_comptrollerProxy, _vaultProxy);\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the verified VaultProxy for a given ComptrollerProxy\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @return vaultProxy_ The VaultProxy of the fund\\n    function getVaultProxyForFund(address _comptrollerProxy)\\n        public\\n        view\\n        returns (address vaultProxy_)\\n    {\\n        return comptrollerProxyToVaultProxy[_comptrollerProxy];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/gas-relayer/GasRelayRecipientMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\nimport \\\"../../utils/beacon-proxy/IBeaconProxyFactory.sol\\\";\\nimport \\\"./IGasRelayPaymaster.sol\\\";\\n\\npragma solidity 0.6.12;\\n\\n/// @title GasRelayRecipientMixin Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A mixin that enables receiving GSN-relayed calls\\n/// @dev IMPORTANT: Do not use storage var in this contract,\\n/// unless it is no longer inherited by the VaultLib\\nabstract contract GasRelayRecipientMixin {\\n    address internal immutable GAS_RELAY_PAYMASTER_FACTORY;\\n\\n    constructor(address _gasRelayPaymasterFactory) internal {\\n        GAS_RELAY_PAYMASTER_FACTORY = _gasRelayPaymasterFactory;\\n    }\\n\\n    /// @dev Helper to parse the canonical sender of a tx based on whether it has been relayed\\n    function __msgSender() internal view returns (address payable canonicalSender_) {\\n        if (msg.data.length >= 24 && msg.sender == getGasRelayTrustedForwarder()) {\\n            assembly {\\n                canonicalSender_ := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n\\n            return canonicalSender_;\\n        }\\n\\n        return msg.sender;\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `GAS_RELAY_PAYMASTER_FACTORY` variable\\n    /// @return gasRelayPaymasterFactory_ The `GAS_RELAY_PAYMASTER_FACTORY` variable value\\n    function getGasRelayPaymasterFactory()\\n        public\\n        view\\n        returns (address gasRelayPaymasterFactory_)\\n    {\\n        return GAS_RELAY_PAYMASTER_FACTORY;\\n    }\\n\\n    /// @notice Gets the trusted forwarder for GSN relaying\\n    /// @return trustedForwarder_ The trusted forwarder\\n    function getGasRelayTrustedForwarder() public view returns (address trustedForwarder_) {\\n        return\\n            IGasRelayPaymaster(\\n                IBeaconProxyFactory(getGasRelayPaymasterFactory()).getCanonicalLib()\\n            )\\n                .trustedForwarder();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/infrastructure/gas-relayer/IGasRelayPaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../interfaces/IGsnPaymaster.sol\\\";\\n\\n/// @title IGasRelayPaymaster Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGasRelayPaymaster is IGsnPaymaster {\\n    function deposit() external;\\n\\n    function withdrawBalance() external;\\n}\\n\"\r\n    },\r\n    \"contracts/release/interfaces/IGsnForwarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IGsnForwarder interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGsnForwarder {\\n    struct ForwardRequest {\\n        address from;\\n        address to;\\n        uint256 value;\\n        uint256 gas;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 validUntil;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/interfaces/IGsnPaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IGsnTypes.sol\\\";\\n\\n/// @title IGsnPaymaster interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGsnPaymaster {\\n    struct GasAndDataLimits {\\n        uint256 acceptanceBudget;\\n        uint256 preRelayedCallGasLimit;\\n        uint256 postRelayedCallGasLimit;\\n        uint256 calldataSizeLimit;\\n    }\\n\\n    function getGasAndDataLimits() external view returns (GasAndDataLimits memory limits);\\n\\n    function getHubAddr() external view returns (address);\\n\\n    function getRelayHubDeposit() external view returns (uint256);\\n\\n    function preRelayedCall(\\n        IGsnTypes.RelayRequest calldata relayRequest,\\n        bytes calldata signature,\\n        bytes calldata approvalData,\\n        uint256 maxPossibleGas\\n    ) external returns (bytes memory context, bool rejectOnRecipientRevert);\\n\\n    function postRelayedCall(\\n        bytes calldata context,\\n        bool success,\\n        uint256 gasUseWithoutPost,\\n        IGsnTypes.RelayData calldata relayData\\n    ) external;\\n\\n    function trustedForwarder() external view returns (address);\\n\\n    function versionPaymaster() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/release/interfaces/IGsnTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IGsnForwarder.sol\\\";\\n\\n/// @title IGsnTypes Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGsnTypes {\\n    struct RelayData {\\n        uint256 gasPrice;\\n        uint256 pctRelayFee;\\n        uint256 baseRelayFee;\\n        address relayWorker;\\n        address paymaster;\\n        address forwarder;\\n        bytes paymasterData;\\n        uint256 clientId;\\n    }\\n\\n    struct RelayRequest {\\n        IGsnForwarder.ForwardRequest request;\\n        RelayData relayData;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/utils/AddressArrayLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title AddressArray Library\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A library to extend the address array data type\\nlibrary AddressArrayLib {\\n    /////////////\\n    // STORAGE //\\n    /////////////\\n\\n    /// @dev Helper to remove an item from a storage array\\n    function removeStorageItem(address[] storage _self, address _itemToRemove)\\n        internal\\n        returns (bool removed_)\\n    {\\n        uint256 itemCount = _self.length;\\n        for (uint256 i; i < itemCount; i++) {\\n            if (_self[i] == _itemToRemove) {\\n                if (i < itemCount - 1) {\\n                    _self[i] = _self[itemCount - 1];\\n                }\\n                _self.pop();\\n                removed_ = true;\\n                break;\\n            }\\n        }\\n\\n        return removed_;\\n    }\\n\\n    ////////////\\n    // MEMORY //\\n    ////////////\\n\\n    /// @dev Helper to add an item to an array. Does not assert uniqueness of the new item.\\n    function addItem(address[] memory _self, address _itemToAdd)\\n        internal\\n        pure\\n        returns (address[] memory nextArray_)\\n    {\\n        nextArray_ = new address[](_self.length + 1);\\n        for (uint256 i; i < _self.length; i++) {\\n            nextArray_[i] = _self[i];\\n        }\\n        nextArray_[_self.length] = _itemToAdd;\\n\\n        return nextArray_;\\n    }\\n\\n    /// @dev Helper to add an item to an array, only if it is not already in the array.\\n    function addUniqueItem(address[] memory _self, address _itemToAdd)\\n        internal\\n        pure\\n        returns (address[] memory nextArray_)\\n    {\\n        if (contains(_self, _itemToAdd)) {\\n            return _self;\\n        }\\n\\n        return addItem(_self, _itemToAdd);\\n    }\\n\\n    /// @dev Helper to verify if an array contains a particular value\\n    function contains(address[] memory _self, address _target)\\n        internal\\n        pure\\n        returns (bool doesContain_)\\n    {\\n        for (uint256 i; i < _self.length; i++) {\\n            if (_target == _self[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /// @dev Helper to merge the unique items of a second array.\\n    /// Does not consider uniqueness of either array, only relative uniqueness.\\n    /// Preserves ordering.\\n    function mergeArray(address[] memory _self, address[] memory _arrayToMerge)\\n        internal\\n        pure\\n        returns (address[] memory nextArray_)\\n    {\\n        uint256 newUniqueItemCount;\\n        for (uint256 i; i < _arrayToMerge.length; i++) {\\n            if (!contains(_self, _arrayToMerge[i])) {\\n                newUniqueItemCount++;\\n            }\\n        }\\n\\n        if (newUniqueItemCount == 0) {\\n            return _self;\\n        }\\n\\n        nextArray_ = new address[](_self.length + newUniqueItemCount);\\n        for (uint256 i; i < _self.length; i++) {\\n            nextArray_[i] = _self[i];\\n        }\\n        uint256 nextArrayIndex = _self.length;\\n        for (uint256 i; i < _arrayToMerge.length; i++) {\\n            if (!contains(_self, _arrayToMerge[i])) {\\n                nextArray_[nextArrayIndex] = _arrayToMerge[i];\\n                nextArrayIndex++;\\n            }\\n        }\\n\\n        return nextArray_;\\n    }\\n\\n    /// @dev Helper to verify if array is a set of unique values.\\n    /// Does not assert length > 0.\\n    function isUniqueSet(address[] memory _self) internal pure returns (bool isUnique_) {\\n        if (_self.length <= 1) {\\n            return true;\\n        }\\n\\n        uint256 arrayLength = _self.length;\\n        for (uint256 i; i < arrayLength; i++) {\\n            for (uint256 j = i + 1; j < arrayLength; j++) {\\n                if (_self[i] == _self[j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @dev Helper to remove items from an array. Removes all matching occurrences of each item.\\n    /// Does not assert uniqueness of either array.\\n    function removeItems(address[] memory _self, address[] memory _itemsToRemove)\\n        internal\\n        pure\\n        returns (address[] memory nextArray_)\\n    {\\n        if (_itemsToRemove.length == 0) {\\n            return _self;\\n        }\\n\\n        bool[] memory indexesToRemove = new bool[](_self.length);\\n        uint256 remainingItemsCount = _self.length;\\n        for (uint256 i; i < _self.length; i++) {\\n            if (contains(_itemsToRemove, _self[i])) {\\n                indexesToRemove[i] = true;\\n                remainingItemsCount--;\\n            }\\n        }\\n\\n        if (remainingItemsCount == _self.length) {\\n            nextArray_ = _self;\\n        } else if (remainingItemsCount > 0) {\\n            nextArray_ = new address[](remainingItemsCount);\\n            uint256 nextArrayIndex;\\n            for (uint256 i; i < _self.length; i++) {\\n                if (!indexesToRemove[i]) {\\n                    nextArray_[nextArrayIndex] = _self[i];\\n                    nextArrayIndex++;\\n                }\\n            }\\n        }\\n\\n        return nextArray_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/utils/FundDeployerOwnerMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../core/fund-deployer/IFundDeployer.sol\\\";\\n\\n/// @title FundDeployerOwnerMixin Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A mixin contract that defers ownership to the owner of FundDeployer\\nabstract contract FundDeployerOwnerMixin {\\n    address internal immutable FUND_DEPLOYER;\\n\\n    modifier onlyFundDeployerOwner() {\\n        require(\\n            msg.sender == getOwner(),\\n            \\\"onlyFundDeployerOwner: Only the FundDeployer owner can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _fundDeployer) public {\\n        FUND_DEPLOYER = _fundDeployer;\\n    }\\n\\n    /// @notice Gets the owner of this contract\\n    /// @return owner_ The owner\\n    /// @dev Ownership is deferred to the owner of the FundDeployer contract\\n    function getOwner() public view returns (address owner_) {\\n        return IFundDeployer(FUND_DEPLOYER).getOwner();\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `FUND_DEPLOYER` variable\\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\\n    function getFundDeployer() public view returns (address fundDeployer_) {\\n        return FUND_DEPLOYER;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/release/utils/beacon-proxy/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IBeacon interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IBeacon {\\n    function getCanonicalLib() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/release/utils/beacon-proxy/IBeaconProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\nimport \\\"./IBeacon.sol\\\";\\n\\npragma solidity 0.6.12;\\n\\n/// @title IBeaconProxyFactory interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IBeaconProxyFactory is IBeacon {\\n    function deployProxy(bytes memory _constructData) external returns (address proxy_);\\n\\n    function setCanonicalLib(address _canonicalLib) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gasRelayPaymasterFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"policy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum IPolicyManager.PolicyHook\",\"name\":\"hook\",\"type\":\"uint8\"}],\"name\":\"PolicyDisabledOnHookForFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"policy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"settingsData\",\"type\":\"bytes\"}],\"name\":\"PolicyEnabledForFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vaultProxy\",\"type\":\"address\"}],\"name\":\"ValidatedVaultProxySetForFund\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isMigratedFund\",\"type\":\"bool\"}],\"name\":\"activateForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivateForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"}],\"name\":\"disablePolicyForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_settingsData\",\"type\":\"bytes\"}],\"name\":\"enablePolicyForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"}],\"name\":\"getEnabledPoliciesForFund\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"enabledPolicies_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyManager.PolicyHook\",\"name\":\"_hook\",\"type\":\"uint8\"}],\"name\":\"getEnabledPoliciesOnHookForFund\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"enabledPolicies_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFundDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fundDeployer_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGasRelayPaymasterFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"gasRelayPaymasterFactory_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGasRelayTrustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"}],\"name\":\"getVaultProxyForFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vaultProxy_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyManager.PolicyHook\",\"name\":\"_hook\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"}],\"name\":\"policyIsEnabledOnHookForFund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEnabled_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"receiveCallFromComptroller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_configData\",\"type\":\"bytes\"}],\"name\":\"setConfigForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_policy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_settingsData\",\"type\":\"bytes\"}],\"name\":\"updatePolicySettingsForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"enum IPolicyManager.PolicyHook\",\"name\":\"_hook\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_validationData\",\"type\":\"bytes\"}],\"name\":\"validatePolicies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PolicyManager", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000188d356caf78bc6694aee5969fde99a9d612284f000000000000000000000000ed05786ef7b5e5bf909512f0ad46eb8f22cdc4ca", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}